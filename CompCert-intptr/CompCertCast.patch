diff --git a/.gitignore b/.gitignore
index d33143bd..de63216c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -76,12 +76,14 @@
 .DS_Store
 # Test generated data
 /test/clightgen/*.v
+/test_orig/clightgen/*.v
 /test/picosat-965/picogcnf
 /test/picosat-965/picomcs
 /test/picosat-965/picomus
 /test/picosat-965/picosat
 /test/picosat-965/config.h
 /test/picosat-965/makefile
+#/smallexamples
 # Coq caches
 .lia.cache
 .nia.cache
diff --git a/Changelog b/Changelog
deleted file mode 100644
index aa57a554..00000000
--- a/Changelog
+++ /dev/null
@@ -1,1652 +0,0 @@
-Release 3.9, 2021-05-10
-=======================
-
-New features:
-- New port: AArch64 (ARM 64 bits, "Apple silicon") under macOS.
-- Support bitfields of types other than `int`, provided they are no larger
-  than 32 bits (#387)
-- Support `__builtin_unreachable` and `__builtin_expect` (#394)
-  (but these builtins are not used for optimization yet)
-
-Optimizations:
-- Improved branch tunneling: optimized conditional branches can
-  introduce further opportunities for tunneling, which are now taken
-  into account.
-
-Usability:
-- Pragmas within functions are now ignored (with a warning) instead of
-  being lifted just before the function like in earlier versions.
-- configure script: add `-mandir` option (#382)
-
-Compiler internals:
-- Finer control of variable initialization in sections.  Now we can
-  put variables initialized with symbol addresses that need relocation
-  in specific sections (e.g. `const_data` on macOS).
-- Support re-normalization of function parameters at function entry,
-  as required by the AArch64/ELF ABI.
-- PowerPC 64 bits: remove `Pfcfi`, `Pfcfiu`, `Pfctiu` pseudo-instructions,
-  expanding the corresponding int<->FP conversions during the
-  selection pass instead.
-
-Bug fixing:
-- PowerPC 64 bits: incorrect `ld` and `std` instructions were generated
-  and rejected by the assembler.
-- PowerPC: some variadic functions had the wrong position for their
-  first variadic parameter.
-- RISC-V: fix calling convention in the case of floating-point
-  arguments that are passed in integer registers.
-- AArch64: the default function alignment was incorrect, causing a
-  warning from the LLVM assembler.
-- Pick the correct archiver to build `.a` library archives (#380).
-- x86 32 bits: make sure functions returning structs and unions
-  return the correct pointer in register EAX (#377).
-- PowerPC, ARM, AArch64: updated the registers destroyed by asm
-  pseudo-instructions and built-in functions.
-- Remove spurious error on initialization of a local struct
-  containing a flexible array member.
-- Fixed bug in emulation of assignment to a volatile bit-field (#395).
-
-The clightgen tool:
-- Move the `$` notation for Clight identifiers to scope `clight_scope`
-  and submodule `ClightNotations`, to avoid clashes with Ltac2's use of `$`
-  (#392).
-
-Coq development:
-- Compatibility with Coq 8.12.2, 8.13.0, 8.13.1, 8.13.2.
-- Compatibility with Menhir 20210419 and up.
-- Oldest Coq version supported is now 8.9.0.
-- Use the `lia` tactic instead of `omega`.
-- Updated the Flocq library to version 3.4.0.
-
-Licensing and distribution:
-- Dual-licensed source files are now distributed under the LGPL version 2.1
-  (plus the Inria non-commercial license) instead of the GPL version 2
-  (plus the Inria non-commercial license).
-
-
-Release 3.8, 2020-11-16
-=======================
-
-New features:
-- Support `_Static_assert` from ISO C11.
-- Support `__builtin_constant_p` from GCC and Clang.
-- New port: x86 64 bits Windows with the Cygwin 64 environment.
-  (configure with target `x86_64-cygwin`).
-- The following built-in functions are now available for all ports:
-  `__builtin_sqrt`, `__builtin_fabsf`, and all variants of
-  `__builtin_clz` and `__builtin_ctz`.
-- Added `__builtin_fmin` and `__builtin_fmax` for AArch64.
-
-Removed features:
-- The x86 32 bits port is no longer supported under macOS.
-
-Compiler internals:
-- Simpler translation of CompCert C casts used for their effects but
-  not for their values.
-- Known builtins whose results are unused are eliminated earlier.
-- Improved error reporting for `++` and `--` applied to pointers to
-  incomplete types.
-- Improved error reporting for redefinitions and implicit definitions
-  of built-in functions.
-- Added formal semantics for some PowerPC built-ins.
-
-The clightgen tool:
-- New `-canonical-idents` mode, selected by default, to change the way
-  C identifiers are encoded as CompCert idents (positive numbers).
-  In `-canonical-idents` mode, a fixed one-to-one encoding is used
-  so that the same identifier occurring in different compilation units
-  encodes to the same number.
-- The `-short-idents` flag restores the previous encoding where
-  C identifiers are consecutively numbered in order of appearance,
-  causing the same identifier to have different numbers in different
-  compilation units.
-- Removed the automatic translation of annotation builtins to Coq
-  logical assertions, which was never used and possibly confusing.
-
-Coq and OCaml development:
-- Compatibility with Coq 8.12.1, 8.12.0, 8.11.2, 8.11.1.
-- Can use already-installed Flocq and MenhirLib libraries instead of their
-  local copies (options `-use-external-Flocq` and `-use-external-MenhirLib`
-  to the `configure` script).
-- Automatically build to OCaml bytecode on platforms where OCaml
-  native-code compilation is not available.
-- Install the `compcert.config` summary of configuration choices
-  in the same directory as the Coq development.
-- Updated the list of dual-licensed source files.
-
-
-Release 3.7, 2020-03-31
-=======================
-
-ISO C conformance:
-- Functions declared `extern` then implemented `inline` remain `extern`
-- The type of a wide char constant is `wchar_t`, not `int`
-- Support vertical tabs and treat them as whitespace
-- Define the semantics of `free(NULL)`
-
-Bug fixing:
-- Take sign into account for conversions from 32-bit integers to 64-bit pointers
-- PowerPC: more precise determination of small data accesses
-- AArch64: when addressing global variables, check for correct alignment
-- PowerPC, ARM: double rounding error in int64->float32 conversions
-
-ABI conformance:
-- x86, AArch64: re-normalize values of small integer types returned by
-  function calls
-- PowerPC: `float` arguments passed on stack are passed in 64-bit format
-- RISC-V: use the new ELF psABI instead of the old ABI from ISA 2.1
-
-Usability and diagnostics:
-- Unknown builtin functions trigger a specific error message
-- Improved error messages
-
-Coq formalization:
-- Revised modeling of the PowerPC/EREF `isel` instruction
-- Weaker `ec_readonly` condition over external calls
-  (permissions can be dropped on read-only locations)
-
-Coq and OCaml development:
-- Compatibility with Coq version 8.10.1, 8.10.2, 8.11.0
-- Compatibility with OCaml 4.10 and up
-- Compatibility with Menhir 20200123 and up
-- Coq versions prior to 8.8.0 are no longer supported
-- OCaml versions prior to 4.05.0 are no longer supported
-
-
-Release 3.6, 2019-09-17
-=======================
-
-New features and optimizations:
-- New port targeting the AArch64 architecture: ARMv8 in 64-bit mode.
-- New optimization: if-conversion.  Some `if`/`else` statements
-  and `a ? b : c` conditional expressions are compiled to branchless
-  conditional move instructions, when supported by the target processor
-- New optimization flag: `-Obranchless`, to favor the generation of
-  branchless instruction sequences, even if probably slower than branches.
-- Built-in functions can now be given a formal semantics within
-  CompCert, instead of being treated as I/O interactions.
-  Currently, `__builtin_fsqrt` and `__builtin_bswap*` have semantics.
-- Extend constant propagation and CSE optimizations to built-in
-  functions that have known semantics.
-- New "polymorphic" built-in function: `__builtin_sel(a,b,c)`.
-  Similar to `a ? b : c` but `b` and `c` are always evaluated,
-  and a branchless conditional move instruction is produced if possible.
-- x86 64 bits: faster, branchless instruction sequences are produced
-  for conversions between `double` and `unsigned int`.
-- `__builtin_bswap64` is now available for all platforms.
-
-Usability and diagnostics:
-- Improved the DWARF debug information generated in -g mode.
-- Added options -fcommon and -fno-common to control the generation
-  of "common" declarations for uninitialized global.
-- Check for reserved keywords `_Complex` and `_Imaginary`.
-- Reject function declarations with multiple `void` parameters.
-- Define macros `__COMPCERT_MAJOR__`, `__COMPCERT_MINOR__`, and
-  `__COMPCERT_VERSION__` with CompCert's version number. (#284)
-- Prepend `$(DESTDIR)` to the installation target. (#169)
-- Extended inline asm: print register names according to the
-  types of the corresponding arguments (e.g. for x86_64,
-  `%eax` if int and `%rax` if long).
-
-Bug fixing:
-- Introduce distinct scopes for iteration and selection statements,
-  as required by ISO C99.
-- Handle dependencies in sequences of declarations
-  (e.g. `int * x, sz = sizeof(x);`).  (#267)
-- Corrected the check for overflow in integer literals.
-- On x86, __builtin_fma was producing wrong code in some cases.
-- `float` arguments to `__builtin_annot` and `__builtin_ais_annot`
-  were uselessly promoted to type `double`.
-
-Coq formalization and development:
-- Improved C parser based on Menhir version 20190626:
-  fewer run-time checks, faster validation, no axioms. (#276)
-- Compatibility with Coq versions 8.9.1 and 8.10.0.
-- Compatibility with OCaml versions 4.08.0 and 4.08.1.
-- Updated to Flocq version 3.1.
-- Revised the construction of NaN payloads in processor descriptions
-  so as to accommodate FMA.
-- Removed some definitions and lemmas from lib/Coqlib.v, using Coq's
-  standard library instead.
-
-The clightgen tool:
-- Fix normalization of Clight `switch` statements. (#285)
-- Add more tracing options: `-dprepro`, `-dall`. (#298)
-- Fix the output of `-dclight`. (#314)
-
-
-Release 3.5, 2019-02-27
-=======================
-
-Bug fixing:
-- Modeling error in PowerPC ISA: how register 0 is interpreted when
-  used as base register for indexed load/stores.  The code generated
-  by CompCert was correct, but was proved correct against the wrong
-  specification.
-- Modeling error in x86 ISA: how flag ZF is set by floating-point
-  comparisons.  Here as well, the code generated by CompCert was
-  correct, but was proved correct against the wrong specification.
-- Revised handling of attributes so that they behave more like in
-  GCC and Clang.  CompCert now distinguishes between attributes that
-  attach to names (variables, fields, typedefs, structs and unions)
-  and attributes that attach to objects (variables).  In particular,
-  the `aligned(N)` attribute now attaches to names, while the `_Alignas(N)`
-   modifier still attaches to objects.  This fixes issue 256.
-- Issue with NULL as argument to a variadic function on 64-bit platforms
-  (issue 265)
-- Macro __bool_true_false_are_defined was missing from <stdbool.h> (issue 266)
-
-Coq development:
-- Can now be entirely rechecked using coqchk
-  (contributed by Vincent Laporte)
-- Support Coq version 8.9.0
-- Avoid using "refine mode" when defining Instance
-  (contributed by Maxime Dénès)
-- Do not support Menhir versions more recent than 20181113, because
-  they will introduce an incompatibility with this CompCert release.
-
-New feature:
-- PowerPC port: add __builtin_isel (conditional move) at types int64, uint64,
-  and _Bool.
-
-
-Release 3.4, 2018-09-17
-=======================
-
-Bug fixing:
-- Redefinition of a typedef in a different scope was wrongly rejected.
-- Attach `_Alignas(N)` and `__attribute((aligned(N)))` to names
-  instead of types, so that `_Alignas(16) int * p` means
-  "16-aligned pointer to int", not "pointer to 16-aligned int".
-- For packed structs, fix a discrepancy between the size and alignment
-  computed during elaboration and those computed by the verified front-end
-  after expansion.
-- Honor qualified array types in function parameters: if a parameter is
-  declared as e.g. `int t[const 4]`, it is now treated as `int * const t`
-  in the function body, not `int * t` like before.
-- Reject `__builtin_offsetof(struct s, f)` if `f` is a bit-field.
-- Wrong parsing of attributes having multiple arguments such as
-  `__attribute((packed(A,B,C)))`.
-- If `__builtin_ais_annot` is followed immediately by a label (e.g. a
-  loop head), add a nop instruction to separate the annotation from
-  the label.
-- Wrong parsing of the command-line options `-u <symbol>` and `-iquote`.
-- PowerPC in hybrid 32/64 bit mode: reject %Q and %R register specifications
-  in inline assembly code, since 64-bit integer arguments are not split
-  in two registers.
-- x86 64-bit mode: wrong expansion of __builtin_clzl and builtin_ctzl
-  (issue #127).
-
-New checks for ISO C conformance:
-- Removed support for `_Alignof(expr)`, which is not C11;
-  only `_Alignof(ty)` is part of C11.
-- Reject occurrences of `_Alignas` in places that are not allowed by C11,
-  e.g. in `typedef`.  `__attribute((aligned(N)))` can be used instead.
-- Reject occurrences of `restrict` in places that are not allowed by
-  C99 and C11.
-- Reject structs composed of a single flexible array `struct { ty []; }`.
-- Check that qualified array types such as `int t[const 4]` occur only
-  as function parameters, but nowhere else.
-- In function definitions, reject function parameters that have no names.
-
-New warnings:
-- Warn for flexible array types `ty[]` in places where they do not make sense.
-- Warn for inline (not static inline) functions that declare
-  non-constant static variables.
-- Optionally warn if the alignment of an object is reduced below its
-  natural alignment because of a _Alignas qualifier or an aligned attribute,
-  or a packed attribute.
-- Warn for tentative static definitions with an incomplete type, e.g.
-  `static int x[];`.
-- The warning about uses of C11 features is now off by default.
-
-Semantic preservation proof:
-- Model the fact that external functions can destroy caller-save registers
-  and Outgoing stack slots; adapt the proofs accordingly.
-
-Coq and OCaml development:
-- Support Coq versions 8.8.1 and 8.8.2.
-- Support OCaml versions 4.7.0 and up.
-- Support Menhir versions 20180530 and up.
-
-Others:
-- Improved error handling in "configure" script (issue #244)
-- clightgen adds configuration information to the generated .v file (issue #226)
-
-
-
-Release 3.3, 2018-05-30
-=======================
-
-New features:
-- Introduced the __builtin_ais_annot built-in function to communicate
-  source-level annotations to AbsInt's a3 tool suite via a special
-  section in object and executable files.
-- Improved C11 support: define the C11 conditional feature macros;
-  define the max_align_t type in stddef.h.
-- PowerPC 64-bit port: new built-in functions for 64-bit load-store with
-  byte reversal and for 64-bit integer multiply high.
-- x86 64 bits: add support for BSD.
-
-Bug fixing:
-- Wrong code generated for unions containing several bit fields.
-- Internal compiler errors for some initializers for structs and
-  unions containing bit-fields, and for anonymous members of unions.
-- Missing error reporting for <integer> - <ptr> subtraction,
-  causing an internal retyping error later during compilation.
-- String literals are l-values.
-- String literals have array types, not pointer types.
-- Array sizes >= 2^32 were handled incorrectly on 64-bit platforms.
-- Wrong code generated for global variables of size 2^31 bytes or more.
-- struct and union arguments to annotation builtins must be passed by
-  reference, regardless of the ABI calling conventions.
-- "e1, e2" has pointer type if "e2" has array type.
-- x86 64 bits: in "symbol + ofs" addressing modes, the offset "ofs"
-  must be limited to [-2^24, 2^24) otherwise linking can fail.
-
-New or improved diagnostics (errors and warnings):
-- Warn for comparison of a pointer to a complete type and a pointer to
-  an incomplete type.
-- More checks on variables declared in "for" loops: not static, not
-  extern, not function types.
-- Reject empty declarations in K&R functions.
-- Reject arrays of incomplete types.
-- Reject duplicate 'case' or 'default' statements within a 'switch'.
-- Reject 'case' and 'default' statements outside a 'switch'.
-- Check that 'typedef' declares a name and doesn't contain '_Noreturn'.
-- Function parameters are in the same scope as function local variables.
-- More comprehensive constant-ness checks for initializers of global
-  or static local variables.
-- Make sure an enum cannot have the same tag as a struct or an union.
-- More checks on where the 'auto' storage class can be used.
-- Accept empty enum declaration after nonempty enum definition.
-- Reject pointers to incomplete types in ptr - ptr subtraction.
-- When defining a function, take attributes (_Noreturn, etc) from
-  earlier declarations of the function into account.
-- Better check for multiple definitions of functions or global variables.
-- Reject illegal initializations of aggregates such as "char c[4] = 42;".
-- Reject designated initializers where a member of a composite type is
-  re-initialized after the composite has been initialized as a whole.
-- Reject casts to struct/union types.
-- Reject sizeof(e) where e designates a bit-field member of a struct or union.
-- "e1, e2" is not a compile-time constant expression even if e1 and e2 are.
-- "main" function must not be "inline"
-- Warn for functions declared extern after having been defined.
-- Warn for function declarations after function definitions when the
-  declaration has more attributes than the definition.
-- Warn for assignment of a volatile struct to a non-volatile struct.
-- Warn for "main" function if declared _Noreturn.
-
-Coq development:
-- Added support for Coq versions 8.7.2 and 8.8.0.
-- Rewrote "Implicit Arguments" and "Require" inside sections,
-  these are obsolete in 8.8.0.
-- Upgraded Flocq to version 2.6.1.
-- Optionally install the .vo files for reuse by other projects
-  (options -install-coqdev and -coqdevdir to configure script;
-   automatically selected if option -clightgen is given).
-
-
-Release 3.2, 2018-01-15
-=======================
-
-Code generation and optimization:
-- Inline static functions that are called only once.
-  Can be turned off by setting the "noinline" attribute on the function.
-- More consistent detection and elimination of divisions by 1.
-- ARM in Thumb mode: simpler instruction sequence for branch through jump table.
-- ARM: support and use the "cmn" instruction.
-- Issue #208: make value analysis of comparisons more conservative for
-  dubious comparisons such as "(uintptr_t) &global == 0x1234" which are
-  undefined behavior in CompCert.
-
-Usability:
-- Resurrected support for the Cygwin x86-32 port, which got lost at release 3.0.
-- Support the "noinline" attribute on C function definitions.
-- PowerPC port with Diab toolchain: support -t <target processor> option
-  and pass it to the Diab tools.
-- Clightgen tool: add -o option to specify output file.
-- Pull request #192: improve the printing of Clight intermediate code
-  so that it looks more like valid C source.  (Frédéric Besson)
-
-Bug fixing:
-- Issue #P25: make sure sizeof(long double) = sizeof(double) in all contexts.
-- Issue #211: wrong scoping for C99 declarations within a "for" statement.
-
-Coq and Caml development:
-- Pull request #191: Support Coq version 8.7.0 and 8.7.1 in addition
-  to Coq 8.6.1.  Coq 8.6 (.0) is no longer supported owing to an
-  incompatibility with 8.7.0.
-  (Sigurd Schneider)
-- ARM code generator: refactoring of constant expansions and EABI fixups.
-- Resynchronized the list of dual-licensed files given in file LICENSE
-  and the copyright headers of the dual-licensed files.
-
-
-Release 3.1, 2017-08-18
-=======================
-
-Major improvements:
-
-- New port targeting the RISC-V architecture, in 32- and 64-bit modes.
-
-- Improved support for PowerPC 64 processors: use 64-bit registers and
-  instructions for 64-bit integer arithmetic.  Pointers remain 32 bits
-  and the 32-bit ABI is still used.
-
-Code generation and optimization:
-
-- Optimize leaf functions in the PowerPC back-end.
-  (Avoid reloading the return address from the stack.)
-- Avoid generating useless conditional branches for empty if/else statements.
-- Earlier elimination of redundant `&*expr` and `*&expr` addressings.
-- Improve utilization of addressing modes for volatile loads and stores.
-
-Usability:
-
-- Add options -finline / -fno-inline to control function inlining.
-- Removed the compilation of '.cm' files written in Cminor concrete syntax.
-- More precise warnings about missing function returns.
-- clightgen: add option "-normalize" to avoid memory loads deep inside
-  expressions.
-
-Bug fixing:
-
-- Issue #179: clightgen produces wrong output for "switch" statements.
-- Issue #196: excessive proof times in .v files produced by clightgen.
-- Do not generate code for functions with "inline" specifier that are
-  neither static nor extern, as per ISO C99.
-- Some line number information was missing for some goto labels and
-  switch cases.
-- Issue #P16: illegal PowerPC asm generated for unsigned division after
-  constant propagation.
-- Issue #P18: ARM addressing overflows caused by 1- underestimation of
-  code size, causing mismanagement of constant pool, and 2- large stack
-  frames where return address and back link are at offsets >= 4Kb.
-- Pass -no-pie flag to the x86 linker when -pie is the default.
-
-Coq and Caml development:
-
-- Support Coq 8.6.1.
-- Improve compatibility with Coq working version.
-- Always generate .merlin and _CoqProject files.
-
-
-Release 3.0.1, 2017-02-14
-=========================
-
-- Ported to Coq 8.6.
-
-
-Release 3.0, 2017-02-10
-=======================
-
-Major improvements:
-
-- Added support for 64-bit target platforms, including pointers that
-  are 64-bit wide, and the ability to use 64-bit integer registers and
-  arithmetic operations.  This support does not replace but comes in
-  addition to CompCert's original support for 32-bit target platforms,
-  with 32-bit pointers and emulation of 64-bit integer arithmetic
-  using pairs of 32-bit integers.  In terms of C data models, CompCert
-  used to be restricted to the ILP32LL64 model; now it also supports
-  I32LP64 and IL32LLP64.
-
-- The x86 port of CompCert was extended to produce x86-64 bit code in
-  addition to the original x86-32 bit (IA32) code.  (This is the first
-  instantiation of the new support for 64-bit targets described
-  above.) Support for x86-64 is currently available for Linux and MacOS X.
-  (Run the configure script with 'x86_64-linux' or 'x86_64-macosx'.)
-  This is an early port: several ABI incompatibilities remain.
-
-Language features:
-
-- Support for anonymous structures and unions as members of
-  structures or unions.  (ISO C11, section 6.7.2.1, para 13 and 19.)
-- New built-in functions for ARM and PowerPC:
-  __builtin_ctz, __builtin_ctzl, __builtin_ctzll
-  (count trailing zeros, 32 and 64 bits).
-
-Usability:
-
-- Added options -Wxxx and -Wno-xxx (for various values of "xxx")
-  to control which warnings are emitted.
-- Added options -Werror=xxx and -Wno-error=xxx (for various values of "xxx")
-  to control which warnings are treated as errors.
-- Support response files where additional command-line arguments can
-  be passed (syntax: @file).
-- Improved wording of warning and error messages.
-- Improved handling of attributes, distinguishing attributes that apply
-  to types from attributes that apply to names.  For example, in
-    __attribute((aligned(8),section("foo"))) int * p;
-  the "aligned" attribute is attached to type "int", while
-  the "section" attribute is attached to name "p".
-
-Code generation:
-
-- Support for ARM target processors in big-endian mode.
-- Optimize 64-bit integer division by constants.
-
-Bug fixing:
-
-- Issue #155: on ARM, assembly errors caused by large jump tables for
-  "switch" statements and overflow in accessing constant pools.
-- Issue #151: large inductive definition causes a fatal error in
-  32-bit versions of Coq.
-- Issue #143: handle "%lf" printf() format in the reference interpreter
-- Issue #138: struct declarations in K&R function parameters were ignored.
-- Issues #110, #111, #113, #114, #115, #119, #120, #121, #122, #123, #124,
-  #125, #126, #127, #128, #129, #130, #133, #138, #144: various cases
-  of internal errors and failed assertions that should have been
-  proper errors instead.
-- For __builtin_memcpy_aligned, size and alignment arguments of 64-bit
-  integer type were causing a fatal error on a 32-bit target.
-- ARM and x86 ports: wrong register allocation for some calls to
-  function pointers. 
-
-
-Release 2.7.1, 2016-07-18
-=========================
-
-- Ported to Coq 8.5pl2.
-
-Bug fixing:
-- Fixed a compile-time assertion failure involving builtins
-  taking a 64-bit integer parameter and given an unsigned 32-bit integer
-  argument.
-- Updates to the Cminor parser.
-
-
-Release 2.7, 2016-06-29
-=======================
-
-Major improvement:
-- The proof of semantic preservation now accounts for separate compilation
-  and linking, following the approach of Kang, Kim, Hur, Dreyer and
-  Vafeiadis, "Lightweight verification of separate compilation", POPL 2016.
-  Namely, the proof considers a set of C compilation units, separately
-  compiled to assembly then linked, and shows that the resulting
-  assembly program preserves the semantics of the C program that would
-  be obtained by syntactic linking of the source C compilation units.
-
-Language features:
-- Parse the _Noreturn function attribute from ISO C11.
-- New standard includes files: <iso646.h> and <stdnoreturn.h> from ISO C11.
-- New built-in functions: __builtin_clzl, __builtin_clzll
-  (count leading zeros, 32 and 64 bits) for ARM, IA32 and PowerPC;
-  __builtin_ctz, __builtin_ctzl, __builtin_ctzll
-  (count trailing zeros, 32 and 64 bits) for IA32.
-
-Formal C semantics:
-- The semantics of conversions from pointer types to _Bool
-  is fully defined (again).
-
-Usability:
-- The generation of DWARF debugging information in "-g" mode is now
-  supported for ARM and IA32 (in addition to PowerPC).
-
-Coq development:
-- Revised the Stacking pass and its proof to make it more extensible
-  later to e.g. 64-bit integer registers.
-- Use register pairs in function calling conventions to control more
-  precisely the splitting of 64-bit integer arguments and results
-  into pairs of 32-bit quantities
-- Revised the way register conventions are described in Machregs
-  and Conventions.
-- Simulation diagrams now live in Prop instead of Type.
-
-OCaml development:
-- Code cleanup to remove warnings, support "safe strings" mode,
-  and be fully compatible with OCaml 4.02 and 4.03.
-- Cminor parser: support for single-precision FP numbers and operators.
-
-Bug fixing:
-- Some declarations within C expressions were incorrectly ignored
-  (e.g. "sizeof(enum e {A})").
-- ARM in Thumb mode: incorrect "movs" instructions involving the stack
-  pointer register were generated.
-
-
-Release 2.6, 2015-12-21
-=======================
-
-Usability:
-- Generation of full DWARF v2 debugging information in "-g" mode,
-  including function-local variables.  This is fully supported
-  for the PowerPC target with GNU tools or Diab tools.  Support
-  for IA32 and ARM is nearly there.
-- Production of detailed explanations for syntax errors during parsing.
-  (Exploiting recent work by F. Pottier on the Menhir parser generator.)
-- PowerPC port: added many new builtin functions.
-
-Code generation and optimization:
-- Support for PowerPC 64-bits (pointers are still 32-bit wide)
-  and Freescale's E5500 variant.
-- More prudent alias analysis for operations over pointers that are
-  formally undefined, such as bit masking.
-- New pass: Debugvar, to associate debug information to local variables.
-
-Coq development:
-- Richer representation of arguments and results to builtin operations.
-- As a consequence, annotation builtins no longer need special handling.
-- Added EF_debug builtins to transport debugging information throughout
-  the compiler back-end.
-- Upgraded the Flocq library to version 2.5.0.
-
-Bug fixing:
-- Issue #71: incorrect initialization of an array of wchar_t
-- Corrected the handling of bit-fields of type _Bool and width > 1
-- Removed copy optimization when returning a struct from a function.
-- Full parsing of unprototyped (K&R-style) function definitions.
-  (Before, the parsing was incomplete and would reject some definitions.)
-
-Miscellaneous:
-- The cchecklink tool (for a posteriori validation of assembly
-  and linking) was removed.  It is replaced by the Valex tool,
-  available from AbsInt.
-- Added a command-line option -conf <config file> to select
-  a different "compcert.ini" configuration file.
-- Removed the command-line options -fstruct-passing=<convention>
-  and -fstruct-return=<convention>, more confusing than useful.
-- Added a command-line option -fstruct-passing that activates
-  ABI-conformant by-value passing of structs and unions as
-  function arguments or results.  If this option is not set,
-  passing a struct/union as function argument is now rejected.
-- The -fstruct-return command-line option is deprecated and
-  becomes a synonymous for -fstruct-passing.
-- The return type of __builtin_clz() is "int", as documented,
-  and not "unsigned int", as previously implemented.
-
-
-Release 2.5, 2015-06-12
-=======================
-
-Language features:
-- Extended inline assembly in the style of GCC.  (See section 6.5
-  of the user's manual.)  The implementation is not as complete
-  as that of GCC or Clang.  In particular, the only constraints
-  supported over operands are "r" (register), "m" (memory), and
-  "i" (integer immediate).
-
-Code generation and optimization:
-- Revised translation of '||' and '&&' to Clight so as to
-  produce well-typed Clight code.
-- More prudent value analysis of uninitialized declarations of
- "const" global variables.
-- Revised handling of "common" global declarations, fixes an issue
-  with uninitialized declarations of "const" global variables.
-
-Improvements in confidence:
-- Formalized the typing rules for CompCert C in Coq and verified
-  a type-checker, which is used to produce the type annotations
-  in CompCert C ASTs, rather than trusting the types produced by
-  the Elab pass.
-- Coq proof of correctness for the Unusedglob pass (elimination
-  of unreferenced static global definitions).  The Coq AST for
-  compilation units now records which globals are static.
-- More careful semantics of comparisons between a non-null pointer
-  and the null pointer.  The comparison is undefined if the non-null
-  pointer is out of bounds.
-
-Usability:
-- Generation of DWARF v2 debugging information in "-g" mode.
-  The information describes C types, global variables, functions,
-  but not yet function-local variables.  This is currently available
-  only for the PowerPC/Diab target.
-- Added command-line options to turn individual optimizations on or off,
-  and a "-O0" option to turn them all off.
-- Revised handling of arguments to __builtin_annot so that no code
-  is generated for an argument that is a global variable or a local
-  variable whose address is taken.
-- In string and character literals, treat illegal escape sequences
-  (e.g. "\%" or "\0") as an error instead of a warning.
-- Warn if floating-point literals overflow or underflow when converted
-  to FP numbers.
-- In "-g -S" mode, annotate the generated .s file with comments
-  containing the C source code.
-- Recognize and accept more of GCC's alternate keywords, e.g. __signed,
-  __volatile__, etc.
-- cchecklink: added option "-files-from" to read .sdump file names
-    from a file or from standard input.
-
-ABI conformance:
-- Improved ABI conformance for passing values of struct or union types
-  as function arguments or results.  Full conformance is achieved on
-  IA32/ELF, IA32/MacOSX, PowerPC/EABI, PowerPC/Linux, and ARM/EABI.
-- Support the "va_arg" macro from <stdarg.h> in the case of arguments
-  of struct or union types.
-
-Coq development:
-- In the CompCert C and Clight ASTs, struct and union types are now
-  represented by name instead of by structure.  A separate environment
-  maps these names to struct/union definitions.  This avoids
-  bad algorithmic complexity of operations over structural types.
-- Introduce symbol environments (type Senv.t) as a restricted view on
-  global environments (type Genv.t).
-- Upgraded the Flocq library to version 2.4.0.
-
-Bug fixing:
-- Issue #4: exponential behaviors with deeply-nested struct types.
-- Issue #6: mismatch on the definition of wchar_t
-- Issue #10: definition of composite type missing from the environment.
-- Issue #13: improved handling of wide string literals
-- Issue #15: variable-argument functions are not eligible for inlining.
-- Issue #19: support empty "switch" statements
-- Issue #20: ABI incompatibility wrt struct passing on IA32.
-- Issue #28: missing type decay in __builtin_memcpy_aligned applied to arrays.
-- Issue #42: emit error if "static" definition follows non-"static" declaration.
-- Issue #44: OSX assembler does not recognize ".global" directive.
-- Protect against redefinition of the __i64_xxx helper library functions.
-- Revised handling of nonstandard attributes in C type compatibility check.
-- Emit an error on "preprocessing numbers" that are invalid numerical literals.
-- Added missing check for static redefinition following a non-static
-  declaration.
-- Added missing check for redefinition of a typedef as an ordinary
-  identifier within the same scope.
-
-Miscellaneous:
-- When preprocessing with gcc or clang, use "-std=c99" mode to force
-  C99 conformance.
-- Use a Makefile instead of ocamlbuild to compile the OCaml code.
-
-
-Release 2.4, 2014-09-17
-=======================
-
-Language features:
-- Support C99 compound literals  (ISO C99 section 6.5.2.5).
-- Support "switch" statements over an argument of type "long long".
-
-Code generation and optimization:
-- Revised and improved support for single-precision floating-point
-  arithmetic.  Earlier, all FP arithmetic was performed at double
-  precision, with conversions to/from single precision as needed,
-  in particular when loading/storing a single-precision FP number
-  from/to memory.  Now, FP operations whose arguments are of type
-  "float" are performed in single-precision, using the processor's
-  single FP instructions.  Fewer conversions between double and
-  single precision are generated.
-- Value analysis and constant propagation: more precise treatment of
-  comparisons against an integer constant.
-
-Improvements in confidence:
-- Full correctness proofs for the algorithms used in the runtime
-  support library for conversions between 64-bit integers and
-  floating-point numbers.
-
-ARM port:
-- Added support for Thumb2 instruction encoding (option -mthumb).
-  Thumb2 is supported on ARMv7 and up, and produces more compact
-  machine code.
-- Exploit some VFPv3 instructions when available.
-- Built-in function '__builtin_cntlz' (count leading zeros)
-  renamed '__builtin_clz' for GCC / Clang compatibility.
-
-PowerPC port:
-- Refactored the expansion of built-in functions and
-  pseudo-instructions so that it does not need to be re-done in
-  cchecklink.
-- Updated the cchecklink validator accordingly.
-- More efficient code generated for volatile accesses to small data areas.
-- Built-in function '__builtin_cntlz' (count leading zeros)
-  renamed '__builtin_clz' for GCC / Clang compatibility.
-
-IA32 port:
-- Added built-in functions __builtin_clz and __builtin_ctz
-  (count leading / trailing zeros).
-
-Coq development:
-- The memory model was extended with two new "chunks", Many32 and Many64,
-  that enable storing any 32-bit value or 64-bit value using
-  an abstract, not bit-based encoding, and reloading these values exactly.
-  These new chunks are used to implement saving and restoring callee-save
-  registers that can contain data of unknown types (e.g. float32 or float64)
-  but known sizes.
-- Refactored the library of FP arithmetic (lib/Floats.v) to support
-  both 64- and 32-bit floats.
-
-
-Release 2.3pl2, 2014-05-15
-==========================
-
-Usability:
-- Re-added support for "__func__" identifier as per ISO C99.
-- Re-added some popular GCC extensions to ISO C99:
-     . alternate keywords __restrict, __inline__, etc, 
-     . support for empty structs and unions
-     . support '\e' escape in char and string literals, meaning ESC
-- Do not assume that the preprocessor removed all comments.
-
-Bug fixing:
-- Fixed regression on initializers of the form  T x[N] = "literal";
-  where T is a typedef for a character type.
-- "asm" statements were causing syntax errors.
-- Better handling of "extern" and "extern inline" function definitions.
-- Internal error on some octal escape sequences in string literals.
-- Parsing of "#pragma section" directives made more robust and
-  with better error reporting.
-
-
-Release 2.3, 2014-05-05
-=======================
-	
-Language features:
-- Support for C99 designated initializers. (ISO C99 section 6.7.8.)
-
-Improvements in confidence:
-- The parser is now formally verified against the ISO C99 grammar plus
-  CompCert's extensions.  The verification proves that the parser
-  recognizes exactly the language specified by the grammar, and that
-  the grammar has no ambiguities.  For more details, see the paper
-  "Validating LR(1) parsers" by Jacques-Henri Jourdan, François Pottier,
-  and Xavier Leroy, ESOP 2012, http://dx.doi.org/10.1007/978-3-642-28869-2_20
-- More theorems proved about float<->integer conversions.
-
-Optimizations:
-- Optimize "x != 0", "x == 0", "x != 1", and "x == 1" when x is known
-  to be a boolean already, ranging over {0, 1, undef}.
-- More systematic constant propagation in pass Selection, lightens
-  the work of later RTL optimisations.
-- IA32: recognize and use the "not" instruction.
-
-Usability:
-- Option "-timings" to print compilation times for various passes.
-- Various tweaks in IRC graph coloring to reduce compilation time.
-- IA32: add built-in functions for fused multiply-add
-  (require a recent processor with FMA3 extensions).
-
-Improvements in ABI conformance:
-- New target platform: ARM with EABI "hard float" calling conventions
-  (armhf in Debian's classification).
-- IA32 and ARM: revised handling of "common" variables to conform with ABI.
-
-Bug fixing:
-- In -fbitfields emulation: "a->f" was not properly rewritten if "a"
-  had "array of structs" type instead of "pointer to struct".
-- Moved analysis of single-precision floats from RTLtyping to Machtyping.
-  (RTLtyping was incorrectly rejecting some functions involving
-  single-precision floats.)  Simplified LTL semantics and Allocation
-  pass accordingly.
-- Assignment to a l-value of "volatile float" type could cause
-  an internal error in RTLtyping/Machtyping.
-- The case __builtin_fabs applied to integers was missing in the
-  C semantics and in C#minor generation.
-- Fixed some type annotations on CompCert C expressions.  These
-  annotations were incorrect but not in a way that impacted code
-  generation.
-
-
-Release 2.2, 2014-02-24
-=======================
-
-Major improvements:
-
-- Two new static analyses are performed on the RTL intermediate form:
-    . Value analysis, tracking constants, some integer range information,
-      and pointer aliasing information.
-    . Neededness analysis, generalizing liveness analysis to individual
-      bits of integer values and to stack memory locations.
-
-- Improved RTL optimizations, exploiting the results of these analyses:
-    . Constant propagation can track constants across memory stores and loads.
-    . Common subexpression elimination exploits nonaliasing information.
-    . Dead code elimination can eliminate useless memory writes and 
-      block copies, as well as integer operations that do not change
-      the needed bits.
-    . Redundant cast elimination is now performed globally (at
-      function level) rather than locally on individual expressions.
-
-- Experimental support for defining and calling variable-argument functions,
-  including support for the <stdarg.h> interface.
-  (Option -fvararg-calls, "on" by default.)
-
-Language features:
-- In "switch" statements, "default" cases can now appear anywhere, not
-  just as the last case.
-- Support for incomplete array as last field of a struct,
-  as specified in ISO C 99.
-- Support for declarations within 'for' loops, as specified in ISO C 99.
-  (E.g. "for (int i = 0; i < 4; i++) ...")
-- Revised semantics and implementation of _Alignas(N) attribute
-  to better match those of GCC and Clang.
-- Better tolerance for functions declared without prototypes
-  (option -funprototyped, "on" by default).
-- On PowerPC, support "far-data" sections
-  (register-relative addressing with 32-bit offsets).
-
-Improvements in ABI conformance:
-- For x86/IA32, align struct fields of types "double" or "long long" to 4
-  instead of 8, as prescribed by the x86 ELF ABI.
-- For PowerPC and ARM, structs and unions returned as function results
-  are now passed in integer registers if their sizes are small enough
-  (<= 8 bytes for PowerPC, <= 4 bytes for ARM).
-
-Usability:
-- Revised parsing of command-line arguments to be closer to GCC and Clang.
-  In particular, "ccomp -c foo.c -o obj/foo.o" now works as expected,
-  instead of ignoring the "-o" option as in earlier CompCert versions.
-- Recognize input files ending in .i and .p as C source files that
-  must not be preprocessed.
-- Warn for uses of the following GCC extensions to ISO C:
-  zero-sized arrays, empty structs/unions, empty initializer braces.
-- Option "-fno-fpu" to prevent the use of FP registers for some
-  integer operations such as block copies.  (Replaces the previous
-  "-fno-sse" option which was x86/IA32-specific, and extends it to
-  PowerPC and ARM.)
-- Option "-drtl" to record the RTL intermediate representation
-  at every stage of optimization.  (Replaces "-dtailcall", "-dinlining",
-  "-dconstprop", and "-dcse".)
-- Add CompCert version number and command-line arguments as comments
-  in the generated assembly files.
-
-Other performance improvements:
-- Recognize __builtin_fabs as a primitive unary operator instead of
-  a built-in function, enabling more optimizations.
-- PowerPC: shorter code generated for "&global_variable + expr".
-
-Improvements in compilation times:
-- More efficient implementation of Kildall's dataflow equation solver,
-  reduces size of worklist and nomber of times a node is visited.
-- Better OCaml GC settings significantly reduce compilation times
-  for very large source functions.
-
-Bug fixing:
-- Fixed incorrect hypothesis on __builtin_write{16,32}_reversed.
-- Fixed syntax error in __attribute__((__packed__)).
-- Emit clean compile-time error for 'switch' over a value of 64-bit
-  integer type (currently not supported).
-- Recognize source files with .i or .p extension as C sources that
-  should not be preprocessed.
-
-Coq development:
-- Removed propositional extensionality axiom (prop_ext).
-- Suppressed the Mfloat64al32 memory_chunk, no longer needed.
-
-
-Release 2.1, 2013-10-28
-=======================
-
-Language semantics:
-- More precise modeling of not-a-numbers (NaNs) in floating-point
-  arithmetic.
-- The CompCert C language is now defined with reference to ISO C99
-  instead of ISO C90 ("ANSI C") as before.  This affects mostly the
-  wording of the reference manual.  However, the parsing of integer
-  constants and character constants was revised to follow the ISO C99
-  standard.
-
-Language features:
-- Support for _Alignas(N) attribute from ISO C 2011.
-- Revised implementation of packed structs, taking advantage of _Alignas.
-- Suppressed the pragma "packed", replaced by a struct-level attribute
-  __packed__(params) or __attribute__(packed(params)).
-- Fixed typing rules for __builtin_annot() to avoid casting arguments
-  of small integer or FP types.
-
-Performance improvements:
-- Optimize integer divisions by positive constants, turning them into
-  multiply-high and shifts.
-- Optimize floating-point divisions by powers of 2, turning them
-  into multiplications.
-- Optimize "x * 2.0" and "2.0 * x" into "x + x".
-- PowerPC: more efficient implementation of division on 64-bit integers.
-
-Bug fixing:
-- Fixed compile-time error when assigning a long long RHS to a bitfield.
-- Avoid double rounding issues in conversion from 64-bit integers
-  to single-precision floats.
-
-Miscellaneous:
-- Minor simplifications in the generic solvers for dataflow analysis.
-- Small improvements in compilation times for the register allocation pass.
-- MacOS X port updated to the latest XCode (version 5.0).
-
-
-Release 2.0, 2013-06-21
-=======================
-
-Major improvements:
-
-- Support for C types "long long" and "unsigned long long", that is,
-  64-bit integers.  Regarding arithmetic operations on 64-bit integers,
-  . simple operations are expanded in-line and proved correct;
-  . more complex operations (division, modulus, conversions to/from floats)
-    call into library functions written in assembly, heavily tested
-    but not yet proved correct.
-
-- The register allocator was completely rewritten to use an "end-to-end"
-  translation validation approach, using a validation algorithm
-  described in the paper "Validating register allocation and spilling"
-  by Silvain Rideau and Xavier Leroy, Compiler Construction 2010,
-  http://dx.doi.org/10.1007/978-3-642-11970-5_13
-  This validation-based approach enables better register allocation, esp:
-  . live-range splitting is implemented
-  . two-address operations are treated more efficiently
-  . no need to reserve processor registers for spilling and reloading.
-  The improvements in quality of generated code is significant for
-  IA32 (because of its paucity of registers) but less so for ARM and PowerPC.
-
-- Preliminary support for debugging information.  The "-g" flag
-  causes DWARF debugging information to be generated for line numbers
-  and stack structure (Call Frame Information).  With a debugger like
-  GDB, this makes it possible to step through the code, put breakpoints
-  by line number, and print stack backtraces.  However, no information
-  is generated yet for C type definitions nor for variables; therefore,
-  it is not possible to print the values of variables.
-
-Improvements in ABI conformance:
-- For IA32 and ARM, function arguments of type "float"
-  (single-precision FP) were incorrectly passed as "double".
-- For PowerPC, fixed alignment of "double" and "long long" arguments
-  passed on stack.
-
-Improvements in code generation:
-- More aggressive common subexpression elimination across some builtin
-  function calls, esp. annotations.
-
-Improvements in compiler usability:
-- Option -fno-taillcalls to turn off tail-call elimination.
-  (Some static analysis tools are confused by this optimization.)
-- Reduced stack usage of the compiler by rewriting some key functions
-  in tail-recursive style.
-- Reduced memory requirements of constant propagation pass by forgetting
-  compile-time approximations of dead variables.
-- More careful elaboration of C struct and union types into CompCert C
-  types, avoiding behaviors exponential in the nesting of structs.
-
-Bug fixing:
-- Fixed parsing of labeled statements inside "switch" constructs,
-  which were causing syntax errors.
-- The "->" operator applied to an array type was causing a type error.
-- Nested conditional expressions "a ? (b ? c : d) : e" were causing
-  a compile-time error if "c", "d" and "e" had different types.
-
-Coq development:
-- Adapted the memory model to the needs of the VST project at Princeton:
-  . Memory block identifiers are now of type "positive" instead of "Z"
-  . Strengthened invariants in the definition of memory injections
-    and the specification of external calls.
-- The LTL intermediate language is now a CFG of basic blocks.
-- Suppressed the LTLin intermediate language, no longer used.
-
-
-Release 1.13, 2013-03-12
-========================
-
-Language semantics:
-- Comparisons involving pointers "one past" the end of a block are
-  now defined.  (They used to be undefined behavior.)
-  (Contributed by Robbert Krebbers).
-
-Language features:
-- Arguments to __builtin_annot() that are compile-time constants
-  are now replaced by their (integer or float) value in the annotation
-  generated in the assembly file.
-
-Improvements in performance:
-- ARM and PowerPC ports: more efficient access to function parameters
-  that are passed on the call stack.
-- ARM port; slightly better code generated for some indirect memory
-  accesses.
-
-Bug fixing:
-- Fixed a bug in the reference interpreter in -all mode causing some
-  reductions to be incorrectly merged.
-- Wrong parsing of hexadecimal floating-point literals 0xMMMMpEEE.
-
-Improvements in usability:
-- Better error and warning messages for declarations of variables
-  of size >= 2^32 bits.
-- Reference interpreter: more efficient exploration of states in -all mode.
-
-Coq development:
-- More efficient implementation of machine integers (module Integers)
-  taking advantage of bitwise operations defined in ZArith in Coq 8.4.
-- Revised handling of return addresses in the Mach language
-  and the Stacking and Asmgen passes.
-- A number of definitions that were opaque for no good reason are now
-  properly transparent.
-
-
-Release 1.12.1, 2013-01-29
-==========================
-
-Ported to Coq 8.4pl1.  Otherwise functionally identical to release 1.12.
-
-
-Release 1.12, 2013-01-11
-========================
-
-Improvements in confidence:
-- Floating-point literals are now parsed and converted to IEEE-754 binary
-  FP numbers using a provably-correct conversion function implemented on
-  top of the Flocq library.
-
-Language semantics:
-- Comparison between function pointers is now correctly defined
-  in the semantics of CompCert C (it was previously undefined behavior,
-  by mistake).
-- Bit-fields of 'enum' type are now treated as either unsigned or signed,
-  whichever is able to represent all values of the enum.
-  (Previously: always signed.)
-- The "&&" and "||" operators are now primitive in CompCert C and are
-  given explicit semantic rules, instead of being expressed in terms
-  of "_ ? _ : _" as in previous CompCert releases.
-- Added a "Ebuiltin" expression form (invocation of built-in function)
-  to CompCert C, and a "Sbuiltin" statement form to Clight.
-  Used it to simplify the encoding of annotations, memcpy, and volatile
-  memory accesses.
-
-Performance improvements:
-- Better code generated for "&&" and "||" operators.
-- More aggressive elimination of conditional branches during constant
-  propagation, taking better advantage of inferred constants.
-
-Language features:
-- By popular demand, "asm" statements for inline assembly are now supported
-  if the flag -finline-asm is set.  Use with extreme caution, as the
-  semantic preservation proof assumes these statements have no effect
-  on the processor state.
-
-Internal simplifications and reorganization:
-- Clight, Csharpminor, Cminor: suppressed the "Econdition" conditional
-  expressions, no longer useful.
-- Clight: a single loop form, the three C loops are derived forms.
-- Clight: volatile memory accesses are materialized as builtin operations.
-- Clight: removed dependencies on CompCert C syntax and semantics.
-- New pass SimplLocals over Clight that replaces local scalar variables
-  whose address is never taken by temporary, nonadressable variables.
-  (This used to be done in Cminorgen.)
-- Csharpminor: simplified semantics.
-- Cminor: suppressed the "Oboolval" and "Onotbool" operators,
-  which can be expressed in terms of "Ocmpu" at no performance costs.
-- All languages: programs are now presented as a list of global definitions
-  (of functions or variables) instead of two lists, one for functions
-  and the other for variables.
-
-Other changes:
-- For compatibility with other C compilers, output files are now generated
-  in the current directory, by default; output file name can be controlled
-  with the -o option, somewhat like with GCC.
-- Reference interpreter: better handling of volatile memory accesses.
-- IA32/MacOS X: now supports referencing global variables defined in shared
-  libraries; old hack for stdio is no longer needed.
-- PowerPC/MacOS X: this port was removed, as recent version of MacOS X
-  no longer support PowerPC.
-
-
-Release 1.11, 2012-07-13
-========================
-
-Improvements in confidence:
-- Floating-point numbers and arithmetic operations, previously axiomatized,
-  are now implemented and proved correct in Coq, using the Flocq library
-  of S. Boldo and G. Melquiond.
-
-Language semantics:
-- In accordance with ISO C standards, the signed division min_int / -1
-  and the signed remainder min_int % -1 (where min_int is the smallest
-  representable signed integer) now have undefined semantics and are
-  treated as "going wrong" behaviors.
-  (Previously, they were defined with results min_int and 0 respectively,
-  but this behavior requires unnatural code to be generated on IA32 and
-  PowerPC.)
-
-Performance improvements:
-- Function inlining is now implemented.  The functions that are inlined
-  are those declared "inline" in the C source, provided they are not
-  recursive.
-- Constant propagation is now able to propagate the initial values of
-  "const" global variables.
-- Added option -ffloat-const-prop to control the propagation of
-  floating-point constants; see user's manual for documentation.
-- Common subexpression elimination can now eliminate memory loads
-  following a memory store at the same location.
-- ARM: make use of the "fcmpzd" and "fmdrr" instructions.
-
-New tool:
-- The "cchecklink" tool performs a posteriori validation of the
-  assembling and linking phases.  It is available for PowerPC-EABI
-  only.  It takes as inputs an ELF-PowerPC executable as produced
-  by the linker, as well as .sdump files (abstract assembly) as
-  produced by "ccomp -sdump", and checks that the executable contains
-  properly-assembled and linked code and data corresponding to those
-  produced by CompCert.
-
-Other changes:
-- Elimination of "static" functions and "static" global variables that
-  are not referenced in the generated code.
-- The memory model was enriched with "max" permissions in addition to
-  "current" permissions, to better reason over "const" blocks and
-  already-deallocated blocks.
-- More efficient implementation of the memory model, resulting
-  in faster interpretation of source files by "ccomp -interp".
-- Added option "-falign-functions" to control alignment of function code.
-
-
-Release 1.10, 2012-03-13
-========================
-
-Improvements in confidence:
-- CompCert C now natively supports volatile types.  Its semantics fully
-  specifies the meaning of volatile memory accesses.  The translation
-  of volatile accesses to built-in function invocations is now proved correct.
-- CompCert C now natively supports assignment between composite types
-  (structs or unions), passing composite types by value as function
-  parameters, and other instances of using composites as r-values, with
-  the exception of returning composites by value from a function.
-  (The latter remains emulated, using the -fstruct-return option.)
-- PowerPC: removed the -fmadd option, not semantically-preserving
-  in the strict sense.
-
-Language features:
-- Support for _Bool type from ISO C99.
-- Support for _Alignof(ty) operator from ISO C 2011
-  and __alignof__(ty), __alignof__(expr) from GCC.
-
-Performance improvements:
-- Improvements in instruction selection, especially for integer casts
-  and their combinations with bitwise operations.
-- Shorter, more efficient code generated for accessing volatile global
-  variables.
-- Better code generated for the && and || operators.
-- More aggressive common subexpression elimination (CSE) of memory loads.
-- Improved register allocation for invocations of built-ins,
-  especially for annotations.
-- In Cminor and down, make safe operators non-strict: they return Vundef
-  instead of getting stuck.  This enables more optimizations.
-- Cast optimization is no longer performed by a separate pass over
-  RTL, but equivalent optimization is done during Cminor generation
-  and during instruction selection.
-
-Other improvements:
-- PowerPC/EABI: uninitialized global variables now go in common (bss) section.
-- PowerPC: work around limited excursion of conditional branch instructions.
-- PowerPC: added __builtin_fnmadd() and __builtin_fnmsub().
-- Reference interpreter: better printing of pointer values and locations.
-- Added command-line options -Wp,<opt> -Wa,<opt> -Wl,<opt> to pass
-  specific options to the preprocessor, assembler, or linker, respectively.
-- More complete Cminor parser and printer (contributed by Andrew Tolmach).
-
-
-Release 1.9.1, 2011-11-28
-=========================
-
-Bug fixes:
-- Initialization of a char array by a short string literal was wrongly rejected
-- Incorrect handling of volatile arrays.
-- IA32 code generator: make sure that min_int / -1 does not cause a
-  machine trap.
-
-Improvements:
-- Added language option -flongdouble to treat "long double" like "double".
-- The reference interpreter (ccomp -interp) now supports 2-argument main
-  functions (int main(int, char **)).
-- Improved but still very experimental emulation of packed structs
-  (-fpacked-structs)
-- Coq->Caml extraction: extract Coq pairs to Caml pairs and Coq
-  characters to Caml "char" type.
-
-
-Release 1.9, 2011-08-22
-=======================
-
-- The reduction semantics of CompCert C was made executable and turned
-  into a reference interpreter for CompCert C, enabling animation of
-  the semantics.  (Thanks to Brian Campbell for suggesting this approach.)
-  Usage is:  ccomp -interp [options] source.c
-  Options include:
-    -trace      to print a detailed trace of reduction steps
-    -random     to randomize execution order
-    -all        to explore all possible execution orders in parallel
-
-- Revised and strengthened the top-level statements of semantic preservation.
-  In particular, we now show:
-  . backward simulation for the whole compiler without assuming
-    a deterministic external world;
-  . if the source program goes wrong after performing some I/O,
-    the compiled code performs at least these I/O before continuing
-    with an arbitrary behavior.
-
-- Fixed two omissions in the semantics of CompCert C
-  (reported by Brian Campbell):
-  . Functions calls through a function pointer had undefined semantics.
-  . Conditional expressions "e1 ? e2 : e3" where e2 and e3 have different
-    types were missing a cast to their common type.
-
-- Support for "read-modify-write" operations over volatiles
-  (such as e++ or --e or e |= 1 where e has volatile type)
-  through a new presimplification (flag -fvolatile-rmw, "on" by default).
-
-- New optimization pass: Redundant Reload Elimination, which fixes up
-  inefficiencies introduced during the Reload pass.  On x86, it increases
-  performance by up to 10%.  On PowerPC and ARM, the effect is negligible.
-
-- Revised handling of annotation statements.  Now they come in two forms:
-    1. __builtin_annot("format", x1, ..., xN)
-       (arbitrarily many arguments; no code generated, even if some
-        of the xi's were spilled; no return value)
-    2. __builtin_annot_intval("format", x1)
-       (one integer argument, reloaded in a register if needed,
-        returned as result).
-
-- Related clean-ups in the handling of external functions and
-  compiler built-ins.  In particular, __builtin_memcpy is now
-  fully specified.
-
-- ARM code generator was ported to the new ABI (EABI in ARM parlance,
-  armel in Debian parlance), using VFD instructions for floating-point.
-  (Successfully tested on a Trimslice platform running Ubuntu 11.04.)
-
-- IA32 code generator:
-    . Added -fno-sse option to prevent generation of SSE instructions
-      for memory copy operations.
-    . More realistic modeling of the ST0 (top-of-FP-stack) register
-      and of floating-point compare and branch.
-
-- PowerPC code generator: more efficient instruction sequences generated
-  for insertion in a bit field and for some comparisons against 0.
-
-
-Release 1.8.2, 2011-05-24
-=========================
-
-- Support for "aligned" and "section" attributes on global variables, e.g.
-    __attribute__((aligned(16))) int x;
-
-- Experimental emulation of packed structs (flag -fpacked-structs).
-
-- Pointer comparisons now treated as unsigned comparisons (previously: signed).
-  This fixes an issue with arrays straddling the 0x8000_0000 boundary.
-  Consequently, the "ofs" part of pointer values "Vptr b ofs" is
-  now treated as unsigned (previously: signed).
-
-- Elimination of unreferenced labels now performed by a separate pass
-  (backend/CleanupLabels.v) and proved correct.
-
-- Stacking pass revised: supports more flexible layout of the stack
-  frame; two-step proof (Stackingproof + Machabstr2concr) merged
-  into one single proof (Stackingproof).
-
-- The requirement that pointers be valid in pointer comparisons
-  was pushed through all intermediate languages of the back-end
-  (previously: requirement present only up to Csharpminor).
-
-- Emulation of assignment between structs and between unions was
-  simplified and made more efficient, thanks to a better implementation
-  of __builtin_memcpy.
-
-- Improvements to the compiler driver:
-    .  -E option now prints preprocessed result to standard output
-       instead of saving it in a .i file
-    .  support for .s (assembly) and .S (assembly to be preprocessed)
-       input files
-
-
-Release 1.8.1, 2011-03-14
-=========================
-
-- Adapted to Coq 8.3pl1.
-
-- Reduced compilation times through several algorithmic improvements
-  (contributed by A. Pilkiewicz).
-
-- In the various semantics, allow float-to-int conversions to fail
-  (if the float argument is outside the range of representable ints).
-
-- Initialization of global C variables made more robust and proved correct.
-
-- ABI conformance improved:
-     . the "char" type is now signed for x86, remains unsigned for PowerPC and ARM
-     . placement of bit-fields now follows SVR4 conventions (affects PowerPC)
-
-- Bug fixes in the C pre-simplifier:
-     . nontermination with some recursive struct types
-     . issues with zero-width bit fields
-     . elimination of struct assignments duplicating some volatile accesses
-
-
-Release 1.8, 2010-09-21
-=======================
-
-- The input language to the proved part of the compiler is no longer
-  Clight but CompCert C: a larger subset of the C language supporting
-  in particular side-effects within expressions.  The transformations
-  that pull side effects out of expressions and materialize implicit
-  casts, formerly performed by untrusted Caml code, are now fully
-  proved in Coq.
-
-- New port targeting Intel/AMD x86 processors.  Generates 32-bit x86 code
-  using SSE2 extensions for floating-point arithmetic.  Works under
-  Linux, MacOS X, and the Cygwin environment for Windows.
-  CompCert's compilation strategy is not a very good match for the
-  x86 architecture, therefore the performance of the generated code
-  is not as good as for the PowerPC port, but still usable.
-  (About 75% of the performance of gcc -O1 for x86, compared with
-   > 90% for PowerPC.)
-
-- More faithful semantics for volatile accesses:
-  . volatile reads and writes from a volatile global variable are treated
-    like input and output system calls (respectively), bypassing
-    the memory model entirely;
-  . volatile reads and writes from other locations are treated like
-    regular loads and stores.
-
-- Introduced __builtin_memcpy() and __builtin_memcpy_words(), use them
-  instead of memcpy() to compile struct and union assignments.
-
-- Introduced __builtin_annotation() to transmit assertions from
-  the source program all the way to the generated assembly code.
-
-- Elimination of some useless casts around "&", "|" and "^" bitwise operators.
-
-- Produce fewer "moves" during RTL generation.  This speeds up the
-  rest of compilation and slightly improves the result of register
-  allocation when register pressure is high.
-
-- Improvements in register allocation:
-  . Implemented a spilling heuristic during register allocation.
-    This heuristic reduces significantly the amount of spill code
-    generated when register pressure is high.
-  . More coalescing between low-pressure and high-pressure variables.
-  . Aggressive coalescing between pairs of spilled variables.
-
-- Fixed some bugs in the emulation of bit fields.
-
-
-Release 1.7.1, 2010-04-13
-=========================
-
-Bug fixes in the new C pre-simplifier:
-- Missing cast on return value for some functions
-- Incorrect simplification of some uses of || and &&
-- Nontermination in the presence of a bit field of size exactly 32 bits.
-- Global initializers for structs containing bit fields.
-- Wrong type in volatile reads from variables of type 'unsigned int'.
-
-Small improvements to the PowerPC port:
-- Added __builtin_trap() built-in function.
-- Support for '#pragma reserve_register' (EABI)
-- Less aggressive alignment of global variables.
-- Generate '.type' and '.size' directives (EABI).
-
-
-Release 1.7, 2010-03-31
-=======================
-
-- New implementation of the C type-checker, simplifier, and translation to
-  Clight.  Compared with the previous CIL-based solution, the new
-  implementation is more modular and supports more optional simplifications.
-
-- More features of the C language are handled by expansion during
-  translation to Clight:
-    . assignment between structs and unions (option -fstruct-assign)
-    . passing structs and union by value (option -fstruct-passing)
-    . bit-fields in structs (option -fbitfields)
-
-- The "volatile" modifier is now honored.  Volatile accesses are represented
-  in Clight by calls to built-in functions, which are preserved throughout
-  the compilation chain, then turned into processor loads and stores
-  at the end.
-
-- Generic support for C built-in functions.  These predefined external
-  functions give access to special instructions of the processor.  See
-  powerpc/CBuiltins.ml for the list of PowerPC built-in functions.
-
-- The memory model now exposes the bit-level in-memory representation
-  of integers and floats.  This strengthens the semantic preservation
-  theorem: we now prove that C code that directly manipulates these
-  bit-level representations (e.g. via a union between floats and integers)
-  is correctly compiled.
-
-- The memory model now supports fine-grained access control to individual
-  bytes of a memory block.  This feature is currently unused in the
-  compiler proofs, but will facilitate connections with separation logics
-  later.
-
-- External functions are now allowed to read and modify memory.
-  The semantic preservation proofs were strengthened accordingly.
-  In particular, this enables the malloc() and free() C library functions
-  to be modeled as external functions in a provably correct manner.
-
-- Minor improvements in the handling of global environments and the
-  construction of the initial memory state.
-
-- Bug fixes in the handling of '#pragma section' and '#pragma set_section'.
-
-- The C test suite was enriched and restructured.
-
-
-Release 1.6, 2010-01-13
-=======================
-
-- Support Clight initializers of the form "int * x = &y;".
-
-- Fixed spurious compile-time error on Clight initializers of the form
-  "const enum E x[2] = { E_1, E_2 };".
-
-- Produce informative error message if a 'return' without argument
-  occurs in a non-void function, or if a 'return' with an argument
-  occurs in a void function.
-
-- Preliminary support for '#pragma section' and '#pragma set_section'.
-
-- Preliminary support for small data areas in PowerPC code generator.
-
-- Back-end: added support for jump tables; used them to compile
-  dense 'switch' statements.
-
-- PowerPC code generator: force conversion to single precision before
-  doing a "store single float" instruction.
-
-
-Release 1.5, 2009-08-28
-=======================
-
-- Support for "goto" in the source language Clight.
-
-- Added small-step semantics for Clight.
-
-- Traces for diverging executions are now uniquely defined;
-  tightened semantic preservation results accordingly.
-
-- Emulated assignments between structures
-  (during the C to Clight initial translation).
-
-- Fixed spurious compile-time error on Clight statements of the form
-  "x = f(...);" where x is a global variable.
-
-- Fixed spurious compile-time error on Clight initializers where
-  the initial value is the result of a floating-point computation
-  (e.g. "double x = 3.14159 / 2;").
-
-- Simplified the interface of the generic dataflow solver.
-
-- Reduced running time and memory requirements for the constant propagation
-  pass.
-
-- Improved the implementation of George and Appel's graph coloring heuristic:
-  runs faster, produces better results.
-
-- Revised the implementation of branch tunneling.
-
-- Improved modularization between processor-dependent and
-  processor-independent parts.
-
-
-Release 1.4.1, 2009-06-05
-=========================
-
-- Adapted to Coq 8.2-1.  No changes in functionality.
-
-Release 1.4, 2009-04-20
-=======================
-
-- Modularized the processor dependencies in the back-end.
-
-- Three target architectures are now supported:
-       PowerPC / MacOS X       (most mature)
-       PowerPC / EABI & Linux  (getting stable)
-       ARM / Linux EABI        (still experimental)
-
-- Added alignment constraints to the memory model.
-
-- Clight: added support for conditional expressions (a ? b : c);
-  removed support for array accesses a[i], now a derived form.
-
-- C front-end: honor "static" modifiers on globals.
-
-- New optimization over RTL: turning calls into tail calls when possible.
-
-- Instruction selection pass: elimination of redundant casts following
-  a memory load of a "small" memory quantity.
-
-- Linearization pass: improved the linearization heuristic.
-
-- Reloading pass: more economical use of temporaries.
-
-- Back-end: removed "alloc heap" instruction; removed pointer validity
-  checks in pointer comparisons.
-
-
-Release 1.3, 2008-08-11
-=======================
-
-- Added "goto" and labeled statements to Cminor.  Extended RTLgen and
-    its proof accordingly.
-
-- Introduced small-step transition semantics for Cminor; used it in
-    proof of RTLgen pass; proved consistency of Cminor big-step semantics
-    w.r.t. transition semantics.
-
-- Revised division of labor between the Allocation pass and the Reload pass.
-    The semantics of LTL and LTLin no longer need to anticipate the passing
-    of arguments through the conventional locations.
-
-- Cleaned up Stacking pass: the positions of the back link and of
-    the return address in the stack frame are no longer hard-wired
-    in the Mach semantics.
-
-- Added operator to convert from float to unsigned int; used it in C front-end
-
-- Added flag -fmadd to control recognition of fused multiply-add and -sub
-
-- Semantics of pointer-pointer comparison in Clight was incomplete:
-    pointers within different blocks can now be compared using == or !=
-
-- Addition integer + pointer is now supported in Clight.
-
-- Improved instruction selection for complex conditions involving || and &&.
-
-- Improved translation of Cminor "switch" statements to RTL decision trees.
-
-- Fixed error in C parser and simplifier related to "for" loops with
-    complex expressions as condition.
-
-- More benchmark programs in test/
-
-
-Release 1.2, 2008-04-03
-=======================
-
-- First public release
diff --git a/Makefile b/Makefile
index 7c129276..13b56442 100644
--- a/Makefile
+++ b/Makefile
@@ -92,7 +92,8 @@ endif
 VLIB=Axioms.v Coqlib.v Intv.v Maps.v Heaps.v Lattice.v Ordered.v \
   Iteration.v Zbits.v Integers.v Archi.v IEEE754_extra.v Floats.v \
   Parmov.v UnionFind.v Wfsimpl.v \
-  Postorder.v FSetAVLplus.v IntvSets.v Decidableplus.v BoolEqual.v
+  Postorder.v FSetAVLplus.v IntvSets.v Decidableplus.v BoolEqual.v \
+  sflib.v CoqlibC.v AxiomsC.v
 
 # General-purpose libraries for the SSA midend (in midend/libSSA)
 
@@ -103,7 +104,8 @@ VLIB2= Maps2.v Utils.v RTLutils.v
 COMMON=Errors.v AST.v Linking.v \
   Events.v Globalenvs.v Memdata.v Memtype.v Memory.v \
   Values.v Smallstep.v Behaviors.v Switch.v Determinism.v Unityping.v \
-  Separation.v Builtins0.v Builtins1.v Builtins.v
+  Separation.v Builtins0.v Builtins1.v Builtins.v Simulation.v \
+  IntPtrRel.v ExtCallAxiomRlx.v
 
 # Back-end modules (in backend/, $(ARCH)/)
 
@@ -133,7 +135,9 @@ BACKEND=\
   Debugvar.v Debugvarproof.v \
   Mach.v \
   Bounds.v Stacklayout.v Stacking.v Stackingproof.v \
-  Asm.v Asmgen.v Asmgenproof0.v Asmgenproof1.v Asmgenproof.v
+  Asm.v Asmgen.v Asmgenproof0.v Asmgenproof1.v Asmgenproof.v \
+  PointerOp.v CminorD.v CminorSelD.v RTLD.v LTLD.v LinearD.v MachD.v \
+  AsmD.v IntPtrRef.v  Lowerbound.v\
 
 # Middle-end modules (in midend/, $(VLIB2)/, $(ARCH))
 MIDEND=\
@@ -146,14 +150,13 @@ MIDEND=\
   Utilsvalidproof.v SSAvalidproof.v SSAvalidprop.v SSAvalidator_proof.v \
   Dom.v DomCompute.v DomTest.v \
   SSAinv.v Dsd.v \
-  Opt.v OptInv.v \
-  GVNopt.v  GVNoptproof.v GVNoptProp.v \
-  ValueDomainSSA.v ValueAOpSSA.v \
-  SCCPopt.v SCCPoptProp.v SCCPoptproof.v \
+  Captureprop.v Capturepropproof.v \
+  Copyprop.v  Copypropproof.v \
   CSSA.v CSSAutils.v CSSAdef.v CSSAgen.v CSSAgenspec.v CSSAgenwf.v CSSAproof.v \
   CSSAval.v CSSAlive.v CSSAninterf.v CSSAliverange.v \
   RTLpar.v RTLpargen.v RTLparproof.v RTLparcleanup.v \
-  RTLdpar.v RTLdparspec.v RTLdparproof.v
+  RTLdpar.v RTLdparspec.v RTLdparproof.v \
+  RTLdfsD.v SSAD.v CSSAD.v RTLparD.v \
 
 # C front-end modules (in cfrontend/)
 
@@ -162,7 +165,8 @@ CFRONTEND=Ctypes.v Cop.v Csyntax.v Csem.v Ctyping.v Cstrategy.v Cexec.v \
   SimplExpr.v SimplExprspec.v SimplExprproof.v \
   Clight.v ClightBigstep.v SimplLocals.v SimplLocalsproof.v \
   Cshmgen.v Cshmgenproof.v \
-  Csharpminor.v Cminorgen.v Cminorgenproof.v
+  Csharpminor.v Cminorgen.v Cminorgenproof.v \
+  ClightD.v CsharpminorD.v
 
 # Parser
 
@@ -365,6 +369,7 @@ clean:
 	$(MAKE) -f Makefile.extr clean
 	$(MAKE) -C runtime clean
 	$(MAKE) -C test clean
+	$(MAKE) -C test_orig clean
 
 distclean:
 	$(MAKE) clean
diff --git a/README.md b/README.md
index 599474c4..fc77f5c4 100644
--- a/README.md
+++ b/README.md
@@ -30,6 +30,11 @@ The following people contibuted to this extension (alphabetic order):
 Sandrine Blazy, Delphine Demange, Yon Fernandez de Retana, David
 Pichardie, Léo Stefanesco.
 
+## CompCertCast
+
+This development is a version that supports CompCert integer-pointer casting. 
+For detailed explanations, please refer to the README in the parent directory and the paper.
+
 ## License
 CompCert is not free software.  This non-commercial release can only
 be used for evaluation, research, educational and personal purposes.
@@ -44,7 +49,9 @@ Recherche en Informatique et en Automatique (INRIA) and
 AbsInt Angewandte Informatik GmbH.
 
 The additions related to the SSA middle-end are Copyright Univ Rennes,
-Inria, IRISA.
+Inria, IRISA. (except for the parts we modified including Copy propagation and Cast propagation)
+
+Our changes to CompCert and CompCertSSA are Copyright Seoul National University.
 
 ## Contact
 General discussions on CompCert take place on the
@@ -56,3 +63,6 @@ info@absint.com
 
 For inquiries on the SSA-specific additions, please contact Delphine
 Demange.
+
+For inquiries on the integer-pointer-casting-specific additions, please 
+contact Yonghyun Kim.
diff --git a/backend/Allocation.v b/backend/Allocation.v
index 08e0a4f4..4948febd 100644
--- a/backend/Allocation.v
+++ b/backend/Allocation.v
@@ -420,8 +420,8 @@ Module OrderedEquation <: OrderedType.
     destruct H0. right; split; auto.
     intuition.
     left; eapply OrderedLoc.lt_trans; eauto.
-    left; congruence.
-    left; congruence.
+    (* left; congruence. *)
+    (* left; congruence. *)
     right; split. congruence. eapply OrderedEqKind.lt_trans; eauto.
   Qed.
   Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.
@@ -430,6 +430,7 @@ Module OrderedEquation <: OrderedType.
     eelim Plt_strict; eauto.
     eelim OrderedLoc.lt_not_eq; eauto. red; auto.
     eelim OrderedEqKind.lt_not_eq; eauto. red; auto.
+    Unshelve. eapply xH.
   Qed.
   Definition compare : forall x y : t, Compare lt eq x y.
   Proof.
@@ -481,9 +482,9 @@ Module OrderedEquation' <: OrderedType.
     destruct H0. auto.
     destruct H0. right; split; auto.
     intuition.
-    left; eapply Plt_trans; eauto.
-    left; congruence.
-    left; congruence.
+    (* left; eapply Plt_trans; eauto. *)
+    (* left; congruence. *)
+    (* left; congruence. *)
     right; split. congruence. eapply OrderedEqKind.lt_trans; eauto.
   Qed.
   Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.
@@ -491,7 +492,7 @@ Module OrderedEquation' <: OrderedType.
     unfold lt, eq; intros; red; intros. subst y. intuition.
     eelim OrderedLoc.lt_not_eq; eauto. red; auto.
     eelim Plt_strict; eauto.
-    eelim OrderedEqKind.lt_not_eq; eauto. red; auto.
+    (* eelim OrderedEqKind.lt_not_eq; eauto. red; auto. *)
   Qed.
   Definition compare : forall x y : t, Compare lt eq x y.
   Proof.
diff --git a/backend/Allocproof.v b/backend/Allocproof.v
index 3fdbacbe..83043f78 100644
--- a/backend/Allocproof.v
+++ b/backend/Allocproof.v
@@ -21,6 +21,8 @@ Require Import Values Memory Globalenvs Events Smallstep.
 Require Archi.
 Require Import Op Registers RTL Locations Conventions RTLtyping LTL.
 Require Import Allocation.
+Require Import Simulation RTLD LTLD PointerOp Classical.
+From Paco Require Import paco.
 
 Definition match_prog (p: RTL.program) (tp: LTL.program) :=
   match_program (fun _ f tf => transf_fundef f = OK tf) eq p tp.
@@ -1487,13 +1489,14 @@ Proof.
 Qed.
 
 Lemma find_function_tailcall:
-  forall tge ros ls1 ls2,
+  forall tge ros ls1 ls2 m,
   ros_compatible_tailcall ros = true ->
-  find_function tge ros (return_regs ls1 ls2) = find_function tge ros ls2.
+  find_function tge (LTL.ros_to_vos m ros (return_regs ls1 ls2)) (return_regs ls1 ls2) = find_function tge (LTL.ros_to_vos m ros ls2) ls2.
 Proof.
   unfold ros_compatible_tailcall, find_function; intros.
   destruct ros as [r|id]; auto.
-  unfold return_regs. destruct (is_callee_save r). discriminate. auto.
+  unfold return_regs. destruct (is_callee_save r) eqn:A. discriminate.
+  ss. rewrite A. auto.
 Qed.
 
 Lemma loadv_int64_split:
@@ -1619,7 +1622,7 @@ Proof.
 Qed.
 
 Lemma add_equations_builtin_eval:
-  forall ef env args args' e1 e2 m1 m1' rs ls (ge: RTL.genv) sp vargs t vres m2,
+  forall ef env args args' e1 e2 m1 m1' rs ls (ge: RTL.genv) sp vargs t vres m2 (INTERN: ~ is_external_ef ef),
   wt_regset env rs ->
   match ef with
   | EF_debug _ _ _ => add_equations_debug_args env args args' e1
@@ -1789,6 +1792,9 @@ Hypothesis TRANSF: match_prog prog tprog.
 Let ge := Genv.globalenv prog.
 Let tge := Genv.globalenv tprog.
 
+Let sem := RTL.semantics prog.
+Let tsem := LTL.semantics tprog.
+
 Lemma symbols_preserved:
   forall (s: ident), Genv.find_symbol tge s = Genv.find_symbol ge s.
 Proof (Genv.find_symbol_match TRANSF).
@@ -1797,6 +1803,9 @@ Lemma senv_preserved:
   Senv.equiv ge tge.
 Proof (Genv.senv_match TRANSF).
 
+Lemma same_public: prog_public prog = prog_public tprog.
+Proof. inv TRANSF. des; eauto. Qed.
+
 Lemma functions_translated:
   forall (v: val) (f: RTL.fundef),
   Genv.find_funct ge v = Some f ->
@@ -1822,21 +1831,25 @@ Proof.
 Qed.
 
 Lemma find_function_translated:
-  forall ros rs fd ros' e e' ls,
-  RTL.find_function ge ros rs = Some fd ->
+  forall ros rs fd ros' e e' ls m m' (MEM: Mem.extends m m'),
+  RTL.find_function ge (RTL.ros_to_vos m ros rs) rs = Some fd ->
   add_equation_ros ros ros' e = Some e' ->
   satisf rs ls e' ->
   exists tfd,
-  LTL.find_function tge ros' ls = Some tfd /\ transf_fundef fd = OK tfd.
+  LTL.find_function tge (LTL.ros_to_vos m' ros' ls) ls = Some tfd /\ transf_fundef fd = OK tfd.
 Proof.
   unfold RTL.find_function, LTL.find_function; intros.
   destruct ros as [r|id]; destruct ros' as [r'|id']; simpl in H0; MonadInv.
   (* two regs *)
   exploit add_equation_lessdef; eauto. intros LD. inv LD.
-  eapply functions_translated; eauto.
-  rewrite <- H2 in H. simpl in H. congruence.
+  2:{ ss. rewrite <- H2 in *. ss. }
+  ss. destruct (rs#r) eqn:RSV; try by ss.
+  { rewrite <- H3. des_ifs_safe. erewrite Mem.denormalize_extends; eauto.
+    eapply functions_translated; eauto. }
+  { rewrite <- H3. eapply functions_translated; eauto. }
   (* two symbols *)
-  rewrite symbols_preserved. rewrite Heqo.
+  simpl in *.
+  rewrite symbols_preserved. des_ifs. (* rewrite Heqo. *)
   eapply function_ptr_translated; eauto.
 Qed.
 
@@ -1847,7 +1860,7 @@ Lemma exec_moves:
   satisf rs ls e' ->
   wt_regset env rs ->
   exists ls',
-    star step tge (Block s f sp (expand_moves mv bb) ls m)
+    DStar tsem (Block s f sp (expand_moves mv bb) ls m)
                E0 (Block s f sp bb ls' m)
   /\ satisf rs ls' e.
 Proof.
@@ -1863,29 +1876,29 @@ Opaque destroyed_by_op.
 * (* reg-reg *)
   exploit IHmv; eauto. eapply subst_loc_undef_satisf; eauto.
   intros [ls' [A B]]. exists ls'; split; auto. eapply star_left; eauto.
-  econstructor. simpl. eauto. auto. auto.
+  DStep_tac. econstructor. rewrite eval_operation_no_ptr_op; eauto. simpl. eauto. auto. auto.
 * (* reg->stack *)
   exploit IHmv; eauto. eapply subst_loc_undef_satisf; eauto.
   intros [ls' [A B]]. exists ls'; split; auto. eapply star_left; eauto.
-  econstructor. simpl. eauto. auto.
+  DStep_tac. econstructor. simpl. eauto. auto.
 * (* stack->reg *)
   simpl in Heqb. exploit IHmv; eauto. eapply subst_loc_undef_satisf; eauto.
   intros [ls' [A B]]. exists ls'; split; auto. eapply star_left; eauto.
-  econstructor. auto. auto.
+  DStep_tac. econstructor. auto. auto.
 * (* stack->stack *)
   inv H0. simpl in H6. contradiction.
 + (* makelong *)
   exploit IHmv; eauto. eapply subst_loc_pair_satisf_makelong; eauto.
   intros [ls' [A B]]. exists ls'; split; auto. eapply star_left; eauto.
-  econstructor. simpl; eauto. reflexivity. traceEq.
+  DStep_tac. econstructor. rewrite eval_operation_no_ptr_op; eauto. simpl; eauto. reflexivity. traceEq.
 + (* lowlong *)
   exploit IHmv; eauto. eapply subst_loc_part_satisf_lowlong; eauto.
   intros [ls' [A B]]. exists ls'; split; auto. eapply star_left; eauto.
-  econstructor. simpl; eauto. reflexivity. traceEq.
+  DStep_tac. econstructor. rewrite eval_operation_no_ptr_op; eauto. simpl; eauto. reflexivity. traceEq.
 + (* highlong *)
   exploit IHmv; eauto. eapply subst_loc_part_satisf_highlong; eauto.
   intros [ls' [A B]]. exists ls'; split; auto. eapply star_left; eauto.
-  econstructor. simpl; eauto. reflexivity. traceEq.
+  DStep_tac. econstructor. rewrite eval_operation_no_ptr_op; eauto. simpl; eauto. reflexivity. traceEq.
 Qed.
 
 (** The simulation relation *)
@@ -1908,7 +1921,7 @@ Inductive match_stackframes: list RTL.stackframe -> list LTL.stackframe -> signa
            Val.has_type v (env res) ->
            agree_callee_save ls ls1 ->
            exists ls2,
-           star LTL.step tge (Block ts tf sp bb ls1 m)
+           DStar tsem (Block ts tf sp bb ls1 m)
                           E0 (State ts tf sp pc ls2 m)
            /\ satisf (rs#res <- v) ls2 e),
       match_stackframes
@@ -1988,40 +2001,41 @@ Qed.
     "plus" kind. *)
 
 Lemma step_simulation:
-  forall S1 t S2, RTL.step ge S1 t S2 -> wt_state S1 ->
+  forall S1 t S2, IStep sem S1 t S2 -> wt_state S1 ->
   forall S1', match_states S1 S1' ->
-  exists S2', plus LTL.step tge S1' t S2' /\ match_states S2 S2'.
+  exists S2', DPlus tsem S1' t S2' /\ match_states S2 S2'.
 Proof.
+  destruct 1. generalize dependent S2. rename H into INT.
   induction 1; intros WT S1' MS; inv MS; try UseShape.
 
 (* nop *)
 - exploit exec_moves; eauto. intros [ls1 [X Y]].
   econstructor; split.
-  eapply plus_left. econstructor; eauto.
-  eapply star_right. eexact X. econstructor; eauto.
+  eapply plus_left. DStep_tac. econstructor; eauto.
+  eapply star_right. eexact X. DStep_tac. econstructor; eauto.
   eauto. traceEq.
   exploit satisf_successors; eauto. simpl; eauto. intros [enext [U V]].
   econstructor; eauto.
 
 (* op move *)
-- generalize (wt_exec_Iop _ _ _ _ _ _ _ _ _ _ _ WTI H0 WTRS). intros WTRS'.
+- generalize (wt_exec_Iop_wrapper _ _ _ _ _ _ _ _ _ _ _ WTI H0 WTRS). intros WTRS'.
   simpl in H0. inv H0.
   exploit (exec_moves mv); eauto. intros [ls1 [X Y]].
   econstructor; split.
-  eapply plus_left. econstructor; eauto.
-  eapply star_right. eexact X. econstructor; eauto.
+  eapply plus_left. DStep_tac. econstructor; eauto.
+  eapply star_right. eexact X. DStep_tac. econstructor; eauto.
   eauto. traceEq.
   exploit satisf_successors; eauto. simpl; eauto. eapply subst_reg_satisf; eauto.
   intros [enext [U V]].
   econstructor; eauto.
 
 (* op makelong *)
-- generalize (wt_exec_Iop _ _ _ _ _ _ _ _ _ _ _ WTI H0 WTRS). intros WTRS'.
+- generalize (wt_exec_Iop_wrapper _ _ _ _ _ _ _ _ _ _ _ WTI H0 WTRS). intros WTRS'.
   simpl in H0. inv H0.
   exploit (exec_moves mv); eauto. intros [ls1 [X Y]].
   econstructor; split.
-  eapply plus_left. econstructor; eauto.
-  eapply star_right. eexact X. econstructor; eauto.
+  eapply plus_left. DStep_tac. econstructor; eauto.
+  eapply star_right. eexact X. DStep_tac. econstructor; eauto.
   eauto. traceEq.
   exploit satisf_successors; eauto. simpl; eauto.
   eapply subst_reg_kind_satisf_makelong. eauto. eauto.
@@ -2029,12 +2043,12 @@ Proof.
   econstructor; eauto.
 
 (* op lowlong *)
-- generalize (wt_exec_Iop _ _ _ _ _ _ _ _ _ _ _ WTI H0 WTRS). intros WTRS'.
+- generalize (wt_exec_Iop_wrapper _ _ _ _ _ _ _ _ _ _ _ WTI H0 WTRS). intros WTRS'.
   simpl in H0. inv H0.
   exploit (exec_moves mv); eauto. intros [ls1 [X Y]].
   econstructor; split.
-  eapply plus_left. econstructor; eauto.
-  eapply star_right. eexact X. econstructor; eauto.
+  eapply plus_left. DStep_tac. econstructor; eauto.
+  eapply star_right. eexact X. DStep_tac. econstructor; eauto.
   eauto. traceEq.
   exploit satisf_successors; eauto. simpl; eauto.
   eapply subst_reg_kind_satisf_lowlong. eauto. eauto.
@@ -2042,12 +2056,12 @@ Proof.
   econstructor; eauto.
 
 (* op highlong *)
-- generalize (wt_exec_Iop _ _ _ _ _ _ _ _ _ _ _ WTI H0 WTRS). intros WTRS'.
+- generalize (wt_exec_Iop_wrapper _ _ _ _ _ _ _ _ _ _ _ WTI H0 WTRS). intros WTRS'.
   simpl in H0. inv H0.
   exploit (exec_moves mv); eauto. intros [ls1 [X Y]].
   econstructor; split.
-  eapply plus_left. econstructor; eauto.
-  eapply star_right. eexact X. econstructor; eauto.
+  eapply plus_left. DStep_tac. econstructor; eauto.
+  eapply star_right. eexact X. DStep_tac. econstructor; eauto.
   eauto. traceEq.
   exploit satisf_successors; eauto. simpl; eauto.
   eapply subst_reg_kind_satisf_highlong. eauto. eauto.
@@ -2055,17 +2069,17 @@ Proof.
   econstructor; eauto.
 
 (* op regular *)
-- generalize (wt_exec_Iop _ _ _ _ _ _ _ _ _ _ _ WTI H0 WTRS). intros WTRS'.
+- generalize (wt_exec_Iop_wrapper _ _ _ _ _ _ _ _ _ _ _ WTI H0 WTRS). intros WTRS'.
   exploit (exec_moves mv1); eauto. intros [ls1 [A1 B1]].
   exploit transfer_use_def_satisf; eauto. intros [X Y].
-  exploit eval_operation_lessdef; eauto. intros [v' [F G]].
+  exploit eval_operation_wrapper_lessdef; eauto. intros [v' [F G]].
   exploit (exec_moves mv2); eauto. intros [ls2 [A2 B2]].
   econstructor; split.
-  eapply plus_left. econstructor; eauto.
+  eapply plus_left. DStep_tac. econstructor; eauto.
   eapply star_trans. eexact A1.
-  eapply star_left. econstructor. instantiate (1 := v'). rewrite <- F.
-  apply eval_operation_preserved. exact symbols_preserved.
-  eauto. eapply star_right. eexact A2. constructor.
+  eapply star_left. DStep_tac. econstructor. instantiate (1 := v'). rewrite <- F.
+  apply eval_operation_wrapper_preserved. exact symbols_preserved.
+  eauto. eapply star_right. eexact A2. DStep_tac. constructor.
   eauto. eauto. eauto. traceEq.
   exploit satisf_successors; eauto. simpl; eauto. intros [enext [U V]].
   econstructor; eauto.
@@ -2073,14 +2087,14 @@ Proof.
 (* op dead *)
 - exploit exec_moves; eauto. intros [ls1 [X Y]].
   econstructor; split.
-  eapply plus_left. econstructor; eauto.
-  eapply star_right. eexact X. econstructor; eauto.
+  eapply plus_left. DStep_tac. econstructor; eauto.
+  eapply star_right. eexact X. DStep_tac. econstructor; eauto.
   eauto. traceEq.
   exploit satisf_successors. eauto. eauto. simpl; eauto. eauto.
   eapply reg_unconstrained_satisf; eauto.
   intros [enext [U V]].
   econstructor; eauto.
-  eapply wt_exec_Iop; eauto.
+  eapply wt_exec_Iop_wrapper; eauto.
 
 (* load regular *)
 - generalize (wt_exec_Iload _ _ _ _ _ _ _ _ _ _ _ WTI H1 WTRS). intros WTRS'.
@@ -2090,11 +2104,11 @@ Proof.
   exploit Mem.loadv_extends; eauto. intros [v' [P Q]].
   exploit (exec_moves mv2); eauto. intros [ls2 [A2 B2]].
   econstructor; split.
-  eapply plus_left. econstructor; eauto.
+  eapply plus_left. DStep_tac. econstructor; eauto.
   eapply star_trans. eexact A1.
-  eapply star_left. econstructor. instantiate (1 := a'). rewrite <- F.
+  eapply star_left. DStep_tac. econstructor. instantiate (1 := a'). rewrite <- F.
   apply eval_addressing_preserved. exact symbols_preserved. eauto. eauto.
-  eapply star_right. eexact A2. constructor.
+  eapply star_right. eexact A2. DStep_tac. constructor.
   eauto. eauto. eauto. traceEq.
   exploit satisf_successors; eauto. simpl; eauto. intros [enext [U V]].
   econstructor; eauto.
@@ -2122,7 +2136,7 @@ Proof.
   { replace (rs##args) with ((rs#dst<-v)##args).
     eapply add_equations_lessdef; eauto.
     apply list_map_exten; intros. rewrite Regmap.gso; auto.
-    eapply addressing_not_long; eauto.
+    (* eapply addressing_not_long; eauto. *)
   }
   exploit eval_addressing_lessdef. eexact LD3.
   eapply eval_offset_addressing; eauto; apply Archi.splitlong_ptr32; auto.
@@ -2139,17 +2153,17 @@ Proof.
   }
   exploit (exec_moves mv3); eauto. intros [ls5 [A5 B5]].
   econstructor; split.
-  eapply plus_left. econstructor; eauto.
+  eapply plus_left. DStep_tac. econstructor; eauto.
   eapply star_trans. eexact A1.
-  eapply star_left. econstructor.
+  eapply star_left. DStep_tac. econstructor.
   instantiate (1 := a1'). rewrite <- F1. apply eval_addressing_preserved. exact symbols_preserved.
   eexact LOAD1'. instantiate (1 := ls2); auto.
   eapply star_trans. eexact A3.
-  eapply star_left. econstructor.
+  eapply star_left. DStep_tac. econstructor.
   instantiate (1 := a2'). rewrite <- F2. apply eval_addressing_preserved. exact symbols_preserved.
   eexact LOAD2'. instantiate (1 := ls4); auto.
   eapply star_right. eexact A5.
-  constructor.
+  DStep_tac. constructor.
   eauto. eauto. eauto. eauto. eauto. traceEq.
   exploit satisf_successors; eauto. simpl; eauto. intros [enext [W Z]].
   econstructor; eauto.
@@ -2173,13 +2187,13 @@ Proof.
   }
   exploit (exec_moves mv2); eauto. intros [ls3 [A3 B3]].
   econstructor; split.
-  eapply plus_left. econstructor; eauto.
+  eapply plus_left. DStep_tac. econstructor; eauto.
   eapply star_trans. eexact A1.
-  eapply star_left. econstructor.
+  eapply star_left. DStep_tac. econstructor.
   instantiate (1 := a1'). rewrite <- F1. apply eval_addressing_preserved. exact symbols_preserved.
   eexact LOAD1'. instantiate (1 := ls2); auto.
   eapply star_right. eexact A3.
-  constructor.
+  DStep_tac. constructor.
   eauto. eauto. eauto. traceEq.
   exploit satisf_successors; eauto. simpl; eauto. intros [enext [W Z]].
   econstructor; eauto.
@@ -2206,13 +2220,13 @@ Proof.
   }
   exploit (exec_moves mv2); eauto. intros [ls3 [A3 B3]].
   econstructor; split.
-  eapply plus_left. econstructor; eauto.
+  eapply plus_left. DStep_tac. econstructor; eauto.
   eapply star_trans. eexact A1.
-  eapply star_left. econstructor.
+  eapply star_left. DStep_tac. econstructor.
   instantiate (1 := a1'). rewrite <- F1. apply eval_addressing_preserved. exact symbols_preserved.
   eexact LOAD2'. instantiate (1 := ls2); auto.
   eapply star_right. eexact A3.
-  constructor.
+  DStep_tac. constructor.
   eauto. eauto. eauto. traceEq.
   exploit satisf_successors; eauto. simpl; eauto. intros [enext [W Z]].
   econstructor; eauto.
@@ -2220,8 +2234,8 @@ Proof.
 (* load dead *)
 - exploit exec_moves; eauto. intros [ls1 [X Y]].
   econstructor; split.
-  eapply plus_left. econstructor; eauto.
-  eapply star_right. eexact X. econstructor; eauto.
+  eapply plus_left. DStep_tac. econstructor; eauto.
+  eapply star_right. eexact X. DStep_tac. econstructor; eauto.
   eauto. traceEq.
   exploit satisf_successors. eauto. eauto. simpl; eauto. eauto.
   eapply reg_unconstrained_satisf; eauto.
@@ -2235,11 +2249,11 @@ Proof.
   exploit eval_addressing_lessdef; eauto. intros [a' [F G]].
   exploit Mem.storev_extends; eauto. intros [m'' [P Q]].
   econstructor; split.
-  eapply plus_left. econstructor; eauto.
+  eapply plus_left. DStep_tac. econstructor; eauto.
   eapply star_trans. eexact X.
-  eapply star_two. econstructor. instantiate (1 := a'). rewrite <- F.
+  eapply star_two. DStep_tac. econstructor. instantiate (1 := a'). rewrite <- F.
   apply eval_addressing_preserved. exact symbols_preserved. eauto. eauto.
-  constructor. eauto. eauto. traceEq.
+  DStep_tac. constructor. eauto. eauto. traceEq.
   exploit satisf_successors; eauto. simpl; eauto.
   eapply can_undef_satisf; eauto. eapply add_equations_satisf; eauto. intros [enext [U V]].
   econstructor; eauto.
@@ -2281,14 +2295,14 @@ Proof.
      [eexact EXT1 | eexact STORE2 | apply Val.add_lessdef; [eexact G2|eauto] | eauto]). }
   destruct STOREX as [m2' [STORE2' EXT2]].
   econstructor; split.
-  eapply plus_left. econstructor; eauto.
+  eapply plus_left. DStep_tac. econstructor; eauto.
   eapply star_trans. eexact X.
   eapply star_left.
-  econstructor. eexact F1'. eexact STORE1'. instantiate (1 := ls2). auto.
+  DStep_tac. econstructor. eexact F1'. eexact STORE1'. instantiate (1 := ls2). auto.
   eapply star_trans. eexact U.
   eapply star_two.
-  eapply exec_Lstore with (m' := m2'). eexact F2''. discriminate||exact STORE2'. eauto.
-  constructor. eauto. eauto. eauto. eauto. traceEq.
+  DStep_tac. eapply exec_Lstore with (m' := m2'). eexact F2''. discriminate||exact STORE2'. eauto.
+  DStep_tac. constructor. eauto. eauto. eauto. eauto. traceEq.
   exploit satisf_successors; eauto. simpl; eauto.
   eapply can_undef_satisf. eauto.
   eapply add_equation_satisf. eapply add_equations_satisf; eauto.
@@ -2300,12 +2314,12 @@ Proof.
   set (args' := loc_arguments sg) in *.
   set (res' := loc_result sg) in *.
   exploit (exec_moves mv1); eauto. intros [ls1 [A1 B1]].
-  exploit find_function_translated. eauto. eauto. eapply add_equations_args_satisf; eauto.
+  exploit find_function_translated. eauto. eauto. eauto. eapply add_equations_args_satisf; eauto.
   intros [tfd [E F]].
   assert (SIG: funsig tfd = sg). eapply sig_function_translated; eauto.
   econstructor; split.
-  eapply plus_left. econstructor; eauto.
-  eapply star_right. eexact A1. econstructor; eauto.
+  eapply plus_left. DStep_tac. econstructor; eauto.
+  eapply star_right. eexact A1. DStep_tac. econstructor; eauto.
   eauto. traceEq.
   exploit analyze_successors; eauto. simpl. left; eauto. intros [enext [U V]].
   econstructor; eauto.
@@ -2319,7 +2333,7 @@ Proof.
   apply wt_regset_assign; auto.
   intros [ls2 [A2 B2]].
   exists ls2; split.
-  eapply star_right. eexact A2. constructor. traceEq.
+  eapply star_right. eexact A2. DStep_tac. constructor. traceEq.
   apply satisf_incr with eafter; auto.
   rewrite SIG. eapply add_equations_args_lessdef; eauto.
   inv WTI. rewrite <- H7. apply wt_regset_list; auto.
@@ -2331,12 +2345,12 @@ Proof.
   set (args' := loc_arguments sg) in *.
   exploit Mem.free_parallel_extends; eauto. intros [m'' [P Q]].
   exploit (exec_moves mv); eauto. intros [ls1 [A1 B1]].
-  exploit find_function_translated. eauto. eauto. eapply add_equations_args_satisf; eauto.
+  exploit find_function_translated. eapply MEM. eauto. eauto. eapply add_equations_args_satisf; eauto.
   intros [tfd [E F]].
   assert (SIG: funsig tfd = sg). eapply sig_function_translated; eauto.
   econstructor; split.
-  eapply plus_left. econstructor; eauto.
-  eapply star_right. eexact A1. econstructor; eauto.
+  eapply plus_left. DStep_tac. econstructor; eauto.
+  eapply star_right. eexact A1. DStep_tac. econstructor; eauto.
   rewrite <- E. apply find_function_tailcall; auto.
   replace (fn_stacksize tf) with (RTL.fn_stacksize f); eauto.
   destruct (transf_function_inv _ _ FUN); auto.
@@ -2351,6 +2365,7 @@ Proof.
 
 (* builtin *)
 - exploit (exec_moves mv1); eauto. intros [ls1 [A1 B1]].
+  unfold is_internal in INT. simpl in INT. rewrite H in INT.
   exploit add_equations_builtin_eval; eauto.
   intros (C & vargs' & vres' & m'' & D & E & F & G).
   assert (WTRS': wt_regset env (regmap_setres res vres rs)) by (eapply wt_exec_Ibuiltin; eauto).
@@ -2360,14 +2375,14 @@ Proof.
     eapply can_undef_satisf; eauto. }
   exploit (exec_moves mv2); eauto. intros [ls3 [A3 B3]].
   econstructor; split.
-  eapply plus_left. econstructor; eauto.
+  eapply plus_left. DStep_tac. econstructor; eauto.
   eapply star_trans. eexact A1.
-  eapply star_left. econstructor.
+  eapply star_left. DStep_tac. econstructor.
   eapply eval_builtin_args_preserved with (ge1 := ge); eauto. exact symbols_preserved.
   eapply external_call_symbols_preserved. apply senv_preserved. eauto.
   instantiate (1 := ls2); auto.
   eapply star_right. eexact A3.
-  econstructor.
+  DStep_tac. econstructor.
   reflexivity. reflexivity. reflexivity. traceEq.
   exploit satisf_successors; eauto. simpl; eauto.
   intros [enext [U V]].
@@ -2376,9 +2391,9 @@ Proof.
 (* cond *)
 - exploit (exec_moves mv); eauto. intros [ls1 [A1 B1]].
   econstructor; split.
-  eapply plus_left. econstructor; eauto.
+  eapply plus_left. DStep_tac. econstructor; eauto.
   eapply star_right. eexact A1.
-  econstructor. eapply eval_condition_lessdef; eauto. eapply add_equations_lessdef; eauto.
+  DStep_tac. econstructor. eapply eval_condition_wrapper_lessdef; eauto. eapply add_equations_lessdef; eauto.
   eauto. eauto. eauto. traceEq.
   exploit satisf_successors; eauto.
   instantiate (1 := if b then ifso else ifnot). simpl. destruct b; auto.
@@ -2392,9 +2407,9 @@ Proof.
     rewrite <- H0. eapply add_equation_lessdef with (q := Eq Full arg (R arg')); eauto.
   inv H2.
   econstructor; split.
-  eapply plus_left. econstructor; eauto.
+  eapply plus_left. DStep_tac. econstructor; eauto.
   eapply star_right. eexact A1.
-  econstructor. eauto. eauto. eauto. eauto. traceEq.
+  DStep_tac. econstructor. eauto. eauto. eauto. eauto. traceEq.
   exploit satisf_successors; eauto.
   instantiate (1 := pc'). simpl. eapply list_nth_z_in; eauto.
   eapply can_undef_satisf. eauto. eapply add_equation_satisf; eauto.
@@ -2408,18 +2423,18 @@ Proof.
 + (* without an argument *)
   exploit (exec_moves mv); eauto. intros [ls1 [A1 B1]].
   econstructor; split.
-  eapply plus_left. econstructor; eauto.
+  eapply plus_left. DStep_tac. econstructor; eauto.
   eapply star_right. eexact A1.
-  econstructor. eauto. eauto. traceEq.
+  DStep_tac. econstructor. eauto. eauto. traceEq.
   simpl. econstructor; eauto.
   apply return_regs_agree_callee_save.
   constructor.
 + (* with an argument *)
   exploit (exec_moves mv); eauto. intros [ls1 [A1 B1]].
   econstructor; split.
-  eapply plus_left. econstructor; eauto.
+  eapply plus_left. DStep_tac. econstructor; eauto.
   eapply star_right. eexact A1.
-  econstructor. eauto. eauto. traceEq.
+  DStep_tac. econstructor. eauto. eauto. traceEq.
   simpl. econstructor; eauto. rewrite <- H11.
   replace (Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f)))
                           (return_regs (parent_locset ts) ls1))
@@ -2446,18 +2461,19 @@ Proof.
     exact WTRS.
   intros [ls1 [A B]].
   econstructor; split.
-  eapply plus_left. econstructor; eauto.
-  eapply star_left. econstructor; eauto.
+  eapply plus_left. DStep_tac. econstructor; eauto.
+  eapply star_left. DStep_tac. econstructor; eauto.
   eapply star_right. eexact A.
-  econstructor; eauto.
+  DStep_tac. econstructor; eauto.
   eauto. eauto. traceEq.
   econstructor; eauto.
 
 (* external function *)
-- exploit external_call_mem_extends; eauto. intros [v' [m'' [F [G [J K]]]]].
+- unfold is_internal in INT. simpl in INT.
+  exploit external_call_mem_extends; eauto. intros [v' [m'' [F [G [J K]]]]].
   simpl in FUN; inv FUN.
   econstructor; split.
-  apply plus_one. econstructor; eauto.
+  apply plus_one. DStep_tac. econstructor; eauto.
   eapply external_call_symbols_preserved with (ge1 := ge); eauto. apply senv_preserved.
   econstructor; eauto.
   simpl. destruct (loc_result (ef_sig ef)) eqn:RES; simpl.
@@ -2478,7 +2494,7 @@ Proof.
 - inv STACKS.
   exploit STEPS; eauto. rewrite WTRES0; auto. intros [ls2 [A B]].
   econstructor; split.
-  eapply plus_left. constructor. eexact A. traceEq.
+  eapply plus_left. DStep_tac. constructor. eexact A. traceEq.
   econstructor; eauto.
   apply wt_regset_assign; auto. rewrite WTRES0; auto.
 Qed.
@@ -2526,21 +2542,188 @@ Proof.
 - constructor.
 Qed.
 
+Lemma match_states_xsim st_src0 st_tgt0 gmtgt
+    (WT: wt_state st_src0)
+    (MATCH: match_states st_src0 st_tgt0) :
+  xsim (RTL.semantics prog) (LTL.semantics tprog) gmtgt lt 1%nat st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold.
+  destruct (classic (RTL.is_external ge st_src0)); cycle 1; rename H into EXT.
+  (* internal *)
+  - left. econs. econs.
+    + i. exploit step_simulation; eauto. i. des. esplits;
+      [eapply tr_rel_refl; eapply ev_rel_refl| |].
+      { left. split; eauto. eapply RTL.semantics_receptive_at; auto. }
+      { right. eapply CIH; eauto. ss.
+        eapply subject_reduction; eauto. eapply wt_prog. }
+    + i. exploit final_states_simulation; eauto. i. eapply final_state_determ; eauto.
+  (* external *)
+  - unfold RTL.is_external in EXT. des_ifs.
+    + destruct (classic (exists t st_src1, Step sem (RTL.State stack f sp pc rs m) t st_src1)); cycle 1.
+      { left. econs; auto. econs; ii; [|inv FINALSRC]. exfalso. eapply H; eauto. }
+      des. inv MATCH. try UseShape.
+      exploit (exec_moves mv1); eauto. intros [ls1 [A1 B1]].      
+      left. econs. econs 2.
+      { split; eauto. eapply plus_left. DStep_tac. econs; eauto. eauto. traceEq. }
+      left. pfold.
+      right. econs. i. econs.
+      { inv H; clarify. ii. inv STEPTGT.
+        exploit add_equations_builtin_args_lessdef; eauto.
+        { des_ifs; eauto. }
+        assert (satisf rs ls1 e2).
+        { eapply add_equations_builtin_args_satisf; eauto. des_ifs; eauto. }
+        i. des.       
+        exploit eval_builtin_args_preserved. eapply senv_preserved. eapply H0.
+        i. exploit eval_builtin_args_determ. eapply H2. eapply H15. i. subst.
+        exploit external_call_mem_extends_backward; try eapply H16; eauto. i. des.
+        * unfold regset in *.
+          assert (WTRS': wt_regset env (regmap_setres b vres1 rs)).
+          { eapply wt_exec_Ibuiltin; try eapply CALLSRC. eauto.
+            instantiate (1:= m2). instantiate (1:=tr'). instantiate (1:=m). instantiate (1:=vargs).
+            eapply external_call_symbols_preserved; try eapply CALLSRC.
+            symmetry. eapply senv_preserved. eauto. }
+          set (ls2 := Locmap.setres res' vres0 (undef_regs (destroyed_by_builtin e) ls1)).
+          assert (satisf (regmap_setres b vres1 rs) ls2 e1).
+          { eapply parallel_set_builtin_res_satisf; eauto. eapply can_undef_satisf; eauto. }
+          exploit (exec_moves mv2); eauto. intros [ls3 [A3 B3]].
+          left. esplits; auto.
+          { eapply tr_rel_refl. eapply ev_rel_refl. }
+          left. eapply plus_one. econs; eauto.
+          eapply external_call_symbols_preserved; eauto.
+          symmetry. eapply senv_preserved.
+          left. pfold. left. econs; auto. econs 2.
+          esplits; eauto. eapply plus_right. eapply A3.
+          DStep_tac. econs; eauto. traceEq.
+          right. eapply CIH; eauto.
+          eapply subject_reduction. eapply wt_prog.
+          eapply exec_Ibuiltin; eauto.
+          eapply external_call_symbols_preserved; eauto.
+          symmetry. eapply senv_preserved. ss.
+          exploit satisf_successors; eauto. simpl; eauto.
+          intros [enext [U V]].
+          econstructor; eauto.
+        * exploit UBSRC; eauto.
+          eapply external_call_symbols_preserved; eauto. eapply senv_preserved. clarify.
+        * right. esplits; eauto. eapply star_one.
+          2:{ instantiate (2:=t'). subst. eapply tr_rel_refl. eapply ev_rel_refl. }
+          eapply RTL.exec_Ibuiltin; eauto. eapply external_call_symbols_preserved; eauto.
+          symmetry. eapply senv_preserved. }
+      (* final *)
+      { ii. inv FINALTGT. }
+      (* progress *)
+      { i. right. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+        { inv SAFESRC; ss. }
+        inv SAFESRC; clarify.
+        exploit add_equations_builtin_args_lessdef; eauto.
+        { des_ifs; eauto. }
+        i. des.
+        exploit external_call_mem_extends_backward_progress; eauto. i. des.
+        esplits. econs; eauto.
+        { eapply eval_builtin_args_preserved; try eapply H0.
+          ii. symmetry. destruct senv_preserved. des. ss. }
+        { eapply external_call_symbols_preserved; eauto. eapply senv_preserved. } }
+    (* externl *)
+    + right. econs. i.
+      unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+      { inv SAFESRC. }
+      econs.
+      * ii. inv MATCH; clarify.
+        inv STEPTGT; ss; des; clarify. inv SAFESRC; ss; clarify; try (by (des; clarify)).
+        exploit external_call_mem_extends_backward.
+        2:{ eapply external_call_symbols_preserved.
+            symmetry. eapply senv_preserved. eapply H6. }
+        all: eauto. i; des.
+        { left. exploit RTL.exec_function_external; eauto. i.
+          esplits; eauto.
+          { eapply tr_rel_refl. eapply ev_rel_refl. }
+          { left. eapply plus_one; eauto. }
+          right. eapply CIH; eauto.
+          eapply subject_reduction; eauto. eapply wt_prog.
+          econstructor; eauto.
+          simpl. destruct (loc_result (ef_sig ef)) eqn:RES; simpl.
+          rewrite Locmap.gss; auto.
+          generalize (loc_result_pair (ef_sig ef)); rewrite RES; intros (A & B & C & D & E).
+          assert (WTRES': Val.has_type res Tlong).
+          { rewrite <- B. eapply external_call_well_typed; eauto. }
+          rewrite Locmap.gss. rewrite Locmap.gso by (red; auto). rewrite Locmap.gss.
+          rewrite val_longofwords_eq_1 by auto. auto.
+          red; intros. rewrite (AG l H0).
+          rewrite locmap_get_set_loc_result_callee_save by auto.
+          unfold undef_caller_save_regs. destruct l; simpl in H0.
+          rewrite H0; auto.
+          destruct sl; auto; congruence.
+          eapply external_call_well_typed; eauto. }
+        { exploit UBSRC; eauto. clarify. }
+        { right. esplits; eauto.
+          { eapply star_one. econs; eauto. }
+          subst. eapply tr_rel_refl. eapply ev_rel_refl. }
+      * ii. inv MATCH. inv FINALTGT.
+      * right. inv SAFESRC; ss; clarify; try (by (des; clarify)); inv MATCH; clarify.
+        exploit external_call_mem_extends_backward_progress; eauto. i. des.
+        esplits. ss. clarify. econs; eauto.
+        eapply external_call_symbols_preserved; eauto. eapply senv_preserved.
+Qed.
+
+Lemma non_static_equiv l:
+  Genv.non_static_glob (Genv.globalenv prog) l = Genv.non_static_glob (Genv.globalenv tprog) l.
+Proof.
+  Local Transparent ge tge.
+  induction l; ss.
+  specialize senv_preserved. ss. i. inv H. inv H1. unfold ge, tge, fundef in *.
+  specialize (H a). unfold Senv.public_symbol in H. ss. erewrite H.
+  specialize (H0 a). rewrite <- H0. erewrite IHl; eauto.
+Qed.
+
+Lemma transf_initial_capture S1 S2 S2'
+    (INITSRC: RTL.initial_state prog S1)
+    (INITTGT: LTL.initial_state tprog S2)
+    (MATCH: match_states S1 S2)
+    (CAPTGT: glob_capture tprog S2 S2'):
+  exists S1', RTL.glob_capture prog S1 S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (RTL.concrete_snapshot ge S1') (concrete_snapshot tge S2').
+Proof.
+  specialize senv_preserved. intros SENVEQ.
+  inv CAPTGT. ss. rename m' into m2'.
+  rewrite Genv.globalenv_public in CAPTURE. erewrite <- same_public in CAPTURE; eauto.
+  inv MATCH. inv STACKS.
+  exploit non_static_equiv. instantiate (1:=AST.prog_public prog). intros EQUIV.
+  assert (exists m1', Genv.capture_init_mem m0 (Genv.non_static_glob (Genv.globalenv prog) (AST.prog_public prog)) m1' /\
+                     Mem.extends m1' m2').
+  { clear INITSRC INITTGT H. rewrite <- EQUIV in CAPTURE. clear EQUIV AG WTARGS FUN ARGS. inv CAPTURE.
+    remember (Genv.non_static_glob (Genv.globalenv prog) (prog_public prog)) as l. clear Heql.
+    clear SENVEQ. move m0 after f. move l before f. revert_until f.
+    induction l; ss; i.
+    { inv CAP. esplits; eauto. econs. econs. }
+    inv CAP. exploit Mem.capture_extends_backward; eauto. i. des.
+    exploit IHl; eauto. i. des. inv H. esplits; eauto. econs. econs; eauto. }
+  des. esplits; eauto.
+  - inv INITSRC. econs. eauto. rewrite Genv.globalenv_public. eauto.
+  - econs; eauto. econs; eauto.
+  - ii. unfold RTL.concrete_snapshot, concrete_snapshot in *. inv SENVEQ. des. erewrite H4, H3. des_ifs; ss.
+    eapply Mem.mext_concrete; eauto. eapply Mem.concrete_valid; eauto.
+Qed.
+
+
 Theorem transf_program_correct:
-  forward_simulation (RTL.semantics prog) (LTL.semantics tprog).
-Proof.
-  set (ms := fun s s' => wt_state s /\ match_states s s').
-  eapply forward_simulation_plus with (match_states := ms).
-- apply senv_preserved.
-- intros. exploit initial_states_simulation; eauto. intros [st2 [A B]].
-  exists st2; split; auto. split; auto.
-  apply wt_initial_state with (p := prog); auto. exact wt_prog.
-- intros. destruct H. eapply final_states_simulation; eauto.
-- intros. destruct H0.
-  exploit step_simulation; eauto. intros [s2' [A B]].
-  exists s2'; split. exact A. split.
-  eapply subject_reduction; eauto. eexact wt_prog. eexact H.
-  auto.
+  mixed_simulation (RTL.semantics prog) (LTL.semantics tprog).
+Proof.
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (1 + a)%nat. lia.
+  - econs. i. exploit initial_states_simulation; eauto. i. des.
+    exists st2. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. inversion INITSRC; subst. inversion H0; subst.
+      inv ARGS. inv STACKS.
+      exploit transf_initial_capture; eauto. i. des.
+      exists 1%nat. exists S1'. esplits; eauto.
+      apply match_states_xsim; auto.
+      eapply wt_initial_capture_state; eauto; [eapply wt_prog|econs; eauto].
+  - i. apply senv_preserved.
 Qed.
 
 End PRESERVATION.
diff --git a/backend/Asmgenproof0.v b/backend/Asmgenproof0.v
index 85cee14f..c31e21a5 100644
--- a/backend/Asmgenproof0.v
+++ b/backend/Asmgenproof0.v
@@ -28,6 +28,8 @@ Require Import Mach.
 Require Import Asm.
 Require Import Asmgen.
 Require Import Conventions.
+Require Import sflib CoqlibC Simulation.
+Require Import AsmD.
 
 (** * Processor registers and register states *)
 
@@ -596,11 +598,12 @@ Qed.
 >>
 *)
 
-Definition return_address_offset (f: Mach.function) (c: Mach.code) (ofs: ptrofs) : Prop :=
-  forall tf tc,
-  transf_function f = OK tf ->
-  transl_code f c false = OK tc ->
-  code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc.
+Inductive return_address_offset (f: Mach.function) (c: Mach.code) (ofs: ptrofs) : Prop :=
+| return_address_offset_intro
+    tf tc
+    (TF: transf_function f = OK tf)
+    (TC: transl_code f c false = OK tc)
+    (TL: code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc).
 
 (** We now show that such an offset always exists if the Mach code [c]
   is a suffix of [f.(fn_code)].  This holds because the translation
@@ -617,16 +620,19 @@ Qed.
 
 Section RETADDR_EXISTS.
 
+Variable f: Mach.function.
+Variable tf: Asm.function.
+Hypothesis transf_function_success: transf_function f = OK tf.
+
 Hypothesis transl_instr_tail:
-  forall f i ep k c, transl_instr f i ep k = OK c -> is_tail k c.
+  forall i ep k c, transl_instr f i ep k = OK c -> is_tail k c.
 Hypothesis transf_function_inv:
-  forall f tf, transf_function f = OK tf ->
   exists tc, exists ep, transl_code f (Mach.fn_code f) ep = OK tc /\ is_tail tc (fn_code tf).
 Hypothesis transf_function_len:
-  forall f tf, transf_function f = OK tf -> list_length_z (fn_code tf) <= Ptrofs.max_unsigned.
+  list_length_z (fn_code tf) <= Ptrofs.max_unsigned.
 
 Lemma transl_code_tail:
-  forall f c1 c2, is_tail c1 c2 ->
+  forall c1 c2, is_tail c1 c2 ->
   forall tc2 ep2, transl_code f c2 ep2 = OK tc2 ->
   exists tc1, exists ep1, transl_code f c1 ep1 = OK tc1 /\ is_tail tc1 tc2.
 Proof.
@@ -638,11 +644,10 @@ Proof.
 Qed.
 
 Lemma return_address_exists:
-  forall f sg ros c, is_tail (Mcall sg ros :: c) f.(Mach.fn_code) ->
+  forall sg ros c, is_tail (Mcall sg ros :: c) f.(Mach.fn_code) ->
   exists ra, return_address_offset f c ra.
 Proof.
-  intros. destruct (transf_function f) as [tf|] eqn:TF.
-+ exploit transf_function_inv; eauto. intros (tc1 & ep1 & TR1 & TL1).
+  intros. destruct transf_function_inv as (tc1 & ep1 & TR1 & TL1).
   exploit transl_code_tail; eauto. intros (tc2 & ep2 & TR2 & TL2).
 Opaque transl_instr.
   monadInv TR2.
@@ -651,11 +656,9 @@ Opaque transl_instr.
     apply is_tail_trans with tc2; auto.
     eapply transl_instr_tail; eauto. }
   exploit is_tail_code_tail. eexact TL3. intros [ofs CT].
-  exists (Ptrofs.repr ofs). red; intros.
-  rewrite Ptrofs.unsigned_repr. congruence.
-  exploit code_tail_bounds_1; eauto.
-  apply transf_function_len in TF. lia.
-+ exists Ptrofs.zero; red; intros. congruence.
+  exists (Ptrofs.repr ofs). econstructor; eauto.
+  rewrite Ptrofs.unsigned_repr. eauto.
+  exploit code_tail_bounds_1; eauto. lia.
 Qed.
 
 End RETADDR_EXISTS.
@@ -682,13 +685,28 @@ Lemma return_address_offset_correct:
   return_address_offset f c ofs' ->
   ofs' = ofs.
 Proof.
-  intros. inv H. red in H0.
-  exploit code_tail_unique. eexact H12. eapply H0; eauto. intro.
+  intros. inv H. inv H0. rewrite TF in *. inv H4; subst. rewrite TC in *.
+  inv H5; subst.
+  exploit code_tail_unique. eexact H12. eexact TL. intro.
   rewrite <- (Ptrofs.repr_unsigned ofs).
   rewrite <- (Ptrofs.repr_unsigned ofs').
   congruence.
 Qed.
 
+Lemma return_address_offset_deterministic:
+  forall f c ofs ofs',
+    return_address_offset f c ofs ->
+    return_address_offset f c ofs' ->
+    ofs = ofs'.
+Proof.
+  intros. inv H; inv H0.
+  rewrite TF in TF0. inv TF0. rewrite TC in TC0. inv TC0.
+  eapply code_tail_unique in TL; eauto.
+  assert(Integers.Ptrofs.eq ofs ofs' = true).
+  unfold Integers.Ptrofs.eq. rewrite TL. rewrite zeq_true. auto.
+  exploit Integers.Ptrofs.eq_spec. rewrite H. auto.
+Qed.
+
 (** The [find_label] function returns the code tail starting at the
   given label.  A connection with [code_tail] is then established. *)
 
@@ -788,8 +806,10 @@ Qed.
 
 Section STRAIGHTLINE.
 
-Variable ge: genv.
+Variable prog: Asm.program.
+Let ge := Genv.globalenv prog.
 Variable fn: function.
+Let sem := Asm.semantics prog.
 
 (** Straight-line code is composed of processor instructions that execute
   in sequence (no branches, no function calls and returns).
@@ -860,13 +880,17 @@ Lemma exec_straight_steps_1:
   rs#PC = Vptr b ofs ->
   Genv.find_funct_ptr ge b = Some (Internal fn) ->
   code_tail (Ptrofs.unsigned ofs) (fn_code fn) c ->
-  plus step ge (State rs m) E0 (State rs' m').
+  DPlus sem (State rs m) E0 (State rs' m').
 Proof.
   induction 1; intros.
   apply plus_one.
+  DStep_tac. fold ge. rewrite H2, H3. eapply find_instr_tail in H4.
+  rewrite H4. unfold exec_instr in H. destruct i1; ss.
   econstructor; eauto.
   eapply find_instr_tail. eauto.
   eapply plus_left'.
+  DStep_tac. fold ge. rewrite H3, H4. eapply find_instr_tail in H5.
+  rewrite H5. destruct i; ss.
   econstructor; eauto.
   eapply find_instr_tail. eauto.
   apply IHexec_straight with b (Ptrofs.add ofs Ptrofs.one).
diff --git a/backend/CSE.v b/backend/CSE.v
index ecfa1f9e..06b8423e 100644
--- a/backend/CSE.v
+++ b/backend/CSE.v
@@ -18,6 +18,7 @@ Require Import AST Linking Builtins.
 Require Import Values Memory.
 Require Import Op Registers RTL.
 Require Import ValueDomain ValueAnalysis CSEdomain CombineOp.
+Require Import PointerOp.
 
 (** The idea behind value numbering algorithms is to associate
   abstract identifiers (``value numbers'') to the contents of registers
@@ -252,6 +253,15 @@ Definition filter_loads (r: rhs) : bool :=
 Definition kill_all_loads (n: numbering) : numbering :=
   kill_equations filter_loads n.
 
+Definition filter_loads_with_psub (r: rhs) : bool :=
+  match r with
+  | Op op _ => op_depends_on_both_memory op
+  | Load _ _ _ => true
+  end.
+
+Definition kill_all_loads_with_psub (n: numbering) : numbering :=
+  kill_equations filter_loads_with_psub n.
+
 (** [kill_loads_after_store app n chunk addr args] removes all equations
   involving loads that could be invalidated by a store of quantity [chunk]
   at address determined by [addr] and [args].  Loads that are disjoint
@@ -272,7 +282,7 @@ Definition filter_after_store (app: VA.t) (n: numbering) (p: aptr) (sz: Z) (r: r
 
 Definition kill_loads_after_store
              (app: VA.t) (n: numbering)
-             (chunk: memory_chunk) (addr: addressing) (args: list reg) :=
+             (chunk: memory_chunk) (addr: addressing) (args: list reg):=
   let p := aaddressing app addr args in
   kill_equations (filter_after_store app n p (size_chunk chunk)) n.
 
@@ -471,14 +481,14 @@ Definition transfer (f: function) (approx: PMap.t VA.t) (pc: node) (before: numb
           empty_numbering
       | Ibuiltin ef args res s =>
           match ef with
-          | EF_external _ _ | EF_runtime _ _ | EF_malloc | EF_free | EF_inline_asm _ _ _ =>
+          | EF_external _ _ | EF_runtime _ _ | EF_malloc | EF_free | EF_inline_asm _ _ _ | EF_capture =>
               empty_numbering
           | EF_vstore _ =>
               set_res_unknown (kill_all_loads before) res
           | EF_builtin name sg =>
               match lookup_builtin_function name sg with
               | Some bf => set_res_unknown before res
-              | None    => set_res_unknown (kill_all_loads before) res
+              | None    => set_res_unknown (kill_all_loads_with_psub before) res
               end
           | EF_memcpy sz al =>
               match args with
diff --git a/backend/CSEdomain.v b/backend/CSEdomain.v
index e96c4cd4..36551c94 100644
--- a/backend/CSEdomain.v
+++ b/backend/CSEdomain.v
@@ -21,6 +21,7 @@ Require Import Memory.
 Require Import Op.
 Require Import Registers.
 Require Import RTL.
+Require Import PointerOp.
 
 (** Value numbers are represented by positive integers.  Equations are
   of the form [valnum = rhs] or [valnum >= rhs], where the right-hand
@@ -104,7 +105,7 @@ Definition valuation := valnum -> val.
 Inductive rhs_eval_to (valu: valuation) (ge: genv) (sp: val) (m: mem):
                                                      rhs -> val -> Prop :=
   | op_eval_to: forall op vl v,
-      eval_operation ge sp op (map valu vl) m = Some v ->
+      eval_operation_wrapper ge sp op (map valu vl) m = Some v ->
       rhs_eval_to valu ge sp m (Op op vl) v
   | load_eval_to: forall chunk addr vl a v,
       eval_addressing ge sp addr (map valu vl) = Some a ->
diff --git a/backend/CSEproof.v b/backend/CSEproof.v
index a2a1b461..76d2b121 100644
--- a/backend/CSEproof.v
+++ b/backend/CSEproof.v
@@ -14,10 +14,12 @@
 
 Require Import Coqlib Maps Errors Integers Floats Lattice Kildall.
 Require Import AST Linking.
+Require Import CoqlibC Simulation RTLD Classical IntPtrRel PointerOp.
 Require Import Values Memory Builtins Events Globalenvs Smallstep.
 Require Import Op Registers RTL.
 Require Import ValueDomain ValueAOp ValueAnalysis.
 Require Import CSEdomain CombineOp CombineOpproof CSE.
+From Paco Require Import paco.
 
 Definition match_prog (prog tprog: RTL.program) :=
   match_program (fun cu f tf => transf_fundef (romem_for cu) f = OK tf) eq prog tprog.
@@ -347,7 +349,7 @@ Qed.
 Lemma add_op_holds:
   forall valu1 ge sp rs m n op (args: list reg) v dst,
   numbering_holds valu1 ge sp rs m n ->
-  eval_operation ge sp op rs##args m = Some v ->
+  eval_operation_wrapper ge sp op rs##args m = Some v ->
   exists valu2, numbering_holds valu2 ge sp (rs#dst <- v) m (add_op n dst op args).
 Proof.
   unfold add_op; intros.
@@ -450,18 +452,36 @@ Proof.
 Qed.
 
 Lemma kill_all_loads_hold:
-  forall valu ge sp rs m n m',
+  forall valu ge sp rs m n m' (CONC: Mem.mem_concrete m = Mem.mem_concrete m'),
   numbering_holds valu ge sp rs m n ->
   numbering_holds valu ge sp rs m' (kill_all_loads n).
 Proof.
   intros. eapply kill_equations_hold; eauto.
   unfold filter_loads; intros. inv H1.
-  constructor. rewrite <- H2. apply op_depends_on_memory_correct; auto.
+  constructor. rewrite <- H2.
+  destruct (ptr_op op) eqn:PTROP.
+  2:{ do 2 (rewrite eval_operation_no_ptr_op; eauto). apply op_depends_on_memory_correct; auto. }
+  { eapply op_wrapper_depends_on_memory_correct; eauto. }
+  discriminate.
+Qed.
+
+Lemma kill_all_loads_with_psub_hold:
+  forall valu ge sp rs m n m',
+  numbering_holds valu ge sp rs m n ->
+  numbering_holds valu ge sp rs m' (kill_all_loads_with_psub n).
+Proof.
+  intros. eapply kill_equations_hold; eauto.
+  unfold filter_loads_with_psub; intros. inv H1.
+  constructor. rewrite <- H2.
+  destruct (ptr_op op) eqn:PTROP.
+  2:{ do 2 (rewrite eval_operation_no_ptr_op; eauto).
+      apply op_depends_on_memory_correct; auto. destruct op; ss. }
+  { destruct op; ss; [destruct cond; ss| destruct c; ss]. }
   discriminate.
 Qed.
 
 Lemma kill_loads_after_store_holds:
-  forall valu ge sp rs m n addr args a chunk v m' bc approx ae am,
+  forall valu ge sp rs m n addr args a chunk v m' bc approx ae am (MM: mmatch bc m am),
   numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n ->
   eval_addressing ge (Vptr sp Ptrofs.zero) addr rs##args = Some a ->
   Mem.storev chunk m a v = Some m' ->
@@ -474,18 +494,103 @@ Lemma kill_loads_after_store_holds:
 Proof.
   intros. apply kill_equations_hold with m; auto.
   intros. unfold filter_after_store in H6; inv H7.
-- constructor. rewrite <- H8. apply op_depends_on_memory_correct; auto.
+- constructor. rewrite <- H8. apply op_wrapper_depends_on_memory_correct; auto.
+  symmetry. eapply Mem.storev_concrete; eauto.
 - destruct (regs_valnums n vl) as [rl|] eqn:RV; try discriminate.
   econstructor; eauto. rewrite <- H9.
   destruct a; simpl in H1; try discriminate.
-  destruct a0; simpl in H9; try discriminate.
-  simpl.
-  rewrite negb_false_iff in H6. unfold aaddressing in H6.
++ destruct a0; simpl in H9; try discriminate.
+* des_ifs. simpl.
+  exploit eval_static_addressing_sound; eauto.
+  erewrite <- regs_valnums_sound by eauto. eauto with va. i.
+  exploit eval_static_addressing_sound; try eapply H0; eauto with va. i.
+  i. dup H5. dup H7. inv H10.
+  { exfalso. ss. rewrite <- H14 in *. ss. inv H7.
+    - rewrite <- H13 in *. ss. des_ifs.
+    - rewrite <- H13 in *. ss. des_ifs. }
+  { exfalso. ss. rewrite <- H14 in H6. ss. inv H7.
+    - rewrite <- H13 in *. ss. des_ifs.
+    - rewrite <- H13 in *. ss. des_ifs. }
+* des_ifs. simpl.
+  exploit eval_static_addressing_sound; eauto.
+  erewrite <- regs_valnums_sound by eauto. eauto with va. i.
+  exploit eval_static_addressing_sound; try eapply H0; eauto with va. i.
+  ss. i. dup H5. dup H7. inv H10.
+  { rewrite <- H15 in H6. ss. inv H7.
+    { rewrite <- H14 in H6. ss. des_ifs.
+      - unfold pdisjoint in H6. des_ifs. inv H13.
+      - unfold pdisjoint in H6. des_ifs. inv H13.
+      + exploit denormalized_nonstack; eauto. i.
+        eapply Mem.load_store_other. eauto.
+        replace z with (Ptrofs.unsigned (Ptrofs.repr z)).
+        2:{ eapply Mem.denormalize_info in Heq0. des. rewrite Ptrofs.unsigned_repr; eauto. }
+        eapply pdisjoint_sound; eauto. ss.
+      + exploit denormalized_nonstack; eauto. i.
+        eapply Mem.load_store_other. eauto.
+        replace z with (Ptrofs.unsigned (Ptrofs.repr z)).
+        2:{ eapply Mem.denormalize_info in Heq0. des. rewrite Ptrofs.unsigned_repr; eauto. }
+        eapply pdisjoint_sound; eauto. ss. }
+    rewrite <- H14 in H6. destruct (am_concrete_stack am) eqn:CONCSTK.
+    { ss. unfold pdisjoint in *. des_ifs. inv H13. }
+    ss. exploit denormalized_nonstack; eauto. i.
+    eapply Mem.load_store_other. eauto.
+    replace z with (Ptrofs.unsigned (Ptrofs.repr z)).
+    2:{ eapply Mem.denormalize_info in Heq0. des. rewrite Ptrofs.unsigned_repr; eauto. }
+    eapply pdisjoint_sound; eauto. rewrite negb_false_iff in H6.
+    unfold pdisjoint in H6. des_ifs; eauto. }
+  rewrite <- H15 in H6. inv H7.
+  { rewrite <- H14 in H6. ss. des_ifs. }
+  rewrite <- H14 in H6. ss. des_ifs.
++ destruct a0; unfold Mem.loadv in H9; simpl in H9; try discriminate.
+* des_ifs. exploit eval_static_addressing_sound; eauto.
+  erewrite <- regs_valnums_sound by eauto. eauto with va. i.
+  exploit eval_static_addressing_sound; try eapply H0; eauto with va. i.
+  unfold Mem.loadv. ss. rewrite Heq0. rewrite Heq1. des_ifs.
+  { exploit Mem.denormalize_store_other; try eapply H1; eauto.
+    i. rewrite H10 in Heq2. clarify.
+    rewrite Ptrofs.unsigned_repr; cycle 1.
+    { eapply Mem.denormalize_in_range in H10. unfold Ptrofs.max_unsigned. des. lia. }
+    dup H5. dup H7. inv H11.
+    { rewrite <- H15 in H6. ss. inv H12.
+      { rewrite <- H16 in H6. ss. rewrite Heq0 in H6.
+        destruct (am_concrete_stack am) eqn:CONCSTK.
+        { ss. des_ifs. inv H13. }
+        rewrite negb_false_iff in H6.      
+        eapply Mem.load_store_other. eauto.
+        replace z0 with (Ptrofs.unsigned (Ptrofs.repr z0)).
+        2:{ eapply Mem.denormalize_info in Heq4. des. rewrite Ptrofs.unsigned_repr; eauto. }
+        eapply pdisjoint_sound; eauto.
+        eapply denormalized_nonstack; eauto. }
+      ss. rewrite <- H16, Heq0 in H6. ss.
+      destruct (am_concrete_stack am) eqn:CONCSTK; [ss|].
+      rewrite negb_false_iff in H6.
+      eapply Mem.load_store_other. eauto.
+      replace z0 with (Ptrofs.unsigned (Ptrofs.repr z0)).
+      2:{ eapply Mem.denormalize_info in Heq4. des. rewrite Ptrofs.unsigned_repr; eauto. }
+      eapply pdisjoint_sound; eauto.
+      eapply denormalized_nonstack; eauto. des_ifs. }
+    inv H12.
+    { rewrite <- H16, <- H15 in H6. ss. destruct (am_concrete_stack am) eqn:CONCSTK.
+      { ss. des_ifs. inv H13. }
+      rewrite negb_false_iff in H6. eapply Mem.load_store_other. eauto.
+      replace z0 with (Ptrofs.unsigned (Ptrofs.repr z0)).
+      2:{ eapply Mem.denormalize_info in Heq4. des. rewrite Ptrofs.unsigned_repr; eauto. }
+      exploit denormalized_nonstack; eauto. i. inv H11.
+      eapply pdisjoint_sound; eauto. des_ifs; econs; eauto. }
+    rewrite <- H16, <- H15 in H6. ss. destruct (am_concrete_stack am) eqn:CONCSTK; [ss|].
+    { rewrite negb_false_iff in H6. eapply Mem.load_store_other. eauto.
+      replace z0 with (Ptrofs.unsigned (Ptrofs.repr z0)).
+      2:{ eapply Mem.denormalize_info in Heq4. des. rewrite Ptrofs.unsigned_repr; eauto. }
+      exploit denormalized_nonstack; eauto. i. inv H11.
+      eapply pdisjoint_sound; [eauto| |]; des_ifs. } }
+  exploit Mem.denormalize_store_other; eauto. i. rewrite H10 in Heq2. clarify.
+* simpl. rewrite negb_false_iff in H6. unfold aaddressing in H6.
   eapply Mem.load_store_other. eauto.
   eapply pdisjoint_sound. eauto.
   apply match_aptr_of_aval. eapply eval_static_addressing_sound; eauto.
   erewrite <- regs_valnums_sound by eauto. eauto with va.
   apply match_aptr_of_aval. eapply eval_static_addressing_sound; eauto with va.
+  Unshelve. ss.
 Qed.
 
 Lemma store_normalized_range_sound:
@@ -527,7 +632,21 @@ Proof.
   red; simpl; intros. auto.
 + destruct H4; eauto with cse. subst eq. apply eq_holds_lessdef with (Val.load_result chunk rs#src).
   apply load_eval_to with a. rewrite <- Q; auto.
-  destruct a; try discriminate. simpl. eapply Mem.load_store_same; eauto.
+  destruct a; try discriminate.
+  { unfold Mem.loadv. simpl. des_ifs.
+    - unfold Mem.storev in H1. des_ifs.
+      exploit Mem.denormalize_store_other; try eapply H1; eauto. i. exfalso.
+      replace (Int64.unsigned i) with 0 in H3; cycle 1.
+      { eapply Int64.same_if_eq in Heq1. subst. symmetry. eapply Int64.unsigned_zero. }
+      erewrite Mem.denormalize_nullptr in H3. clarify.
+    - unfold Mem.storev in H1. des_ifs.
+      exploit Mem.denormalize_store_other; try eapply H1; eauto. i. rewrite H3 in Heq2. clarify.
+      simpl. eapply Mem.load_store_same; eauto. instantiate (1:=m).
+      rewrite Ptrofs.unsigned_repr; eauto. eapply Mem.denormalize_in_range in Heq.
+      unfold Ptrofs.max_unsigned. des; lia.
+    - unfold Mem.storev in H1. des_ifs.
+      exploit Mem.denormalize_store_other; eauto. i. rewrite H3 in Heq2. clarify. }
+  simpl. eapply Mem.load_store_same; eauto.
   rewrite B. rewrite R by auto. apply store_normalized_range_sound with bc.
   rewrite <- B. eapply vmatch_ge. apply vincl_ge; eauto. apply H2.
 + eauto with cse.
@@ -536,7 +655,7 @@ Proof.
 Qed.
 
 Lemma kill_loads_after_storebytes_holds:
-  forall valu ge sp rs m n dst b ofs bytes m' bc approx ae am sz,
+  forall valu ge sp rs m n dst b ofs bytes m' bc approx ae am sz (MM: mmatch bc m am),
   numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n ->
   pmatch bc b ofs dst ->
   Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m' ->
@@ -550,10 +669,32 @@ Lemma kill_loads_after_storebytes_holds:
 Proof.
   intros. apply kill_equations_hold with m; auto.
   intros. unfold filter_after_store in H8; inv H9.
-- constructor. rewrite <- H10. apply op_depends_on_memory_correct; auto.
+- constructor. rewrite <- H10. eapply op_wrapper_depends_on_memory_correct; auto.
+  symmetry. eapply Mem.concrete_storebytes; eauto.
 - destruct (regs_valnums n vl) as [rl|] eqn:RV; try discriminate.
   econstructor; eauto. rewrite <- H11.
   destruct a; simpl in H10; try discriminate.
+  { unfold Mem.loadv in *. ss. des_ifs_safe. exploit Mem.denormalize_storebytes_other; eauto. i. rewrite H5.
+    exploit eval_static_addressing_sound; eauto.
+    erewrite <- regs_valnums_sound by eauto. eauto with va. i. inv H9.
+    - rewrite <- H14 in H8. ss. des_ifs.
+      { ss. des_ifs. inv H0. }
+      exploit denormalized_nonstack; eauto. i. rewrite negb_false_iff in H8.
+      eapply Mem.load_storebytes_other. eauto.
+      replace z with (Ptrofs.unsigned (Ptrofs.repr z)).
+      2:{ eapply Mem.denormalize_info in H5. des. rewrite Ptrofs.unsigned_repr; eauto. }
+      rewrite H6. rewrite Z2Nat.id by lia.
+      eapply pdisjoint_sound; eauto. rewrite Ptrofs.repr_unsigned. eauto.
+    - rewrite <- H14 in H8. ss. destruct (am_concrete_stack am) eqn:CONCSTK.
+      { ss. des_ifs. inv H0. }
+      exploit denormalized_nonstack; eauto. i. rewrite negb_false_iff in H8.
+      eapply Mem.load_storebytes_other. eauto.
+      replace z with (Ptrofs.unsigned (Ptrofs.repr z)).
+      2:{ eapply Mem.denormalize_info in H5. des. rewrite Ptrofs.unsigned_repr; eauto. }
+      rewrite H6. rewrite Z2Nat.id by lia.
+      inv H9. eapply pdisjoint_sound with (bc:=bc). eauto.
+      + des_ifs; econs; eauto.
+      + des_ifs; econs; eauto. }
   simpl.
   rewrite negb_false_iff in H8.
   eapply Mem.load_storebytes_other. eauto.
@@ -564,6 +705,19 @@ Proof.
   auto.
 Qed.
 
+Lemma kill_loads_after_storebytes_zero_holds:
+  forall valu ge sp rs m n dst bc approx ae am (MM: mmatch bc m am),
+  numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n ->
+  genv_match bc ge ->
+  bc sp = BCstack ->
+  ematch bc rs ae ->
+  approx = VA.State ae am ->
+  numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m
+                           (kill_loads_after_storebytes approx n dst 0).
+Proof.
+  intros. apply kill_equations_hold with m; auto.
+Qed.
+
 Lemma load_memcpy:
   forall m b1 ofs1 sz bytes b2 ofs2 m' chunk i v,
   Mem.loadbytes m b1 ofs1 sz = Some bytes ->
@@ -609,10 +763,12 @@ Proof.
     unfold n2; lia.
     right; left; lia. }
   exploit Mem.load_valid_access; eauto. intros [P Q].
-  rewrite B. apply Mem.loadbytes_load.
+  rewrite B. erewrite <- (Mem.normalize_mvs_same_concrete m'). apply Mem.loadbytes_load.
   replace (i + (ofs2 - ofs1)) with (ofs2 + n1) by (unfold n1; lia).
   exact LB''.
   apply Z.divide_add_r; auto.
+  symmetry. eapply Mem.concrete_storebytes in SB1, SB2, SB3.
+  rewrite SB1, SB2, SB3. eauto.
 Qed.
 
 Lemma shift_memcpy_eq_wf:
@@ -655,7 +811,7 @@ Proof with (try discriminate).
     Mem.loadv chunk m (Vptr sp ofs) = Some v ->
     Mem.loadv chunk m' (Vptr sp (Ptrofs.repr j)) = Some v).
   {
-    simpl; intros. rewrite Ptrofs.unsigned_repr by lia.
+    unfold Mem.loadv. simpl; intros. rewrite Ptrofs.unsigned_repr by lia.
     unfold j, delta. eapply load_memcpy; eauto.
     apply Zmod_divide; auto. generalize (align_chunk_pos chunk); lia.
   }
@@ -672,6 +828,24 @@ Proof with (try discriminate).
   apply LD; auto.
 Qed.
 
+Lemma shift_memcpy_zero_eq_holds:
+  forall src dst e e' m sp valu ge,
+  shift_memcpy_eq src 0 (dst - src) e = Some e' ->
+  equation_holds valu ge (Vptr sp Ptrofs.zero) m e ->
+  equation_holds valu ge (Vptr sp Ptrofs.zero) m e'.
+Proof with (try discriminate).
+  intros. set (delta := dst - src) in *. unfold shift_memcpy_eq in H.
+  destruct e as [l strict rhs] eqn:E.
+  destruct rhs as [op vl | chunk addr vl]...
+  destruct addr...
+  try (rename i into ofs).
+  set (i1 := Ptrofs.unsigned ofs) in *. set (j := i1 + delta) in *.
+  destruct (zle src i1)...
+  destruct (zle (i1 + size_chunk chunk) (src + 0))...
+  destruct (zeq (delta mod align_chunk chunk) 0)...
+  destruct chunk; ss; lia.
+Qed.
+
 Lemma add_memcpy_eqs_charact:
   forall e' src sz delta eqs2 eqs1,
   In e' (add_memcpy_eqs src sz delta eqs1 eqs2) ->
@@ -716,6 +890,33 @@ Proof.
   eapply shift_memcpy_eq_holds; eauto with cse.
 Qed.
 
+Lemma add_memcpy_zero_holds:
+  forall m valu ge sp rs n1 n2 (bc: block_classification) asrc adst,
+  numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n1 ->
+  numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m n2 ->
+  bc sp = BCstack ->
+  Ple (num_next n1) (num_next n2) ->
+  numbering_holds valu ge (Vptr sp Ptrofs.zero) rs m (add_memcpy n1 n2 asrc adst 0).
+Proof.
+  intros. unfold add_memcpy.
+  destruct asrc; auto; destruct adst; auto.
+  assert (A: forall b o i, pmatch bc b o (Stk i) -> b = sp /\ i = o).
+  {
+    intros. inv H3. split; auto. eapply bc_stack; eauto.
+  }
+  (* apply A in H3; destruct H3. subst bsrc ofs. *)
+  (* apply A in H4; destruct H4. subst bdst ofs0. *)
+  constructor; simpl; intros; eauto with cse.
+- constructor; simpl; eauto with cse.
+  intros. exploit add_memcpy_eqs_charact; eauto. intros [X | (e0 & X & Y)].
+  eauto with cse.
+  apply wf_equation_incr with (num_next n1); auto.
+  eapply shift_memcpy_eq_wf; eauto with cse.
+- exploit add_memcpy_eqs_charact; eauto. intros [X | (e0 & X & Y)].
+  eauto with cse.
+  eapply shift_memcpy_zero_eq_holds; eauto with cse.
+Qed.
+
 (** Correctness of operator reduction *)
 
 Section REDUCE.
@@ -816,6 +1017,9 @@ Hypothesis TRANSF: match_prog prog tprog.
 Let ge := Genv.globalenv prog.
 Let tge := Genv.globalenv tprog.
 
+Let sem := semantics prog.
+Let tsem := semantics tprog.
+
 Lemma symbols_preserved:
   forall (s: ident), Genv.find_symbol tge s = Genv.find_symbol ge s.
 Proof (Genv.find_symbol_match TRANSF).
@@ -824,6 +1028,9 @@ Lemma senv_preserved:
   Senv.equiv ge tge.
 Proof (Genv.senv_match TRANSF).
 
+Lemma same_public: prog_public prog = prog_public tprog.
+Proof. inv TRANSF. des; eauto. Qed.
+
 Lemma functions_translated:
   forall (v: val) (f: RTL.fundef),
   Genv.find_funct ge v = Some f ->
@@ -882,18 +1089,21 @@ Proof.
 Qed.
 
 Lemma find_function_translated:
-  forall ros rs fd rs',
-  find_function ge ros rs = Some fd ->
+  forall ros rs fd rs' m m' (MEXT: Mem.extends m m'),
+  find_function ge (ros_to_vos m ros rs) rs = Some fd ->
   regs_lessdef rs rs' ->
-  exists cu tfd, find_function tge ros rs' = Some tfd
+  exists cu tfd, find_function tge (ros_to_vos m' ros rs') rs' = Some tfd
               /\ transf_fundef (romem_for cu) fd = OK tfd
               /\ linkorder cu prog.
 Proof.
   unfold find_function; intros; destruct ros.
 - specialize (H0 r). inv H0.
+  2:{ ss. rewrite <- H2 in *. ss. }
+  ss. destruct (rs # r) eqn: RSV; try by ss.
++ rewrite <- H3. des_ifs_safe. erewrite Mem.denormalize_extends; eauto.
   apply functions_translated; auto.
-  rewrite <- H2 in H; discriminate.
-- rewrite symbols_preserved. destruct (Genv.find_symbol ge i).
++ rewrite <- H3. apply functions_translated; auto. 
+- simpl in *. rewrite symbols_preserved. destruct (Genv.find_symbol ge i).
   apply funct_ptr_translated; auto.
   discriminate.
 Qed.
@@ -972,15 +1182,16 @@ Ltac TransfInstr :=
   in the source code. *)
 
 Lemma transf_step_correct:
-  forall s1 t s2, step ge s1 t s2 ->
+  forall s1 t s2, IStep sem s1 t s2 ->
   forall s1' (MS: match_states s1 s1') (SOUND: sound_state prog s1),
-  exists s2', step tge s1' t s2' /\ match_states s2 s2'.
+  exists s2', DStep tsem s1' t s2' /\ match_states s2 s2'.
 Proof.
+  destruct 1. generalize dependent s2. rename H into INT.
   induction 1; intros; inv MS; try (TransfInstr; intro C).
 
   (* Inop *)
 - econstructor; split.
-  eapply exec_Inop; eauto.
+  DStep_tac. eapply exec_Inop; eauto.
   econstructor; eauto.
   eapply analysis_correct_1; eauto. simpl; auto.
   unfold transfer; rewrite H; auto.
@@ -988,11 +1199,11 @@ Proof.
   (* Iop *)
 - destruct (is_trivial_op op) eqn:TRIV.
 + (* unchanged *)
-  exploit eval_operation_lessdef. eapply regs_lessdef_regs; eauto. eauto. eauto.
+  exploit eval_operation_wrapper_lessdef. eapply regs_lessdef_regs; eauto. eauto. eauto.
   intros [v' [A B]].
   econstructor; split.
-  eapply exec_Iop with (v := v'); eauto.
-  rewrite <- A. apply eval_operation_preserved. exact symbols_preserved.
+  DStep_tac. eapply exec_Iop with (v := v'); eauto.
+  rewrite <- A. apply eval_operation_wrapper_preserved. exact symbols_preserved.
   econstructor; eauto.
   eapply analysis_correct_1; eauto. simpl; auto.
   unfold transfer; rewrite H.
@@ -1005,9 +1216,11 @@ Proof.
   destruct (find_rhs n1 (Op op vl)) as [r|] eqn:?.
 * (* replaced by move *)
   exploit find_rhs_sound; eauto. intros (v' & EV & LD).
-  assert (v' = v) by (inv EV; congruence). subst v'.
-  econstructor; split.
-  eapply exec_Iop; eauto. simpl; eauto.
+  unfold sem in *. ss.
+  assert (v' = v).
+  { inv EV. unfold ge in *. rewrite <- EQ in H4. Eq. }
+  subst v'. econstructor; split.
+  DStep_tac. eapply exec_Iop; eauto. simpl; eauto. ss.
   econstructor; eauto.
   eapply analysis_correct_1; eauto. simpl; auto.
   unfold transfer; rewrite H.
@@ -1016,14 +1229,14 @@ Proof.
   eapply Val.lessdef_trans; eauto.
 * (* possibly simplified *)
   destruct (reduce operation combine_op n1 op args vl) as [op' args'] eqn:?.
-  assert (RES: eval_operation ge sp op' rs##args' m = Some v).
-    eapply reduce_sound with (sem := fun op vl => eval_operation ge sp op vl m); eauto.
+  assert (RES: eval_operation_wrapper ge sp op' rs##args' m = Some v).
+    eapply reduce_sound with (sem := fun op vl => eval_operation_wrapper ge sp op vl m); eauto.
     intros; eapply combine_op_sound; eauto.
-  exploit eval_operation_lessdef. eapply regs_lessdef_regs; eauto. eauto. eauto.
+  exploit eval_operation_wrapper_lessdef. eapply regs_lessdef_regs; eauto. eauto. eauto.
   intros [v' [A B]].
   econstructor; split.
-  eapply exec_Iop with (v := v'); eauto.
-  rewrite <- A. apply eval_operation_preserved. exact symbols_preserved.
+  DStep_tac. eapply exec_Iop with (v := v'); eauto.
+  rewrite <- A. apply eval_operation_wrapper_preserved. exact symbols_preserved.
   econstructor; eauto.
   eapply analysis_correct_1; eauto. simpl; auto.
   unfold transfer; rewrite H.
@@ -1037,9 +1250,11 @@ Proof.
   destruct (find_rhs n1 (Load chunk addr vl)) as [r|] eqn:?.
 + (* replaced by move *)
   exploit find_rhs_sound; eauto. intros (v' & EV & LD).
-  assert (v' = v) by (inv EV; congruence). subst v'.
-  econstructor; split.
-  eapply exec_Iop; eauto. simpl; eauto.
+  assert (v' = v).
+  { inv EV. rewrite <- EQ in H6. unfold ge in *. ss. clarify. }
+  subst v'. econstructor; split.
+  DStep_tac. eapply exec_Iop; eauto. simpl; eauto.
+  econstructor; eauto.
   econstructor; eauto.
   eapply analysis_correct_1; eauto. simpl; auto.
   unfold transfer; rewrite H.
@@ -1057,7 +1272,7 @@ Proof.
   exploit Mem.loadv_extends; eauto.
   intros [v' [X Y]].
   econstructor; split.
-  eapply exec_Iload; eauto.
+  DStep_tac. eapply exec_Iload; eauto.
   econstructor; eauto.
   eapply analysis_correct_1; eauto. simpl; auto.
   unfold transfer; rewrite H.
@@ -1078,7 +1293,7 @@ Proof.
   { rewrite <- A. apply eval_addressing_preserved. exact symbols_preserved. }
   exploit Mem.storev_extends; eauto. intros [m'' [X Y]].
   econstructor; split.
-  eapply exec_Istore; eauto.
+  DStep_tac. eapply exec_Istore; eauto.
   econstructor; eauto.
   eapply analysis_correct_1; eauto. simpl; auto.
   unfold transfer; rewrite H.
@@ -1089,7 +1304,7 @@ Proof.
 - (* Icall *)
   exploit find_function_translated; eauto. intros (cu' & tf & FIND' & TRANSF' & LINK').
   econstructor; split.
-  eapply exec_Icall; eauto.
+  DStep_tac. eapply exec_Icall; eauto.
   eapply sig_preserved; eauto.
   econstructor; eauto.
   eapply match_stackframes_cons with (cu := cu); eauto.
@@ -1102,18 +1317,19 @@ Proof.
   exploit find_function_translated; eauto. intros (cu' & tf & FIND' & TRANSF' & LINK').
   exploit Mem.free_parallel_extends; eauto. intros [m'' [A B]].
   econstructor; split.
-  eapply exec_Itailcall; eauto.
+  DStep_tac. eapply exec_Itailcall; eauto.
   eapply sig_preserved; eauto.
   econstructor; eauto.
   apply regs_lessdef_regs; auto.
 
 - (* Ibuiltin *)
+  unfold is_internal in INT. ss. rewrite H in INT.
   exploit (@eval_builtin_args_lessdef _ ge (fun r => rs#r) (fun r => rs'#r)); eauto.
   intros (vargs' & A & B).
   exploit external_call_mem_extends; eauto.
   intros (v' & m1' & P & Q & R & S).
   econstructor; split.
-  eapply exec_Ibuiltin; eauto.
+  DStep_tac. eapply exec_Ibuiltin; eauto.
   eapply eval_builtin_args_preserved with (ge1 := ge); eauto. exact symbols_preserved.
   eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   econstructor; eauto.
@@ -1124,28 +1340,34 @@ Proof.
   { exists valu; apply empty_numbering_holds. }
   assert (CASE2: m' = m -> exists valu, numbering_holds valu ge sp (regmap_setres res vres rs) m' (set_res_unknown approx#pc res)).
   { intros. subst m'. exists valu. apply set_res_unknown_holds; auto. }
-  assert (CASE3: exists valu, numbering_holds valu ge sp (regmap_setres res vres rs) m'
+  assert (CASE3: Mem.mem_concrete m = Mem.mem_concrete m' ->
+                 exists valu, numbering_holds valu ge sp (regmap_setres res vres rs) m'
                          (set_res_unknown (kill_all_loads approx#pc) res)).
   { exists valu. apply set_res_unknown_holds. eapply kill_all_loads_hold; eauto. }
-  destruct ef.
+  destruct ef eqn:PPP.
   + apply CASE1.
   + destruct (lookup_builtin_function name sg) as [bf|] eqn:LK.
     ++ apply CASE2. simpl in H1; red in H1; rewrite LK in H1; inv H1. auto.
-    ++ apply CASE3.
+    ++ ss. des_ifs.
   + apply CASE1.
   + apply CASE2; inv H1; auto.
   + apply CASE3.
+    ss. inv H1; eauto. inv H2. ss. eapply Mem.concrete_store; eauto.
   + apply CASE1.
   + apply CASE1.
   + inv H0; auto. inv H3; auto. inv H4; auto.
-    simpl in H1. inv H1.
+    simpl in H1. inv H1; cycle 1.
+    { exists valu.
+      apply set_res_unknown_holds.
+      InvSoundState. unfold vanalyze; rewrite AN.
+      eapply add_memcpy_zero_holds; eauto.
+      eapply kill_loads_after_storebytes_zero_holds; eauto.
+      simpl. apply Ple_refl. }
     exists valu.
     apply set_res_unknown_holds.
     InvSoundState. unfold vanalyze; rewrite AN.
-    assert (pmatch bc bsrc osrc (aaddr_arg (VA.State ae am) a0))
-    by (eapply aaddr_arg_sound_1; eauto).
-    assert (pmatch bc bdst odst (aaddr_arg (VA.State ae am) a1))
-    by (eapply aaddr_arg_sound_1; eauto).
+    assert (pmatch bc bsrc osrc (aaddr_arg (VA.State ae am) a0)) by (eapply aaddr_arg_to_ptr_sound_1; eauto).
+    assert (pmatch bc bdst odst (aaddr_arg (VA.State ae am) a1)) by (eapply aaddr_arg_to_ptr_sound_1; eauto).
     eapply add_memcpy_holds; eauto.
     eapply kill_loads_after_storebytes_holds; eauto.
     eapply Mem.loadbytes_length; eauto.
@@ -1154,6 +1376,7 @@ Proof.
   + apply CASE2; inv H1; auto.
   + apply CASE1.
   + apply CASE2; inv H1; auto.
+  + ss.
 * apply set_res_lessdef; auto.
 
 - (* Icond *)
@@ -1161,12 +1384,12 @@ Proof.
   elim SAT; intros valu1 NH1.
   exploit valnum_regs_holds; eauto. intros (valu2 & NH2 & EQ & AG & P & Q).
   destruct (reduce condition combine_cond n1 cond args vl) as [cond' args'] eqn:?.
-  assert (RES: eval_condition cond' rs##args' m = Some b).
-  { eapply reduce_sound with (sem := fun cond vl => eval_condition cond vl m); eauto.
+  assert (RES: eval_condition_wrapper cond' rs##args' m = Some b).
+  { eapply reduce_sound with (sem := fun cond vl => eval_condition_wrapper cond vl m); eauto.
     intros; eapply combine_cond_sound; eauto. }
   econstructor; split.
-  eapply exec_Icond; eauto.
-  eapply eval_condition_lessdef; eauto. apply regs_lessdef_regs; auto.
+  DStep_tac. eapply exec_Icond; eauto.
+  eapply eval_condition_wrapper_lessdef; eauto. apply regs_lessdef_regs; auto.
   econstructor; eauto.
   destruct b; eapply analysis_correct_1; eauto; simpl; auto;
   unfold transfer; rewrite H; auto.
@@ -1174,7 +1397,7 @@ Proof.
 - (* Ijumptable *)
   generalize (RLD arg); rewrite H0; intro LD; inv LD.
   econstructor; split.
-  eapply exec_Ijumptable; eauto.
+  DStep_tac. eapply exec_Ijumptable; eauto.
   econstructor; eauto.
   eapply analysis_correct_1; eauto. simpl. eapply list_nth_z_in; eauto.
   unfold transfer; rewrite H; auto.
@@ -1182,7 +1405,7 @@ Proof.
 - (* Ireturn *)
   exploit Mem.free_parallel_extends; eauto. intros [m'' [A B]].
   econstructor; split.
-  eapply exec_Ireturn; eauto.
+  DStep_tac. eapply exec_Ireturn; eauto.
   econstructor; eauto.
   destruct or; simpl; auto.
 
@@ -1192,24 +1415,24 @@ Proof.
   exploit Mem.alloc_extends; eauto. apply Z.le_refl. apply Z.le_refl.
   intros (m'' & A & B).
   econstructor; split.
-  eapply exec_function_internal; simpl; eauto.
+  DStep_tac. eapply exec_function_internal; simpl; eauto.
   simpl. econstructor; eauto.
   eapply analysis_correct_entry; eauto.
   apply init_regs_lessdef; auto.
 
 - (* external function *)
   monadInv TFD.
-  exploit external_call_mem_extends; eauto.
+  exploit external_call_mem_extends; eauto. ss.
   intros (v' & m1' & P & Q & R & S).
   econstructor; split.
-  eapply exec_function_external; eauto.
+  DStep_tac. eapply exec_function_external; eauto.
   eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   econstructor; eauto.
 
 - (* return *)
   inv STACK.
   econstructor; split.
-  eapply exec_return; eauto.
+  DStep_tac. eapply exec_return; eauto.
   econstructor; eauto.
   apply set_reg_lessdef; auto.
 Qed.
@@ -1237,17 +1460,160 @@ Proof.
   intros. inv H0. inv H. inv RES. inv STACK. constructor.
 Qed.
 
+Lemma match_states_bsim
+      s1 (EXT: is_external ge s1)
+      (SOUND: sound_state prog s1)
+      s2 t s2' (STEPTGT: Step tsem s2 t s2')
+      (MATCH: match_states s1 s2)
+      (SAFESRC: safe sem s1) :
+    (exists s1', Step sem s1 t s1' /\ match_states s1' s2')
+  \/ (~ trace_intact t /\ exists s1'' t', Step sem s1 t' s1'' /\ exists tl, t' = (trace_cut_pterm t) ** tl).
+Proof.
+  assert (SEQUIV: Senv.equiv tge ge) by (symmetry; eapply senv_preserved).
+  unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+  { inv SAFESRC; ss. }
+  i. unfold is_external in *. des_ifs.
+  (* builtin *)
+  - inversion MATCH; try (TransfInstr; intro C); subst.
+    inv SAFESRC; ss; des_ifs. inv STEPTGT; ss; des_ifs; clarify.
+    exploit (@eval_builtin_args_lessdef _ ge (fun r => rs#r) (fun r => rs'#r)); eauto. intros (vargs' & A & B).
+    exploit eval_builtin_args_preserved; try eapply A. eapply senv_preserved. i.
+    exploit eval_builtin_args_determ. eapply H. eapply H11. i. subst.
+    exploit external_call_mem_extends_backward; eauto.
+    destruct SAT as [valu NH].
+    i; des; cycle 1.
+    + exploit UBSRC. eapply external_call_symbols_preserved; eauto. eapply senv_preserved. contradiction.
+    + right. esplits; eauto. eapply exec_Ibuiltin. eauto. eapply H8.
+      eapply external_call_symbols_preserved; eauto.
+    + left. esplits; eauto. eapply exec_Ibuiltin. eauto. eapply H8.
+      eapply external_call_symbols_preserved; eauto.
+      econs; eauto.
+      { eapply analysis_correct_1; eauto. simpl; auto.
+        unfold transfer; rewrite H7.
+        assert (CASE1: exists valu, numbering_holds valu ge sp (regmap_setres b vres1 rs) m2 empty_numbering).
+        { exists valu; apply empty_numbering_holds. }
+        assert (CASE2: m2 = m -> exists valu, numbering_holds valu ge sp (regmap_setres b vres1 rs) m2 (set_res_unknown approx#pc b)).
+        { intros. subst m2. exists valu. apply set_res_unknown_holds; auto. }
+        assert (CASE3: exists valu, numbering_holds valu ge sp (regmap_setres b vres1 rs) m2
+                                 (set_res_unknown (kill_all_loads_with_psub approx#pc) b)).
+        { exists valu. apply set_res_unknown_holds. eapply kill_all_loads_with_psub_hold; eauto. }
+        destruct e eqn:PPP; ss.
+        + destruct (lookup_builtin_function name sg) as [bf|] eqn:LK.
+          ++ apply CASE2.
+             simpl in CALLSRC; red in CALLSRC; rewrite LK in CALLSRC; inv CALLSRC. auto.
+          ++ apply CASE3.
+        + eapply CASE2. inv CALLSRC. eauto. }
+      eapply set_res_lessdef; eauto.
+  (* external call *)
+  - inversion MATCH; try (TransfInstr; intro C).
+    inv SAFESRC; ss; des_ifs. inv STEPTGT; ss; des_ifs; clarify.
+    exploit external_call_mem_extends_backward. eauto.
+    eapply external_call_symbols_preserved; eauto. eauto. eauto. i. des; cycle 1.
+    { exploit UBSRC; eauto. i; ss. }
+    { right. esplits; eauto. eapply exec_function_external; eauto. }
+    left. esplits; eauto;[|econs;eauto].
+    eapply exec_function_external; eauto.
+Qed.
+
+Lemma match_states_xsim st_src0 st_tgt0 gmtgt
+    (MATCH: match_states st_src0 st_tgt0)
+    (SOUND: sound_state prog st_src0) :
+  xsim (RTL.semantics prog) (RTL.semantics tprog) gmtgt lt 0%nat st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold.
+  destruct (classic (is_external ge st_src0)); cycle 1; rename H into EXT.
+  - left. econs. econs.
+    + (* internal *)
+      i. exploit transf_step_correct; eauto. i. des; esplits; eauto;
+      [eapply tr_rel_refl; eapply ev_rel_refl| |].
+      { left. split. apply plus_one. eauto. eapply semantics_receptive_at; auto. }
+      { right. eapply CIH; eauto. eapply sound_step; eauto. }
+    + i. exploit transf_final_states; eauto. i. eapply final_state_determ; eauto.
+  - right. econs; eauto. i. econs.
+    + i. unfold is_external in EXT.
+      exploit match_states_bsim; eauto. ss. i. des; subst.
+      { left. esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl| |].
+        { left. eapply plus_one. eauto. }
+        right. eapply CIH; eauto. eapply sound_step; eauto. }
+      { right. esplits; eauto; [|eapply tr_rel_refl; eapply ev_rel_refl].
+        eapply star_one. eauto. }
+    + i. inv FINALTGT; inv MATCH; ss.
+    + i. specialize (SAFESRC _ (star_refl _ _ _)). des; ss; [inv SAFESRC; ss|].
+      right. inv MATCH; ss; des_ifs.
+      * TransfInstr. i.
+        inv SAFESRC; unfold ge in *; ss; des_ifs.
+        exploit eval_builtin_args_lessdef; try eapply RLD; eauto. i. des.
+        exploit external_call_mem_extends_backward_progress; eauto. i. des.
+        exploit external_call_symbols_preserved. apply senv_preserved. eauto. i.
+        esplits; eapply exec_Ibuiltin; eauto.
+        eapply eval_builtin_args_preserved with (ge1 := ge); eauto. exact symbols_preserved.
+      * monadInv TFD.
+        inv SAFESRC; unfold ge in *; ss; des_ifs.
+        exploit external_call_mem_extends_backward_progress; eauto. i. des.
+        exploit external_call_symbols_preserved. apply senv_preserved. eauto. i.
+        esplits; exploit exec_function_external; eauto.
+Qed.
+
+Lemma non_static_equiv l:
+  Genv.non_static_glob (Genv.globalenv prog) l = Genv.non_static_glob (Genv.globalenv tprog) l.
+Proof.
+  Local Transparent ge tge.
+  induction l; ss.
+  specialize senv_preserved. ss. i. inv H. inv H1. unfold ge, tge, fundef in *.
+  specialize (H a). unfold Senv.public_symbol in H. ss. erewrite H.
+  specialize (H0 a). rewrite <- H0. erewrite IHl; eauto.
+Qed.
+
+Lemma transf_initial_capture S1 S2 S2'
+    (INITSRC: initial_state prog S1)
+    (INITTGT: initial_state tprog S2)
+    (MATCH: match_states S1 S2)
+    (CAPTGT: glob_capture tprog S2 S2'):
+  exists S1', glob_capture prog S1 S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (concrete_snapshot ge S1') (concrete_snapshot tge S2').
+Proof.
+  specialize senv_preserved. intros SENVEQ.
+  inv CAPTGT. ss. rename m' into m2'.
+  rewrite Genv.globalenv_public in CAPTURE. erewrite <- same_public in CAPTURE; eauto.
+  inv MATCH. inv ARGS. inv STACKS.
+  exploit non_static_equiv. instantiate (1:=AST.prog_public prog). intros EQUIV.
+  assert (exists m1', Genv.capture_init_mem m0 (Genv.non_static_glob (Genv.globalenv prog) (AST.prog_public prog)) m1' /\
+                     Mem.extends m1' m2').
+  { clear LINK INITSRC INITTGT TFD.
+    rewrite <- EQUIV in CAPTURE. clear EQUIV. inv CAPTURE.
+    remember (Genv.non_static_glob (Genv.globalenv prog) (prog_public prog)) as l. clear Heql.
+    clear SENVEQ cu. move m0 after f. move l before f. revert_until f.
+    induction l; ss; i.
+    { inv CAP. esplits; eauto. econs. econs. }
+    inv CAP. exploit Mem.capture_extends_backward; eauto. i. des.
+    exploit IHl; eauto. i. des. inv H. esplits; eauto. econs. econs; eauto. }
+  des. esplits; eauto.
+  - econs. eauto. rewrite Genv.globalenv_public. eauto.
+  - econs; eauto. econs.
+  - ii. unfold concrete_snapshot in *. inv SENVEQ. des. erewrite H3, H2. des_ifs; ss.
+    eapply Mem.mext_concrete; eauto. eapply Mem.concrete_valid; eauto.
+Qed.
+
 Theorem transf_program_correct:
-  forward_simulation (RTL.semantics prog) (RTL.semantics tprog).
+  mixed_simulation (RTL.semantics prog) (RTL.semantics tprog).
 Proof.
-  eapply forward_simulation_step with
-    (match_states := fun s1 s2 => sound_state prog s1 /\ match_states s1 s2).
-- apply senv_preserved.
-- intros. exploit transf_initial_states; eauto. intros [s2 [A B]].
-  exists s2. split. auto. split. apply sound_initial; auto. auto.
-- intros. destruct H. eapply transf_final_states; eauto.
-- intros. destruct H0. exploit transf_step_correct; eauto.
-  intros [s2' [A B]]. exists s2'; split. auto. split. eapply sound_step; eauto. auto.
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (S a). lia.
+  - econs. i. exploit transf_initial_states; eauto. i. des.
+    exists st2. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. inversion INITSRC; subst. inversion H0; subst.
+      inv ARGS. inv STACKS.
+      exploit transf_initial_capture;
+      [eapply INITSRC|eapply H|eapply H0|eapply CAPTGT|]. i. des.
+      exists 0%nat. exists S1'. esplits; eauto. apply match_states_xsim; auto.
+      eapply sound_capture_initial; eauto.
+  - i. apply senv_preserved.
 Qed.
 
 End PRESERVATION.
diff --git a/backend/CleanupLabelsproof.v b/backend/CleanupLabelsproof.v
index fb8e57b7..ffbef618 100644
--- a/backend/CleanupLabelsproof.v
+++ b/backend/CleanupLabelsproof.v
@@ -15,9 +15,11 @@
 Require Import FSets.
 Require Import Coqlib Ordered Integers.
 Require Import AST Linking.
+Require Import CoqlibC Simulation LinearD PointerOp Classical.
 Require Import Values Memory Events Globalenvs Smallstep.
 Require Import Op Locations Linear.
 Require Import CleanupLabels.
+From Paco Require Import paco.
 
 Module LabelsetFacts := FSetFacts.Facts(Labelset).
 
@@ -37,6 +39,9 @@ Hypothesis TRANSL: match_prog prog tprog.
 Let ge := Genv.globalenv prog.
 Let tge := Genv.globalenv tprog.
 
+Let sem := Linear.semantics prog.
+Let tsem := Linear.semantics tprog.
+
 Lemma symbols_preserved:
   forall id,
   Genv.find_symbol tge id = Genv.find_symbol ge id.
@@ -230,51 +235,52 @@ Proof.
 Qed.
 
 Theorem transf_step_correct:
-  forall s1 t s2, step ge s1 t s2 ->
+  forall s1 t s2, IStep sem s1 t s2 ->
   forall s1' (MS: match_states s1 s1'),
-  (exists s2', step tge s1' t s2' /\ match_states s2 s2')
+  (exists s2', DStep tsem s1' t s2' /\ match_states s2 s2')
   \/ (measure s2 < measure s1 /\ t = E0 /\ match_states s2 s1')%nat.
 Proof.
+  destruct 1. generalize dependent s2. rename H into INT.
   induction 1; intros; inv MS; try rewrite remove_unused_labels_cons.
 (* Lgetstack *)
   left; econstructor; split.
-  econstructor; eauto.
+  DStep_tac. econstructor; eauto.
   econstructor; eauto with coqlib.
 (* Lsetstack *)
   left; econstructor; split.
-  econstructor; eauto.
+  DStep_tac. econstructor; eauto.
   econstructor; eauto with coqlib.
 (* Lop *)
   left; econstructor; split.
-  econstructor; eauto. instantiate (1 := v). rewrite <- H.
-  apply eval_operation_preserved. exact symbols_preserved.
+  DStep_tac. econstructor; eauto. instantiate (1 := v). rewrite <- H.
+  apply eval_operation_wrapper_preserved. exact symbols_preserved.
   econstructor; eauto with coqlib.
 (* Lload *)
   assert (eval_addressing tge sp addr (LTL.reglist rs args) = Some a).
     rewrite <- H. apply eval_addressing_preserved. exact symbols_preserved.
   left; econstructor; split.
-  econstructor; eauto.
+  DStep_tac. econstructor; eauto.
   econstructor; eauto with coqlib.
 (* Lstore *)
   assert (eval_addressing tge sp addr (LTL.reglist rs args) = Some a).
     rewrite <- H. apply eval_addressing_preserved. exact symbols_preserved.
   left; econstructor; split.
-  econstructor; eauto.
+  DStep_tac. econstructor; eauto.
   econstructor; eauto with coqlib.
 (* Lcall *)
   left; econstructor; split.
-  econstructor. eapply find_function_translated; eauto.
+  DStep_tac. econstructor. eapply find_function_translated; eauto.
   symmetry; apply sig_function_translated.
   econstructor; eauto. constructor; auto. constructor; eauto with coqlib.
 (* Ltailcall *)
   left; econstructor; split.
-  econstructor. erewrite match_parent_locset; eauto. eapply find_function_translated; eauto.
+  DStep_tac. econstructor. erewrite match_parent_locset; eauto. eapply find_function_translated; eauto.
   symmetry; apply sig_function_translated.
   simpl. eauto.
   econstructor; eauto.
 (* Lbuiltin *)
   left; econstructor; split.
-  econstructor.
+  DStep_tac. econstructor.
   eapply eval_builtin_args_preserved with (ge1 := ge); eauto. exact symbols_preserved.
   eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   eauto.
@@ -283,43 +289,43 @@ Proof.
   case_eq (Labelset.mem lbl (labels_branched_to (fn_code f))); intros.
   (* not eliminated *)
   left; econstructor; split.
-  constructor.
+  DStep_tac. constructor.
   econstructor; eauto with coqlib.
   (* eliminated *)
   right. split. simpl. lia. split. auto. econstructor; eauto with coqlib.
 (* Lgoto *)
   left; econstructor; split.
-  econstructor. eapply find_label_translated; eauto. red; auto.
+  DStep_tac. econstructor. eapply find_label_translated; eauto. red; auto.
   econstructor; eauto. eapply find_label_incl; eauto.
 (* Lcond taken *)
   left; econstructor; split.
-  econstructor. auto. eauto. eapply find_label_translated; eauto. red; auto.
+  DStep_tac. econstructor. auto. eauto. eapply find_label_translated; eauto. red; auto.
   econstructor; eauto. eapply find_label_incl; eauto.
 (* Lcond not taken *)
   left; econstructor; split.
-  eapply exec_Lcond_false; eauto.
+  DStep_tac. eapply exec_Lcond_false; eauto.
   econstructor; eauto with coqlib.
 (* Ljumptable *)
   left; econstructor; split.
-  econstructor. eauto. eauto. eapply find_label_translated; eauto.
+  DStep_tac. econstructor. eauto. eauto. eapply find_label_translated; eauto.
   red. eapply list_nth_z_in; eauto. eauto.
   econstructor; eauto. eapply find_label_incl; eauto.
 (* Lreturn *)
   left; econstructor; split.
-  econstructor; eauto.
+  DStep_tac. econstructor; eauto.
   erewrite <- match_parent_locset; eauto.
   econstructor; eauto with coqlib.
 (* internal function *)
   left; econstructor; split.
-  econstructor; simpl; eauto.
+  DStep_tac. econstructor; simpl; eauto.
   econstructor; eauto with coqlib.
 (* external function *)
   left; econstructor; split.
-  econstructor; eauto. eapply external_call_symbols_preserved; eauto. apply senv_preserved.
+  DStep_tac. econstructor; eauto. eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   econstructor; eauto with coqlib.
 (* return *)
   inv H3. inv H1. left; econstructor; split.
-  econstructor; eauto.
+  DStep_tac. econstructor; eauto.
   econstructor; eauto.
 Qed.
 
@@ -344,14 +350,104 @@ Proof.
   intros. inv H0. inv H. inv H5. econstructor; eauto.
 Qed.
 
+Lemma match_states_bsim
+      s1 (EXT: is_external ge s1)
+      s2 t s2' (STEPTGT: Step tsem s2 t s2')
+      (MATCH: match_states s1 s2)
+      (SAFESRC: safe sem s1) :
+    (exists s1', Step sem s1 t s1' /\ match_states s1' s2')
+  \/ (~ trace_intact t /\ exists s1'' t', Star sem s1 t' s1'' /\ exists tl, t' = (trace_cut_pterm t) ** tl).
+Proof.
+  assert (SEQUIV: Senv.equiv tge ge) by (symmetry; apply senv_preserved).
+  unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+  { inv SAFESRC. inv MATCH. inv H4. inv STEPTGT. }
+  inv MATCH; ss; des_ifs; try rewrite remove_unused_labels_cons in *.
+  (* builtin *)
+  - i. inv STEPTGT; ss; clarify. inv SAFESRC; clarify.
+    exploit eval_builtin_args_preserved; [eapply SEQUIV|eapply H10|].
+    i. exploit eval_builtin_args_determ. eapply H. eapply H12. i. subst.
+    left. esplits.
+    + econs; eauto. eapply external_call_symbols_preserved; eauto.
+    + econstructor; eauto with coqlib.
+  - i. inv STEPTGT; clarify. inv SAFESRC; clarify.
+    left. ss. clarify. esplits; eauto; [|econs; eauto].
+    econs; eauto. eapply external_call_symbols_preserved; eauto.
+Qed.
+
+Lemma match_states_xsim st_src0 st_tgt0 gmtgt
+    (MATCH: match_states st_src0 st_tgt0) :
+  xsim (Linear.semantics prog) (Linear.semantics tprog) gmtgt lt (measure st_src0) st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold. destruct (classic (is_external ge st_src0)); cycle 1.
+  (* not external *)
+  - left. econs. econs.
+    + i. exploit transf_step_correct; eauto. i. destruct H0.
+      * des; esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl|].
+        left. split; eauto; [eapply plus_one|eapply semantics_receptive_at]; eauto.
+      * des; esplits; eauto. eapply tr_rel_refl. eapply ev_rel_refl.
+    + ii. eapply final_state_determ; eauto. inv FINALSRC. inv MATCH. inv H5. econs; eauto.
+  (* external *)
+  - right. econs. i. econs.
+    + i. exploit match_states_bsim; eauto. i. des.
+      * left. esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl|].
+        left. eapply plus_one. eauto.
+      * right. esplits; eauto. subst. eapply tr_rel_refl. eapply ev_rel_refl.
+    + ii. inv FINALTGT. inv MATCH. inv H3. esplits. eapply star_refl. econs; eauto.
+    + i. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify; [inv SAFESRC;ss|].
+      right. inv MATCH; ss; des_ifs; inv SAFESRC; unfold ge in *; clarify.
+      * esplits. rewrite remove_unused_labels_cons. eapply exec_Lbuiltin; eauto.
+        { eapply eval_builtin_args_preserved. eapply senv_preserved. eauto. }
+        { eapply external_call_symbols_preserved; eauto. apply senv_preserved. }
+      * ss. clarify. esplits. eapply exec_function_external; eauto.
+        eapply external_call_symbols_preserved; eauto. apply senv_preserved.
+Qed.
+
+Lemma non_static_equiv l:
+  Genv.non_static_glob (Genv.globalenv prog) l = Genv.non_static_glob (Genv.globalenv tprog) l.
+Proof.
+  Local Transparent ge tge.
+  induction l; ss.
+  specialize senv_preserved. ss. i. inv H. inv H1. unfold ge, tge, fundef in *.
+  specialize (H a). unfold Senv.public_symbol in H. ss. erewrite H.
+  specialize (H0 a). rewrite <- H0. erewrite IHl; eauto.
+Qed.
+
+Lemma same_public: prog_public prog = prog_public tprog.
+Proof. inv TRANSL. des; eauto. Qed.
+
+Lemma transf_initial_capture S1 S2 S2'
+    (INITSRC: initial_state prog S1)
+    (INITTGT: initial_state tprog S2)
+    (MATCH: match_states S1 S2)
+    (CAPTGT: glob_capture tprog S2 S2'):
+  exists S1', glob_capture prog S1 S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (concrete_snapshot ge S1') (concrete_snapshot tge S2').
+Proof.
+  inv CAPTGT. ss. rewrite Genv.globalenv_public in CAPTURE.
+  rewrite <- same_public in CAPTURE. erewrite <- non_static_equiv in CAPTURE.
+  inv MATCH. inv H1. esplits.
+  - econs; eauto. rewrite Genv.globalenv_public. eauto.
+  - econs. econs.
+  - specialize senv_preserved. intros SENVEQ. destruct SENVEQ. des.
+    unfold concrete_snapshot. ii. erewrite H0, H. des_ifs; ss.
+Qed.
+
 Theorem transf_program_correct:
-  forward_simulation (Linear.semantics prog) (Linear.semantics tprog).
+  mixed_simulation (Linear.semantics prog) (Linear.semantics tprog).
 Proof.
-  eapply forward_simulation_opt.
-  apply senv_preserved.
-  eexact transf_initial_states.
-  eexact transf_final_states.
-  eexact transf_step_correct.
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (1 + a)%nat. lia.
+  - econs. i. exploit transf_initial_states; eauto. i. des.
+    exists st2. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. exploit transf_initial_capture; eauto. i. des. subst.
+      esplits; eauto. apply match_states_xsim; auto.
+  - i. apply senv_preserved.
 Qed.
 
 End CLEANUP.
diff --git a/backend/Cminor.v b/backend/Cminor.v
index 1618866e..640ec3c5 100644
--- a/backend/Cminor.v
+++ b/backend/Cminor.v
@@ -27,6 +27,7 @@ Require Import Memory.
 Require Import Globalenvs.
 Require Import Smallstep.
 Require Import Switch.
+Require Import Simulation IntPtrRel.
 
 (** * Abstract syntax *)
 
@@ -112,6 +113,7 @@ Inductive binary_operation : Type :=
   | Oshll: binary_operation                (**r long left shift *)
   | Oshrl: binary_operation                (**r long right signed shift *)
   | Oshrlu: binary_operation               (**r long right unsigned shift *)
+  | Opsub: binary_operation                (**r pointer subtraction *)
   | Ocmp: comparison -> binary_operation   (**r integer signed comparison *)
   | Ocmpu: comparison -> binary_operation  (**r integer unsigned comparison *)
   | Ocmpf: comparison -> binary_operation  (**r float64 comparison *)
@@ -336,6 +338,7 @@ Definition eval_binop
   | Oshll => Some (Val.shll arg1 arg2)
   | Oshrl => Some (Val.shrl arg1 arg2)
   | Oshrlu => Some (Val.shrlu arg1 arg2)
+  | Opsub => if Archi.ptr64 then Some (Val.psubl arg1 arg2) else Some (Val.psub arg1 arg2)
   | Ocmp c => Some (Val.cmp c arg1 arg2)
   | Ocmpu c => Some (Val.cmpu (Mem.valid_pointer m) c arg1 arg2)
   | Ocmpf c => Some (Val.cmpf c arg1 arg2)
@@ -344,6 +347,166 @@ Definition eval_binop
   | Ocmplu c => Val.cmplu (Mem.valid_pointer m) c arg1 arg2
   end.
 
+Definition ptr_binop (op: binary_operation) : bool :=
+  match op with
+  | Ocmpu _ => if negb Archi.ptr64 then true else false
+  | Opsub => true
+  | Ocmplu _ => if Archi.ptr64 then true else false
+  | _ => false
+  end.
+
+Definition eval_binop_join (op: binary_operation) (arg1 arg2: val) (m: mem): option val :=
+  val_optjoin (eval_binop op (to_ptr_val m arg1) (to_ptr_val m arg2) m)
+              (eval_binop op (to_int_val m arg1) (to_int_val m arg2) m).
+
+Lemma eval_binop_join_psubl_join
+  v1 v2 m v (SF: Archi.ptr64 = true):
+  eval_binop_join Opsub v1 v2 m = Some v <-> psubl_join m v1 v2 = v.
+Proof.
+  unfold eval_binop_join, val_optjoin, psubl_join. simpl. rewrite SF. simpl. split.
+  - i. inv H. eauto.
+  - i. rewrite H. eauto.
+Qed.
+
+Lemma eval_binop_join_psub_join
+  v1 v2 m v (SF: Archi.ptr64 = false):
+  eval_binop_join Opsub v1 v2 m = Some v <-> psub_join m v1 v2 = v.
+Proof.
+  unfold eval_binop_join, val_optjoin, psub_join. simpl. rewrite SF. simpl. split.
+  - i. inv H. eauto.
+  - i. rewrite H. eauto.
+Qed.
+
+Lemma eval_binop_join_cmplu_join1 c v1 v2 m v
+  (SF: Archi.ptr64 = true)
+  (CMP: eval_binop_join (Ocmplu c) v1 v2 m = Some v) :
+  exists b, cmplu_join m c v1 v2 = Some b /\ v = Val.of_bool b.
+Proof.
+  unfold eval_binop_join, val_optjoin, cmplu_join, val_join in *. simpl in *.
+  unfold Val.cmplu in *. unfold bool_optjoin, opt_join in *.
+  destruct (Val.cmplu_bool (Mem.valid_pointer m) c (to_ptr_val m v1) (to_ptr_val m v2)) eqn:PCMP.
+  - destruct (Val.cmplu_bool (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2)) eqn:ICMP.
+    { exploit cmplu_no_angelic; eauto. i. des; subst. simpl in *.
+      destruct b0; simpl in *; rewrite Int.eq_true in *; eauto.
+      - inv CMP. exists true. simpl. ss.
+      - inv CMP. exists false. simpl. ss. }
+    simpl in *. inv CMP. esplits; eauto.
+  - destruct (Val.cmplu_bool (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2)) eqn:ICMP; [|ss].
+    simpl in *. inv CMP. esplits; eauto.
+Qed.
+
+Lemma eval_binop_join_cmplu_join2
+  c v1 v2 m b
+  (SF: Archi.ptr64 = true)
+  (CMP: cmplu_join m c v1 v2 = Some b)
+  :
+  exists v, eval_binop_join (Ocmplu c) v1 v2 m = Some v /\ v = Val.of_bool b.
+Proof.
+  unfold eval_binop_join, val_optjoin, cmplu_join, val_join in *. simpl in *.
+  unfold Val.cmplu in *. unfold bool_optjoin, opt_join in *.
+  destruct (Val.cmplu_bool (Mem.valid_pointer m) c (to_ptr_val m v1) (to_ptr_val m v2)) eqn:PCMP.
+  - destruct (Val.cmplu_bool (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2)) eqn:ICMP.
+    { exploit cmplu_no_angelic; eauto. i. des; subst. simpl in *.
+      rewrite bool_join_angelic in CMP; eauto. inv CMP. destruct b; simpl in *; rewrite Int.eq_true in *; eauto. }
+    simpl in *. inv CMP. esplits; eauto.
+  - destruct (Val.cmplu_bool (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2)) eqn:ICMP; [|ss].
+    simpl in *. inv CMP. esplits; eauto.
+Qed.
+
+Lemma eval_binop_join_cmpu_join1 c v1 v2 m v
+  (SF: Archi.ptr64 = false)
+  (CMP: eval_binop_join (Ocmpu c) v1 v2 m = Some v) :
+  exists b, cmpu_join m c v1 v2 = Some b /\ v = Val.of_bool b.
+Proof.
+  unfold eval_binop_join, val_optjoin, cmpu_join, val_join in *. simpl in *.
+  unfold Val.cmpu in *. unfold bool_optjoin, opt_join in *.
+  destruct (Val.cmpu_bool (Mem.valid_pointer m) c (to_ptr_val m v1) (to_ptr_val m v2)) eqn:PCMP.
+  - destruct (Val.cmpu_bool (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2)) eqn:ICMP.
+    { exploit cmpu_no_angelic; eauto. i. des; subst. simpl in *.
+      destruct b0; simpl in *; rewrite Int.eq_true in *; eauto.
+      - inv CMP. exists true. simpl. ss.
+      - inv CMP. exists false. simpl. ss. }
+    simpl in *. inv CMP. esplits; eauto. destruct b; simpl; auto.
+  - destruct (Val.cmpu_bool (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2)) eqn:ICMP; [|ss].
+    simpl in *. inv CMP. esplits; auto.
+Qed.
+
+Lemma eval_binop_join_cmpu_join2 c v1 v2 m b
+  (SF: Archi.ptr64 = false)
+  (CMP: cmpu_join m c v1 v2 = Some b) :
+  exists v, eval_binop_join (Ocmpu c) v1 v2 m = Some v /\ v = Val.of_bool b.
+Proof.
+  unfold eval_binop_join, val_optjoin, cmpu_join, val_join in *. simpl in *.
+  unfold Val.cmpu in *. unfold bool_optjoin, opt_join in *.
+  destruct (Val.cmpu_bool (Mem.valid_pointer m) c (to_ptr_val m v1) (to_ptr_val m v2)) eqn:PCMP.
+  - destruct (Val.cmpu_bool (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2)) eqn:ICMP.
+    { exploit cmpu_no_angelic; eauto. i. des; subst. simpl in *.
+      rewrite bool_join_angelic in CMP; eauto. inv CMP. destruct b; ss; rewrite Int.eq_true in *; eauto. }
+    simpl in *. inv CMP. esplits; eauto. destruct b; simpl; auto.
+  - destruct (Val.cmpu_bool (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2)) eqn:ICMP; [|ss].
+    simpl in *. inv CMP. esplits; auto.
+Qed.
+
+Definition psub_join_cminor (arg1 arg2: val) (m:mem) :=
+  if Archi.ptr64 then psubl_join_common m arg1 arg2 else psub_join_common m arg1 arg2.
+
+Definition eval_binop_wrapper (op: binary_operation) (arg1 arg2: val) (m: mem): option val :=
+  if ptr_binop op then
+    match op with
+    | Opsub => Some (psub_join_cminor arg1 arg2 m)
+    | Ocmpu c => Some (Val.of_optbool (match arg1, arg2 with
+                                      | Vptr _ _, Vptr _ _ | Vint _, Vint _ => Val.cmpu_bool (Mem.valid_pointer m) c arg1 arg2
+                                      | Vptr _ _, Vint n | Vint n, Vptr _ _ => if Int.eq n Int.zero
+                                                                              then Val.cmpu_bool (Mem.valid_pointer m) c arg1 arg2
+                                                                              else cmpu_join m c arg1 arg2
+                                      | _, _ => None
+                                      end))
+    | Ocmplu c => option_map Val.of_bool
+                   (match arg1, arg2 with
+                    | Vptr _ _, Vptr _ _ | Vlong _, Vlong _ => Val.cmplu_bool (Mem.valid_pointer m) c arg1 arg2
+                    | Vptr _ _, Vlong n | Vlong n, Vptr _ _ => if Int64.eq n Int64.zero
+                                                              then Val.cmplu_bool (Mem.valid_pointer m) c arg1 arg2
+                                                              else cmplu_join m c arg1 arg2
+                    | _, _ => None
+                    end)
+    | _ => None
+    end
+  else eval_binop op arg1 arg2 m.
+
+Lemma eval_binop_no_ptr_binop op arg1 arg2 m
+    (NOPTRBIN: ptr_binop op = false) :
+  <<SAME: eval_binop_wrapper op arg1 arg2 m = eval_binop op arg1 arg2 m>>.
+Proof. unfold eval_binop_wrapper in *. rewrite NOPTRBIN in *. eauto. Qed.
+
+Lemma eval_binop_join_no_angelic op arg1 arg2 m v1 v2
+    (PTRBIN: ptr_binop op = true)
+    (EVAL1: eval_binop op (to_ptr_val m arg1) (to_ptr_val m arg2) m = Some v1)
+    (EVAL2: eval_binop op (to_int_val m arg1) (to_int_val m arg2) m = Some v2) :
+  <<NOANGELIC: v1 = Vundef \/ v2 = Vundef \/ v1 = v2>>.
+Proof.
+  destruct Archi.ptr64 eqn:SF; unfold ptr_binop in *; rewrite SF in PTRBIN; simpl in *.
+  - destruct op; simpl in *; inv PTRBIN; r.
+    + rewrite SF in *. inversion EVAL1; inversion EVAL2.
+      exploit psubl_wrapper_no_angelic; eauto. i; des; subst; eauto.
+    + inv EVAL1. inv EVAL2. exploit cmplu_no_angelic'; eauto.
+  - destruct op; simpl in *; inv PTRBIN.
+    + rewrite SF in *. inversion EVAL1; inversion EVAL2.
+      exploit psub_wrapper_no_angelic; eauto. i; des; subst; eauto.
+    + inv EVAL1. inv EVAL2. eapply cmpu_no_angelic'; eauto.
+Qed.
+
+Lemma eval_binop_int_cmpu c n1 n2 n m
+    (EVAL: eval_binop (Ocmpu c) (Vint n1) (Vint n2) m = Some (Vint n)) :
+  <<WRAPPER: eval_binop_wrapper (Ocmpu c) (Vint n1) (Vint n2) m = Some (Vint n)>>.
+Proof.
+  destruct (ptr_binop (Ocmpu c)) eqn:PTRBIN; cycle 1.
+  { erewrite eval_binop_no_ptr_binop; eauto. }
+  assert (eval_binop (Ocmpu c) (to_int_val m (Vint n1)) (to_int_val m (Vint n2)) m = Some (Vint n)).
+  { unfold to_int_val. ss. }
+  unfold eval_binop_wrapper, eval_binop_join. rewrite PTRBIN.
+  unfold to_int_val in H. simpl in *. inv H. eauto.
+Qed.
+      
 (** Evaluation of an expression: [eval_expr ge sp e m a v]
   states that expression [a] evaluates to value [v].
   [ge] is the global environment, [e] the local environment,
@@ -372,7 +535,7 @@ Inductive eval_expr: expr -> val -> Prop :=
   | eval_Ebinop: forall op a1 a2 v1 v2 v,
       eval_expr a1 v1 ->
       eval_expr a2 v2 ->
-      eval_binop op v1 v2 m = Some v ->
+      eval_binop_wrapper op v1 v2 m = Some v ->
       eval_expr (Ebinop op a1 a2) v
   | eval_Eload: forall chunk addr vaddr v,
       eval_expr addr vaddr ->
@@ -563,21 +726,58 @@ Inductive initial_state (p: program): state -> Prop :=
       funsig f = signature_main ->
       initial_state p (Callstate f nil Kstop m0).
 
+Inductive glob_capture (p: program) : state -> state -> Prop :=
+  | glob_capture_intro
+      f m pbs m'
+      (NONSTATIC: Genv.non_static_glob (Genv.globalenv p) (Genv.genv_public (Genv.globalenv p)) = pbs)
+      (CAPTURE: Genv.capture_init_mem m pbs m') :
+    glob_capture p (Callstate f nil Kstop m) (Callstate f nil Kstop m').
+
+Definition state_mem (st: state) : mem :=
+  match st with
+  | State _ _ _ _ _ m => m
+  | Callstate _ _ _ m => m
+  | Returnstate _ _ m => m
+  end.
+
+Definition concrete_snapshot (ge: Senv.t) (st: state) (id: ident) : option Z :=
+  if Senv.public_symbol ge id
+  then (match Senv.find_symbol ge id with
+        | Some b => Maps.PTree.get b (state_mem st).(Mem.mem_concrete)
+        | None => None
+        end)
+  else None.
+
 (** A final state is a [Returnstate] with an empty continuation. *)
 
 Inductive final_state: state -> int -> Prop :=
   | final_state_intro: forall r m,
       final_state (Returnstate (Vint r) Kstop m) r.
 
+(** Non-deterministic external state *)
+
+Definition is_external (ge: genv) (s:state) : Prop :=
+  match s with
+  | State f s k e le m => match s with
+                         | Sbuiltin optid ef al => is_external_ef ef
+                         | _ => False
+                         end
+  | Callstate f args k m => match f with
+                           | External ef => is_external_ef ef
+                           | _ => False
+                           end
+  | _ => False
+  end.
+
 (** The corresponding small-step semantics. *)
 
 Definition semantics (p: program) :=
-  Semantics step (initial_state p) final_state (Genv.globalenv p).
+  Semantics step (initial_state p) (glob_capture p) (concrete_snapshot (Genv.globalenv p)) final_state is_external (Genv.globalenv p).
 
 (** This semantics is receptive to changes in events. *)
 
 Lemma semantics_receptive:
-  forall (p: program), receptive (semantics p).
+forall (p: program) s (INT: ~ is_external (Genv.globalenv p) s), receptive_at (semantics p) s.
 Proof.
   intros. constructor; simpl; intros.
 (* receptiveness *)
@@ -632,28 +832,24 @@ Ltac Determ :=
   end.
 
 Lemma semantics_determinate:
-  forall (p: program), determinate (semantics p).
+  forall (p: program) s (INT: ~ is_external (Genv.globalenv p) s), deterministic_at (semantics p) s.
 Proof.
   intros. constructor; set (ge := Genv.globalenv p); simpl; intros.
 - (* determ *)
-  inv H; inv H0; Determ.
-  + subst vargs0. exploit external_call_determ. eexact H2. eexact H13.
-    intros (A & B). split; intros; auto.
-    apply B in H; destruct H; congruence.
-  + subst v0. assert (b0 = b) by (inv H2; inv H13; auto). subst b0; auto.
-  + assert (n0 = n) by (inv H2; inv H14; auto). subst n0; auto.
-  + exploit external_call_determ. eexact H1. eexact H7.
-    intros (A & B). split; intros; auto.
-    apply B in H; destruct H; congruence.
+  inv STEP0; inv STEP1; Determ; try by (clarify; subst; esplits; eauto).
+  + subst vargs0. exploit external_call_determ. eauto. eexact H0. eexact H12.
+    intros (A & B & C). split; intros; auto.
+    subst; eauto.
+  + subst v0. assert (b0 = b) by (inv H0; inv H12; auto). subst b0; auto.
+  + assert (n0 = n) by (inv H0; inv H13; auto). subst n0; auto.
+  + erewrite H in H6. clarify.
+  + exploit external_call_determ. eauto. eexact H. eexact H6.
+    intros (A & B & C). split; intros; auto.
+    subst; eauto.
+- inv FINAL. inv STEP.
 - (* single event *)
   red; simpl. destruct 1; simpl; try lia;
   eapply external_call_trace_length; eauto.
-- (* initial states *)
-  inv H; inv H0. unfold ge0, ge1 in *. congruence.
-- (* nostep final state *)
-  red; intros; red; intros. inv H; inv H0.
-- (* final states *)
-  inv H; inv H0; auto.
 Qed.
 
 (** * Alternate operational semantics (big-step) *)
@@ -909,339 +1105,343 @@ End NATURALSEM.
 
 (** Big-step execution of a whole program *)
 
-Inductive bigstep_program_terminates (p: program): trace -> int -> Prop :=
-  | bigstep_program_terminates_intro:
-      forall b f m0 t m r,
-      let ge := Genv.globalenv p in
-      Genv.init_mem p = Some m0 ->
-      Genv.find_symbol ge p.(prog_main) = Some b ->
-      Genv.find_funct_ptr ge b = Some f ->
-      funsig f = signature_main ->
-      eval_funcall ge m0 f nil t m (Vint r) ->
-      bigstep_program_terminates p t r.
-
-Inductive bigstep_program_diverges (p: program): traceinf -> Prop :=
-  | bigstep_program_diverges_intro:
-      forall b f m0 t,
-      let ge := Genv.globalenv p in
-      Genv.init_mem p = Some m0 ->
-      Genv.find_symbol ge p.(prog_main) = Some b ->
-      Genv.find_funct_ptr ge b = Some f ->
-      funsig f = signature_main ->
-      evalinf_funcall ge m0 f nil t ->
-      bigstep_program_diverges p t.
-
-Definition bigstep_semantics (p: program) :=
-  Bigstep_semantics (bigstep_program_terminates p) (bigstep_program_diverges p).
-
-(** ** Correctness of the big-step semantics with respect to the transition semantics *)
-
-Section BIGSTEP_TO_TRANSITION.
-
-Variable prog: program.
-Let ge := Genv.globalenv prog.
-
-Inductive outcome_state_match
-        (sp: val) (e: env) (m: mem) (f: function) (k: cont):
-        outcome -> state -> Prop :=
-  | osm_normal:
-      outcome_state_match sp e m f k
-                          Out_normal
-                          (State f Sskip k sp e m)
-  | osm_exit: forall n,
-      outcome_state_match sp e m f k
-                          (Out_exit n)
-                          (State f (Sexit n) k sp e m)
-  | osm_return_none: forall k',
-      call_cont k' = call_cont k ->
-      outcome_state_match sp e m f k
-                          (Out_return None)
-                          (State f (Sreturn None) k' sp e m)
-  | osm_return_some: forall k' a v,
-      call_cont k' = call_cont k ->
-      eval_expr ge sp e m a v ->
-      outcome_state_match sp e m f k
-                          (Out_return (Some v))
-                          (State f (Sreturn (Some a)) k' sp e m)
-  | osm_tail: forall v,
-      outcome_state_match sp e m f k
-                          (Out_tailcall_return v)
-                          (Returnstate v (call_cont k) m).
-
-Remark is_call_cont_call_cont:
-  forall k, is_call_cont (call_cont k).
-Proof.
-  induction k; simpl; auto.
-Qed.
-
-Remark call_cont_is_call_cont:
-  forall k, is_call_cont k -> call_cont k = k.
-Proof.
-  destruct k; simpl; intros; auto || contradiction.
-Qed.
-
-Lemma eval_funcall_exec_stmt_steps:
-  (forall m fd args t m' res,
-   eval_funcall ge m fd args t m' res ->
-   forall k,
-   is_call_cont k ->
-   star step ge (Callstate fd args k m)
-              t (Returnstate res k m'))
-/\(forall f sp e m s t e' m' out,
-   exec_stmt ge f sp e m s t e' m' out ->
-   forall k,
-   exists S,
-   star step ge (State f s k sp e m) t S
-   /\ outcome_state_match sp e' m' f k out S).
-Proof.
-  apply eval_funcall_exec_stmt_ind2; intros.
-
-(* funcall internal *)
-  destruct (H2 k) as [S [A B]].
-  assert (call_cont k = k) by (apply call_cont_is_call_cont; auto).
-  eapply star_left. econstructor; eauto.
-  eapply star_trans. eexact A.
-  inversion B; clear B; subst out; simpl in H3; simpl; try contradiction.
-  (* Out normal *)
-  subst vres. apply star_one. apply step_skip_call; auto.
-  (* Out_return None *)
-  subst vres. replace k with (call_cont k') by congruence.
-  apply star_one. apply step_return_0; auto.
-  (* Out_return Some *)
-  subst vres.
-  replace k with (call_cont k') by congruence.
-  apply star_one. eapply step_return_1; eauto.
-  (* Out_tailcall_return *)
-  subst vres. red in H4. subst m3. rewrite H6. apply star_refl.
-
-  reflexivity. traceEq.
-
-(* funcall external *)
-  apply star_one. constructor; auto.
-
-(* skip *)
-  econstructor; split.
-  apply star_refl.
-  constructor.
-
-(* assign *)
-  exists (State f Sskip k sp (PTree.set id v e) m); split.
-  apply star_one. constructor. auto.
-  constructor.
-
-(* store *)
-  econstructor; split.
-  apply star_one. econstructor; eauto.
-  constructor.
-
-(* call *)
-  econstructor; split.
-  eapply star_left. econstructor; eauto.
-  eapply star_right. apply H4. red; auto.
-  constructor. reflexivity. traceEq.
-  subst e'. constructor.
-
-(* builtin *)
-  econstructor; split.
-  apply star_one. econstructor; eauto.
-  subst e'. constructor.
-
-(* ifthenelse *)
-  destruct (H2 k) as [S [A B]].
-  exists S; split.
-  apply star_left with E0 (State f (if b then s1 else s2) k sp e m) t.
-  econstructor; eauto. exact A.
-  traceEq.
-  auto.
-
-(* seq continue *)
-  destruct (H0 (Kseq s2 k)) as [S1 [A1 B1]].
-  destruct (H2 k) as [S2 [A2 B2]].
-  inv B1.
-  exists S2; split.
-  eapply star_left. constructor.
-  eapply star_trans. eexact A1.
-  eapply star_left. constructor. eexact A2.
-  reflexivity. reflexivity. traceEq.
-  auto.
-
-(* seq stop *)
-  destruct (H0 (Kseq s2 k)) as [S1 [A1 B1]].
-  set (S2 :=
-    match out with
-    | Out_exit n => State f (Sexit n) k sp e1 m1
-    | _ => S1
-    end).
-  exists S2; split.
-  eapply star_left. constructor. eapply star_trans. eexact A1.
-  unfold S2; destruct out; try (apply star_refl).
-  inv B1. apply star_one. constructor.
-  reflexivity. traceEq.
-  unfold S2; inv B1; congruence || simpl; constructor; auto.
-
-(* loop loop *)
-  destruct (H0 (Kseq (Sloop s) k)) as [S1 [A1 B1]].
-  destruct (H2 k) as [S2 [A2 B2]].
-  inv B1.
-  exists S2; split.
-  eapply star_left. constructor.
-  eapply star_trans. eexact A1.
-  eapply star_left. constructor. eexact A2.
-  reflexivity. reflexivity. traceEq.
-  auto.
-
-(* loop stop *)
-  destruct (H0 (Kseq (Sloop s) k)) as [S1 [A1 B1]].
-  set (S2 :=
-    match out with
-    | Out_exit n => State f (Sexit n) k sp e1 m1
-    | _ => S1
-    end).
-  exists S2; split.
-  eapply star_left. constructor. eapply star_trans. eexact A1.
-  unfold S2; destruct out; try (apply star_refl).
-  inv B1. apply star_one. constructor.
-  reflexivity. traceEq.
-  unfold S2; inv B1; congruence || simpl; constructor; auto.
-
-(* block *)
-  destruct (H0 (Kblock k)) as [S1 [A1 B1]].
-  set (S2 :=
-    match out with
-    | Out_normal => State f Sskip k sp e1 m1
-    | Out_exit O => State f Sskip k sp e1 m1
-    | Out_exit (S m) => State f (Sexit m) k sp e1 m1
-    | _ => S1
-    end).
-  exists S2; split.
-  eapply star_left. constructor. eapply star_trans. eexact A1.
-  unfold S2; destruct out; try (apply star_refl).
-  inv B1. apply star_one. constructor.
-  inv B1. apply star_one. destruct n; constructor.
-  reflexivity. traceEq.
-  unfold S2; inv B1; simpl; try constructor; auto.
-  destruct n; constructor.
-
-(* exit *)
-  econstructor; split. apply star_refl. constructor.
-
-(* switch *)
-  econstructor; split.
-  apply star_one. econstructor; eauto. constructor.
-
-(* return none *)
-  econstructor; split. apply star_refl. constructor; auto.
-
-(* return some *)
-  econstructor; split. apply star_refl. constructor; auto.
-
-(* tailcall *)
-  econstructor; split.
-  eapply star_left. econstructor; eauto.
-  apply H5. apply is_call_cont_call_cont. traceEq.
-  econstructor.
-Qed.
-
-Lemma eval_funcall_steps:
-   forall m fd args t m' res,
-   eval_funcall ge m fd args t m' res ->
-   forall k,
-   is_call_cont k ->
-   star step ge (Callstate fd args k m)
-              t (Returnstate res k m').
-Proof (proj1 eval_funcall_exec_stmt_steps).
-
-Lemma exec_stmt_steps:
-   forall f sp e m s t e' m' out,
-   exec_stmt ge f sp e m s t e' m' out ->
-   forall k,
-   exists S,
-   star step ge (State f s k sp e m) t S
-   /\ outcome_state_match sp e' m' f k out S.
-Proof (proj2 eval_funcall_exec_stmt_steps).
-
-Lemma evalinf_funcall_forever:
-  forall m fd args T k,
-  evalinf_funcall ge m fd args T ->
-  forever_plus step ge (Callstate fd args k m) T.
-Proof.
-  cofix CIH_FUN.
-  assert (forall sp e m s T f k,
-          execinf_stmt ge f sp e m s T ->
-          forever_plus step ge (State f s k sp e m) T).
-  cofix CIH_STMT.
-  intros. inv H.
-
-(* call *)
-  eapply forever_plus_intro.
-  apply plus_one. econstructor; eauto.
-  apply CIH_FUN. eauto. traceEq.
-
-(* ifthenelse *)
-  eapply forever_plus_intro with (s2 := State f (if b then s1 else s2) k sp e m).
-  apply plus_one. econstructor; eauto.
-  apply CIH_STMT. eauto. traceEq.
-
-(* seq 1 *)
-  eapply forever_plus_intro.
-  apply plus_one. constructor.
-  apply CIH_STMT. eauto. traceEq.
-
-(* seq 2 *)
-  destruct (exec_stmt_steps _ _ _ _ _ _ _ _ _ H0 (Kseq s2 k))
-  as [S [A B]]. inv B.
-  eapply forever_plus_intro.
-  eapply plus_left. constructor.
-  eapply star_right. eexact A. constructor.
-  reflexivity. reflexivity.
-  apply CIH_STMT. eauto. traceEq.
-
-(* loop body *)
-  eapply forever_plus_intro.
-  apply plus_one. econstructor; eauto.
-  apply CIH_STMT. eauto. traceEq.
-
-(* loop loop *)
-  destruct (exec_stmt_steps _ _ _ _ _ _ _ _ _ H0 (Kseq (Sloop s0) k))
-  as [S [A B]]. inv B.
-  eapply forever_plus_intro.
-  eapply plus_left. constructor.
-  eapply star_right. eexact A. constructor.
-  reflexivity. reflexivity.
-  apply CIH_STMT. eauto. traceEq.
-
-(* block *)
-  eapply forever_plus_intro.
-  apply plus_one. econstructor; eauto.
-  apply CIH_STMT. eauto. traceEq.
-
-(* tailcall *)
-  eapply forever_plus_intro.
-  apply plus_one. econstructor; eauto.
-  apply CIH_FUN. eauto. traceEq.
-
-(* function call *)
-  intros. inv H0.
-  eapply forever_plus_intro.
-  apply plus_one. econstructor; eauto.
-  apply H. eauto.
-  traceEq.
-Qed.
-
-Theorem bigstep_semantics_sound:
-  bigstep_sound (bigstep_semantics prog) (semantics prog).
-Proof.
-  constructor; intros.
-(* termination *)
-  inv H. econstructor; econstructor.
-  split. econstructor; eauto.
-  split. apply eval_funcall_steps. eauto. red; auto.
-  econstructor.
-(* divergence *)
-  inv H. econstructor.
-  split. econstructor; eauto.
-  eapply forever_plus_forever.
-  eapply evalinf_funcall_forever; eauto.
-Qed.
-
-End BIGSTEP_TO_TRANSITION.
+(* Inductive bigstep_program_terminates (p: program): trace -> int -> Prop := *)
+(*   | bigstep_program_terminates_intro: *)
+(*       forall b f m0 t m r, *)
+(*       let ge := Genv.globalenv p in *)
+(*       Genv.init_mem p = Some m0 -> *)
+(*       Genv.find_symbol ge p.(prog_main) = Some b -> *)
+(*       Genv.find_funct_ptr ge b = Some f -> *)
+(*       funsig f = signature_main -> *)
+(*       eval_funcall ge m0 f nil t m (Vint r) -> *)
+(*       bigstep_program_terminates p t r. *)
+
+(* Inductive bigstep_program_diverges (p: program): traceinf -> Prop := *)
+(*   | bigstep_program_diverges_intro: *)
+(*       forall b f m0 t, *)
+(*       let ge := Genv.globalenv p in *)
+(*       Genv.init_mem p = Some m0 -> *)
+(*       Genv.find_symbol ge p.(prog_main) = Some b -> *)
+(*       Genv.find_funct_ptr ge b = Some f -> *)
+(*       funsig f = signature_main -> *)
+(*       evalinf_funcall ge m0 f nil t -> *)
+(*       bigstep_program_diverges p t. *)
+
+(* Definition bigstep_semantics (p: program) := *)
+(*   Bigstep_semantics (bigstep_program_terminates p) (bigstep_program_diverges p). *)
+
+(* (** ** Correctness of the big-step semantics with respect to the transition semantics *) *)
+
+(* Section BIGSTEP_TO_TRANSITION. *)
+
+(* Variable prog: program. *)
+(* Let ge := Genv.globalenv prog. *)
+
+(* Inductive outcome_state_match *)
+(*         (sp: val) (e: env) (m: mem) (f: function) (k: cont): *)
+(*         outcome -> state -> Prop := *)
+(*   | osm_normal: *)
+(*       outcome_state_match sp e m f k *)
+(*                           Out_normal *)
+(*                           (State f Sskip k sp e m) *)
+(*   | osm_exit: forall n, *)
+(*       outcome_state_match sp e m f k *)
+(*                           (Out_exit n) *)
+(*                           (State f (Sexit n) k sp e m) *)
+(*   | osm_return_none: forall k', *)
+(*       call_cont k' = call_cont k -> *)
+(*       outcome_state_match sp e m f k *)
+(*                           (Out_return None) *)
+(*                           (State f (Sreturn None) k' sp e m) *)
+(*   | osm_return_some: forall k' a v, *)
+(*       call_cont k' = call_cont k -> *)
+(*       eval_expr ge sp e m a v -> *)
+(*       outcome_state_match sp e m f k *)
+(*                           (Out_return (Some v)) *)
+(*                           (State f (Sreturn (Some a)) k' sp e m) *)
+(*   | osm_tail: forall v, *)
+(*       outcome_state_match sp e m f k *)
+(*                           (Out_tailcall_return v) *)
+(*                           (Returnstate v (call_cont k) m). *)
+
+(* Remark is_call_cont_call_cont: *)
+(*   forall k, is_call_cont (call_cont k). *)
+(* Proof. *)
+(*   induction k; simpl; auto. *)
+(* Qed. *)
+
+(* Remark call_cont_is_call_cont: *)
+(*   forall k, is_call_cont k -> call_cont k = k. *)
+(* Proof. *)
+(*   destruct k; simpl; intros; auto || contradiction. *)
+(* Qed. *)
+
+(* Lemma eval_funcall_exec_stmt_steps: *)
+(*   (forall m fd args t m' res, *)
+(*    eval_funcall ge m fd args t m' res -> *)
+(*    forall k, *)
+(*    is_call_cont k -> *)
+(*    star step ge (Callstate fd args k m) *)
+(*               t (Returnstate res k m')) *)
+(* /\(forall f sp e m s t e' m' out, *)
+(*    exec_stmt ge f sp e m s t e' m' out -> *)
+(*    forall k, *)
+(*    exists S, *)
+(*    star step ge (State f s k sp e m) t S *)
+(*    /\ outcome_state_match sp e' m' f k out S). *)
+(* Proof. *)
+(*   apply eval_funcall_exec_stmt_ind2; intros. *)
+
+(* (* funcall internal *) *)
+(*   destruct (H2 k) as [S [A B]]. *)
+(*   assert (call_cont k = k) by (apply call_cont_is_call_cont; auto). *)
+(*   eapply star_left. econstructor; eauto. *)
+(*   eapply star_trans. eexact A. *)
+(*   inversion B; clear B; subst out; simpl in H3; simpl; try contradiction. *)
+(*   (* Out normal *) *)
+(*   subst vres. apply star_one. apply step_skip_call; auto. *)
+(*   (* Out_return None *) *)
+(*   subst vres. replace k with (call_cont k') by congruence. *)
+(*   apply star_one. apply step_return_0; auto. *)
+(*   (* Out_return Some *) *)
+(*   subst vres. *)
+(*   replace k with (call_cont k') by congruence. *)
+(*   apply star_one. eapply step_return_1; eauto. *)
+(*   (* Out_tailcall_return *) *)
+(*   subst vres. red in H4. subst m3. rewrite H6. apply star_refl. *)
+
+(*   reflexivity. traceEq. *)
+
+(* (* funcall external *) *)
+(*   apply star_one. constructor; auto. *)
+
+(* (* skip *) *)
+(*   econstructor; split. *)
+(*   apply star_refl. *)
+(*   constructor. *)
+
+(* (* assign *) *)
+(*   exists (State f Sskip k sp (PTree.set id v e) m); split. *)
+(*   apply star_one. constructor. auto. *)
+(*   constructor. *)
+
+(* (* store *) *)
+(*   econstructor; split. *)
+(*   apply star_one. econstructor; eauto. *)
+(*   constructor. *)
+
+(* (* call *) *)
+(*   econstructor; split. *)
+(*   eapply star_left. econstructor; eauto. *)
+(*   eapply star_right. apply H4. red; auto. *)
+(*   constructor. reflexivity. traceEq. *)
+(*   subst e'. constructor. *)
+
+(* (* builtin *) *)
+(*   econstructor; split. *)
+(*   apply star_one. econstructor; eauto. *)
+(*   subst e'. constructor. *)
+
+(* (* ifthenelse *) *)
+(*   destruct (H2 k) as [S [A B]]. *)
+(*   exists S; split. *)
+(*   apply star_left with E0 (State f (if b then s1 else s2) k sp e m) t. *)
+(*   econstructor; eauto. exact A. *)
+(*   traceEq. *)
+(*   auto. *)
+
+(* (* seq continue *) *)
+(*   destruct (H0 (Kseq s2 k)) as [S1 [A1 B1]]. *)
+(*   destruct (H2 k) as [S2 [A2 B2]]. *)
+(*   inv B1. *)
+(*   exists S2; split. *)
+(*   eapply star_left. constructor. *)
+(*   eapply star_trans. eexact A1. *)
+(*   eapply star_left. constructor. eexact A2. *)
+(*   reflexivity. reflexivity. traceEq. *)
+(*   auto. *)
+
+(* (* seq stop *) *)
+(*   destruct (H0 (Kseq s2 k)) as [S1 [A1 B1]]. *)
+(*   set (S2 := *)
+(*     match out with *)
+(*     | Out_exit n => State f (Sexit n) k sp e1 m1 *)
+(*     | _ => S1 *)
+(*     end). *)
+(*   exists S2; split. *)
+(*   eapply star_left. constructor. eapply star_trans. eexact A1. *)
+(*   unfold S2; destruct out; try (apply star_refl). *)
+(*   inv B1. apply star_one. constructor. *)
+(*   reflexivity. traceEq. *)
+(*   unfold S2; inv B1; congruence || simpl; constructor; auto. *)
+
+(* (* loop loop *) *)
+(*   destruct (H0 (Kseq (Sloop s) k)) as [S1 [A1 B1]]. *)
+(*   destruct (H2 k) as [S2 [A2 B2]]. *)
+(*   inv B1. *)
+(*   exists S2; split. *)
+(*   eapply star_left. constructor. *)
+(*   eapply star_trans. eexact A1. *)
+(*   eapply star_left. constructor. eexact A2. *)
+(*   reflexivity. reflexivity. traceEq. *)
+(*   auto. *)
+
+(* (* loop stop *) *)
+(*   destruct (H0 (Kseq (Sloop s) k)) as [S1 [A1 B1]]. *)
+(*   set (S2 := *)
+(*     match out with *)
+(*     | Out_exit n => State f (Sexit n) k sp e1 m1 *)
+(*     | _ => S1 *)
+(*     end). *)
+(*   exists S2; split. *)
+(*   eapply star_left. constructor. eapply star_trans. eexact A1. *)
+(*   unfold S2; destruct out; try (apply star_refl). *)
+(*   inv B1. apply star_one. constructor. *)
+(*   reflexivity. traceEq. *)
+(*   unfold S2; inv B1; congruence || simpl; constructor; auto. *)
+
+(* (* block *) *)
+(*   destruct (H0 (Kblock k)) as [S1 [A1 B1]]. *)
+(*   set (S2 := *)
+(*     match out with *)
+(*     | Out_normal => State f Sskip k sp e1 m1 *)
+(*     | Out_exit O => State f Sskip k sp e1 m1 *)
+(*     | Out_exit (S m) => State f (Sexit m) k sp e1 m1 *)
+(*     | _ => S1 *)
+(*     end). *)
+(*   exists S2; split. *)
+(*   eapply star_left. constructor. eapply star_trans. eexact A1. *)
+(*   unfold S2; destruct out; try (apply star_refl). *)
+(*   inv B1. apply star_one. constructor. *)
+(*   inv B1. apply star_one. destruct n; constructor. *)
+(*   reflexivity. traceEq. *)
+(*   unfold S2; inv B1; simpl; try constructor; auto. *)
+(*   destruct n; constructor. *)
+
+(* (* exit *) *)
+(*   econstructor; split. apply star_refl. constructor. *)
+
+(* (* switch *) *)
+(*   econstructor; split. *)
+(*   apply star_one. econstructor; eauto. constructor. *)
+
+(* (* return none *) *)
+(*   econstructor; split. apply star_refl. constructor; auto. *)
+
+(* (* return some *) *)
+(*   econstructor; split. apply star_refl. constructor; auto. *)
+
+(* (* tailcall *) *)
+(*   econstructor; split. *)
+(*   eapply star_left. econstructor; eauto. *)
+(*   apply H5. apply is_call_cont_call_cont. traceEq. *)
+(*   econstructor. *)
+(* Qed. *)
+
+(* Lemma eval_funcall_steps: *)
+(*    forall m fd args t m' res, *)
+(*    eval_funcall ge m fd args t m' res -> *)
+(*    forall k, *)
+(*    is_call_cont k -> *)
+(*    star step ge (Callstate fd args k m) *)
+(*               t (Returnstate res k m'). *)
+(* Proof (proj1 eval_funcall_exec_stmt_steps). *)
+
+(* Lemma exec_stmt_steps: *)
+(*    forall f sp e m s t e' m' out, *)
+(*    exec_stmt ge f sp e m s t e' m' out -> *)
+(*    forall k, *)
+(*    exists S, *)
+(*    star step ge (State f s k sp e m) t S *)
+(*    /\ outcome_state_match sp e' m' f k out S. *)
+(* Proof (proj2 eval_funcall_exec_stmt_steps). *)
+
+(* Lemma evalinf_funcall_forever: *)
+(*   forall m fd args T k, *)
+(*   evalinf_funcall ge m fd args T -> *)
+(*   forever_plus step ge (Callstate fd args k m) T. *)
+(* Proof. *)
+(*   cofix CIH_FUN. *)
+(*   assert (forall sp e m s T f k, *)
+(*           execinf_stmt ge f sp e m s T -> *)
+(*           forever_plus step ge (State f s k sp e m) T). *)
+(*   cofix CIH_STMT. *)
+(*   intros. inv H. *)
+
+(* (* call *) *)
+(*   eapply forever_plus_intro. *)
+(*   apply plus_one. econstructor; eauto. *)
+(*   apply CIH_FUN. eauto. traceEq. *)
+(*   ss. *)
+  
+(* (* ifthenelse *) *)
+(*   eapply forever_plus_intro with (s2 := State f (if b then s1 else s2) k sp e m). *)
+(*   apply plus_one. econstructor; eauto. *)
+(*   apply CIH_STMT. eauto. traceEq. *)
+(*   ss. *)
+  
+(* (* seq 1 *) *)
+(*   eapply forever_plus_intro. *)
+(*   apply plus_one. constructor. *)
+(*   apply CIH_STMT. eauto. traceEq. *)
+(*   ss. *)
+  
+(* (* seq 2 *) *)
+(*   destruct (exec_stmt_steps _ _ _ _ _ _ _ _ _ H0 (Kseq s2 k)) *)
+(*   as [S [A B]]. inv B. *)
+(*   eapply forever_plus_intro. *)
+(*   eapply plus_left. constructor. *)
+(*   eapply star_right. eexact A. constructor. *)
+(*   reflexivity. reflexivity. *)
+(*   apply CIH_STMT. eauto. traceEq. *)
+(*   ss. *)
+  
+(* (* loop body *) *)
+(*   eapply forever_plus_intro. *)
+(*   apply plus_one. econstructor; eauto. *)
+(*   apply CIH_STMT. eauto. traceEq. *)
+
+(* (* loop loop *) *)
+(*   destruct (exec_stmt_steps _ _ _ _ _ _ _ _ _ H0 (Kseq (Sloop s0) k)) *)
+(*   as [S [A B]]. inv B. *)
+(*   eapply forever_plus_intro. *)
+(*   eapply plus_left. constructor. *)
+(*   eapply star_right. eexact A. constructor. *)
+(*   reflexivity. reflexivity. *)
+(*   apply CIH_STMT. eauto. traceEq. *)
+
+(* (* block *) *)
+(*   eapply forever_plus_intro. *)
+(*   apply plus_one. econstructor; eauto. *)
+(*   apply CIH_STMT. eauto. traceEq. *)
+
+(* (* tailcall *) *)
+(*   eapply forever_plus_intro. *)
+(*   apply plus_one. econstructor; eauto. *)
+(*   apply CIH_FUN. eauto. traceEq. *)
+
+(* (* function call *) *)
+(*   intros. inv H0. *)
+(*   eapply forever_plus_intro. *)
+(*   apply plus_one. econstructor; eauto. *)
+(*   apply H. eauto. *)
+(*   traceEq. *)
+(* Qed. *)
+
+(* Theorem bigstep_semantics_sound: *)
+(*   bigstep_sound (bigstep_semantics prog) (semantics prog). *)
+(* Proof. *)
+(*   constructor; intros. *)
+(* (* termination *) *)
+(*   inv H. econstructor; econstructor. *)
+(*   split. econstructor; eauto. *)
+(*   split. apply eval_funcall_steps. eauto. red; auto. *)
+(*   econstructor. *)
+(* (* divergence *) *)
+(*   inv H. econstructor. *)
+(*   split. econstructor; eauto. *)
+(*   eapply forever_plus_forever. *)
+(*   eapply evalinf_funcall_forever; eauto. *)
+(* Qed. *)
+
+(* End BIGSTEP_TO_TRANSITION. *)
diff --git a/backend/CminorD.v b/backend/CminorD.v
new file mode 100644
index 00000000..5de6c50a
--- /dev/null
+++ b/backend/CminorD.v
@@ -0,0 +1,24 @@
+Require Import Coqlib.
+Require Import Values Globalenvs Events.
+Require Import Smallstep Simulation.
+Require Import Cminor.
+
+(** Determinacy *)
+
+Lemma initial_state_determ: forall p st0 st1,
+    Smallstep.initial_state (semantics p) st0 ->
+    Smallstep.initial_state (semantics p) st1 -> st0 = st1.
+Proof.
+  intros. inv H; inv H0. subst ge0 ge. Eq.
+Qed.
+
+Theorem final_state_determ: forall p st0 retv,
+    Smallstep.final_state (Cminor.semantics p) st0 retv ->
+    Dfinal_state (Cminor.semantics p) st0 retv.
+Proof.
+  econstructor; eauto.
+  - intros. inv FINAL1; inv FINAL0; auto.
+  - red. unfold not. intros. inv FINAL; inv H0.
+Qed.
+
+Ltac DStep_tac := esplit; [(eapply semantics_determinate; simpl in *; eauto)|].
diff --git a/backend/CminorSel.v b/backend/CminorSel.v
index f6f6e34d..8ec141d8 100644
--- a/backend/CminorSel.v
+++ b/backend/CminorSel.v
@@ -23,6 +23,7 @@ Require Import Cminor.
 Require Import Op.
 Require Import Globalenvs.
 Require Import Smallstep.
+Require Import PointerOp.
 
 (** * Abstract syntax *)
 
@@ -169,7 +170,7 @@ Inductive eval_expr: letenv -> expr -> val -> Prop :=
       eval_expr le (Evar id) v
   | eval_Eop: forall le op al vl v,
       eval_exprlist le al vl ->
-      eval_operation ge sp op vl m = Some v ->
+      eval_operation_wrapper ge sp op vl m = Some v ->
       eval_expr le (Eop op al) v
   | eval_Eload: forall le chunk addr al vl vaddr v,
       eval_exprlist le al vl ->
@@ -187,11 +188,11 @@ Inductive eval_expr: letenv -> expr -> val -> Prop :=
   | eval_Eletvar: forall le n v,
       nth_error le n = Some v ->
       eval_expr le (Eletvar n) v
-  | eval_Ebuiltin: forall le ef al vl v,
+  | eval_Ebuiltin: forall le ef al vl v (INTERN: ~ is_external_ef ef),
       eval_exprlist le al vl ->
       external_call ef ge vl m E0 v m ->
       eval_expr le (Ebuiltin ef al) v
-  | eval_Eexternal: forall le id sg al b ef vl v,
+  | eval_Eexternal: forall le id sg al b ef vl v (INTERN: ~ is_external_ef ef),
       Genv.find_symbol ge id = Some b ->
       Genv.find_funct_ptr ge b = Some (External ef) ->
       ef_sig ef = sg ->
@@ -209,7 +210,7 @@ with eval_exprlist: letenv -> exprlist -> list val -> Prop :=
 with eval_condexpr: letenv -> condexpr -> bool -> Prop :=
   | eval_CEcond: forall le cond al vl vb,
       eval_exprlist le al vl ->
-      eval_condition cond vl m = Some vb ->
+      (if ptr_cond cond then eval_condition_join cond vl m else eval_condition cond vl m) = Some vb ->
       eval_condexpr le (CEcond cond al) vb
   | eval_CEcondition: forall le a b c va v,
       eval_condexpr le a va ->
@@ -461,8 +462,49 @@ Inductive final_state: state -> int -> Prop :=
   | final_state_intro: forall r m,
       final_state (Returnstate (Vint r) Kstop m) r.
 
+(** Non-deterministic external state *)
+
+Definition is_external (ge: genv) (s:state) : Prop :=
+  match s with
+  | State f s k e le m =>
+    match s with
+    | Sbuiltin optid ef al => is_external_ef ef
+    | _ => False
+    end
+  | Callstate f args k m =>
+    match f with
+    | External ef => is_external_ef ef
+    | _ => False
+    end
+  | _ => False
+  end.
+
+Inductive glob_capture (p: program) : state -> state -> Prop :=
+  | glob_capture_intro
+      f m pbs m'
+      (* (INIT: initial_state p (Callstate nil f nil m)) *)
+      (NONSTATIC: Genv.non_static_glob (Genv.globalenv p) (Genv.genv_public (Genv.globalenv p)) = pbs)
+      (CAPTURE: Genv.capture_init_mem m pbs m') :
+    glob_capture p (Callstate f nil Kstop m) (Callstate f nil Kstop m').
+
+Definition state_mem (st: state) : mem :=
+  match st with
+  | State _ _ _ _ _ m => m
+  | Callstate _ _ _ m => m
+  | Returnstate _ _ m => m
+  end.
+
+Definition concrete_snapshot (ge: Senv.t) (st: state) (id: ident) : option Z :=
+  if Senv.public_symbol ge id
+  then (match Senv.find_symbol ge id with
+        | Some b => Maps.PTree.get b (state_mem st).(Mem.mem_concrete)
+        | None => None
+        end
+    )
+  else None.
+
 Definition semantics (p: program) :=
-  Semantics step (initial_state p) final_state (Genv.globalenv p).
+  Semantics step (initial_state p) (glob_capture p) (concrete_snapshot (Genv.globalenv p)) final_state is_external (Genv.globalenv p).
 
 Global Hint Constructors eval_expr eval_exprlist eval_condexpr: evalexpr.
 
diff --git a/backend/CminorSelD.v b/backend/CminorSelD.v
new file mode 100644
index 00000000..62e240e3
--- /dev/null
+++ b/backend/CminorSelD.v
@@ -0,0 +1,136 @@
+Require Import Coqlib.
+Require Import Globalenvs Events.
+Require Import CoqlibC Smallstep Simulation.
+Require Import CminorSel.
+
+(** Determinacy *)
+
+Lemma semantics_single_events p s (INT: ~ is_external (Genv.globalenv p) s): single_events_at (CminorSel.semantics p) s.
+Proof.
+  red. intros. inv H; (try (exploit external_call_trace_length; eauto; intro T)); simpl; try lia; ss.
+Qed.
+
+Lemma eval_expr_determ:
+  forall ge sp e m le a v, eval_expr ge sp e m le a v -> forall v', eval_expr ge sp e m le a v' -> v' = v
+with eval_exprlist_determ:
+       forall ge sp e m le al vl, eval_exprlist ge sp e m le al vl -> forall vl', eval_exprlist ge sp e m le al vl' -> vl' = vl
+with eval_condexpr_determ:
+       forall ge sp e m le a v, eval_condexpr ge sp e m le a v  -> forall v', eval_condexpr ge sp e m le a v' -> v' = v.
+Proof.
+  - induction 1; intros v' EV; inv EV; try (Eq; auto); try (by determ_tac eval_exprlist_determ).
+    + determ_tac eval_condexpr_determ. determ_tac eval_expr_determ.
+    + determ_tac eval_expr_determ. exploit eval_expr_determ. eapply H0. eapply H6. intros; subst. auto.
+    + determ_tac eval_exprlist_determ. determ_tac external_call_determ.
+    + determ_tac eval_exprlist_determ. eapply external_call_deterministic; eauto.
+  - induction 1; intros v' EV; inv EV; try (Eq; auto).
+    determ_tac eval_exprlist_determ. determ_tac eval_expr_determ.
+  - induction 1; intros v' EV; inv EV; try (Eq; auto).
+    + determ_tac eval_exprlist_determ.
+    + determ_tac eval_condexpr_determ. exploit eval_condexpr_determ. eapply H0. eapply H7. auto.
+    + determ_tac eval_expr_determ. exploit eval_condexpr_determ. eapply H0. eapply H6. auto.
+Qed.
+
+Let eval_expr_or_symbol_determ:
+  forall ge sp e m le a vf, eval_expr_or_symbol ge sp e m le a vf -> forall vf', eval_expr_or_symbol ge sp e m le a vf' -> vf = vf'.
+Proof. induction 1; intros vf' EV; inv EV; try congruence. eapply eval_expr_determ; eauto. Qed.
+
+Let eval_exitexpr_determ:
+  forall ge sp e m le a n, eval_exitexpr ge sp e m le a n -> forall n', eval_exitexpr ge sp e m le a n' -> n = n'.
+Proof.
+  induction 1; intros vf' EV; inv EV; try congruence.
+  + exploit eval_expr_determ. eapply H. eapply H4. intros. inv H1. Eq.
+  + exploit eval_condexpr_determ. eapply H. eapply H6. intro; subst. eapply IHeval_exitexpr; eauto.
+  + exploit eval_expr_determ. eapply H. eapply H4. intro; subst. eapply IHeval_exitexpr; eauto.
+Qed.
+
+Let eval_builtin_arg_determ:
+  forall ge sp e m a v, eval_builtin_arg ge sp e m a v -> forall v', eval_builtin_arg ge sp e m a v' -> v = v'.
+Proof.
+  induction 1; intros vf' EV; inv EV; try congruence.
+  + eapply eval_expr_determ; eauto.
+  + exploit eval_expr_determ. eapply H. eapply H3.
+    exploit eval_expr_determ. eapply H0. eapply H5. intros; subst; auto.
+  + erewrite IHeval_builtin_arg1; eauto. erewrite IHeval_builtin_arg2; eauto.
+Qed.
+
+Let eval_builtin_args_determ:
+  forall ge sp e m al vl, list_forall2 (eval_builtin_arg ge sp e m) al vl -> forall vl', list_forall2 (eval_builtin_arg ge sp e m) al vl' -> vl = vl'.
+Proof.
+  intros. generalize dependent al. generalize dependent vl'. induction vl; intros.
+  { inv H. inv H0. simpl. auto. }
+  inv H. inv H0. exploit eval_builtin_arg_determ. eapply H4. eapply H2. intros; subst. f_equal. eapply IHvl; eauto.
+Qed.
+
+Lemma initial_state_determ: forall p st0 st1,
+    Smallstep.initial_state (CminorSel.semantics p) st0 ->
+    Smallstep.initial_state (CminorSel.semantics p) st1 -> st0 = st1.
+Proof. intros. inv H; inv H0. subst ge0 ge. Eq. Qed.
+
+Ltac Determ :=
+  repeat (try congruence;
+          match goal with
+          | [ |- match_traces _ E0 E0 /\ (_ -> _) ]  =>
+            split; [constructor|intros _]
+          | [ H: is_call_cont ?k |- _ ] =>
+            contradiction || (clear H)
+          | [ H1: eval_expr _ _ _ _ _ ?a ?v1, H2: eval_expr _ _ _ _ _ ?a ?v2 |- _ ] =>
+            assert (v1 = v2) by (eapply eval_expr_determ; eauto);
+            clear H1 H2
+          | [ H1: eval_exprlist _ _ _ _ _ ?a ?v1, H2: eval_exprlist _ _ _ _ _ ?a ?v2 |- _ ] =>
+            assert (v1 = v2) by (eapply eval_exprlist_determ; eauto);
+            clear H1 H2
+          | [ H1: eval_expr_or_symbol _ _ _ _ _ ?a ?v1, H2: eval_expr_or_symbol _ _ _ _ _ ?a ?v2 |- _ ] =>
+            assert (v1 = v2) by (eapply eval_expr_or_symbol_determ; eauto);
+            clear H1 H2
+          | [ H1: eval_condexpr _ _ _ _ _ ?a ?v1, H2: eval_condexpr _ _ _ _ _ ?a ?v2 |- _ ] =>
+            assert (v1 = v2) by (eapply eval_condexpr_determ; eauto);
+            clear H1 H2
+          | [ H1: eval_exitexpr _ _ _ _ _ ?a ?v1, H2: eval_exitexpr _ _ _ _ _ ?a ?v2 |- _ ] =>
+            assert (v1 = v2) by (eapply eval_exitexpr_determ; eauto);
+            clear H1 H2
+          | _ => idtac
+          end).
+
+Lemma semantics_determinate_at:
+  forall (p: program) s (INT: ~ is_external (Genv.globalenv p) s), deterministic_at (CminorSel.semantics p) s.
+Proof.
+  econstructor; eauto.
+  - intros. simpl in *.
+    inv STEP0; inv STEP1; Determ; subst; auto; try by (clarify; subst; esplits; eauto).
+    + exploit eval_builtin_args_determ. eapply H. eapply H11. intros; subst.
+      determ_tac external_call_determ.
+    + rewrite H in H6. clarify.
+    + simpl in INT. determ_tac external_call_determ.
+  - i. inv FINAL; inv STEP.
+  - unfold single_events_at. i. eapply semantics_single_events; eauto.
+Qed.
+
+Ltac simpl_case :=
+  match goal with
+  | [ H: match_traces _ E0 _ |- _ ] =>
+    inv H; do 2 econstructor; eauto
+  | [ H: match_traces _ _ E0 |- _ ] =>
+    inv H; do 2 econstructor; eauto
+  | _ => idtac
+  end.
+
+Lemma semantics_receptive_at:
+  forall (p: program) s (INT: ~ is_external (Genv.globalenv p) s), receptive_at (CminorSel.semantics p) s.
+Proof.
+  econstructor; eauto.
+  - intros. simpl in *.
+    inv H; simpl_case; try (exploit external_call_receptive; eauto; intros (vres2 & m2 & EXT);
+    (do 2 econstructor); eauto).
+  - unfold single_events_at. i. eapply semantics_single_events; eauto.
+Qed.
+
+Theorem final_state_determ: forall p st0 retv,
+    Smallstep.final_state (CminorSel.semantics p) st0 retv ->
+    Dfinal_state (CminorSel.semantics p) st0 retv.
+Proof.
+  econstructor; eauto.
+  - intros. inv FINAL1; inv FINAL0; auto.
+  - red. unfold not. intros. inv FINAL; inv H0.
+Qed.
+
+Ltac DStep_tac := esplit; [(eapply semantics_determinate_at; simpl in *; eauto)|].
diff --git a/backend/Cminortyping.v b/backend/Cminortyping.v
index 9f35fe35..1a05c07b 100644
--- a/backend/Cminortyping.v
+++ b/backend/Cminortyping.v
@@ -14,6 +14,8 @@ Require Import Coqlib Maps Errors.
 Require Import AST Integers Floats Values Memory Globalenvs Events Smallstep.
 Require Import Cminor.
 Require Import Unityping.
+Require Import sflib.
+Require Import IntPtrRel.
 
 Local Open Scope string_scope.
 Local Open Scope error_monad_scope.
@@ -60,6 +62,7 @@ Definition type_binop (op: binary_operation) : typ * typ * typ :=
   | Oaddl | Osubl | Omull | Odivl | Odivlu | Omodl | Omodlu
   | Oandl | Oorl  | Oxorl => (Tlong, Tlong, Tlong)
   | Oshll | Oshrl | Oshrlu => (Tlong, Tint, Tlong)
+  | Opsub => (Tptr, Tptr, Tptr) (* Tptr = if Archi.ptr64 then Tlong else Tint *)
   | Ocmp _ | Ocmpu _ => (Tint, Tint, Tint)
   | Ocmpf _ => (Tfloat, Tfloat, Tint)
   | Ocmpfs _ => (Tsingle, Tsingle, Tint)
@@ -596,8 +599,36 @@ Qed.
 Lemma type_binop_sound: forall op v1 v2 m v,
   eval_binop op v1 v2 m = Some v -> Val.has_type v (snd (type_binop op)).
 Proof.
-  unfold eval_binop; intros op v1 v2 m v EV; destruct op; simpl; VHT';
-  destruct (eq_block b b0); VHT.
+  unfold eval_binop; intros op v1 v2 m v EV; destruct op; try (by (simpl; VHT';
+                                                                   destruct (eq_block b b0); VHT)).
+  destruct Archi.ptr64 eqn:SF; unfold Val.has_type, type_binop, Tptr; rewrite SF in *; simpl.
+  - unfold Val.psubl in *. des_ifs.
+  - unfold Val.psub in *. des_ifs.
+Qed.
+
+(* move to IntPtrRel *)
+Lemma val_join_sound v v' ty (TY1: Val.has_type v ty) (TY2: Val.has_type v' ty):
+  <<TYPE: Val.has_type (val_join v v') ty>>.
+Proof. unfold val_join. des_ifs. Qed.
+
+Lemma type_binop_wrapper_sound op v1 v2 m v (EVAL: eval_binop_wrapper op v1 v2 m = Some v):
+  <<TYPE:Val.has_type v (snd (type_binop op))>>.
+Proof.
+  destruct (ptr_binop op) eqn:PTRBIN; cycle 1.
+  { rewrite eval_binop_no_ptr_binop in EVAL; eauto. eapply type_binop_sound; eauto. }
+  destruct op; unfold eval_binop_wrapper in *; ss; clarify.
+  - destruct Archi.ptr64 eqn:SF; unfold psub_join_cminor, Tptr; rewrite SF.
+    + unfold psubl_join_common. destruct v1, v2; simpl; auto; try rewrite SF; [ss| | | ].
+      { unfold psubl_join. eapply val_join_sound; unfold Val.psubl; des_ifs. }
+      { unfold psubl_join. eapply val_join_sound; unfold Val.psubl; des_ifs. }
+      { unfold Val.psubl in *. des_ifs. }
+    + unfold psub_join_common. destruct v1, v2; simpl; auto; try rewrite SF; [ss| | | ].
+      { unfold psub_join. eapply val_join_sound; unfold Val.psub; des_ifs. }
+      { unfold psub_join. eapply val_join_sound; unfold Val.psub; des_ifs. }
+      { unfold Val.psub in *. des_ifs. }
+  - destruct Archi.ptr64 eqn:SF; try rewrite SF in *.
+    + destruct v1, v2; VHT'; unfold Val.of_bool; des_ifs.
+    + destruct v1, v2; VHT'; unfold Val.of_bool; des_ifs.
 Qed.
 
 Lemma wt_eval_expr: forall env sp e m a v,
@@ -611,8 +642,10 @@ Proof.
 - inv WT. apply ENV; auto.
 - inv WT. eapply type_constant_sound; eauto.
 - inv WT. replace t with (snd (type_unop op)) by (rewrite H3; auto). eapply type_unop_sound; eauto.
-- inv WT. replace t with (snd (type_binop op)) by (rewrite H5; auto). eapply type_binop_sound; eauto.
-- inv WT. destruct vaddr; try discriminate. eapply Mem.load_type; eauto.
+- inv WT. replace t with (snd (type_binop op)) by (rewrite H5; auto). eapply type_binop_wrapper_sound; eauto.
+- inv WT. destruct vaddr; try discriminate.
+  2:{ eapply Mem.load_type; eauto. unfold Mem.loadv in H0. ss. eauto. }
+  unfold Mem.loadv in *. des_ifs. eapply Mem.load_type; eauto.
 Qed.
 
 Lemma wt_eval_exprlist: forall env sp e m al vl,
@@ -701,6 +734,16 @@ Proof.
   rewrite H3; constructor.
 Qed.
 
+Lemma wt_initial_capture_state
+    S S'
+    (INIT: initial_state p S)
+    (CAP: glob_capture p S S') :
+  wt_state S'.
+Proof.
+  exploit wt_initial_state; eauto. i. inv INIT. inv H. inv CAP.
+  econs; eauto.
+Qed.
+
 End SUBJECT_REDUCTION.
 
 (** * Safe expressions *)
@@ -794,8 +837,11 @@ Proof.
   - InvBooleans.
     destruct IHa1 as [v1 E1]; auto.
     destruct IHa2 as [v2 E2]; auto.
-    destruct (eval_binop b v1 v2 m) as [v|] eqn:E.
+    destruct (eval_binop_wrapper b v1 v2 m) as [v|] eqn:E.
     exists v; econstructor; eauto.
+    unfold eval_binop_wrapper in E.
+    destruct (ptr_binop b) eqn:PTRBIN.
+    { destruct b; ss. }
     destruct b; discriminate.
   - discriminate.
 Qed.
diff --git a/backend/Constpropproof.v b/backend/Constpropproof.v
index a3592c4d..38012138 100644
--- a/backend/Constpropproof.v
+++ b/backend/Constpropproof.v
@@ -14,11 +14,13 @@
 
 Require Import Coqlib Maps Integers Floats Lattice Kildall.
 Require Import AST Linking.
+Require Import Simulation RTLD Classical PointerOp.
 Require Import Values Builtins Events Memory Globalenvs Smallstep.
 Require Compopts Machregs.
 Require Import Op Registers RTL.
 Require Import Liveness ValueDomain ValueAOp ValueAnalysis.
 Require Import ConstpropOp ConstpropOpproof Constprop.
+From Paco Require Import paco.
 
 Definition match_prog (prog tprog: program) :=
   match_program (fun cu f tf => tf = transf_fundef (romem_for cu) f) eq prog tprog.
@@ -37,6 +39,9 @@ Hypothesis TRANSL: match_prog prog tprog.
 Let ge := Genv.globalenv prog.
 Let tge := Genv.globalenv tprog.
 
+Let sem := semantics prog.
+Let tsem := semantics tprog.
+
 (** * Correctness of the code transformation *)
 
 (** We now show that the transformed code after constant propagation
@@ -50,6 +55,9 @@ Lemma senv_preserved:
   Senv.equiv ge tge.
 Proof (Genv.senv_match TRANSL).
 
+Lemma same_public: prog_public prog = prog_public tprog.
+Proof. inv TRANSL. des; eauto. Qed.
+
 Lemma functions_translated:
   forall (v: val) (f: fundef),
   Genv.find_funct ge v = Some f ->
@@ -87,35 +95,46 @@ Proof.
 Qed.
 
 Lemma transf_ros_correct:
-  forall bc rs ae ros f rs',
+  forall bc rs ae ros f rs' m m' (MEXT: Mem.extends m m'),
   genv_match bc ge ->
   ematch bc rs ae ->
-  find_function ge ros rs = Some f ->
+  find_function ge (ros_to_vos m ros rs) rs = Some f ->
   regs_lessdef rs rs' ->
   exists cunit,
-     find_function tge (transf_ros ae ros) rs' = Some (transf_fundef (romem_for cunit) f)
+     find_function tge (ros_to_vos m' (transf_ros ae ros) rs') rs' = Some (transf_fundef (romem_for cunit) f)
   /\ linkorder cunit prog.
 Proof.
-  intros until rs'; intros GE EM FF RLD. destruct ros; simpl in *.
+  intros until m'; intros MEXT GE EM FF RLD. destruct ros; simpl in *.
 - (* function pointer *)
   generalize (EM r); fold (areg ae r); intro VM. generalize (RLD r); intro LD.
+  destruct (rs # r) eqn:RSV; try by ss.
++ des_ifs_safe. inv LD. des_ifs; try by inv VM.
+* simpl. rewrite <- H1. des_ifs_safe. erewrite Mem.denormalize_extends; eauto. ss. des_ifs_safe.
+  apply function_ptr_translated; auto.
+* simpl. rewrite <- H1. des_ifs_safe. erewrite Mem.denormalize_extends; eauto. ss. des_ifs_safe.
+  apply function_ptr_translated; auto.
++ simpl in FF. des_ifs_safe. inv LD. rename H1 into VPTR.
   assert (DEFAULT:
     exists cunit,
-       find_function tge (inl _ r) rs' = Some (transf_fundef (romem_for cunit) f)
+       find_function tge (inl _ rs'#r) rs' = Some (transf_fundef (romem_for cunit) f)
     /\ linkorder cunit prog).
   {
-    simpl. inv LD. apply functions_translated; auto. rewrite <- H0 in FF; discriminate.
+    simpl. apply functions_translated; auto. rewrite <- VPTR. eauto.
   }
-  destruct (areg ae r); auto. destruct p; auto.
+  destruct (areg ae r); auto; try by inv VM.
+  2:{ unfold ros_to_vos. rewrite <- VPTR in *. eauto. }
+  rewrite <- VPTR in *. simpl in DEFAULT.
+  destruct p; auto; ss; try rewrite <- VPTR; ss.
   predSpec Ptrofs.eq Ptrofs.eq_spec ofs Ptrofs.zero; intros; auto.
+  2:{ inv VM. inv H1. clarify. }
   subst ofs. exploit vmatch_ptr_gl; eauto. intros LD'. inv LD'; try discriminate.
-  rewrite H1 in FF. unfold Genv.symbol_address in FF.
+  assert (FF': Genv.find_funct ge (Vptr b Ptrofs.zero) = Some f) by ss.
+  rewrite H1 in FF'. unfold Genv.symbol_address in FF'.
   simpl. rewrite symbols_preserved.
-  destruct (Genv.find_symbol ge id) as [b|]; try discriminate.
-  simpl in FF. rewrite dec_eq_true in FF.
+  destruct (Genv.find_symbol ge id) as [b'|]; try discriminate.
+  simpl in FF'. rewrite dec_eq_true in FF'.
   apply function_ptr_translated; auto.
-  rewrite <- H0 in FF; discriminate.
-- (* function symbol *)
+- (* function symbol *) 
   rewrite symbols_preserved.
   destruct (Genv.find_symbol ge i) as [b|]; try discriminate.
   apply function_ptr_translated; auto.
@@ -127,11 +146,11 @@ Lemma const_for_result_correct:
   vmatch bc v a ->
   bc sp = BCstack ->
   genv_match bc ge ->
-  exists v', eval_operation tge (Vptr sp Ptrofs.zero) op nil m = Some v' /\ Val.lessdef v v'.
+  exists v', eval_operation_wrapper tge (Vptr sp Ptrofs.zero) op nil m = Some v' /\ Val.lessdef v v'.
 Proof.
   intros. exploit ConstpropOpproof.const_for_result_correct; eauto. intros (v' & A & B).
   exists v'; split.
-  rewrite <- A; apply eval_operation_preserved. exact symbols_preserved.
+  rewrite <- A; apply eval_operation_wrapper_preserved. exact symbols_preserved.
   auto.
 Qed.
 
@@ -145,7 +164,7 @@ Inductive match_pc (f: function) (rs: regset) (m: mem): nat -> node -> node -> P
   | match_pc_cond: forall n pc cond args s1 s2 pcx,
       f.(fn_code)!pc = Some (Icond cond args s1 s2) ->
       (forall b,
-        eval_condition cond rs##args m = Some b ->
+        eval_condition_wrapper cond rs##args m = Some b ->
         match_pc f rs m n (if b then s1 else s2) pcx) ->
       match_pc f rs m (S n) pc pcx.
 
@@ -164,7 +183,7 @@ Proof.
   eapply match_pc_cond; eauto. intros b' DYNAMIC.
   assert (b = b').
   { eapply resolve_branch_sound; eauto.
-    rewrite <- DYNAMIC. apply eval_static_condition_sound with bc.
+    rewrite <- DYNAMIC. apply eval_static_condition_wrapper_sound with bc.
     apply aregs_sound; auto. }
   subst b'. apply IHn.
 Qed.
@@ -349,17 +368,18 @@ Ltac TransfInstr :=
 
 Lemma transf_step_correct:
   forall s1 t s2,
-  step ge s1 t s2 ->
+  IStep sem s1 t s2 ->
   forall n1 s1' (SS: sound_state prog s1) (MS: match_states n1 s1 s1'),
-  (exists n2, exists s2', step tge s1' t s2' /\ match_states n2 s2 s2')
+  (exists n2, exists s2', DStep tsem s1' t s2' /\ match_states n2 s2 s2')
   \/ (exists n2, n2 < n1 /\ t = E0 /\ match_states n2 s2 s1')%nat.
 Proof.
+  destruct 1. generalize dependent s2. rename H into INT.
   induction 1; intros; inv MS; try InvSoundState; try (inv PC; try congruence).
 
 - (* Inop, preserved *)
   rename pc'0 into pc. TransfInstr; intros.
   left; econstructor; econstructor; split.
-  eapply exec_Inop; eauto.
+  DStep_tac. eapply exec_Inop; eauto.
   eapply match_states_succ; eauto.
 
 - (* Inop, skipped over *)
@@ -371,13 +391,13 @@ Proof.
   rename pc'0 into pc. TransfInstr.
   set (a := eval_static_operation op (aregs ae args)).
   set (ae' := AE.set res a ae).
-  assert (VMATCH: vmatch bc v a) by (eapply eval_static_operation_sound; eauto with va).
+  assert (VMATCH: vmatch bc v a) by (eapply eval_static_operation_wrapper_sound; eauto with va).
   assert (MATCH': ematch bc (rs#res <- v) ae') by (eapply ematch_update; eauto).
   destruct (const_for_result a) as [cop|] eqn:?; intros.
 + (* constant is propagated *)
   exploit const_for_result_correct; eauto. intros (v' & A & B).
   left; econstructor; econstructor; split.
-  eapply exec_Iop; eauto.
+  DStep_tac. eapply exec_Iop; eauto.
   apply match_states_intro; auto.
   eapply match_successor; eauto.
   apply set_reg_lessdef; auto.
@@ -385,17 +405,17 @@ Proof.
   assert(OP:
      let (op', args') := op_strength_reduction op args (aregs ae args) in
      exists v',
-        eval_operation ge (Vptr sp0 Ptrofs.zero) op' rs ## args' m = Some v' /\
+        eval_operation_wrapper ge (Vptr sp0 Ptrofs.zero) op' rs ## args' m = Some v' /\
         Val.lessdef v v').
-  { eapply op_strength_reduction_correct with (ae := ae); eauto with va. }
+  { eapply op_strength_reduction_wrapper_correct with (ae := ae); eauto with va. }
   destruct (op_strength_reduction op args (aregs ae args)) as [op' args'].
   destruct OP as [v' [EV' LD']].
-  assert (EV'': exists v'', eval_operation ge (Vptr sp0 Ptrofs.zero) op' rs'##args' m' = Some v'' /\ Val.lessdef v' v'').
-  { eapply eval_operation_lessdef; eauto. eapply regs_lessdef_regs; eauto. }
+  assert (EV'': exists v'', eval_operation_wrapper ge (Vptr sp0 Ptrofs.zero) op' rs'##args' m' = Some v'' /\ Val.lessdef v' v'').
+  { eapply eval_operation_wrapper_lessdef; eauto. eapply regs_lessdef_regs; eauto. }
   destruct EV'' as [v'' [EV'' LD'']].
   left; econstructor; econstructor; split.
-  eapply exec_Iop; eauto.
-  erewrite eval_operation_preserved. eexact EV''. exact symbols_preserved.
+  DStep_tac. eapply exec_Iop; eauto.
+  erewrite eval_operation_wrapper_preserved. eexact EV''. exact symbols_preserved.
   apply match_states_intro; auto.
   eapply match_successor; eauto.
   apply set_reg_lessdef; auto. eapply Val.lessdef_trans; eauto.
@@ -410,7 +430,7 @@ Proof.
 + (* constant-propagated *)
   exploit const_for_result_correct; eauto. intros (v' & A & B).
   left; econstructor; econstructor; split.
-  eapply exec_Iop; eauto.
+  DStep_tac. eapply exec_Iop; eauto.
   eapply match_states_succ; eauto.
   apply set_reg_lessdef; auto.
 + (* strength-reduced *)
@@ -429,7 +449,7 @@ Proof.
   exploit Mem.loadv_extends. eauto. eauto. apply Val.lessdef_trans with a'; eauto.
   intros (v' & X & Y).
   left; econstructor; econstructor; split.
-  eapply exec_Iload; eauto.
+  DStep_tac. eapply exec_Iload; eauto.
   eapply match_states_succ; eauto. apply set_reg_lessdef; auto.
 
 - (* Istore *)
@@ -449,7 +469,7 @@ Proof.
   exploit Mem.storev_extends. eauto. eauto. apply Val.lessdef_trans with a'; eauto. apply REGS.
   intros (m2' & X & Y).
   left; econstructor; econstructor; split.
-  eapply exec_Istore; eauto.
+  DStep_tac. eapply exec_Istore; eauto.
   eapply match_states_succ; eauto.
 
 - (* Icall *)
@@ -457,28 +477,29 @@ Proof.
   exploit transf_ros_correct; eauto. intros (cu' & FIND & LINK').
   TransfInstr; intro.
   left; econstructor; econstructor; split.
-  eapply exec_Icall; eauto. apply sig_function_translated; auto.
+  DStep_tac. eapply exec_Icall; eauto. apply sig_function_translated; auto.
   constructor; auto. constructor; auto.
   econstructor; eauto.
   apply regs_lessdef_regs; auto.
 
 - (* Itailcall *)
   exploit Mem.free_parallel_extends; eauto. intros [m2' [A B]].
-  exploit transf_ros_correct; eauto. intros (cu' & FIND & LINK').
+  exploit transf_ros_correct; try eapply H0; eauto. intros (cu' & FIND & LINK').
   TransfInstr; intro.
   left; econstructor; econstructor; split.
-  eapply exec_Itailcall; eauto. apply sig_function_translated; auto.
+  DStep_tac. eapply exec_Itailcall; eauto. apply sig_function_translated; auto.
   constructor; auto.
   apply regs_lessdef_regs; auto.
 
 - (* Ibuiltin *)
+  unfold is_internal in INT. ss. des_ifs.
   rename pc'0 into pc. TransfInstr; intros.
 Opaque builtin_strength_reduction.
   set (dfl := Ibuiltin ef (builtin_strength_reduction ae ef args) res pc') in *.
   set (rm := romem_for cu) in *.
   assert (DFL: (fn_code (transf_function rm f))!pc = Some dfl ->
           exists (n2 : nat) (s2' : state),
-            step tge
+            DStep tsem
              (State s' (transf_function rm f) (Vptr sp0 Ptrofs.zero) pc rs' m'0) t s2' /\
             match_states n2
              (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m') s2').
@@ -490,7 +511,7 @@ Opaque builtin_strength_reduction.
     exploit external_call_mem_extends; eauto.
     intros (v' & m2' & A & B & C & D).
     econstructor; econstructor; split.
-    eapply exec_Ibuiltin; eauto.
+    DStep_tac. eapply exec_Ibuiltin; eauto.
     eapply eval_builtin_args_preserved. eexact symbols_preserved. eauto.
     eapply external_call_symbols_preserved; eauto. apply senv_preserved.
     eapply match_states_succ; eauto.
@@ -502,28 +523,28 @@ Opaque builtin_strength_reduction.
   destruct (eval_static_builtin_function ae am rm bf args) as [a|] eqn:ES; auto.
   destruct (const_for_result a) as [cop|] eqn:CR; auto.
   clear DFL. simpl in H1; red in H1; rewrite LK in H1; inv H1.
-  exploit const_for_result_correct; eauto. 
+  exploit const_for_result_correct; eauto.
   eapply eval_static_builtin_function_sound; eauto.
   intros (v' & A & B).
   left; econstructor; econstructor; split.
-  eapply exec_Iop; eauto.
+  DStep_tac. eapply exec_Iop; eauto.
   eapply match_states_succ; eauto.
   apply set_reg_lessdef; auto.
 - (* Icond, preserved *)
   rename pc'0 into pc. TransfInstr.
   set (ac := eval_static_condition cond (aregs ae args)).
-  assert (C: cmatch (eval_condition cond rs ## args m) ac)
-  by (eapply eval_static_condition_sound; eauto with va).
+  assert (C: cmatch (eval_condition_wrapper cond rs ## args m) ac)
+  by (eapply eval_static_condition_wrapper_sound; eauto with va).
   rewrite H0 in C.
-  generalize (cond_strength_reduction_correct bc ae rs m EM cond args (aregs ae args) (eq_refl _)).
+  generalize (cond_strength_reduction_wrapper_correct bc ae rs m EM cond args (aregs ae args) (eq_refl _)).
   destruct (cond_strength_reduction cond args (aregs ae args)) as [cond' args'].
   intros EV1 TCODE.
   left; exists O; exists (State s' (transf_function (romem_for cu) f) (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs' m'); split.
   destruct (resolve_branch ac) eqn: RB.
   assert (b0 = b) by (eapply resolve_branch_sound; eauto). subst b0.
-  destruct b; eapply exec_Inop; eauto.
-  eapply exec_Icond; eauto.
-  eapply eval_condition_lessdef with (vl1 := rs##args'); eauto. eapply regs_lessdef_regs; eauto. congruence.
+  DStep_tac. destruct b; eapply exec_Inop; eauto.
+  DStep_tac. eapply exec_Icond; eauto.
+  eapply eval_condition_wrapper_lessdef with (vl1 := rs##args'); eauto. eapply regs_lessdef_regs; eauto. congruence.
   eapply match_states_succ; eauto.
 
 - (* Icond, skipped over *)
@@ -543,13 +564,14 @@ Opaque builtin_strength_reduction.
   assert (rs'#arg = Vint n).
   { generalize (REGS arg). rewrite H0. intros LD; inv LD; auto. }
   left; exists O; exists (State s' (transf_function (romem_for cu) f) (Vptr sp0 Ptrofs.zero) pc' rs' m'); split.
-  destruct A. eapply exec_Ijumptable; eauto. eapply exec_Inop; eauto.
+  destruct A. DStep_tac. eapply exec_Ijumptable; eauto. DStep_tac. eapply exec_Inop; eauto.
   eapply match_states_succ; eauto.
 
 - (* Ireturn *)
+  unfold is_internal in INT. ss. des_ifs. TransfInstr. i.
   exploit Mem.free_parallel_extends; eauto. intros [m2' [A B]].
   left; exists O; exists (Returnstate s' (regmap_optget or Vundef rs') m2'); split.
-  eapply exec_Ireturn; eauto. TransfInstr; auto.
+  DStep_tac. eapply exec_Ireturn; eauto. TransfInstr; auto.
   constructor; auto.
   destruct or; simpl; auto.
 
@@ -558,23 +580,24 @@ Opaque builtin_strength_reduction.
   intros [m2' [A B]].
   simpl. unfold transf_function.
   left; exists O; econstructor; split.
-  eapply exec_function_internal; simpl; eauto.
+  DStep_tac. eapply exec_function_internal; simpl; eauto.
   simpl. econstructor; eauto.
   constructor.
   apply init_regs_lessdef; auto.
 
 - (* external function *)
+  unfold is_internal in INT. ss.
   exploit external_call_mem_extends; eauto.
   intros [v' [m2' [A [B [C D]]]]].
   simpl. left; econstructor; econstructor; split.
-  eapply exec_function_external; eauto.
+  DStep_tac. eapply exec_function_external; eauto.
   eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   constructor; auto.
 
 - (* return *)
   inv H4. inv H1.
   left; exists O; econstructor; split.
-  eapply exec_return; eauto.
+  DStep_tac. eapply exec_return; eauto.
   econstructor; eauto. constructor. apply set_reg_lessdef; auto.
 Qed.
 
@@ -601,25 +624,156 @@ Proof.
   intros. inv H0. inv H. inv STACKS. inv RES. constructor.
 Qed.
 
+Lemma match_states_bsim
+      s1 (EXT: is_external ge s1)
+      (SOUND: sound_state prog s1)
+      s2 t s2' (STEPTGT: Step tsem s2 t s2')
+      n (MATCH: match_states n s1 s2)
+      (SAFESRC: safe sem s1) :
+    (exists n' s1', Step sem s1 t s1' /\ match_states n' s1' s2')
+  \/ (~ trace_intact t /\ exists s1'' t', Star sem s1 t' s1'' /\ exists tl, t' = (trace_cut_pterm t) ** tl).
+Proof.
+  assert (SEQUIV: Senv.equiv tge ge) by (symmetry; eapply senv_preserved).
+  unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+  { inv SAFESRC; ss. }
+  unfold is_external in *. inv MATCH; des_ifs; try InvSoundState; try (inv PC; try congruence).
+  (* builtin *)
+  - TransfInstr; i.
+    assert (TI: (fn_code (transf_function (romem_for cu) f)) ! pc' = Some (Ibuiltin e (builtin_strength_reduction ae e l) b n0)).
+    { des_ifs. ss. des_ifs. }
+    clear H. inv STEPTGT; clarify. inv SAFESRC; clarify.
+    assert (eval_builtin_args (globalenv (semantics prog)) (fun r : positive => rs # r) (Vptr sp0 Ptrofs.zero) m
+                              (builtin_strength_reduction ae e l) vargs0).
+    { Local Transparent builtin_strength_reduction. unfold builtin_strength_reduction.
+      des_ifs; eapply builtin_args_strength_reduction_correct; eauto. }
+    exploit eval_builtin_args_lessdef. eapply REGS. eauto. eapply H. i. des.
+
+    exploit eval_builtin_args_determ; [eapply H0| |].
+    { eapply eval_builtin_args_preserved; [|eapply H8]. i. eapply SEQUIV. } i. subst.
+
+    exploit external_call_mem_extends_backward. eauto. eapply H9. eauto. eauto. i; des; cycle 1.
+    { exploit UBSRC. eapply external_call_symbols_preserved; eauto. eapply senv_preserved. contradiction. }
+    { right. esplits; eauto. eapply star_one. eapply exec_Ibuiltin; eauto.
+      eapply external_call_symbols_preserved; eauto. }
+    { left. esplits.
+      - eapply exec_Ibuiltin; eauto. eapply external_call_symbols_preserved; eauto.
+      - eapply match_states_succ; eauto. apply set_res_lessdef; auto. }
+  (* external call *)
+  - inv SAFESRC; clarify. inv STEPTGT; ss; clarify.
+    exploit external_call_mem_extends_backward; try apply H8; eauto. i; des; cycle 1.
+    { exploit UBSRC; eauto. eapply external_call_symbols_preserved; eauto. eapply senv_preserved. i; ss. }
+    { right. esplits; eauto. eapply star_one. eapply exec_function_external.
+      eapply external_call_symbols_preserved; eauto. }
+    exploit exec_function_external. eapply external_call_symbols_preserved; eauto.
+    i. left. esplits; eauto. econs; eauto.
+Qed.
+
+Lemma match_states_xsim n st_src0 st_tgt0 gmtgt
+    (SOUND: sound_state prog st_src0)
+    (MATCH: match_states n%nat st_src0 st_tgt0):
+  xsim (RTL.semantics prog) (RTL.semantics tprog) gmtgt lt n%nat st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0. generalize dependent n.
+  pcofix CIH. i. pfold. destruct (classic (is_external ge st_src0)); cycle 1; rename H into EXT.
+  (* internal *)
+  - left. econs. econs.
+    + i. exploit transf_step_correct; eauto. i. des; esplits; eauto;
+      [eapply tr_rel_refl; eapply ev_rel_refl| | |eapply tr_rel_refl; eapply ev_rel_refl|].
+      { left. split. apply plus_one. eauto. eapply semantics_receptive_at; auto. }
+      { right. eapply CIH; eauto. eapply sound_step; eauto. }
+      { right. eapply CIH; eauto. eapply sound_step; eauto. }   
+    + i. exploit transf_final_states; eauto. i. eapply final_state_determ; eauto.
+  (* external *)
+  - right. econs. i. econs.
+    + i. exploit match_states_bsim; eauto. i. des.
+      * left. esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl| |].
+        { left. eapply plus_one. eauto. }
+        { right. eapply CIH; eauto. eapply sound_step; eauto. }
+      * right. esplits; eauto.
+        subst. eapply tr_rel_refl. eapply ev_rel_refl.
+    + i. inv FINALTGT; inv MATCH; ss.
+    + i. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify; [inv SAFESRC; ss|].
+      right. inv MATCH; ss; des_ifs; inv SAFESRC; unfold ge in *; clarify.
+      * InvSoundState. TransfInstr; intros.
+        assert (TI: (fn_code (transf_function (romem_for cu) f)) ! pc = Some (Ibuiltin e (builtin_strength_reduction ae e l) b n0)).
+        { des_ifs. ss. des_ifs. } clear H.
+        assert (pc = pc').
+        { inv PC; clarify. } subst.
+        exploit builtin_strength_reduction_correct; eauto. intros (vargs' & P & Q).
+        exploit (@eval_builtin_args_lessdef _ ge (fun r => rs#r) (fun r => rs'#r)).
+        apply REGS. eauto. eexact P.
+        intros (vargs'' & U & V).
+        exploit external_call_mem_extends_backward_progress; eauto. i. des.
+        esplits. eapply exec_Ibuiltin; eauto.
+        eapply eval_builtin_args_preserved. eexact symbols_preserved. eauto.
+        eapply external_call_symbols_preserved; eauto. apply senv_preserved.
+      * exploit external_call_mem_extends_backward_progress; eauto.
+        i. des. esplits. eapply exec_function_external; eauto.
+        eapply external_call_symbols_preserved; eauto. apply senv_preserved.
+Qed.
+
+Lemma non_static_equiv l:
+  Genv.non_static_glob (Genv.globalenv prog) l = Genv.non_static_glob (Genv.globalenv tprog) l.
+Proof.
+  Local Transparent ge tge.
+  induction l; ss.
+  specialize senv_preserved. ss. i. inv H. inv H1. unfold ge, tge, fundef in *.
+  specialize (H a). unfold Senv.public_symbol in H. ss. erewrite H.
+  specialize (H0 a). rewrite <- H0. erewrite IHl; eauto.
+Qed.
+
+Lemma transf_initial_capture S1 S2 S2' i
+    (INITSRC: initial_state prog S1)
+    (INITTGT: initial_state tprog S2)
+    (MATCH: match_states i S1 S2)
+    (CAPTGT: glob_capture tprog S2 S2'):
+  exists i' S1', glob_capture prog S1 S1'
+  /\ match_states i' S1' S2'
+  /\ gm_improves (concrete_snapshot ge S1') (concrete_snapshot tge S2').
+Proof.
+  specialize senv_preserved. intros SENVEQ.
+  inv CAPTGT. ss. rename m' into m2'.
+  rewrite Genv.globalenv_public in CAPTURE. erewrite <- same_public in CAPTURE; eauto.
+  inv MATCH. inv ARGS. inv STACKS.
+  exploit non_static_equiv. instantiate (1:=AST.prog_public prog). intros EQUIV.
+  assert (exists m1', Genv.capture_init_mem m0 (Genv.non_static_glob (Genv.globalenv prog) (AST.prog_public prog)) m1' /\
+                     Mem.extends m1' m2').
+  { clear LINK INITSRC INITTGT.
+    rewrite <- EQUIV in CAPTURE. clear EQUIV. inv CAPTURE.
+    remember (Genv.non_static_glob (Genv.globalenv prog) (prog_public prog)) as l. clear Heql.
+    clear SENVEQ. (* move m0 after f0. *) move l before f0. revert_until f0.
+    induction l; ss; i.
+    { inv CAP. esplits; eauto. econs. econs. }
+    inv CAP. exploit Mem.capture_extends_backward; eauto. i. des.
+    exploit IHl; eauto. i. des. inv H. esplits; eauto. econs. econs; eauto. }
+  des. esplits; eauto.
+  - econs. eauto. rewrite Genv.globalenv_public. eauto.
+  - econs; eauto. econs.
+  - ii. unfold concrete_snapshot in *. inv SENVEQ. des. erewrite H3, H2. des_ifs; ss.
+    eapply Mem.mext_concrete; eauto. eapply Mem.concrete_valid; eauto.
+Qed.
+
 (** The preservation of the observable behavior of the program then
   follows. *)
 
 Theorem transf_program_correct:
-  forward_simulation (RTL.semantics prog) (RTL.semantics tprog).
+  mixed_simulation (RTL.semantics prog) (RTL.semantics tprog).
 Proof.
-  apply Forward_simulation with lt (fun n s1 s2 => sound_state prog s1 /\ match_states n s1 s2); constructor.
-- apply lt_wf.
-- simpl; intros. exploit transf_initial_states; eauto. intros (n & st2 & A & B).
-  exists n, st2; intuition. eapply sound_initial; eauto.
-- simpl; intros. destruct H. eapply transf_final_states; eauto.
-- simpl; intros. destruct H0.
-  assert (sound_state prog s1') by (eapply sound_step; eauto).
-  fold ge; fold tge.
-  exploit transf_step_correct; eauto.
-  intros [ [n2 [s2' [A B]]] | [n2 [A [B C]]]].
-  exists n2; exists s2'; split; auto. left; apply plus_one; auto.
-  exists n2; exists s2; split; auto. right; split; auto. subst t; apply star_refl.
-- apply senv_preserved.
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (S a). lia.
+  - econs. i. exploit transf_initial_states; eauto. i. des.
+    exists st2. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. inversion INITSRC; subst. inversion H0; subst.
+      inv ARGS. inv STACKS.
+      exploit transf_initial_capture; eauto. i. des.
+      exists i'%nat. exists S1'. esplits; eauto.
+      apply match_states_xsim; auto.
+      eapply sound_capture_initial; eauto.
+  - i. apply senv_preserved.
 Qed.
 
 End PRESERVATION.
diff --git a/backend/Deadcodeproof.v b/backend/Deadcodeproof.v
index 7be12c69..84f5e1ac 100644
--- a/backend/Deadcodeproof.v
+++ b/backend/Deadcodeproof.v
@@ -15,9 +15,11 @@
 Require Import FunInd.
 Require Import Coqlib Maps Errors Integers Floats Lattice Kildall.
 Require Import AST Linking.
+Require Import CoqlibC Simulation RTLD Classical PointerOp.
 Require Import Values Memory Globalenvs Events Smallstep.
 Require Import Registers Op RTL.
 Require Import ValueDomain ValueAnalysis NeedDomain NeedOp Deadcode.
+From Paco Require Import paco.
 
 Definition match_prog (prog tprog: RTL.program) :=
   match_program (fun cu f tf => transf_fundef (romem_for cu) f = OK tf) eq prog tprog.
@@ -51,7 +53,11 @@ Record magree (m1 m2: mem) (P: locset) : Prop := mk_magree {
     memval_lessdef (ZMap.get ofs (PMap.get b (Mem.mem_contents m1)))
                    (ZMap.get ofs (PMap.get b (Mem.mem_contents m2)));
   ma_nextblock:
-    Mem.nextblock m2 = Mem.nextblock m1
+    Mem.nextblock m2 = Mem.nextblock m1;
+  ma_concrete:
+    forall b addr,
+    Mem.valid_block m1 b ->
+    m1.(Mem.mem_concrete) ! b = Some addr -> m2.(Mem.mem_concrete) ! b = Some addr;
 }.
 
 Lemma magree_monotone:
@@ -72,6 +78,7 @@ Proof.
 - exploit mi_memval; eauto. unfold inject_id; eauto.
   rewrite Z.add_0_r. auto.
 - auto.
+- auto.
 Qed.
 
 Lemma magree_extends:
@@ -122,9 +129,13 @@ Proof.
   intros. exploit Mem.load_valid_access; eauto. intros [A B].
   exploit Mem.load_loadbytes; eauto. intros [bytes [C D]].
   exploit magree_loadbytes; eauto. intros [bytes' [E F]].
-  exists (decode_val chunk bytes'); split.
+  exists (decode_val chunk (Mem.normalize_mvs chunk m2 bytes')); split.
   apply Mem.loadbytes_load; auto.
-  apply val_inject_id. subst v. apply decode_val_inject; auto.
+  apply val_inject_id. subst v.
+  eapply Mem.normalize_mvs_decode_val_inject; eauto.
+  { erewrite Mem.loadbytes_length; eauto. destruct chunk; ss; lia. }
+  { ii. unfold inject_id in H2. clarify. exploit ma_concrete; eauto. i.
+    rewrite H2. f_equal. lia. }
 Qed.
 
 Lemma magree_storebytes_parallel:
@@ -173,6 +184,9 @@ Proof.
 - rewrite (Mem.nextblock_storebytes _ _ _ _ _ H0).
   rewrite (Mem.nextblock_storebytes _ _ _ _ _ ST2).
   eapply ma_nextblock; eauto.
+- erewrite <- Mem.concrete_storebytes; [|eapply ST2].
+  erewrite <- Mem.concrete_storebytes in H4; [|eapply H0].
+  eapply ma_concrete; eauto. eapply Mem.storebytes_valid_block_2; eauto.
 Qed.
 
 Lemma magree_store_parallel:
@@ -216,6 +230,9 @@ Proof.
 + eapply ma_memval; eauto. eapply Mem.perm_storebytes_2; eauto.
 - rewrite (Mem.nextblock_storebytes _ _ _ _ _ H0).
   eapply ma_nextblock; eauto.
+- exploit Mem.concrete_storebytes; eauto. i. rewrite <- H4 in H3; eauto.
+  eapply ma_concrete with (P:=P); eauto.
+  unfold Mem.valid_block in *. erewrite <- Mem.nextblock_storebytes; eauto.
 Qed.
 
 Lemma magree_store_left:
@@ -264,6 +281,11 @@ Proof.
   rewrite (Mem.free_result _ _ _ _ _ H0).
   rewrite (Mem.free_result _ _ _ _ _ FREE).
   simpl. eapply ma_nextblock; eauto.
+- (* concrete *)
+  erewrite <- Mem.concrete_free with (m1:=m1) in H3; eauto.
+  erewrite <- Mem.concrete_free with (m1:=m2) (m2:=m2'); eauto.
+  eapply ma_concrete with (P:=P); eauto.
+  unfold Mem.valid_block in *; erewrite <- Mem.nextblock_free; eauto.
 Qed.
 
 Lemma magree_valid_access:
@@ -276,6 +298,49 @@ Proof.
   red; intros. eapply ma_perm; eauto.
 Qed.
 
+Lemma magree_denormalize m1 m2 (P: locset) z b ofs
+    (MA: magree m1 m2 P)
+    (DENO: Mem.denormalize z m1 = Some (b, ofs)) :
+  <<DENO: Mem.denormalize z m2 = Some (b, ofs)>>.
+Proof.
+  exploit Mem.denormalize_info; eauto. i. des.
+  exploit ma_concrete; eauto. intros CONC'. exploit ma_perm; eauto. i.
+  exploit Mem.ptr2int_to_denormalize_max; eauto.
+  unfold Mem.ptr2int. rewrite CONC'. f_equal. lia.
+Qed.
+
+Lemma magree_to_ptr m1 m2 (P: locset) v1 v2 b ofs
+    (MA: magree m1 m2 P)
+    (LESS: Val.lessdef v1 v2)
+    (TOPTR: Mem.to_ptr v1 m1 = Some (Vptr b ofs)) :
+  <<TOPTR': Mem.to_ptr v2 m2 = Some (Vptr b ofs)>>.
+Proof.
+  inv LESS; ss. destruct v2; ss. des_ifs.
+  2: { exploit magree_denormalize; eauto. i. rewrite H in Heq1. clarify. }
+  eapply magree_denormalize in Heq2; eauto.
+  rewrite Heq1 in Heq2. inv Heq2. eauto.
+Qed.
+
+Lemma magree_valid_block m1 m2 (P: locset) b1 b2 delta
+    (MA: magree m1 m2 P)
+    (INJ: inject_id b1 = Some (b2, delta))
+    (VLD1: Mem.valid_block m1 b1) :
+  <<VLD2: Mem.valid_block m2 b2>>.
+Proof.
+  unfold inject_id in INJ. clarify.
+  unfold Mem.valid_block in *. erewrite ma_nextblock; eauto.
+Qed.
+
+Lemma magree_concrete m1 m2 (P: locset) b1 b2 addr delta
+    (MA: magree m1 m2 P)
+    (INJ: inject_id b1 = Some (b2, delta))
+    (CONC: (Mem.mem_concrete m1) ! b1 = Some addr) :
+  <<CONC': (Mem.mem_concrete m2) ! b2 = Some (addr - delta)>>.
+Proof.
+  unfold inject_id in INJ. clarify. replace (addr - 0) with addr by lia.
+  eapply ma_concrete; eauto. eapply NNPP. ii. eapply Mem.nextblocks_logical in H; clarify.
+Qed.
+
 (** * Properties of the need environment *)
 
 Lemma add_need_all_eagree:
@@ -386,6 +451,9 @@ Hypothesis TRANSF: match_prog prog tprog.
 Let ge := Genv.globalenv prog.
 Let tge := Genv.globalenv tprog.
 
+Let sem := RTL.semantics prog.
+Let tsem := RTL.semantics tprog.
+
 Lemma symbols_preserved:
   forall (s: ident), Genv.find_symbol tge s = Genv.find_symbol ge s.
 Proof (Genv.find_symbol_match TRANSF).
@@ -394,6 +462,9 @@ Lemma senv_preserved:
   Senv.equiv ge tge.
 Proof (Genv.senv_match TRANSF).
 
+Lemma same_public: prog_public prog = prog_public tprog.
+Proof. inv TRANSF. des; eauto. Qed.
+
 Lemma functions_translated:
   forall (v: val) (f: RTL.fundef),
   Genv.find_funct ge v = Some f ->
@@ -462,18 +533,21 @@ Proof.
 Qed.
 
 Lemma find_function_translated:
-  forall ros rs fd trs ne,
-  find_function ge ros rs = Some fd ->
+  forall ros rs fd trs ne m tm P (MEM: magree m tm P),
+  find_function ge (ros_to_vos m ros rs) rs = Some fd ->
   eagree rs trs (add_ros_need_all ros ne) ->
   exists cu tfd,
-     find_function tge ros trs = Some tfd
+     find_function tge (ros_to_vos tm ros trs) trs = Some tfd
   /\ transf_fundef (romem_for cu) fd = OK tfd
   /\ linkorder cu prog.
 Proof.
   intros. destruct ros as [r|id]; simpl in *.
 - assert (LD: Val.lessdef rs#r trs#r) by eauto with na. inv LD.
+  2:{ rewrite <- H2 in *. ss. }
+  destruct (rs # r) eqn:RSV; try by ss.
++ des_ifs_safe. erewrite magree_denormalize; eauto.
   apply functions_translated; auto.
-  rewrite <- H2 in H; discriminate.
++ apply functions_translated; auto.
 - rewrite symbols_preserved. destruct (Genv.find_symbol ge id); try discriminate.
   apply function_ptr_translated; auto.
 Qed.
@@ -587,14 +661,14 @@ Proof.
 - exists (Vlong n); intuition auto. constructor. apply vagree_same.
 - exists (Vfloat n); intuition auto. constructor. apply vagree_same.
 - exists (Vsingle n); intuition auto. constructor. apply vagree_same.
-- simpl in H. exploit magree_load; eauto.
+- unfold Mem.loadv in H. simpl in H. exploit magree_load; eauto.
   intros. eapply nlive_add; eauto with va. rewrite Ptrofs.add_zero_l in H0; auto.
   intros (v' & A & B).
   exists v'; intuition auto. constructor; auto. apply vagree_lessdef; auto.
   eapply magree_monotone; eauto. intros; eapply incl_nmem_add; eauto.
 - exists (Vptr sp (Ptrofs.add Ptrofs.zero ofs)); intuition auto with na. constructor.
 - unfold Senv.symbol_address in H; simpl in H.
-  destruct (Genv.find_symbol ge id) as [b|] eqn:FS; simpl in H; try discriminate.
+  destruct (Genv.find_symbol ge id) as [b|] eqn:FS; unfold Mem.loadv in H; simpl in H; try discriminate.
   exploit magree_load; eauto.
   intros. eapply nlive_add; eauto. constructor. apply GM; auto.
   intros (v' & A & B).
@@ -653,8 +727,12 @@ Proof.
   assert (LD: forall chunk addr v,
               Mem.loadv chunk m addr = Some v ->
               exists v', Mem.loadv chunk m' addr = Some v').
-  {
-    intros. destruct addr; simpl in H; try discriminate.
+  { 
+    intros. destruct addr; unfold Mem.loadv in H; simpl in H; try discriminate.
+    { des_ifs. eapply magree_denormalize in Heq2; eauto. i.
+      unfold Mem.loadv. ss. rewrite Heq0, Heq1, Heq2.
+      eapply Mem.valid_access_load. eapply magree_valid_access; eauto.
+      eapply Mem.load_valid_access; eauto. }
     eapply Mem.valid_access_load. eapply magree_valid_access; eauto.
     eapply Mem.load_valid_access; eauto. }
   induction 1; try (econstructor; now constructor).
@@ -696,15 +774,20 @@ Lemma transf_volatile_store:
            /\ magree m' tm' (nlive ge sp nm).
 Proof.
   intros. inv H. split; auto.
+  assert (TOPTR': Mem.to_ptr v1' tm = Some (Vptr b ofs)).
+  { unfold Mem.to_ptr in TOPTR. des_ifs; inv H0; ss.
+    exploit magree_denormalize; eauto. i. rewrite Heq, Heq0, H. eauto. }
   inv H0. inv H9.
 - (* volatile *)
-  exists tm; split; auto. econstructor. econstructor; eauto.
+  exists tm; split; eauto. econstructor. eauto. econstructor; eauto.
+  eapply ma_perm; eauto.
   eapply eventval_match_lessdef; eauto. apply store_argument_load_result; auto.
 - (* not volatile *)
   exploit magree_store_parallel. eauto. eauto. eauto.
   instantiate (1 := nlive ge sp nm). auto.
   intros (tm' & P & Q).
-  exists tm'; split. econstructor. econstructor; eauto. auto.
+  exists tm'; split. econstructor. eauto. econstructor; eauto. auto.
+- ss.
 Qed.
 
 Lemma eagree_set_undef:
@@ -716,9 +799,9 @@ Qed.
 (** * The simulation diagram *)
 
 Theorem step_simulation:
-  forall S1 t S2, step ge S1 t S2 ->
+  forall S1 t S2, IStep sem S1 t S2 ->
   forall S1', match_states S1 S1' -> sound_state prog S1 ->
-  exists S2', step tge S1' t S2' /\ match_states S2 S2'.
+  exists S2', DStep tsem S1' t S2' /\ match_states S2 S2'.
 Proof.
 
 Ltac TransfInstr :=
@@ -741,12 +824,13 @@ Ltac UseTransfer :=
        simpl in *
   end.
 
+  destruct 1. generalize dependent S2. rename H into INT.
   induction 1; intros S1' MS SS; inv MS.
 
 - (* nop *)
   TransfInstr; UseTransfer.
   econstructor; split.
-  eapply exec_Inop; eauto.
+  DStep_tac. eapply exec_Inop; eauto.
   eapply match_succ_states; eauto. simpl; auto.
 
 - (* op *)
@@ -756,12 +840,12 @@ Ltac UseTransfer :=
   [idtac|destruct (operation_is_redundant op (nreg ne res)) eqn:REDUNDANT]].
 + (* dead instruction, turned into a nop *)
   econstructor; split.
-  eapply exec_Inop; eauto.
+  DStep_tac. eapply exec_Inop; eauto.
   eapply match_succ_states; eauto. simpl; auto.
   apply eagree_update_dead; auto with na.
 + (* instruction with needs = [I Int.zero], turned into a load immediate of zero. *)
   econstructor; split.
-  eapply exec_Iop with (v := Vint Int.zero); eauto.
+  DStep_tac. eapply exec_Iop with (v := Vint Int.zero); eauto.
   eapply match_succ_states; eauto. simpl; auto.
   apply eagree_update; auto.
   rewrite is_int_zero_sound by auto.
@@ -770,29 +854,34 @@ Ltac UseTransfer :=
   destruct args.
   * (* kept as is because no arguments -- should never happen *)
   simpl in *.
-  exploit needs_of_operation_sound. eapply ma_perm; eauto.
+  exploit needs_of_operation_wrapper_sound. eapply ma_perm; eauto.
+  { i. eapply magree_valid_block; eauto. }
+  { i. eapply magree_concrete; eauto. }
   eauto. instantiate (1 := nreg ne res). eauto with na. eauto with na. intros [tv [A B]].
   econstructor; split.
-  eapply exec_Iop with (v := tv); eauto.
-  rewrite <- A. apply eval_operation_preserved. exact symbols_preserved.
+  DStep_tac. eapply exec_Iop with (v := tv); eauto.
+  rewrite <- A. apply eval_operation_wrapper_preserved. exact symbols_preserved.
   eapply match_succ_states; eauto. simpl; auto.
   apply eagree_update; auto.
   * (* turned into a move *)
   unfold fst in ENV. unfold snd in MEM. simpl in H0.
   assert (VA: vagree v te#r (nreg ne res)).
-  { eapply operation_is_redundant_sound with (arg1' := te#r) (args' := te##args).
+  { eapply operation_wrapper_is_redundant_sound with (arg1' := te#r) (args' := te##args).
     eauto. eauto. exploit add_needs_vagree; eauto. }
   econstructor; split.
-  eapply exec_Iop; eauto. simpl; reflexivity.
+  DStep_tac. eapply exec_Iop; eauto. simpl; reflexivity.
   eapply match_succ_states; eauto. simpl; auto.
   eapply eagree_update; eauto 2 with na.
 + (* preserved operation *)
   simpl in *.
-  exploit needs_of_operation_sound. eapply ma_perm; eauto. eauto. eauto 2 with na. eauto with na.
+  exploit needs_of_operation_wrapper_sound. eapply ma_perm; eauto.
+  { i. eapply magree_valid_block; eauto. }
+  { i. eapply magree_concrete; eauto. }  
+  eauto. eauto 2 with na. eauto with na.
   intros [tv [A B]].
   econstructor; split.
-  eapply exec_Iop with (v := tv); eauto.
-  rewrite <- A. apply eval_operation_preserved. exact symbols_preserved.
+  DStep_tac. eapply exec_Iop with (v := tv); eauto.
+  rewrite <- A. apply eval_operation_wrapper_preserved. exact symbols_preserved.
   eapply match_succ_states; eauto. simpl; auto.
   apply eagree_update; eauto 2 with na.
 
@@ -803,12 +892,12 @@ Ltac UseTransfer :=
   simpl in *.
 + (* dead instruction, turned into a nop *)
   econstructor; split.
-  eapply exec_Inop; eauto.
+  DStep_tac. eapply exec_Inop; eauto.
   eapply match_succ_states; eauto. simpl; auto.
   apply eagree_update_dead; auto with na.
 + (* instruction with needs = [I Int.zero], turned into a load immediate of zero. *)
   econstructor; split.
-  eapply exec_Iop with (v := Vint Int.zero); eauto.
+  DStep_tac. eapply exec_Iop with (v := Vint Int.zero); eauto.
   eapply match_succ_states; eauto. simpl; auto.
   apply eagree_update; auto.
   rewrite is_int_zero_sound by auto.
@@ -816,13 +905,25 @@ Ltac UseTransfer :=
 + (* preserved *)
   exploit eval_addressing_lessdef. eapply add_needs_all_lessdef; eauto. eauto.
   intros (ta & U & V). inv V; try discriminate.
-  destruct ta; simpl in H1; try discriminate.
+  destruct ta; unfold Mem.loadv in H1; simpl in H1; try discriminate.
+  { des_ifs.
+    exploit magree_load; eauto.
+    exploit aaddressing_denormalize_sound; eauto. intros (bc & A & B & C). des.
+    intros. apply nlive_add with bc (Ptrofs.repr z); eauto.
+    intros (tv & P & Q).
+    econstructor; split.
+    DStep_tac. eapply exec_Iload with (a := Vlong i). eauto.
+    rewrite <- U. apply eval_addressing_preserved. exact symbols_preserved.
+    exploit magree_denormalize; eauto. i. unfold Mem.loadv. ss. rewrite Heq0, Heq1, H2; eauto.
+    eapply match_succ_states; eauto. simpl; auto.
+    apply eagree_update; eauto 2 with na.
+    eapply magree_monotone; eauto. intros. apply incl_nmem_add; auto. }
   exploit magree_load; eauto.
   exploit aaddressing_sound; eauto. intros (bc & A & B & C).
   intros. apply nlive_add with bc i; assumption.
   intros (tv & P & Q).
   econstructor; split.
-  eapply exec_Iload with (a := Vptr b i). eauto.
+  DStep_tac. eapply exec_Iload with (a := Vptr b i). eauto.
   rewrite <- U. apply eval_addressing_preserved. exact symbols_preserved.
   eauto.
   eapply match_succ_states; eauto. simpl; auto.
@@ -838,21 +939,43 @@ Ltac UseTransfer :=
   exploit eval_addressing_lessdef. eapply add_needs_all_lessdef; eauto. eauto.
   intros (ta & U & V). inv V; try discriminate.
   destruct ta; simpl in H1; try discriminate.
+  { des_ifs.
+    exploit magree_store_parallel. eauto. eauto. instantiate (1 := te#src). eauto with na.
+    instantiate (1 := nlive ge sp0 nm).
+    exploit aaddressing_denormalize_sound; eauto. intros (bc & A & B & C). des.
+    intros. apply nlive_remove with bc b (Ptrofs.repr z); eauto.
+    { eapply Mem.denormalize_in_range in Heq0. rewrite Ptrofs.unsigned_repr; eauto.
+      unfold Ptrofs.max_unsigned. des; lia. }
+    intros (tm' & P & Q).
+    econstructor; split.
+    DStep_tac. eapply exec_Istore with (a := Vlong i). eauto.
+    rewrite <- U. apply eval_addressing_preserved. exact symbols_preserved.
+    exploit magree_denormalize; try eapply Heq0; eauto. i. unfold Mem.storev. rewrite Heq, H2; eauto.
+    eapply match_succ_states; eauto. simpl; auto.
+    eauto 3 with na. }
   exploit magree_store_parallel. eauto. eauto. instantiate (1 := te#src). eauto with na.
   instantiate (1 := nlive ge sp0 nm).
   exploit aaddressing_sound; eauto. intros (bc & A & B & C).
   intros. apply nlive_remove with bc b i; assumption.
   intros (tm' & P & Q).
   econstructor; split.
-  eapply exec_Istore with (a := Vptr b i). eauto.
+  DStep_tac. eapply exec_Istore with (a := Vptr b i). eauto.
   rewrite <- U. apply eval_addressing_preserved. exact symbols_preserved.
   eauto.
   eapply match_succ_states; eauto. simpl; auto.
   eauto 3 with na.
 + (* dead instruction, turned into a nop *)
   destruct a; simpl in H1; try discriminate.
+  { des_ifs. econstructor; split.
+    DStep_tac. eapply exec_Inop; eauto.
+    eapply match_succ_states; eauto. simpl; auto.
+    eapply magree_store_left; eauto.
+    exploit aaddressing_denormalize_sound; eauto. intros (bc & A & B & C).
+    intros. eapply nlive_contains; eauto.
+    { eapply Mem.denormalize_in_range in Heq0. rewrite Ptrofs.unsigned_repr; eauto.
+      unfold Ptrofs.max_unsigned. des; lia. } }
   econstructor; split.
-  eapply exec_Inop; eauto.
+  DStep_tac. eapply exec_Inop; eauto.
   eapply match_succ_states; eauto. simpl; auto.
   eapply magree_store_left; eauto.
   exploit aaddressing_sound; eauto. intros (bc & A & B & C).
@@ -862,7 +985,7 @@ Ltac UseTransfer :=
   TransfInstr; UseTransfer.
   exploit find_function_translated; eauto 2 with na. intros (cu' & tfd & A & B & C).
   econstructor; split.
-  eapply exec_Icall; eauto. eapply sig_function_translated; eauto.
+  DStep_tac. eapply exec_Icall; eauto. eapply sig_function_translated; eauto.
   eapply match_call_states with (cu := cu'); eauto.
   constructor; auto. eapply match_stackframes_intro with (cu := cu); eauto.
   intros.
@@ -879,12 +1002,13 @@ Ltac UseTransfer :=
   intros; eapply nlive_dead_stack; eauto.
   intros (tm' & C & D).
   econstructor; split.
-  eapply exec_Itailcall; eauto. eapply sig_function_translated; eauto.
+  DStep_tac. eapply exec_Itailcall; eauto. eapply sig_function_translated; eauto.
   erewrite stacksize_translated by eauto. eexact C.
   eapply match_call_states with (cu := cu'); eauto 2 with na.
   eapply magree_extends; eauto. apply nlive_all.
 
 - (* builtin *)
+  unfold is_internal in INT. ss. rewrite H in INT.
   TransfInstr; UseTransfer. revert ENV MEM TI.
   functional induction (transfer_builtin (vanalyze cu f)#pc ef args res ne nm);
   simpl in *; intros.
@@ -897,23 +1021,26 @@ Ltac UseTransfer :=
   InvSoundState. exploit transfer_builtin_arg_sound; eauto.
   intros (tv1 & A & B & C & D).
   inv H1. simpl in B. inv B.
+  2:{ ss. }
+  exploit magree_to_ptr; try eapply TOPTR; eauto. intros TOPTR'.
   assert (X: exists tvres, volatile_load ge chunk tm b ofs t tvres /\ Val.lessdef vres tvres).
   {
     inv H2.
   * exists (Val.load_result chunk v); split; auto. constructor; auto.
+    eapply ma_perm; eauto.
   * exploit magree_load; eauto.
-    exploit aaddr_arg_sound_1; eauto. rewrite <- AN. intros.
+    exploit aaddr_arg_to_ptr_sound_1; eauto. rewrite <- AN. intros.
     intros. eapply nlive_add; eassumption.
     intros (tv & P & Q).
     exists tv; split; auto. constructor; auto.
   }
   destruct X as (tvres & P & Q).
   econstructor; split.
-  eapply exec_Ibuiltin; eauto.
+  DStep_tac. eapply exec_Ibuiltin; eauto.
   apply eval_builtin_args_preserved with (ge1 := ge). exact symbols_preserved.
   constructor. eauto. constructor.
   eapply external_call_symbols_preserved. apply senv_preserved.
-  constructor. simpl. eauto.
+  econstructor. eapply TOPTR'. simpl. eauto.
   eapply match_succ_states; eauto. simpl; auto.
   apply eagree_set_res; auto.
   eapply magree_monotone; eauto. intros. apply incl_nmem_add; auto.
@@ -930,7 +1057,7 @@ Ltac UseTransfer :=
   exploit transf_volatile_store; eauto.
   intros (EQ & tm' & P & Q). subst vres.
   econstructor; split.
-  eapply exec_Ibuiltin; eauto.
+  DStep_tac. eapply exec_Ibuiltin; eauto.
   apply eval_builtin_args_preserved with (ge1 := ge). exact symbols_preserved.
   constructor. eauto. constructor. eauto. constructor.
   eapply external_call_symbols_preserved. apply senv_preserved.
@@ -953,9 +1080,20 @@ Ltac UseTransfer :=
   exploit transfer_builtin_arg_sound. eexact H4. eauto. eauto. eauto. eauto. eauto.
   intros (tv2 & A2 & B2 & C2 & D2).
   inv H1.
+  2:{ esplits.
+      - DStep_tac. eapply exec_Ibuiltin; eauto.
+        apply eval_builtin_args_preserved with (ge1 := ge). exact symbols_preserved.
+        constructor. eauto. constructor. eauto. constructor.
+        econs 2; eauto.
+      - eapply match_succ_states; eauto. simpl; auto.
+        apply eagree_set_res; auto. ss.
+        eapply magree_monotone in D2; cycle 1.
+        { instantiate (1:= nlive ge sp0 (nmem_remove nm adst 0)). ss. i.
+          eapply incl_nmem_add; eauto. }
+        eapply magree_monotone; eauto. i. eapply nmem_remove_nlive_implies; eauto. }
   exploit magree_loadbytes. eauto. eauto.
   intros. eapply nlive_add; eauto.
-  unfold asrc, vanalyze; rewrite AN; eapply aaddr_arg_sound_1; eauto.
+  unfold asrc, vanalyze; rewrite AN; eapply aaddr_arg_to_ptr_sound_1; eauto.
   intros (tbytes & P & Q).
   exploit magree_storebytes_parallel.
   eapply magree_monotone. eexact D2.
@@ -964,17 +1102,20 @@ Ltac UseTransfer :=
   eauto.
   instantiate (1 := nlive ge sp0 nm).
   intros. eapply nlive_remove; eauto.
-  unfold adst, vanalyze; rewrite AN; eapply aaddr_arg_sound_1; eauto.
+  unfold adst, vanalyze; rewrite AN; eapply aaddr_arg_to_ptr_sound_1; eauto.
   erewrite Mem.loadbytes_length in H1 by eauto.
   rewrite Z2Nat.id in H1 by lia. auto.
   eauto.
   intros (tm' & A & B).
   econstructor; split.
-  eapply exec_Ibuiltin; eauto.
+  DStep_tac. eapply exec_Ibuiltin; eauto.
   apply eval_builtin_args_preserved with (ge1 := ge). exact symbols_preserved.
   constructor. eauto. constructor. eauto. constructor.
   eapply external_call_symbols_preserved. apply senv_preserved.
+  exploit magree_to_ptr; try eapply TOPTR1; eauto. intro TOPTR1'.
+  exploit magree_to_ptr; try eapply TOPTR2; eauto. intro TOPTR2'.
   simpl in B1; inv B1. simpl in B2; inv B2. econstructor; eauto.
+  econs; eauto. econs; eauto.
   eapply match_succ_states; eauto. simpl; auto.
   apply eagree_set_res; auto.
 + (* memcpy eliminated *)
@@ -983,13 +1124,17 @@ Ltac UseTransfer :=
   set (adst := aaddr_arg (vanalyze cu f) # pc dst) in *.
   set (asrc := aaddr_arg (vanalyze cu f) # pc src) in *.
   inv H1.
+  2:{ econs; split.
+      DStep_tac. eapply exec_Inop; eauto.
+      eapply match_succ_states; eauto. simpl; auto.
+      destruct res; auto. apply eagree_set_undef; auto. }
   econstructor; split.
-  eapply exec_Inop; eauto.
+  DStep_tac. eapply exec_Inop; eauto.
   eapply match_succ_states; eauto. simpl; auto.
   destruct res; auto. apply eagree_set_undef; auto.
   eapply magree_storebytes_left; eauto.
   clear H3.
-  exploit aaddr_arg_sound; eauto.
+  exploit aaddr_arg_to_ptr_sound; eauto.
   intros (bc & A & B & C).
   intros. eapply nlive_contains; eauto.
   erewrite Mem.loadbytes_length in H0 by eauto.
@@ -1000,7 +1145,7 @@ Ltac UseTransfer :=
   exploit transfer_builtin_args_sound; eauto. intros (tvl & A & B & C & D).
   inv H1.
   econstructor; split.
-  eapply exec_Ibuiltin; eauto.
+  DStep_tac. eapply exec_Ibuiltin; eauto.
   apply eval_builtin_args_preserved with (ge1 := ge); eauto. exact symbols_preserved.
   eapply external_call_symbols_preserved. apply senv_preserved.
   constructor. eapply eventval_list_match_lessdef; eauto 2 with na.
@@ -1012,7 +1157,7 @@ Ltac UseTransfer :=
   exploit transfer_builtin_args_sound; eauto. intros (tvl & A & B & C & D).
   inv H1. inv B. inv H6.
   econstructor; split.
-  eapply exec_Ibuiltin; eauto.
+  DStep_tac. eapply exec_Ibuiltin; eauto.
   apply eval_builtin_args_preserved with (ge1 := ge); eauto. exact symbols_preserved.
   eapply external_call_symbols_preserved. apply senv_preserved.
   constructor.
@@ -1023,7 +1168,7 @@ Ltac UseTransfer :=
   inv H1.
   exploit can_eval_builtin_args; eauto. intros (vargs' & A).
   econstructor; split.
-  eapply exec_Ibuiltin; eauto. constructor.
+  DStep_tac. eapply exec_Ibuiltin; eauto. constructor.
   eapply match_succ_states; eauto. simpl; auto.
   apply eagree_set_res; auto.
 + (* all other builtins *)
@@ -1039,7 +1184,7 @@ Ltac UseTransfer :=
   eapply magree_extends; eauto. intros. apply nlive_all.
   intros (v' & tm' & P & Q & R & S).
   econstructor; split.
-  eapply exec_Ibuiltin; eauto.
+  DStep_tac. eapply exec_Ibuiltin; eauto.
   apply eval_builtin_args_preserved with (ge1 := ge); eauto. exact symbols_preserved.
   eapply external_call_symbols_preserved. apply senv_preserved. eauto.
   eapply match_succ_states; eauto. simpl; auto.
@@ -1050,11 +1195,14 @@ Ltac UseTransfer :=
   TransfInstr; UseTransfer. destruct (peq ifso ifnot).
 + replace (if b then ifso else ifnot) with ifso by (destruct b; congruence).
   econstructor; split.
-  eapply exec_Inop; eauto.
+  DStep_tac. eapply exec_Inop; eauto.
   eapply match_succ_states; eauto. simpl; auto.
 + econstructor; split.
-  eapply exec_Icond; eauto.
-  eapply needs_of_condition_sound. eapply ma_perm; eauto. eauto. eauto with na.
+  DStep_tac. eapply exec_Icond; eauto.
+  eapply needs_of_condition_wrapper_sound. eapply ma_perm; eauto.
+  { i. eapply magree_valid_block; eauto. }
+  { i. eapply magree_concrete; eauto. }
+  eauto. eauto with na.
   eapply match_succ_states; eauto 2 with na.
   simpl; destruct b; auto.
 
@@ -1063,7 +1211,7 @@ Ltac UseTransfer :=
   assert (LD: Val.lessdef rs#arg te#arg) by eauto 2 with na.
   rewrite H0 in LD. inv LD.
   econstructor; split.
-  eapply exec_Ijumptable; eauto.
+  DStep_tac. eapply exec_Ijumptable; eauto.
   eapply match_succ_states; eauto 2 with na.
   simpl. eapply list_nth_z_in; eauto.
 
@@ -1073,7 +1221,7 @@ Ltac UseTransfer :=
   intros; eapply nlive_dead_stack; eauto.
   intros (tm' & A & B).
   econstructor; split.
-  eapply exec_Ireturn; eauto.
+  DStep_tac. eapply exec_Ireturn; eauto.
   erewrite stacksize_translated by eauto. eexact A.
   constructor; auto.
   destruct or; simpl; eauto 2 with na.
@@ -1085,25 +1233,27 @@ Ltac UseTransfer :=
   exploit Mem.alloc_extends; eauto. apply Z.le_refl. apply Z.le_refl.
   intros (tm' & A & B).
   econstructor; split.
-  econstructor; simpl; eauto.
+  DStep_tac. econstructor; simpl; eauto.
   simpl. econstructor; eauto.
   apply eagree_init_regs; auto.
   apply mextends_agree; auto.
 
 - (* external function *)
   exploit external_call_mem_extends; eauto.
+  ss.
   intros (res' & tm' & A & B & C & D).
   simpl in FUN. inv FUN.
   econstructor; split.
-  econstructor; eauto.
+  DStep_tac. econstructor; eauto.
   eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   econstructor; eauto.
 
 - (* return *)
   inv STACKS. inv H1.
   econstructor; split.
-  constructor.
+  DStep_tac. constructor.
   econstructor; eauto. apply mextends_agree; auto.
+  Unshelve. all:ss.
 Qed.
 
 Lemma transf_initial_states:
@@ -1129,22 +1279,237 @@ Proof.
   intros. inv H0. inv H. inv STACKS. inv RES. constructor.
 Qed.
 
+Lemma match_states_bsim
+      s1 (EXT: is_external ge s1)
+      (SOUND: sound_state prog s1)
+      s2 t s2' (STEPTGT: Step tsem s2 t s2')
+      (MATCH: match_states s1 s2)
+      (SAFESRC: safe sem s1) :
+    (exists s1', Step sem s1 t s1' /\ match_states s1' s2')
+  \/ (~ trace_intact t /\ exists s1'' t', Step sem s1 t' s1'' /\ exists tl, t' = (trace_cut_pterm t) ** tl).
+Proof.
+  assert (SEQUIV: Senv.equiv tge ge) by (symmetry; eapply senv_preserved).
+  unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+  { inv SAFESRC; ss. }
+  unfold is_external in *. des_ifs.
+  (* builtin *)
+  - inversion MATCH; subst.
+    destruct (classic (exists chunk, e = EF_vload chunk)).
+    { inv SAFESRC; clarify. TransfInstr; UseTransfer.
+      assert (TI0: (fn_code tf) ! pc = Some (Ibuiltin e l b n)).
+      { des_ifs. } clear TI.
+      inv STEPTGT; ss; clarify. des. subst. ss. des_ifs_safe. des_ifs.
+      { inv H12. inv H13. }
+      2:{ inv H12. inv H3. inv H13. }
+      destruct (transfer_builtin_arg All
+                  (kill_builtin_res b ne, nmem_add nm (aaddr_arg (vanalyze cu f) # pc b0) (size_chunk chunk)) b0) as (ne1, nm1) eqn: TR.
+      ss. InvSoundState.
+      exploit transfer_builtin_args_sound; eauto. intros (tvl & A & B & C & D).
+      exploit eval_builtin_args_determ; [eapply H12| |].
+      { eapply eval_builtin_args_preserved; [|eapply A]. eapply symbols_preserved. }
+      i. subst. inv H13.
+      assert (X: exists vres, volatile_load ge chunk m b1 ofs t vres /\ Val.lessdef vres vres0).
+      { inv H.
+        - exists (Val.load_result chunk v). inv H10. inv H; cycle 1.
+          { eapply magree_to_ptr in TOPTR0; eauto. des; clarify.
+            inv B. inv H7; ss. clarify. destruct senv_preserved. des.
+            exfalso. fold ge in H3. fold tge in H0. unfold Senv.block_is_volatile in *. ss.
+            rewrite H6 in *. clarify. }
+          esplits; eauto.
+          eapply magree_to_ptr in TOPTR0; eauto. des; clarify.
+          inv B. inv H10; ss. clarify. econs; eauto.
+          + destruct senv_preserved. des. rewrite <- H. eauto.
+          + eapply eventval_match_preserved; try eapply H2.
+            { fold tge. destruct senv_preserved. des. eauto. }
+            { fold tge. destruct senv_preserved. des. eauto. }
+        - inv H10. dup TOPTR0.
+          eapply magree_to_ptr in TOPTR0; eauto. des; clarify.
+          inv B. inv H7; ss. inv H5; clarify. inv H.
+          { destruct senv_preserved. des. fold ge in H2.
+            rewrite <- H6 in H2. fold tge in H0.
+            unfold Senv.block_is_volatile in H2. ss. clarify. }
+          exploit magree_load; eauto.
+          { exploit aaddr_arg_to_ptr_sound_1.
+            eapply EM. eapply RO. eapply MM. eapply GE. eauto. inv H9. eauto.
+            eapply TOPTR1. rewrite <- AN. i.
+            intros. eapply nlive_add; eassumption. }
+          intros (tv & P & Q). clarify. 
+          exists vres; split; auto. econs; eauto. }
+      destruct X as (vres1 & P & Q).
+      inv B. inv H4.
+      left. esplits. eapply exec_Ibuiltin; eauto. ss. econs; eauto.
+      { inv H10. exploit magree_to_ptr; try eapply TOPTR0; eauto. i. des.
+        rewrite H0 in TOPTR. clarify. }
+      eapply match_succ_states; eauto. simpl; auto.
+      apply eagree_set_res; auto.
+      eapply magree_monotone; eauto. intros. apply incl_nmem_add; auto. }
+    rename H into NOVL.
+    inv SAFESRC; clarify. TransfInstr; UseTransfer.
+    assert (TI0: (fn_code tf) ! pc = Some (Ibuiltin e l b n)).
+    { des_ifs. } clear TI.
+    inv STEPTGT; ss; clarify.
+    replace (transfer_builtin (vanalyze cu f) # pc e l b ne nm) with
+        (transfer_builtin_args (kill_builtin_res b ne, nmem_all) l) in *; cycle 1.
+    { unfold transfer_builtin. des_ifs. ss. exfalso. eapply NOVL. eauto. }
+    destruct (transfer_builtin_args (kill_builtin_res b ne, nmem_all) l) as (ne1, nm1) eqn:TR.
+    InvSoundState.
+    exploit transfer_builtin_args_sound; eauto. intros (tvl & A & B & C & D).
+    exploit eval_builtin_args_determ; [eapply H11| |].
+    { eapply eval_builtin_args_preserved; [|eapply A]. eapply symbols_preserved. }
+    i. subst. exploit external_call_mem_extends_backward; eauto.
+    eapply magree_extends; eauto. apply nlive_all. i. des.
+    + left. esplits. eapply exec_Ibuiltin; eauto.
+      exploit external_call_symbols_preserved; eauto.
+      eapply match_succ_states; eauto. simpl; auto.
+      apply eagree_set_res; auto.
+      eapply mextends_agree; eauto.
+    + exploit UBSRC. eapply external_call_symbols_preserved; eauto. eapply senv_preserved. contradiction.
+    + right. esplits; eauto. eapply exec_Ibuiltin; eauto.
+      exploit external_call_symbols_preserved; eauto.
+  (* external call *)
+  - inversion MATCH; clarify.
+    inv SAFESRC; ss; des_ifs. inv STEPTGT; ss; des_ifs; clarify.
+    exploit external_call_symbols_preserved; eauto. i.
+    exploit external_call_mem_extends_backward; eauto. i; des; cycle 1.
+    { exploit UBSRC; eauto. i; ss. }
+    { right. esplits; eauto. econs. eauto. }
+    left. esplits; eauto; econs; eauto.
+Qed.
+
+Lemma match_states_xsim st_src0 st_tgt0 gmtgt
+    (MATCH: match_states st_src0 st_tgt0)
+    (SOUND: sound_state prog st_src0) :
+  xsim (RTL.semantics prog) (RTL.semantics tprog) gmtgt lt 0%nat st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold.
+  destruct (classic (is_external ge st_src0)); cycle 1; rename H into EXT.
+  - left. econs. econs.
+    (* internal *)
+    + i. exploit step_simulation; eauto. i. des; esplits; eauto;
+      [eapply tr_rel_refl; eapply ev_rel_refl| |].
+      { left. split. apply plus_one. eauto. eapply semantics_receptive_at; auto. }
+      right. eapply CIH; eauto. eapply sound_step; eauto.
+    + i. exploit transf_final_states; eauto. i. eapply final_state_determ; eauto.
+  - right. econs; eauto. i. econs.
+    + i. unfold is_external in *.
+      exploit match_states_bsim; eauto. ss. i. des; subst.
+      { left. esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl| |].
+        { left. eapply plus_one. eauto. }
+        right. eapply CIH; eauto. eapply sound_step; eauto. }
+      { right. esplits; eauto; [|eapply tr_rel_refl; eapply ev_rel_refl].
+        eapply star_one; eauto. }
+    + i. inv FINALTGT; inv MATCH; ss.
+    + i. specialize (SAFESRC _ (star_refl _ _ _)). des; ss; [inv SAFESRC; ss|].
+      right. inv MATCH; ss; des_ifs.
+      * destruct (classic (exists chunk, e0 = EF_vload chunk)).
+        { TransfInstr; UseTransfer.
+          assert (TI0: (fn_code tf) ! pc = Some (Ibuiltin e0 l b n)).
+          { des_ifs. } clear TI.
+          des. subst. ss.
+          inv SAFESRC; clarify. des_ifs.
+          { inv H8. inv H9. }
+          2:{ inv H8. inv H3. inv H9. }
+          ss. inv H9.
+          destruct (transfer_builtin_arg All
+                   (kill_builtin_res b ne, nmem_add nm (aaddr_arg (vanalyze cu f) # pc b0) (size_chunk chunk)) b0) as (ne1, nm1) eqn: TR.
+          ss. InvSoundState.
+          exploit transfer_builtin_args_sound; eauto. intros (tvl & A & B & C & D).
+        
+          exploit magree_to_ptr; try eapply TOPTR; eauto. i.
+          assert (X: exists tvres, volatile_load ge chunk tm b1 ofs t tvres).
+          { inv H.
+            - exists (Val.load_result chunk v).
+              econs; eauto. eapply ma_perm; eauto.
+            - des. exploit Mem.load_valid_access; eauto. i.
+              exploit magree_valid_access; eauto. i. exploit Mem.valid_access_load; eauto. i. des.
+              exists v. econs 2; eauto. }
+          des. exists t. esplits. eapply exec_Ibuiltin; eauto.
+          eapply eval_builtin_args_preserved; try eapply A. eapply senv_preserved.
+          ss. instantiate (1:=tm). instantiate (1:=tvres).
+          inv B. inv H5. inv H3; ss. econs; eauto. eapply volatile_load_preserved; eauto.
+          eapply senv_preserved. }
+        TransfInstr; UseTransfer.
+        assert (TI0: (fn_code tf) ! pc = Some (Ibuiltin e0 l b n)).
+        { des_ifs. } clear TI.
+        inv SAFESRC; ss; des_ifs; clarify.
+        replace (transfer_builtin (vanalyze cu f) # pc e0 l b ne nm) with
+            (transfer_builtin_args (kill_builtin_res b ne, nmem_all) l) in *; cycle 1.
+        { unfold transfer_builtin. des_ifs. exfalso. eapply H. eauto. }
+        destruct (transfer_builtin_args (kill_builtin_res b ne, nmem_all) l) as (ne1, nm1) eqn:TR.
+        InvSoundState.
+        exploit transfer_builtin_args_sound; eauto. intros (tvl & A & B & C & D).
+        exploit external_call_mem_extends_backward_progress; eauto.
+        eapply magree_extends; eauto. intros. apply nlive_all. i. des. esplits.
+        eapply exec_Ibuiltin; eauto.
+        apply eval_builtin_args_preserved with (ge1 := ge); eauto. exact symbols_preserved.
+        eapply external_call_symbols_preserved. apply senv_preserved. eauto.
+      * inv SAFESRC; unfold ge in *; clarify.
+        exploit external_call_mem_extends_backward_progress; eauto. i. des.
+        simpl in FUN. inv FUN.
+        exploit external_call_symbols_preserved. eapply senv_preserved. eauto. i.
+        exploit exec_function_external; eauto.
+Qed.
+
+Lemma non_static_equiv l:
+  Genv.non_static_glob (Genv.globalenv prog) l = Genv.non_static_glob (Genv.globalenv tprog) l.
+Proof.
+  Local Transparent ge tge.
+  induction l; ss.
+  specialize senv_preserved. ss. i. inv H. inv H1. unfold ge, tge, fundef in *.
+  specialize (H a). unfold Senv.public_symbol in H. ss. erewrite H.
+  specialize (H0 a). rewrite <- H0. erewrite IHl; eauto.
+Qed.
+
+Lemma transf_initial_capture S1 S2 S2'
+    (INITSRC: initial_state prog S1)
+    (INITTGT: initial_state tprog S2)
+    (MATCH: match_states S1 S2)
+    (CAPTGT: glob_capture tprog S2 S2'):
+  exists S1', glob_capture prog S1 S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (concrete_snapshot ge S1') (concrete_snapshot tge S2').
+Proof.
+  specialize senv_preserved. intros SENVEQ.
+  inv CAPTGT. ss. rename m' into m2'.
+  rewrite Genv.globalenv_public in CAPTURE. erewrite <- same_public in CAPTURE; eauto.
+  inv MATCH. inv ARGS. inv STACKS.
+  exploit non_static_equiv. instantiate (1:=AST.prog_public prog). intros EQUIV.
+  assert (exists m1', Genv.capture_init_mem m0 (Genv.non_static_glob (Genv.globalenv prog) (AST.prog_public prog)) m1' /\
+                     Mem.extends m1' m2').
+  { clear LINK INITSRC INITTGT. rewrite <- EQUIV in CAPTURE. clear EQUIV. inv CAPTURE.
+    remember (Genv.non_static_glob (Genv.globalenv prog) (prog_public prog)) as l. clear Heql.
+    clear SENVEQ. move m0 after f. move l before f. revert_until f.
+    induction l; ss; i.
+    { inv CAP. esplits; eauto. econs. econs. }
+    inv CAP. exploit Mem.capture_extends_backward; eauto. i. des.
+    exploit IHl; eauto. i. des. inv H. esplits; eauto. econs. econs; eauto. }
+  des. esplits; eauto.
+  - econs. eauto. rewrite Genv.globalenv_public. eauto.
+  - econs; eauto. econs.
+  - ii. unfold concrete_snapshot in *. inv SENVEQ. des. erewrite H3, H2. des_ifs; ss.
+    eapply Mem.mext_concrete; eauto. eapply Mem.concrete_valid; eauto.
+Qed.
+
 (** * Semantic preservation *)
 
 Theorem transf_program_correct:
-  forward_simulation (RTL.semantics prog) (RTL.semantics tprog).
+  mixed_simulation (RTL.semantics prog) (RTL.semantics tprog).
 Proof.
-  intros.
-  apply forward_simulation_step with
-     (match_states := fun s1 s2 => sound_state prog s1 /\ match_states s1 s2).
-- apply senv_preserved.
-- simpl; intros. exploit transf_initial_states; eauto. intros [st2 [A B]].
-  exists st2; intuition. eapply sound_initial; eauto.
-- simpl; intros. destruct H. eapply transf_final_states; eauto.
-- simpl; intros. destruct H0.
-  assert (sound_state prog s1') by (eapply sound_step; eauto).
-  fold ge; fold tge. exploit step_simulation; eauto. intros [st2' [A B]].
-  exists st2'; auto.
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (S a). lia.
+  - econs. i. exploit transf_initial_states; eauto. i. des.
+    exists st2. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. inversion INITSRC; subst. inversion H0; subst.
+      inv ARGS. inv STACKS.
+      exploit transf_initial_capture; eauto. i. des.
+      exists 0%nat. exists S1'. esplits; eauto. apply match_states_xsim; auto.
+      eapply sound_capture_initial; eauto.
+  - i. apply senv_preserved.
 Qed.
 
 End PRESERVATION.
diff --git a/backend/Debugvarproof.v b/backend/Debugvarproof.v
index d31c63ec..d5b9ffae 100644
--- a/backend/Debugvarproof.v
+++ b/backend/Debugvarproof.v
@@ -14,9 +14,11 @@
 
 Require Import Axioms Coqlib Maps Iteration Errors.
 Require Import Integers Floats AST Linking.
+Require Import CoqlibC Simulation LinearD PointerOp Classical.
 Require Import Values Memory Events Globalenvs Smallstep.
 Require Import Machregs Locations Conventions Op Linear.
 Require Import Debugvar.
+From Paco Require Import paco.
 
 (** * Relational characterization of the transformation *)
 
@@ -294,6 +296,9 @@ Hypothesis TRANSF: match_prog prog tprog.
 Let ge := Genv.globalenv prog.
 Let tge := Genv.globalenv tprog.
 
+Let sem := Linear.semantics prog.
+Let tsem := Linear.semantics tprog.
+
 Lemma symbols_preserved:
   forall (s: ident), Genv.find_symbol tge s = Genv.find_symbol ge s.
 Proof (Genv.find_symbol_match TRANSF).
@@ -355,7 +360,7 @@ Qed.
 
 Lemma eval_add_delta_ranges:
   forall s f sp c rs m before after,
-  star step tge (State s f sp (add_delta_ranges before after c) rs m)
+  DStar tsem (State s f sp (add_delta_ranges before after c) rs m)
              E0 (State s f sp c rs m).
 Proof.
   intros. unfold add_delta_ranges.
@@ -366,13 +371,13 @@ Proof.
 + destruct i as [a SAFE]; simpl.
   exploit can_eval_safe_arg; eauto. intros [v1 E1].
   eapply star_step; eauto.
-  econstructor.
+  DStep_tac. econstructor.
   constructor. eexact E1. constructor.
   simpl; constructor.
   simpl; auto.
   traceEq.
 - eapply star_step; eauto.
-  econstructor.
+  DStep_tac. econstructor.
   constructor.
   simpl; constructor.
   simpl; auto.
@@ -421,30 +426,31 @@ Qed.
 (** The simulation diagram. *)
 
 Theorem transf_step_correct:
-  forall s1 t s2, step ge s1 t s2 ->
+  forall s1 t s2, IStep sem s1 t s2 ->
   forall ts1 (MS: match_states s1 ts1),
-  exists ts2, plus step tge ts1 t ts2 /\ match_states s2 ts2.
+  exists ts2, DPlus tsem ts1 t ts2 /\ match_states s2 ts2.
 Proof.
+  destruct 1. generalize dependent s2. rename H into INT.
   induction 1; intros ts1 MS; inv MS; try (inv TRC).
 - (* getstack *)
   econstructor; split.
-  eapply plus_left. constructor; auto. apply eval_add_delta_ranges. traceEq.
+  eapply plus_left. DStep_tac. constructor; auto. apply eval_add_delta_ranges. traceEq.
   constructor; auto.
 - (* setstack *)
   econstructor; split.
-  eapply plus_left. constructor; auto. apply eval_add_delta_ranges. traceEq.
+  eapply plus_left. DStep_tac. constructor; auto. apply eval_add_delta_ranges. traceEq.
   constructor; auto.
 - (* op *)
   econstructor; split.
   eapply plus_left.
-  econstructor; eauto.
-  instantiate (1 := v). rewrite <- H; apply eval_operation_preserved; exact symbols_preserved.
+  DStep_tac. econstructor; eauto.
+  instantiate (1 := v). rewrite <- H; apply eval_operation_wrapper_preserved; exact symbols_preserved.
   apply eval_add_delta_ranges. traceEq.
   constructor; auto.
 - (* load *)
   econstructor; split.
   eapply plus_left.
-  eapply exec_Lload with (a := a).
+  DStep_tac. eapply exec_Lload with (a := a).
   rewrite <- H; apply eval_addressing_preserved; exact symbols_preserved.
   eauto. eauto.
   apply eval_add_delta_ranges. traceEq.
@@ -452,7 +458,7 @@ Proof.
 - (* store *)
   econstructor; split.
   eapply plus_left.
-  eapply exec_Lstore with (a := a).
+  DStep_tac. eapply exec_Lstore with (a := a).
   rewrite <- H; apply eval_addressing_preserved; exact symbols_preserved.
   eauto. eauto.
   apply eval_add_delta_ranges. traceEq.
@@ -461,69 +467,69 @@ Proof.
   exploit find_function_translated; eauto. intros (tf' & A & B).
   econstructor; split.
   apply plus_one.
-  econstructor. eexact A. symmetry; apply sig_preserved; auto. traceEq.
+  DStep_tac. econstructor. eexact A. symmetry; apply sig_preserved; auto. traceEq.
   constructor; auto. constructor; auto. constructor; auto.
 - (* tailcall *)
   exploit find_function_translated; eauto. intros (tf' & A & B).
   exploit parent_locset_match; eauto. intros PLS.
   econstructor; split.
   apply plus_one.
-  econstructor. eauto. rewrite PLS. eexact A.
+  DStep_tac. econstructor. eauto. rewrite PLS. eexact A.
   symmetry; apply sig_preserved; auto.
   inv TRF; eauto. traceEq.
   rewrite PLS. constructor; auto.
 - (* builtin *)
   econstructor; split.
   eapply plus_left.
-  econstructor; eauto.
+  DStep_tac. econstructor; eauto.
   eapply eval_builtin_args_preserved with (ge1 := ge); eauto. exact symbols_preserved.
   eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   apply eval_add_delta_ranges. traceEq.
   constructor; auto.
 - (* label *)
   econstructor; split.
-  eapply plus_left. constructor; auto. apply eval_add_delta_ranges. traceEq.
+  eapply plus_left. DStep_tac. constructor; auto. apply eval_add_delta_ranges. traceEq.
   constructor; auto.
 - (* goto *)
   exploit find_label_match; eauto. intros (before' & after' & tc' & A & B).
   econstructor; split.
-  eapply plus_left. constructor; eauto. apply eval_add_delta_ranges; eauto. traceEq.
+  eapply plus_left. DStep_tac. constructor; eauto. apply eval_add_delta_ranges; eauto. traceEq.
   constructor; auto.
 - (* cond taken *)
   exploit find_label_match; eauto. intros (before' & after' & tc' & A & B).
   econstructor; split.
-  eapply plus_left. eapply exec_Lcond_true; eauto. apply eval_add_delta_ranges; eauto. traceEq.
+  eapply plus_left. DStep_tac. eapply exec_Lcond_true; eauto. apply eval_add_delta_ranges; eauto. traceEq.
   constructor; auto.
 - (* cond not taken *)
   econstructor; split.
-  eapply plus_left. eapply exec_Lcond_false; auto. apply eval_add_delta_ranges. traceEq.
+  eapply plus_left. DStep_tac. eapply exec_Lcond_false; auto. apply eval_add_delta_ranges. traceEq.
   constructor; auto.
 - (* jumptable *)
   exploit find_label_match; eauto. intros (before' & after' & tc' & A & B).
   econstructor; split.
-  eapply plus_left. econstructor; eauto.
+  eapply plus_left. DStep_tac. econstructor; eauto.
   apply eval_add_delta_ranges. reflexivity. traceEq.
   constructor; auto.
 - (* return *)
   econstructor; split.
-  apply plus_one.  constructor. inv TRF; eauto. traceEq.
+  apply plus_one. DStep_tac. constructor. inv TRF; eauto. traceEq.
   rewrite (parent_locset_match _ _ STACKS). constructor; auto.
 - (* internal function *)
   monadInv H7. rename x into tf.
   assert (MF: match_function f tf) by (apply transf_function_match; auto).
   inversion MF; subst.
   econstructor; split.
-  apply plus_one. constructor. simpl; eauto. reflexivity.
+  apply plus_one. DStep_tac. constructor. simpl; eauto. reflexivity.
   constructor; auto.
 - (* external function *)
   monadInv H8. econstructor; split.
-  apply plus_one. econstructor; eauto.
+  apply plus_one. DStep_tac. econstructor; eauto.
   eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   constructor; auto.
 - (* return *)
   inv H3. inv H1.
   econstructor; split.
-  eapply plus_left. econstructor. apply eval_add_delta_ranges. traceEq.
+  eapply plus_left. DStep_tac. econstructor. apply eval_add_delta_ranges. traceEq.
   constructor; auto.
 Qed.
 
@@ -547,14 +553,105 @@ Proof.
   intros. inv H0. inv H. inv H5. econstructor; eauto.
 Qed.
 
+Lemma match_states_xsim n st_src0 st_tgt0 gmtgt
+    (MATCH: match_states st_src0 st_tgt0) :
+  xsim (Linear.semantics prog) (Linear.semantics tprog) gmtgt lt n%nat st_src0 st_tgt0.
+Proof.
+  generalize dependent n. generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold.
+  destruct (classic (is_external ge st_src0)); cycle 1.
+  - econs. econs; ss. econs; i.
+    + exploit transf_step_correct; eauto. i. des.
+      esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl|].
+      left. esplits; eauto. eapply semantics_receptive_at; eauto.
+    + ii. eapply final_state_determ; eauto.
+      inv FINALSRC. inv MATCH. inv H5. econs; eauto.
+  (* external *)
+  - unfold is_external in H. ss. des_ifs.
+    + right. econs. ii.
+      unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)).
+      des; cycle 2; clarify; [inv SAFESRC|]. econs.
+      * ii. left. inv MATCH; try inv TRC.
+        inv STEPTGT; ss; clarify.
+        esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl| |].
+        { left. eapply plus_one. econs; eauto.
+          { eapply eval_builtin_args_preserved; try eapply H12.
+            destruct senv_preserved. ii. symmetry. eapply H0. }
+          { eapply external_call_symbols_preserved; eauto.
+            symmetry. eapply senv_preserved. } }
+        exploit eval_add_delta_ranges. i.
+        exploit star_inv; eauto. i. des; subst.
+        { right. eapply CIH. econs; eauto. inv H1. rewrite <- H5. eauto. }
+        { left. pfold. left. econs. econs 2. esplits; eauto.
+          right. eapply CIH; eauto. econs; eauto. }
+      * ii. inv MATCH. inv FINALTGT.
+      * i. right. inv MATCH; try inv TRC. inv SAFESRC; unfold ge in *; clarify.
+        esplits. econs; eauto.
+        { eapply eval_builtin_args_preserved. eapply senv_preserved. eauto. }
+        { eapply external_call_symbols_preserved; eauto. apply senv_preserved. }
+    + right. econs. i.
+      unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)).
+      des; cycle 2; clarify; [inv SAFESRC|].
+      inv MATCH; try inv TRC; ss; clarify. econs.
+      * ii. inv STEPTGT; ss; clarify.
+        left. esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl| |].
+        { left. eapply plus_one. econs; eauto.
+          eapply external_call_symbols_preserved; eauto.
+          symmetry. eapply senv_preserved. }
+        right. eapply CIH. econs; eauto.
+      * ii. inv FINALTGT.
+      * ii. inv SAFESRC. right. esplits; eauto. econs; eauto.
+        eapply external_call_symbols_preserved; eauto.
+        eapply senv_preserved.
+Unshelve. all: eapply O.
+Qed.
+
+Lemma non_static_equiv l:
+  Genv.non_static_glob (Genv.globalenv prog) l = Genv.non_static_glob (Genv.globalenv tprog) l.
+Proof.
+  Local Transparent ge tge.
+  induction l; ss.
+  specialize senv_preserved. ss. i. inv H. inv H1. unfold ge, tge, fundef in *.
+  specialize (H a). unfold Senv.public_symbol in H. ss. erewrite H.
+  specialize (H0 a). rewrite <- H0. erewrite IHl; eauto.
+Qed.
+
+Lemma same_public: prog_public prog = prog_public tprog.
+Proof. inv TRANSF. des; eauto. Qed.
+
+Lemma transf_initial_capture S1 S2 S2'
+    (INITSRC: initial_state prog S1)
+    (INITTGT: initial_state tprog S2)
+    (MATCH: match_states S1 S2)
+    (CAPTGT: glob_capture tprog S2 S2'):
+  exists S1', glob_capture prog S1 S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (concrete_snapshot ge S1') (concrete_snapshot tge S2').
+Proof.
+  inv CAPTGT. ss.
+  rewrite Genv.globalenv_public in CAPTURE.
+  rewrite <- same_public in CAPTURE. erewrite <- non_static_equiv in CAPTURE.
+  inv MATCH. inv H2. esplits.
+  - econs; eauto. rewrite Genv.globalenv_public. eauto.
+  - econs. econs. eauto.
+  - specialize senv_preserved. intros SENVEQ. destruct SENVEQ. des.
+    unfold concrete_snapshot. ii. erewrite H0, H. des_ifs; ss.
+Qed.
+
 Theorem transf_program_correct:
-  forward_simulation (semantics prog) (semantics tprog).
+  mixed_simulation (semantics prog) (semantics tprog).
 Proof.
-  eapply forward_simulation_plus.
-  apply senv_preserved.
-  eexact transf_initial_states.
-  eexact transf_final_states.
-  eexact transf_step_correct.
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (1 + a)%nat. lia.
+  - econs. i. exploit transf_initial_states; eauto. i. des.
+    exists st2. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. exploit transf_initial_capture; eauto. i. des. subst.
+      eexists 0%nat. esplits; eauto. apply match_states_xsim; auto.
+  - i. apply senv_preserved.
 Qed.
 
 End PRESERVATION.
diff --git a/backend/Inliningproof.v b/backend/Inliningproof.v
index 0434a4a4..f5ed1d81 100644
--- a/backend/Inliningproof.v
+++ b/backend/Inliningproof.v
@@ -13,9 +13,11 @@
 (** RTL function inlining: semantic preservation *)
 
 Require Import Coqlib Wfsimpl Maps Errors Integers.
+Require Import Simulation RTLD Classical PointerOp.
 Require Import AST Linking Values Memory Globalenvs Events Smallstep.
 Require Import Op Registers RTL.
 Require Import Inlining Inliningspec.
+From Paco Require Import paco.
 
 Definition match_prog (prog tprog: program) :=
   match_program (fun cunit f tf => transf_fundef (funenv_program cunit) f = OK tf) eq prog tprog.
@@ -34,6 +36,9 @@ Hypothesis TRANSF: match_prog prog tprog.
 Let ge := Genv.globalenv prog.
 Let tge := Genv.globalenv tprog.
 
+Let sem := semantics prog.
+Let tsem := semantics tprog.
+
 Lemma symbols_preserved:
   forall (s: ident), Genv.find_symbol tge s = Genv.find_symbol ge s.
 Proof (Genv.find_symbol_match TRANSF).
@@ -42,6 +47,10 @@ Lemma senv_preserved:
   Senv.equiv ge tge.
 Proof (Genv.senv_match TRANSF).
 
+Lemma same_public:
+  prog_public prog = prog_public tprog.
+Proof. inv TRANSF. des; eauto. Qed.
+
 Lemma functions_translated:
   forall (v: val) (f: fundef),
   Genv.find_funct ge v = Some f ->
@@ -224,7 +233,7 @@ Lemma tr_moves_init_regs:
   (forall r, In r rdsts -> Ple r ctx2.(mreg)) ->
   list_forall2 (val_reg_charact F ctx1 rs1) vl rsrcs ->
   exists rs2,
-    star step tge (State stk f sp pc1 rs1 m)
+    DStar tsem (State stk f sp pc1 rs1 m)
                E0 (State stk f sp pc2 rs2 m)
   /\ agree_regs F ctx2 (init_regs vl rdsts) rs2
   /\ forall r, Plt r ctx2.(dreg) -> rs2#r = rs1#r.
@@ -238,7 +247,7 @@ Proof.
   simpl in H0. inv H0.
   exploit IHrdsts; eauto. intros [rs2 [A [B C]]].
   exists (rs2#(sreg ctx2 a) <- (rs2#(sreg ctx1 b1))).
-  split. eapply star_right. eauto. eapply exec_Iop; eauto. traceEq.
+  split. eapply star_right. eauto. DStep_tac. eapply exec_Iop; eauto. traceEq.
   split. destruct H3 as [[P Q] | [P Q]].
   subst a1. eapply agree_set_reg_undef; eauto.
   eapply agree_set_reg; eauto. rewrite C; auto.  apply context_below_lt; auto.
@@ -365,24 +374,44 @@ Inductive match_globalenvs (F: meminj) (bound: block): Prop :=
       (VARINFOS: forall b gv, Genv.find_var_info ge b = Some gv -> Plt b bound).
 
 Lemma find_function_agree:
-  forall ros rs fd F ctx rs' bound,
-  find_function ge ros rs = Some fd ->
+  forall ros rs fd F ctx rs' bound m m' (INJ: Mem.inject F m m'),
+  find_function ge (ros_to_vos m ros rs) rs = Some fd ->
   agree_regs F ctx rs rs' ->
   match_globalenvs F bound ->
   exists cu fd',
-  find_function tge (sros ctx ros) rs' = Some fd' /\ transf_fundef (funenv_program cu) fd = OK fd' /\ linkorder cu prog.
+  find_function tge (ros_to_vos m' (sros ctx ros) rs') rs' = Some fd' /\ transf_fundef (funenv_program cu) fd = OK fd' /\ linkorder cu prog.
 Proof.
   intros. destruct ros as [r | id]; simpl in *.
 - (* register *)
+  des_ifs_safe. destruct (rs # r) eqn:RSV; try by ss.
+  { destruct (Int64.eq i Int64.zero) eqn:NEQ; [ss|].
+    des_ifs_safe. exploit Mem.denormalize_inject; eauto. i. des.
+    assert (FINDF: Genv.find_funct ge (Vptr b (Ptrofs.repr z)) = Some fd) by ss.
+    assert (EQ: rs'#(sreg ctx r) = rs#r).
+    { exploit Genv.find_funct_inv; eauto. intros [b0 EQ].
+      assert (A: Val.inject F rs#r rs'#(sreg ctx r)). eapply agree_val_reg; eauto.
+      clarify. rename RSV into EQ. clear H. rename FINDF into H.
+      rewrite EQ in A; inv A. des_ifs_safe. }
+    rewrite EQ. rewrite RSV. rewrite NEQ. rewrite DENOTGT.
+    eapply functions_translated; eauto.
+    inv H1. inv VINJ. erewrite DOMAIN in H4; clarify.
+    { ss. des_ifs_safe.
+      exploit Mem.denormalize_inject; eauto. i. des.
+      clarify. inv VINJ.
+      assert (delta = 0).
+      { exploit FUNCTIONS; eauto. i. exploit DOMAIN; eauto. i. clarify. }
+      subst. rewrite e in H7. rewrite Ptrofs.add_zero_l in H7.
+      rewrite H7 in n. exfalso. eapply n; eauto. }
+    eapply FUNCTIONS. ss. des_ifs. eauto. }
+  assert (FINDF: Genv.find_funct ge (Vptr b i) = Some fd) by ss.
   assert (EQ: rs'#(sreg ctx r) = rs#r).
-  { exploit Genv.find_funct_inv; eauto. intros [b EQ].
+  { exploit Genv.find_funct_inv; eauto. intros [b0 EQ].
     assert (A: Val.inject F rs#r rs'#(sreg ctx r)). eapply agree_val_reg; eauto.
+    clarify. rename RSV into EQ. clear H. rename FINDF into H.
     rewrite EQ in A; inv A.
     inv H1. rewrite DOMAIN in H5. inv H5. auto.
-    apply FUNCTIONS with fd.
-    rewrite EQ in H; rewrite Genv.find_funct_find_funct_ptr in H. auto.
-  }
-  rewrite EQ. eapply functions_translated; eauto.
+    apply FUNCTIONS with fd. auto. }
+  rewrite EQ. rewrite RSV. eapply functions_translated; eauto.
 - (* symbol *)
   rewrite symbols_preserved. destruct (Genv.find_symbol ge id); try discriminate.
   eapply function_ptr_translated; eauto.
@@ -931,29 +960,30 @@ Qed.
 
 Theorem step_simulation:
   forall S1 t S2,
-  step ge S1 t S2 ->
+  IStep sem S1 t S2 ->
   forall S1' (MS: match_states S1 S1'),
-  (exists S2', plus step tge S1' t S2' /\ match_states S2 S2')
+  (exists S2', DPlus tsem S1' t S2' /\ match_states S2 S2')
   \/ (measure S2 < measure S1 /\ t = E0 /\ match_states S2 S1')%nat.
 Proof.
+  destruct 1. generalize dependent S2. rename H into INT.
   induction 1; intros; inv MS.
 
 - (* nop *)
   exploit tr_funbody_inv; eauto. intros TR; inv TR.
   left; econstructor; split.
-  eapply plus_one. eapply exec_Inop; eauto.
+  eapply plus_one. DStep_tac. eapply exec_Inop; eauto.
   econstructor; eauto.
 
 - (* op *)
   exploit tr_funbody_inv; eauto. intros TR; inv TR.
-  exploit eval_operation_inject.
+  exploit eval_operation_wrapper_inject.
     eapply match_stacks_inside_globals; eauto.
     eexact SP.
     instantiate (2 := rs##args). instantiate (1 := rs'##(sregs ctx args)). eapply agree_val_regs; eauto.
     eexact MINJ. eauto.
   fold (sop ctx op). intros [v' [A B]].
   left; econstructor; split.
-  eapply plus_one. eapply exec_Iop; eauto. erewrite eval_operation_preserved; eauto.
+  eapply plus_one. DStep_tac. eapply exec_Iop; eauto. erewrite eval_operation_wrapper_preserved; eauto.
   exact symbols_preserved.
   econstructor; eauto.
   apply match_stacks_inside_set_reg; auto.
@@ -971,7 +1001,7 @@ Proof.
   assert (eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr) rs' ## (sregs ctx args) = Some a').
   rewrite <- P. apply eval_addressing_preserved. exact symbols_preserved.
   left; econstructor; split.
-  eapply plus_one. eapply exec_Iload; eauto.
+  eapply plus_one. DStep_tac. eapply exec_Iload; eauto.
   econstructor; eauto.
   apply match_stacks_inside_set_reg; auto.
   apply agree_set_reg; auto.
@@ -989,9 +1019,19 @@ Proof.
   assert (eval_addressing tge (Vptr sp' Ptrofs.zero) (saddr ctx addr) rs' ## (sregs ctx args) = Some a').
     rewrite <- P. apply eval_addressing_preserved. exact symbols_preserved.
   left; econstructor; split.
-  eapply plus_one. eapply exec_Istore; eauto.
+  eapply plus_one. DStep_tac. eapply exec_Istore; eauto.
   destruct a; simpl in H1; try discriminate.
+  { destruct a'; simpl in U; cycle 1; clarify; inv Q. des_ifs_safe.
+    exploit Mem.denormalize_inject; try eapply MINJ; eauto. i. des. clarify.
+    econstructor; eauto.
+    eapply match_stacks_inside_store; eauto.
+    eapply Mem.store_valid_block_1; eauto.
+    eapply range_private_invariant; eauto.
+    intros; split; auto. eapply Mem.perm_store_2; eauto.
+    intros; eapply Mem.perm_store_1; eauto.
+    intros. eapply SSZ2. eapply Mem.perm_store_2; eauto. }
   destruct a'; simpl in U; try discriminate.
+  { inv Q. }
   econstructor; eauto.
   eapply match_stacks_inside_store; eauto.
   eapply Mem.store_valid_block_1; eauto.
@@ -1006,7 +1046,7 @@ Proof.
   exploit tr_funbody_inv; eauto. intros TR; inv TR.
 + (* not inlined *)
   left; econstructor; split.
-  eapply plus_one. eapply exec_Icall; eauto.
+  eapply plus_one. DStep_tac. eapply exec_Icall; eauto.
   eapply sig_function_translated; eauto.
   econstructor; eauto.
   eapply match_stacks_cons; eauto.
@@ -1037,7 +1077,7 @@ Proof.
     inv FB. eapply range_private_perms; eauto. extlia.
   destruct X as [m1' FREE].
   left; econstructor; split.
-  eapply plus_one. eapply exec_Itailcall; eauto.
+  eapply plus_one. DStep_tac. eapply exec_Itailcall; eauto.
   eapply sig_function_translated; eauto.
   econstructor; eauto.
   eapply match_stacks_bound with (bound := sp').
@@ -1054,7 +1094,7 @@ Proof.
   apply Mem.perm_max with k. apply Mem.perm_implies with p; auto with mem.
 + (* turned into a call *)
   left; econstructor; split.
-  eapply plus_one. eapply exec_Icall; eauto.
+  eapply plus_one. DStep_tac. eapply exec_Icall; eauto.
   eapply sig_function_translated; eauto.
   econstructor; eauto.
   eapply match_stacks_untailcall; eauto.
@@ -1077,14 +1117,17 @@ Proof.
     lia.
 
 - (* builtin *)
+  unfold is_internal in INT. ss. des_ifs.
   exploit tr_funbody_inv; eauto. intros TR; inv TR.
   exploit match_stacks_inside_globalenvs; eauto. intros [bound MG].
   exploit tr_builtin_args; eauto. intros (vargs' & P & Q).
-  exploit external_call_mem_inject; eauto.
+  exploit ec_mem_inject; eauto.
+    eapply external_call_spec; eauto.
+    eapply meminj_preserves_globals_to_symbols_inject.
     eapply match_stacks_inside_globals; eauto.
   intros [F1 [v1 [m1' [A [B [C [D [E [J K]]]]]]]]].
   left; econstructor; split.
-  eapply plus_one. eapply exec_Ibuiltin; eauto.
+  eapply plus_one. DStep_tac. eapply exec_Ibuiltin; eauto.
     eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   econstructor.
     eapply match_stacks_inside_set_res.
@@ -1102,10 +1145,10 @@ Proof.
 
 - (* cond *)
   exploit tr_funbody_inv; eauto. intros TR; inv TR.
-  assert (eval_condition cond rs'##(sregs ctx args) m' = Some b).
-    eapply eval_condition_inject; eauto. eapply agree_val_regs; eauto.
+  assert (eval_condition_wrapper cond rs'##(sregs ctx args) m' = Some b).
+    eapply eval_condition_wrapper_inject; eauto. eapply agree_val_regs; eauto.
   left; econstructor; split.
-  eapply plus_one. eapply exec_Icond; eauto.
+  eapply plus_one. DStep_tac. eapply exec_Icond; eauto.
   destruct b; econstructor; eauto.
 
 - (* jumptable *)
@@ -1113,7 +1156,7 @@ Proof.
   assert (Val.inject F rs#arg rs'#(sreg ctx arg)). eapply agree_val_reg; eauto.
   rewrite H0 in H2; inv H2.
   left; econstructor; split.
-  eapply plus_one. eapply exec_Ijumptable; eauto.
+  eapply plus_one. DStep_tac. eapply exec_Ijumptable; eauto.
   rewrite list_nth_z_map. rewrite H1. simpl; reflexivity.
   econstructor; eauto.
 
@@ -1130,7 +1173,7 @@ Proof.
     generalize (Zmax_spec (fn_stacksize f) 0). destruct (zlt 0 (fn_stacksize f)); lia.
   destruct X as [m1' FREE].
   left; econstructor; split.
-  eapply plus_one. eapply exec_Ireturn; eauto.
+  eapply plus_one. DStep_tac. eapply exec_Ireturn; eauto.
   econstructor; eauto.
   eapply match_stacks_bound with (bound := sp').
   eapply match_stacks_invariant; eauto.
@@ -1168,7 +1211,7 @@ Proof.
     instantiate (1 := fn_stacksize f'). inv H1. extlia.
   intros [F' [m1' [sp' [A [B [C [D E]]]]]]].
   left; econstructor; split.
-  eapply plus_one. eapply exec_function_internal; eauto.
+  eapply plus_one. DStep_tac. eapply exec_function_internal; eauto.
   rewrite H6. econstructor.
   instantiate (1 := F'). apply match_stacks_inside_base.
   assert (SP: sp' = Mem.nextblock m'0) by (eapply Mem.alloc_result; eauto).
@@ -1220,7 +1263,7 @@ Proof.
   intros [F' [A [B [C D]]]].
   exploit tr_moves_init_regs; eauto. intros [rs'' [P [Q R]]].
   left; econstructor; split.
-  eapply plus_left. eapply exec_Inop; eauto. eexact P. traceEq.
+  eapply plus_left. DStep_tac. eapply exec_Inop; eauto. eexact P. traceEq.
   econstructor.
   eapply match_stacks_inside_alloc_left; eauto.
   eapply match_stacks_inside_invariant; eauto.
@@ -1233,12 +1276,15 @@ Proof.
 
 - (* external function *)
   exploit match_stacks_globalenvs; eauto. intros [bound MG].
-  exploit external_call_mem_inject; eauto.
+  unfold is_internal in INT. ss.
+  exploit ec_mem_inject; eauto.
+    eapply external_call_spec; eauto.
+    eapply meminj_preserves_globals_to_symbols_inject.
     eapply match_globalenvs_preserves_globals; eauto.
   intros [F1 [v1 [m1' [A [B [C [D [E [J K]]]]]]]]].
   simpl in FD. inv FD.
   left; econstructor; split.
-  eapply plus_one. eapply exec_function_external; eauto.
+  eapply plus_one. DStep_tac. eapply exec_function_external; eauto.
     eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   econstructor.
     eapply match_stacks_bound with (Mem.nextblock m'0).
@@ -1253,7 +1299,7 @@ Proof.
   inv MS0.
 + (* normal case *)
   left; econstructor; split.
-  eapply plus_one. eapply exec_return.
+  eapply plus_one. DStep_tac. eapply exec_return.
   econstructor; eauto.
   apply match_stacks_inside_set_reg; auto.
   apply agree_set_reg; auto.
@@ -1261,7 +1307,7 @@ Proof.
   inv MS; try congruence.
   rewrite RET in RET0; inv RET0.
   left; econstructor; split.
-  eapply plus_one. eapply exec_return.
+  eapply plus_one. DStep_tac. eapply exec_return.
   eapply match_regular_states.
   eapply match_stacks_inside_set_reg; eauto.
   eauto. auto.
@@ -1278,11 +1324,11 @@ Proof.
   destruct or.
 + (* with a result *)
   left; econstructor; split.
-  eapply plus_one. eapply exec_Iop; eauto. simpl. reflexivity.
+  eapply plus_one. DStep_tac. eapply exec_Iop; eauto. simpl. reflexivity.
   econstructor; eauto. apply match_stacks_inside_set_reg; auto. apply agree_set_reg; auto.
 + (* without a result *)
   left; econstructor; split.
-  eapply plus_one. eapply exec_Inop; eauto.
+  eapply plus_one. DStep_tac. eapply exec_Inop; eauto.
   econstructor; eauto. subst vres. apply agree_set_reg_undef'; auto.
 Qed.
 
@@ -1319,14 +1365,188 @@ Proof.
   exploit match_stacks_inside_empty; eauto. intros [A B]. congruence.
 Qed.
 
+Lemma match_states_bsim
+      s1
+      (EXT: is_external ge s1)
+      s2 t s2'
+      (STEPTGT: Step tsem s2 t s2')
+      (MATCH: match_states s1 s2)
+      (SAFESRC: safe sem s1)
+  :
+    (exists s1', Step sem s1 t s1' /\ match_states s1' s2')
+    \/ (~ trace_intact t /\ exists s1'' t', Star sem s1 t' s1'' /\ exists tl, t' = (trace_cut_pterm t) ** tl).
+Proof.
+  assert (SEQUIV: Senv.equiv tge ge) by (symmetry; apply senv_preserved).
+  unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+  { inv SAFESRC; inv EXT. }
+  i; inversion MATCH; clarify.
+  (* builtin *)
+  - ss. des_ifs. exploit tr_funbody_inv; eauto. intros TR; inv TR.
+    inv STEPTGT; clarify. inv SAFESRC; clarify.
+    exploit match_stacks_inside_globalenvs; eauto. intros [bound MG].
+    exploit tr_builtin_args; eauto. intros (vargs' & P & Q).
+    exploit eval_builtin_args_determ.
+    { eapply H10. }
+    { eapply P. } i. subst.    
+    exploit external_call_mem_inject_backward. eauto.
+    eapply match_globalenvs_preserves_globals; eauto.
+    eapply external_call_symbols_preserved; eauto. eauto. eauto.
+    i. des; cycle 1.
+    { exploit H; eauto. clarify. }
+    { right. esplits; eauto. eapply star_one.
+      eapply exec_Ibuiltin; eauto. }
+    left. esplits; eauto.
+    + econs; eauto.
+    + econstructor.
+      eapply match_stacks_inside_set_res.
+      eapply match_stacks_inside_extcall with (F1 := F) (F2 := f'0) (m1 := m) (m1' := m'); eauto.
+      intros; eapply external_call_max_perm; eauto.
+      intros; eapply external_call_max_perm; eauto.
+      auto. eauto. auto.
+      destruct b; simpl; [apply agree_set_reg;auto|idtac|idtac]; eapply agree_regs_incr; eauto.
+      auto. auto.
+      eapply external_call_valid_block; eauto.
+      eapply range_private_extcall; eauto.
+      intros; eapply external_call_max_perm; eauto.
+      auto.
+      intros. apply SSZ2. eapply external_call_max_perm; eauto.
+  (* external call *)
+  - inv SAFESRC; ss; clarify. inv STEPTGT; clarify.
+    exploit match_stacks_globalenvs; eauto. intros [bound MG].
+    exploit external_call_mem_inject_backward. eauto.
+    eapply match_globalenvs_preserves_globals; eauto.
+    eapply external_call_symbols_preserved; eauto. eauto. eauto. i. des; cycle 1.
+    { exploit H; eauto. clarify. }
+    { right. esplits; eauto. eapply star_one.
+      eapply exec_function_external; eauto. }
+    left. esplits; eauto.
+    + econs; eauto.
+    + econstructor.
+      eapply match_stacks_bound with (Mem.nextblock m').
+      eapply match_stacks_extcall with (F1 := F) (F2 := f') (m1 := m) (m1' := m'); eauto.
+      intros; eapply external_call_max_perm; eauto.
+      intros; eapply external_call_max_perm; eauto.
+      extlia.
+      eapply external_call_nextblock; eauto.
+      auto. auto.
+Qed.
+
+Lemma match_states_xsim
+    st_src0 st_tgt0 gmtgt
+    (MATCH: match_states st_src0 st_tgt0) :
+  xsim (RTL.semantics prog) (RTL.semantics tprog) gmtgt lt (measure st_src0)%nat st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold.
+  destruct (classic (is_external ge st_src0)); cycle 1; rename H into EXT.
+  - left. econs. econs.
+    + i. exploit step_simulation; eauto. i. destruct H.
+      * des. esplits; eauto.
+        { eapply tr_rel_refl. eapply ev_rel_refl. }
+        { left. split; eauto. eapply semantics_receptive_at; auto. }
+      * des. subst. esplits; eauto. econs.
+    + i. exploit transf_final_states; eauto. i. eapply final_state_determ; eauto.
+  (* external *)
+  - right. assert (SEQUIV: Senv.equiv tge ge) by (symmetry; apply senv_preserved).
+    econs. i. econs.
+    + i. exploit match_states_bsim; eauto. i. des.
+      * left. esplits; eauto.
+        { eapply tr_rel_refl. eapply ev_rel_refl. }
+        left. eapply plus_one. eauto.
+      * right. esplits; eauto. subst. eapply tr_rel_refl. eapply ev_rel_refl.
+    + i. inv FINALTGT; inv MATCH; ss.
+    + i. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+      { inv SAFESRC; ss. }
+      right. inv MATCH; ss; des_ifs; inv SAFESRC; unfold ge in *; clarify.
+      * exploit tr_funbody_inv; eauto. intros TR; inv TR.
+        exploit match_stacks_inside_globalenvs; eauto. intros [bound MG].
+        exploit tr_builtin_args; eauto. intros (vargs' & P & Q).
+        exploit external_call_mem_inject_backward_progress; eauto.
+        eapply match_globalenvs_preserves_globals; eauto. i. des.
+        exploit external_call_symbols_preserved. apply senv_preserved. eauto. i. des. esplits.
+        eapply exec_Ibuiltin; eauto.
+      * exploit match_stacks_globalenvs; eauto. intros [bound MG].
+        exploit external_call_mem_inject_backward_progress; eauto.
+        eapply match_globalenvs_preserves_globals; eauto. i. des.
+        exploit external_call_symbols_preserved. apply senv_preserved. eauto. i.
+        simpl in FD. inv FD. esplits. eapply exec_function_external; eauto.
+Qed.
+
+Lemma non_static_equiv j l hi (MGE: match_globalenvs j hi):
+  Forall2 (fun b b' => (j b = Some (b', 0)) /\ b = b') (Genv.non_static_glob (Genv.globalenv prog) l) (Genv.non_static_glob (Genv.globalenv tprog) l).
+Proof.
+  induction l; ss.
+  destruct (Genv.find_symbol (Genv.globalenv prog) a) eqn:FS1; cycle 1.
+  - destruct (Genv.find_symbol (Genv.globalenv tprog) a) eqn:FS2; cycle 1.
+    { unfold Genv.public_symbol. des_ifs. }
+    destruct senv_preserved. des. unfold Senv.find_symbol in *. ss. erewrite H in FS2.
+    Local Transparent ge tge. unfold ge, fundef in *. ss. clarify.
+  - destruct (Genv.public_symbol (Genv.globalenv prog) a) eqn:PS1; cycle 1.
+    { des_ifs. destruct senv_preserved. des. ss. erewrite H0 in Heq.
+      unfold ge, fundef in *. clarify. }
+    destruct senv_preserved. des. ss. erewrite <- H0 in PS1.
+    unfold tge, fundef in *. erewrite PS1. erewrite H. unfold ge. rewrite FS1. econs; eauto.
+    inv MGE. esplits; eauto.
+Qed.
+
+Lemma transf_initial_capture
+    S1 S2 S2'
+    (INITSRC: initial_state prog S1)
+    (INITTGT: initial_state tprog S2)
+    (MATCH: match_states S1 S2)
+    (CAPTGT: glob_capture tprog S2 S2'):
+  exists S1', glob_capture prog S1 S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (concrete_snapshot ge S1') (concrete_snapshot tge S2').
+Proof.
+  specialize senv_preserved. intros SENVEQ.
+  inv CAPTGT. ss. rename m' into m2'.
+  rewrite Genv.globalenv_public in CAPTURE. erewrite <- same_public in CAPTURE; eauto.
+  dup INITSRC. inv INITSRC0.
+  inv MATCH. inv MS. inv VINJ.
+  exploit non_static_equiv. eapply MG. instantiate (1:=prog_public prog). intros EQUIV.
+  assert (exists m1', Genv.capture_init_mem m0 (Genv.non_static_glob (Genv.globalenv prog) (prog_public prog)) m1' /\
+                     Mem.inject F m1' m2').
+  { clear - SENVEQ MINJ EQUIV CAPTURE.
+    ginduction EQUIV; ss; ii.
+    - exists m0. inv CAPTURE. inv CAP. esplits; eauto. econs. econs.
+    - inv CAPTURE. inv CAP. des; subst.
+      exploit Mem.capture_inject_backward; try eapply INJ; eauto.
+      { instantiate (2:=addr). instantiate (1:= m2). rewrite Z.sub_0_r. eauto. }
+      i. des. exploit IHEQUIV; try eapply MEM. eauto. econs; eauto. i. des.
+      inv H0. esplits; eauto. econs; eauto. econs; eauto. }
+  des. esplits; eauto.
+  - econs; try eapply H2; eauto. ss. rewrite Genv.globalenv_public. eauto.
+  - econs; eauto; cycle 1.
+    { econs; eauto. inv CAPTURE. exploit Mem.capture_list_nextblock; eauto.
+      i. rewrite <- H5. eauto. }
+  - ii. unfold concrete_snapshot in *. inv SENVEQ. des. erewrite H7, H6. des_ifs; ss.
+    inv MG.
+    assert (F b0 = Some (b0, 0)).
+    { inv H. exploit SYMBOLS; eauto. }
+    exploit Mem.mi_src_concrete_public; eauto. i. erewrite H10. f_equal. lia.
+Qed.
+
 Theorem transf_program_correct:
-  forward_simulation (semantics prog) (semantics tprog).
+  mixed_simulation (RTL.semantics prog) (RTL.semantics tprog).
 Proof.
-  eapply forward_simulation_star.
-  apply senv_preserved.
-  eexact transf_initial_states.
-  eexact transf_final_states.
-  eexact step_simulation.
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (S a). lia.
+  - econs. i. exploit transf_initial_states; eauto. i. des.
+    exists st2. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. inversion INITSRC; subst. inversion H; subst. inversion H0; subst.
+      exploit transf_initial_capture.
+      { eapply INITSRC. }
+      { eapply H. }
+      { eapply H0. }
+      { eauto. }
+      i. des.
+      exists (measure S1'). esplits; eauto. apply match_states_xsim; auto.
+  - i. apply senv_preserved.
 Qed.
 
 End INLINING.
diff --git a/backend/LTL.v b/backend/LTL.v
index 5e7eec8c..f6e9ca4a 100644
--- a/backend/LTL.v
+++ b/backend/LTL.v
@@ -18,6 +18,7 @@
 Require Import Coqlib Maps.
 Require Import AST Integers Values Events Memory Globalenvs Smallstep.
 Require Import Op Locations Conventions.
+Require Import Simulation PointerOp.
 
 (** * Abstract syntax *)
 
@@ -160,6 +161,25 @@ Inductive state : Type :=
              (m: mem),                (**r memory state *)
       state.
 
+Definition ros_to_vos (m: Mem.mem) (ros: mreg + ident) (rs: locset) : val + ident :=
+  match ros with
+  | inl r => match (rs (R r)) with
+            | Vint n => if negb Archi.ptr64
+                       then (match Mem.to_ptr (Vint n) m with
+                             | Some v' => inl v'
+                             | None => inl (rs (R r))
+                             end)
+                       else inl (rs (R r))
+            | Vlong n => if Archi.ptr64
+                        then (match Mem.to_ptr (Vlong n) m with
+                              | Some v' => inl v'
+                              | None => inl (rs (R r))
+                              end)
+                        else inl (rs (R r))
+            | _ => inl (rs (R r))
+            end
+  | inr symb => inr symb
+  end.
 
 Section RELSEM.
 
@@ -180,9 +200,9 @@ Definition destroyed_by_getstack (s: slot): list mreg :=
   | _        => nil
   end.
 
-Definition find_function (ros: mreg + ident) (rs: locset) : option fundef :=
+Definition find_function (ros: val + ident) (rs: locset) : option fundef :=
   match ros with
-  | inl r => Genv.find_funct ge (rs (R r))
+  | inl r => Genv.find_funct ge r
   | inr symb =>
       match Genv.find_symbol ge symb with
       | None => None
@@ -205,7 +225,7 @@ Inductive step: state -> trace -> state -> Prop :=
       step (State s f sp pc rs m)
         E0 (Block s f sp bb rs m)
   | exec_Lop: forall s f sp op args res bb rs m v rs',
-      eval_operation ge sp op (reglist rs args) m = Some v ->
+      eval_operation_wrapper ge sp op (reglist rs args) m = Some v ->
       rs' = Locmap.set (R res) v (undef_regs (destroyed_by_op op) rs) ->
       step (Block s f sp (Lop op args res :: bb) rs m)
         E0 (Block s f sp bb rs' m)
@@ -230,13 +250,13 @@ Inductive step: state -> trace -> state -> Prop :=
       step (Block s f sp (Lstore chunk addr args src :: bb) rs m)
         E0 (Block s f sp bb rs' m')
   | exec_Lcall: forall s f sp sig ros bb rs m fd,
-      find_function ros rs = Some fd ->
+      find_function (ros_to_vos m ros rs) rs = Some fd ->
       funsig fd = sig ->
       step (Block s f sp (Lcall sig ros :: bb) rs m)
         E0 (Callstate (Stackframe f sp rs bb :: s) fd rs m)
   | exec_Ltailcall: forall s f sp sig ros bb rs m fd rs' m',
       rs' = return_regs (parent_locset s) rs ->
-      find_function ros rs' = Some fd ->
+      find_function (ros_to_vos m ros rs') rs' = Some fd ->
       funsig fd = sig ->
       Mem.free m sp 0 f.(fn_stacksize) = Some m' ->
       step (Block s f (Vptr sp Ptrofs.zero) (Ltailcall sig ros :: bb) rs m)
@@ -251,7 +271,7 @@ Inductive step: state -> trace -> state -> Prop :=
       step (Block s f sp (Lbranch pc :: bb) rs m)
         E0 (State s f sp pc rs m)
   | exec_Lcond: forall s f sp cond args pc1 pc2 bb rs b pc rs' m,
-      eval_condition cond (reglist rs args) m = Some b ->
+      eval_condition_wrapper cond (reglist rs args) m = Some b ->
       pc = (if b then pc1 else pc2) ->
       rs' = undef_regs (destroyed_by_cond cond) rs ->
       step (Block s f sp (Lcond cond args pc1 pc2 :: bb) rs m)
@@ -297,13 +317,51 @@ Inductive initial_state (p: program): state -> Prop :=
       funsig f = signature_main ->
       initial_state p (Callstate nil f (Locmap.init Vundef) m0).
 
+Inductive glob_capture (p: program) : state -> state -> Prop :=
+  | glob_capture_intro
+      f m pbs m'
+      (* (INIT: initial_state p (Callstate nil f nil m)) *)
+      (NONSTATIC: Genv.non_static_glob (Genv.globalenv p) (Genv.genv_public (Genv.globalenv p)) = pbs)
+      (CAPTURE: Genv.capture_init_mem m pbs m') :
+    glob_capture p (Callstate nil f (Locmap.init Vundef) m) (Callstate nil f (Locmap.init Vundef) m').
+
+Definition state_mem (st: state) : mem :=
+  match st with
+  | State _ _ _ _ _ m => m
+  | Block _ _ _ _ _ m => m
+  | Callstate _ _ _ m => m
+  | Returnstate _ _ m => m
+  end.
+
+Definition concrete_snapshot (ge: Senv.t) (st: state) (id: ident) : option Z :=
+  if Senv.public_symbol ge id
+  then (match Senv.find_symbol ge id with
+        | Some b => Maps.PTree.get b (state_mem st).(Mem.mem_concrete)
+        | None => None
+        end
+    )
+  else None.
+
 Inductive final_state: state -> int -> Prop :=
   | final_state_intro: forall rs m retcode,
       Locmap.getpair (map_rpair R (loc_result signature_main)) rs = Vint retcode ->
       final_state (Returnstate nil rs m) retcode.
 
+(** Non-deterministic external state *)
+
+Definition is_external (ge:genv) (s:state) : Prop :=
+  match s with
+  | Callstate stk fd vargs m =>
+    match fd with
+    | External ef => is_external_ef ef
+    | _ => False
+    end
+  | Block _ _ _ (Lbuiltin ef _ _ :: _) _ _ => (is_external_ef ef)
+  | _ => False
+  end.
+
 Definition semantics (p: program) :=
-  Semantics step (initial_state p) final_state (Genv.globalenv p).
+  Semantics step (initial_state p) (glob_capture p) (concrete_snapshot (Genv.globalenv p)) final_state is_external (Genv.globalenv p).
 
 (** * Operations over LTL *)
 
diff --git a/backend/LTLD.v b/backend/LTLD.v
new file mode 100644
index 00000000..c1a1bb32
--- /dev/null
+++ b/backend/LTLD.v
@@ -0,0 +1,58 @@
+Require Import Coqlib CoqlibC Events.
+Require Import Globalenvs Smallstep Simulation.
+Require Import sflib LTL.
+
+(** Determinacy *)
+
+Lemma semantics_single_events p s (INT: ~ is_external (Genv.globalenv p) s): single_events_at (LTL.semantics p) s.
+Proof.
+  red. intros. inv H; (try (exploit external_call_trace_length; eauto; intro T)); simpl; try lia; ss; des_ifs.
+Qed.
+
+Lemma semantics_receptive_at:
+  forall (p: program) s (INT: ~ is_external (Genv.globalenv p) s), receptive_at (semantics p) s.
+Proof.
+  intros. constructor; simpl; intros.
+(* receptiveness *)
+  assert (t1 = E0 -> exists s2, step (Genv.globalenv p) s t2 s2).
+    intros. subst. inv H0. exists s1; auto.
+  inversion H; subst; auto.
+  ss. des_ifs.  
+  exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
+  eexists. eapply exec_Lbuiltin; eauto.
+  exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
+  eexists. econs; eauto.
+(* trace length *)
+  red; intros; inv H; simpl; try lia; ss; des_ifs.
+  eapply external_call_trace_length; eauto.
+  eapply external_call_trace_length; eauto.
+Qed.
+
+Lemma semantics_determinate_at:
+  forall (p: program) s (INT: ~ is_external (Genv.globalenv p) s), deterministic_at (semantics p) s.
+Proof.
+  intros. constructor; simpl; intros.
+  - (* determinacy *)
+    inv STEP0; inv STEP1; Eq; try (split; [apply match_traces_E0| intro;auto]);
+      try (elim H; simpl; try rewrite H2; auto); ss.
+    + ss. ss. des_ifs. determ_tac eval_builtin_args_determ. determ_tac external_call_determ.
+    + ss. determ_tac external_call_determ.
+  - inv FINAL; inv STEP.
+  - ii. eapply semantics_single_events; eauto.
+Qed.
+
+Lemma initial_state_determ: forall p st0 st1,
+    Smallstep.initial_state (semantics p) st0 ->
+    Smallstep.initial_state (semantics p) st1 -> st0 = st1.
+Proof. intros. inv H; inv H0. subst ge0 ge. Eq. Qed.
+
+Theorem final_state_determ: forall p st0 retv,
+    Smallstep.final_state (semantics p) st0 retv ->
+    Dfinal_state (semantics p) st0 retv.
+Proof.
+  econstructor; eauto.
+  - intros. inv FINAL0; inv FINAL1. Eq.
+  - red. unfold not. intros. inv FINAL; inv H0.
+Qed.
+
+Ltac DStep_tac := esplit; [(eapply semantics_determinate_at; simpl in *; eauto; des_ifs)|].
diff --git a/backend/Linear.v b/backend/Linear.v
index 447c6ba6..45ea8d77 100644
--- a/backend/Linear.v
+++ b/backend/Linear.v
@@ -19,6 +19,7 @@
 Require Import Coqlib.
 Require Import AST Integers Values Memory Events Globalenvs Smallstep.
 Require Import Op Locations LTL Conventions.
+Require Import PointerOp.
 
 (** * Abstract syntax *)
 
@@ -89,13 +90,34 @@ Fixpoint find_label (lbl: label) (c: code) {struct c} : option code :=
   | i1 :: il => if is_label lbl i1 then Some il else find_label lbl il
   end.
 
+Definition ros_to_vos (m: Mem.mem) (ros: mreg + ident) (rs: locset) : val + ident :=
+  match ros with
+  | inl r => match (rs (R r)) with
+            | Vint n => if negb Archi.ptr64
+                       then (match Mem.to_ptr (Vint n) m with
+                             | Some v' => inl v'
+                             | None => inl (rs (R r))
+                             end)
+                       else inl (rs (R r))
+            | Vlong n => if Archi.ptr64
+                        then (match Mem.to_ptr (Vlong n) m with
+                              | Some v' => inl v'
+                              | None => inl (rs (R r))
+                              end)
+                        else inl (rs (R r))
+            | _ => inl (rs (R r))
+            end
+  | inr symb => inr symb
+  end.
+
+
 Section RELSEM.
 
 Variable ge: genv.
 
-Definition find_function (ros: mreg + ident) (rs: locset) : option fundef :=
+Definition find_function (ros: val + ident) (rs: locset) : option fundef :=
   match ros with
-  | inl r => Genv.find_funct ge (rs (R r))
+  | inl r => Genv.find_funct ge r
   | inr symb =>
       match Genv.find_symbol ge symb with
       | None => None
@@ -155,7 +177,7 @@ Inductive step: state -> trace -> state -> Prop :=
         E0 (State s f sp b rs' m)
   | exec_Lop:
       forall s f sp op args res b rs m v rs',
-      eval_operation ge sp op (reglist rs args) m = Some v ->
+      eval_operation_wrapper ge sp op (reglist rs args) m = Some v ->
       rs' = Locmap.set (R res) v (undef_regs (destroyed_by_op op) rs) ->
       step (State s f sp (Lop op args res :: b) rs m)
         E0 (State s f sp b rs' m)
@@ -175,14 +197,14 @@ Inductive step: state -> trace -> state -> Prop :=
         E0 (State s f sp b rs' m')
   | exec_Lcall:
       forall s f sp sig ros b rs m f',
-      find_function ros rs = Some f' ->
+      find_function (ros_to_vos m ros rs) rs = Some f' ->
       sig = funsig f' ->
       step (State s f sp (Lcall sig ros :: b) rs m)
         E0 (Callstate (Stackframe f sp rs b:: s) f' rs m)
   | exec_Ltailcall:
       forall s f stk sig ros b rs m rs' f' m',
       rs' = return_regs (parent_locset s) rs ->
-      find_function ros rs' = Some f' ->
+      find_function (ros_to_vos m ros rs') rs' = Some f' ->
       sig = funsig f' ->
       Mem.free m stk 0 f.(fn_stacksize) = Some m' ->
       step (State s f (Vptr stk Ptrofs.zero) (Ltailcall sig ros :: b) rs m)
@@ -205,14 +227,14 @@ Inductive step: state -> trace -> state -> Prop :=
         E0 (State s f sp b' rs m)
   | exec_Lcond_true:
       forall s f sp cond args lbl b rs m rs' b',
-      eval_condition cond (reglist rs args) m = Some true ->
+      eval_condition_wrapper cond (reglist rs args) m = Some true ->
       rs' = undef_regs (destroyed_by_cond cond) rs ->
       find_label lbl f.(fn_code) = Some b' ->
       step (State s f sp (Lcond cond args lbl :: b) rs m)
         E0 (State s f sp b' rs' m)
   | exec_Lcond_false:
       forall s f sp cond args lbl b rs m rs',
-      eval_condition cond (reglist rs args) m = Some false ->
+      eval_condition_wrapper cond (reglist rs args) m = Some false ->
       rs' = undef_regs (destroyed_by_cond cond) rs ->
       step (State s f sp (Lcond cond args lbl :: b) rs m)
         E0 (State s f sp b rs' m)
@@ -258,10 +280,48 @@ Inductive initial_state (p: program): state -> Prop :=
       funsig f = signature_main ->
       initial_state p (Callstate nil f (Locmap.init Vundef) m0).
 
+Inductive glob_capture (p: program) : state -> state -> Prop :=
+  | glob_capture_intro
+      f m pbs m'
+      (* (INIT: initial_state p (Callstate nil f nil m)) *)
+      (NONSTATIC: Genv.non_static_glob (Genv.globalenv p) (Genv.genv_public (Genv.globalenv p)) = pbs)
+      (CAPTURE: Genv.capture_init_mem m pbs m') :
+    glob_capture p (Callstate nil f (Locmap.init Vundef) m) (Callstate nil f (Locmap.init Vundef) m').
+
+Definition state_mem (st: state) : mem :=
+  match st with
+  | State _ _ _ _ _ m => m
+  (* | Block _ _ _ _ _ m => m *)
+  | Callstate _ _ _ m => m
+  | Returnstate _ _ m => m
+  end.
+
+Definition concrete_snapshot (ge: Senv.t) (st: state) (id: ident) : option Z :=
+  if Senv.public_symbol ge id
+  then (match Senv.find_symbol ge id with
+        | Some b => Maps.PTree.get b (state_mem st).(Mem.mem_concrete)
+        | None => None
+        end
+    )
+  else None.
+
 Inductive final_state: state -> int -> Prop :=
   | final_state_intro: forall rs m retcode,
       Locmap.getpair (map_rpair R (loc_result signature_main)) rs = Vint retcode ->
       final_state (Returnstate nil rs m) retcode.
 
+(** Non-deterministic external state *)
+
+Definition is_external (ge: genv) (st: state): Prop :=
+  match st with
+  | State _ _ _ (Lbuiltin ef _ _ :: _) _ _ => (is_external_ef ef)
+  | Callstate stk fd vargs m =>
+    match fd with
+    | External ef => is_external_ef ef
+    | _ => False
+    end
+  | _ => False
+  end.
+
 Definition semantics (p: program) :=
-  Semantics step (initial_state p) final_state (Genv.globalenv p).
+  Semantics step (initial_state p) (glob_capture p) (concrete_snapshot (Genv.globalenv p)) final_state is_external (Genv.globalenv p).
diff --git a/backend/LinearD.v b/backend/LinearD.v
new file mode 100644
index 00000000..e4f3eb64
--- /dev/null
+++ b/backend/LinearD.v
@@ -0,0 +1,172 @@
+Require Import Coqlib CoqlibC Events.
+Require Import Globalenvs Smallstep Simulation.
+Require Import sflib Linear.
+
+(** Determinacy *)
+
+Lemma semantics_single_events p s (INT: ~ is_external (Genv.globalenv p) s): single_events_at (Linear.semantics p) s.
+Proof.
+  red. intros. inv H; (try (exploit external_call_trace_length; eauto; intro T)); simpl; try lia; ss.
+Qed.
+
+Lemma semantics_receptive_at:
+  forall (p: program) s (INT: ~ is_external (Genv.globalenv p) s), receptive_at (semantics p) s.
+Proof.
+  intros. constructor; simpl; intros.
+(* receptiveness *)
+  assert (t1 = E0 -> exists s2, step (Genv.globalenv p) s t2 s2).
+    intros. subst. inv H0. exists s1; auto.
+  inversion H; subst; auto. ss. des_ifs.
+  exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
+  eexists. eapply exec_Lbuiltin; eauto.
+  exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
+  eexists. econs; eauto.
+(* trace length *)
+  red; intros; inv H; simpl; try omega.
+  eapply external_call_trace_length; eauto.
+  eapply external_call_trace_length; eauto.
+Qed.
+
+Lemma semantics_determinate_at:
+  forall (p: program) s (INT: ~ is_external (Genv.globalenv p) s), deterministic_at (semantics p) s.
+Proof.
+  intros. constructor; simpl; intros.
+  - (* determinacy *)
+    inv STEP0; inv STEP1; Eq; try (split; [apply match_traces_E0| intro;auto]);
+      try (elim H; simpl; try rewrite H2; auto); ss.
+    + ss. ss. des_ifs.
+      determ_tac eval_builtin_args_determ. determ_tac external_call_determ.
+    + ss. determ_tac external_call_determ.
+  - inv FINAL; inv STEP.
+  - ii. eapply semantics_single_events; eauto.
+Qed.
+
+Lemma initial_state_determ: forall p st0 st1,
+    Smallstep.initial_state (semantics p) st0 ->
+    Smallstep.initial_state (semantics p) st1 -> st0 = st1.
+Proof.
+  intros. inv H; inv H0. subst ge0 ge. Eq.
+Qed.
+
+Theorem final_state_determ: forall p st0 retv,
+    Smallstep.final_state (semantics p) st0 retv ->
+    Dfinal_state (semantics p) st0 retv.
+Proof.
+  econstructor; eauto.
+  - intros. inv FINAL0; inv FINAL1. Eq.
+  - red. unfold not. intros. inv FINAL; inv H0.
+Qed.
+
+Ltac DStep_tac := esplit; [(eapply semantics_determinate_at; simpl in *; eauto; des_ifs)|].
+
+Require Import Memory.
+
+Section FUNCPERM.
+
+Variable p: program.
+Let ge := Genv.globalenv p.
+
+Definition mem_char (m: mem) :=
+  forall b fd, Genv.find_funct_ptr ge b = Some fd ->
+  Mem.perm m b 0 Max Nonempty
+  /\ (forall ofs k p, Mem.perm m b ofs k p -> ofs = 0 /\ p = Nonempty).
+
+Lemma capture_mem_char m b addr m'
+    (CHAR: mem_char m)
+    (CAP: Mem.capture m b addr m'):
+  mem_char m'.
+Proof.
+  unfold mem_char in *. i. exploit CHAR; eauto. i. des. split.
+  - erewrite <- Genv.capture_same_perm; eauto.
+  - i. eapply H1. erewrite Genv.capture_same_perm; eauto.
+Qed.
+
+Lemma capture_list_mem_char m bs addrs m'
+    (CHAR: mem_char m)
+    (CAP: Mem.capture_list m bs addrs m'):
+  mem_char m'.
+Proof.
+  ginduction bs; i; [inv CAP; eauto|]. inv CAP. hexploit capture_mem_char; eauto.
+Qed.
+
+Definition state_char (s: state) : Prop :=
+  mem_char (state_mem s).
+
+Lemma init_mem_mem_char m
+    (INIT: Genv.init_mem p = Some m):
+  mem_char m.
+Proof.
+  r. i. exploit Genv.init_mem_characterization_2; eauto. i. des; split; eauto.
+  eapply Mem.perm_max. eauto.
+Qed.
+
+Lemma initial_state_char s
+    (INIT: initial_state p s):
+  state_char s.
+Proof. inv INIT. ss. r. ss. eapply init_mem_mem_char; eauto. Qed.
+
+Lemma glob_capture_char s s'
+    (CHAR: state_char s)
+    (GCAP: glob_capture p s s'):
+  state_char s'.
+Proof.
+  inv GCAP. inv CAPTURE. unfold state_char in *. ss.
+  eapply capture_list_mem_char; eauto.
+Qed.
+
+Lemma state_char_preservation s s' tr
+    (CHAR: state_char s)
+    (STEP: step ge s tr s'):
+  state_char s'.
+Proof.
+  Local Transparent Mem.free. inv STEP; ss; unfold state_char in *; ss.
+  - r. i. exploit CHAR; eauto. i. des. split.
+    { unfold Mem.storev in H0. des_ifs; eapply Mem.perm_store_1; eauto. }
+    i. unfold Mem.storev in H0. des_ifs; eapply H3; eapply Mem.perm_store_2; eauto.
+  - r. i. exploit CHAR; eauto. i. des. split.
+    2:{ i. eapply H3. eapply Mem.perm_free_3; eauto. }
+    hexploit Mem.free_range_perm; eauto. intros FPERM.
+    destruct (classic ((fn_stacksize f) > 0)); cycle 1.
+    { eapply Mem.perm_free_1; eauto. }
+    destruct (peq b0 stk); cycle 1.
+    { eapply Mem.perm_free_1; eauto. }
+    subst. specialize (FPERM 0). exploit FPERM; try lia. i.
+    eapply H3 in H5. des; clarify.
+  - r. i. exploit CHAR; eauto. i. des. split; cycle 1.
+    { i. eapply H3. instantiate (1:=Max).
+      eapply external_call_max_perm; eauto.
+      { eapply Mem.perm_valid_block; eauto. }
+      eapply Mem.perm_max; eauto. }
+    assert (NM: nonempty_perm m b0 0).
+    { r. split; eauto. i. exploit H3; eauto. i. des; eauto. }
+    exploit ec_nonempty; eauto.
+    { eapply external_call_common_spec. }
+    i. r in H4. des; eauto.
+  - r. i. exploit CHAR; eauto. i. des. split.
+    2:{ i. eapply H2. eapply Mem.perm_free_3; eauto. }
+    hexploit Mem.free_range_perm; eauto. intros FPERM.
+    destruct (classic ((fn_stacksize f) > 0)); cycle 1.
+    { eapply Mem.perm_free_1; eauto. }
+    destruct (peq b0 stk); cycle 1.
+    { eapply Mem.perm_free_1; eauto. }
+    subst. specialize (FPERM 0). exploit FPERM; try lia. i.
+    eapply H2 in H4. des; clarify.
+  - unfold mem_char in *. i. exploit CHAR; eauto. i. des.
+    assert (stk <> b).
+    { hexploit Mem.fresh_block_alloc; eauto. i.
+      eapply Mem.perm_valid_block in H1. ii; subst; clarify. }
+    split; [eapply Mem.perm_alloc_1; eauto|].
+    i. eapply H2. eapply Mem.perm_alloc_4; eauto.
+  - r. i. exploit CHAR; eauto. i. des. split; cycle 1.
+    { i. eapply H2. instantiate (1:=Max).
+      eapply external_call_max_perm; eauto.
+      { eapply Mem.perm_valid_block; eauto. }
+      eapply Mem.perm_max; eauto. }
+    assert (NM: nonempty_perm m b 0).
+    { r. split; eauto. i. exploit H2; eauto. i. des; eauto. }
+    exploit ec_nonempty; eauto.
+    { eapply external_call_common_spec. }
+    i. r in H3. des; eauto.
+Qed.
+
+End FUNCPERM.
diff --git a/backend/Linearizeproof.v b/backend/Linearizeproof.v
index b065238c..bc9b0418 100644
--- a/backend/Linearizeproof.v
+++ b/backend/Linearizeproof.v
@@ -18,6 +18,8 @@ Require Import AST Linking.
 Require Import Values Memory Events Globalenvs Smallstep.
 Require Import Op Locations LTL Linear.
 Require Import Linearize.
+Require Import CoqlibC Simulation LTLD LinearD PointerOp Classical.
+From Paco Require Import paco.
 
 Module NodesetFacts := FSetFacts.Facts(Nodeset).
 
@@ -40,6 +42,9 @@ Hypothesis TRANSF: match_prog prog tprog.
 Let ge := Genv.globalenv prog.
 Let tge := Genv.globalenv tprog.
 
+Let sem := LTL.semantics prog.
+Let tsem := Linear.semantics tprog.
+
 Lemma functions_translated:
   forall v f,
   Genv.find_funct ge v = Some f ->
@@ -63,6 +68,9 @@ Lemma senv_preserved:
   Senv.equiv ge tge.
 Proof (Genv.senv_transf_partial TRANSF).
 
+Lemma same_public: prog_public prog = prog_public tprog.
+Proof. inv TRANSF. des; eauto. Qed.
+
 Lemma sig_preserved:
   forall f tf,
   transf_fundef f = OK tf ->
@@ -252,7 +260,7 @@ Lemma starts_with_correct:
   unique_labels c2 ->
   starts_with lbl c1 = true ->
   find_label lbl c2 = Some c3 ->
-  plus step tge (State s f sp c1 ls m)
+  DPlus tsem (State s f sp c1 ls m)
              E0 (State s f sp c3 ls m).
 Proof.
   induction c1.
@@ -260,7 +268,7 @@ Proof.
   simpl starts_with. destruct a; try (intros; discriminate).
   intros.
   apply plus_left with E0 (State s f sp c1 ls m) E0.
-  simpl. constructor.
+  DStep_tac. simpl. constructor.
   destruct (peq lbl l).
   subst l. replace c3 with c1. constructor.
   apply find_label_unique with lbl c2; auto.
@@ -456,14 +464,14 @@ Lemma add_branch_correct:
   transf_function f = OK tf ->
   is_tail k tf.(fn_code) ->
   find_label lbl tf.(fn_code) = Some c ->
-  plus step tge (State s tf sp (add_branch lbl k) ls m)
+  DPlus tsem (State s tf sp (add_branch lbl k) ls m)
              E0 (State s tf sp c ls m).
 Proof.
   intros. unfold add_branch.
   caseEq (starts_with lbl k); intro SW.
   eapply starts_with_correct; eauto.
   eapply unique_labels_transf_function; eauto.
-  apply plus_one. apply exec_Lgoto. auto.
+  apply plus_one. DStep_tac. apply exec_Lgoto. auto.
 Qed.
 
 (** * Correctness of linearization *)
@@ -508,7 +516,7 @@ Inductive match_states: LTL.state -> Linear.state -> Prop :=
         (STACKS: list_forall2 match_stackframes s ts)
         (TRF: transf_function f = OK tf)
         (REACH: (reachable f)!!pc = true)
-        (JUMP: eval_condition cond (reglist ls args) m = Some true),
+        (JUMP: eval_condition_wrapper cond (reglist ls args) m = Some true),
       match_states (LTL.State s f sp pc (undef_regs (destroyed_by_cond cond) ls) m)
                    (Linear.State ts tf sp (Lcond cond args pc :: c) ls m)
   | match_states_jumptable:
@@ -554,11 +562,12 @@ Proof.
 Qed.
 
 Theorem transf_step_correct:
-  forall s1 t s2, LTL.step ge s1 t s2 ->
+  forall s1 t s2, IStep sem s1 t s2 ->
   forall s1' (MS: match_states s1 s1'),
-  (exists s2', plus Linear.step tge s1' t s2' /\ match_states s2 s2')
+  (exists s2', DPlus tsem s1' t s2' /\ match_states s2 s2')
   \/ (measure s2 < measure s1 /\ t = E0 /\ match_states s2 s1')%nat.
 Proof.
+  destruct 1. generalize dependent s2. rename H into INT.
   induction 1; intros; try (inv MS).
 
   (* start of block, at an [add_branch] *)
@@ -572,7 +581,7 @@ Proof.
   (* start of block, target of an [Lcond] *)
   exploit find_label_lin; eauto. intros [k F].
   left; econstructor; split.
-  apply plus_one. eapply exec_Lcond_true; eauto.
+  apply plus_one. DStep_tac. eapply exec_Lcond_true; eauto.
   econstructor; eauto.
   intros; eapply reachable_successors; eauto.
   eapply is_tail_lin_block; eauto. eapply is_tail_find_label; eauto.
@@ -580,38 +589,38 @@ Proof.
   (* start of block, target of an [Ljumptable] *)
   exploit find_label_lin; eauto. intros [k F].
   left; econstructor; split.
-  apply plus_one. eapply exec_Ljumptable; eauto.
+  apply plus_one. DStep_tac. eapply exec_Ljumptable; eauto.
   econstructor; eauto.
   intros; eapply reachable_successors; eauto.
   eapply is_tail_lin_block; eauto. eapply is_tail_find_label; eauto.
 
   (* Lop *)
   left; econstructor; split. simpl.
-  apply plus_one. econstructor; eauto.
-  instantiate (1 := v); rewrite <- H; apply eval_operation_preserved.
+  apply plus_one. DStep_tac. econstructor; eauto.
+  instantiate (1 := v); rewrite <- H; apply eval_operation_wrapper_preserved.
   exact symbols_preserved.
   econstructor; eauto.
 
   (* Lload *)
   left; econstructor; split. simpl.
-  apply plus_one. econstructor.
+  apply plus_one. DStep_tac. econstructor.
   instantiate (1 := a). rewrite <- H; apply eval_addressing_preserved.
   exact symbols_preserved. eauto. eauto.
   econstructor; eauto.
 
   (* Lgetstack *)
   left; econstructor; split. simpl.
-  apply plus_one. econstructor; eauto.
+  apply plus_one. DStep_tac. econstructor; eauto.
   econstructor; eauto.
 
   (* Lsetstack *)
   left; econstructor; split. simpl.
-  apply plus_one. econstructor; eauto.
+  apply plus_one. DStep_tac. econstructor; eauto.
   econstructor; eauto.
 
   (* Lstore *)
   left; econstructor; split. simpl.
-  apply plus_one. econstructor.
+  apply plus_one. DStep_tac. econstructor.
   instantiate (1 := a). rewrite <- H; apply eval_addressing_preserved.
   exact symbols_preserved. eauto. eauto.
   econstructor; eauto.
@@ -619,14 +628,14 @@ Proof.
   (* Lcall *)
   exploit find_function_translated; eauto. intros [tfd [A B]].
   left; econstructor; split. simpl.
-  apply plus_one. econstructor; eauto.
+  apply plus_one. DStep_tac. econstructor; eauto.
   symmetry; eapply sig_preserved; eauto.
   econstructor; eauto. constructor; auto. econstructor; eauto.
 
   (* Ltailcall *)
   exploit find_function_translated; eauto. intros [tfd [A B]].
   left; econstructor; split. simpl.
-  apply plus_one. econstructor; eauto.
+  apply plus_one. DStep_tac. econstructor; eauto.
   rewrite (match_parent_locset _ _ STACKS). eauto.
   symmetry; eapply sig_preserved; eauto.
   rewrite (stacksize_preserved _ _ TRF); eauto.
@@ -635,7 +644,7 @@ Proof.
 
   (* Lbuiltin *)
   left; econstructor; split. simpl.
-  apply plus_one. eapply exec_Lbuiltin; eauto.
+  apply plus_one. DStep_tac. eapply exec_Lbuiltin; eauto.
   eapply eval_builtin_args_preserved with (ge1 := ge); eauto. exact symbols_preserved.
   eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   econstructor; eauto.
@@ -655,19 +664,19 @@ Proof.
   destruct b.
   (* cond is true: no branch *)
   left; econstructor; split.
-  apply plus_one. eapply exec_Lcond_false.
-  rewrite eval_negate_condition. rewrite H. auto. eauto.
+  apply plus_one. DStep_tac. eapply exec_Lcond_false.
+  rewrite eval_negate_condition_wrapper. rewrite H. auto. eauto.
   rewrite DC. econstructor; eauto.
   (* cond is false: branch is taken *)
   right; split. simpl; lia. split. auto.  rewrite <- DC. econstructor; eauto.
-  rewrite eval_negate_condition. rewrite H. auto.
+  rewrite eval_negate_condition_wrapper. rewrite H. auto.
   (* branch if cond is true *)
   destruct b.
   (* cond is true: branch is taken *)
   right; split. simpl; lia. split. auto. econstructor; eauto.
   (* cond is false: no branch *)
   left; econstructor; split.
-  apply plus_one. eapply exec_Lcond_false. eauto. eauto.
+  apply plus_one. DStep_tac. eapply exec_Lcond_false. eauto. eauto.
   econstructor; eauto.
 
   (* Ljumptable *)
@@ -677,7 +686,7 @@ Proof.
 
   (* Lreturn *)
   left; econstructor; split.
-  simpl. apply plus_one. econstructor; eauto.
+  simpl. apply plus_one. DStep_tac. econstructor; eauto.
   rewrite (stacksize_preserved _ _ TRF). eauto.
   rewrite (match_parent_locset _ _ STACKS). econstructor; eauto.
 
@@ -686,21 +695,21 @@ Proof.
     apply reachable_entrypoint.
   monadInv H7.
   left; econstructor; split.
-  apply plus_one. eapply exec_function_internal; eauto.
+  apply plus_one. DStep_tac. eapply exec_function_internal; eauto.
   rewrite (stacksize_preserved _ _ EQ). eauto.
   generalize EQ; intro EQ'; monadInv EQ'. simpl.
   econstructor; eauto. simpl. eapply is_tail_add_branch. constructor.
 
   (* external function *)
   monadInv H8. left; econstructor; split.
-  apply plus_one. eapply exec_function_external; eauto.
+  apply plus_one. DStep_tac. eapply exec_function_external; eauto.
   eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   econstructor; eauto.
 
   (* return *)
   inv H3. inv H1.
   left; econstructor; split.
-  apply plus_one. econstructor.
+  apply plus_one. DStep_tac. econstructor.
   econstructor; eauto.
 Qed.
 
@@ -725,14 +734,102 @@ Proof.
   intros. inv H0. inv H. inv H5. econstructor; eauto.
 Qed.
 
+Lemma match_states_bsim
+      s1 (EXT: LTL.is_external ge s1)
+      s2 t s2' (STEPTGT: Step tsem s2 t s2')
+      (MATCH: match_states s1 s2)
+      (SAFESRC: safe sem s1) :
+    (exists s1', Step sem s1 t s1' /\ match_states s1' s2')
+  \/ (~ trace_intact t /\ exists s1'' t', Star sem s1 t' s1'' /\ exists tl, t' = (trace_cut_pterm t) ** tl).
+Proof.
+  assert (SEQUIV: Senv.equiv tge ge) by (symmetry; apply senv_preserved).
+  unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+  { inv SAFESRC. inv MATCH. inv H4. inv STEPTGT. }
+  inv MATCH; ss; des_ifs.
+  (* builtin *)
+  - i. inv STEPTGT; clarify. inv SAFESRC; clarify.
+    exploit eval_builtin_args_preserved; [eapply SEQUIV|eapply H10|].
+    i. exploit eval_builtin_args_determ. eapply H. eapply H12. i. subst.
+    left. esplits; [|econs; eauto].
+    econs; eauto. eapply external_call_symbols_preserved; eauto.
+  - i. inv STEPTGT; clarify. inv SAFESRC; clarify.
+    left. ss. clarify. esplits; eauto; [|econs; eauto].
+    econs; eauto. eapply external_call_symbols_preserved; eauto.
+Qed.
+
+Lemma match_states_xsim st_src0 st_tgt0 gmtgt
+    (MATCH: match_states st_src0 st_tgt0) :
+  xsim (LTL.semantics prog) (Linear.semantics tprog) gmtgt lt (measure st_src0) st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold. destruct (classic (LTL.is_external ge st_src0)); cycle 1.
+  (* not external *)
+  - left. econs. econs.
+    + i. exploit transf_step_correct; eauto. i. destruct H0.
+      * des; esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl|].
+        left. split; eauto. eapply LTLD.semantics_receptive_at; auto.
+      * des; esplits; eauto. eapply tr_rel_refl. eapply ev_rel_refl.
+    + ii. eapply final_state_determ; eauto. inv FINALSRC. inv MATCH. inv H5. econs; eauto.
+  (* external *)
+  - right. econs. i. econs.
+    + i. exploit match_states_bsim; eauto. i. des.
+      * left. esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl|].
+        left. eapply plus_one. eauto.
+      * right. esplits; eauto. subst. eapply tr_rel_refl. eapply ev_rel_refl.
+    + ii. inv FINALTGT. inv MATCH. inv H3.
+      esplits; auto. eapply star_refl. econs; eauto.
+    + i. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify; [inv SAFESRC; ss|].
+      right. inv MATCH; ss; des_ifs; inv SAFESRC; unfold ge in *; clarify.
+      * esplits. eapply exec_Lbuiltin; eauto.
+        { eapply eval_builtin_args_preserved. eapply senv_preserved. eauto. }
+        { eapply external_call_symbols_preserved; eauto. apply senv_preserved. }
+      * ss. clarify. esplits. eapply exec_function_external; eauto.
+        eapply external_call_symbols_preserved; eauto. apply senv_preserved.
+Qed.
+
+Lemma non_static_equiv l:
+  Genv.non_static_glob (Genv.globalenv prog) l = Genv.non_static_glob (Genv.globalenv tprog) l.
+Proof.
+  Local Transparent ge tge.
+  induction l; ss.
+  specialize senv_preserved. ss. i. inv H. inv H1. unfold ge, tge, fundef in *.
+  specialize (H a). unfold Senv.public_symbol in H. ss. erewrite H.
+  specialize (H0 a). rewrite <- H0. erewrite IHl; eauto.
+Qed.
+
+Lemma transf_initial_capture S1 S2 S2'
+    (INITSRC: LTL.initial_state prog S1)
+    (INITTGT: Linear.initial_state tprog S2)
+    (MATCH: match_states S1 S2)
+    (CAPTGT: Linear.glob_capture tprog S2 S2'):
+  exists S1', LTL.glob_capture prog S1 S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (LTL.concrete_snapshot ge S1') (Linear.concrete_snapshot tge S2').
+Proof.
+  inv CAPTGT. ss. rewrite Genv.globalenv_public in CAPTURE.
+  rewrite <- same_public in CAPTURE. erewrite <- non_static_equiv in CAPTURE.
+  inv MATCH. inv H2. esplits.
+  - econs; eauto. rewrite Genv.globalenv_public. eauto.
+  - econs. econs. eauto.
+  - specialize senv_preserved. intros SENVEQ. destruct SENVEQ. des.
+    unfold LTL.concrete_snapshot, concrete_snapshot. ii.
+    erewrite H0, H. des_ifs; ss.
+Qed.
+
 Theorem transf_program_correct:
-  forward_simulation (LTL.semantics prog) (Linear.semantics tprog).
-Proof.
-  eapply forward_simulation_star.
-  apply senv_preserved.
-  eexact transf_initial_states.
-  eexact transf_final_states.
-  eexact transf_step_correct.
+  mixed_simulation (LTL.semantics prog) (Linear.semantics tprog).
+Proof.
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (1 + a)%nat. lia.
+  - econs. i. exploit transf_initial_states; eauto. i. des.
+    exists st2. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. exploit transf_initial_capture; eauto. i. des. subst.
+      esplits; eauto. apply match_states_xsim; auto.
+  - i. apply senv_preserved.
 Qed.
 
 End LINEARIZATION.
diff --git a/backend/Lineartyping.v b/backend/Lineartyping.v
index 0e3b7c8e..d3a01a00 100644
--- a/backend/Lineartyping.v
+++ b/backend/Lineartyping.v
@@ -25,6 +25,7 @@ Require Import Locations.
 Require Import Conventions.
 Require Import LTL.
 Require Import Linear.
+Require Import sflib PointerOp.
 
 (** The rules are presented as boolean-valued functions so that we
   get an executable type-checker for free. *)
@@ -322,7 +323,7 @@ Local Opaque mreg_type.
     destruct (type_of_operation op) as [ty_args ty_res] eqn:TYOP. InvBooleans.
     econstructor; eauto.
     apply wt_setreg. eapply Val.has_subtype; eauto.
-    change ty_res with (snd (ty_args, ty_res)). rewrite <- TYOP. eapply type_of_operation_sound; eauto.
+    change ty_res with (snd (ty_args, ty_res)). rewrite <- TYOP. eapply type_of_operation_wrapper_sound; eauto.
     red; intros; subst op. simpl in ISMOVE.
     destruct args; try discriminate. destruct args; discriminate.
     apply wt_undef_regs; auto.
@@ -330,7 +331,9 @@ Local Opaque mreg_type.
   simpl in *; InvBooleans.
   econstructor; eauto.
   apply wt_setreg. eapply Val.has_subtype; eauto.
-  destruct a; simpl in H0; try discriminate. eapply Mem.load_type; eauto.
+  destruct a; unfold Mem.loadv in H0; simpl in H0; try discriminate.
+  { des_ifs. eapply Mem.load_type; eauto. }
+  eapply Mem.load_type; eauto.
   apply wt_undef_regs; auto.
 - (* store *)
   simpl in *; InvBooleans.
@@ -400,6 +403,15 @@ Proof.
   red; auto.
 Qed.
 
+Theorem wt_initial_capture_state
+    S S'
+    (INIT: initial_state prog S)
+    (ICAP: glob_capture prog S S') :
+  wt_state S'.
+Proof.
+  exploit wt_initial_state; eauto. i. inv INIT. inv ICAP. inv H. econs; eauto.
+Qed.
+
 End SOUNDNESS.
 
 (** Properties of well-typed states that are used in [Stackingproof]. *)
diff --git a/backend/Mach.v b/backend/Mach.v
index 9fdee9eb..553c5b95 100644
--- a/backend/Mach.v
+++ b/backend/Mach.v
@@ -28,6 +28,7 @@ Require Import Smallstep.
 Require Import Op.
 Require Import Locations.
 Require Import Conventions.
+Require Import PointerOp.
 Require Stacklayout.
 
 (** * Abstract syntax *)
@@ -205,6 +206,27 @@ Proof.
   intros; red; intros. eapply is_tail_incl; eauto. eapply find_label_tail; eauto.
 Qed.
 
+
+Definition ros_to_vos (m: Mem.mem) (ros: mreg + ident) (rs: regset) : val + ident :=
+  match ros with
+  | inl r => match (rs r) with
+            | Vint n => if negb Archi.ptr64
+                       then (match Mem.to_ptr (Vint n) m with
+                             | Some v' => inl v'
+                             | None => inl (rs r)
+                             end)
+                       else inl (rs r)
+            | Vlong n => if Archi.ptr64
+                        then (match Mem.to_ptr (Vlong n) m with
+                              | Some v' => inl v'
+                              | None => inl (rs r)
+                              end)
+                        else inl (rs r)
+            | _ => inl (rs r)
+            end
+  | inr symb => inr symb
+  end.
+
 Section RELSEM.
 
 Variable return_address_offset: function -> code -> ptrofs -> Prop.
@@ -212,10 +234,10 @@ Variable return_address_offset: function -> code -> ptrofs -> Prop.
 Variable ge: genv.
 
 Definition find_function_ptr
-        (ge: genv) (ros: mreg + ident) (rs: regset) : option block :=
+        (ge: genv) (ros: val + ident) (rs: regset) : option block :=
   match ros with
   | inl r =>
-      match rs r with
+      match r with
       | Vptr b ofs => if Ptrofs.eq ofs Ptrofs.zero then Some b else None
       | _ => None
       end
@@ -316,7 +338,7 @@ Inductive step: state -> trace -> state -> Prop :=
         E0 (State s fb sp c rs' m)
   | exec_Mop:
       forall s f sp op args res c rs m v rs',
-      eval_operation ge sp op rs##args m = Some v ->
+      eval_operation_wrapper ge sp op rs##args m = Some v ->
       rs' = ((undef_regs (destroyed_by_op op) rs)#res <- v) ->
       step (State s f sp (Mop op args res :: c) rs m)
         E0 (State s f sp c rs' m)
@@ -336,15 +358,15 @@ Inductive step: state -> trace -> state -> Prop :=
         E0 (State s f sp c rs' m')
   | exec_Mcall:
       forall s fb sp sig ros c rs m f f' ra,
-      find_function_ptr ge ros rs = Some f' ->
+      find_function_ptr ge (ros_to_vos m ros rs) rs = Some f' ->
       Genv.find_funct_ptr ge fb = Some (Internal f) ->
       return_address_offset f c ra ->
       step (State s fb sp (Mcall sig ros :: c) rs m)
         E0 (Callstate (Stackframe fb sp (Vptr fb ra) c :: s)
                        f' rs m)
   | exec_Mtailcall:
-      forall s fb stk soff sig ros c rs m f f' m',
-      find_function_ptr ge ros rs = Some f' ->
+      forall s fb stk soff sig ros c rs m f f' m' (FUNCPTR: exists fd, Genv.find_funct_ptr ge f' = Some fd),
+      find_function_ptr ge (ros_to_vos m ros rs) rs = Some f' ->
       Genv.find_funct_ptr ge fb = Some (Internal f) ->
       load_stack m (Vptr stk soff) Tptr f.(fn_link_ofs) = Some (parent_sp s) ->
       load_stack m (Vptr stk soff) Tptr f.(fn_retaddr_ofs) = Some (parent_ra s) ->
@@ -366,7 +388,7 @@ Inductive step: state -> trace -> state -> Prop :=
         E0 (State s fb sp c' rs m)
   | exec_Mcond_true:
       forall s fb f sp cond args lbl c rs m c' rs',
-      eval_condition cond rs##args m = Some true ->
+      eval_condition_wrapper cond rs##args m = Some true ->
       Genv.find_funct_ptr ge fb = Some (Internal f) ->
       find_label lbl f.(fn_code) = Some c' ->
       rs' = undef_regs (destroyed_by_cond cond) rs ->
@@ -374,7 +396,7 @@ Inductive step: state -> trace -> state -> Prop :=
         E0 (State s fb sp c' rs' m)
   | exec_Mcond_false:
       forall s f sp cond args lbl c rs m rs',
-      eval_condition cond rs##args m = Some false ->
+      eval_condition_wrapper cond rs##args m = Some false ->
       rs' = undef_regs (destroyed_by_cond cond) rs ->
       step (State s f sp (Mcond cond args lbl :: c) rs m)
         E0 (State s f sp c rs' m)
@@ -427,14 +449,55 @@ Inductive initial_state (p: program): state -> Prop :=
       Genv.find_symbol ge p.(prog_main) = Some fb ->
       initial_state p (Callstate nil fb (Regmap.init Vundef) m0).
 
+Inductive glob_capture (p: program) : state -> state -> Prop :=
+  | glob_capture_intro
+      f m pbs m'
+      (* (INIT: initial_state p (Callstate nil f nil m)) *)
+      (NONSTATIC: Genv.non_static_glob (Genv.globalenv p) (Genv.genv_public (Genv.globalenv p)) = pbs)
+      (CAPTURE: Genv.capture_init_mem m pbs m') :
+    glob_capture p (Callstate nil f (Regmap.init Vundef) m) (Callstate nil f (Regmap.init Vundef) m').
+
+Definition state_mem (st: state) : mem :=
+  match st with
+  | State _ _ _ _ _ m => m
+  | Callstate _ _ _ m => m
+  | Returnstate _ _ m => m
+  end.
+
+Definition concrete_snapshot (ge: Senv.t) (st: state) (id: ident) : option Z :=
+  if Senv.public_symbol ge id
+  then (match Senv.find_symbol ge id with
+        | Some b => Maps.PTree.get b (state_mem st).(Mem.mem_concrete)
+        | None => None
+        end
+    )
+  else None.
+
 Inductive final_state: state -> int -> Prop :=
   | final_state_intro: forall rs m r retcode,
       loc_result signature_main = One r ->
       rs r = Vint retcode ->
       final_state (Returnstate nil rs m) retcode.
 
+(** Non-deterministic external state *)
+
+Definition is_external (ge: genv) (st: state): Prop :=
+  match st with
+  | State _ _ _ (Mbuiltin ef _ _ :: _) _ _ => is_external_ef ef
+  | Callstate _ fb _ _ =>
+    match Genv.find_funct_ptr ge fb with
+    | Some f =>
+      match f with
+      | Internal f => False
+      | External ef => is_external_ef ef
+      end
+    | None => False
+    end
+  | _ => False
+  end.
+
 Definition semantics (rao: function -> code -> ptrofs -> Prop) (p: program) :=
-  Semantics (step rao) (initial_state p) final_state (Genv.globalenv p).
+  Semantics (step rao) (initial_state p) (glob_capture p) (concrete_snapshot (Genv.globalenv p)) final_state is_external (Genv.globalenv p).
 
 (** * Leaf functions *)
 
@@ -502,3 +565,12 @@ Lemma wf_initial:
 Proof.
   intros. inv H. fold ge. constructor. constructor.
 Qed.
+
+Lemma wf_initial_capture
+    p S S'
+    (INIT: initial_state p S)
+    (ICAP: glob_capture p S S'):
+  wf_state (Genv.globalenv p) S'.
+Proof.
+  exploit wf_initial; eauto. i. inv INIT. inv ICAP. inv H. econs; eauto.
+Qed.
diff --git a/backend/MachD.v b/backend/MachD.v
new file mode 100644
index 00000000..6507bd27
--- /dev/null
+++ b/backend/MachD.v
@@ -0,0 +1,99 @@
+Require Import Coqlib sflib CoqlibC.
+Require Import Globalenvs Events.
+Require Import Integers.
+Require Import Smallstep Simulation.
+Require Import Mach.
+
+(** Determinacy *)
+
+Section Determinacy.
+
+Variable rao: function -> code -> ptrofs -> Prop.
+
+Lemma semantics_single_events p s (INT: ~ is_external (Genv.globalenv p) s): single_events_at (semantics rao p) s.
+Proof.
+  red. intros. inv H; (try (exploit external_call_trace_length; eauto; intro T)); simpl; try lia; ss; des_ifs.
+Qed.
+
+Lemma semantics_receptive_at:
+  forall (p: program) s (INT: ~ is_external (Genv.globalenv p) s), receptive_at (semantics rao p) s.
+Proof.
+  intros. constructor; simpl; intros.
+  - (* receptiveness *)
+    assert (t1 = E0 -> exists s2, step rao (Genv.globalenv p) s t2 s2).
+    { intros. subst. inv H0. exists s1; auto. }
+    inversion H; subst; auto.
+    (* builtin *)
+    ss. determ_tac external_call_receptive.
+    econstructor; econstructor; eauto.
+    (* external *)
+    simpl in INT. rewrite H2 in INT.
+    exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
+    eexists. eapply exec_function_external; eauto.
+  - red; intros; inv H; simpl; try lia; ss; des_ifs.
+    eapply external_call_trace_length; eauto.
+    eapply external_call_trace_length; eauto.
+Qed.
+
+Hypothesis rao_dtm: forall f c ofs ofs',
+    rao f c ofs -> rao f c ofs' -> ofs = ofs'.
+
+Lemma extcall_arguments_determ
+      rs m rsp sg vs0 vs1
+      (ARGS0: Mach.extcall_arguments rs m rsp sg vs0)
+      (ARGS1: Mach.extcall_arguments rs m rsp sg vs1):
+  vs0 = vs1.
+Proof.
+  generalize dependent vs1. generalize dependent vs0. generalize dependent sg.
+  assert (A: forall l v1 v2,
+             Mach.extcall_arg rs m rsp l v1 -> Mach.extcall_arg rs m rsp l v2 -> v1 = v2).
+  { intros. inv H; inv H0; congruence. }
+  assert (B: forall p v1 v2,
+             Mach.extcall_arg_pair rs m rsp p v1 -> Mach.extcall_arg_pair rs m rsp p v2 -> v1 = v2).
+  { intros. inv H; inv H0.
+    eapply A; eauto.
+    f_equal; eapply A; eauto. }
+  assert (C: forall ll vl1, list_forall2 (Mach.extcall_arg_pair rs m rsp) ll vl1 ->
+                       forall vl2, list_forall2 (Mach.extcall_arg_pair rs m rsp) ll vl2 -> vl1 = vl2).
+  { induction 1; intros vl2 EA; inv EA.
+    auto.
+    f_equal; eauto. }
+  intros. eapply C; eauto.
+Qed.
+
+Lemma semantics_determinate_at:
+  forall (p: program) s (INT: ~ is_external (Genv.globalenv p) s), deterministic_at (semantics rao p) s.
+Proof.
+  intros. constructor; simpl; intros.
+  - (* determinacy *)
+    inv STEP0; inv STEP1; Eq; try (split; [apply match_traces_E0| intro;auto]);
+      try (elim H; simpl; try rewrite H2; auto); ss.
+    + exploit rao_dtm. eapply H1. eapply H14. intros. subst. auto.
+    + exploit eval_builtin_args_determ. eapply H. eapply H12. intros; subst.
+      ss. determ_tac external_call_determ.
+    + assert (sp = sp0) by auto. rewrite H3 in *. Eq.
+    + exploit extcall_arguments_determ. eapply H0. eapply H9. intros. subst.
+      simpl in INT. determ_tac external_call_determ. des_ifs.
+  - inv FINAL; inv STEP.
+  - red; intros; inv H; simpl; try lia; ss; des_ifs.
+    eapply external_call_trace_length; eauto.
+    eapply external_call_trace_length; eauto.
+Qed.
+
+Lemma initial_state_determ: forall p st0 st1,
+    Smallstep.initial_state (semantics rao p) st0 ->
+    Smallstep.initial_state (semantics rao p) st1 -> st0 = st1.
+Proof. intros. inv H; inv H0. subst ge0 ge. Eq. Qed.
+
+Theorem final_state_determ: forall p st0 retv,
+    Smallstep.final_state (semantics rao p) st0 retv ->
+    Dfinal_state (semantics rao p) st0 retv.
+Proof.
+  econstructor; eauto.
+  - intros. inv FINAL0; inv FINAL1; Eq; auto.
+  - red. unfold not. intros. inv FINAL; inv H0; simpl.
+Qed.
+
+End Determinacy.
+
+Ltac DStep_tac := esplit; [(eapply semantics_determinate_at; simpl in *; eauto)|].
diff --git a/backend/NeedDomain.v b/backend/NeedDomain.v
index 62b8ff90..dfa21c67 100644
--- a/backend/NeedDomain.v
+++ b/backend/NeedDomain.v
@@ -28,6 +28,7 @@ Require Import Registers.
 Require Import ValueDomain.
 Require Import Op.
 Require Import RTL.
+Require Import sflib IntPtrRel PointerOp.
 
 (** * Neededness for values *)
 
@@ -929,6 +930,85 @@ Proof.
   apply vagree_lessdef. apply val_inject_lessdef. auto.
 Qed.
 
+Let src_concrete_private: forall b, inject_id b = None -> (Mem.mem_concrete m1) ! b = None.
+Proof. unfold inject_id. ii. clarify. Qed.
+
+Hypothesis mappedblocks: forall b b' delta, Mem.valid_block m1 b -> inject_id b = Some (b', delta) -> Mem.valid_block m2 b'.
+
+Hypothesis src_concrete_public: forall b1 b2 addr delta,
+    inject_id b1 = Some (b2, delta) ->
+    (Mem.mem_concrete m1) ! b1 = Some addr ->
+    (Mem.mem_concrete m2) ! b2 = Some (addr - delta).
+
+Let representable: forall b b' delta ofs,
+    inject_id b = Some (b', delta) ->
+    Mem.perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \/
+    Mem.perm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->
+    delta >= 0 /\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.
+Proof.
+  unfold inject_id. ii. clarify. split;[lia|].
+  replace (Ptrofs.unsigned ofs + 0) with (Ptrofs.unsigned ofs) by lia.
+  eapply Ptrofs.unsigned_range_2.
+Qed.
+
+Lemma default_needs_of_condition_join_sound
+  cond args1 b args2
+  (PTRCOND: ptr_cond cond = true)
+  (ECOND: eval_condition_join cond args1 m1 = Some b)
+  (VALIST: vagree_list args1 args2 nil)
+  :
+  <<ECONS': eval_condition_join cond args2 m2 = Some b>>.
+Proof.
+  intros. apply eval_condition_join_inj with (f := inject_id) (m1 := m1) (vl1 := args1); auto.
+    { ii. unfold inject_id in *. clarify. replace (ofs + 0) with ofs by lia. eauto. }
+  apply val_inject_list_lessdef. apply lessdef_vagree_list. auto.
+Qed.
+
+Lemma default_needs_of_condition_wrapper_sound
+  cond args1 b args2
+  (ECOND: eval_condition_wrapper cond args1 m1 = Some b)
+  (VALIST: vagree_list args1 args2 nil)
+  :
+  <<ECONS': eval_condition_wrapper cond args2 m2 = Some b>>.
+Proof.
+  intros. apply eval_condition_wrapper_inj with (f := inject_id) (m1 := m1) (vl1 := args1); auto.
+    { ii. unfold inject_id in *. clarify. replace (ofs + 0) with ofs by lia. eauto. }
+  apply val_inject_list_lessdef. apply lessdef_vagree_list. auto.
+Qed.
+
+Lemma default_needs_of_operation_wrapper_sound
+  op args1 v1 args2 nv
+  (EVAL: eval_operation_wrapper ge (Vptr sp Ptrofs.zero) op args1 m1 = Some v1)
+  (ALIST: vagree_list args1 args2 nil
+          \/ vagree_list args1 args2 (default nv :: nil)
+          \/ vagree_list args1 args2 (default nv :: default nv :: nil)
+          \/ vagree_list args1 args2 (default nv :: default nv :: default nv :: nil))
+  (NNOT: nv <> Nothing)
+  :
+  exists v2,
+    <<EVAL': eval_operation_wrapper ge (Vptr sp Ptrofs.zero) op args2 m2 = Some v2>>
+  /\ <<VA: vagree v1 v2 nv>>.
+Proof.
+  intros. assert (default nv = All) by (destruct nv; simpl; congruence).
+  rewrite H in ALIST.
+  assert (Val.lessdef_list args1 args2).
+  {
+    destruct ALIST. auto with na.
+    destruct H0. inv H0; constructor; auto with na.
+    destruct H0. inv H0. constructor. inv H6; constructor; auto with na. 
+    inv H0; constructor; auto with na. inv H6; constructor; auto with na. inv H7; constructor; auto with na.
+  }
+  exploit (@eval_operation_wrapper_inj _ _ _ _ ge ge inject_id m1 m2).
+  { ii. unfold inject_id in *. clarify. replace (ofs + 0) with ofs by lia. eauto. }
+  eassumption. auto. auto. auto. auto. eauto. auto. auto.
+  instantiate (1 := op). intros. eapply val_inject_lessdef; auto.
+  apply val_inject_list_lessdef; eauto.
+  eapply val_inject_lessdef. instantiate (1 := Vptr sp Ptrofs.zero). instantiate (1 := Vptr sp Ptrofs.zero). auto.
+  eauto.
+  intros (v2 & A & B). exists v2; split; auto.
+  apply vagree_lessdef. apply val_inject_lessdef. auto.
+Qed.
+
 End DEFAULT.
 
 (** ** Detecting operations that are redundant and can be turned into a move *)
@@ -1432,6 +1512,32 @@ Proof.
   rewrite ISet.beq_spec in H1. rewrite H1. eauto.
 Qed.
 
+Lemma nmem_remove_nlive_implies
+  nm b ofs ap
+  (NLV: nlive nm b ofs):
+  <<NLV: nlive (nmem_remove nm ap 0) b ofs>>.
+Proof.
+  unfold nmem_remove. des_ifs.
+  - eapply nmem_beq_sound; eauto.
+    ss. rewrite andb_true_iff. split.
+    { rewrite ISet.beq_spec. ss. }
+    rewrite PTree.beq_correct. i.
+    destruct (peq x id); subst.
+    { unfold ISet.add. des_ifs; try lia.
+      2:{ rewrite PTree.gss in Heq0. clarify. }
+      rewrite PTree.gss in Heq0. ss. clarify. rewrite ISet.beq_spec; ss. }
+    rewrite PTree.gso; eauto. des_ifs. rewrite ISet.beq_spec; ss.
+  - r. inv NLV. econs; eauto. i.
+    destruct (peq id0 id); subst; cycle 1.
+    { rewrite PTree.gso in H0; eauto. }
+    rewrite PTree.gss in H0; eauto.  inv H0. ii. rewrite ISet.In_interval in H0.
+    lia.
+  - eapply nmem_beq_sound; eauto.
+    ss. rewrite andb_true_iff. split.
+    2:{ rewrite PTree.beq_correct. i. des_ifs. rewrite ISet.beq_spec; ss. }
+    unfold ISet.add. des_ifs; try lia. rewrite ISet.beq_spec; ss.
+Qed.
+    
 End LOCATIONS.
 
 
diff --git a/backend/PrintCminor.ml b/backend/PrintCminor.ml
index 59b340f7..69b56e32 100644
--- a/backend/PrintCminor.ml
+++ b/backend/PrintCminor.ml
@@ -32,7 +32,7 @@ let precedence = function
   | Econst _ -> (16, NA)
   | Eunop _ -> (15, RtoL)
   | Ebinop((Omul|Odiv|Odivu|Omod|Omodu|Omulf|Odivf|Omulfs|Odivfs|Omull|Odivl|Odivlu|Omodl|Omodlu), _, _) -> (13, LtoR)
-  | Ebinop((Oadd|Osub|Oaddf|Osubf|Oaddfs|Osubfs|Oaddl|Osubl), _, _) -> (12, LtoR)
+  | Ebinop((Oadd|Osub|Oaddf|Osubf|Oaddfs|Osubfs|Oaddl|Osubl|Opsub), _, _) -> (12, LtoR)
   | Ebinop((Oshl|Oshr|Oshru|Oshll|Oshrl|Oshrlu), _, _) -> (11, LtoR)
   | Ebinop((Ocmp _|Ocmpu _|Ocmpf _|Ocmpfs _|Ocmpl _|Ocmplu _), _, _) -> (10, LtoR)
   | Ebinop((Oand|Oandl), _, _) -> (8, LtoR)
@@ -124,6 +124,7 @@ let name_of_binop = function
   | Oshll -> "<<l"
   | Oshrl -> ">>l"
   | Oshrlu -> ">>lu"
+  | Opsub -> "-p"
   | Ocmp c -> comparison_name c
   | Ocmpu c -> comparison_name c ^ "u"
   | Ocmpf c -> comparison_name c ^ "f"
diff --git a/backend/PrintMach.ml b/backend/PrintMach.ml
index 8a5f9a7c..d328312a 100644
--- a/backend/PrintMach.ml
+++ b/backend/PrintMach.ml
@@ -83,6 +83,7 @@ let print_instruction pp i =
       fprintf pp "\treturn\n"
 
 let print_function pp id f =
+  fprintf pp "machstacksize: %s\n" (Z.to_string f.fn_stacksize);
   fprintf pp "%s() {\n" (extern_atom id);
   List.iter (print_instruction pp) f.fn_code;
   fprintf pp "}\n\n"
diff --git a/backend/RTL.v b/backend/RTL.v
index a022f55a..cfe71770 100644
--- a/backend/RTL.v
+++ b/backend/RTL.v
@@ -19,6 +19,7 @@
 Require Import Coqlib Maps.
 Require Import AST Integers Values Events Memory Globalenvs Smallstep.
 Require Import Op Registers.
+Require Import PointerOp Simulation.
 
 (** * Abstract syntax *)
 
@@ -179,14 +180,34 @@ Inductive state : Type :=
              (m: mem),                (**r memory state *)
       state.
 
+Definition ros_to_vos (m: Mem.mem) (ros: reg + ident) (rs: regset) : val + ident :=
+  match ros with
+  | inl r => match rs#r with
+            | Vint n => if negb Archi.ptr64
+                       then (match Mem.to_ptr (Vint n) m with
+                             | Some v' => inl v'
+                             | None => inl rs#r
+                             end)
+                       else inl rs#r
+            | Vlong n => if Archi.ptr64
+                        then (match Mem.to_ptr (Vlong n) m with
+                              | Some v' => inl v'
+                              | None => inl rs#r
+                              end)
+                        else inl rs#r
+            | _ => inl rs#r
+            end
+  | inr symb => inr symb
+  end.
+
 Section RELSEM.
 
 Variable ge: genv.
 
 Definition find_function
-      (ros: reg + ident) (rs: regset) : option fundef :=
+      (ros: val + ident) (rs: regset) : option fundef :=
   match ros with
-  | inl r => Genv.find_funct ge rs#r
+  | inl r => Genv.find_funct ge r
   | inr symb =>
       match Genv.find_symbol ge symb with
       | None => None
@@ -208,7 +229,7 @@ Inductive step: state -> trace -> state -> Prop :=
   | exec_Iop:
       forall s f sp pc rs m op args res pc' v,
       (fn_code f)!pc = Some(Iop op args res pc') ->
-      eval_operation ge sp op rs##args m = Some v ->
+      eval_operation_wrapper ge sp op rs##args m = Some v ->
       step (State s f sp pc rs m)
         E0 (State s f sp pc' (rs#res <- v) m)
   | exec_Iload:
@@ -228,14 +249,14 @@ Inductive step: state -> trace -> state -> Prop :=
   | exec_Icall:
       forall s f sp pc rs m sig ros args res pc' fd,
       (fn_code f)!pc = Some(Icall sig ros args res pc') ->
-      find_function ros rs = Some fd ->
+      find_function (ros_to_vos m ros rs) rs = Some fd ->
       funsig fd = sig ->
       step (State s f sp pc rs m)
         E0 (Callstate (Stackframe res f sp pc' rs :: s) fd rs##args m)
   | exec_Itailcall:
       forall s f stk pc rs m sig ros args fd m',
       (fn_code f)!pc = Some(Itailcall sig ros args) ->
-      find_function ros rs = Some fd ->
+      find_function (ros_to_vos m ros rs) rs = Some fd ->
       funsig fd = sig ->
       Mem.free m stk 0 f.(fn_stacksize) = Some m' ->
       step (State s f (Vptr stk Ptrofs.zero) pc rs m)
@@ -250,7 +271,7 @@ Inductive step: state -> trace -> state -> Prop :=
   | exec_Icond:
       forall s f sp pc rs m cond args ifso ifnot b pc',
       (fn_code f)!pc = Some(Icond cond args ifso ifnot) ->
-      eval_condition cond rs##args m = Some b ->
+      eval_condition_wrapper cond rs##args m = Some b ->
       pc' = (if b then ifso else ifnot) ->
       step (State s f sp pc rs m)
         E0 (State s f sp pc' rs m)
@@ -290,7 +311,7 @@ Inductive step: state -> trace -> state -> Prop :=
 Lemma exec_Iop':
   forall s f sp pc rs m op args res pc' rs' v,
   (fn_code f)!pc = Some(Iop op args res pc') ->
-  eval_operation ge sp op rs##args m = Some v ->
+  eval_operation_wrapper ge sp op rs##args m = Some v ->
   rs' = (rs#res <- v) ->
   step (State s f sp pc rs m)
     E0 (State s f sp pc' rs' m).
@@ -326,33 +347,76 @@ Inductive initial_state (p: program): state -> Prop :=
       funsig f = signature_main ->
       initial_state p (Callstate nil f nil m0).
 
+Inductive glob_capture (p: program) : state -> state -> Prop :=
+  | glob_capture_intro
+      f m pbs m'
+      (* (INIT: initial_state p (Callstate nil f nil m)) *)
+      (NONSTATIC: Genv.non_static_glob (Genv.globalenv p) (Genv.genv_public (Genv.globalenv p)) = pbs)
+      (CAPTURE: Genv.capture_init_mem m pbs m') :
+    glob_capture p (Callstate nil f nil m) (Callstate nil f nil m').
+      
 (** A final state is a [Returnstate] with an empty call stack. *)
 
 Inductive final_state: state -> int -> Prop :=
   | final_state_intro: forall r m,
       final_state (Returnstate nil (Vint r) m) r.
 
+(** Non-deterministic external state *)
+
+Definition is_external (ge:genv) (s:state) : Prop :=
+  match s with
+  | Callstate stk fd vargs m =>
+    match fd with
+    | External ef => is_external_ef ef
+    | _ => False
+    end
+  | State cs f sp pc rs m =>
+    match (fn_code f)!pc with
+    | Some (Ibuiltin ef args res pc') => is_external_ef ef
+    | _ => False
+    end
+  | _ => False
+  end.
+
+Definition state_mem (st: state) : mem :=
+  match st with
+  | State _ _ _ _ _ m => m
+  | Callstate _ _ _ m => m
+  | Returnstate _ _ m => m
+  end.
+
+Definition concrete_snapshot (ge: Senv.t) (st: state) (id: ident) : option Z :=
+  if Senv.public_symbol ge id
+  then (match Senv.find_symbol ge id with
+        | Some b => Maps.PTree.get b (state_mem st).(Mem.mem_concrete)
+        | None => None
+        end
+    )
+  else None.
+
 (** The small-step semantics for a program. *)
 
 Definition semantics (p: program) :=
-  Semantics step (initial_state p) final_state (Genv.globalenv p).
+  Semantics step (initial_state p) (glob_capture p) (concrete_snapshot (Genv.globalenv p)) final_state is_external (Genv.globalenv p).
 
 (** This semantics is receptive to changes in events. *)
 
-Lemma semantics_receptive:
-  forall (p: program), receptive (semantics p).
+
+Lemma semantics_receptive_at:
+  forall (p: program) s (INT: ~ is_external (Genv.globalenv p) s), receptive_at (semantics p) s.
 Proof.
   intros. constructor; simpl; intros.
 (* receptiveness *)
   assert (t1 = E0 -> exists s2, step (Genv.globalenv p) s t2 s2).
     intros. subst. inv H0. exists s1; auto.
   inversion H; subst; auto.
+  ss. des_ifs.
   exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
   exists (State s0 f sp pc' (regmap_setres res vres2 rs) m2). eapply exec_Ibuiltin; eauto.
   exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
   exists (Returnstate s0 vres2 m2). econstructor; eauto.
 (* trace length *)
-  red; intros; inv H; simpl; try lia.
+  red; intros; inv H; simpl; try lia; ss; des_ifs.
   eapply external_call_trace_length; eauto.
   eapply external_call_trace_length; eauto.
 Qed.
@@ -520,8 +584,8 @@ Proof.
 - destruct H. right; subst; extlia. auto.
 - destruct H. right; subst; extlia. auto.
 - destruct H. right; subst; extlia. auto.
-- intuition. subst; extlia.
-- destruct o; simpl in H; intuition. subst; extlia.
+- intuition.
+- destruct o; simpl in H; intuition.
 Qed.
 
 Lemma max_reg_function_def:
diff --git a/backend/RTLD.v b/backend/RTLD.v
new file mode 100644
index 00000000..c2810c16
--- /dev/null
+++ b/backend/RTLD.v
@@ -0,0 +1,79 @@
+Require Import Coqlib CoqlibC Events.
+Require Import Globalenvs Smallstep Simulation.
+Require Import sflib RTL.
+
+(** Determinacy *)
+
+Lemma semantics_single_events p s (INT: ~ is_external (Genv.globalenv p) s): single_events_at (RTL.semantics p) s.
+Proof.
+  red. intros. inv H; (try (exploit external_call_trace_length; eauto; intro T)); simpl; try lia; ss; des_ifs.
+Qed.
+
+Definition ev_rel_eq (ev1 ev2: event) : Prop := ev1 = ev2.
+
+Lemma tr_rel_eq tr :
+  tr_rel (ev_rel_eq) tr tr.
+Proof. ginduction tr; ss; econs; eauto; ss. Qed.
+
+(* Definition state_event_rel (p:program) (st: Smallstep.state (semantics p)) := *)
+(*   fun ev1 ev2 => *)
+(*     let ge := Genv.globalenv p in *)
+(*     match st with *)
+(*     | State _ _ _ _ _ m => event_rel (eventval_bind ge m) ev1 ev2 *)
+(*     | Callstate _ _ _ m => event_rel (eventval_bind ge m) ev1 ev2 *)
+(*     | Returnstate _ _ m => event_rel (eventval_bind ge m) ev1 ev2 *)
+(*     end. *)
+
+(* Definition ev_rel (p: program) : event -> event -> Prop := *)
+(*   sem_ev_rel (semantics p) (state_event_rel p). *)
+
+(* Definition ev_rel_eq (p: program) (st: Smallstep.state (semantics p)) (ev1 ev2: event) : Prop := ((fun x => ev1 = ev2) st). *)
+
+(* Lemma tr_rel_eq *)
+(*     p st tr : *)
+(*   tr_rel (RTL.semantics p) (ev_rel_eq p) st tr tr. *)
+(* Proof. *)
+(*   ginduction tr; ss; econs; eauto; ss. eapply IHtr. *)
+(* Qed. *)
+
+(* Definition ev_rel (p: program) (st: Smallstep.state (semantics p)) (ev1 ev2: event) : Prop := *)
+(*   let ge := Genv.globalenv p in *)
+(*   match st with *)
+(*   | State _ _ _ _ _ m => event_rel (eventval_bind ge m) ev1 ev2 *)
+(*   | Callstate _ _ _ m => event_rel (eventval_bind ge m) ev1 ev2 *)
+(*   | Returnstate _ _ m => event_rel (eventval_bind ge m) ev1 ev2 *)
+(*   end. *)
+(* (fun (st: Smallstep.state (semantics p)) e1 e2 => e1 = e2) *)
+(* (Smallstep.state L -> event -> event -> Prop) *)
+Lemma semantics_determinate_at:
+  forall (p: program) s (INT: ~ is_external (Genv.globalenv p) s),
+    deterministic_at (semantics p) s.
+Proof.
+  intros. constructor; simpl; intros.
+  - (* determinacy *)
+    inv STEP0; inv STEP1; Eq;
+      try (split; [apply match_traces_E0| intro;auto]);
+      try (elim H; simpl; try rewrite H2; auto).
+    + ss. des_ifs.
+      determ_tac eval_builtin_args_determ. determ_tac external_call_determ.
+    + ss. determ_tac external_call_determ.
+    + esplits; eauto.
+  - inv FINAL; inv STEP.
+  - ii. eapply semantics_single_events; eauto.
+Qed.
+
+Lemma initial_state_determ: forall p st0 st1,
+    Smallstep.initial_state (semantics p) st0 ->
+    Smallstep.initial_state (semantics p) st1 -> st0 = st1.
+Proof. intros. inv H; inv H0. subst ge0 ge. Eq. Qed.
+
+Theorem final_state_determ: forall p st0 retv,
+    Smallstep.final_state (semantics p) st0 retv ->
+    Dfinal_state (semantics p) st0 retv.
+Proof.
+  econstructor; eauto.
+  - intros. inv FINAL0; inv FINAL1. auto.
+  - red. unfold not. intros. inv FINAL; inv H0.
+Qed.
+
+Ltac DStep_tac := esplit; [(eapply semantics_determinate_at; simpl in *; eauto; des_ifs)|].
diff --git a/backend/RTLgenproof.v b/backend/RTLgenproof.v
index 1602823f..4e2861d9 100644
--- a/backend/RTLgenproof.v
+++ b/backend/RTLgenproof.v
@@ -13,9 +13,12 @@
 (** Correctness proof for RTL generation. *)
 
 Require Import Wellfounded Coqlib Maps AST Linking.
+Require Import sflib CoqlibC Classical Simulation CminorSelD RTLD.
+Require Import PointerOp IntPtrRel.
 Require Import Integers Values Memory Events Smallstep Globalenvs.
 Require Import Switch Registers Cminor Op CminorSel RTL.
 Require Import RTLgen RTLgenspec.
+From Paco Require Import paco.
 
 (** * Correspondence between Cminor environments and RTL register sets *)
 
@@ -366,6 +369,9 @@ Hypothesis TRANSL: match_prog prog tprog.
 Let ge : CminorSel.genv := Genv.globalenv prog.
 Let tge : RTL.genv := Genv.globalenv tprog.
 
+Let sem := CminorSel.semantics prog.
+Let tsem := RTL.semantics tprog.
+
 (** Relationship between the global environments for the original
   CminorSel program and the generated RTL program. *)
 
@@ -410,20 +416,24 @@ Lemma senv_preserved:
 Proof
   (Genv.senv_transf_partial TRANSL).
 
+Lemma same_public:
+  prog_public prog = prog_public tprog.
+Proof. inv TRANSL. des; eauto. Qed.
+
 (** Correctness of the code generated by [add_move]. *)
 
 Lemma tr_move_correct:
   forall r1 ns r2 nd cs f sp rs m,
   tr_move f.(fn_code) ns r1 nd r2 ->
   exists rs',
-  star step tge (State cs f sp ns rs m) E0 (State cs f sp nd rs' m) /\
+  DStar tsem (State cs f sp ns rs m) E0 (State cs f sp nd rs' m) /\
   rs'#r2 = rs#r1 /\
   (forall r, r <> r2 -> rs'#r = rs#r).
 Proof.
   intros. inv H.
   exists rs; split. constructor. auto.
   exists (rs#r2 <- (rs#r1)); split.
-  apply star_one. eapply exec_Iop. eauto. auto.
+  apply star_one. DStep_tac. eapply exec_Iop. eauto. auto.
   split. apply Regmap.gss. intros; apply Regmap.gso; auto.
 Qed.
 
@@ -474,7 +484,7 @@ Definition transl_expr_prop
     (ME: match_env map e le rs)
     (EXT: Mem.extends m tm),
   exists rs', exists tm',
-     star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm')
+     DStar tsem (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm')
   /\ match_env map (set_optvar dst v e) le rs'
   /\ Val.lessdef v rs'#rd
   /\ (forall r, In r pr -> rs'#r = rs#r)
@@ -488,7 +498,7 @@ Definition transl_exprlist_prop
     (ME: match_env map e le rs)
     (EXT: Mem.extends m tm),
   exists rs', exists tm',
-     star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm')
+     DStar tsem (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm')
   /\ match_env map e le rs'
   /\ Val.lessdef_list vl rs'##rl
   /\ (forall r, In r pr -> rs'#r = rs#r)
@@ -502,7 +512,7 @@ Definition transl_condexpr_prop
     (ME: match_env map e le rs)
     (EXT: Mem.extends m tm),
   exists rs', exists tm',
-     plus step tge (State cs f sp ns rs tm) E0 (State cs f sp (if v then ntrue else nfalse) rs' tm')
+     DPlus tsem (State cs f sp ns rs tm) E0 (State cs f sp (if v then ntrue else nfalse) rs' tm')
   /\ match_env map e le rs'
   /\ (forall r, In r pr -> rs'#r = rs#r)
   /\ Mem.extends m tm'.
@@ -547,18 +557,18 @@ Lemma transl_expr_Eop_correct:
          (vargs : list val) (v : val),
   eval_exprlist ge sp e m le args vargs ->
   transl_exprlist_prop le args vargs ->
-  eval_operation ge sp op vargs m = Some v ->
+  eval_operation_wrapper ge sp op vargs m = Some v ->
   transl_expr_prop le (Eop op args) v.
 Proof.
   intros; red; intros. inv TE.
 (* normal case *)
   exploit H0; eauto. intros [rs1 [tm1 [EX1 [ME1 [RR1 [RO1 EXT1]]]]]].
-  edestruct eval_operation_lessdef as [v' []]; eauto.
+  edestruct eval_operation_wrapper_lessdef as [v' []]; eauto.
   exists (rs1#rd <- v'); exists tm1.
 (* Exec *)
-  split. eapply star_right. eexact EX1.
+  split. eapply star_right. eexact EX1. DStep_tac.
   eapply exec_Iop; eauto.
-  rewrite (@eval_operation_preserved CminorSel.fundef _ _ _ ge tge). eauto.
+  rewrite (@eval_operation_wrapper_preserved CminorSel.fundef _ _ _ ge tge). eauto.
   exact symbols_preserved. traceEq.
 (* Match-env *)
   split. eauto with rtlg.
@@ -585,7 +595,7 @@ Proof.
   edestruct Mem.loadv_extends as [v' []]; eauto.
   exists (rs1#rd <- v'); exists tm1.
 (* Exec *)
-  split. eapply star_right. eexact EX1. eapply exec_Iload. eauto.
+  split. eapply star_right. eexact EX1. DStep_tac. eapply exec_Iload. eauto.
   instantiate (1 := vaddr'). rewrite <- H3.
   apply eval_addressing_preserved. exact symbols_preserved.
   auto. traceEq.
@@ -695,7 +705,7 @@ Proof.
 Qed.
 
 Lemma transl_expr_Ebuiltin_correct:
-  forall le ef al vl v,
+  forall le ef al vl v (INTERN: ~ is_external_ef ef),
   eval_exprlist ge sp e m le al vl ->
   transl_exprlist_prop le al vl ->
   external_call ef ge vl m E0 v m ->
@@ -709,7 +719,7 @@ Proof.
 (* Exec *)
   split. eapply star_right. eexact EX1.
   change (rs1#rd <- v') with (regmap_setres (BR rd) v' rs1).
-  eapply exec_Ibuiltin; eauto.
+  DStep_tac. eapply exec_Ibuiltin; eauto.
   eapply eval_builtin_args_trivial.
   eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   reflexivity.
@@ -724,7 +734,7 @@ Proof.
 Qed.
 
 Lemma transl_expr_Eexternal_correct:
-  forall le id sg al b ef vl v,
+  forall le id sg al b ef vl v (INTERN: ~ is_external_ef ef),
   Genv.find_symbol ge id = Some b ->
   Genv.find_funct_ptr ge b = Some (External ef) ->
   ef_sig ef = sg ->
@@ -741,11 +751,11 @@ Proof.
   exists (rs1#rd <- v'); exists tm2.
 (* Exec *)
   split. eapply star_trans. eexact EX1.
-  eapply star_left. eapply exec_Icall; eauto.
+  eapply star_left. DStep_tac. eapply exec_Icall; eauto.
   simpl. rewrite symbols_preserved. rewrite H. eauto. auto.
-  eapply star_left. eapply exec_function_external.
+  eapply star_left. DStep_tac. eapply exec_function_external.
   eapply external_call_symbols_preserved; eauto. apply senv_preserved.
-  apply star_one. apply exec_return.
+  apply star_one. DStep_tac. apply exec_return.
   reflexivity. reflexivity. reflexivity.
 (* Match-env *)
   split. eauto with rtlg.
@@ -802,15 +812,15 @@ Lemma transl_condexpr_CEcond_correct:
   forall le cond al vl vb,
   eval_exprlist ge sp e m le al vl ->
   transl_exprlist_prop le al vl ->
-  eval_condition cond vl m = Some vb ->
+  eval_condition_wrapper cond vl m = Some vb ->
   transl_condexpr_prop le (CEcond cond al) vb.
 Proof.
   intros; red; intros. inv TE.
   exploit H0; eauto. intros [rs1 [tm1 [EX1 [ME1 [RES1 [OTHER1 EXT1]]]]]].
   exists rs1; exists tm1.
 (* Exec *)
-  split. eapply plus_right. eexact EX1. eapply exec_Icond. eauto.
-  eapply eval_condition_lessdef; eauto. auto. traceEq.
+  split. eapply plus_right. eexact EX1. DStep_tac. eapply exec_Icond. eauto.
+  eapply eval_condition_wrapper_lessdef; eauto. auto. traceEq.
 (* Match-env *)
   split. assumption.
 (* Other regs *)
@@ -947,7 +957,7 @@ Definition transl_exitexpr_prop
     (ME: match_env map e le rs)
     (EXT: Mem.extends m tm),
   exists nd, exists rs', exists tm',
-     star step tge (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm')
+     DStar tsem (State cs f sp ns rs tm) E0 (State cs f sp nd rs' tm')
   /\ nth_error nexits x = Some nd
   /\ match_env map e le rs'
   /\ Mem.extends m tm'.
@@ -966,7 +976,7 @@ Proof.
   exploit H3; eauto. intros (nd & A & B).
   exploit transl_expr_correct; eauto. intros (rs1 & tm1 & EXEC1 & ME1 & RES1 & PRES1 & EXT1).
   exists nd, rs1, tm1.
-  split. eapply star_right. eexact EXEC1. eapply exec_Ijumptable; eauto. inv RES1; auto. traceEq.
+  split. eapply star_right. eexact EXEC1. DStep_tac. eapply exec_Ijumptable; eauto. inv RES1; auto. traceEq.
   auto.
 - (* XEcondition *)
   exploit transl_condexpr_correct; eauto. intros (rs1 & tm1 & EXEC1 & ME1 & RES1 & EXT1).
@@ -1295,12 +1305,13 @@ Proof.
 Qed.
 
 Theorem transl_step_correct:
-  forall S1 t S2, CminorSel.step ge S1 t S2 ->
+  forall S1 t S2, IStep sem S1 t S2 ->
   forall R1, match_states S1 R1 ->
   exists R2,
-  (plus RTL.step tge R1 t R2 \/ (star RTL.step tge R1 t R2 /\ lt_state S2 S1))
+  (DPlus tsem R1 t R2 \/ (DStar tsem R1 t R2 /\ lt_state S2 S1))
   /\ match_states S2 R2.
 Proof.
+  destruct 1. generalize dependent S2. rename H into INT.
   induction 1; intros R1 MSTATE; inv MSTATE.
 
   (* skip seq *)
@@ -1323,7 +1334,7 @@ Proof.
     inv TF. auto.
   edestruct Mem.free_parallel_extends as [tm' []]; eauto.
   econstructor; split.
-  left; apply plus_one. eapply exec_Ireturn. eauto.
+  left; apply plus_one. DStep_tac. eapply exec_Ireturn. eauto.
   rewrite H3. eauto.
   constructor; auto.
 
@@ -1348,7 +1359,7 @@ Proof.
   edestruct Mem.storev_extends as [tm''' []]; eauto.
   econstructor; split.
   left; eapply plus_right. eapply star_trans. eexact A. eexact F. reflexivity.
-  eapply exec_Istore with (a := vaddr'). eauto.
+  DStep_tac. eapply exec_Istore with (a := vaddr'). eauto.
   rewrite <- H4. apply eval_addressing_preserved. exact symbols_preserved.
   eauto. traceEq.
   econstructor; eauto. constructor.
@@ -1363,7 +1374,9 @@ Proof.
   exploit functions_translated; eauto. intros [tf' [P Q]].
   econstructor; split.
   left; eapply plus_right. eapply star_trans. eexact A. eexact E. reflexivity.
-  eapply exec_Icall; eauto. simpl. rewrite J. destruct C. eauto. discriminate P. simpl; auto.
+  DStep_tac. eapply exec_Icall; eauto. simpl. rewrite J. destruct C.
+  { destruct v; ss. des_ifs. eauto. }
+  eauto. discriminate P. simpl; auto.
   apply sig_transl_function; auto.
   traceEq.
   constructor; auto. econstructor; eauto.
@@ -1372,8 +1385,8 @@ Proof.
   intros [rs'' [tm'' [E [F [G [J Y]]]]]].
   exploit functions_translated; eauto. intros [tf' [P Q]].
   econstructor; split.
-  left; eapply plus_right. eexact E.
-  eapply exec_Icall; eauto. simpl. rewrite symbols_preserved. rewrite H4.
+  left; eapply plus_right. eexact E. DStep_tac.
+  eapply exec_Icall; eauto. simpl. rewrite symbols_preserved. simpl in H4. unfold ge. rewrite H4.
     rewrite Genv.find_funct_find_funct_ptr in P. eauto.
   apply sig_transl_function; auto.
   traceEq.
@@ -1392,7 +1405,9 @@ Proof.
   edestruct Mem.free_parallel_extends as [tm''' []]; eauto.
   econstructor; split.
   left; eapply plus_right. eapply star_trans. eexact A. eexact E. reflexivity.
-  eapply exec_Itailcall; eauto. simpl. rewrite J. destruct C. eauto. discriminate P. simpl; auto.
+  DStep_tac. eapply exec_Itailcall; eauto. simpl. rewrite J. destruct C.
+  { destruct v; ss. des_ifs. eauto. }
+  eauto. discriminate P. simpl; auto.
   apply sig_transl_function; auto.
   rewrite H; eauto.
   traceEq.
@@ -1405,8 +1420,8 @@ Proof.
   assert (fn_stacksize tf = fn_stackspace f). inv TF; auto.
   edestruct Mem.free_parallel_extends as [tm''' []]; eauto.
   econstructor; split.
-  left; eapply plus_right. eexact E.
-  eapply exec_Itailcall; eauto. simpl. rewrite symbols_preserved. rewrite H5.
+  left; eapply plus_right. eexact E. DStep_tac.
+  eapply exec_Itailcall; eauto. simpl. rewrite symbols_preserved. simpl in H5. unfold ge. rewrite H5.
   rewrite Genv.find_funct_find_funct_ptr in P. eauto.
   apply sig_transl_function; auto.
   rewrite H; eauto.
@@ -1414,6 +1429,7 @@ Proof.
   constructor; auto.
 
   (* builtin *)
+  unfold is_internal in INT. simpl in INT.
   inv TS.
   exploit invert_eval_builtin_args; eauto. intros (vparams & P & Q).
   exploit transl_exprlist_correct; eauto.
@@ -1426,7 +1442,7 @@ Proof.
   edestruct external_call_mem_extends as [tv [tm'' [A [B [C D]]]]]; eauto.
   econstructor; split.
   left. eapply plus_right. eexact E.
-  eapply exec_Ibuiltin. eauto.
+  DStep_tac. eapply exec_Ibuiltin. eauto.
   eapply eval_builtin_args_preserved with (ge1 := ge); eauto. exact symbols_preserved.
   eapply external_call_symbols_preserved. apply senv_preserved. eauto.
   traceEq.
@@ -1449,7 +1465,7 @@ Proof.
   (* loop *)
   inversion TS; subst.
   econstructor; split.
-  left. apply plus_one. eapply exec_Inop; eauto.
+  left. apply plus_one. DStep_tac. eapply exec_Inop; eauto.
   econstructor; eauto.
   econstructor; eauto.
   econstructor; eauto.
@@ -1492,7 +1508,7 @@ Proof.
   inversion TF.
   edestruct Mem.free_parallel_extends as [tm' []]; eauto.
   econstructor; split.
-  left; apply plus_one. eapply exec_Ireturn; eauto.
+  left; apply plus_one. DStep_tac. eapply exec_Ireturn; eauto.
   rewrite H2; eauto.
   constructor; auto.
 
@@ -1504,7 +1520,7 @@ Proof.
   inversion TF.
   edestruct Mem.free_parallel_extends as [tm'' []]; eauto.
   econstructor; split.
-  left; eapply plus_right. eexact A. eapply exec_Ireturn; eauto.
+  left; eapply plus_right. eexact A. DStep_tac. eapply exec_Ireturn; eauto.
   rewrite H4; eauto. traceEq.
   simpl. constructor; auto.
 
@@ -1519,7 +1535,7 @@ Proof.
   exploit tr_find_label; eauto. eapply tr_cont_call_cont; eauto.
   intros [ns2 [nd2 [nexits2 [A [B C]]]]].
   econstructor; split.
-  left; apply plus_one. eapply exec_Inop; eauto.
+  left; apply plus_one. DStep_tac. eapply exec_Inop; eauto.
   econstructor; eauto.
 
   (* internal call *)
@@ -1535,27 +1551,149 @@ Proof.
     eapply add_vars_wf; eauto. eapply add_vars_wf; eauto. apply init_mapping_wf.
   edestruct Mem.alloc_extends as [tm' []]; eauto; try apply Z.le_refl.
   econstructor; split.
-  left; apply plus_one. eapply exec_function_internal; simpl; eauto.
+  left; apply plus_one. DStep_tac. eapply exec_function_internal; simpl; eauto.
   simpl. econstructor; eauto.
   econstructor; eauto.
   inversion MS; subst; econstructor; eauto.
 
   (* external call *)
+  unfold is_internal in INT. simpl in INT.
   monadInv TF.
   edestruct external_call_mem_extends as [tvres [tm' [A [B [C D]]]]]; eauto.
   econstructor; split.
-  left; apply plus_one. eapply exec_function_external; eauto.
+  left; apply plus_one. DStep_tac. eapply exec_function_external; eauto.
   eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   constructor; auto.
 
   (* return *)
   inv MS.
   econstructor; split.
-  left; apply plus_one; constructor.
+  left; apply plus_one; DStep_tac. constructor.
   econstructor; eauto. constructor.
   eapply match_env_update_dest; eauto.
 Qed.
 
+Definition lt_state2 (S1 S2: CminorSel.state * nat) :=
+  lex_ord lt_state lt S1 S2.
+
+Lemma lt_state2_wf:
+  well_founded lt_state2.
+Proof.
+  unfold lt_state2. apply wf_inverse_image.
+  apply wf_lex_ord. apply lt_state_wf. apply lt_wf.
+Qed.
+
+Lemma match_states_xsim
+    st_src0 st_tgt0 gmtgt
+    (MATCH: match_states st_src0 st_tgt0) :
+  xsim sem tsem gmtgt lt_state2 (st_src0, 1) st_src0 st_tgt0.
+Proof.
+  (* generalize n *)
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold.
+  assert (SEQUIV: Senv.equiv tge ge) by (symmetry; apply senv_preserved).  
+  destruct (classic (CminorSel.is_external ge st_src0)).
+  (* external state *)
+  - unfold CminorSel.is_external in H. des_ifs.
+    (* builtin *)
+    + destruct (classic (exists t st_src1, Step sem (CminorSel.State f (Sbuiltin b e0 l) k sp e m) t st_src1)); cycle 1.
+      { left. econs. econs;[|ii; inv FINALSRC]. ii. exfalso. eapply H0. eauto. }
+      des. inversion MATCH; subst. inv TS. inv H0.
+      exploit invert_eval_builtin_args; eauto. intros (vparams & P & Q).
+      exploit transl_exprlist_correct; eauto. instantiate (1:=cs).
+      intros [rs' [tm' [E [F [G [J K]]]]]].
+      exploit transl_eval_builtin_args; eauto. intros (vargs' & U & V).
+      exploit (@eval_builtin_args_lessdef _ ge (fun r => rs'#r) (fun r => rs'#r)); eauto. intros (vargs'' & X & Y).
+      assert (Z: Val.lessdef_list vl vargs'') by (eapply Val.lessdef_list_trans; eauto).
+      exploit star_inv; eauto. i. des; subst; clarify; cycle 1.
+      (* arg eval plus *)
+      { left. econs. econs 2.
+        - esplits; eauto. instantiate (1:= (CminorSel.State f (Sbuiltin b e0 l) k sp e m, 0)).
+          econs 2. omega.
+        - left. pfold. ss. right. econs. i. econs.
+          + ii. inv STEPTGT; clarify.
+            exploit eval_builtin_args_preserved; try eapply X.
+            { instantiate (1:=tge). ss. ii. symmetry. destruct senv_preserved. des. ss. }
+            i. ss. unfold tge in H1.
+            exploit eval_builtin_args_determ. eapply H13. eapply H1. i. subst.
+            exploit external_call_mem_extends_backward;[eauto| |eauto| |].
+            { eapply external_call_symbols_preserved; eauto. }
+            { eapply Z. } i. des.
+            * left. esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl| |].
+              left. eapply plus_one. eapply CminorSel.step_builtin; eauto.
+              right. eapply CIH. econstructor; eauto. constructor.
+              eapply match_env_update_res; eauto.
+            * exploit UBSRC; eauto. clarify.
+            * right. esplits; eauto.
+              { eapply star_one. eapply CminorSel.step_builtin; eauto. }
+              subst. eapply tr_rel_refl. eapply ev_rel_refl.
+          + ii. inv FINALTGT.
+          + i. right. exploit external_call_mem_extends_backward_progress; eauto. i. des.
+            esplits. eapply exec_Ibuiltin; eauto.
+            { exploit eval_builtin_args_preserved; try eapply X.
+              destruct senv_preserved. des. ss. eauto. }
+            { eapply external_call_symbols_preserved. eapply senv_preserved. eauto. } }
+      { right. econs. ii. econs.
+        - ii. inv STEPTGT; clarify.
+          exploit eval_builtin_args_preserved; try eapply X.
+          { instantiate (1:=tge). ss. ii. symmetry.
+            destruct senv_preserved. des. ss. }
+          i. ss. unfold tge in H1.
+          exploit eval_builtin_args_determ. eapply H13. eapply H0. i. subst.
+          exploit external_call_mem_extends_backward;[eauto| |eauto| |].
+          { eapply external_call_symbols_preserved; eauto. }
+          { eapply Z. } i. des.
+          * left. esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl| |].
+            left. eapply plus_one. eapply CminorSel.step_builtin; eauto.
+            right. eapply CIH. econstructor; eauto. constructor.
+            eapply match_env_update_res; eauto.
+          * exploit UBSRC; eauto. clarify.
+          * right. esplits; eauto.
+            { eapply star_one. eapply CminorSel.step_builtin; eauto. }
+            subst. eapply tr_rel_refl. eapply ev_rel_refl.
+        - ii. inv FINALTGT.
+        - i. right. exploit external_call_mem_extends_backward_progress; eauto. i. des.
+          esplits. eapply exec_Ibuiltin; eauto.
+          { exploit eval_builtin_args_preserved; try eapply X.
+            destruct senv_preserved. des. ss. eauto. }
+            { eapply external_call_symbols_preserved. eapply senv_preserved. eauto. } }
+    + (* external *)
+      right. econs. i.
+      unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+      { inv SAFESRC. }
+      econs.
+      * ii. inv MATCH; clarify.
+        inv STEPTGT; ss; des; clarify. inv SAFESRC; ss; clarify; try (by (des; clarify)).
+        exploit external_call_mem_extends_backward.
+        2:{ eapply external_call_symbols_preserved; eauto. }
+        all: eauto. i; des.
+        { left. esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl| |].
+          { left. eapply plus_one. eapply CminorSel.step_external_function; eauto. }
+          right. eapply CIH; eauto. constructor; auto. }
+        { exploit UBSRC; eauto. clarify. }
+        { right. esplits; eauto.
+          { eapply star_one. eapply CminorSel.step_external_function; eauto. }
+          subst. eapply tr_rel_refl. eapply ev_rel_refl. }
+      * ii. inv MATCH. inv FINALTGT.
+      * right. inv SAFESRC; ss; clarify; try (by (des; clarify)); inv MATCH; clarify.
+        exploit external_call_mem_extends_backward_progress; eauto. i. des.
+        monadInv TF. esplits. eapply exec_function_external; eauto.
+        eapply external_call_symbols_preserved; eauto. eapply senv_preserved.
+  (* internal state *)
+  - left. econs. econs.
+    + i. exploit transl_step_correct; eauto. i. des.
+      * esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl|].
+        left. split; eauto. eapply CminorSelD.semantics_receptive_at; auto.
+      * exploit star_inv; eauto. i. des; subst.
+        { esplits; [econs| |].
+          - right. esplits; eauto. econs. eauto.
+          - right. eapply CIH. eauto. }
+        { esplits; [eapply tr_rel_refl; eapply ev_rel_refl| |].
+          - left. split; eauto. eapply CminorSelD.semantics_receptive_at; auto.
+          - right. eapply CIH; eauto. }
+    + ii. eapply final_state_determ; eauto. inv FINALSRC. inv MATCH. inv MS; inv LD. econs.
+Qed.
+
 Lemma transl_initial_states:
   forall S, CminorSel.initial_state prog S ->
   exists R, RTL.initial_state tprog R /\ match_states S R.
@@ -1579,15 +1717,61 @@ Proof.
   intros. inv H0. inv H. inv MS. inv LD. constructor.
 Qed.
 
+Lemma non_static_equiv l:
+  Genv.non_static_glob (Genv.globalenv prog) l = Genv.non_static_glob (Genv.globalenv tprog) l.
+Proof.
+  Local Transparent ge tge.
+  induction l; ss.
+  specialize senv_preserved. ss. i. inv H. inv H1. unfold ge, tge, fundef in *.
+  specialize (H a). unfold Senv.public_symbol in H. ss. erewrite H.
+  specialize (H0 a). rewrite <- H0. erewrite IHl; eauto.
+Qed.
+
+Lemma transf_initial_capture S1 S2 S2'
+    (INITSRC: CminorSel.initial_state prog S1)
+    (INITTGT: RTL.initial_state tprog S2)
+    (MATCH: match_states S1 S2)
+    (CAPTGT: RTL.glob_capture tprog S2 S2'):
+  exists S1', CminorSel.glob_capture prog S1 S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (CminorSel.concrete_snapshot ge S1') (RTL.concrete_snapshot tge S2').
+Proof.
+  specialize senv_preserved. intros SENVEQ.
+  inv CAPTGT. ss. rename m' into m2'.
+  rewrite Genv.globalenv_public in CAPTURE. erewrite <- same_public in CAPTURE; eauto.
+  inv MATCH. (* inv STAKS. inv ARGS.  *) inv MS. inv LD.
+  exploit non_static_equiv. instantiate (1:=prog_public prog). intros EQUIV.
+  assert (exists m1', Genv.capture_init_mem m0 (Genv.non_static_glob (Genv.globalenv prog) (AST.prog_public prog)) m1' /\
+                     Mem.extends m1' m2').
+  { clear INITSRC INITTGT. rewrite <- EQUIV in CAPTURE. clear EQUIV TF. inv CAPTURE.
+    remember (Genv.non_static_glob (Genv.globalenv prog) (prog_public prog)) as l. clear Heql.
+    clear SENVEQ. move l before f0. revert_until f0.
+    induction l; ss; i.
+    { inv CAP. esplits; eauto. econs. econs. }
+    inv CAP. exploit Mem.capture_extends_backward; eauto. i. des.
+    exploit IHl; eauto. i. des. inv H. esplits; eauto. econs. econs; eauto. }
+  des. esplits; eauto.
+  - inv INITSRC. econs. eauto. rewrite Genv.globalenv_public. eauto.
+  - econs; eauto. econs; eauto.
+  - ii. unfold CminorSel.concrete_snapshot, concrete_snapshot in *. inv SENVEQ. des. erewrite H3, H2. des_ifs; ss.
+    eapply Mem.mext_concrete; eauto. eapply Mem.concrete_valid; eauto.
+Qed.
+
 Theorem transf_program_correct:
-  forward_simulation (CminorSel.semantics prog) (RTL.semantics tprog).
+  mixed_simulation (CminorSel.semantics prog) (RTL.semantics tprog).
 Proof.
-  eapply forward_simulation_star_wf with (order := lt_state).
-  apply senv_preserved.
-  eexact transl_initial_states.
-  eexact transl_final_states.
-  apply lt_state_wf.
-  exact transl_step_correct.
+  econs. econs.
+  - eapply lt_state2_wf.
+  - rr. i. destruct a. exists (s, (1 + n)%nat). ss. econs 2. lia.
+  - econs. i. exploit transl_initial_states; eauto. i. des.
+    exists R. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. inversion INITSRC; subst. inversion H0; subst.
+      inv MS. inv LD. exploit transf_initial_capture; eauto. i. des.
+      esplits; eauto. eapply match_states_xsim; auto.
+  - i. apply senv_preserved.
 Qed.
 
 End CORRECTNESS.
diff --git a/backend/RTLtyping.v b/backend/RTLtyping.v
index 5b8646ea..a792fc3a 100644
--- a/backend/RTLtyping.v
+++ b/backend/RTLtyping.v
@@ -26,6 +26,7 @@ Require Import Memory.
 Require Import Events.
 Require Import RTL.
 Require Import Conventions.
+Require Import PointerOp.
 
 (** * The type system *)
 
@@ -843,6 +844,20 @@ Proof.
   rewrite H8. eapply type_of_operation_sound; eauto.
 Qed.
 
+Lemma wt_exec_Iop_wrapper:
+  forall (ge: genv) env f sp op args res s rs m v,
+  wt_instr f env (Iop op args res s) ->
+  eval_operation_wrapper ge sp op rs##args m = Some v ->
+  wt_regset env rs ->
+  wt_regset env (rs#res <- v).
+Proof.
+  intros. inv H.
+  simpl in H0. inv H0. apply wt_regset_assign; auto.
+  rewrite H4; auto.
+  eapply wt_regset_assign; auto.
+  rewrite H8. eapply type_of_operation_wrapper_sound; eauto.
+Qed.
+
 Lemma wt_exec_Iload:
   forall env f chunk addr args dst s m a v rs,
   wt_instr f env (Iload chunk addr args dst s) ->
@@ -850,7 +865,10 @@ Lemma wt_exec_Iload:
   wt_regset env rs ->
   wt_regset env (rs#dst <- v).
 Proof.
-  intros. destruct a; simpl in H0; try discriminate. inv H.
+  intros. destruct a; simpl in H0; try discriminate.
+  { unfold Mem.loadv in H0. des_ifs. inv H. eapply wt_regset_assign; eauto.
+    rewrite H8. eapply Mem.load_type; eauto. }
+  inv H. unfold Mem.loadv in H0. des_ifs.
   eapply wt_regset_assign; eauto. rewrite H8; eapply Mem.load_type; eauto.
 Qed.
 
@@ -930,15 +948,15 @@ Proof.
   (* Inop *)
   econstructor; eauto.
   (* Iop *)
-  econstructor; eauto. eapply wt_exec_Iop; eauto.
+  econstructor; eauto. eapply wt_exec_Iop_wrapper; eauto.
   (* Iload *)
   econstructor; eauto. eapply wt_exec_Iload; eauto.
   (* Istore *)
   econstructor; eauto.
   (* Icall *)
   assert (wt_fundef fd).
-    destruct ros; simpl in H0.
-    pattern fd. apply Genv.find_funct_prop with fundef unit p (rs#r).
+    destruct (ros_to_vos m ros rs); simpl in H0.
+    pattern fd. apply Genv.find_funct_prop with fundef unit p v.
     exact wt_p. exact H0.
     caseEq (Genv.find_symbol ge i); intros; rewrite H1 in H0.
     pattern fd. apply Genv.find_funct_ptr_prop with fundef unit p b.
@@ -949,8 +967,8 @@ Proof.
   inv WTI. rewrite <- H8. apply wt_regset_list. auto.
   (* Itailcall *)
   assert (wt_fundef fd).
-    destruct ros; simpl in H0.
-    pattern fd. apply Genv.find_funct_prop with fundef unit p (rs#r).
+    destruct (ros_to_vos m ros rs); simpl in H0.
+    pattern fd. apply Genv.find_funct_prop with fundef unit p v.
     exact wt_p. exact H0.
     caseEq (Genv.find_symbol ge i); intros; rewrite H1 in H0.
     pattern fd. apply Genv.find_funct_ptr_prop with fundef unit p b.
@@ -989,6 +1007,16 @@ Proof.
   rewrite H3. constructor.
 Qed.
 
+Lemma wt_initial_capture_state
+    S S'
+    (INIT: initial_state p S)
+    (CAP: glob_capture p S S'):
+  wt_state S'.
+Proof.
+  exploit wt_initial_state; eauto. intros WT.
+  inv INIT; inv WT. inv CAP. econs; eauto.
+Qed.
+
 Lemma wt_instr_inv:
   forall s f sp pc rs m i,
   wt_state (State s f sp pc rs m) ->
diff --git a/backend/Regalloc.ml b/backend/Regalloc.ml
index 19aba4f6..452632be 100644
--- a/backend/Regalloc.ml
+++ b/backend/Regalloc.ml
@@ -1192,6 +1192,7 @@ and success f alloc =
 
 
 let regalloc f =
+  (* fprintf !pp "SI is callee save?: %B\n" (is_callee_save SI); *)
   init_trace();
   reset_temps();
   let f1 = Splitting.rename_function f in
diff --git a/backend/Renumberproof.v b/backend/Renumberproof.v
index 7cda9425..e84dae7d 100644
--- a/backend/Renumberproof.v
+++ b/backend/Renumberproof.v
@@ -14,8 +14,10 @@
 
 Require Import Coqlib Maps Postorder.
 Require Import AST Linking.
+Require Import Simulation RTLD Classical PointerOp.
 Require Import Values Memory Globalenvs Events Smallstep.
 Require Import Op Registers RTL Renumber.
+From Paco Require Import paco.
 
 Definition match_prog (p tp: RTL.program) :=
   match_program (fun ctx f tf => tf = transf_fundef f) eq p tp.
@@ -33,6 +35,10 @@ Hypothesis TRANSL: match_prog prog tprog.
 Let ge := Genv.globalenv prog.
 Let tge := Genv.globalenv tprog.
 
+Let sem := semantics prog.
+Let tsem := semantics tprog.
+Let ev_rel2 := ev_rel_eq.
+
 Lemma functions_translated:
   forall v f,
   Genv.find_funct ge v = Some f ->
@@ -54,6 +60,9 @@ Lemma senv_preserved:
   Senv.equiv ge tge.
 Proof (Genv.senv_transf TRANSL).
 
+Lemma same_public: prog_public prog = prog_public tprog.
+Proof. inv TRANSL. des; eauto. Qed.
+
 Lemma sig_preserved:
   forall f, funsig (transf_fundef f) = funsig f.
 Proof.
@@ -156,80 +165,106 @@ Inductive match_states: RTL.state -> RTL.state -> Prop :=
                    (Returnstate stk' v m).
 
 Lemma step_simulation:
-  forall S1 t S2, RTL.step ge S1 t S2 ->
+  forall S1 t S2, IStep sem S1 t S2 ->
   forall S1', match_states S1 S1' ->
-  exists S2', RTL.step tge S1' t S2' /\ match_states S2 S2'.
+  exists S2', DStep tsem S1' t S2' /\ match_states S2 S2'.
 Proof.
+  destruct 1. generalize dependent S2. rename H into INT.
   induction 1; intros S1' MS; inv MS; try TR_AT.
 (* nop *)
-  econstructor; split. eapply exec_Inop; eauto.
+  econstructor; split. DStep_tac. eapply exec_Inop; eauto.
   constructor; auto. eapply reach_succ; eauto. simpl; auto.
 (* op *)
   econstructor; split.
-  eapply exec_Iop; eauto.
-  instantiate (1 := v). rewrite <- H0. apply eval_operation_preserved. exact symbols_preserved.
+  DStep_tac. eapply exec_Iop; eauto.
+  instantiate (1 := v). rewrite <- H0. apply eval_operation_wrapper_preserved. exact symbols_preserved.
   constructor; auto. eapply reach_succ; eauto. simpl; auto.
 (* load *)
   econstructor; split.
   assert (eval_addressing tge sp addr rs ## args = Some a).
   rewrite <- H0. apply eval_addressing_preserved. exact symbols_preserved.
-  eapply exec_Iload; eauto.
+  DStep_tac. eapply exec_Iload; eauto.
   constructor; auto. eapply reach_succ; eauto. simpl; auto.
 (* store *)
   econstructor; split.
   assert (eval_addressing tge sp addr rs ## args = Some a).
   rewrite <- H0. apply eval_addressing_preserved. exact symbols_preserved.
-  eapply exec_Istore; eauto.
+  DStep_tac. eapply exec_Istore; eauto.
   constructor; auto. eapply reach_succ; eauto. simpl; auto.
 (* call *)
   econstructor; split.
-  eapply exec_Icall with (fd := transf_fundef fd); eauto.
+  DStep_tac. eapply exec_Icall with (fd := transf_fundef fd); eauto.
     eapply find_function_translated; eauto.
     apply sig_preserved.
   constructor. constructor; auto. constructor. eapply reach_succ; eauto. simpl; auto.
 (* tailcall *)
   econstructor; split.
-  eapply exec_Itailcall with (fd := transf_fundef fd); eauto.
+  DStep_tac. eapply exec_Itailcall with (fd := transf_fundef fd); eauto.
     eapply find_function_translated; eauto.
     apply sig_preserved.
   constructor. auto.
 (* builtin *)
   econstructor; split.
+  DStep_tac. unfold is_internal in INT. ss. des_ifs.
   eapply exec_Ibuiltin; eauto.
     eapply eval_builtin_args_preserved with (ge1 := ge); eauto. exact symbols_preserved.
     eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   constructor; auto. eapply reach_succ; eauto. simpl; auto.
 (* cond *)
   econstructor; split.
-  eapply exec_Icond; eauto.
+  DStep_tac. eapply exec_Icond; eauto.
   replace (if b then renum_pc (pnum f) ifso else renum_pc (pnum f) ifnot)
      with (renum_pc (pnum f) (if b then ifso else ifnot)).
   constructor; auto. eapply reach_succ; eauto. simpl. destruct b; auto.
   destruct b; auto.
 (* jumptbl *)
   econstructor; split.
-  eapply exec_Ijumptable; eauto. rewrite list_nth_z_map. rewrite H1. simpl; eauto.
+  DStep_tac. eapply exec_Ijumptable; eauto. rewrite list_nth_z_map. rewrite H1. simpl; eauto.
   constructor; auto. eapply reach_succ; eauto. simpl. eapply list_nth_z_in; eauto.
 (* return *)
   econstructor; split.
-  eapply exec_Ireturn; eauto.
+  DStep_tac. eapply exec_Ireturn; eauto.
   constructor; auto.
 (* internal function *)
   simpl. econstructor; split.
-  eapply exec_function_internal; eauto.
+  DStep_tac. eapply exec_function_internal; eauto.
   constructor; auto. unfold reach. constructor.
 (* external function *)
   econstructor; split.
-  eapply exec_function_external; eauto.
+  DStep_tac. eapply exec_function_external; eauto.
     eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   constructor; auto.
 (* return *)
   inv STACKS. inv H1.
   econstructor; split.
-  eapply exec_return; eauto.
+  DStep_tac. eapply exec_return; eauto.
   constructor; auto.
 Qed.
 
+Lemma match_states_bsim
+      s1 (EXT: is_external ge s1)
+      s2 t s2' (STEPTGT: Step tsem s2 t s2')
+      (MATCH: match_states s1 s2)
+      (SAFESRC: safe sem s1) :
+    (exists s1', Step sem s1 t s1' /\ match_states s1' s2')
+  \/ (~ trace_intact t /\ exists s1'' t', Star sem s1 t' s1'' /\ exists tl, t' = (trace_cut_pterm t) ** tl).
+Proof.
+  assert (SEQUIV: Senv.equiv tge ge) by (symmetry; eapply senv_preserved).
+  i. unfold is_external in *. des_ifs; i; inv MATCH.
+  (* builtin *)
+  - inv STEPTGT; try TR_AT; Eq.
+    exploit external_call_symbols_preserved; eauto. i.
+    exploit exec_Ibuiltin;[eapply Heq| |eapply H|].
+    { eapply eval_builtin_args_preserved. eapply SEQUIV. eauto. }
+    i. left. esplits; eauto.
+    econs; eauto. eapply reach_succ; eauto. ss. eauto.
+  (* external call *)
+  - inv STEPTGT; try TR_AT; Eq.
+    exploit external_call_symbols_preserved; eauto. i.
+    exploit exec_function_external. eapply H. i.
+    left. esplits; eauto. econs; eauto.
+Qed.
+
 Lemma transf_initial_states:
   forall S1, RTL.initial_state prog S1 ->
   exists S2, RTL.initial_state tprog S2 /\ match_states S1 S2.
@@ -249,14 +284,74 @@ Proof.
   intros. inv H0. inv H. inv STACKS. constructor.
 Qed.
 
+Lemma non_static_equiv l:
+  Genv.non_static_glob (Genv.globalenv prog) l = Genv.non_static_glob (Genv.globalenv tprog) l.
+Proof.
+  induction l; ss.
+  specialize senv_preserved. i. unfold ge, tge in H. r in H. des.
+  specialize (H0 a).
+  unfold Senv.public_symbol in H0. ss. rewrite <- H0.
+  specialize (H a). rewrite <- H. erewrite IHl; eauto.
+Qed.
+
+Lemma transf_initial_capture S1 S2 S2'
+    (INITSRC: RTL.initial_state prog S1)
+    (INITTGT: RTL.initial_state tprog S2)
+    (MATCH: match_states S1 S2)
+    (CAPTGT: RTL.glob_capture tprog S2 S2'):
+  exists S1', RTL.glob_capture prog S1 S1' /\ match_states S1' S2'.
+Proof.
+  inv CAPTGT. ss. rewrite Genv.globalenv_public in CAPTURE.
+  rewrite <- same_public in CAPTURE. erewrite <- non_static_equiv in CAPTURE.
+  inv MATCH. inv STACKS. esplits;[|econs; econs].
+  econs; eauto. rewrite Genv.globalenv_public. eauto.
+Qed.
+  
+Lemma match_states_xsim st_src0 st_tgt0 gmtgt
+    (MATCH: match_states st_src0 st_tgt0) :
+  xsim (RTL.semantics prog) (RTL.semantics tprog) gmtgt lt 0%nat st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold. destruct (classic (is_external ge st_src0)); cycle 1.
+  (* not external *)
+  - left. econs. econs.
+    + i. exploit step_simulation; eauto. i. des.
+      esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl|].
+      left. split; [eapply plus_one; eauto|]. eapply semantics_receptive_at; auto.
+    + ii. eapply final_state_determ; eauto. inv FINALSRC. inv MATCH. inv STACKS. econs.
+  (* external *)
+  - right. econs. i. econs.
+    + i. exploit match_states_bsim; eauto. i. des.
+      * left. esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl|].
+        left. eauto. eapply plus_one. eauto.
+      * right. esplits; eauto. subst. eapply tr_rel_refl. eapply ev_rel_refl.
+    + ii. inv FINALTGT. inv MATCH. inv STACKS. esplits; auto. eapply star_refl. econs.
+    + ss. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify; [inv SAFESRC; ss|].
+      inv MATCH; ss; des_ifs; inv SAFESRC; unfold ge in *; clarify.
+      * esplits. right. esplits. eapply exec_Ibuiltin; eauto; [TR_AT; eauto| |].
+        { eapply eval_builtin_args_preserved. eapply senv_preserved. eauto. }
+        { eapply external_call_symbols_preserved; eauto. apply senv_preserved. }
+      * right. esplits. eapply exec_function_external; eauto.
+        eapply external_call_symbols_preserved; eauto. apply senv_preserved.
+Qed.
+
 Theorem transf_program_correct:
-  forward_simulation (RTL.semantics prog) (RTL.semantics tprog).
+  mixed_simulation (RTL.semantics prog) (RTL.semantics tprog).
 Proof.
-  eapply forward_simulation_step.
-  apply senv_preserved.
-  eexact transf_initial_states.
-  eexact transf_final_states.
-  exact step_simulation.
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (S a). lia.
+  - econs. i. exploit transf_initial_states; eauto. i. des.
+    exists S2. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. exploit transf_initial_capture; eauto. i. des. esplits; eauto.
+      { subst. ss. unfold concrete_snapshot. ii.
+        destruct senv_preserved. des. fold tge. rewrite H4, H5.
+        inv INITSRC. inv H1. inv H2. inv STACKS. ss. }
+        des_ifs; eauto. apply match_states_xsim; auto.
+  - i. apply senv_preserved.
 Qed.
 
 End PRESERVATION.
diff --git a/backend/Selection.v b/backend/Selection.v
index a5bef9ae..26e96186 100644
--- a/backend/Selection.v
+++ b/backend/Selection.v
@@ -154,6 +154,8 @@ Definition sel_binop (op: Cminor.binary_operation) (arg1 arg2: expr) : expr :=
   | Cminor.Oshll => shll arg1 arg2
   | Cminor.Oshrl => shrl arg1 arg2
   | Cminor.Oshrlu => shrlu arg1 arg2
+  | Cminor.Opsub => if Archi.ptr64 then psubl arg1 arg2 else psub arg1 arg2
+  (* | Cminor.Opsubl => psubl arg1 arg2 *)
   | Cminor.Ocmp c => comp c arg1 arg2
   | Cminor.Ocmpu c => compu c arg1 arg2
   | Cminor.Ocmpf c => compf c arg1 arg2
@@ -210,7 +212,17 @@ Definition classify_call (e: Cminor.expr) : call_kind :=
   | None => Call_default
   | Some id =>
       match defmap!id with
-      | Some(Gfun(External ef)) => if ef_inline ef then Call_builtin ef else Call_imm id
+        Some(Gfun(External ef)) => if ef_inline ef then
+                                    (* (if Events.is_external_efb ef *)
+                                    (*  then Call_imm id *)
+                                    (*  else *)
+                                    Call_builtin ef
+                                  else Call_imm id
+                                  (* is this necessary? 
+                                    You shouldn't touch the optimization details
+                                     -> if unknown builtin/runtime functions are determinate,
+                                        we dont need this changes. *)
+   (* | Some(Gfun(External ef)) => if ef_inline ef then Call_builtin ef else Call_imm id *)        
       | _ => Call_imm id
       end
   end.
diff --git a/backend/Selectionaux.ml b/backend/Selectionaux.ml
index 8acae8f2..63177af3 100644
--- a/backend/Selectionaux.ml
+++ b/backend/Selectionaux.ml
@@ -40,6 +40,7 @@ let cost_unop = function
 
 let cost_binop = function
   | Oadd  | Osub -> 1
+  | Opsub -> 1
   | Omul -> 2
   | Odiv  | Odivu | Omod  | Omodu -> assert false
   | Oand  | Oor   | Oxor  | Oshl  | Oshr  | Oshru -> 1
diff --git a/backend/Selectionproof.v b/backend/Selectionproof.v
index 4755ab79..0da9dc20 100644
--- a/backend/Selectionproof.v
+++ b/backend/Selectionproof.v
@@ -19,6 +19,10 @@ Require Import Values Memory Builtins Events Globalenvs Smallstep.
 Require Import Switch Cminor Op CminorSel Cminortyping.
 Require Import SelectOp SelectDiv SplitLong SelectLong Selection.
 Require Import SelectOpproof SelectDivproof SplitLongproof SelectLongproof.
+Require Import sflib Classical Simulation CminorD CoqlibC.
+Require Import CminorSelD IntPtrRel PointerOp.
+From Paco Require Import paco.
+Require Import sflib.
 
 Local Open Scope cminorsel_scope.
 Local Open Scope error_monad_scope.
@@ -118,6 +122,10 @@ Variable prog: Cminor.program.
 Variable tprog: CminorSel.program.
 Let ge := Genv.globalenv prog.
 Let tge := Genv.globalenv tprog.
+
+Let sem := Cminor.semantics prog.
+Let tsem := CminorSel.semantics tprog.
+
 Hypothesis TRANSF: match_prog prog tprog.
 
 Lemma wt_prog : wt_program prog.
@@ -138,6 +146,9 @@ Lemma senv_preserved:
   Senv.equiv (Genv.to_senv ge) (Genv.to_senv tge).
 Proof (Genv.senv_match TRANSF).
 
+Lemma same_public: prog_public prog = prog_public tprog.
+Proof. inv TRANSF. des; eauto. Qed.
+
 Lemma function_ptr_translated:
   forall (b: block) (f: Cminor.fundef),
   Genv.find_funct_ptr ge b = Some f ->
@@ -203,7 +214,12 @@ Proof.
   intros until a. functional induction (condexpr_of_expr a); intros.
 (* compare *)
   inv H. econstructor; eauto.
+  destruct (ptr_cond c) eqn:PCD; cycle 1.
+  rewrite eval_operation_no_ptr_op in H6; eauto. 
   simpl in H6. inv H6. apply Val.bool_of_val_of_optbool. auto.
+  rewrite PointerOp.cmp_wrapper_eval_condition_join in H6; eauto.
+  destruct (eval_condition_join c vl m); ss. des_ifs; inv H0; eauto.
+  inv H6. inv H0.
 (* condition *)
   inv H. econstructor; eauto. destruct va; eauto.
 (* let *)
@@ -219,14 +235,24 @@ Lemma eval_condition_of_expr:
   Val.bool_of_val v b ->
   exists vl,
      eval_exprlist tge sp e m le (snd (condition_of_expr a)) vl
-  /\ eval_condition (fst (condition_of_expr a)) vl m = Some b.
+  /\ if (ptr_cond (fst (condition_of_expr a)))
+    then eval_condition_join (fst (condition_of_expr a)) vl m = Some b
+    else eval_condition (fst (condition_of_expr a)) vl m = Some b.
 Proof.
   intros a; functional induction (condition_of_expr a); intros; simpl.
 - inv H. exists vl; split; auto.
+  destruct (ptr_cond c) eqn:PCOND; cycle 1.
+  rewrite eval_operation_no_ptr_op in H6; eauto.
   simpl in H6. inv H6. apply Val.bool_of_val_of_optbool in H0. auto.
+  rewrite cmp_wrapper_eval_condition_join in H6; eauto.
+  destruct (eval_condition_join c vl m); ss; des_ifs; inv H0; eauto.
 - exists (v :: nil); split.
   constructor; auto; constructor.
-  inv H0; simpl; auto.
+  destruct (ptr_cond (Ccompuimm Cne Int.zero)) eqn:PCOND; cycle 1.
+  inv H0; simpl; auto. inv H0.
+  destruct (Val.cmpu_bool (Mem.valid_pointer m) Cne (to_ptr_val m (Vint n)) (to_ptr_val m (Vint Int.zero))) eqn:PCMP.
+  2:{ simpl. eauto. }
+  exploit (cmpu_no_angelic m Cne (Vint n) (Vint Int.zero) b (negb (Int.eq n Int.zero))); eauto.
 Qed.
 
 Lemma eval_load:
@@ -236,6 +262,10 @@ Lemma eval_load:
   eval_expr tge sp e m le (load chunk a) v'.
 Proof.
   intros. generalize H0; destruct v; simpl; intro; try discriminate.
+  { unfold Mem.loadv in H1. ss. des_ifs. unfold load.
+    generalize (eval_addressing_long _ _ _ _ _ chunk _ _ _ Heq0 H (eq_refl _)).
+    destruct (addressing chunk a). intros [vl [EV EQ]].
+    eapply eval_Eload; eauto. }
   unfold load.
   generalize (eval_addressing _ _ _ _ _ chunk _ _ _ _ H (eq_refl _)).
   destruct (addressing chunk a). intros [vl [EV EQ]].
@@ -247,13 +277,17 @@ Lemma eval_store:
   eval_expr tge sp e m nil a1 v1 ->
   eval_expr tge sp e m nil a2 v2 ->
   Mem.storev chunk m v1 v2 = Some m' ->
-  step tge (State f (store chunk a1 a2) k sp e m)
+  DStep tsem (State f (store chunk a1 a2) k sp e m)
         E0 (State f Sskip k sp e m').
 Proof.
   intros. generalize H1; destruct v1; simpl; intro; try discriminate.
+  { des_ifs. unfold store.
+    generalize (eval_addressing_long _ _ _ _ _ chunk _ _ _ Heq H (eq_refl _)).
+    destruct (addressing chunk a1). intros [vl [EV EQ]].
+    DStep_tac. eapply step_store; eauto. }
   unfold store.
   generalize (eval_addressing _ _ _ _ _ chunk _ _ _ _ H (eq_refl _)).
-  destruct (addressing chunk a1). intros [vl [EV EQ]].
+  destruct (addressing chunk a1). intros [vl [EV EQ]]. DStep_tac.
   eapply step_store; eauto.
 Qed.
 
@@ -302,7 +336,7 @@ Proof.
 Qed.
 
 Lemma eval_sel_binop:
-  forall le op a1 a2 v1 v2 v,
+  forall le op a1 a2 v1 v2 v (PTRBIN: Cminor.ptr_binop op = false),
   eval_expr tge sp e m le a1 v1 ->
   eval_expr tge sp e m le a2 v2 ->
   eval_binop op v1 v2 m = Some v ->
@@ -343,14 +377,36 @@ Proof.
   eapply eval_shll; eauto.
   eapply eval_shrl; eauto.
   eapply eval_shrlu; eauto.
+  clarify.
+  clarify.
   apply eval_comp; auto.
+  destruct Archi.ptr64; simpl in *.
   apply eval_compu; auto.
+  clarify.
   apply eval_compf; auto.
   apply eval_compfs; auto.
   exists v; split; auto. eapply eval_cmpl; eauto.
   exists v; split; auto. eapply eval_cmplu; eauto.
 Qed.
 
+Lemma eval_sel_binop_wrapper le op a1 a2 v1 v2 v
+    (EV1: eval_expr tge sp e m le a1 v1)
+    (EV2: eval_expr tge sp e m le a2 v2)
+    (BIN: eval_binop_wrapper op v1 v2 m = Some v) :
+  exists v', <<SEL: eval_expr tge sp e m le (sel_binop op a1 a2) v'>> /\ <<LD: Val.lessdef v v'>>.
+Proof.
+  destruct (Cminor.ptr_binop op) eqn: PTRBIN; cycle 1.
+  { rewrite eval_binop_no_ptr_binop in BIN; eauto. eapply eval_sel_binop; eauto. }
+  destruct op; simpl in *; inv PTRBIN.
+  (* psub *)
+  - unfold eval_binop_wrapper in *. simpl in *. destruct Archi.ptr64 eqn:SF; ss.
+    inv BIN. unfold psub_join_cminor. des_ifs. subst. eapply eval_psubl; eauto.
+  (* cmplu *)
+  - unfold eval_binop_wrapper in *. simpl in *. destruct Archi.ptr64 eqn:SF.
+    + esplits; eauto. eapply eval_cmplu_wrapper; eauto.
+    + esplits; eauto. eapply eval_cmplu; eauto.
+Qed.
+
 Lemma eval_sel_select:
   forall le a1 a2 a3 v1 v2 v3 b ty,
   eval_expr tge sp e m le a1 v1 ->
@@ -364,7 +420,8 @@ Proof.
   specialize (eval_condition_of_expr _ _ _ _ H H2). 
   destruct (condition_of_expr a1) as [cond args]; simpl fst; simpl snd. intros (vl & A & B).
   destruct (select ty cond args a2 a3) as [a|] eqn:SEL.
-- eapply eval_select; eauto. 
+- destruct (ptr_cond cond) eqn:PCOND; cycle 1.
+  eapply eval_select; eauto. eapply eval_select_join; eauto.
 - exists (if b then v2 else v3); split.
   econstructor; eauto. eapply eval_condexpr_of_expr; eauto. destruct b; auto.
   apply Val.lessdef_normalize.
@@ -601,8 +658,12 @@ Proof.
   rewrite Int64.unsigned_repr. destruct (zeq (Int64.unsigned n0) n); auto.
   unfold Int64.max_unsigned; lia.
 - intros until n; intros EVAL R RANGE.
-  eapply eval_cmplu; auto. eexact EVAL. apply eval_longconst with (n := Int64.repr n).
-  inv R. unfold Val.cmplu. simpl. f_equal; f_equal. unfold Int64.ltu.
+  eapply eval_cmplu_wrapper; auto. eexact EVAL. apply eval_longconst with (n := Int64.repr n).
+  unfold eval_binop_wrapper. destruct Archi.ptr64 eqn:SF; simpl; rewrite SF.
++ inv R. unfold Val.cmplu. simpl. f_equal; f_equal. unfold Int64.ltu.
+  rewrite Int64.unsigned_repr. destruct (zlt (Int64.unsigned n0) n); auto.
+  unfold Int64.max_unsigned; omega.
++ inv R. unfold Val.cmplu. simpl. f_equal; f_equal. unfold Int64.ltu.
   rewrite Int64.unsigned_repr. destruct (zlt (Int64.unsigned n0) n); auto.
   unfold Int64.max_unsigned; lia.
 - intros until n; intros EVAL R RANGE.
@@ -653,8 +714,8 @@ Proof.
   intros until m'; intros EV LD1 LD2 ME.
   assert (exists v', eval_binop op v1' v2' m = Some v' /\ Val.lessdef v v').
   { inv LD1. inv LD2. exists v; auto.
-    destruct op; destruct v1'; simpl in *; inv EV; TrivialExists.
-    destruct op; simpl in *; inv EV; TrivialExists. }
+    destruct op; destruct v1'; simpl in *; inv EV; des_ifs; TrivialExists.
+    destruct op; simpl in *; inv EV; des_ifs; TrivialExists. }
   assert (CMPU: forall c,
     eval_binop (Ocmpu c) v1 v2 m = Some v ->
     exists v' : val, eval_binop (Ocmpu c) v1' v2' m' = Some v' /\ Val.lessdef v v').
@@ -673,6 +734,49 @@ Proof.
   destruct op; auto.
 Qed.
 
+Lemma eval_binop_wrapper_lessdef op v1 v1' v2 v2' v m m'
+    (EV: eval_binop_wrapper op v1 v2 m = Some v)
+    (LD1: Val.lessdef v1 v1')
+    (LD2: Val.lessdef v2 v2')
+    (ME: Mem.extends m m') :
+  exists v', <<EV': eval_binop_wrapper op v1' v2' m' = Some v'>> /\ <<LD': Val.lessdef v v'>>.
+Proof.
+  assert (VLD: forall b ofs, Mem.valid_pointer m b ofs = true -> Mem.valid_pointer m' b ofs = true).
+  { ii. eapply Mem.valid_pointer_extends; eauto. }
+  destruct (Cminor.ptr_binop op) eqn: PTRBIN; cycle 1.
+  { rewrite eval_binop_no_ptr_binop in *; eauto. eapply eval_binop_lessdef; eauto. }
+  destruct op; simpl in PTRBIN; destruct Archi.ptr64 eqn:SF; inv PTRBIN; try by ss.
+  - unfold eval_binop_wrapper in *; ss.
+    unfold psub_join_cminor, psubl_join_common in *. simpl in *. rewrite SF in *. simpl in *.
+    destruct v1; destruct v2; (try by (ss; des_ifs; esplits; eauto)).
+    + inv LD1; inv LD2; inv EV. esplits; eauto.
+    + exploit psubl_join_lessdef. eapply LD1. eapply LD2. eauto. eauto. i.
+      inv EV; inv LD1; inv LD2; ss. des. subst. esplits; eauto.
+    + exploit psubl_join_lessdef. eapply LD1. eapply LD2. eauto. eauto. i.
+      inv EV; inv LD1; inv LD2; ss. des. subst. esplits; eauto.
+    + inv LD1; inv LD2; inv EV. esplits; eauto.
+  - unfold eval_binop_wrapper in *. simpl in *. rewrite SF in *. simpl in *.
+    destruct v1; destruct v2; (try by ss); inversion LD1; inversion LD2; subst.
+    + ss. esplits; eauto.
+    + destruct (Int64.eq i Int64.zero) eqn:NULL.
+      * destruct (Val.cmplu_bool (Mem.valid_pointer m) c (Vlong i) (Vptr b i0)) eqn:SRC; try by ss.
+        exploit Val.cmplu_bool_lessdef; try eapply SRC; eauto. i.
+        rewrite H. esplits; eauto.
+      * destruct (cmplu_join m c (Vlong i) (Vptr b i0)) eqn:SRC; ss. inv EV.
+        exploit cmplu_join_lessdef; try eapply SRC; eauto. i. des.
+        esplits; eauto. rewrite H. eauto.
+    + destruct (Int64.eq i0 Int64.zero) eqn:NULL.
+      * destruct (Val.cmplu_bool (Mem.valid_pointer m) c (Vptr b i) (Vlong i0)) eqn:SRC; try by ss.
+        exploit Val.cmplu_bool_lessdef; try eapply SRC; eauto. i.
+        rewrite H. esplits; eauto.
+      * destruct (cmplu_join m c (Vptr b i) (Vlong i0)) eqn:SRC; ss. inv EV.
+        exploit cmplu_join_lessdef; try eapply SRC; eauto. i. des.
+        esplits; eauto. rewrite H. eauto.
+    + destruct (Val.cmplu_bool (Mem.valid_pointer m) c (Vptr b i) (Vptr b0 i0)) eqn:SRC; try by ss.
+      exploit Val.cmplu_bool_lessdef; try eapply SRC; eauto. i.
+      rewrite H. esplits; eauto.
+Qed.
+
 (** * Semantic preservation for instruction selection. *)
 
 (** Relationship between the local environments. *)
@@ -750,9 +854,9 @@ Proof.
   (* Ebinop *)
   exploit IHeval_expr1; eauto. intros [v1' [A B]].
   exploit IHeval_expr2; eauto. intros [v2' [C D]].
-  exploit eval_binop_lessdef; eauto. intros [v' [E F]].
-  assert (G: exists v'', eval_expr tge sp e' m' le (sel_binop op (sel_expr a1) (sel_expr a2)) v'' /\ Val.lessdef v' v'')
-  by (eapply eval_sel_binop; eauto).
+  exploit eval_binop_wrapper_lessdef; eauto. intros [v' [E F]].
+  assert (G: exists v'', eval_expr tge sp e' m' le (sel_binop op (sel_expr a1) (sel_expr a2)) v'' /\ Val.lessdef v' v'').
+  { eapply eval_sel_binop_wrapper; eauto. }
   destruct G as [v'' [P Q]].
   exists v''; split; eauto. eapply Val.lessdef_trans; eauto.
   (* Eload *)
@@ -792,6 +896,13 @@ Proof.
   exploit sel_expr_correct. eexact H2. eauto. eauto. intros (v2' & EV2 & LD2).
   assert (Val.bool_of_val vcond' b) by (inv H3; inv LDC; constructor).
   exploit eval_condition_of_expr. eexact EVC. eauto. rewrite C. intros (vargs' & EVARGS & EVCOND).
+  simpl in EVCOND. destruct (ptr_cond cnd) eqn:PCOND.
+  { exploit eval_select_join.
+    eauto.
+    eauto. eauto. eapply EV1. eapply EV2. eauto. intros (v' & X & Y).
+    exists v'; split; eauto. 
+    eapply Val.lessdef_trans; [|eexact Y].
+    apply Val.select_lessdef; auto. }
   exploit eval_select; eauto. intros (v' & X & Y). 
   exists v'; split; eauto. 
   eapply Val.lessdef_trans; [|eexact Y].
@@ -842,12 +953,12 @@ Proof.
 Qed.
 
 Lemma sel_builtin_default_correct:
-  forall optid ef al sp e1 m1 vl t v m2 e1' m1' f k,
+  forall optid ef al sp e1 m1 vl t v m2 e1' m1' f k (INTERN: ~ is_external_ef ef),
   Cminor.eval_exprlist ge sp e1 m1 al vl ->
   external_call ef ge vl m1 t v m2 ->
   env_lessdef e1 e1' -> Mem.extends m1 m1' ->
   exists e2' m2',
-     plus step tge (State f (sel_builtin_default optid ef al) k sp e1' m1')
+     DPlus tsem (State f (sel_builtin_default optid ef al) k sp e1' m1')
                  t (State f Sskip k sp e2' m2')
   /\ env_lessdef (set_optvar optid v e1) e2'
   /\ Mem.extends m2 m2'.
@@ -857,17 +968,52 @@ Proof.
   exploit external_call_mem_extends; eauto. intros (v' & m2' & D & E & F & _).
   econstructor; exists m2'; split.
   apply plus_one.
+  DStep_tac.
   econstructor. eexact A. eapply external_call_symbols_preserved. eexact senv_preserved. eexact D.
   split; auto. apply sel_builtin_res_correct; auto.
 Qed. 
 
+Lemma sel_builtin_default_progress:
+  forall optid ef al sp e1 m1 vl t v m2 e1' m1' f k (EXTERN: is_external_ef ef),
+  Cminor.eval_exprlist ge sp e1 m1 al vl ->
+  external_call ef ge vl m1 t v m2 ->
+  env_lessdef e1 e1' -> Mem.extends m1 m1' ->
+  exists t' s',
+     Step tsem (State f (sel_builtin_default optid ef al) k sp e1' m1') t' s'.
+Proof.
+  intros. unfold sel_builtin_default.
+  exploit sel_builtin_args_correct; eauto. intros (vl' & A & B).
+  exploit external_call_mem_extends_backward_progress; eauto. i. des.
+  esplits. econs; eauto. eapply external_call_symbols_preserved. eexact senv_preserved. eauto.
+Qed.
+
+Lemma sel_builtin_progress:
+  forall optid ef al sp e1 m1 vl t v m2 e1' m1' f k (EXTERN: is_external_ef ef),
+  Cminor.eval_exprlist ge sp e1 m1 al vl ->
+  external_call ef ge vl m1 t v m2 ->
+  env_lessdef e1 e1' -> Mem.extends m1 m1' ->
+  exists t' s',
+     Step tsem (State f (sel_builtin optid ef al) k sp e1' m1') t' s'.
+Proof.
+  intros. exploit sel_exprlist_correct; eauto. intros (vl' & A & B).
+  exploit external_call_mem_extends_backward_progress; eauto. i. des.
+  unfold sel_builtin.
+  destruct optid as [id|]; eauto using sel_builtin_default_correct.
+  destruct ef; eauto using sel_builtin_default_progress.
+  ss. red in CALLTGT. des_ifs.
+  exploit sel_builtin_default_progress; eauto; ss; des_ifs. eapply H0.
+  exploit sel_builtin_default_progress; eauto; ss. i.
+  unfold is_external_ef in EXTERN. des_ifs; eauto.
+  Unshelve. eauto.
+Qed.
+
 Lemma sel_builtin_correct:
-  forall optid ef al sp e1 m1 vl t v m2 e1' m1' f k,
+  forall optid ef al sp e1 m1 vl t v m2 e1' m1' f k (INTERN: ~ is_external_ef ef),
   Cminor.eval_exprlist ge sp e1 m1 al vl ->
   external_call ef ge vl m1 t v m2 ->
   env_lessdef e1 e1' -> Mem.extends m1 m1' ->
   exists e2' m2',
-     plus step tge (State f (sel_builtin optid ef al) k sp e1' m1')
+     DPlus tsem (State f (sel_builtin optid ef al) k sp e1' m1')
                  t (State f Sskip k sp e2' m2')
   /\ env_lessdef (set_optvar optid v e1) e2'
   /\ Mem.extends m2 m2'.
@@ -883,26 +1029,28 @@ Proof.
 - destruct (sel_known_builtin bf (sel_exprlist al)) as [a|] eqn:SKB; eauto using sel_builtin_default_correct.
   exploit eval_sel_known_builtin; eauto. intros (v'' & U & V).
   econstructor; exists m2'; split.
-  apply plus_one. econstructor. eexact U.
+  apply plus_one. DStep_tac. econstructor. eexact U.
   split; auto. apply set_var_lessdef; auto. apply Val.lessdef_trans with v'; auto.
 - exists e1', m2'; split.
-  eapply plus_two. constructor. constructor. auto.
+  eapply plus_two. DStep_tac. constructor. DStep_tac. constructor. auto.
   simpl; auto.  
 Qed.
 
 (** If-conversion *)
 
+Ltac Itac := econstructor; unfold is_internal; simpl; eauto.
+
 Lemma classify_stmt_sound_1:
   forall f sp e m s k,
   classify_stmt s = SCskip ->
-  star Cminor.step ge (Cminor.State f s k sp e m) E0 (Cminor.State f Cminor.Sskip k sp e m).
+  IStar sem (Cminor.State f s k sp e m) E0 (Cminor.State f Cminor.Sskip k sp e m).
 Proof.
   intros until s; functional induction (classify_stmt s); intros; try discriminate.
   - apply star_refl.
-  - eapply star_trans; eauto. eapply star_two. constructor. constructor.
-    traceEq. traceEq.
-  - eapply star_left. constructor.
-    eapply star_right. eauto. constructor.
+  - eapply star_trans; eauto. eapply star_two. Itac. constructor. Itac. constructor.
+    traceEq. eapply IHs0; eauto. traceEq.
+  - eapply star_left. Itac. constructor.
+    eapply star_right. eapply IHs0; eauto. Itac. constructor.
     traceEq. traceEq.
 Qed.
 
@@ -911,14 +1059,14 @@ Lemma classify_stmt_sound_2:
   Cminor.eval_expr ge sp e m a v ->
   forall s k,
   classify_stmt s = SCassign id a ->
-  star Cminor.step ge (Cminor.State f s k sp e m) E0 (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m).
+  IStar sem (Cminor.State f s k sp e m) E0 (Cminor.State f Cminor.Sskip k sp (PTree.set id v e) m).
 Proof.
   intros until s; functional induction (classify_stmt s); intros; try discriminate.
-  - inv H0. apply star_one. constructor; auto.
-  - eapply star_trans; eauto. eapply star_two. constructor. constructor.
-    traceEq. traceEq.
-  - eapply star_left. constructor.
-    eapply star_right. eauto. constructor.
+  - inv H0. apply star_one. Itac. constructor; auto.
+  - eapply star_trans; eauto. eapply star_two. Itac. constructor. Itac. constructor.
+    traceEq. eapply IHs0; eauto. traceEq.
+  - eapply star_left. Itac. constructor.
+    eapply star_right. eapply IHs0; eauto. Itac. constructor.
     traceEq. traceEq.
 Qed.
 
@@ -976,8 +1124,8 @@ Lemma if_conversion_correct:
   env_lessdef e e' -> Mem.extends m m' ->
   let s0 := if b then ifso else ifnot in
   exists e1 e1',
-     step tge (State f' s k' sp e' m') E0 (State f' Sskip k' sp e1' m')
-  /\ star Cminor.step ge (Cminor.State f s0 k sp e m) E0 (Cminor.State f Cminor.Sskip k sp e1 m)
+     DStep tsem (State f' s k' sp e' m') E0 (State f' Sskip k' sp e1' m')
+  /\ IStar sem (Cminor.State f s0 k sp e m) E0 (Cminor.State f Cminor.Sskip k sp e1 m)
   /\ env_lessdef e1 e1'.
 Proof.
   unfold if_conversion; intros until m'; intros IFC DE WTE WT1 WT2 EVC BOV ELD MEXT.
@@ -992,7 +1140,7 @@ Proof.
   constructor. eapply classify_stmt_wt; eauto.
   intros (a' & v1 & v2 & v' & A & B & C & D & E).
   exists (PTree.set id (if b then v1 else v2) e), (PTree.set id v' e').
-  split. subst s. constructor; auto.
+  split. subst s. DStep_tac. constructor; auto.
   split. unfold s0; destruct b. 
   rewrite PTree.gsident by (inv B; auto). apply classify_stmt_sound_1; auto.
   eapply classify_stmt_sound_2; eauto.
@@ -1004,7 +1152,7 @@ Proof.
   eapply classify_stmt_wt; eauto. constructor. 
   intros (a' & v1 & v2 & v' & A & B & C & D & E).
   exists (PTree.set id (if b then v1 else v2) e), (PTree.set id v' e').
-  split. subst s. constructor; auto.
+  split. subst s. DStep_tac. constructor; auto.
   split. unfold s0; destruct b. 
   eapply classify_stmt_sound_2; eauto.
   rewrite PTree.gsident by (inv C; auto). apply classify_stmt_sound_1; auto.
@@ -1017,7 +1165,7 @@ Proof.
   eapply classify_stmt_wt; eauto. eapply classify_stmt_wt; eauto.
   intros (a' & v1 & v2 & v' & A & B & C & D & E).
   exists (PTree.set id (if b then v1 else v2) e), (PTree.set id v' e').
-  split. subst s. constructor; auto.
+  split. subst s. DStep_tac. constructor; auto.
   split. unfold s0; destruct b; eapply classify_stmt_sound_2; eauto.
   apply set_var_lessdef; auto.
 Qed.
@@ -1240,29 +1388,30 @@ Definition measure (s: Cminor.state) : nat :=
   end.
 
 Lemma sel_step_correct:
-  forall S1 t S2, Cminor.step ge S1 t S2 ->
+  forall S1 t S2, IStep sem S1 t S2 ->
   forall T1, match_states S1 T1 -> wt_state S1 ->
-  (exists T2, plus step tge T1 t T2 /\ match_states S2 T2)
+  (exists T2, DPlus tsem T1 t T2 /\ match_states S2 T2)
   \/ (measure S2 < measure S1 /\ t = E0 /\ match_states S2 T1)%nat
-  \/ (exists S3 T2, star Cminor.step ge S2 E0 S3 /\ step tge T1 t T2 /\ match_states S3 T2).
+  \/ (exists S3 T2, IStar sem S2 E0 S3 /\ DStep tsem T1 t T2 /\ match_states S3 T2).
 Proof.
+  destruct 1. generalize dependent S2. rename H into INT.
   induction 1; intros T1 ME WTS; inv ME; try (monadInv TS).
 - (* skip seq *)
-  inv MC. left; econstructor; split. apply plus_one; econstructor. econstructor; eauto.
+  inv MC. left; econstructor; split. apply plus_one; DStep_tac; econstructor. econstructor; eauto.
   inv H.
 - (* skip block *)
-  inv MC. left; econstructor; split. apply plus_one; econstructor. econstructor; eauto.
+  inv MC. left; econstructor; split. apply plus_one; DStep_tac; econstructor. econstructor; eauto.
   inv H.
 - (* skip call *)
   exploit Mem.free_parallel_extends; eauto. intros [m2' [A B]].
   left; econstructor; split.
-  apply plus_one; econstructor. eapply match_is_call_cont; eauto.
+  apply plus_one; DStep_tac; econstructor. eapply match_is_call_cont; eauto.
   erewrite stackspace_function_translated; eauto.
   econstructor; eauto. eapply match_is_call_cont; eauto.
 - (* assign *)
   exploit sel_expr_correct; eauto. intros [v' [A B]].
   left; econstructor; split.
-  apply plus_one; econstructor; eauto.
+  apply plus_one; DStep_tac; econstructor; eauto.
   econstructor; eauto. apply set_var_lessdef; auto.
 - (* store *)
   exploit sel_expr_correct. try apply LINK. try apply HF. eexact H. eauto. eauto. intros [vaddr' [A B]].
@@ -1279,7 +1428,7 @@ Proof.
   exploit sel_exprlist_correct; eauto. intros [vargs' [C D]].
   exploit functions_translated; eauto. intros (cunit' & fd' & U & V & W).
   left; econstructor; split.
-  apply plus_one; econstructor; eauto. econstructor; eauto.
+  apply plus_one; DStep_tac; econstructor; eauto. econstructor; eauto.
   eapply sig_function_translated; eauto.
   eapply match_callstate with (cunit := cunit'); eauto.
   eapply match_cont_call with (cunit := cunit) (hf := hf); eauto.
@@ -1288,7 +1437,7 @@ Proof.
   exploit sel_exprlist_correct; eauto. intros [vargs' [C D]].
   exploit functions_translated; eauto. intros (cunit' & fd' & X & Y & Z).
   left; econstructor; split.
-  apply plus_one; econstructor; eauto.
+  apply plus_one; DStep_tac; econstructor; eauto.
   subst vf. econstructor; eauto. rewrite symbols_preserved; eauto.
   eapply sig_function_translated; eauto.
   eapply match_callstate with (cunit := cunit'); eauto.
@@ -1303,7 +1452,7 @@ Proof.
   exploit sel_exprlist_correct; eauto. intros [vargs' [C D]].
   exploit functions_translated; eauto. intros (cunit' & fd' & E & F & G).
   left; econstructor; split.
-  apply plus_one.
+  apply plus_one. DStep_tac. des_ifs.
   exploit classify_call_correct. eexact LINK. eauto. eauto.
   destruct (classify_call (prog_defmap cunit)) as [ | id | ef]; intros.
   econstructor; eauto. econstructor; eauto. eapply sig_function_translated; eauto.
@@ -1313,11 +1462,12 @@ Proof.
   eapply match_callstate with (cunit := cunit'); eauto.
   eapply call_cont_commut; eauto.
 - (* Sbuiltin *)
+  unfold is_internal in *. simpl in INT.
   exploit sel_builtin_correct; eauto. intros (e2' & m2' & P & Q & R).
   left; econstructor; split. eexact P. econstructor; eauto.
 - (* Seq *)
   left; econstructor; split.
-  apply plus_one; constructor.
+  apply plus_one; DStep_tac; constructor.
   econstructor; eauto. constructor; auto.
 - (* Sifthenelse *)
   simpl in TS. destruct (if_conversion (known_id f) env a s1 s2) as [s|] eqn:IFC; monadInv TS.
@@ -1329,21 +1479,21 @@ Proof.
 + exploit sel_expr_correct; eauto. intros [v' [A B]].
   assert (Val.bool_of_val v' b). inv B. auto. inv H0.
   left; exists (State f' (if b then x else x0) k' sp e' m'); split.
-  apply plus_one; econstructor; eauto. eapply eval_condexpr_of_expr; eauto.
+  apply plus_one; DStep_tac; econstructor; eauto. eapply eval_condexpr_of_expr; eauto.
   econstructor; eauto. destruct b; auto.
 - (* Sloop *)
-  left; econstructor; split. apply plus_one; constructor. econstructor; eauto.
+  left; econstructor; split. apply plus_one; DStep_tac; constructor. econstructor; eauto.
   constructor; auto. simpl; rewrite EQ; auto.
 - (* Sblock *)
-  left; econstructor; split. apply plus_one; constructor. econstructor; eauto. constructor; auto.
+  left; econstructor; split. apply plus_one; DStep_tac; constructor. econstructor; eauto. constructor; auto.
 - (* Sexit seq *)
-  inv MC. left; econstructor; split. apply plus_one; constructor. econstructor; eauto.
+  inv MC. left; econstructor; split. apply plus_one; DStep_tac; constructor. econstructor; eauto.
   inv H.
 - (* Sexit0 block *)
-  inv MC. left; econstructor; split. apply plus_one; constructor. econstructor; eauto.
+  inv MC. left; econstructor; split. apply plus_one; DStep_tac; constructor. econstructor; eauto.
   inv H.
 - (* SexitS block *)
-  inv MC. left; econstructor; split. apply plus_one; constructor. econstructor; eauto.
+  inv MC. left; econstructor; split. apply plus_one; DStep_tac; constructor. econstructor; eauto.
   inv H.
 - (* Sswitch *)
   inv H0; simpl in TS.
@@ -1351,29 +1501,29 @@ Proof.
   destruct (validate_switch Int.modulus default cases ct) eqn:VALID; inv TS.
   exploit sel_expr_correct; eauto. intros [v' [A B]]. inv B.
   left; econstructor; split.
-  apply plus_one; econstructor. eapply sel_switch_int_correct; eauto.
+  apply plus_one; DStep_tac; econstructor. eapply sel_switch_int_correct; eauto.
   econstructor; eauto.
 + set (ct := compile_switch Int64.modulus default cases) in *.
   destruct (validate_switch Int64.modulus default cases ct) eqn:VALID; inv TS.
   exploit sel_expr_correct; eauto. intros [v' [A B]]. inv B.
   left; econstructor; split.
-  apply plus_one; econstructor. eapply sel_switch_long_correct; eauto.
+  apply plus_one; DStep_tac; econstructor. eapply sel_switch_long_correct; eauto.
   econstructor; eauto.
 - (* Sreturn None *)
   exploit Mem.free_parallel_extends; eauto. intros [m2' [P Q]].
   erewrite <- stackspace_function_translated in P by eauto.
   left; econstructor; split.
-  apply plus_one; econstructor. simpl; eauto.
+  apply plus_one; DStep_tac; econstructor. simpl; eauto.
   econstructor; eauto. eapply call_cont_commut; eauto.
 - (* Sreturn Some *)
   exploit Mem.free_parallel_extends; eauto. intros [m2' [P Q]].
   erewrite <- stackspace_function_translated in P by eauto.
   exploit sel_expr_correct; eauto. intros [v' [A B]].
   left; econstructor; split.
-  apply plus_one; econstructor; eauto.
+  apply plus_one; DStep_tac; econstructor; eauto.
   econstructor; eauto. eapply call_cont_commut; eauto.
 - (* Slabel *)
-  left; econstructor; split. apply plus_one; constructor. econstructor; eauto.
+  left; econstructor; split. apply plus_one; DStep_tac; constructor. econstructor; eauto.
 - (* Sgoto *)
   assert (sel_stmt (prog_defmap cunit) (known_id f) env (Cminor.fn_body f) = OK (fn_body f')).
   { monadInv TF; simpl. congruence. }
@@ -1384,7 +1534,7 @@ Proof.
   as [[s'' k'']|] eqn:?; intros; try contradiction.
   destruct H1.
   left; econstructor; split.
-  apply plus_one; econstructor; eauto.
+  apply plus_one; DStep_tac; econstructor; eauto.
   econstructor; eauto.
 - (* internal function *)
   destruct TF as (hf & HF & TF). 
@@ -1392,33 +1542,240 @@ Proof.
   exploit Mem.alloc_extends. eauto. eauto. apply Z.le_refl. apply Z.le_refl.
   intros [m2' [A B]].
   left; econstructor; split.
-  apply plus_one; econstructor; simpl; eauto.
+  apply plus_one; DStep_tac; econstructor; simpl; eauto.
   econstructor; simpl; eauto.
   apply match_cont_other; auto.
   apply set_locals_lessdef. apply set_params_lessdef; auto.
 - (* external call *)
+  unfold is_internal in *. simpl in INT.
   destruct TF as (hf & HF & TF).
   monadInv TF.
   exploit external_call_mem_extends; eauto.
   intros [vres' [m2 [A [B [C D]]]]].
   left; econstructor; split.
-  apply plus_one; econstructor. eapply external_call_symbols_preserved; eauto. apply senv_preserved.
+  apply plus_one; DStep_tac; econstructor. eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   econstructor; eauto.
 - (* external call turned into a Sbuiltin *)
+  unfold is_internal in *. simpl in INT.
   exploit sel_builtin_correct; eauto. intros (e2' & m2' & P & Q & R).
   left; econstructor; split. eexact P. econstructor; eauto.
 - (* return *)
   inv MC.
   left; econstructor; split.
-  apply plus_one; econstructor.
+  apply plus_one; DStep_tac; econstructor.
   econstructor; eauto. destruct optid; simpl; auto. apply set_var_lessdef; auto.
 - (* return of an external call turned into a Sbuiltin *)
   right; left; split. simpl; lia. split. auto. econstructor; eauto.
 Qed.
 
+Lemma match_states_bsim
+      s1 (EXT: Cminor.is_external ge s1)
+      s2 t s2'
+      (STEPTGT: Step tsem s2 t s2')
+      (MATCH: match_states s1 s2)
+      (SAFESRC: safe sem s1) :
+    (exists s1', Step sem s1 t s1' /\ match_states s1' s2')
+    \/ (~ trace_intact t /\ exists s1'' t', Star sem s1 t' s1'' /\ exists tl, t' = (trace_cut_pterm t) ** tl).
+Proof.
+  assert (SEQUIV: Senv.equiv tge ge) by (symmetry; apply senv_preserved).
+  unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+  { inv SAFESRC. inv MATCH. inv MC. inv STEPTGT. }
+  unfold Cminor.is_external in *. des_ifs.
+  (* builtin *)
+  - inversion MATCH; clarify. monadInv TS. inv SAFESRC.
+    unfold sel_builtin in STEPTGT. des_ifs; unfold sel_builtin_default in *.
+    { inv STEPTGT. exploit sel_builtin_args_correct; eauto. i. des.
+      exploit CminorSelD.eval_builtin_args_determ. eapply H11. eapply H. i. subst.
+      exploit external_call_mem_extends_backward; eauto. i. des.
+      - left. esplits; eauto.
+        econs; eauto. eapply external_call_symbols_preserved; eauto.
+        econs; eauto. ss. eapply sel_builtin_res_correct; eauto.
+      - exploit UBSRC; eauto.
+        eapply external_call_symbols_preserved; eauto. eapply senv_preserved. clarify.
+      - right. esplits; eauto. eapply star_one. econs; eauto.
+        eapply external_call_symbols_preserved; eauto. }
+    { ss. des_ifs. }
+    { ss. des_ifs. }
+    { ss. des_ifs. }
+    { inv STEPTGT. exploit sel_builtin_args_correct; eauto. i. des.
+      exploit CminorSelD.eval_builtin_args_determ. eapply H11. eapply H. i. subst.
+      exploit external_call_mem_extends_backward; eauto. i. des.
+      - left. esplits; eauto.
+        econs; eauto. eapply external_call_symbols_preserved; eauto.
+        econs; eauto. ss. eapply sel_builtin_res_correct; eauto.
+      - exploit UBSRC; eauto.
+        eapply external_call_symbols_preserved; eauto. eapply senv_preserved. clarify.
+      - right. esplits; eauto. eapply star_one. econs; eauto.
+        eapply external_call_symbols_preserved; eauto. }
+    { inv STEPTGT. exploit sel_builtin_args_correct; eauto. i. des.
+      exploit CminorSelD.eval_builtin_args_determ. eapply H11. eapply H. i. subst.
+      exploit external_call_mem_extends_backward; eauto. i. des.
+      - left. esplits; eauto.
+        econs; eauto. eapply external_call_symbols_preserved; eauto.
+        econs; eauto. ss. eapply sel_builtin_res_correct; eauto.
+      - exploit UBSRC; eauto.
+        eapply external_call_symbols_preserved; eauto. eapply senv_preserved. clarify.
+      - right. esplits; eauto. eapply star_one. econs; eauto.
+        eapply external_call_symbols_preserved; eauto. }
+    { inv STEPTGT. exploit sel_builtin_args_correct; eauto. i. des.
+      exploit CminorSelD.eval_builtin_args_determ. eapply H11. eapply H. i. subst.
+      exploit external_call_mem_extends_backward; eauto. i. des.
+      - left. esplits; eauto.
+        econs; eauto. eapply external_call_symbols_preserved; eauto.
+        econs; eauto. ss. eapply sel_builtin_res_correct; eauto.
+      - exploit UBSRC; eauto.
+        eapply external_call_symbols_preserved; eauto. eapply senv_preserved. clarify.
+      - right. esplits; eauto. eapply star_one. econs; eauto.
+        eapply external_call_symbols_preserved; eauto. }
+    { inv STEPTGT. exploit sel_builtin_args_correct; eauto. i. des.
+      exploit CminorSelD.eval_builtin_args_determ. eapply H11. eapply H. i. subst.
+      exploit external_call_mem_extends_backward; eauto. i. des.
+      - left. esplits; eauto.
+        econs; eauto. eapply external_call_symbols_preserved; eauto.
+        econs; eauto. ss. eapply sel_builtin_res_correct; eauto.
+      - exploit UBSRC; eauto.
+        eapply external_call_symbols_preserved; eauto. eapply senv_preserved. clarify.
+      - right. esplits; eauto. eapply star_one. econs; eauto.
+        eapply external_call_symbols_preserved; eauto. }
+    { inv STEPTGT. exploit sel_builtin_args_correct; eauto. i. des.
+      exploit CminorSelD.eval_builtin_args_determ. eapply H11. eapply H. i. subst.
+      exploit external_call_mem_extends_backward; eauto. i. des.
+      - left. esplits; eauto.
+        econs; eauto. eapply external_call_symbols_preserved; eauto.
+        econs; eauto. ss. eapply sel_builtin_res_correct; eauto.
+      - exploit UBSRC; eauto.
+        eapply external_call_symbols_preserved; eauto. eapply senv_preserved. clarify.
+      - right. esplits; eauto.
+        eapply star_one. econs; eauto.
+        eapply external_call_symbols_preserved; eauto. }
+  (* external call *)
+  - inversion MATCH; clarify.
+    { inv STEPTGT; ss; inv TF; des; clarify. inv SAFESRC; ss; clarify; try (by (des; clarify)).
+      exploit external_call_mem_extends_backward.
+      2:{ eapply external_call_symbols_preserved; eauto. }
+      all: eauto. i. des.
+      + left. esplits; eauto.
+        eapply Cminor.step_external_function; eauto.
+        econstructor; eauto.
+      + exploit UBSRC; eauto. clarify.
+      + des. right. esplits; eauto. eapply star_one. eapply Cminor.step_external_function; eauto. }
+    { unfold sel_builtin in STEPTGT. des_ifs; unfold sel_builtin_default in *.
+      - inv SAFESRC. exploit sel_builtin_args_correct; eauto. i. des.
+        inv STEPTGT. exploit CminorSelD.eval_builtin_args_determ. eapply H12. eapply H. i. subst.
+        exploit external_call_mem_extends_backward; eauto. i. des.
+        + left. esplits; eauto.
+          econs; eauto. eapply external_call_symbols_preserved; eauto.
+          econs; eauto. ss. eapply sel_builtin_res_correct; eauto.
+        + exploit UBSRC; eauto.
+          eapply external_call_symbols_preserved; eauto. eapply senv_preserved. clarify.
+        + right. esplits; eauto. eapply star_one. econs; eauto.
+          eapply external_call_symbols_preserved; eauto.
+      - ss. des_ifs.
+      - ss. des_ifs.
+      - ss. des_ifs.
+      - inv SAFESRC. exploit sel_builtin_args_correct; eauto. i. des.
+        inv STEPTGT.
+        exploit CminorSelD.eval_builtin_args_determ. eapply H12. eapply H. i. subst.
+        exploit external_call_mem_extends_backward; eauto. i. des.
+        + left. esplits; eauto.
+          econs; eauto. eapply external_call_symbols_preserved; eauto.
+          econs; eauto. ss. eapply sel_builtin_res_correct; eauto.
+        + exploit UBSRC; eauto.
+          eapply external_call_symbols_preserved; eauto. eapply senv_preserved. clarify.
+        + right. esplits; eauto. eapply star_one. econs; eauto.
+          eapply external_call_symbols_preserved; eauto.
+      - inv SAFESRC. exploit sel_builtin_args_correct; eauto. i. des.
+        inv STEPTGT. exploit CminorSelD.eval_builtin_args_determ. eapply H12. eapply H. i. subst.
+        exploit external_call_mem_extends_backward; eauto. i. des.
+        + left. esplits; eauto.
+          econs; eauto. eapply external_call_symbols_preserved; eauto.
+          econs; eauto. ss. eapply sel_builtin_res_correct; eauto.
+        + exploit UBSRC; eauto.
+          eapply external_call_symbols_preserved; eauto. eapply senv_preserved. clarify.
+        + right. esplits; eauto. eapply star_one. econs; eauto.
+          eapply external_call_symbols_preserved; eauto.
+      - inv SAFESRC. exploit sel_builtin_args_correct; eauto. i. des.
+        inv STEPTGT. exploit CminorSelD.eval_builtin_args_determ. eapply H12. eapply H. i. subst.
+        exploit external_call_mem_extends_backward; eauto. i. des.
+        + left. esplits; eauto.
+          econs; eauto. eapply external_call_symbols_preserved; eauto.
+          econs; eauto. ss. eapply sel_builtin_res_correct; eauto.
+        + exploit UBSRC; eauto.
+          eapply external_call_symbols_preserved; eauto. eapply senv_preserved. clarify.
+        + right. esplits; eauto. eapply star_one. econs; eauto.
+          eapply external_call_symbols_preserved; eauto.
+      - inv SAFESRC. exploit sel_builtin_args_correct; eauto. i. des.
+        inv STEPTGT. exploit CminorSelD.eval_builtin_args_determ. eapply H12. eapply H. i. subst.
+        exploit external_call_mem_extends_backward; eauto. i. des.
+        + left. esplits; eauto.
+          econs; eauto. eapply external_call_symbols_preserved; eauto.
+          econs; eauto. ss. eapply sel_builtin_res_correct; eauto.
+        + exploit UBSRC; eauto.
+          eapply external_call_symbols_preserved; eauto. eapply senv_preserved. clarify.
+        + right. esplits; eauto.
+          eapply star_one. econs; eauto.
+          eapply external_call_symbols_preserved; eauto.
+      - inv SAFESRC. exploit sel_builtin_args_correct; eauto. i. des.
+        inv STEPTGT. exploit CminorSelD.eval_builtin_args_determ. eapply H12. eapply H. i. subst.
+        exploit external_call_mem_extends_backward; eauto. i. des.
+        + left. esplits; eauto.
+          econs; eauto. eapply external_call_symbols_preserved; eauto.
+          econs; eauto. ss. eapply sel_builtin_res_correct; eauto.
+        + exploit UBSRC; eauto.
+          eapply external_call_symbols_preserved; eauto. eapply senv_preserved. clarify.
+        + right. esplits; eauto. eapply star_one. econs; eauto.
+          eapply external_call_symbols_preserved; eauto. }
+Qed.
+
+Lemma istar_star: forall (L: Smallstep.semantics) s t s', IStar L s t s' -> Star L s t s'.
+Proof. intros L s t s' H. induction H; econstructor; eauto. destruct H. auto. Qed.
+
+Lemma match_states_xsim st_src0 st_tgt0 gmtgt
+    (MATCH: match_states st_src0 st_tgt0)
+    (WT: wt_state st_src0) :
+  xsim (Cminor.semantics prog) (CminorSel.semantics tprog) gmtgt lt (measure st_src0)%nat st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold. destruct (classic (Cminor.is_external ge st_src0)); cycle 1.
+  (* not external *)
+  - left. econs. econs.
+    + i. exploit sel_step_correct; eauto.
+      intros [(T2 & D & E) | [(D & E & F) | (S3 & T2 & D & E & F)]].
+      { esplits;[eapply tr_rel_refl; eapply ev_rel_refl| |].
+        - left. esplits; eauto. eapply Cminor.semantics_receptive. ss.
+        - right. eapply CIH; eauto. ss. eapply subject_reduction; eauto. eapply wt_prog. }
+      { esplits;[eapply tr_rel_refl; eapply ev_rel_refl| |].
+        - right. esplits; eauto.
+        - right. eapply CIH; eauto. ss. eapply subject_reduction; eauto. eapply wt_prog. }
+      { esplits;[eapply tr_rel_refl; eapply ev_rel_refl| |].
+        - left. split. eapply plus_one; eauto. eapply Cminor.semantics_receptive. ss.
+        - left. ss. pfold. right. econs. i. econs 2; eauto.
+          eapply istar_star; eauto. eauto.
+          right. eapply CIH; eauto. eapply subject_reduction_star; eauto using wt_prog.
+          exploit istar_star; eauto. eauto. ss. i. eapply star_left; eauto. }
+    + ii. eapply final_state_determ; eauto. inv FINALSRC. inv MATCH. inv MC. inv LD. econs.
+  - right. econs. i. econs.
+    + i. exploit match_states_bsim; eauto. i. des.
+      * left. esplits; eauto;[eapply tr_rel_refl; eapply ev_rel_refl| |].
+        { left. eapply plus_one. eauto. }
+        right. eapply CIH; eauto. eapply subject_reduction; ss; eauto. eapply wt_prog.
+      * right. esplits; eauto. subst. eapply tr_rel_refl. eapply ev_rel_refl.
+    + ii. unfold Cminor.is_external in *. des_ifs; inv FINALTGT; inv MATCH.
+    (* progress *)
+    + i. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify; [inv SAFESRC; ss|].
+      right. inv SAFESRC; ss; clarify; try (by (des; clarify)); inv MATCH; try (monadInv TS).
+      * exploit sel_builtin_args_correct; eauto. i. des.
+        exploit sel_builtin_progress; eauto.
+      * destruct TF as (hf & HF & TF). monadInv TF.
+        exploit external_call_mem_extends_backward_progress; eauto. i. des.
+        esplits. econs; eauto. eapply external_call_symbols_preserved; eauto. eapply senv_preserved.
+      * exploit sel_builtin_progress; eauto.
+Unshelve. econs.
+Qed.
+
 Lemma sel_initial_states:
   forall S, Cminor.initial_state prog S ->
-  exists R, initial_state tprog R /\ match_states S R.
+  exists R, CminorSel.initial_state tprog R /\ match_states S R.
 Proof.
   destruct 1.
   exploit function_ptr_translated; eauto. intros (cu & f' & A & B & C).
@@ -1433,30 +1790,71 @@ Qed.
 
 Lemma sel_final_states:
   forall S R r,
-  match_states S R -> Cminor.final_state S r -> final_state R r.
+  match_states S R -> Cminor.final_state S r -> CminorSel.final_state R r.
 Proof.
   intros. inv H0. inv H. inv MC. inv LD. constructor.
 Qed.
 
+Lemma non_static_equiv l:
+  Genv.non_static_glob (Genv.globalenv prog) l = Genv.non_static_glob (Genv.globalenv tprog) l.
+Proof.
+  Local Transparent ge tge.
+  induction l; ss.
+  specialize senv_preserved. ss. i. inv H. inv H1.
+  unfold ge, tge, fundef in *.
+  specialize (H a).
+  unfold Senv.public_symbol in H. ss. erewrite H.
+  specialize (H0 a). rewrite <- H0. erewrite IHl; eauto.
+Qed.
+
+Lemma transf_initial_capture S1 S2 S2'
+    (INITSRC: Cminor.initial_state prog S1)
+    (INITTGT: CminorSel.initial_state tprog S2)
+    (MATCH: match_states S1 S2)
+    (CAPTGT: CminorSel.glob_capture tprog S2 S2'):
+  exists S1', Cminor.glob_capture prog S1 S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (Cminor.concrete_snapshot ge S1') (CminorSel.concrete_snapshot tge S2').
+Proof.
+  specialize senv_preserved. intros SENVEQ.
+  inv CAPTGT. ss. rename m' into m2'.
+  rewrite Genv.globalenv_public in CAPTURE. erewrite <- same_public in CAPTURE; eauto.
+  inv MATCH. inv MC. inv LD.
+  exploit non_static_equiv. instantiate (1:=AST.prog_public prog). intros EQUIV.
+  assert (exists m1', Genv.capture_init_mem m0 (Genv.non_static_glob (Genv.globalenv prog) (AST.prog_public prog)) m1' /\
+                     Mem.extends m1' m2').
+  { clear LINK INITSRC INITTGT.
+    rewrite <- EQUIV in CAPTURE. clear EQUIV. inv CAPTURE.
+    remember (Genv.non_static_glob (Genv.globalenv prog) (prog_public prog)) as l. clear Heql.
+    clear TF SENVEQ. move m0 after f. move l before f. revert_until f.
+    induction l; ss; i.
+    { inv CAP. esplits; eauto. econs. econs. }
+    inv CAP. exploit Mem.capture_extends_backward; eauto. i. des.
+    exploit IHl; eauto. i. des. inv H. esplits; eauto. econs. econs; eauto. }
+  des. esplits; eauto.
+  - econs. eauto. rewrite Genv.globalenv_public. eauto.
+  - econs; eauto. econs.
+  - ii. unfold Cminor.concrete_snapshot, concrete_snapshot in *. inv SENVEQ. des. erewrite H3, H2. des_ifs; ss.
+    eapply Mem.mext_concrete; eauto. eapply Mem.concrete_valid; eauto.
+Qed.
+
 Theorem transf_program_correct:
-  forward_simulation (Cminor.semantics prog) (CminorSel.semantics tprog).
-Proof.
-  set (MS := fun S T => match_states S T /\ wt_state S).
-  apply forward_simulation_determ_star with (match_states := MS) (measure := measure).
-- apply Cminor.semantics_determinate.
-- apply senv_preserved.
-- intros. exploit sel_initial_states; eauto. intros (T & P & Q). 
-  exists T; split; auto; split; auto. eapply wt_initial_state. eexact wt_prog. auto. 
-- intros. destruct H. eapply sel_final_states; eauto.
-- intros S1 t S2 A T1 [B C].
-  assert (wt_state S2) by (eapply subject_reduction; eauto using wt_prog).
-  unfold MS.
-  exploit sel_step_correct; eauto.
-  intros [(T2 & D & E) | [(D & E & F) | (S3 & T2 & D & E & F)]].
-+ exists S2, T2. intuition auto using star_refl.
-+ subst t. exists S2, T1. intuition auto using star_refl.
-+ assert (wt_state S3) by (eapply subject_reduction_star; eauto using wt_prog).
-  exists S3, T2. intuition auto using plus_one.
+  mixed_simulation (Cminor.semantics prog) (CminorSel.semantics tprog).
+Proof.
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (S a). lia.
+  - econs. i. exploit sel_initial_states; eauto. i. des.
+    exists R. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. inversion INITSRC; subst. inversion H0; subst.
+      inv MC. inv LD.
+      exploit transf_initial_capture; eauto. i. des.
+      exists (measure S1'). exists S1'. esplits; eauto. apply match_states_xsim; auto.
+      eapply wt_initial_capture_state; ss; eauto. eapply wt_prog.
+  - i. apply senv_preserved.
 Qed.
 
 End PRESERVATION.
diff --git a/backend/SplitLongproof.v b/backend/SplitLongproof.v
index 1e50b1c2..f6709aff 100644
--- a/backend/SplitLongproof.v
+++ b/backend/SplitLongproof.v
@@ -17,6 +17,7 @@ Require Import Coqlib Maps.
 Require Import AST Errors Integers Floats.
 Require Import Values Memory Globalenvs Builtins Events Cminor Op CminorSel.
 Require Import SelectOp SelectOpproof SplitLong.
+Require Import PointerOp.
 
 Local Open Scope cminorsel_scope.
 Local Open Scope string_scope.
@@ -68,7 +69,8 @@ Proof.
   intros.
   red in H0. apply Genv.find_def_symbol in H0. destruct H0 as (b & P & Q).
   rewrite <- Genv.find_funct_ptr_iff in Q.
-  econstructor; eauto. 
+  econstructor; eauto.
+  ss. des_ifs.
   simpl. red. rewrite H1. constructor; auto.
 Qed.
 
@@ -102,7 +104,7 @@ Remark eval_builtin_1:
   builtin_function_sem bf (varg1 :: nil) = Some vres ->
   eval_expr ge sp e m le (Ebuiltin (EF_builtin id sg) (arg1 ::: Enil)) vres.
 Proof.
-  intros. econstructor. econstructor. eauto. constructor.
+  intros. econstructor. ss. des_ifs. econstructor. eauto. constructor.
   simpl. red. rewrite H0. constructor. auto.
 Qed.
 
@@ -114,7 +116,7 @@ Remark eval_builtin_2:
   builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres ->
   eval_expr ge sp e m le (Ebuiltin (EF_builtin id sg) (arg1 ::: arg2 ::: Enil)) vres.
 Proof.
-  intros. econstructor. constructor; eauto. constructor; eauto. constructor.
+  intros. econstructor. ss. des_ifs. constructor; eauto. constructor; eauto. constructor.
   simpl. red. rewrite H1. constructor. auto.
 Qed.
 
@@ -141,6 +143,8 @@ Ltac EvalOp :=
   | _ => idtac
   end.
 
+Ltac no_ptr_tac := rewrite eval_operation_no_ptr_op; ss.
+
 Lemma eval_splitlong:
   forall le a f v sem,
   (forall le a b x y,
@@ -161,7 +165,7 @@ Proof.
   destruct v0; simpl in *; try (rewrite UNDEF; auto).
   erewrite B; eauto.
 - exploit (EXEC (v :: le) (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))).
-  EvalOp. EvalOp.
+  EvalOp. no_ptr_tac. EvalOp. no_ptr_tac.
   intros [v' [A B]].
   exists v'; split. econstructor; eauto.
   destruct v; try (rewrite UNDEF; auto). erewrite B; simpl; eauto. rewrite Int64.ofwords_recompose. auto.
@@ -213,7 +217,7 @@ Proof.
 - InvEval; subst.
   exploit (EXEC (vb :: le) (lift h1) (lift l1)
                 (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))).
-  EvalOp. EvalOp. EvalOp. EvalOp.
+  EvalOp. EvalOp. EvalOp. no_ptr_tac. EvalOp. no_ptr_tac.
   intros [v [A B]].
   exists v; split.
   econstructor; eauto.
@@ -225,7 +229,7 @@ Proof.
   exploit (EXEC (va :: le)
                 (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))
                 (lift h2) (lift l2)).
-  EvalOp. EvalOp. EvalOp. EvalOp.
+  EvalOp. no_ptr_tac. EvalOp. no_ptr_tac. EvalOp. EvalOp.
   intros [v [A B]].
   exists v; split.
   econstructor; eauto.
@@ -236,7 +240,7 @@ Proof.
 - exploit (EXEC (vb :: va :: le)
                 (Eop Ohighlong (Eletvar 1 ::: Enil)) (Eop Olowlong (Eletvar 1 ::: Enil))
                 (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))).
-  EvalOp. EvalOp. EvalOp. EvalOp.
+  EvalOp. no_ptr_tac. EvalOp. no_ptr_tac. EvalOp. no_ptr_tac. EvalOp. no_ptr_tac.
   intros [v [A B]].
   exists v; split. EvalOp.
   destruct va; try (rewrite UNDEF; auto); destruct vb; try (rewrite UNDEF; auto).
@@ -318,7 +322,7 @@ Qed.
 Lemma eval_longconst:
   forall le n, eval_expr ge sp e m le (longconst n) (Vlong n).
 Proof.
-  intros. EvalOp. rewrite Int64.ofwords_recompose; auto.
+  intros. EvalOp; no_ptr_tac. simpl. rewrite Int64.ofwords_recompose; auto.
 Qed.
 
 Theorem eval_intoflong: unary_constructor_sound intoflong Val.loword.
@@ -326,7 +330,7 @@ Proof eval_lowlong.
 
 Theorem eval_longofintu: unary_constructor_sound longofintu Val.longofintu.
 Proof.
-  red; intros. unfold longofintu. econstructor; split. EvalOp.
+  red; intros. unfold longofintu. econstructor; split. EvalOp; no_ptr_tac.
   unfold Val.longofintu. destruct x; auto.
   replace (Int64.repr (Int.unsigned i)) with (Int64.ofwords Int.zero i); auto.
   apply Int64.same_bits_eq; intros.
@@ -345,6 +349,7 @@ Proof.
 - exploit (eval_shrimm ge sp e m (Int.repr 31) (x :: le) (Eletvar 0)). EvalOp.
   intros [v1 [A B]].
   econstructor; split. EvalOp.
+  no_ptr_tac.
   destruct x; simpl; auto.
   simpl in B. inv B. simpl.
   replace (Int64.repr (Int.signed i))
@@ -584,6 +589,7 @@ Proof.
     exploit eval_shruimm. eexact H5. instantiate (1 := Int.sub Int.iwordsize n). intros [v3 [A3 B3]].
     exploit eval_or. eexact A1. eexact A3. intros [v4 [A4 B4]].
     econstructor; split. EvalOp.
+    no_ptr_tac.
     intros. subst. simpl in *. rewrite H1 in *. rewrite H2 in *. rewrite H3.
     inv B1; inv B2; inv B3. simpl in B4. inv B4.
     simpl. rewrite Int64.decompose_shl_1; auto.
@@ -591,7 +597,7 @@ Proof.
   + (* 32 <= n < 64 *)
     exploit eval_lowlong. eexact H. intros [v1 [A1 B1]].
     exploit eval_shlimm. eexact A1. instantiate (1 := Int.sub n Int.iwordsize). intros [v2 [A2 B2]].
-    econstructor; split. EvalOp.
+    econstructor; split. EvalOp; no_ptr_tac.
     destruct x; simpl; auto.
     destruct (Int.ltu n Int64.iwordsize'); auto.
     simpl in B1; inv B1. simpl in B2. rewrite H1 in B2. inv B2.
@@ -599,7 +605,7 @@ Proof.
     rewrite Int64.ofwords_recompose. auto. auto.
   + (* n >= 64 *)
     econstructor; split.
-    eapply eval_helper_2; eauto. EvalOp. DeclHelper. reflexivity. reflexivity.
+    eapply eval_helper_2; eauto. EvalOp. no_ptr_tac. DeclHelper. reflexivity. reflexivity.
     auto.
 Qed.
 
@@ -631,6 +637,7 @@ Proof.
     exploit eval_shlimm. eexact H4. instantiate (1 := Int.sub Int.iwordsize n). intros [v3 [A3 B3]].
     exploit eval_or. eexact A1. eexact A3. intros [v4 [A4 B4]].
     econstructor; split. EvalOp.
+    no_ptr_tac.
     intros. subst. simpl in *. rewrite H1 in *. rewrite H2 in *. rewrite H3.
     inv B1; inv B2; inv B3. simpl in B4. inv B4.
     simpl. rewrite Int64.decompose_shru_1; auto.
@@ -638,7 +645,7 @@ Proof.
   + (* 32 <= n < 64 *)
     exploit eval_highlong. eexact H. intros [v1 [A1 B1]].
     exploit eval_shruimm. eexact A1. instantiate (1 := Int.sub n Int.iwordsize). intros [v2 [A2 B2]].
-    econstructor; split. EvalOp.
+    econstructor; split. EvalOp; no_ptr_tac.
     destruct x; simpl; auto.
     destruct (Int.ltu n Int64.iwordsize'); auto.
     simpl in B1; inv B1. simpl in B2. rewrite H1 in B2. inv B2.
@@ -646,7 +653,7 @@ Proof.
     rewrite Int64.ofwords_recompose. auto. auto.
   + (* n >= 64 *)
     econstructor; split.
-    eapply eval_helper_2; eauto. EvalOp. DeclHelper. reflexivity. reflexivity.
+    eapply eval_helper_2; eauto. EvalOp. no_ptr_tac. DeclHelper. reflexivity. reflexivity.
     auto.
 Qed.
 
@@ -678,6 +685,7 @@ Proof.
     exploit eval_shlimm. eexact H4. instantiate (1 := Int.sub Int.iwordsize n). intros [v3 [A3 B3]].
     exploit eval_or. eexact A1. eexact A3. intros [v4 [A4 B4]].
     econstructor; split. EvalOp.
+    no_ptr_tac.
     intros. subst. simpl in *. rewrite H1 in *. rewrite H2 in *. rewrite H3.
     inv B1; inv B2; inv B3. simpl in B4. inv B4.
     simpl. rewrite Int64.decompose_shr_1; auto.
@@ -688,6 +696,7 @@ Proof.
     exploit eval_shrimm. eexact H2. instantiate (1 := Int.sub n Int.iwordsize). intros [v2 [A2 B2]].
     exploit eval_shrimm. eexact H2. instantiate (1 := Int.repr 31). intros [v3 [A3 B3]].
     econstructor; split. EvalOp.
+    no_ptr_tac.
     destruct x; simpl; auto.
     destruct (Int.ltu n Int64.iwordsize'); auto.
     simpl in B1; inv B1. simpl in B2. rewrite H1 in B2. inv B2.
@@ -697,7 +706,7 @@ Proof.
     rewrite Int64.ofwords_recompose. auto. auto.
   + (* n >= 64 *)
     econstructor; split.
-    eapply eval_helper_2; eauto. EvalOp. DeclHelper. reflexivity. reflexivity.
+    eapply eval_helper_2; eauto. EvalOp. no_ptr_tac. DeclHelper. reflexivity. reflexivity.
     auto.
 Qed.
 
@@ -942,6 +951,7 @@ Proof.
   eapply eval_splitlong_strict; eauto. intros.
   exploit eval_or. eexact H0. eexact H1. intros [v1 [A1 B1]]. simpl in B1; inv B1.
   exploit eval_comp. eexact A1. instantiate (2 := Eop (Ointconst Int.zero) Enil). EvalOp.
+  no_ptr_tac.
   instantiate (1 := Ceq). intros [v2 [A2 B2]].
   unfold Val.cmp in B2; simpl in B2.
   rewrite <- decompose_cmpl_eq_zero in B2.
@@ -958,6 +968,7 @@ Proof.
   eapply eval_splitlong_strict; eauto. intros.
   exploit eval_or. eexact H0. eexact H1. intros [v1 [A1 B1]]. simpl in B1; inv B1.
   exploit eval_comp. eexact A1. instantiate (2 := Eop (Ointconst Int.zero) Enil). EvalOp.
+  no_ptr_tac.
   instantiate (1 := Cne). intros [v2 [A2 B2]].
   unfold Val.cmp in B2; simpl in B2.
   rewrite <- decompose_cmpl_eq_zero in B2.
@@ -1079,6 +1090,7 @@ Proof.
   exploit eval_highlong. eexact H. intros [v1 [A1 B1]]. simpl in B1. inv B1.
   exploit eval_comp. eexact A1.
   instantiate (2 := Eop (Ointconst Int.zero) Enil). EvalOp.
+  no_ptr_tac.
   instantiate (1 := Clt). intros [v2 [A2 B2]].
   unfold Val.cmp in B2. simpl in B2.
   rewrite <- (Int64.ofwords_recompose x). rewrite decompose_cmpl_lt_zero.
@@ -1098,6 +1110,7 @@ Proof.
   exploit eval_highlong. eexact H. intros [v1 [A1 B1]]. simpl in B1; inv B1.
   exploit eval_comp. eexact A1.
   instantiate (2 := Eop (Ointconst Int.zero) Enil). EvalOp.
+  no_ptr_tac.
   instantiate (1 := Cge). intros [v2 [A2 B2]].
   unfold Val.cmp in B2; simpl in B2.
   rewrite <- (Int64.ofwords_recompose x). rewrite decompose_cmpl_lt_zero.
diff --git a/backend/Stackingproof.v b/backend/Stackingproof.v
index 7724c5d6..36fdfbbd 100644
--- a/backend/Stackingproof.v
+++ b/backend/Stackingproof.v
@@ -20,6 +20,8 @@ Require Import Values Memory Separation Events Globalenvs Smallstep.
 Require Import LTL Op Locations Linear Mach.
 Require Import Bounds Conventions Stacklayout Lineartyping.
 Require Import Stacking.
+Require Import Simulation LinearD MachD PointerOp Classical.
+From Paco Require Import paco.
 
 Local Open Scope sep_scope.
 
@@ -76,11 +78,6 @@ Section PRESERVATION.
 
 Variable return_address_offset: Mach.function -> Mach.code -> ptrofs -> Prop.
 
-Hypothesis return_address_offset_exists:
-  forall f sg ros c,
-  is_tail (Mcall sg ros :: c) (fn_code f) ->
-  exists ofs, return_address_offset f c ofs.
-
 Let step := Mach.step return_address_offset.
 
 Variable prog: Linear.program.
@@ -89,6 +86,20 @@ Hypothesis TRANSF: match_prog prog tprog.
 Let ge := Genv.globalenv prog.
 Let tge := Genv.globalenv tprog.
 
+Hypothesis return_address_offset_exists:
+  forall f sg ros c v (FUNCT: Genv.find_funct tge v = Some (Internal f)),
+  is_tail (Mcall sg ros :: c) (fn_code f) ->
+  exists ofs, return_address_offset f c ofs.
+
+Hypothesis return_address_offset_deterministic:
+  forall f c ofs ofs',
+  return_address_offset f c ofs ->
+  return_address_offset f c ofs' ->
+  ofs = ofs'.
+
+Let sem := Linear.semantics prog.
+Let tsem := Mach.semantics return_address_offset tprog.
+
 Section FRAME_PROPERTIES.
 
 Variable f: Linear.function.
@@ -190,15 +201,16 @@ Program Definition contains_locations (j: meminj) (sp: block) (pos bound: Z) (sl
     Mem.range_perm m sp pos (pos + 4 * bound) Cur Freeable /\
     forall ofs ty, 0 <= ofs -> ofs + typesize ty <= bound -> (typealign ty | ofs) ->
     exists v, Mem.load (chunk_of_type ty) m sp (pos + 4 * ofs) = Some v
-           /\ Val.inject j (ls (S sl ofs ty)) v;
+         /\ Val.inject j (ls (S sl ofs ty)) v;
   m_footprint := fun b ofs =>
     b = sp /\ pos <= ofs < pos + 4 * bound
 |}.
 Next Obligation.
   intuition auto.
 - red; intros. eapply Mem.perm_unchanged_on; eauto. simpl; auto.
-- exploit H4; eauto. intros (v & A & B). exists v; split; auto.
-  eapply Mem.load_unchanged_on; eauto.
+- exploit H4; eauto. intros (v & A & B (* & C *)).
+  exploit Mem.load_unchanged_on_impure; eauto.
+  2:{ i. des_safe. exists v'. split; eauto. des; subst; eauto. inv B. eauto. }
   simpl; intros. rewrite size_type_chunk, typesize_typesize in H8.
   split; auto. lia.
 Qed.
@@ -232,7 +244,7 @@ Lemma get_location:
 Proof.
   intros. destruct H as (D & E & F & G & H).
   exploit H; eauto. intros (v & U & V). exists v; split; auto.
-  unfold load_stack; simpl. rewrite Ptrofs.add_zero_l, Ptrofs.unsigned_repr; auto.
+  unfold load_stack; unfold Mem.loadv; simpl. rewrite Ptrofs.add_zero_l, Ptrofs.unsigned_repr; auto.
   unfold Ptrofs.max_unsigned. generalize (typesize_pos ty). lia.
 Qed.
 
@@ -262,14 +274,14 @@ Proof.
   eapply Mem.load_store_similar_2; eauto. lia.
   apply Val.load_result_inject; auto.
 * (* different locations *)
-  exploit H; eauto. intros (v0 & X & Y). exists v0; split; auto.
+  exploit H; eauto. intros (v0 & X & Y). exists v0; split; try split; auto.
   rewrite <- X; eapply Mem.load_store_other; eauto.
   destruct d. congruence. right. rewrite ! size_type_chunk, ! typesize_typesize. lia.
 * (* overlapping locations *)
   destruct (Mem.valid_access_load m' (chunk_of_type ty0) sp (pos + 4 * ofs0)) as [v'' LOAD].
   apply Mem.valid_access_implies with Writable; auto with mem.
   eapply valid_access_location; eauto.
-  exists v''; auto.
+  exists v''; repeat split; auto.
 + apply (m_invar P) with m; auto.
   eapply Mem.store_unchanged_on; eauto.
   intros i; rewrite size_type_chunk, typesize_typesize. intros; red; intros.
@@ -904,12 +916,12 @@ Hypothesis ls_temp_undef:
 Hypothesis wt_ls: forall r, Val.has_type (ls (R r)) (mreg_type r).
 
 Lemma save_callee_save_rec_correct:
-  forall k l pos rs m P,
+  forall k l pos rs m P Q (UNDEF: m |= undef_area sp pos (size_callee_save_area_rec l pos) ** Q),
   (forall r, In r l -> is_callee_save r = true) ->
   m |= range sp pos (size_callee_save_area_rec l pos) ** P ->
   agree_regs j ls rs ->
   exists rs', exists m',
-     star step tge
+     DStar tsem
         (State cs fb (Vptr sp Ptrofs.zero) (save_callee_save_rec l pos k) rs m)
      E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')
   /\ m' |= contains_callee_saves j sp pos l ls ** P
@@ -917,7 +929,7 @@ Lemma save_callee_save_rec_correct:
   /\ agree_regs j ls rs'.
 Proof.
 Local Opaque mreg_type.
-  induction l as [ | r l]; simpl; intros until P; intros CS SEP AG.
+  induction l as [ | r l]; simpl; intros until Q; intros UNDEF CS SEP AG.
 - exists rs, m.
   split. apply star_refl.
   split. rewrite sep_pure; split; auto. eapply sep_drop; eauto.
@@ -936,21 +948,36 @@ Local Opaque mreg_type.
   apply range_drop_left with (mid := pos1) in SEP; [ | lia ].
   apply range_split with (mid := pos1 + sz) in SEP; [ | lia ].
   unfold sz at 1 in SEP. rewrite <- size_type_chunk in SEP.
-  apply range_contains in SEP; auto.
+  apply undef_area_drop_left with (mid := pos1) in UNDEF; [ | lia ].
+  apply undef_area_split with (mid := pos1 + sz) in UNDEF; [ | lia ].
+  unfold sz at 1 in UNDEF. rewrite <- size_type_chunk in UNDEF.
+  dup SEP. dup UNDEF.
+  eapply range_contains' in SEP; auto.
+  2:{ eapply UNDEF0. }
+  eapply undef_contains in UNDEF; auto.
+  2:{ eapply SEP0. }
+  clear UNDEF0 SEP0.
   exploit (contains_set_stack (fun v' => Val.inject j (ls (R r)) v') (rs r)).
   eexact SEP.
   apply load_result_inject; auto. apply wt_ls.
   clear SEP; intros (m1 & STORE & SEP).
+  exploit (contains_set_stack (fun v' => Val.inject j (ls (R r)) v') (rs r)).
+  eexact UNDEF.
+  apply load_result_inject; auto. apply wt_ls.
+  clear UNDEF; intros (m1' & STORE' & UNDEF).
+  rewrite STORE in STORE'. symmetry in STORE'. clarify.
   set (rs1 := undef_regs (destroyed_by_setstack ty) rs).
   assert (AG1: agree_regs j ls rs1).
   { red; intros. unfold rs1. destruct (In_dec mreg_eq r0 (destroyed_by_setstack ty)).
     erewrite ls_temp_undef by eauto. auto.
     rewrite undef_regs_other by auto. apply AG. }
   rewrite sep_swap in SEP.
+  rewrite sep_swap in UNDEF.
+  (* eapply sep_proj2 in UNDEF. *)
   exploit (IHl (pos1 + sz) rs1 m1); eauto.
   intros (rs2 & m2 & A & B & C & D).
   exists rs2, m2.
-  split. eapply star_left; eauto. constructor. exact STORE. auto. traceEq.
+  split. eapply star_left; eauto. DStep_tac. constructor. exact STORE. auto. traceEq.
   split. rewrite sep_assoc, sep_swap. exact B.
   split. intros. apply C. unfold store_stack in STORE; simpl in STORE. eapply Mem.perm_store_1; eauto.
   auto.
@@ -992,7 +1019,7 @@ Proof.
 Qed.
 
 Lemma save_callee_save_correct:
-  forall j ls ls0 rs sp cs fb k m P,
+  forall j ls ls0 rs sp cs fb k m P Q (UNDEF: m |= undef_area sp fe.(fe_ofs_callee_save) (size_callee_save_area b fe.(fe_ofs_callee_save)) ** Q),
   m |= range sp fe.(fe_ofs_callee_save) (size_callee_save_area b fe.(fe_ofs_callee_save)) ** P ->
   (forall r, Val.has_type (ls (R r)) (mreg_type r)) ->
   agree_callee_save ls ls0 ->
@@ -1000,17 +1027,18 @@ Lemma save_callee_save_correct:
   let ls1 := LTL.undef_regs destroyed_at_function_entry (LTL.call_regs ls) in
   let rs1 := undef_regs destroyed_at_function_entry rs in
   exists rs', exists m',
-     star step tge
+     DStar tsem
         (State cs fb (Vptr sp Ptrofs.zero) (save_callee_save fe k) rs1 m)
      E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m')
   /\ m' |= contains_callee_saves j sp fe.(fe_ofs_callee_save) b.(used_callee_save) ls0 ** P
   /\ (forall ofs k p, Mem.perm m sp ofs k p -> Mem.perm m' sp ofs k p)
   /\ agree_regs j ls1 rs'.
 Proof.
-  intros until P; intros SEP TY AGCS AG; intros ls1 rs1.
+  intros until Q; intros UNDEF SEP TY AGCS AG; intros ls1 rs1.
   exploit (save_callee_save_rec_correct j cs fb sp ls1).
 - intros. unfold ls1. apply LTL_undef_regs_same. eapply destroyed_by_setstack_function_entry; eauto.
 - intros. unfold ls1. apply undef_regs_type. apply TY.
+- eauto.
 - exact b.(used_callee_save_prop).
 - eexact SEP.
 - instantiate (1 := rs1). apply agree_regs_undef_regs. apply agree_regs_call_regs. auto.
@@ -1050,7 +1078,7 @@ Lemma function_prologue_correct:
      Mem.alloc m1' 0 tf.(fn_stacksize) = (m2', sp')
   /\ store_stack m2' (Vptr sp' Ptrofs.zero) Tptr tf.(fn_link_ofs) parent = Some m3'
   /\ store_stack m3' (Vptr sp' Ptrofs.zero) Tptr tf.(fn_retaddr_ofs) ra = Some m4'
-  /\ star step tge
+  /\ DStar tsem
          (State cs fb (Vptr sp' Ptrofs.zero) (save_callee_save fe k) rs1 m4')
       E0 (State cs fb (Vptr sp' Ptrofs.zero) k rs' m5')
   /\ agree_regs j' ls1 rs'
@@ -1076,7 +1104,7 @@ Local Opaque b fe.
   generalize (bound_stack_data_pos b) size_no_overflow; lia.
   tauto.
   tauto.
-  clear SEP. intros (j' & SEP & INCR & SAME).
+  clear SEP. intros (j' & SEP & INCR & SAME & UNDEF).
   (* Remember the freeable permissions using a mconj *)
   assert (SEPCONJ:
     m2' |= mconj (range sp' 0 (fe_stack_data fe) ** range sp' (fe_stack_data fe + bound_stack_data b) (fe_size fe))
@@ -1085,41 +1113,68 @@ Local Opaque b fe.
   { apply mconj_intro; rewrite sep_assoc; assumption. }
   (* Dividing up the frame *)
   apply (frame_env_separated b) in SEP. replace (make_env b) with fe in SEP by auto.
+  apply (frame_env_separated_undef b) in UNDEF. replace (make_env b) with fe in UNDEF by auto.
   (* Store of parent *)
   rewrite sep_swap3 in SEP.
-  apply (range_contains Mptr) in SEP; [|tauto].
+  rewrite sep_swap3 in UNDEF.
+  (* exploit alloc_undef_rule; try eapply ALLOC'; try lia. eapply size_no_overflow. intros UNDEF. *)
+  dup SEP. dup UNDEF.
+  eapply (range_contains' Mptr) in SEP; [| |tauto].
+  2:{ eapply UNDEF0. }
+  eapply (undef_contains Mptr) in UNDEF; [| |tauto].
+  2:{ eapply SEP0. }
+  clear SEP0 UNDEF0.
   exploit (contains_set_stack (fun v' => v' = parent) parent (fun _ => True) m2' Tptr).
   rewrite chunk_of_Tptr; eexact SEP. apply Val.load_result_same; auto.
   clear SEP; intros (m3' & STORE_PARENT & SEP).
+  exploit (contains_set_stack (fun v' => v' = parent) parent (fun _ => True) m2' Tptr).
+  rewrite chunk_of_Tptr; eexact UNDEF. apply Val.load_result_same; auto.
+  clear UNDEF; intros (m3'' & STORE_PARENT' & UNDEF).
+  rewrite STORE_PARENT in STORE_PARENT'. symmetry in STORE_PARENT'. inv STORE_PARENT'.
   rewrite sep_swap3 in SEP.
+  rewrite sep_swap3 in UNDEF.
   (* Store of return address *)
   rewrite sep_swap4 in SEP.
-  apply (range_contains Mptr) in SEP; [|tauto].
+  rewrite sep_swap4 in UNDEF.
+  dup SEP. dup UNDEF.
+  eapply (range_contains' Mptr) in SEP; [| |tauto].
+  2:{ eapply UNDEF0. }
+  eapply (undef_contains Mptr) in UNDEF; [| |tauto].
+  2:{ eapply SEP0. }
+  clear SEP0 UNDEF0.
   exploit (contains_set_stack (fun v' => v' = ra) ra (fun _ => True) m3' Tptr).
   rewrite chunk_of_Tptr; eexact SEP. apply Val.load_result_same; auto.
   clear SEP; intros (m4' & STORE_RETADDR & SEP).
+  exploit (contains_set_stack (fun v' => v' = ra) ra (fun _ => True) m3' Tptr).
+  rewrite chunk_of_Tptr; eexact UNDEF. apply Val.load_result_same; auto.
+  clear UNDEF; intros (m4'' & STORE_RETADDR' & UNDEF).
+  rewrite STORE_RETADDR in STORE_RETADDR'. symmetry in STORE_RETADDR'. clarify.
   rewrite sep_swap4 in SEP.
+  rewrite sep_swap4 in UNDEF.
   (* Saving callee-save registers *)
   rewrite sep_swap5 in SEP.
+  rewrite sep_swap5 in UNDEF.
   exploit (save_callee_save_correct j' ls ls0 rs); eauto.
   apply agree_regs_inject_incr with j; auto.
-  replace (LTL.undef_regs destroyed_at_function_entry (call_regs ls)) with ls1 by auto.
-  replace (undef_regs destroyed_at_function_entry rs) with rs1 by auto.
-  clear SEP; intros (rs2 & m5' & SAVE_CS & SEP & PERMS & AGREGS').
+  remember (LTL.undef_regs destroyed_at_function_entry (call_regs ls)) as ls2.
+  remember (undef_regs destroyed_at_function_entry rs) as rs2.
+  (* replace (LTL.undef_regs destroyed_at_function_entry (call_regs ls)) with ls1 by auto. *)
+  (* replace (undef_regs destroyed_at_function_entry rs) with rs1 by auto. *)
+  clear SEP UNDEF; intros (rs1 & m5' & SAVE_CS & SEP & PERMS & AGREGS').
   rewrite sep_swap5 in SEP.
   (* Materializing the Local and Outgoing locations *)
   exploit (initial_locations j'). eexact SEP. tauto.
-  instantiate (1 := Local). instantiate (1 := ls1).
-  intros; rewrite LS1. rewrite LTL_undef_regs_slot. reflexivity.
+  instantiate (1 := Local). instantiate (1 := ls2).
+  intros; rewrite Heqls2. rewrite LTL_undef_regs_slot. reflexivity.
   clear SEP; intros SEP.
   rewrite sep_swap in SEP.
   exploit (initial_locations j'). eexact SEP. tauto.
-  instantiate (1 := Outgoing). instantiate (1 := ls1).
-  intros; rewrite LS1. rewrite LTL_undef_regs_slot. reflexivity.
+  instantiate (1 := Outgoing). instantiate (1 := ls2).
+  intros; rewrite Heqls2. rewrite LTL_undef_regs_slot. reflexivity.
   clear SEP; intros SEP.
   rewrite sep_swap in SEP.
   (* Now we frame this *)
-  assert (SEPFINAL: m5' |= frame_contents j' sp' ls1 ls0 parent ra ** minjection j' m2 ** globalenv_inject ge j' ** P).
+  assert (SEPFINAL: m5' |= frame_contents j' sp' ls2 ls0 parent ra ** minjection j' m2 ** globalenv_inject ge j' ** P).
   { eapply frame_mconj. eexact SEPCONJ.
     rewrite chunk_of_Tptr in SEP.
     unfold frame_contents_1; rewrite ! sep_assoc. exact SEP.
@@ -1134,13 +1189,13 @@ Local Opaque b fe.
   }
   clear SEP SEPCONJ.
 (* Conclusions *)
-  exists j', rs2, m2', sp', m3', m4', m5'.
+  exists j', rs1, m2', sp', m3', m4', m5'.
   split. auto.
   split. exact STORE_PARENT.
   split. exact STORE_RETADDR.
   split. eexact SAVE_CS.
   split. exact AGREGS'.
-  split. rewrite LS1. apply agree_locs_undef_locs; [|reflexivity].
+  split. rewrite Heqls2. apply agree_locs_undef_locs; [|reflexivity].
     constructor; intros. unfold call_regs. apply AGCS.
     unfold mreg_within_bounds in H; tauto.
     unfold call_regs. apply AGARGS. apply incoming_slot_in_parameters; auto.
@@ -1171,7 +1226,7 @@ Lemma restore_callee_save_rec_correct:
   agree_unused ls0 rs ->
   (forall r, In r l -> mreg_within_bounds b r) ->
   exists rs',
-    star step tge
+    DStar tsem
       (State cs fb (Vptr sp Ptrofs.zero) (restore_callee_save_rec l ofs k) rs m)
    E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m)
   /\ (forall r, In r l -> Val.inject j (ls0 (R r)) (rs' r))
@@ -1199,6 +1254,7 @@ Local Opaque mreg_type.
   intros (rs' & A & B & C & D).
   exists rs'.
   split. eapply star_step; eauto.
+    DStep_tac.
     econstructor. exact LOAD. traceEq.
   split. intros.
     destruct (In_dec mreg_eq r0 l). auto.
@@ -1216,7 +1272,7 @@ Lemma restore_callee_save_correct:
   m |= frame_contents j sp ls ls0 pa ra ** P ->
   agree_unused j ls0 rs ->
   exists rs',
-    star step tge
+    DStar tsem
        (State cs fb (Vptr sp Ptrofs.zero) (restore_callee_save fe k) rs m)
     E0 (State cs fb (Vptr sp Ptrofs.zero) k rs' m)
   /\ (forall r,
@@ -1255,7 +1311,7 @@ Lemma function_epilogue_correct:
      load_stack m' (Vptr sp' Ptrofs.zero) Tptr tf.(fn_link_ofs) = Some pa
   /\ load_stack m' (Vptr sp' Ptrofs.zero) Tptr tf.(fn_retaddr_ofs) = Some ra
   /\ Mem.free m' sp' 0 tf.(fn_stacksize) = Some m1'
-  /\ star step tge
+  /\ DStar tsem
        (State cs fb (Vptr sp' Ptrofs.zero) (restore_callee_save fe k) rs m')
     E0 (State cs fb (Vptr sp' Ptrofs.zero) k rs1 m')
   /\ agree_regs j (return_regs ls0 ls) rs1
@@ -1551,23 +1607,32 @@ Proof.
 Qed.
 
 Lemma find_function_translated:
-  forall j ls rs m ros f,
+  forall j ls rs m ros f m1 (MINJ: m |= minjection j m1),
   agree_regs j ls rs ->
   m |= globalenv_inject ge j ->
-  Linear.find_function ge ros ls = Some f ->
+  Linear.find_function ge (Linear.ros_to_vos m1 ros ls) ls = Some f ->
   exists bf, exists tf,
-     find_function_ptr tge ros rs = Some bf
+     find_function_ptr tge (Mach.ros_to_vos m ros rs) rs = Some bf
   /\ Genv.find_funct_ptr tge bf = Some tf
   /\ transf_fundef f = OK tf.
 Proof.
-  intros until f; intros AG [bound [_ [?????]]] FF.
+  intros until m1; intros MINJ AG [bound [_ [?????]]] FF.
   destruct ros; simpl in FF.
-- exploit Genv.find_funct_inv; eauto. intros [b EQ]. rewrite EQ in FF.
-  rewrite Genv.find_funct_find_funct_ptr in FF.
+- destruct (ls (R m0)) eqn:RSV; try by ss.
++ des_ifs_safe. inv MINJ. specialize (AG m0). rewrite RSV in AG.
+  inv AG. ss. rewrite <- H. des_ifs_safe. exploit Mem.denormalize_inject'; try eapply Heq2; eauto.
+  { inv mi_inj. eauto. }
+  i. des. rewrite DENOTGT. inv VINJ. rewrite DOMAIN in H3; clarify.
+  2:{ eapply FUNCTIONS; eauto. }
+  rewrite Ptrofs.add_zero in H5. rewrite H5.
   exploit function_ptr_translated; eauto. intros [tf [A B]].
-  exists b; exists tf; split; auto. simpl.
-  generalize (AG m0). rewrite EQ. intro INJ. inv INJ.
-  rewrite DOMAIN in H2. inv H2. simpl. auto. eapply FUNCTIONS; eauto.
+  rewrite e. esplits; eauto. ss.
++ specialize (AG m0). rewrite RSV in AG. inv AG.
+  rewrite DOMAIN in H2; clarify.
+  2:{ ss. des_ifs. eapply FUNCTIONS; eauto. }
+  ss. rewrite <- H1. ss. des_ifs.
+  exploit function_ptr_translated; eauto. intros [tf [A B]].
+  esplits; eauto.
 - destruct (Genv.find_symbol ge i) as [b|] eqn:?; try discriminate.
   exploit function_ptr_translated; eauto. intros [tf [A B]].
   exists b; exists tf; split; auto. simpl.
@@ -1802,10 +1867,11 @@ Inductive match_states: Linear.state -> Mach.state -> Prop :=
                   (Mach.Returnstate cs' rs m').
 
 Theorem transf_step_correct:
-  forall s1 t s2, Linear.step ge s1 t s2 ->
-  forall (WTS: wt_state s1) s1' (MS: match_states s1 s1'),
-  exists s2', plus step tge s1' t s2' /\ match_states s2 s2'.
+  forall s1 t s2, IStep sem s1 t s2 ->
+  forall (WTS: wt_state s1) (SCHAR: state_char prog s1) s1' (MS: match_states s1 s1'),
+  exists s2', DPlus tsem s1' t s2' /\ match_states s2 s2'.
 Proof.
+  destruct 1. generalize dependent s2. rename H into INT.
   induction 1; intros;
   try inv MS;
   try rewrite transl_code_eq;
@@ -1820,7 +1886,7 @@ Proof.
 + (* Lgetstack, local *)
   exploit frame_get_local; eauto. intros (v & A & B).
   econstructor; split.
-  apply plus_one. apply exec_Mgetstack. exact A.
+  apply plus_one. DStep_tac. apply exec_Mgetstack. exact A.
   econstructor; eauto with coqlib.
   apply agree_regs_set_reg; auto.
   apply agree_locs_set_reg; auto.
@@ -1836,7 +1902,7 @@ Proof.
   eapply slot_outgoing_argument_valid; eauto.
   intros (v & A & B).
   econstructor; split.
-  apply plus_one. eapply exec_Mgetparam; eauto.
+  apply plus_one. DStep_tac. eapply exec_Mgetparam; eauto.
   rewrite (unfold_transf_function _ _ TRANSL). unfold fn_link_ofs.
   eapply frame_get_parent. eexact SEP.
   econstructor; eauto with coqlib. econstructor; eauto.
@@ -1846,7 +1912,7 @@ Proof.
 + (* Lgetstack, outgoing *)
   exploit frame_get_outgoing; eauto. intros (v & A & B).
   econstructor; split.
-  apply plus_one. apply exec_Mgetstack. exact A.
+  apply plus_one. DStep_tac. apply exec_Mgetstack. exact A.
   econstructor; eauto with coqlib.
   apply agree_regs_set_reg; auto.
   apply agree_locs_set_reg; auto.
@@ -1871,7 +1937,9 @@ Proof.
   clear SEP; destruct A as (m'' & STORE & SEP).
   econstructor; split.
   apply plus_one. destruct sl; try discriminate.
+    DStep_tac.
     econstructor. eexact STORE. eauto.
+    DStep_tac.
     econstructor. eexact STORE. eauto.
   econstructor. eauto. eauto. eauto.
   apply agree_regs_set_slot. apply agree_regs_undef_regs. auto.
@@ -1880,16 +1948,16 @@ Proof.
 
 - (* Lop *)
   assert (exists v',
-          eval_operation ge (Vptr sp' Ptrofs.zero) (transl_op (make_env (function_bounds f)) op) rs0##args m' = Some v'
+          eval_operation_wrapper ge (Vptr sp' Ptrofs.zero) (transl_op (make_env (function_bounds f)) op) rs0##args m' = Some v'
        /\ Val.inject j v v').
-  eapply eval_operation_inject; eauto.
+  eapply eval_operation_wrapper_inject; eauto.
   eapply globalenv_inject_preserves_globals. eapply sep_proj2. eapply sep_proj2. eapply sep_proj2. eexact SEP.
   eapply agree_reglist; eauto.
   apply sep_proj2 in SEP. apply sep_proj2 in SEP. apply sep_proj1 in SEP. exact SEP.
   destruct H0 as [v' [A B]].
   econstructor; split.
-  apply plus_one. econstructor.
-  instantiate (1 := v'). rewrite <- A. apply eval_operation_preserved.
+  apply plus_one. DStep_tac. econstructor.
+  instantiate (1 := v'). rewrite <- A. apply eval_operation_wrapper_preserved.
   exact symbols_preserved. eauto.
   econstructor; eauto with coqlib.
   apply agree_regs_set_reg; auto.
@@ -1910,7 +1978,7 @@ Proof.
   eauto. eauto.
   intros [v' [C D]].
   econstructor; split.
-  apply plus_one. econstructor.
+  apply plus_one. DStep_tac. econstructor.
   instantiate (1 := a'). rewrite <- A. apply eval_addressing_preserved. exact symbols_preserved.
   eexact C. eauto.
   econstructor; eauto with coqlib.
@@ -1930,7 +1998,7 @@ Proof.
   clear SEP; intros (m1' & C & SEP).
   rewrite sep_swap3 in SEP.
   econstructor; split.
-  apply plus_one. econstructor.
+  apply plus_one. DStep_tac. econstructor.
   instantiate (1 := a'). rewrite <- A. apply eval_addressing_preserved. exact symbols_preserved.
   eexact C. eauto.
   econstructor. eauto. eauto. eauto.
@@ -1941,13 +2009,14 @@ Proof.
 
 - (* Lcall *)
   exploit find_function_translated; eauto.
+    eapply sep_drop in SEP. eapply sep_drop in SEP. erewrite sep_comm in SEP. eapply sep_drop in SEP. eexact SEP.
     eapply sep_proj2. eapply sep_proj2. eapply sep_proj2. eexact SEP.
   intros [bf [tf' [A [B C]]]].
   exploit is_tail_transf_function; eauto. intros IST.
   rewrite transl_code_eq in IST. simpl in IST.
-  exploit return_address_offset_exists. eexact IST. intros [ra D].
+  exploit return_address_offset_exists. { rewrite Genv.find_funct_find_funct_ptr. fold tge. eauto. } eexact IST. intros [ra D].
   econstructor; split.
-  apply plus_one. econstructor; eauto.
+  apply plus_one. DStep_tac. econstructor; eauto.
   econstructor; eauto.
   econstructor; eauto with coqlib.
   apply Val.Vptr_has_type.
@@ -1961,11 +2030,71 @@ Proof.
   exploit function_epilogue_correct; eauto.
   clear SEP. intros (rs1 & m1' & P & Q & R & S & T & U & SEP).
   rewrite sep_swap in SEP.
+  assert (RTV: (Linear.ros_to_vos m ros (return_regs (parent_locset s) rs)) = (Linear.ros_to_vos m' ros (return_regs (parent_locset s) rs))).
+  { destruct ros; try by ss. unfold find_function in H0.
+    destruct (Linear.ros_to_vos m (inl m0) (return_regs (parent_locset s) rs)) eqn:A.
+    2:{ simpl in A. des_ifs. }
+    destruct v; simpl in H0; try by clarify. des_ifs_safe.
+    r in SCHAR. simpl in SCHAR. r in SCHAR. exploit SCHAR; eauto. intros (NE & NE').
+    clear SCHAR. unfold Linear.ros_to_vos in A. des_ifs_safe. des_ifs; cycle 1.
+    { unfold Linear.ros_to_vos. rewrite Heq1. ss. }
+    assert (Mem.to_ptr (Vlong i) m' = Some (Vptr b0 Ptrofs.zero)).
+    { simpl in Heq2. destruct Archi.ptr64 eqn:SF; try by ss.
+      destruct (Int64.eq i Int64.zero) eqn:NULL; try by ss.
+      destruct (Mem.denormalize (Int64.unsigned i) m) eqn:DENO; try by ss. destruct p.
+      assert (z = 0).
+      { eapply Mem.denormalize_info in DENO. des.
+        assert (ZERO: Ptrofs.repr z = Ptrofs.zero).
+        { eapply Ptrofs.same_if_eq. unfold Ptrofs.eq. des_ifs. }
+        rewrite <- Ptrofs.unsigned_repr; try lia.
+        rewrite <- Ptrofs.unsigned_repr at 1; try lia. rewrite ZERO. eauto. }
+      subst. inv Heq2.
+      assert (P2I: Mem.ptr2int b0 0 m' = Some (Int64.unsigned i)).
+      { eapply Mem.denormalize_info in DENO. des. unfold Mem.ptr2int.
+        erewrite <- Mem.concrete_free; eauto. rewrite CONC. f_equal. lia. }
+      exploit Mem.denormalize_perm; eauto. i. des.
+      exploit NE'; eauto. i. des; clarify.
+      hexploit Mem.free_range_perm; try eapply H2; eauto. intros FPERM.
+      destruct (classic (Linear.fn_stacksize f > 0)); cycle 1.
+      { exploit Mem.perm_free_1; try eapply H2; eauto. i.
+        exploit Mem.ptr2int_to_denormalize_max; eauto. 
+        { unfold Ptrofs.max_unsigned, Ptrofs.modulus, two_power_nat. lia. }
+        i. unfold Mem.to_ptr. rewrite SF, NULL, H5. eauto. }
+      assert (b0 <> stk).
+      { ii. subst. r in FPERM. specialize (FPERM 0). exploit FPERM; try lia. i.
+        eapply NE' in H4; eauto. des; clarify. }
+      exploit Mem.perm_free_1; try eapply H2; eauto. i.
+      exploit Mem.ptr2int_to_denormalize_max; eauto.
+      { unfold Ptrofs.max_unsigned, Ptrofs.modulus, two_power_nat. lia. }
+      i. unfold Mem.to_ptr. rewrite SF, NULL, H6. eauto. }
+    unfold Linear.ros_to_vos. rewrite Heq1, H. des_ifs. }
+  rewrite RTV in H0.
   exploit find_function_translated; eauto.
+    eapply sep_drop in SEP. erewrite sep_comm in SEP. eapply sep_drop in SEP. eexact SEP.
     eapply sep_proj2. eapply sep_proj2. eexact SEP.
   intros [bf [tf' [A [B C]]]].
+  assert (RTV' : (ros_to_vos m1' ros rs1) = (ros_to_vos m'0 ros rs1)).
+  { destruct ros; try by ss.
+    destruct (ros_to_vos m1' (inl m0) rs1) eqn:X.
+    2:{ simpl in X. des_ifs. }
+    destruct v; simpl in A; try by clarify. des_ifs_safe.
+    unfold ros_to_vos in X. des_ifs_safe. des_ifs; cycle 1.
+    { simpl. rewrite Heq2. ss. }
+    unfold ros_to_vos. rewrite Heq2, Heq1.
+    assert (Mem.to_ptr (Vlong i0) m'0 = Some (Vptr bf i)).
+    { simpl in Heq3. des_ifs.
+      assert (Mem.ptr2int bf z m'0 = Some (Int64.unsigned i0)).
+      { eapply Mem.denormalize_info in Heq5. des. subst.
+        unfold Mem.ptr2int. erewrite Mem.concrete_free; eauto. rewrite CONC. f_equal. lia. }
+      exploit Mem.denormalize_perm; eauto. i. des. eapply Mem.perm_free_3 in H1; eauto.
+      eapply Mem.perm_implies in H1; [|eapply perm_any_N].
+      exploit Mem.ptr2int_to_denormalize_max; eauto.
+      { eapply Mem.denormalize_info in Heq5. des. eauto. }
+      i. unfold Mem.to_ptr. rewrite Heq1, Heq4, H3. eauto. }
+    rewrite H. ss. }
+  rewrite RTV' in A.
   econstructor; split.
-  eapply plus_right. eexact S. econstructor; eauto. traceEq.
+  eapply plus_right. eexact S. DStep_tac. econstructor; eauto. traceEq.
   econstructor; eauto.
   apply match_stacks_change_sig with (Linear.fn_sig f); auto.
   apply zero_size_arguments_tailcall_possible. eapply wt_state_tailcall; eauto.
@@ -1979,10 +2108,11 @@ Proof.
   intros [vargs' [P Q]].
   rewrite <- sep_assoc, sep_comm, sep_assoc in SEP.
   exploit external_call_parallel_rule; eauto.
+  eapply external_call_spec; eauto.
   clear SEP; intros (j' & res' & m1' & EC & RES & SEP & INCR & ISEP).
   rewrite <- sep_assoc, sep_comm, sep_assoc in SEP.
   econstructor; split.
-  apply plus_one. econstructor; eauto.
+  apply plus_one. DStep_tac. econstructor; eauto.
   eapply eval_builtin_args_preserved with (ge1 := ge); eauto. exact symbols_preserved.
   eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   eapply match_states_intro with (j := j'); eauto with coqlib.
@@ -1995,20 +2125,20 @@ Proof.
 
 - (* Llabel *)
   econstructor; split.
-  apply plus_one; apply exec_Mlabel.
+  apply plus_one; DStep_tac. apply exec_Mlabel.
   econstructor; eauto with coqlib.
 
 - (* Lgoto *)
   econstructor; split.
-  apply plus_one; eapply exec_Mgoto; eauto.
+  apply plus_one; DStep_tac. eapply exec_Mgoto; eauto.
   apply transl_find_label; eauto.
   econstructor; eauto.
   eapply find_label_tail; eauto.
 
 - (* Lcond, true *)
   econstructor; split.
-  apply plus_one. eapply exec_Mcond_true; eauto.
-  eapply eval_condition_inject with (m1 := m). eapply agree_reglist; eauto. apply sep_pick3 in SEP; exact SEP. auto.
+  apply plus_one. DStep_tac. eapply exec_Mcond_true; eauto.
+  eapply eval_condition_wrapper_inject with (m1 := m). eapply agree_reglist; eauto. apply sep_pick3 in SEP; exact SEP. auto.
   eapply transl_find_label; eauto.
   econstructor. eauto. eauto. eauto.
   apply agree_regs_undef_regs; auto.
@@ -2019,8 +2149,8 @@ Proof.
 
 - (* Lcond, false *)
   econstructor; split.
-  apply plus_one. eapply exec_Mcond_false; eauto.
-  eapply eval_condition_inject with (m1 := m). eapply agree_reglist; eauto. apply sep_pick3 in SEP; exact SEP. auto.
+  apply plus_one. DStep_tac. eapply exec_Mcond_false; eauto.
+  eapply eval_condition_wrapper_inject with (m1 := m). eapply agree_reglist; eauto. apply sep_pick3 in SEP; exact SEP. auto.
   econstructor. eauto. eauto. eauto.
   apply agree_regs_undef_regs; auto.
   apply agree_locs_undef_locs. auto. apply destroyed_by_cond_caller_save.
@@ -2031,7 +2161,7 @@ Proof.
   assert (rs0 arg = Vint n).
   { generalize (AGREGS arg). rewrite H. intro IJ; inv IJ; auto. }
   econstructor; split.
-  apply plus_one; eapply exec_Mjumptable; eauto.
+  apply plus_one; DStep_tac. eapply exec_Mjumptable; eauto.
   apply transl_find_label; eauto.
   econstructor. eauto. eauto. eauto.
   apply agree_regs_undef_regs; auto.
@@ -2044,7 +2174,7 @@ Proof.
   exploit function_epilogue_correct; eauto.
   intros (rs' & m1' & A & B & C & D & E & F & G).
   econstructor; split.
-  eapply plus_right. eexact D. econstructor; eauto. traceEq.
+  eapply plus_right. eexact D. DStep_tac. econstructor; eauto. traceEq.
   econstructor; eauto.
   rewrite sep_swap; exact G.
 
@@ -2063,7 +2193,7 @@ Proof.
   rewrite (sep_comm (globalenv_inject ge j')) in SEP.
   rewrite (sep_swap (minjection j' m')) in SEP.
   econstructor; split.
-  eapply plus_left. econstructor; eauto.
+  eapply plus_left. DStep_tac. fold tge. rewrite FIND. eauto. econstructor; eauto.
   rewrite (unfold_transf_function _ _ TRANSL). unfold fn_code. unfold transl_body.
   eexact D. traceEq.
   eapply match_states_intro with (j := j'); eauto with coqlib.
@@ -2071,14 +2201,16 @@ Proof.
   rewrite sep_swap in SEP. rewrite sep_swap. eapply stack_contents_change_meminj; eauto.
 
 - (* external function *)
+  unfold is_internal in INT. simpl in INT.
   simpl in TRANSL. inversion TRANSL; subst tf.
   exploit wt_callstate_agree; eauto. intros [AGCS AGARGS].
   exploit transl_external_arguments; eauto. apply sep_proj1 in SEP; eauto. intros [vl [ARGS VINJ]].
   rewrite sep_comm, sep_assoc in SEP.
   exploit external_call_parallel_rule; eauto.
+  eapply external_call_spec; eauto.
   intros (j' & res' & m1' & A & B & C & D & E).
   econstructor; split.
-  apply plus_one. eapply exec_function_external; eauto.
+  apply plus_one. DStep_tac. fold tge. rewrite FIND; ss. eapply exec_function_external; eauto.
   eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   eapply match_states_return with (j := j').
   eapply match_stacks_change_meminj; eauto.
@@ -2092,7 +2224,7 @@ Proof.
   inv STACKS. exploit wt_returnstate_agree; eauto. intros [AGCS OUTU].
   simpl in AGCS. simpl in SEP. rewrite sep_assoc in SEP.
   econstructor; split.
-  apply plus_one. apply exec_return.
+  apply plus_one. DStep_tac. apply exec_return.
   econstructor; eauto.
   apply agree_locs_return with rs0; auto.
   apply frame_contents_exten with rs0 (parent_locset s); auto.
@@ -2153,21 +2285,208 @@ Proof.
 - auto.
 Qed.
 
+Lemma match_states_xsim st_src0 st_tgt0 gmtgt
+    (WT: wt_state st_src0)
+    (SCHAR: state_char prog st_src0) 
+    (MATCH: match_states st_src0 st_tgt0) :
+  xsim sem tsem gmtgt lt 0%nat st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold.
+  destruct (classic (Linear.is_external ge st_src0)); cycle 1; rename H into EXT.
+  (* internal *)
+  - left. econs. econs.
+    + i. exploit transf_step_correct; eauto. i. des; esplits; eauto;
+      [eapply tr_rel_refl; eapply ev_rel_refl| |].
+      { left. split; eauto. eapply LinearD.semantics_receptive_at; auto. }
+      { right. eapply CIH; eauto. ss.
+        - eapply step_type_preservation; eauto. eapply wt_prog.
+        - eapply state_char_preservation; eauto. }
+    + i. exploit transf_final_states; eauto. i. eapply final_state_determ; eauto.
+  (* external *)
+  - right. econs. i.
+    assert (SEQUIV: Senv.equiv tge ge) by (symmetry; eapply senv_preserved).
+    unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+    { inv SAFESRC; ss. }
+    econs; i.
+    (* bsim *)
+    { unfold Linear.is_external in *.
+      inv MATCH; des_ifs; clarify; try (generalize (function_is_within_bounds f _ (is_tail_in TAIL));
+             intro BOUND; simpl in BOUND); unfold transl_instr.
+      (* builtin *)
+      - inv STEPTGT; clarify; try rewrite transl_code_eq in *; try inv H2; try inv H3; try inv H4.
+        inv SAFESRC; clarify.
+        (* copied begin *)
+        destruct BOUND as [BND1 BND2].
+        exploit transl_builtin_args_correct.
+        eauto. eauto. rewrite sep_swap in SEP; apply sep_proj2 in SEP; eexact SEP.
+        eauto. rewrite <- forallb_forall. eapply wt_state_builtin; eauto.
+        exact BND2. intros [vargs' [P Q]].
+
+        exploit eval_builtin_args_preserved; try eapply SEQUIV. apply H7. i.
+        exploit eval_builtin_args_determ. apply P. apply H. i. subst.
+        rewrite <- sep_assoc, sep_comm, sep_assoc in SEP.
+        exploit external_call_symbols_preserved; try eapply H8. eauto. i.
+        exploit external_call_parallel_rule_backward; try eapply H0; eauto.
+        clear SEP.
+        intros [(j' & res' & m1' & EC & RES & SEP & INCR & ISEP) | [UBSRC | (PTERM & t' & vres1 & m1' & CALLSRC & SUB)]].
+        + left. esplits.
+          * eapply tr_rel_refl. eapply ev_rel_refl.
+          * left. eapply plus_one. eapply exec_Lbuiltin; eauto.
+          * right. eapply CIH; eauto.
+            eapply step_type_preservation; ss; eauto.
+            eapply wt_prog. eapply exec_Lbuiltin; eauto.
+            { eapply state_char_preservation; eauto. eapply exec_Lbuiltin; eauto. }
+            eapply match_states_intro with (j := j'); eauto with coqlib.
+            eapply match_stacks_change_meminj; eauto.
+            apply agree_regs_set_res; auto. apply agree_regs_undef_regs; auto. eapply agree_regs_inject_incr; eauto.
+            apply agree_locs_set_res; auto. apply agree_locs_undef_regs; auto.
+            apply frame_set_res. apply frame_undef_regs. apply frame_contents_incr with j; auto.
+            rewrite sep_swap2. apply stack_contents_change_meminj with j; auto. rewrite sep_swap2.
+            rewrite <- sep_assoc, sep_comm, sep_assoc in SEP. exact SEP.
+        + exploit UBSRC; eauto. clarify.
+        + des; subst. right. esplits; eauto. eapply star_one.
+          ss. eapply exec_Lbuiltin; eauto. subst. eapply tr_rel_refl. eapply ev_rel_refl.
+      (* external call *)
+      - inv SAFESRC; ss; clarify.
+        inv STEPTGT; ss; clarify.
+        { fold tge in H3. clarify. }
+        exploit wt_callstate_agree; eauto. intros [AGCS AGARGS].
+        exploit transl_external_arguments; eauto. apply sep_proj1 in SEP; eauto. intros [vl [ARGS VINJ]].
+        fold tge in H3. Eq.
+        exploit extcall_arguments_determ. eapply H7. eapply ARGS. i. subst.
+
+        eapply external_call_symbols_preserved in H8; try eapply SEQUIV.
+        rewrite sep_comm, sep_assoc in SEP.
+        exploit external_call_parallel_rule_backward; try eapply H8; eauto.
+        clear SEP. i; des.
+        + left. esplits.
+          * eapply tr_rel_refl. eapply ev_rel_refl.
+          * left. eapply plus_one. econs; eauto.
+          * right. eapply CIH; eauto.
+            { eapply step_type_preservation; ss; eauto.
+              eapply wt_prog. econs; eauto. }
+            { eapply state_char_preservation; eauto. econs; eauto. }
+            eapply match_states_return with (j := j').
+            eapply match_stacks_change_meminj; eauto.
+            apply agree_regs_set_pair. apply agree_regs_undef_caller_save_regs. 
+            apply agree_regs_inject_incr with j; auto. auto.
+            apply stack_contents_change_meminj with j; auto.
+            rewrite sep_comm, sep_assoc; auto.
+        + exploit H; eauto. clarify.
+        + right. esplits; eauto. eapply star_one. econs; eauto.
+          subst. eapply tr_rel_refl. eapply ev_rel_refl. }
+    (* final *)
+    { unfold Linear.is_external in *; des_ifs; inv MATCH; ss; inv FINALTGT. }
+    (* progress *)
+    { unfold Linear.is_external in *.
+      inv MATCH; des_ifs; clarify; try (generalize (function_is_within_bounds f _ (is_tail_in TAIL));
+             intro BOUND; simpl in BOUND); unfold transl_instr.
+      (* builtin *)
+      - inv SAFESRC; clarify.
+        destruct BOUND as [BND1 BND2].
+        exploit transl_builtin_args_correct.
+        eauto. eauto. rewrite sep_swap in SEP; apply sep_proj2 in SEP; eexact SEP.
+        eauto. rewrite <- forallb_forall. eapply wt_state_builtin; eauto.
+        exact BND2. intros [vargs' [P Q]].
+        exploit external_call_parallel_rule_backward_progress; try eapply H11; eauto.
+        rewrite <- sep_assoc. simpl. fold ge. rewrite sep_comm. eapply SEP. i. des.
+        exploit external_call_symbols_preserved. apply senv_preserved. eauto. i.
+        exploit eval_builtin_args_preserved. apply senv_preserved. apply P. i.
+        right. esplits. rewrite transl_code_eq in *. ss. eapply exec_Mbuiltin; eauto.
+      (* external *)
+      - inv SAFESRC; ss; clarify.
+        exploit wt_callstate_agree; eauto. intros [AGCS AGARGS].
+        exploit transl_external_arguments; eauto. apply sep_proj1 in SEP; eauto. intros [vl [ARGS VINJ]].
+        rewrite sep_comm, sep_assoc in SEP.
+        exploit external_call_parallel_rule_backward_progress; try eapply H7; eauto. i. des.
+        exploit external_call_symbols_preserved. apply senv_preserved. eauto. i.
+        right. esplits. eapply Mach.exec_function_external; eauto. }
+Qed.
+
+Lemma same_public: prog_public prog = prog_public tprog.
+Proof. inv TRANSF. des; eauto. Qed.
+
+Lemma non_static_equiv j l m (MGE: m|=globalenv_inject ge j):
+  Forall2 (fun b b' => (j b = Some (b', 0)) /\ b = b') (Genv.non_static_glob (Genv.globalenv prog) l) (Genv.non_static_glob (Genv.globalenv tprog) l).
+Proof.
+  induction l; ss.
+  destruct (Genv.find_symbol (Genv.globalenv prog) a) eqn:FS1; cycle 1.
+  - destruct (Genv.find_symbol (Genv.globalenv tprog) a) eqn:FS2; cycle 1.
+    { unfold Genv.public_symbol. des_ifs. }
+    destruct senv_preserved. des. unfold Senv.find_symbol in *. ss. erewrite H in FS2.
+    Local Transparent ge tge. unfold ge, fundef in *. ss. clarify.
+  - destruct (Genv.public_symbol (Genv.globalenv prog) a) eqn:PS1; cycle 1.
+    { des_ifs. destruct senv_preserved. des. ss. erewrite H0 in Heq.
+      unfold ge, fundef in *. clarify. }
+    destruct senv_preserved. des. ss. erewrite <- H0 in PS1.
+    unfold tge, fundef in *. erewrite PS1. erewrite H. unfold ge. rewrite FS1. econs; eauto.
+    inv MGE0. esplits; eauto.
+Qed.
+
+Lemma transf_initial_capture S1 S2 S2'
+    (INITSRC: Linear.initial_state prog S1)
+    (INITTGT: Mach.initial_state tprog S2)
+    (MATCH: match_states S1 S2)
+    (CAPTGT: Mach.glob_capture tprog S2 S2'):
+  exists S1', Linear.glob_capture prog S1 S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (Linear.concrete_snapshot ge S1') (Mach.concrete_snapshot tge S2').
+Proof.
+  specialize senv_preserved. intros SENVEQ.
+  inv CAPTGT. ss. rename m' into m2'.
+  rewrite Genv.globalenv_public in CAPTURE. erewrite <- same_public in CAPTURE; eauto.
+  dup INITSRC. inv INITSRC0. inv MATCH.
+  assert (GINJ: m|=globalenv_inject ge j).
+  { eapply sep_assoc in SEP. eapply sep_drop; eauto. }
+  assert (MINJ: m|= minjection j m0).
+  { eapply sep_pick2; eauto. }
+  inv STACKS. exploit non_static_equiv. eapply GINJ. instantiate (1:=prog_public prog). intros EQUIV.
+  assert (exists m1', Genv.capture_init_mem m0 (Genv.non_static_glob (Genv.globalenv prog) (prog_public prog)) m1' /\
+                     m2' |= stack_contents j [] [] ** minjection j m1' ** globalenv_inject ge j).
+  { clear - MINJ SEP EQUIV CAPTURE.
+    ginduction EQUIV; ss; ii.
+    - exists m0. inv CAPTURE. inv CAP. esplits; eauto. econs. econs.
+    - inv CAPTURE. inv CAP. des; subst.
+      exploit Mem.capture_inject_backward; try eapply INJ; eauto.
+      { instantiate (2:=addr). instantiate (1:= m2). rewrite Z.sub_0_r. eauto. }
+      i. des. exploit IHEQUIV; try eapply MEM. econs; eauto.
+      { econs; ss. split; ss. econs; ss. splits.
+        - eapply sep_comm in SEP. eapply sep_assoc in SEP. eapply sep_pick2 in SEP.
+          ss. des. esplits; eauto. eapply Mem.nextblock_capture in CAP0. rewrite CAP0; eauto.
+        - inv SEP. ss. }
+      i. des. inv H0. esplits; eauto. econs; eauto. econs; eauto. }
+  des. esplits; eauto.
+  - econs; try eapply H2; eauto. ss. rewrite Genv.globalenv_public. eauto.
+  - econs; eauto. econs; eauto.
+  - ii. unfold Linear.concrete_snapshot, concrete_snapshot in *. inv SENVEQ. des. erewrite H8, H7. des_ifs; ss.
+    des. inv GINJ0.
+    assert (j b0 = Some (b0, 0)).
+    { inv H. exploit SYMBOLS; eauto. }
+    eapply sep_pick2 in H5.
+    ss. exploit Mem.mi_src_concrete_public; eauto. i. erewrite H11. f_equal. lia.
+Qed.
+
 Theorem transf_program_correct:
-  forward_simulation (Linear.semantics prog) (Mach.semantics return_address_offset tprog).
-Proof.
-  set (ms := fun s s' => wt_state s /\ match_states s s').
-  eapply forward_simulation_plus with (match_states := ms).
-- apply senv_preserved.
-- intros. exploit transf_initial_states; eauto. intros [st2 [A B]].
-  exists st2; split; auto. split; auto.
-  apply wt_initial_state with (prog := prog); auto. exact wt_prog.
-- intros. destruct H. eapply transf_final_states; eauto.
-- intros. destruct H0.
-  exploit transf_step_correct; eauto. intros [s2' [A B]].
-  exists s2'; split. exact A. split.
-  eapply step_type_preservation; eauto. eexact wt_prog. eexact H.
-  auto.
+  mixed_simulation (Linear.semantics prog) (Mach.semantics return_address_offset tprog).
+Proof.
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (1 + a)%nat. lia.
+  - econs. i. exploit transf_initial_states; eauto. i. des.
+    exists st2. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. inversion INITSRC; subst. inversion H0; subst.
+      inv STACKS.
+      exploit transf_initial_capture; eauto. i. des.
+      exists 0%nat. esplits; eauto.
+      apply match_states_xsim; auto.
+      eapply wt_initial_capture_state; try eapply INITSRC; eauto.
+      { eapply wt_prog. }
+      { eapply glob_capture_char; eauto. eapply initial_state_char; eauto. }
+  - i. apply senv_preserved.
 Qed.
 
 End PRESERVATION.
diff --git a/backend/Tailcallproof.v b/backend/Tailcallproof.v
index 7a5be5ed..179003dd 100644
--- a/backend/Tailcallproof.v
+++ b/backend/Tailcallproof.v
@@ -13,8 +13,10 @@
 (** Recognition of tail calls: correctness proof *)
 
 Require Import Coqlib Maps Integers AST Linking.
+Require Import CoqlibC Simulation RTLD Classical PointerOp.
 Require Import Values Memory Events Globalenvs Smallstep.
 Require Import Op Registers RTL Conventions Tailcall.
+From Paco Require Import paco.
 
 (** * Syntactic properties of the code transformation *)
 
@@ -216,6 +218,9 @@ Hypothesis TRANSL: match_prog prog tprog.
 Let ge := Genv.globalenv prog.
 Let tge := Genv.globalenv tprog.
 
+Let sem := semantics prog.
+Let tsem := semantics tprog.
+
 Lemma symbols_preserved:
   forall (s: ident), Genv.find_symbol tge s = Genv.find_symbol ge s.
 Proof (Genv.find_symbol_transf TRANSL).
@@ -236,6 +241,10 @@ Lemma senv_preserved:
   Senv.equiv ge tge.
 Proof (Genv.senv_transf TRANSL).
 
+Lemma same_public:
+  prog_public prog = prog_public tprog.
+Proof. inv TRANSL. des; eauto. Qed.
+
 Lemma sig_preserved:
   forall f, funsig (transf_fundef f) = funsig f.
 Proof.
@@ -251,17 +260,25 @@ Proof.
 Qed.
 
 Lemma find_function_translated:
-  forall ros rs rs' f,
-  find_function ge ros rs = Some f ->
+  forall ros rs rs' f m m' (MLD: Mem.extends m m'),
+  find_function ge (ros_to_vos m ros rs) rs = Some f ->
   regs_lessdef rs rs' ->
-  find_function tge ros rs' = Some (transf_fundef f).
+  find_function tge (ros_to_vos m' ros rs') rs' = Some (transf_fundef f).
 Proof.
-  intros until f; destruct ros; simpl.
+  intros until m'; destruct ros; simpl.
   intros.
   assert (rs'#r = rs#r).
-    exploit Genv.find_funct_inv; eauto. intros [b EQ].
-    generalize (H0 r). rewrite EQ. intro LD. inv LD. auto.
-  rewrite H1. apply functions_translated; auto.
+  { destruct (rs#r) eqn:RSV; ss.
+    - specialize (H0 r). rewrite RSV in H0. inv H0. eauto.
+    - specialize (H0 r). rewrite RSV in H0. inv H0. eauto. }
+      (* assert (FUNC: Genv.find_funct ge (Vptr b i) = Some f) by ss. *)
+      (* exploit Genv.find_funct_inv; eauto. intros [b' EQ]. *)
+      (* generalize (H0 r). rewrite EQ. intro LD. inv LD. auto. *)
+  rewrite H1. destruct (rs#r) eqn:RSV; try by ss.
+  { des_ifs_safe. erewrite Mem.denormalize_extends; eauto.
+    apply functions_translated; auto. }
+  { apply functions_translated; auto. }
+  intros.
   rewrite symbols_preserved. destruct (Genv.find_symbol ge i); intros.
   apply funct_ptr_translated; auto.
   discriminate.
@@ -395,15 +412,16 @@ Ltac EliminatedInstr :=
   of the ``option'' kind. *)
 
 Lemma transf_step_correct:
-  forall s1 t s2, step ge s1 t s2 ->
+  forall s1 t s2, IStep sem s1 t s2 ->
   forall s1' (MS: match_states s1 s1'),
-  (exists s2', step tge s1' t s2' /\ match_states s2 s2')
+  (exists s2', DStep tsem s1' t s2' /\ match_states s2 s2')
   \/ (measure s2 < measure s1 /\ t = E0 /\ match_states s2 s1')%nat.
 Proof.
+  destruct 1. generalize dependent s2. rename H into INT.
   induction 1; intros; inv MS; EliminatedInstr.
 
 - (* nop *)
-  TransfInstr. left. econstructor; split.
+  TransfInstr. left. econstructor; split. DStep_tac.
   eapply exec_Inop; eauto. constructor; auto.
 - (* eliminated nop *)
   assert (s0 = pc') by congruence. subst s0.
@@ -413,15 +431,16 @@ Proof.
 - (* op *)
   TransfInstr.
   assert (Val.lessdef_list (rs##args) (rs'##args)). apply regs_lessdef_regs; auto.
-  exploit eval_operation_lessdef; eauto.
+  exploit eval_operation_wrapper_lessdef; eauto.
   intros [v' [EVAL' VLD]].
   left. exists (State s' (transf_function f) (Vptr sp0 Ptrofs.zero) pc' (rs'#res <- v') m'); split.
-  eapply exec_Iop; eauto.  rewrite <- EVAL'.
-  apply eval_operation_preserved. exact symbols_preserved.
+  DStep_tac. eapply exec_Iop; eauto.  rewrite <- EVAL'.
+  apply eval_operation_wrapper_preserved. exact symbols_preserved.
   econstructor; eauto. apply set_reg_lessdef; auto.
 - (* eliminated move *)
   rewrite H1 in H. clear H1. inv H.
   right. split. simpl. lia. split. auto.
+  rewrite eval_operation_no_ptr_op in H0; eauto.
   econstructor; eauto. simpl in H0. rewrite PMap.gss. congruence.
 
 - (* load *)
@@ -432,7 +451,7 @@ Proof.
   exploit Mem.loadv_extends; eauto.
   intros [v' [LOAD' VLD]].
   left. exists (State s' (transf_function f) (Vptr sp0 Ptrofs.zero) pc' (rs'#dst <- v') m'); split.
-  eapply exec_Iload with (a := a'). eauto.  rewrite <- ADDR'.
+  DStep_tac. eapply exec_Iload with (a := a'). eauto.  rewrite <- ADDR'.
   apply eval_addressing_preserved. exact symbols_preserved. eauto.
   econstructor; eauto. apply set_reg_lessdef; auto.
 
@@ -444,10 +463,11 @@ Proof.
   exploit Mem.storev_extends. 2: eexact H1. eauto. eauto. apply RLD.
   intros [m'1 [STORE' MLD']].
   left. exists (State s' (transf_function f) (Vptr sp0 Ptrofs.zero) pc' rs' m'1); split.
-  eapply exec_Istore with (a := a'). eauto.  rewrite <- ADDR'.
+  DStep_tac. eapply exec_Istore with (a := a'). eauto.  rewrite <- ADDR'.
   apply eval_addressing_preserved. exact symbols_preserved. eauto.
   destruct a; simpl in H1; try discriminate.
   econstructor; eauto.
+  econstructor; eauto.
 
 - (* call *)
   exploit find_function_translated; eauto. intro FIND'.
@@ -458,14 +478,14 @@ Proof.
     red; intros; extlia.
   destruct X as [m'' FREE].
   left. exists (Callstate s' (transf_fundef fd) (rs'##args) m''); split.
-  eapply exec_Itailcall; eauto. apply sig_preserved.
+  DStep_tac. eapply exec_Itailcall; eauto. apply sig_preserved.
   constructor. eapply match_stackframes_tail; eauto. apply regs_lessdef_regs; auto.
   eapply Mem.free_right_extends; eauto.
   rewrite stacksize_preserved. rewrite H7. intros. extlia.
 + (* call that remains a call *)
   left. exists (Callstate (Stackframe res (transf_function f) (Vptr sp0 Ptrofs.zero) pc' rs' :: s')
                           (transf_fundef fd) (rs'##args) m'); split.
-  eapply exec_Icall; eauto. apply sig_preserved.
+  DStep_tac. eapply exec_Icall; eauto. apply sig_preserved.
   constructor. constructor; auto. apply regs_lessdef_regs; auto. auto.
 
 - (* tailcall *)
@@ -473,18 +493,19 @@ Proof.
   exploit Mem.free_parallel_extends; eauto. intros [m'1 [FREE EXT]].
   TransfInstr.
   left. exists (Callstate s' (transf_fundef fd) (rs'##args) m'1); split.
-  eapply exec_Itailcall; eauto. apply sig_preserved.
+  DStep_tac. eapply exec_Itailcall; eauto. apply sig_preserved.
   rewrite stacksize_preserved; auto.
   constructor. auto.  apply regs_lessdef_regs; auto. auto.
 
 - (* builtin *)
+  unfold is_internal in INT. ss. des_ifs.
   TransfInstr.
   exploit (@eval_builtin_args_lessdef _ ge (fun r => rs#r) (fun r => rs'#r)); eauto.
   intros (vargs' & P & Q).
   exploit external_call_mem_extends; eauto.
   intros [v' [m'1 [A [B [C D]]]]].
   left. exists (State s' (transf_function f) (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res v' rs') m'1); split.
-  eapply exec_Ibuiltin; eauto.
+  DStep_tac. eapply exec_Ibuiltin; eauto.
   eapply eval_builtin_args_preserved with (ge1 := ge); eauto. exact symbols_preserved.
   eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   econstructor; eauto. apply set_res_lessdef; auto.
@@ -492,14 +513,14 @@ Proof.
 - (* cond *)
   TransfInstr.
   left. exists (State s' (transf_function f) (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs' m'); split.
-  eapply exec_Icond; eauto.
-  apply eval_condition_lessdef with (rs##args) m; auto. apply regs_lessdef_regs; auto.
+  DStep_tac. eapply exec_Icond; eauto.
+  apply eval_condition_wrapper_lessdef with (rs##args) m; auto. apply regs_lessdef_regs; auto.
   constructor; auto.
 
 - (* jumptable *)
   TransfInstr.
   left. exists (State s' (transf_function f) (Vptr sp0 Ptrofs.zero) pc' rs' m'); split.
-  eapply exec_Ijumptable; eauto.
+  DStep_tac. eapply exec_Ijumptable; eauto.
   generalize (RLD arg). rewrite H0. intro. inv H2. auto.
   constructor; auto.
 
@@ -507,7 +528,7 @@ Proof.
   exploit Mem.free_parallel_extends; eauto. intros [m'1 [FREE EXT]].
   TransfInstr.
   left. exists (Returnstate s' (regmap_optget or Vundef rs') m'1); split.
-  apply exec_Ireturn; auto. rewrite stacksize_preserved; auto.
+  DStep_tac. apply exec_Ireturn; auto. rewrite stacksize_preserved; auto.
   constructor. auto.
   destruct or; simpl. apply RLD. constructor.
   auto.
@@ -537,15 +558,16 @@ Proof.
     unfold transf_function. destruct (zeq (fn_stacksize f) 0); auto.
   destruct H0 as [EQ1 [EQ2 EQ3]].
   left. econstructor; split.
-  simpl. eapply exec_function_internal; eauto. rewrite EQ1; eauto.
+  DStep_tac. simpl. eapply exec_function_internal; eauto. rewrite EQ1; eauto.
   rewrite EQ2. rewrite EQ3. constructor; auto.
   apply regs_lessdef_init_regs. auto.
 
 - (* external call *)
+  unfold is_internal in INT. ss. des_ifs.
   exploit external_call_mem_extends; eauto.
   intros [res' [m2' [A [B [C D]]]]].
   left. exists (Returnstate s' res' m2'); split.
-  simpl. econstructor; eauto.
+  DStep_tac. simpl. econstructor; eauto.
   eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   constructor; auto.
 
@@ -553,7 +575,7 @@ Proof.
   inv H2.
 + (* synchronous return in both programs *)
   left. econstructor; split.
-  apply exec_return.
+  DStep_tac. apply exec_return.
   constructor; auto. apply set_reg_lessdef; auto.
 + (* return instr in source program, eliminated because of tailcall *)
   right. split. unfold measure. simpl length.
@@ -565,6 +587,80 @@ Proof.
   rewrite Regmap.gss. auto.
 Qed.
 
+Lemma match_states_bsim
+      s1 (EXT: is_external ge s1)
+      s2 t s2' (STEPTGT: Step tsem s2 t s2')
+      (MATCH: match_states s1 s2)
+      (SAFESRC: safe sem s1) :
+    (exists s1', Step sem s1 t s1' /\ match_states s1' s2')
+    \/ (~ trace_intact t /\ exists s1'' t', Star sem s1 t' s1'' /\ exists tl, t' = (trace_cut_pterm t) ** tl).
+Proof.
+  assert (SEQUIV: Senv.equiv tge ge) by (symmetry; apply senv_preserved).
+  unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+  { inv SAFESRC. inv MATCH. inv H2; inv H4. inv STEPTGT. }
+  unfold is_external in *. des_ifs.
+  (* builtin *)
+  - i. inv MATCH; clarify; EliminatedInstr.
+    TransfInstr. inv STEPTGT; clarify. inv SAFESRC; clarify.
+    exploit eval_builtin_args_lessdef; try eapply RLD; eauto. i. des.
+    exploit eval_builtin_args_preserved. eapply SEQUIV. apply H8. i.
+    exploit eval_builtin_args_determ. eapply H. eapply H1. i. subst.
+    exploit external_call_mem_extends_backward; try eapply H9; eauto. i; des.
+    + exploit external_call_symbols_preserved. apply SEQUIV. eapply CALLSRC. i.
+      exploit exec_Ibuiltin; try eapply H2; eauto. i.
+      left. esplits; eauto.
+      econstructor; eauto. apply set_res_lessdef; auto.
+    + exploit external_call_symbols_preserved. apply senv_preserved. eapply H12. i.
+      exploit UBSRC; eauto. contradiction.
+    + exploit external_call_symbols_preserved. apply SEQUIV. eapply CALLSRC. i.
+      right. esplits; eauto. eapply star_one. econs; eauto.
+  (* external *)
+  - i. inv MATCH; clarify; EliminatedInstr.
+    inv STEPTGT; clarify. inv SAFESRC; clarify.
+    exploit external_call_symbols_preserved. apply SEQUIV. eauto. i.
+    exploit external_call_mem_extends_backward; eauto. i; des; cycle 1; clarify.
+    + exploit UBSRC; eauto. contradiction.
+    + right. esplits; eauto. eapply star_one. econs; eauto.
+    + left. esplits; eauto. econs; eauto. constructor; eauto.
+Qed.
+
+Lemma match_states_xsim st_src0 st_tgt0 gmtgt
+    (MATCH: match_states st_src0 st_tgt0) :
+  xsim (RTL.semantics prog) (RTL.semantics tprog) gmtgt lt (measure st_src0)%nat st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold.
+  destruct (classic (is_external ge st_src0)); cycle 1.
+  (* not external *)
+  - left. econs. econs.
+    + i. exploit transf_step_correct; eauto. i. des.
+      * esplits; eauto;[eapply tr_rel_refl; eapply ev_rel_refl|].
+        left. split; [eapply plus_one; eauto|]. eapply semantics_receptive_at; auto.
+      * esplits;[eapply tr_rel_refl; eapply ev_rel_refl| |].
+        { right. esplits; eauto. }
+        { right. eapply CIH; eauto. }
+    + ii. eapply final_state_determ; eauto. inv FINALSRC. inv MATCH. inv H3; inv H5. econs.
+  (* external *)
+  - right. econs. i. econs.
+    + i. exploit match_states_bsim; eauto. i. des.
+      * left. esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl|].
+        left. eapply plus_one. eauto.
+      * right. esplits; eauto. subst. eapply tr_rel_refl. eapply ev_rel_refl.
+    + i. unfold is_external in *. des_ifs; inv FINALTGT; inv MATCH; EliminatedInstr; ss.
+    (* progress *)
+    + i. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify; [inv SAFESRC; ss|].
+      right. inv MATCH; EliminatedInstr; ss; des_ifs; inv SAFESRC; unfold ge in *; clarify.
+      * TransfInstr.
+        exploit eval_builtin_args_lessdef; try eapply RLD; eauto. i. des.
+        exploit eval_builtin_args_preserved. eapply senv_preserved. apply H0. i.
+        exploit external_call_symbols_preserved. apply senv_preserved. eauto. i.
+        exploit external_call_mem_extends_backward_progress; eauto. i. des.
+        esplits. eapply exec_Ibuiltin; eauto.
+      * exploit external_call_symbols_preserved. apply senv_preserved. eauto. i.
+        exploit external_call_mem_extends_backward_progress; eauto. ss. i. des.
+        exploit exec_function_external; eauto.
+Qed.
+
 Lemma transf_initial_states:
   forall st1, initial_state prog st1 ->
   exists st2, initial_state tprog st2 /\ match_states st1 st2.
@@ -587,18 +683,66 @@ Proof.
   intros. inv H0. inv H. inv H5. inv H3. constructor.
 Qed.
 
+Lemma non_static_equiv l:
+  Genv.non_static_glob (Genv.globalenv prog) l = Genv.non_static_glob (Genv.globalenv tprog) l.
+Proof.
+  Local Transparent ge tge.
+  induction l; ss.
+  specialize senv_preserved. ss. i. inv H. inv H1.
+  unfold ge, tge, fundef in *.
+  specialize (H a).
+  unfold Senv.public_symbol in H. ss. erewrite H.
+  specialize (H0 a). rewrite <- H0. erewrite IHl; eauto.
+Qed.
+
+Lemma transf_initial_capture S1 S2 S2'
+    (INITSRC: initial_state prog S1)
+    (INITTGT: initial_state tprog S2)
+    (MATCH: match_states S1 S2)
+    (CAPTGT: glob_capture tprog S2 S2'):
+  exists S1', glob_capture prog S1 S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (concrete_snapshot ge S1') (concrete_snapshot tge S2').
+Proof.
+  specialize senv_preserved. intros SENVEQ.
+  inv CAPTGT. ss. rename m' into m2'.
+  rewrite Genv.globalenv_public in CAPTURE. erewrite <- same_public in CAPTURE; eauto.
+  inv MATCH. inv H5. (* dup INITSRC. inv INITSRC0. inv H3. *)
+  exploit non_static_equiv. instantiate (1:=prog_public prog). intros EQUIV.
+  assert (exists m1', Genv.capture_init_mem m0 (Genv.non_static_glob (Genv.globalenv prog) (prog_public prog)) m1' /\
+                     Mem.extends m1' m2').
+  { clear INITSRC INITTGT. rewrite <- EQUIV in CAPTURE. clear EQUIV. inv CAPTURE.
+    remember (Genv.non_static_glob (Genv.globalenv prog) (prog_public prog)) as l. clear Heql.
+    clear SENVEQ. move l before f0. revert_until f0.
+    induction l; ss; i.
+    { inv CAP. esplits; eauto. econs. econs. }
+    inv CAP. exploit Mem.capture_extends_backward; eauto. i. des.
+    exploit IHl; eauto. i. des. inv H. esplits; eauto. econs. econs; eauto. }
+  des. inv INITSRC. esplits; eauto.
+  - econs. eauto. rewrite Genv.globalenv_public. eauto.
+  - econs; eauto.
+  - ii. unfold concrete_snapshot in *. inv SENVEQ. des. erewrite H4, H2. des_ifs; ss.
+    eapply Mem.mext_concrete; eauto. eapply Mem.concrete_valid; eauto.
+Qed.
 
 (** The preservation of the observable behavior of the program then
   follows. *)
 
 Theorem transf_program_correct:
-  forward_simulation (RTL.semantics prog) (RTL.semantics tprog).
+  mixed_simulation (RTL.semantics prog) (RTL.semantics tprog).
 Proof.
-  eapply forward_simulation_opt with (measure := measure); eauto.
-  apply senv_preserved.
-  eexact transf_initial_states.
-  eexact transf_final_states.
-  exact transf_step_correct.
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (S a). lia.
+  - econs. i. exploit transf_initial_states; eauto. i. des.
+    exists st2. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. inversion INITSRC; subst. inversion H0; subst.
+      inv H10. inv H11. exploit transf_initial_capture; eauto. i. des.
+      esplits; eauto. apply match_states_xsim; auto.
+  - i. apply senv_preserved.
 Qed.
 
 End PRESERVATION.
diff --git a/backend/Tunnelingproof.v b/backend/Tunnelingproof.v
index 68913fc9..3daf3f43 100644
--- a/backend/Tunnelingproof.v
+++ b/backend/Tunnelingproof.v
@@ -15,9 +15,11 @@
 Require Import FunInd.
 Require Import Coqlib Maps UnionFind.
 Require Import AST Linking.
+Require Import Simulation LTLD Classical PointerOp CoqlibC.
 Require Import Values Memory Events Globalenvs Smallstep.
 Require Import Op Locations LTL.
 Require Import Tunneling.
+From Paco Require Import paco.
 
 Definition match_prog (p tp: program) :=
   match_program (fun ctx f tf => tf = tunnel_fundef f) eq p tp.
@@ -265,6 +267,9 @@ Hypothesis TRANSL: match_prog prog tprog.
 Let ge := Genv.globalenv prog.
 Let tge := Genv.globalenv tprog.
 
+Let sem := semantics prog.
+Let tsem := semantics tprog.
+
 Lemma functions_translated:
   forall v f,
   Genv.find_funct ge v = Some f ->
@@ -286,6 +291,9 @@ Lemma senv_preserved:
   Senv.equiv ge tge.
 Proof (Genv.senv_transf TRANSL).
 
+Lemma same_public: prog_public prog = prog_public tprog.
+Proof. inv TRANSL. des; eauto. Qed.
+
 Lemma sig_preserved:
   forall f, funsig (tunnel_fundef f) = funsig f.
 Proof.
@@ -474,16 +482,20 @@ Proof.
 Qed.
 
 Lemma find_function_translated:
-  forall ros ls tls fd,
+  forall ros ls tls fd m1 m2 (MEM: Mem.extends m1 m2),
   locmap_lessdef ls tls ->
-  find_function ge ros ls = Some fd ->
-  find_function tge ros tls = Some (tunnel_fundef fd).
+  find_function ge (ros_to_vos m1 ros ls) ls = Some fd ->
+  find_function tge (ros_to_vos m2 ros tls) tls = Some (tunnel_fundef fd).
 Proof.
   intros. destruct ros; simpl in *.
 - assert (E: tls (R m) = ls (R m)).
-  { exploit Genv.find_funct_inv; eauto. intros (b & EQ). 
-    generalize (H (R m)). rewrite EQ. intros LD; inv LD. auto. }
-  rewrite E. apply functions_translated; auto.
+  { des_ifs; eauto.
+    { generalize (H (R m)). i. rewrite Heq in H1. inv H1. ss. }
+    generalize (H (R m)). rewrite Heq. intros LD; inv LD. auto. }
+  ss. destruct (ls (R m)) eqn:RSV; try by ss.
++ des_ifs_safe. erewrite Mem.denormalize_extends; eauto.
+  apply functions_translated; auto.
++ des_ifs_safe. apply functions_translated; auto.
 - rewrite symbols_preserved. destruct (Genv.find_symbol ge i); inv H0. 
   apply function_ptr_translated; auto.
 Qed.
@@ -531,20 +543,21 @@ Proof.
 Qed.
 
 Lemma tunnel_step_correct:
-  forall st1 t st2, step ge st1 t st2 ->
+  forall st1 t st2, IStep sem st1 t st2 ->
   forall st1' (MS: match_states st1 st1'),
-  (exists st2', step tge st1' t st2' /\ match_states st2 st2')
+  (exists st2', DStep tsem st1' t st2' /\ match_states st2 st2')
   \/ (measure st2 < measure st1 /\ t = E0 /\ match_states st2 st1')%nat.
 Proof.
+  destruct 1. generalize dependent st2. rename H into INT.
   induction 1; intros; try inv MS.
 
 - (* entering a block *)
   assert (DEFAULT: branch_target f pc = pc ->
     (exists st2' : state,
-     step tge (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0 st2'
+     DStep tsem (State ts (tunnel_function f) sp (branch_target f pc) tls tm) E0 st2'
      /\ match_states (Block s f sp bb rs m) st2')).
   { intros. rewrite H0. econstructor; split.
-    econstructor. simpl. rewrite PTree.gmap1. rewrite H. simpl. eauto.
+    DStep_tac. econstructor. simpl. rewrite PTree.gmap1. rewrite H. simpl. eauto.
     econstructor; eauto. }
 
   generalize (record_gotos_correct f pc). rewrite H.
@@ -561,66 +574,67 @@ Proof.
   rewrite B. econstructor; eauto. congruence.
 
 - (* Lop *)
-  exploit eval_operation_lessdef. apply reglist_lessdef; eauto. eauto. eauto. 
+  exploit eval_operation_wrapper_lessdef. apply reglist_lessdef; eauto. eauto. eauto.
   intros (tv & EV & LD).
   left; simpl; econstructor; split.
-  eapply exec_Lop with (v := tv); eauto.
-  rewrite <- EV. apply eval_operation_preserved. exact symbols_preserved.
+  DStep_tac. eapply exec_Lop with (v := tv); eauto.
+  rewrite <- EV. apply eval_operation_wrapper_preserved. exact symbols_preserved.
   econstructor; eauto using locmap_set_lessdef, locmap_undef_regs_lessdef.
 - (* Lload *)
-  exploit eval_addressing_lessdef. apply reglist_lessdef; eauto. eauto. 
+  exploit eval_addressing_lessdef. apply reglist_lessdef; eauto. eauto.
   intros (ta & EV & LD).
-  exploit Mem.loadv_extends. eauto. eauto. eexact LD. 
+  exploit Mem.loadv_extends. eauto. eauto. eexact LD.
   intros (tv & LOAD & LD').
   left; simpl; econstructor; split.
-  eapply exec_Lload with (a := ta).
+  DStep_tac. eapply exec_Lload with (a := ta).
   rewrite <- EV. apply eval_addressing_preserved. exact symbols_preserved.
   eauto. eauto.
   econstructor; eauto using locmap_set_lessdef, locmap_undef_regs_lessdef.
 - (* Lgetstack *)
   left; simpl; econstructor; split.
-  econstructor; eauto.
+  DStep_tac. econstructor; eauto.
   econstructor; eauto using locmap_set_lessdef, locmap_undef_regs_lessdef.
 - (* Lsetstack *)
   left; simpl; econstructor; split.
-  econstructor; eauto.
+  DStep_tac. econstructor; eauto.
   econstructor; eauto using locmap_set_lessdef, locmap_undef_regs_lessdef.
 - (* Lstore *)
-  exploit eval_addressing_lessdef. apply reglist_lessdef; eauto. eauto. 
+  exploit eval_addressing_lessdef. apply reglist_lessdef; eauto. eauto.
   intros (ta & EV & LD).
-  exploit Mem.storev_extends. eauto. eauto. eexact LD. apply LS.  
+  exploit Mem.storev_extends. eauto. eauto. eexact LD. apply LS.
   intros (tm' & STORE & MEM').
   left; simpl; econstructor; split.
-  eapply exec_Lstore with (a := ta).
+  DStep_tac. eapply exec_Lstore with (a := ta).
   rewrite <- EV. apply eval_addressing_preserved. exact symbols_preserved.
   eauto. eauto.
   econstructor; eauto using locmap_undef_regs_lessdef.
 - (* Lcall *)
   left; simpl; econstructor; split.
-  eapply exec_Lcall with (fd := tunnel_fundef fd); eauto.
+  DStep_tac. eapply exec_Lcall with (fd := tunnel_fundef fd); eauto.
   eapply find_function_translated; eauto.
   rewrite sig_preserved. auto.
   econstructor; eauto.
   constructor; auto.
   constructor; auto.
 - (* Ltailcall *)
-  exploit Mem.free_parallel_extends. eauto. eauto. intros (tm' & FREE & MEM'). 
+  exploit Mem.free_parallel_extends. eauto. eauto. intros (tm' & FREE & MEM').
   left; simpl; econstructor; split.
-  eapply exec_Ltailcall with (fd := tunnel_fundef fd); eauto.
+  DStep_tac. eapply exec_Ltailcall with (fd := tunnel_fundef fd); eauto.
   eapply find_function_translated; eauto using return_regs_lessdef, match_parent_locset.
   apply sig_preserved.
   econstructor; eauto using return_regs_lessdef, match_parent_locset.
 - (* Lbuiltin *)
+  unfold is_internal in INT; ss.
   exploit eval_builtin_args_lessdef. eexact LS. eauto. eauto. intros (tvargs & EVA & LDA).
   exploit external_call_mem_extends; eauto. intros (tvres & tm' & A & B & C & D).
   left; simpl; econstructor; split.
-  eapply exec_Lbuiltin; eauto.
-  eapply eval_builtin_args_preserved with (ge1 := ge); eauto. exact symbols_preserved. 
+  DStep_tac. eapply exec_Lbuiltin; eauto.
+  eapply eval_builtin_args_preserved with (ge1 := ge); eauto. exact symbols_preserved.
   eapply external_call_symbols_preserved. apply senv_preserved. eauto.
   econstructor; eauto using locmap_setres_lessdef, locmap_undef_regs_lessdef.
 - (* Lbranch (preserved) *)
   left; simpl; econstructor; split.
-  eapply exec_Lbranch; eauto.
+  DStep_tac. eapply exec_Lbranch; eauto.
   fold (branch_target f pc). econstructor; eauto.
 - (* Lbranch (eliminated) *)
   right; split. simpl. lia. split. auto. constructor; auto.
@@ -630,12 +644,12 @@ Proof.
   set (s1 := U.repr (record_gotos f) pc1). set (s2 := U.repr (record_gotos f) pc2).
   destruct (peq s1 s2).
 + left; econstructor; split.
-  eapply exec_Lbranch.
+  DStep_tac. eapply exec_Lbranch.
   set (pc := if b then pc1 else pc2).
   replace s1 with (branch_target f pc) by (unfold pc; destruct b; auto).
   constructor; eauto using locmap_undef_regs_lessdef_1.
 + left; econstructor; split.
-  eapply exec_Lcond; eauto. eapply eval_condition_lessdef; eauto using reglist_lessdef.
+  DStep_tac. eapply exec_Lcond; eauto. eapply eval_condition_wrapper_lessdef; eauto using reglist_lessdef.
   destruct b; econstructor; eauto using locmap_undef_regs_lessdef.
 - (* Lcond (eliminated) *)
   right; split. simpl. destruct b; lia.
@@ -648,31 +662,32 @@ Proof.
   assert (tls (R arg) = Vint n).
   { generalize (LS (R arg)); rewrite H; intros LD; inv LD; auto. }
   left; simpl; econstructor; split.
-  eapply exec_Ljumptable.
-  eauto. rewrite list_nth_z_map. change U.elt with node. rewrite H0. reflexivity. eauto.
+  DStep_tac. eapply exec_Ljumptable.
+  eauto. rewrite Coqlib.list_nth_z_map. change U.elt with node. rewrite H0. reflexivity. eauto.
   econstructor; eauto using locmap_undef_regs_lessdef.
 - (* Lreturn *)
-  exploit Mem.free_parallel_extends. eauto. eauto. intros (tm' & FREE & MEM'). 
+  exploit Mem.free_parallel_extends. eauto. eauto. intros (tm' & FREE & MEM').
   left; simpl; econstructor; split.
-  eapply exec_Lreturn; eauto.
+  DStep_tac. eapply exec_Lreturn; eauto.
   constructor; eauto using return_regs_lessdef, match_parent_locset.
 - (* internal function *)
   exploit Mem.alloc_extends. eauto. eauto. apply Z.le_refl. apply Z.le_refl.
-  intros (tm' & ALLOC & MEM'). 
+  intros (tm' & ALLOC & MEM').
   left; simpl; econstructor; split.
-  eapply exec_function_internal; eauto.
+  DStep_tac. eapply exec_function_internal; eauto.
   simpl. econstructor; eauto using locmap_undef_regs_lessdef, call_regs_lessdef.
 - (* external function *)
+  unfold is_internal in INT; ss.
   exploit external_call_mem_extends; eauto using locmap_getpairs_lessdef.
   intros (tvres & tm' & A & B & C & D).
   left; simpl; econstructor; split.
-  eapply exec_function_external; eauto.
+  DStep_tac. eapply exec_function_external; eauto.
   eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   simpl. econstructor; eauto using locmap_setpair_lessdef, locmap_undef_caller_save_regs_lessdef.
 - (* return *)
   inv STK. inv H1.
   left; econstructor; split.
-  eapply exec_return; eauto.
+  DStep_tac. eapply exec_return; eauto.
   constructor; auto.
 Qed.
 
@@ -701,14 +716,141 @@ Proof.
   econstructor; eauto.
 Qed.
 
+Lemma match_states_bsim
+    s1 (EXT: is_external ge s1)
+    s2 t s2' (STEPTGT: Step tsem s2 t s2')
+    (MATCH: match_states s1 s2)
+    (SAFESRC: safe sem s1):
+  (exists s1', Step sem s1 t s1' /\ match_states s1' s2')
+\/ (~ trace_intact t /\ exists s1'' t', Star sem s1 t' s1'' /\ exists tl, t' = (trace_cut_pterm t) ** tl).
+Proof.
+  assert (SEQUIV: Senv.equiv tge ge) by (symmetry; apply senv_preserved).
+  unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; clarify.
+  { inv SAFESRC. inv MATCH. inv STEPTGT. inv STK. }
+  unfold is_external in *. des_ifs.
+  - i. inv MATCH; clarify. inv SAFESRC; clarify.
+    exploit eval_builtin_args_lessdef. eexact LS. eauto. eauto. intros (tvargs & EVA & LDA).
+    inv STEPTGT; clarify.
+    assert (HEQ: vargs0 = tvargs).
+    { exploit eval_builtin_args_preserved. eapply senv_preserved. eauto. i. ss.
+      unfold tge in *. exploit eval_builtin_args_determ. eapply H12. eapply H. eauto. }
+    subst. exploit external_call_mem_extends_backward; eauto. i. des; cycle 1.
+    + exfalso. eapply UBSRC. eapply external_call_symbols_preserved.
+      symmetry. eauto. eauto.
+    + right. esplits; eauto. eapply star_one. eapply exec_Lbuiltin; eauto.
+      eapply external_call_symbols_preserved. eauto. eauto.
+    + left. esplits. eapply exec_Lbuiltin; eauto.
+      eapply external_call_symbols_preserved. eauto. eauto.
+      econstructor; eauto using locmap_setres_lessdef, locmap_undef_regs_lessdef.
+  (* external *)
+  - i. inv MATCH; clarify. inv STEPTGT; clarify. inv SAFESRC; clarify.
+    exploit external_call_symbols_preserved. apply SEQUIV. eauto. i.
+    exploit external_call_mem_extends_backward; eauto using locmap_getpairs_lessdef.
+     i; des; cycle 1; clarify.
+    + exploit UBSRC; eauto. contradiction.
+    + right. esplits; eauto. eapply star_one. econs; eauto.
+    + left. esplits; eauto. econs; eauto.
+      econstructor; eauto using locmap_setpair_lessdef, locmap_undef_caller_save_regs_lessdef.
+Qed.
+
+Lemma match_states_xsim st_src0 st_tgt0 gmtgt
+    (MATCH: match_states st_src0 st_tgt0) :
+  xsim (LTL.semantics prog) (LTL.semantics tprog) gmtgt lt (measure st_src0)%nat st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold. destruct (classic (is_external ge st_src0)); cycle 1.
+  (* not external *)
+  - left. econs. econs.
+    + i. exploit tunnel_step_correct; eauto. i. des.
+      * esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl|].
+        left. split; [eapply plus_one|eapply semantics_receptive_at]; eauto.
+      * esplits; [eapply tr_rel_refl; eapply ev_rel_refl| |].
+        { right. esplits; eauto. }
+        { right. eapply CIH; eauto. }
+    + ii. eapply final_state_determ; eauto.
+      inv FINALSRC. inv MATCH. inv STK. eapply transf_final_states.
+      econs; eauto. econs. econs. eauto.
+  (* external *)
+  - right. econs. i. econs.
+    + i. exploit match_states_bsim; eauto. i. des.
+      * left. esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl|].
+        left. eapply plus_one. eauto.
+      * right. esplits; eauto. subst. eapply tr_rel_refl. eapply ev_rel_refl.
+    + i. unfold is_external in *. des_ifs; inv FINALTGT; inv MATCH; ss.
+    (* progress *)
+    + i. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+      { inv SAFESRC; ss. }
+      right. inv MATCH; ss; des_ifs; inv SAFESRC; unfold ge in *; clarify.
+      * exploit eval_builtin_args_lessdef; try eapply LS; eauto. i. des.
+        exploit eval_builtin_args_preserved. eapply senv_preserved. apply H0. i.
+
+        exploit external_call_symbols_preserved. apply senv_preserved. eauto. i.
+        exploit external_call_mem_extends_backward_progress; eauto. i. des.
+
+        esplits. eapply exec_Lbuiltin; eauto.
+      * exploit external_call_symbols_preserved. apply senv_preserved. eauto. i.
+        exploit external_call_mem_extends_backward_progress;
+        eauto using locmap_getpairs_lessdef. ss. i. des.
+        exploit exec_function_external; eauto.
+Qed.
+
+Lemma non_static_equiv l:
+  Genv.non_static_glob (Genv.globalenv prog) l = Genv.non_static_glob (Genv.globalenv tprog) l.
+Proof.
+  Local Transparent ge tge.
+  induction l; ss.
+  specialize senv_preserved. ss. i. inv H. inv H1.
+  unfold ge, tge, fundef in *.
+  specialize (H a).
+  unfold Senv.public_symbol in H. ss. erewrite H.
+  specialize (H0 a). rewrite <- H0. erewrite IHl; eauto.
+Qed.
+
+Lemma transf_initial_capture S1 S2 S2'
+    (INITSRC: initial_state prog S1)
+    (INITTGT: initial_state tprog S2)
+    (MATCH: match_states S1 S2)
+    (CAPTGT: glob_capture tprog S2 S2'):
+  exists S1', glob_capture prog S1 S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (concrete_snapshot ge S1') (concrete_snapshot tge S2').
+Proof.
+  specialize senv_preserved. intros SENVEQ.
+  inv CAPTGT. ss. rename m' into m2'.
+  rewrite Genv.globalenv_public in CAPTURE. erewrite <- same_public in CAPTURE; eauto.
+  inv MATCH. inv STK.
+  exploit non_static_equiv. instantiate (1:=prog_public prog). intros EQUIV.
+  assert (exists m1', Genv.capture_init_mem m0 (Genv.non_static_glob (Genv.globalenv prog) (AST.prog_public prog)) m1' /\
+                     Mem.extends m1' m2').
+  { clear INITSRC INITTGT. rewrite <- EQUIV in CAPTURE. clear EQUIV LS. inv CAPTURE.
+    remember (Genv.non_static_glob (Genv.globalenv prog) (prog_public prog)) as l. clear Heql.
+    clear SENVEQ. move l before f0. revert_until f0.
+    induction l; ss; i.
+    { inv CAP. esplits; eauto. econs. econs. }
+    inv CAP. exploit Mem.capture_extends_backward; eauto. i. des.
+    exploit IHl; eauto. i. des. inv H. esplits; eauto. econs. econs; eauto. }
+  des. esplits; eauto.
+  - inv INITSRC. econs. eauto. rewrite Genv.globalenv_public. eauto.
+  - econs; eauto. econs; eauto. econs.
+  - ii. unfold concrete_snapshot in *. inv SENVEQ. des. erewrite H3, H2. des_ifs; ss.
+    eapply Mem.mext_concrete; eauto. eapply Mem.concrete_valid; eauto.
+Qed.
+
 Theorem transf_program_correct:
-  forward_simulation (LTL.semantics prog) (LTL.semantics tprog).
+  mixed_simulation (LTL.semantics prog) (LTL.semantics tprog).
 Proof.
-  eapply forward_simulation_opt.
-  apply senv_preserved.
-  eexact transf_initial_states.
-  eexact transf_final_states.
-  eexact tunnel_step_correct.
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (1 + a)%nat. lia.
+  - econs. i. exploit transf_initial_states; eauto. i. des.
+    exists st2. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. inversion INITSRC; subst. inversion H0; subst.
+      inv STK. exploit transf_initial_capture; eauto. i. des.
+      exists (measure S1'); exists S1'. esplits; eauto. apply match_states_xsim; auto.
+  - i. apply senv_preserved.
 Qed.
 
 End PRESERVATION.
diff --git a/backend/Unusedglobproof.v b/backend/Unusedglobproof.v
index 3216ec50..fb0cfe02 100644
--- a/backend/Unusedglobproof.v
+++ b/backend/Unusedglobproof.v
@@ -14,9 +14,11 @@
 
 Require Import FSets Coqlib Maps Ordered Iteration Errors.
 Require Import AST Linking.
+Require Import CoqlibC Simulation RTLD Classical PointerOp.
 Require Import Integers Values Memory Globalenvs Events Smallstep.
 Require Import Op Registers RTL.
 Require Import Unusedglob.
+From Paco Require Import paco.
 
 Module ISF := FSetFacts.Facts(IS).
 Module ISP := FSetProperties.Properties(IS).
@@ -453,6 +455,10 @@ Let ge := Genv.globalenv p.
 Let tge := Genv.globalenv tp.
 Let pm := prog_defmap p.
 
+Let sem := semantics p.
+Let tsem := semantics tp.
+Let ev_rel2 := ev_rel_eq.
+
 Definition kept (id: ident) : Prop := IS.In id used.
 
 Lemma kept_closed:
@@ -776,7 +782,7 @@ Inductive match_states: state -> state -> Prop :=
                    (Returnstate ts tres tm).
 
 Lemma external_call_inject:
-  forall ef vargs m1 t vres m2 f m1' vargs',
+  forall ef vargs m1 t vres m2 f m1' vargs' (EXT: ~ is_external_ef ef),
   meminj_preserves_globals f ->
   external_call ef ge vargs m1 t vres m2 ->
   Mem.inject f m1 m1' ->
@@ -795,16 +801,25 @@ Proof.
 Qed.
 
 Lemma find_function_inject:
-  forall j ros rs fd trs,
+  forall j ros rs fd trs m tm (MEMINJ: Mem.inject j m tm),
   meminj_preserves_globals j ->
-  find_function ge ros rs = Some fd ->
+  find_function ge (ros_to_vos m ros rs) rs = Some fd ->
   match ros with inl r => regset_inject j rs trs | inr id => kept id end ->
-  find_function tge ros trs = Some fd /\ (forall id, ref_fundef fd id -> kept id).
+  find_function tge (ros_to_vos tm ros trs) trs = Some fd /\ (forall id, ref_fundef fd id -> kept id).
 Proof.
   intros. destruct ros as [r|id]; simpl in *.
-- exploit Genv.find_funct_inv; eauto. intros (b & R). rewrite R in H0.
+- destruct (rs # r) eqn:RSV; try by ss.
++ des_ifs_safe. specialize (H1 r). rewrite RSV in H1. inv H1. des_ifs_safe.
+  exploit Mem.denormalize_inject; eauto. i. des. rewrite DENOTGT. inv VINJ.
+  simpl in H0. des_ifs. rewrite Genv.find_funct_ptr_iff in H0.
+  exploit defs_inject; eauto. intros (A & B & C).
+  subst. rewrite e in H7. rewrite Ptrofs.add_zero_l in H7.
+  rewrite <- Genv.find_funct_ptr_iff in A. rewrite H7. ss.
++ assert (FUNC: Genv.find_funct ge (Vptr b i) = Some fd) by ss.
+  exploit Genv.find_funct_inv; eauto. intros (b' & R). rewrite R in H0.
+  clarify. clear H0. rename FUNC into H0.
   rewrite Genv.find_funct_find_funct_ptr in H0.
-  specialize (H1 r). rewrite R in H1. inv H1.
+  specialize (H1 r). rewrite RSV in H1. inv H1.
   rewrite Genv.find_funct_ptr_iff in H0.
   exploit defs_inject; eauto. intros (A & B & C).
   rewrite <- Genv.find_funct_ptr_iff in A.
@@ -835,7 +850,7 @@ Proof.
 - econstructor; eauto with barg.
 - econstructor; eauto with barg.
 - econstructor; eauto with barg.
-- simpl in H. exploit Mem.load_inject; eauto. rewrite Z.add_0_r.
+- unfold Mem.loadv in H. ss. simpl in H. exploit Mem.load_inject; eauto. rewrite Z.add_0_r.
   intros (v' & A & B). exists v'; auto with barg.
 - econstructor; split; eauto with barg. simpl. econstructor; eauto. rewrite Ptrofs.add_zero; auto.
 - assert (Val.inject j (Senv.symbol_address ge id ofs) (Senv.symbol_address tge id ofs)).
@@ -880,33 +895,41 @@ Proof.
 Qed.
 
 Theorem step_simulation:
-  forall S1 t S2, step ge S1 t S2 ->
+  forall S1 t S2, IStep sem S1 t S2 ->
   forall S1' (MS: match_states S1 S1'),
-  exists S2', step tge S1' t S2' /\ match_states S2 S2'.
+  exists S2', DStep tsem S1' t S2' /\ match_states S2 S2'.
 Proof.
+  destruct 1. generalize dependent S2. rename H into INT.
   induction 1; intros; inv MS.
 
 - (* nop *)
   econstructor; split.
+  DStep_tac.
   eapply exec_Inop; eauto.
   econstructor; eauto.
 
 - (* op *)
   assert (A: exists tv,
-               eval_operation tge (Vptr tsp Ptrofs.zero) op trs##args tm = Some tv
+               eval_operation_wrapper tge (Vptr tsp Ptrofs.zero) op trs##args tm = Some tv
             /\ Val.inject j v tv).
-  { apply eval_operation_inj with (ge1 := ge) (m1 := m) (sp1 := Vptr sp0 Ptrofs.zero) (vl1 := rs##args).
+  { simpl in H0. fold ge in H0.
+    eapply eval_operation_wrapper_inj with (* (ge := ge) *) (m1 := m) (sp1 := Vptr sp0 Ptrofs.zero) (vl1 := rs##args).
+    intros. eapply Mem.mi_perm; eauto. eapply Mem.mi_inj; eauto.
     intros; eapply Mem.valid_pointer_inject_val; eauto.
     intros; eapply Mem.weak_valid_pointer_inject_val; eauto.
     intros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.
     intros; eapply Mem.different_pointers_inject; eauto.
+    intros. eapply Mem.mi_src_concrete_private; eauto.
+    intros. eapply Mem.mi_mappedblocks; eauto.
+    intros. eapply Mem.mi_src_concrete_public; eauto.
+    intros. eapply Mem.mi_representable; eauto.
     intros. apply symbol_address_inject. eapply match_stacks_preserves_globals; eauto.
     apply KEPT. red. exists pc, (Iop op args res pc'); auto.
-    econstructor; eauto.
     apply regs_inject; auto.
+    econstructor; eauto.
     assumption. }
   destruct A as (tv & B & C).
-  econstructor; split. eapply exec_Iop; eauto.
+  econstructor; split. DStep_tac. eapply exec_Iop; eauto.
   econstructor; eauto. apply set_reg_inject; auto.
 
 - (* load *)
@@ -921,7 +944,7 @@ Proof.
     assumption. }
   destruct A as (ta & B & C).
   exploit Mem.loadv_inject; eauto. intros (tv & D & E).
-  econstructor; split. eapply exec_Iload; eauto.
+  econstructor; split. DStep_tac. eapply exec_Iload; eauto.
   econstructor; eauto. apply set_reg_inject; auto.
 
 - (* store *)
@@ -936,15 +959,16 @@ Proof.
     assumption. }
   destruct A as (ta & B & C).
   exploit Mem.storev_mapped_inject; eauto. intros (tm' & D & E).
-  econstructor; split. eapply exec_Istore; eauto.
+  econstructor; split. DStep_tac. eapply exec_Istore; eauto.
   econstructor; eauto.
 
 - (* call *)
   exploit find_function_inject.
+  eauto.
   eapply match_stacks_preserves_globals; eauto. eauto.
   destruct ros as [r|id]. eauto. apply KEPT. red. econstructor; econstructor; split; eauto. simpl; auto.
   intros (A & B).
-  econstructor; split. eapply exec_Icall; eauto.
+  econstructor; split. DStep_tac. eapply exec_Icall; eauto.
   econstructor; eauto.
   econstructor; eauto.
   change (Mem.valid_block m sp0). eapply Mem.valid_block_inject_1; eauto.
@@ -952,13 +976,13 @@ Proof.
   apply regs_inject; auto.
 
 - (* tailcall *)
-  exploit find_function_inject.
+  exploit find_function_inject. eauto.
   eapply match_stacks_preserves_globals; eauto. eauto.
   destruct ros as [r|id]. eauto. apply KEPT. red. econstructor; econstructor; split; eauto. simpl; auto.
   intros (A & B).
   exploit Mem.free_parallel_inject; eauto. rewrite ! Z.add_0_r. intros (tm' & C & D).
   econstructor; split.
-  eapply exec_Itailcall; eauto.
+  DStep_tac. eapply exec_Itailcall; eauto.
   econstructor; eauto.
   apply match_stacks_bound with stk tsp; auto.
   apply Plt_Ple.
@@ -968,6 +992,7 @@ Proof.
   apply regs_inject; auto.
 
 - (* builtin *)
+  unfold is_internal in INT. ss. rewrite H in INT.
   exploit eval_builtin_args_inject; eauto.
   eapply match_stacks_preserves_globals; eauto.
   intros. apply KEPT. red. econstructor; econstructor; eauto.
@@ -976,7 +1001,7 @@ Proof.
   eapply match_stacks_preserves_globals; eauto.
   intros (j' & tv & tm' & A & B & C & D & E & F & G).
   econstructor; split.
-  eapply exec_Ibuiltin; eauto.
+  DStep_tac. eapply exec_Ibuiltin; eauto.
   eapply match_states_regular with (j := j'); eauto.
   apply match_stacks_incr with j; auto.
   intros. exploit G; eauto. intros [U V].
@@ -986,22 +1011,22 @@ Proof.
   apply set_res_inject; auto. apply regset_inject_incr with j; auto.
 
 - (* cond *)
-  assert (C: eval_condition cond trs##args tm = Some b).
-  { eapply eval_condition_inject; eauto. apply regs_inject; auto. }
+  assert (C: eval_condition_wrapper cond trs##args tm = Some b).
+  { eapply eval_condition_wrapper_inject; eauto. apply regs_inject; auto. }
   econstructor; split.
-  eapply exec_Icond with (pc' := if b then ifso else ifnot); eauto.
+  DStep_tac. eapply exec_Icond with (pc' := if b then ifso else ifnot); eauto.
   econstructor; eauto.
 
 - (* jumptbl *)
   generalize (REGINJ arg); rewrite H0; intros INJ; inv INJ.
   econstructor; split.
-  eapply exec_Ijumptable; eauto.
+  DStep_tac. eapply exec_Ijumptable; eauto.
   econstructor; eauto.
 
 - (* return *)
   exploit Mem.free_parallel_inject; eauto. rewrite ! Z.add_0_r. intros (tm' & C & D).
   econstructor; split.
-  eapply exec_Ireturn; eauto.
+  DStep_tac. eapply exec_Ireturn; eauto.
   econstructor; eauto.
   apply match_stacks_bound with stk tsp; auto.
   apply Plt_Ple.
@@ -1022,16 +1047,16 @@ Proof.
     subst b1. rewrite F in H1; inv H1. split; apply Ple_refl.
     rewrite G in H1 by auto. congruence. }
   econstructor; split.
-  eapply exec_function_internal; eauto.
+  DStep_tac. eapply exec_function_internal; eauto.
   eapply match_states_regular with (j := j'); eauto.
   apply init_regs_inject; auto. apply val_inject_list_incr with j; auto.
 
 - (* external function *)
-  exploit external_call_inject; eauto.
+  exploit external_call_inject; eauto. ss.
   eapply match_stacks_preserves_globals; eauto.
   intros (j' & tres & tm' & A & B & C & D & E & F & G).
   econstructor; split.
-  eapply exec_function_external; eauto.
+  DStep_tac. eapply exec_function_external; eauto.
   eapply match_states_return with (j := j'); eauto.
   apply match_stacks_bound with (Mem.nextblock m) (Mem.nextblock tm).
   apply match_stacks_incr with j; auto.
@@ -1042,7 +1067,7 @@ Proof.
 
 - (* return *)
   inv STACKS. econstructor; split.
-  eapply exec_return.
+  DStep_tac. eapply exec_return.
   econstructor; eauto. apply set_reg_inject; auto.
 Qed.
 
@@ -1193,6 +1218,8 @@ Proof.
   apply Q2 in H0. destruct H0. subst.
   left. apply Mem.perm_cur. eapply Mem.perm_implies; eauto.
   apply P1. lia.
+- rewrite Genv.init_mem_logical with (b:=b1) (m:=m) (p:=p) in CONCRETE; clarify.
+- apply Genv.init_mem_logical with (b:=b) (m:=m) (p:=p). assumption.
 Qed.
 
 End INIT_MEM.
@@ -1252,21 +1279,184 @@ Proof.
   intros. inv H0. inv H. inv STACKS. inv RESINJ. constructor.
 Qed.
 
+Lemma match_states_bsim
+      s1 (EXT: is_external ge s1)
+      s2 t s2' (STEPTGT: Step tsem s2 t s2')
+      (MATCH: match_states s1 s2)
+      (SAFESRC: safe sem s1) :
+    (exists s1', Step sem s1 t s1' /\ match_states s1' s2')
+  \/ (~ trace_intact t /\ exists s1'' t', Star sem s1 t' s1'' /\ exists tl, t' = (trace_cut_pterm t) ** tl).
+Proof.
+  unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+  { inv SAFESRC; inv EXT. }
+  unfold is_external in *. des_ifs; i; inv MATCH.
+  (* builtin *)
+  - inv SAFESRC; ss; clarify. inv STEPTGT; clarify. 
+    exploit eval_builtin_args_inject; eauto.
+    eapply match_stacks_preserves_globals; eauto.
+    intros. apply KEPT. red. econstructor; econstructor; eauto. i. des.
+    exploit eval_builtin_args_determ; [eapply H11|eapply H|]. i. subst.
+    exploit external_call_mem_inject_gen_backward; try apply MEMINJ; eauto.
+    eapply globals_symbols_inject; eauto.
+    eapply match_stacks_preserves_globals; eauto. i; des; cycle 1.
+    { exploit UBSRC; eauto. i; ss. }
+    { right. splits; auto. esplits; eauto. eapply star_one. eapply exec_Ibuiltin; eauto. }
+    left. esplits.
+    + eapply exec_Ibuiltin; eauto.
+    + eapply match_states_regular with (j := f'); eauto.
+      apply match_stacks_incr with j; auto.
+      intros. exploit INJSEP; eauto. intros [P Q].
+      assert (Mem.valid_block m sp0) by (eapply Mem.valid_block_inject_1; eauto).
+      assert (Mem.valid_block tm tsp) by (eapply Mem.valid_block_inject_2; eauto).
+      unfold Mem.valid_block in *; extlia.
+      eapply set_res_inject; eauto.
+      eapply regset_inject_incr; eauto.
+  (* external call *)
+  - inv SAFESRC; ss; clarify; ss. inv STEPTGT.
+    exploit external_call_mem_inject_gen_backward; try apply MEMINJ; eauto.
+    eapply globals_symbols_inject; eauto.
+    eapply match_stacks_preserves_globals; eauto. i; des; cycle 1.
+    { exploit UBSRC; eauto. i; ss. }
+    { right. splits; auto. esplits; eauto.
+      eapply star_one. eapply exec_function_external. eauto. }
+    left. esplits.
+    + eapply exec_function_external. eauto.
+    + eapply match_states_return with (j := f'); eauto.
+      apply match_stacks_bound with (Mem.nextblock m) (Mem.nextblock tm).
+      apply match_stacks_incr with j; auto.
+      intros. exploit INJSEP; eauto. intros [P Q].
+      unfold Mem.valid_block in *; extlia.
+      eapply external_call_nextblock; eauto.
+      eapply external_call_nextblock; eauto.
+Qed.
+
+Lemma non_static_equiv l (KEPT: forall i, In i l -> kept i):
+  Forall2 (fun b b' => init_meminj b = Some (b', 0)) (Genv.non_static_glob (Genv.globalenv p) l) (Genv.non_static_glob (Genv.globalenv tp) l).
+Proof.
+  induction l; ss.
+  destruct (Genv.find_symbol (Genv.globalenv p) a) eqn:FS1; cycle 1.
+  - destruct (Genv.find_symbol (Genv.globalenv tp) a) eqn:FS2.
+    2:{ unfold Genv.public_symbol. des_ifs. eapply IHl. ii. eapply KEPT; eauto. }
+    exploit transform_find_symbol_2; eauto. unfold ge. i. des; clarify.
+  - exploit transform_find_symbol_1; eauto. unfold tge. i. des.
+    rewrite H. unfold Genv.public_symbol. rewrite FS1, H.
+    do 2 erewrite Genv.globalenv_public. erewrite <- match_prog_public; eauto.
+    des_ifs; eauto. econs; eauto.
+    eapply init_meminj_eq; eauto.
+Qed.
+
+Lemma transf_initial_capture f m1 m2 S2'
+    (INITSRC: RTL.initial_state p (Callstate [] f [] m1))
+    (INITTGT: RTL.initial_state tp (Callstate [] f [] m2))
+    (INJ: Mem.inject init_meminj m1 m2)
+    (MATCH: match_states (Callstate [] f [] m1) (Callstate [] f [] m2))
+    (CAPTGT: RTL.glob_capture tp (Callstate [] f [] m2) S2'):
+  exists S1', RTL.glob_capture p (Callstate [] f [] m1) S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (concrete_snapshot ge S1') (concrete_snapshot tge S2').
+Proof.
+  inv CAPTGT. ss. rename m' into m2'.
+  rewrite Genv.globalenv_public in CAPTURE. erewrite match_prog_public in CAPTURE; eauto.
+  specialize (non_static_equiv (prog_public p)). i. exploit H; try eapply kept_public.
+  intros EQUIV. clear H.
+  inv MATCH. inv STACKS. inv ARGINJ.
+  assert (exists m1', Genv.capture_init_mem m1 (Genv.non_static_glob (Genv.globalenv p) (prog_public p)) m1' /\
+                     Mem.inject init_meminj m1' m2').
+  { remember (prog_public p) as l. clear Heql. clear - INJ EQUIV CAPTURE.
+    ginduction EQUIV; ss; ii.
+    - exists m1. inv CAPTURE. inv CAP. esplits; eauto. econs. econs.
+    - inv CAPTURE. inv CAP.
+      exploit Mem.capture_inject_backward; try eapply INJ; eauto.
+      { instantiate (2:=addr). instantiate (1:= m0). rewrite Z.sub_0_r. eauto. }
+      i. des. exploit IHEQUIV.
+      eapply MEM. econs. eauto. i. des. esplits; eauto. inv H0. econs. econs; eauto. }
+  des. esplits; eauto.
+  - econs; eauto. rewrite Genv.globalenv_public. eauto.
+  - econs; eauto. econs.
+    { eapply init_meminj_preserves_globals. }
+    { inv H2. eapply Mem.capture_list_nextblock in CAP. rewrite <- CAP. eauto. }
+    { inv CAPTURE. eapply Mem.capture_list_nextblock in CAP. rewrite <- CAP. eauto. }
+  - unfold concrete_snapshot. r. i.
+    destruct (Senv.find_symbol ge id) eqn:FS1; cycle 1; [exfalso; des_ifs|].
+    destruct (Senv.public_symbol ge id) eqn:PS1; clarify.
+    assert (PUB: In id (prog_public p)).
+    { unfold Senv.public_symbol in PS1. ss. unfold Genv.public_symbol in PS1. des_ifs.
+      unfold ge in PS1. rewrite Genv.globalenv_public in PS1.
+      destruct in_dec in PS1; ss. }
+    exploit kept_public; eauto. intros PKEPT.
+    exploit transform_find_symbol_1; eauto.
+    { unfold Senv.find_symbol in FS1. ss. eauto. }
+    i. des.
+    exploit globals_symbols_inject. apply init_meminj_preserves_globals. intros [A [B [C D]]].
+    rewrite A. rewrite PS1. unfold Senv.find_symbol. ss. rewrite H5.
+    exploit Mem.mi_src_concrete_public; [eapply H3| |eapply H4|].
+    { exploit C. eauto. eauto. i. des. clarify. eauto. }
+    i. rewrite H6. f_equal. lia.
+Qed.
+
+
+Lemma match_states_xsim st_src0 st_tgt0 gmtgt
+    (MATCH: match_states st_src0 st_tgt0) :
+  xsim (semantics p) (semantics tp) gmtgt lt 0%nat st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold. destruct (classic (is_external ge st_src0)); cycle 1.
+  (* not external *)
+  - left. econs. econs.
+    + i. exploit step_simulation; eauto. i. des; esplits; eauto;
+      [eapply tr_rel_refl; eapply ev_rel_refl|].
+      left. split; [eapply plus_one|eapply semantics_receptive_at]; eauto.
+    + ii. eapply final_state_determ; eauto.
+      inv FINALSRC. inv MATCH. inv STACKS. inv RESINJ. econs.
+  (* external *)
+  - right. econs. i. econs.
+    + i. exploit match_states_bsim; eauto. i. des.
+      * left. esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl|].
+        left. eapply plus_one. eauto.
+      * right. esplits; eauto. subst. eapply tr_rel_refl. eapply ev_rel_refl. 
+    + i. inv FINALTGT; inv MATCH; ss.
+    + i. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify; [inv SAFESRC; ss|].
+      right. inv MATCH; ss; des_ifs; inv SAFESRC; unfold ge in *; clarify.
+      * exploit eval_builtin_args_inject; eauto.
+        eapply match_stacks_preserves_globals; eauto.
+        intros. apply KEPT. red. econstructor; econstructor; eauto.
+        intros (vargs' & P & Q).
+        exploit external_call_mem_inject_gen_backward_progress; eauto.
+        eapply globals_symbols_inject; eauto.
+        eapply match_stacks_preserves_globals; eauto. i. des.
+        esplits. eapply exec_Ibuiltin; eauto.
+      * exploit external_call_mem_inject_gen_backward_progress; eauto.
+        eapply globals_symbols_inject; eauto.
+        eapply match_stacks_preserves_globals; eauto. i. des.
+        esplits. eapply exec_function_external; eauto.
+Qed.
+
 Lemma transf_program_correct_1:
-  forward_simulation (semantics p) (semantics tp).
-Proof.
-  intros.
-  eapply forward_simulation_step.
-  exploit globals_symbols_inject. apply init_meminj_preserves_globals. intros [A B]. exact A.
-  eexact transf_initial_states.
-  eexact transf_final_states.
-  eexact step_simulation.
+  mixed_simulation (semantics p) (semantics tp).
+Proof.
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (S a). lia.
+  - econs. i. exploit transf_initial_states; eauto. i. des.
+    exists S2. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. inversion INITSRC; subst. inversion H0; subst.
+      inv STACKS. inv ARGINJ. inversion H; subst.
+      exploit transf_initial_capture; [eapply INITSRC|eapply H| | | |].
+      { eapply init_mem_inj_2; eauto. }
+      { econs; eauto. econs; eauto. }
+      { r in CAPTGT. ss. eauto. }
+      i. des. esplits; eauto. apply match_states_xsim; auto.
+  - exploit globals_symbols_inject. apply init_meminj_preserves_globals. intros [A B].
+    i. eapply A.
 Qed.
 
 End SOUNDNESS.
 
 Theorem transf_program_correct:
-  forall p tp, match_prog p tp -> forward_simulation (semantics p) (semantics tp).
+  forall p tp, match_prog p tp -> mixed_simulation (semantics p) (semantics tp).
 Proof.
   intros p tp (used & A & B).  apply transf_program_correct_1 with used; auto.
 Qed.
diff --git a/backend/ValueAnalysis.v b/backend/ValueAnalysis.v
index ebf2c5ea..6ad8a3db 100644
--- a/backend/ValueAnalysis.v
+++ b/backend/ValueAnalysis.v
@@ -16,6 +16,7 @@ Require Import Compopts AST Linking.
 Require Import Values Memory Globalenvs Builtins Events.
 Require Import Registers Op RTL.
 Require Import ValueDomain ValueAOp Liveness.
+Require Import Classical.
 
 (** * The dataflow analysis *)
 
@@ -34,11 +35,13 @@ Definition mafter_private_call (am_before: amem) : amem :=
   {| am_stack := am_before.(am_stack);
      am_glob := PTree.empty _;
      am_nonstack := Nonstack;
-     am_top := plub (ab_summary (am_stack am_before)) Nonstack |}.
+     am_top := plub (ab_summary (am_stack am_before)) Nonstack;
+     am_concrete_stack := am_before.(am_concrete_stack) |}.
 
 Definition analyze_call (am: amem) (aargs: list aval) :=
   if pincl am.(am_nonstack) Nonstack
   && forallb (fun av => vpincl av Nonstack) aargs
+  && negb (am.(am_concrete_stack))
   then (Ifptr Nonstack, mafter_private_call am)
   else (Vtop, mafter_public_call).
 
@@ -106,8 +109,8 @@ Definition transfer_builtin
   | EF_memcpy sz al, dst :: src :: nil =>
       let adst := abuiltin_arg ae am rm dst in
       let asrc := abuiltin_arg ae am rm src in
-      let p := loadbytes am rm (aptr_of_aval asrc) in
-      let am' := storebytes am (aptr_of_aval adst) sz p in
+      let p := loadbytes am rm (aptr_of_aval asrc am.(am_concrete_stack)) in
+      let am' := storebytes am (aptr_of_aval adst am.(am_concrete_stack)) sz p in 
       VA.State (set_builtin_res res ntop ae) am'
   | (EF_annot _ _ _ | EF_debug _ _ _), _ =>
       VA.State (set_builtin_res res ntop ae) am
@@ -187,7 +190,8 @@ Definition mfunction_entry :=
   {| am_stack := ablock_init Pbot;
      am_glob := PTree.empty _;
      am_nonstack := Nonstack;
-     am_top := Nonstack |}.
+     am_top := Nonstack;
+     am_concrete_stack := false |}.
 
 Definition analyze (rm: romem) (f: function): PMap.t VA.t :=
   let lu := Liveness.last_uses f in
@@ -356,12 +360,12 @@ Lemma abuiltin_arg_sound:
   vmatch bc v (abuiltin_arg ae am rm a).
 Proof.
   intros until am; intros EM RM MM GM SP.
-  induction 1; simpl; eauto with va.
-- eapply loadv_sound; eauto. simpl. rewrite Ptrofs.add_zero_l. auto with va.
+  induction 1; try (by (simpl; eauto with va)).
+- unfold abuiltin_arg. eapply loadv_sound; eauto. simpl. rewrite Ptrofs.add_zero_l. auto with va.
 - simpl. rewrite Ptrofs.add_zero_l. auto with va.
 - eapply loadv_sound; eauto. apply symbol_address_sound; auto.
 - apply symbol_address_sound; auto.
-- destruct Archi.ptr64; auto with va.
+- ss. destruct Archi.ptr64; auto with va.
 Qed.
 
 Lemma abuiltin_args_sound:
@@ -443,7 +447,7 @@ Proof.
 Qed.
 
 Lemma mmatch_no_stack: forall m am astk,
-  mmatch bc m am -> mmatch bc m {| am_stack := astk; am_glob := PTree.empty _; am_nonstack := Nonstack; am_top := Nonstack |}.
+  mmatch bc m am -> mmatch bc m {| am_stack := astk; am_glob := PTree.empty _; am_nonstack := Nonstack; am_top := Nonstack; am_concrete_stack := false |}.
 Proof.
   intros. destruct H. constructor; simpl; intros.
 - elim (NOSTACK b); auto.
@@ -451,6 +455,9 @@ Proof.
 - eapply smatch_no_stack; eauto.
 - eapply smatch_no_stack; eauto.
 - auto.
+- auto.
+- unfold bc_nostack in NOSTACK. specialize NOSTACK with sp.
+  unfold not in NOSTACK. apply NOSTACK in H. elim H.
 Qed.
 
 End NOSTACK.
@@ -546,6 +553,15 @@ Proof.
     red; simpl; intros. rewrite NB. destruct (eq_block b sp).
     subst b; rewrite SP; extlia.
     exploit mmatch_below; eauto. extlia.
+  + rewrite <- Mem.concrete_alloc with (m1:=m) (lo:=0) (hi:=sz) (b:=sp); auto.
+    destruct (eq_block b sp); [inversion H|].
+    inversion MM. apply mmatch_logical. auto.
+  + unfold bc_nostack in NOSTACK.
+    destruct (eq_block sp0 sp).
+    subst. rewrite <- Mem.concrete_alloc with (m1:=m) (lo:=0) (hi:=sz)(b:=Mem.nextblock m); auto.
+    apply m.(Mem.nextblocks_logical). apply Plt_strict.
+    specialize NOSTACK with sp0. unfold not in NOSTACK.
+    apply NOSTACK in H. elim H.    
 - (* unchanged *)
   simpl; intros. apply dec_eq_false. apply Plt_ne. auto.
 - (* values *)
@@ -635,6 +651,9 @@ Proof.
   + red; simpl; intros. destruct (eq_block b sp).
     subst b. eapply mmatch_below; eauto. congruence.
     eapply mmatch_below; eauto.
+  + destruct (eq_block b sp). inversion H. inversion MM.
+    apply mmatch_logical. auto.
+  + inversion H0.  
 Qed.
 
 (** Construction 3: turn the stack into an invalid block, at private calls *)
@@ -646,6 +665,7 @@ Theorem hide_stack:
   mmatch bc m am ->
   bc sp = BCstack ->
   pge Nonstack am.(am_nonstack) ->
+  m.(Mem.mem_concrete)!sp = None -> (* stack is not captured *)
   exists bc',
      bc_nostack bc'
   /\ bc' sp = BCinvalid
@@ -655,7 +675,7 @@ Theorem hide_stack:
   /\ romatch bc' m rm
   /\ mmatch bc' m mtop.
 Proof.
-  intros until am; intros GENV RO MM SP NOLEAK.
+  intros until am; intros GENV RO MM SP NOLEAK NOCONC.
 (* Part 1: constructing bc' *)
   set (f := fun b => if eq_block b sp then BCinvalid else bc b).
   assert (F_stack: forall b1 b2, f b1 = BCstack -> f b2 = BCstack -> b1 = b2).
@@ -720,6 +740,9 @@ Proof.
     red; intros; elim n. eapply bc_stack; eauto.
   + red; simpl; intros. destruct (eq_block b sp). congruence.
     eapply mmatch_below; eauto.
+  + destruct (eq_block b sp); subst; auto.
+    inversion MM. apply mmatch_logical. auto.
+  + inversion H0.
 Qed.
 
 (** Construction 4: restore the stack after a public call *)
@@ -809,6 +832,9 @@ Proof.
     red; simpl; intros. destruct (eq_block b sp).
     subst b. eapply mmatch_below; eauto. congruence.
     eapply mmatch_below; eauto.
+  + destruct (eq_block b sp); inversion H.
+    inversion MM. apply mmatch_logical. auto.
+  + inversion H0.
 - (* genv *)
   eapply genv_match_exten with caller; eauto.
   simpl; intros. destruct (eq_block b sp). intuition congruence.
@@ -921,6 +947,12 @@ Proof.
     red; simpl; intros. destruct (eq_block b sp).
     subst b. apply Pos.lt_le_trans with bound. apply BELOW. congruence. auto.
     eapply mmatch_below; eauto.
+  + destruct (eq_block b sp); inversion H.
+    inversion MM. apply mmatch_logical. auto.
+  + destruct (eq_block sp0 sp); inversion H. subst.
+    inversion MM. apply mmatch_logical. auto.
+    unfold bc_nostack, not in NOSTACK. specialize NOSTACK with sp0.
+    elim NOSTACK. auto.
 - (* genv *)
   eapply genv_match_exten; eauto.
   simpl; intros. destruct (eq_block b sp); intuition congruence.
@@ -953,8 +985,136 @@ Theorem external_call_match:
   /\ (forall b ofs n, Mem.valid_block m b -> bc b = BCinvalid -> Mem.loadbytes m' b ofs n = Mem.loadbytes m b ofs n).
 Proof.
   intros until am; intros EC GENV ARGS RO MM NOSTACK.
+  destruct (classic (is_external_ef ef)) as [EXT|NOEXT].
+  { exploit ec_sound. eapply external_call_spec_backward. eauto.
+    instantiate (1:= (inj_of_bc bc)).
+    unfold self_inj, inj_of_bc. intros. destruct (bc b); inv H; eauto.
+    eapply meminj_preserves_globals_to_symbols_inject.
+    apply inj_of_bc_preserves_globals; eauto.
+    eexact EC.
+    eapply mmatch_inj; eauto. eapply mmatch_below; eauto.
+    revert ARGS. generalize vargs.
+    induction vargs0; simpl; intros; constructor.
+    eapply vmatch_inj; eauto. auto.
+    intros (j' & IRES & IMEM & UNCH1 & UNCH2 & IINCR & ISEP).
+    assert (JBELOW: forall b, Plt b (Mem.nextblock m) -> j' b = inj_of_bc bc b).
+    {
+      intros. destruct (inj_of_bc bc b) as [[b' delta] | ] eqn:EQ.
+      eapply IINCR; eauto.
+      destruct (j' b) as [[b'' delta'] | ] eqn:EQ'; auto.
+      exploit ISEP; eauto. tauto.
+    }
+    (* Part 2: constructing bc' from j' *)
+    set (f := fun b => if plt b (Mem.nextblock m)
+                    then bc b
+                    else match j' b with None => BCinvalid | Some _ => BCother end).
+    assert (F_stack: forall b1 b2, f b1 = BCstack -> f b2 = BCstack -> b1 = b2).
+    {
+      assert (forall b, f b = BCstack -> bc b = BCstack).
+      { unfold f; intros. destruct (plt b (Mem.nextblock m)); auto. destruct (j' b); discriminate. }
+      intros. apply (bc_stack bc); auto.
+    }
+    assert (F_glob: forall b1 b2 id, f b1 = BCglob id -> f b2 = BCglob id -> b1 = b2).
+    {
+      assert (forall b id, f b = BCglob id -> bc b = BCglob id).
+      { unfold f; intros. destruct (plt b (Mem.nextblock m)); auto. destruct (j' b); discriminate. }
+      intros. eapply (bc_glob bc); eauto.
+    }
+
+    set (bc' := BC f F_stack F_glob). unfold f in bc'.
+    assert (INCR: bc_incr bc bc').
+    {
+      red; simpl; intros. apply pred_dec_true. eapply mmatch_below; eauto.
+    }
+    assert (BC'INV: forall b, bc' b <> BCinvalid -> exists b' delta, j' b = Some(b', delta)).
+    {
+      simpl; intros. destruct (plt b (Mem.nextblock m)).
+      exists b, 0. rewrite JBELOW by auto. apply inj_of_bc_valid; auto.
+      destruct (j' b) as [[b' delta] | ].
+      exists b', delta; auto.
+      congruence.
+    }
+
+    (* Part 3: injection wrt j' implies matching with top wrt bc' *)
+    assert (PMTOP: forall b b' delta ofs, j' b = Some (b', delta) -> pmatch bc' b ofs Ptop).
+    {
+      intros. constructor. simpl; unfold f.
+      destruct (plt b (Mem.nextblock m)).
+      rewrite JBELOW in H by auto. eapply inj_of_bc_inv; eauto.
+      rewrite H; congruence.
+    }
+    assert (VMTOP: forall v v', Val.inject j' v v' -> vmatch bc' v Vtop).
+    {
+      intros. inv H; constructor. eapply PMTOP; eauto.
+    }
+    assert (SMTOP: forall b, bc' b <> BCinvalid -> smatch bc' m' b Ptop).
+    {
+      intros; split; intros.
+      - exploit BC'INV; eauto. intros (b' & delta & J').
+        exploit Mem.load_inject. eexact IMEM. eauto. eauto. intros (v' & A & B).
+        eapply VMTOP; eauto.
+      - exploit BC'INV; eauto. intros (b'' & delta & J').
+        exploit Mem.loadbytes_inject. eexact IMEM. eauto. eauto. intros (bytes & A & B).
+        inv B. inv H3. inv H7. eapply PMTOP; eauto.
+    }
+    (* Conclusions *)
+    exists bc'; splitall.
+    - (* incr *)
+      exact INCR.
+    - (* unchanged *)
+      simpl; intros. apply pred_dec_true; auto.
+    - (* vmatch res *)
+      eapply VMTOP; eauto.
+    - (* genv match *)
+      apply genv_match_exten with bc; auto.
+      simpl; intros; split; intros.
+      rewrite pred_dec_true by (eapply mmatch_below; eauto with va). auto.
+      destruct (plt b (Mem.nextblock m)). auto. destruct (j' b); congruence.
+      simpl; intros. rewrite pred_dec_true by (eapply mmatch_below; eauto with va). auto.
+    - (* romatch m' *)
+      red; simpl; intros. destruct (plt b (Mem.nextblock m)).
+      exploit RO; eauto. intros (R & P & Q).
+      split; auto.
+      split. apply bmatch_incr with bc; auto. apply bmatch_ext with m; auto.
+      intros. eapply external_call_readonly with (m2 := m'); eauto.
+      intros; red; intros; elim (Q ofs).
+      eapply external_call_max_perm with (m2 := m'); eauto.
+      destruct (j' b); congruence.
+    - (* mmatch top *)
+      constructor; simpl; intros.
+      + apply ablock_init_sound. apply SMTOP. simpl; congruence.
+      + rewrite PTree.gempty in H0; discriminate.
+      + apply SMTOP; auto.
+      + apply SMTOP; auto.
+      + red; simpl; intros. destruct (plt b (Mem.nextblock m)).
+        eapply Pos.lt_le_trans. eauto. eapply external_call_nextblock; eauto.
+        destruct (j' b) as [[bx deltax] | ] eqn:J'.
+        eapply Mem.valid_block_inject_1; eauto.
+        congruence.
+      + destruct (plt b m'.(Mem.nextblock)); try (apply m'.(Mem.nextblocks_logical); assumption).
+        destruct (plt b m.(Mem.nextblock)).
+        * assert(m.(Mem.mem_concrete)!b = None).
+          { apply mmatch_logical with bc am; auto. }
+          destruct (j' b) eqn:J'B.
+          unfold inject_separated in ISEP.
+          destruct p1 as [b2 delta]. rr in ISEP. specialize ISEP with b b2 delta.
+          unfold inj_of_bc in ISEP. rewrite H in ISEP.
+          assert(~Mem.valid_block m b) by (apply ISEP; auto).
+          unfold Mem.valid_block, not in H1. exfalso. apply H1. auto.
+          apply Mem.mi_src_concrete_private with (f:=j') (m2:=m'); auto.
+        * destruct (j' b) eqn:J'B; inversion H.
+          apply Mem.mi_src_concrete_private with (f:=j') (m2:=m'); auto.
+      + inversion H0.
+    - (* nostack *)
+      red; simpl; intros. destruct (plt b (Mem.nextblock m)).
+      apply NOSTACK; auto.
+      destruct (j' b); congruence.
+    - (* unmapped blocks are invariant *)
+      intros. eapply Mem.loadbytes_unchanged_on_1; auto.
+      apply UNCH1; auto. intros; red. unfold inj_of_bc; rewrite H0; auto. } 
   (* Part 1: using ec_mem_inject *)
   exploit (@external_call_mem_inject ef _ _ ge vargs m t vres m' (inj_of_bc bc) m vargs).
+  eapply external_call_spec; eauto.
   apply inj_of_bc_preserves_globals; auto.
   exact EC.
   eapply mmatch_inj; eauto. eapply mmatch_below; eauto.
@@ -1055,6 +1215,20 @@ Proof.
     destruct (j' b) as [[bx deltax] | ] eqn:J'.
     eapply Mem.valid_block_inject_1; eauto.
     congruence.
+  + destruct (plt b m'.(Mem.nextblock)); try (apply m'.(Mem.nextblocks_logical); assumption).
+    destruct (plt b m.(Mem.nextblock)).
+    * assert(m.(Mem.mem_concrete)!b = None).
+      { apply mmatch_logical with bc am; auto. }
+      destruct (j' b) eqn:J'B.
+      unfold inject_separated in ISEP.
+      destruct p1 as [b2 delta]. specialize ISEP with b b2 delta.
+      unfold inj_of_bc in ISEP. rewrite H in ISEP.
+      assert(~ Mem.valid_block m b) by (apply ISEP; auto).
+      unfold Mem.valid_block, not in H1. exfalso. apply H1. auto.
+      apply Mem.mi_src_concrete_private with (f:=j') (m2:=m''); auto.
+    * destruct (j' b) eqn:J'B; inversion H.
+      apply Mem.mi_src_concrete_private with (f:=j') (m2:=m''); auto.
+  + inversion H0.
 - (* nostack *)
   red; simpl; intros. destruct (plt b (Mem.nextblock m)).
   apply NOSTACK; auto.
@@ -1164,7 +1338,7 @@ Proof.
 Qed.
 
 Lemma sound_stack_storev:
-  forall chunk m addr v m' bc aaddr stk bound,
+  forall chunk m addr v m' bc aaddr stk bound am' (MMCH: mmatch bc m' am'),
   Mem.storev chunk m addr v = Some m' ->
   vmatch bc addr aaddr ->
   sound_stack bc stk m bound ->
@@ -1172,6 +1346,14 @@ Lemma sound_stack_storev:
 Proof.
   intros. apply sound_stack_inv with m; auto.
   destruct addr; simpl in H; try discriminate.
+  { des_ifs. eapply Mem.denormalize_info in Heq0. des.
+    replace z with (Ptrofs.unsigned (Ptrofs.repr z)) in H.
+    2:{ rewrite Ptrofs.unsigned_repr; eauto. }
+    assert (A: pmatch bc b (Ptrofs.repr z) Ptop).
+    { econs. ii. exploit mmatch_logical; eauto. i; clarify.
+      erewrite Mem.concrete_store in CONC; eauto. clarify. }
+    inv A.
+    intros. eapply Mem.loadbytes_store_other; eauto. left; congruence. }
   assert (A: pmatch bc b i Ptop).
   { inv H0; eapply pmatch_top'; eauto. }
   inv A.
@@ -1264,7 +1446,7 @@ Proof.
 - (* op *)
   eapply sound_succ_state; eauto. simpl; auto.
   unfold transfer; rewrite H. eauto.
-  apply ematch_update; auto. eapply eval_static_operation_sound; eauto with va.
+  apply ematch_update; auto. eapply eval_static_operation_wrapper_sound; eauto with va.
 
 - (* load *)
   eapply sound_succ_state; eauto. simpl; auto.
@@ -1277,7 +1459,10 @@ Proof.
   eapply sound_succ_state; eauto. simpl; auto.
   unfold transfer; rewrite H. eauto.
   eapply storev_sound; eauto.
-  destruct a; simpl in H1; try discriminate. eapply romatch_store; eauto.
+  destruct a; simpl in H1; try discriminate.
+  { des_ifs. eapply romatch_store; eauto. }
+  eapply romatch_store; eauto.
+  exploit storev_sound; eauto. i.
   eapply sound_stack_storev; eauto.
 
 - (* call *)
@@ -1285,11 +1470,13 @@ Proof.
   { unfold transfer; rewrite H; auto. }
   unfold transfer_call, analyze_call in TR.
   destruct (pincl (am_nonstack am) Nonstack &&
-            forallb (fun av => vpincl av Nonstack) (aregs ae args)) eqn:NOLEAK.
+            forallb (fun av => vpincl av Nonstack) (aregs ae args) &&
+            negb (am.(am_concrete_stack))) eqn:ISPRIVATE.
 + (* private call *)
   InvBooleans.
   exploit analyze_successor; eauto. simpl; eauto. rewrite TR. intros SUCC.
   exploit hide_stack; eauto. apply pincl_ge; auto.
+  apply mmatch_logical_stack with bc am; auto. apply negb_true_iff. auto.
   intros (bc' & A & B & C & D & E & F & G).
   apply sound_call_state with bc'; auto.
   * eapply sound_stack_private_call with (bound' := Mem.nextblock m) (bc' := bc); eauto.
@@ -1298,8 +1485,8 @@ Proof.
     eapply mmatch_stack; eauto.
   * intros. exploit list_in_map_inv; eauto. intros (r & P & Q). subst v.
     apply D with (areg ae r).
-    rewrite forallb_forall in H2. apply vpincl_ge.
-    apply H2. apply in_map; auto.
+    rewrite forallb_forall in H4. apply vpincl_ge.
+    apply H4. apply in_map; auto.
     auto with va.
 + (* public call *)
   exploit analyze_successor; eauto. simpl; eauto. rewrite TR. intros SUCC.
@@ -1338,15 +1525,18 @@ Proof.
   set (aargs := map (abuiltin_arg ae am rm) args) in *.
   assert (ARGS: list_forall2 (vmatch bc) vargs aargs) by (eapply abuiltin_args_sound; eauto).
   destruct (pincl (am_nonstack am) Nonstack &&
-            forallb (fun av => vpincl av Nonstack) aargs)
-        eqn: NOLEAK.
+            forallb (fun av => vpincl av Nonstack) aargs &&
+            negb (am.(am_concrete_stack)))
+           eqn: NOLEAK.
 * (* private builtin call *)
-  InvBooleans. rewrite forallb_forall in H3.
+  InvBooleans. rewrite forallb_forall in H5.
   exploit hide_stack; eauto. apply pincl_ge; auto.
+  apply mmatch_logical_stack with bc am; auto.
+  apply negb_true_iff. auto.
   intros (bc1 & A & B & C & D & E & F & G).
   exploit external_call_match; eauto.
   intros. exploit list_forall2_in_left; eauto. intros (av & U & V).
-  eapply D; eauto with va. apply vpincl_ge. apply H3; auto.
+  eapply D; eauto with va. apply vpincl_ge. apply H5; auto.
   intros (bc2 & J & K & L & M & N & O & P & Q).
   exploit (return_from_private_call bc bc2); eauto.
   eapply mmatch_below; eauto.
@@ -1404,7 +1594,10 @@ Proof.
     destruct (va_strict tt). apply vmatch_lub_r. apply vnormalize_sound. auto.
     apply vnormalize_sound. eapply vmatch_ge; eauto. constructor. constructor.
   * (* normal memory access *)
-    exploit loadv_sound; eauto. simpl; eauto. intros V.
+    assert (LDV: Mem.loadv chunk m' b1 = Some vres).
+    { unfold Mem.loadv, Mem.to_ptr in *. des_ifs. }
+    exploit loadv_sound; eauto.
+    eauto. simpl; eauto. intros V.
     destruct (va_strict tt).
     apply vmatch_lub_l. auto.
     eapply vnormalize_cast; eauto. eapply vmatch_top; eauto.
@@ -1418,23 +1611,201 @@ Proof.
     apply set_builtin_res_sound; auto. constructor.
     apply mmatch_lub_l; auto.
   * (* normal memory access *)
+    assert (STV: Mem.storev chunk m b1 b0 = Some m').
+    { unfold Mem.storev, Mem.to_ptr in *. des_ifs. rewrite Ptrofs.unsigned_repr in H3; eauto.
+      eapply Mem.denormalize_info in Heq0. des. lia. }
     eapply sound_succ_state; eauto. simpl; auto.
     apply set_builtin_res_sound; auto. constructor.
     apply mmatch_lub_r. eapply storev_sound; eauto. auto.
     eapply romatch_store; eauto.
-    eapply sound_stack_storev; eauto. simpl; eauto.
+    exploit storev_sound; eauto. i. eapply sound_stack_storev; eauto.
 + (* memcpy *)
-  inv H0; auto. inv H3; auto. inv H4; auto. inv H1.
+  inv H0; auto. inv H3; auto. inv H4; auto. simpl in H1. inv H1.
+  2:{ eapply sound_succ_state; eauto. simpl; auto.
+      apply set_builtin_res_sound; auto. constructor.
+      eapply storebytes_zero_sound; eauto. }
   exploit abuiltin_arg_sound. eauto. eauto. eauto. eauto. eauto. eexact H0. intros VM1.
   exploit abuiltin_arg_sound. eauto. eauto. eauto. eauto. eauto. eexact H2. intros VM2.
   eapply sound_succ_state; eauto. simpl; auto.
   apply set_builtin_res_sound; auto. constructor.
-  eapply storebytes_sound; eauto.
-  apply match_aptr_of_aval; auto.
-  eapply Mem.loadbytes_length; eauto.
-  intros. eapply loadbytes_sound; eauto. apply match_aptr_of_aval; auto.
+  destruct (abuiltin_arg ae am rm a1) eqn:DST; try (by (inv VM2; clarify)).
+  (* dst long *)
+  { destruct (abuiltin_arg ae am rm a0) eqn:SRC; try (by (inv VM1; clarify)).
+  (* L L *)
+  - inv VM1; inv VM2.
+    eapply storebytes_sound; eauto.
+  + destruct (am_concrete_stack am) eqn:CONCSTK.
+  (* concrete stack *)
+  * simpl. des_ifs. econs; eauto. eapply to_ptr_valid; eauto.
+  (* logical stack *)
+  * ss. eapply to_ptr_nonstack; eauto.
+  + eapply Mem.loadbytes_length; eauto.
+  + eapply loadbytes_sound; eauto.
+    destruct (am_concrete_stack am) eqn:CONCSTK.
+  (* concrete stack *)
+  * simpl. des_ifs. econs; eauto. eapply to_ptr_valid; eauto.
+  (* logical stack *)
+  * ss. eapply to_ptr_nonstack; eauto.
+  (* PTR L *)
+  - inv VM1; [|ss]. simpl in TOPTR2. inv TOPTR2.
+    eapply storebytes_sound; eauto.
+  + destruct (am_concrete_stack am) eqn:CONCSTK.
+  (* concrete stack *)
+  * simpl. des_ifs. econs; eauto. inv VM2. eapply to_ptr_valid; eauto.
+  (* logical stack *)
+  * ss. des_ifs. inv VM2. eapply to_ptr_nonstack; eauto.
+  + eapply Mem.loadbytes_length; eauto.
+  + ss. eapply loadbytes_sound; eauto.
+  (* Ifptr L *)
+  - inv VM1; ss.
+  (* src pointer is a int *)
+  + des_ifs_safe.
+    eapply storebytes_sound; eauto.
+  * destruct (am_concrete_stack am) eqn:CONCSTK.
+    { inv VM2. econs; eauto. eapply to_ptr_valid; eauto. }
+    inv VM2. eapply to_ptr_nonstack; eauto.
+  * eapply Mem.loadbytes_length; eauto.
+  * ss. eapply loadbytes_sound; eauto.
+    destruct (am_concrete_stack am) eqn:CONCSTK.
+    { econs; eauto. eapply denormalized_valid; eauto. }
+    des_ifs; try (by (econs; eauto; eapply denormalized_valid; eauto)).
+    all: (eapply denormalized_nonstack; eauto).
+  (* src pointer is a pointer *)
+  + inv TOPTR2. des_ifs_safe.
+    eapply storebytes_sound; eauto.
+  * destruct (am_concrete_stack am) eqn:CONCSTK.
+    { inv VM2. econs; eauto. eapply to_ptr_valid; eauto. }
+    inv VM2. eapply to_ptr_nonstack; eauto.
+  * eapply Mem.loadbytes_length; eauto.
+  * ss. eapply loadbytes_sound; eauto.
+    destruct (am_concrete_stack am) eqn:CONCSTK.
+    { eapply pmatch_top'; eauto. }
+    des_ifs; try (eapply pmatch_top'; eauto).
+    { inv H4. }
+    { eapply pmatch_ge; eauto. eapply pge_ns_gl. }
+    { eapply pmatch_ge; eauto. eapply pge_ns_glo. }
+    { eapply pmatch_ge; eauto. eapply pge_ns_glob. } }
+  (* dst ptr *)
+  { destruct (abuiltin_arg ae am rm a0) eqn:SRC; try (by (inv VM1; clarify)).
+    (* L PTR *)
+    - inv VM1; inv VM2; [|ss].
+      eapply storebytes_sound; eauto.
+    + ss. inv TOPTR1. eauto.
+    + eapply Mem.loadbytes_length; eauto.
+    + eapply loadbytes_sound; eauto.
+      destruct (am_concrete_stack am) eqn:CONCSTK.
+      { simpl. des_ifs_safe. econs; eauto. eapply to_ptr_valid; eauto. }
+      simpl. des_ifs_safe. eapply to_ptr_nonstack; eauto.
+    (* PTR PTR *)
+    - inv VM1; inv VM2; try by ss. inv TOPTR1; inv TOPTR2.
+      eapply storebytes_sound; eauto.
+    + eapply Mem.loadbytes_length; eauto.
+    + eapply loadbytes_sound; eauto.
+    (* Ifptr PTR *)
+    - inv VM1; inv VM2; try by ss.
+    (* src pointer is a integer *)
+    + inv TOPTR1. des_ifs_safe.
+      eapply storebytes_sound; eauto.    
+    * eapply Mem.loadbytes_length; eauto.
+    * eapply loadbytes_sound; eauto.
+      destruct (am_concrete_stack am) eqn:CONCSTK.
+      { econs; eauto. eapply to_ptr_valid; eauto. }
+      simpl. des_ifs; try (by (econs; eauto; eapply to_ptr_valid; eauto)).
+      all: (eapply to_ptr_nonstack; eauto).
+    (* src pointer is a pointer *)
+    + ss. inv TOPTR1; inv TOPTR2.
+      eapply storebytes_sound; eauto.    
+    * eapply Mem.loadbytes_length; eauto.
+    * eapply loadbytes_sound; eauto.
+      destruct (am_concrete_stack am) eqn:CONCSTK.
+      { eapply pmatch_top'; eauto. }
+      des_ifs; try (eapply pmatch_top'; eauto).
+      { inv H4. }
+      { eapply pmatch_ge; eauto. eapply pge_ns_gl. }
+      { eapply pmatch_ge; eauto. eapply pge_ns_glo. }
+      { eapply pmatch_ge; eauto. eapply pge_ns_glob. } }
+  (* dst ifptr *)
+  { destruct (abuiltin_arg ae am rm a0) eqn:SRC; try (by (inv VM1; clarify)).
+    (* L Ifptr *)
+    - inv VM1.
+      eapply storebytes_sound; eauto.
+    + inv VM2; try by ss.
+    * destruct (am_concrete_stack am) eqn:CONCSTK.
+      { simpl. econs; eauto. eapply to_ptr_valid; eauto. }
+      simpl. des_ifs; try (by (econs; eauto; eapply to_ptr_valid; eauto)).
+      all: (eapply to_ptr_nonstack; eauto).
+    * simpl in TOPTR1. inv TOPTR1. simpl.
+      destruct (am_concrete_stack am) eqn:CONCSTK.
+      { eapply pmatch_top'; eauto. }
+      des_ifs; try (eapply pmatch_top'; eauto).
+      { inv H4. }
+      { eapply pmatch_ge; eauto. eapply pge_ns_gl. }
+      { eapply pmatch_ge; eauto. eapply pge_ns_glo. }
+      { eapply pmatch_ge; eauto. eapply pge_ns_glob. }
+    + eapply Mem.loadbytes_length; eauto.
+    + eapply loadbytes_sound; eauto.
+      destruct (am_concrete_stack am) eqn:CONCSTK.
+      { econs; eauto. eapply to_ptr_valid; eauto. }
+      simpl. des_ifs; try (by (econs; eauto; eapply to_ptr_valid; eauto)).
+      all: (eapply to_ptr_nonstack; eauto).
+    (* Ptr Ifptr *)
+    - inv VM1; [|ss]. simpl in TOPTR2. inv TOPTR2.
+      eapply storebytes_sound; eauto.
+    + inv VM2; try by ss.
+    * destruct (am_concrete_stack am) eqn:CONCSTK.
+      { simpl. econs; eauto. eapply to_ptr_valid; eauto. }
+      simpl. des_ifs; try (by (econs; eauto; eapply to_ptr_valid; eauto)).
+      all: (eapply to_ptr_nonstack; eauto).
+    * simpl in TOPTR1. inv TOPTR1. simpl.
+      destruct (am_concrete_stack am) eqn:CONCSTK.
+      { eapply pmatch_top'; eauto. }
+      des_ifs; try (eapply pmatch_top'; eauto).
+      { inv H12. }
+      { eapply pmatch_ge; eauto. eapply pge_ns_gl. }
+      { eapply pmatch_ge; eauto. eapply pge_ns_glo. }
+      { eapply pmatch_ge; eauto. eapply pge_ns_glob. }
+    + eapply Mem.loadbytes_length; eauto.
+    + eapply loadbytes_sound; eauto.
+    (* Ifptr Ifptr *)
+    - eapply storebytes_sound; eauto.
+    + destruct (am_concrete_stack am) eqn:CONCSTK.
+    * simpl. inv VM2; try by ss.
+      { econs; eauto. eapply to_ptr_valid; eauto. }
+      { ss. inv TOPTR1. eapply pmatch_top'; eauto. }
+    * simpl. inv VM2; try by ss.
+      { simpl. des_ifs; try (by (econs; eauto; eapply to_ptr_valid; eauto)).
+        all: (eapply to_ptr_nonstack; eauto). }
+      { simpl in TOPTR1. inv TOPTR1. des_ifs; try (eapply pmatch_top'; eauto).
+        { inv H4. }
+        { eapply pmatch_ge; eauto. eapply pge_ns_gl. }
+        { eapply pmatch_ge; eauto. eapply pge_ns_glo. }
+        { eapply pmatch_ge; eauto. eapply pge_ns_glob. } }
+    + eapply Mem.loadbytes_length; eauto.
+    + eapply loadbytes_sound; eauto.
+      destruct (am_concrete_stack am) eqn:CONCSTK.
+    * simpl. inv VM1; try by ss.
+      { econs; eauto. eapply to_ptr_valid; eauto. }
+      { ss. inv TOPTR2. eapply pmatch_top'; eauto. }
+    * simpl. inv VM1; try by ss.
+      { simpl. des_ifs; try (by (econs; eauto; eapply to_ptr_valid; eauto)).
+        all: (eapply to_ptr_nonstack; eauto). }
+      { simpl in TOPTR2. inv TOPTR2. des_ifs; try (eapply pmatch_top'; eauto).
+        { inv H4. }
+        { eapply pmatch_ge; eauto. eapply pge_ns_gl. }
+        { eapply pmatch_ge; eauto. eapply pge_ns_glo. }
+        { eapply pmatch_ge; eauto. eapply pge_ns_glob. } } }
   eapply romatch_storebytes; eauto.
+  assert (bc bdst <> BCinvalid).
+  { unfold Mem.to_ptr in TOPTR1. des_ifs_safe. destruct b1; ss.
+    - destruct (Int64.eq i Int64.zero); ss. destruct (Mem.denormalize (Int64.unsigned i) m) eqn:DENO; ss.
+      destruct p. inv TOPTR1. eapply Mem.denormalize_info in DENO. des_safe.
+      destruct (classic (bc bdst = BCinvalid)); eauto.
+      exploit mmatch_logical; eauto. i. rewrite H3 in CONC. inv CONC.
+    - inv TOPTR1. inv VM2.
+      + inv H3; ii; try rewrite H3 in *; clarify.
+      + inv H3; ii; try rewrite H3 in *; clarify. }
   eapply sound_stack_storebytes; eauto.
+  instantiate (1:=Vtop). econs; eauto. econs; eauto.
 + (* annot *)
   inv H1. eapply sound_succ_state; eauto. simpl; auto. apply set_builtin_res_sound; auto. constructor.
 + (* annot val *)
@@ -1506,6 +1877,7 @@ Proof.
    eapply sound_regular_state with (bc := bc1); eauto.
    apply sound_stack_exten with bc'; auto.
    eapply ematch_ge; eauto. apply ematch_update. auto. auto.
+   (* Unshelve. ss. eapply Vbot. *)
 Qed.
 
 End SOUNDNESS.
@@ -1912,6 +2284,28 @@ Proof.
 - exact NOSTACK.
 Qed.
 
+Theorem sound_capture_initial prog st st'
+    (INIT: initial_state prog st)
+    (CAP: glob_capture prog st st'):
+  sound_state prog st'.
+Proof.
+  inv INIT. exploit initial_mem_matches; eauto. intros (bc & GE & BELOW & NOSTACK & RM & VALID).
+  inv CAP. rename m0 into m. econs. i. econs; eauto; [econs|i; ss| |].
+  - inv CAPTURE. eapply romatch_capture_list; eauto.
+  - eapply mmatch_inj_top. instantiate (1:=m').
+    replace (inj_of_bc bc) with (Mem.flat_inj (Mem.nextblock m')); cycle 1.
+    { symmetry; apply extensionality; unfold Mem.flat_inj; intros x.
+      assert (Mem.nextblock m = Mem.nextblock m').
+      { inv CAPTURE. eapply Mem.capture_list_nextblock; eauto. }
+      destruct (plt x (Mem.nextblock m)).
+      { rewrite H4 in p. des_ifs. apply inj_of_bc_valid; auto.
+        unfold inj_of_bc. eapply VALID. rewrite <- H4 in p. eauto. }
+      unfold inj_of_bc. erewrite bc_below_invalid; eauto.
+      rewrite <- H4. des_ifs. }
+    inv CAPTURE. eapply Genv.flat_inj_capture_list_inject; eauto.
+    eapply nat. eapply nat. eapply Genv.initmem_inject; eauto.
+Qed.
+
 Global Hint Resolve areg_sound aregs_sound: va.
 
 (** * Interface with other optimizations *)
@@ -1940,10 +2334,10 @@ Proof.
   intros. InvSoundState. exists bc; split; auto. rewrite AN. apply EM.
 Qed.
 
-Definition aaddr (a: VA.t) (r: reg) : aptr :=
+Definition aaddr (a: VA.t) (r: reg): aptr :=
   match a with
   | VA.Bot => Pbot
-  | VA.State ae am => aptr_of_aval (AE.get r ae)
+  | VA.State ae am => aptr_of_aval (AE.get r ae) am.(am_concrete_stack)
   end.
 
 Lemma aaddr_sound:
@@ -1960,10 +2354,10 @@ Proof.
   unfold aaddr; rewrite AN. apply match_aptr_of_aval. rewrite <- H1. apply EM.
 Qed.
 
-Definition aaddressing (a: VA.t) (addr: addressing) (args: list reg) : aptr :=
+Definition aaddressing (a: VA.t) (addr: addressing) (args: list reg): aptr :=
   match a with
   | VA.Bot => Pbot
-  | VA.State ae am => aptr_of_aval (eval_static_addressing addr (aregs ae args))
+  | VA.State ae am => aptr_of_aval (eval_static_addressing addr (aregs ae args)) am.(am_concrete_stack)
   end.
 
 Lemma aaddressing_sound:
@@ -1981,15 +2375,37 @@ Proof.
   eapply eval_static_addressing_sound; eauto with va.
 Qed.
 
+Lemma aaddressing_denormalize_sound
+  cunit prog s f sp pc e m addr args i b ofs
+  (SOUND: sound_state prog (State s f (Vptr sp Ptrofs.zero) pc e m))
+  (LINK: linkorder cunit prog)
+  (ADDR: eval_addressing (Genv.globalenv prog) (Vptr sp Ptrofs.zero) addr e##args = Some (Vlong i))
+  (DENO: Mem.denormalize (Int64.unsigned i) m = Some (b, ofs)) :
+  exists bc, <<PM: pmatch bc b (Ptrofs.repr ofs) (aaddressing (analyze (romem_for cunit) f)!!pc addr args)>>
+      /\ <<GM: genv_match bc (Genv.globalenv prog)>>
+      /\ <<ISSTK: bc sp = BCstack>>.
+Proof.
+  intros. InvSoundState. exists bc; split; auto.
+  unfold aaddressing. rewrite AN.
+  exploit eval_static_addressing_sound; eauto with va. i.
+  destruct (am_concrete_stack am) eqn:CONCSTK.
+  { inv H; ss; des_ifs; econs; eapply denormalized_valid; eauto. }
+  assert (VLD: bc b <> BCinvalid) by (eapply denormalized_valid; eauto).
+  inv H; ss.
+  - des_ifs. eapply denormalized_nonstack; eauto.
+  - assert (NOSTK: bc b <> BCstack) by (eapply denormalized_not_stack; eauto).
+    des_ifs; econs; eauto.
+Qed.
+
 (** This is a less precise version of [abuiltin_arg], where memory
     contents are not taken into account. *)
 
-Definition aaddr_arg (a: VA.t) (ba: builtin_arg reg) : aptr :=
+Definition aaddr_arg (a: VA.t) (ba: builtin_arg reg): aptr :=
   match a with
   | VA.Bot => Pbot
   | VA.State ae am =>
       match ba with
-      | BA r => aptr_of_aval (AE.get r ae)
+      | BA r => aptr_of_aval (AE.get r ae) am.(am_concrete_stack)
       | BA_addrstack ofs => Stk ofs
       | BA_addrglobal id ofs => Gl id ofs
       | _ => Ptop
@@ -2007,11 +2423,36 @@ Lemma aaddr_arg_sound_1:
   pmatch bc b ofs (aaddr_arg (VA.State ae am) a).
 Proof.
   intros.
-  apply pmatch_ge with (aptr_of_aval (abuiltin_arg ae am rm a)).
+  apply pmatch_ge with (aptr_of_aval (abuiltin_arg ae am rm a) am.(am_concrete_stack)).
   simpl. destruct a; try (apply pge_top); simpl; apply pge_refl.
   apply match_aptr_of_aval. eapply abuiltin_arg_sound; eauto.
 Qed.
 
+Lemma aaddr_arg_to_ptr_sound_1
+    bc rs ae m rm am ge sp a v b ofs
+    (EM: ematch bc rs ae)
+    (RM: romatch bc m rm)
+    (MM: mmatch bc m am)
+    (GM: genv_match bc ge)
+    (ISSTK: bc sp = BCstack)
+    (EVALARG: eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a v)
+    (TOPTR: Mem.to_ptr v m = Some (Vptr b ofs)) :
+  <<PM: pmatch bc b ofs (aaddr_arg (VA.State ae am) a)>>.
+Proof.
+  destruct v; ss.
+  2:{ inv TOPTR. eapply aaddr_arg_sound_1; eauto. }
+  des_ifs_safe. assert (VLD1: bc b <> BCinvalid) by (eapply denormalized_valid; eauto).
+  destruct a; ss; try by econs.
+  2:{ inv EVALARG. }
+  2:{ inv EVALARG. unfold Senv.symbol_address in H. des_ifs. }
+  inv EVALARG. unfold ematch in EM. specialize (EM x). rewrite H in EM.
+  destruct (am_concrete_stack am) eqn:CONCSTK.
+  { inv EM; ss; [|econs; eauto]. rewrite Heq. econs; eauto. }
+  exploit denormalized_nonstack; eauto. i.
+  inv EM; ss; des_ifs_safe; eauto.
+  destruct p; eauto; econs; eauto.
+Qed.
+
 Lemma aaddr_arg_sound:
   forall cunit prog s f sp pc e m a b ofs,
   sound_state prog (State s f (Vptr sp Ptrofs.zero) pc e m) ->
@@ -2025,3 +2466,17 @@ Proof.
   intros. InvSoundState. rewrite AN. exists bc; split; auto.
   eapply aaddr_arg_sound_1; eauto.
 Qed.
+
+Lemma aaddr_arg_to_ptr_sound
+    cunit prog s f sp pc e m a v b ofs
+    (SOUND: sound_state prog (State s f (Vptr sp Ptrofs.zero) pc e m))
+    (LINKER: linkorder cunit prog)
+    (EVALARG: eval_builtin_arg (Genv.globalenv prog) (fun r => e#r) (Vptr sp Ptrofs.zero) m a v)
+    (PTPTR: Mem.to_ptr v m = Some (Vptr b ofs)) :
+  exists bc, <<PM: pmatch bc b ofs (aaddr_arg (analyze (romem_for cunit) f)!!pc a)>>
+      /\ <<GM: genv_match bc (Genv.globalenv prog)>>
+      /\ <<STK: bc sp = BCstack>>.
+Proof.
+  i. InvSoundState. rewrite AN. exists bc; split; auto. eapply aaddr_arg_to_ptr_sound_1; eauto.
+Qed.
+
diff --git a/backend/ValueDomain.v b/backend/ValueDomain.v
index 01f080ff..fade8680 100644
--- a/backend/ValueDomain.v
+++ b/backend/ValueDomain.v
@@ -15,6 +15,8 @@ Require Import Zwf Coqlib Maps Zbits Integers Floats Lattice.
 Require Import Compopts AST.
 Require Import Values Memory Globalenvs Builtins Events.
 Require Import Registers RTL.
+Require Import Classical.
+Require Import sflib IntPtrRel.
 
 (** The abstract domains for value analysis *)
 
@@ -1023,18 +1025,31 @@ Qed.
   however.  Therefore, in relaxed mode, [aptr_of_aval x] returns
   [Nonstack] (any pointer outside the stack) when [x] denotes a number. *)
 
-Definition aptr_of_aval (v: aval) : aptr :=
+(* Change : Ifptr *)
+Definition aptr_of_aval (v: aval) (cstk: bool) : aptr :=
   match v with
   | Ptr p => p
-  | Ifptr p => p
+  | Ifptr p => if cstk (* stack captured? *)
+              then Ptop
+              else match p with
+                   | Stk _ | Stack | Ptop => Ptop
+                   | _ => Nonstack
+                   end
+  | L _ => if Archi.ptr64 then
+            (if cstk (* stack captured? *)
+             then Ptop
+             else Nonstack)
+          else Pbot
+  | I _ => if negb Archi.ptr64 then Pbot else Ptop
   | _ => if va_strict tt then Pbot else Nonstack
   end.
 
 Lemma match_aptr_of_aval:
-  forall b ofs av,
-  vmatch (Vptr b ofs) av -> pmatch b ofs (aptr_of_aval av).
+  forall b ofs av cstk,
+  vmatch (Vptr b ofs) av -> pmatch b ofs (aptr_of_aval av cstk).
 Proof.
   unfold aptr_of_aval; intros. inv H; auto.
+  des_ifs; try econs; inv H3; ii; clarify; Eq.
 Qed.
 
 Definition vplub (v: aval) (p: aptr) : aptr :=
@@ -1996,6 +2011,93 @@ Proof.
   inv H; constructor; apply padd_sound; assumption.
 Qed.
 
+Definition ptrsub32 (v w: aval) :=
+  match v, w with
+  | I i1, I i2 => I (Int.sub i1 i2)
+  | Ptr _, _ => Ifptr (poffset Nonstack)
+  | _, Ptr _ => Ifptr (poffset Nonstack)
+  | Ifptr _, _ => Ifptr (plub (poffset Nonstack) (provenance w))
+  | _, Ifptr _ => Ifptr (plub (provenance v) (poffset Nonstack))
+  | _, _ => ntop2 v w
+  end.
+
+Lemma ptrsub32_sound v w x y
+    (SF: Archi.ptr64 = false)
+    (VM1: vmatch v x)
+    (VM2: vmatch w y) :
+  <<VM: vmatch (Val.psub v w) (ptrsub32 x y)>>.
+Proof.
+  intros. unfold Val.psub, ptrsub32.
+  inv VM1; inv VM2; try (destruct (eq_block b b0)); eauto using psub_sound, poffset_sound, pmatch_lub_l with va.
+  rewrite SF. eapply vmatch_i.
+Qed.
+
+Definition ptrsub64 (v w: aval) :=
+  match v, w with
+  | L i1, L i2 => L (Int64.sub i1 i2)
+  | Ptr _, _ => Ifptr (poffset Nonstack)
+  | _, Ptr _ => Ifptr (poffset Nonstack)
+  | Ifptr _, _ => Ifptr (plub (poffset Nonstack) (provenance w))
+  | _, Ifptr _ => Ifptr (plub (provenance v) (poffset Nonstack))
+  | _, _ => ntop2 v w
+  end.
+
+Lemma ptrsub64_sound v w x y
+    (SF: Archi.ptr64 = true)
+    (VM1: vmatch v x)
+    (VM2: vmatch w y) :
+  <<VM: vmatch (Val.psubl v w) (ptrsub64 x y)>>.
+Proof.
+  intros. unfold Val.psubl, ptrsub64.
+  inv VM1; inv VM2; try (destruct (eq_block b b0)); eauto using psub_sound, poffset_sound, pmatch_lub_l with va.
+Qed.
+
+Definition ptrsub (v w: aval) := if Archi.ptr64 then ptrsub64 v w else ptrsub32 v w.
+
+Lemma ptrsub64_join_sound_l m b ofs n x y
+    (SF: Archi.ptr64 = true)
+    (VM1: vmatch (Vptr b ofs) x)
+    (VM2: vmatch (Vlong n) y) :
+  <<VM: vmatch (psubl_join m (Vptr b ofs) (Vlong n)) (ptrsub64 x y)>>.        
+Proof.
+  unfold psubl_join, Val.psubl, ptrsub64.
+  inv VM1; inv VM2; eauto using psub_sound, poffset_sound, pmatch_lub_l with va;
+  des_ifs; ss; try econs; des_ifs; econs.
+Qed.
+
+Lemma ptrsub64_join_sound_r m b ofs n x y
+    (SF: Archi.ptr64 = true)
+    (VM1: vmatch (Vlong n) x)
+    (VM2: vmatch (Vptr b ofs) y) :
+  <<VM: vmatch (psubl_join m (Vlong n) (Vptr b ofs)) (ptrsub64 x y)>>.        
+Proof.
+  unfold psubl_join, Val.psubl, ptrsub64.
+  inv VM1; inv VM2; eauto using psub_sound, poffset_sound, pmatch_lub_l with va;
+  des_ifs; ss; try econs; des_ifs; econs.
+Qed.
+
+Lemma ptrsub32_join_sound_l m b ofs n x y
+    (SF: Archi.ptr64 = false)
+    (VM1: vmatch (Vptr b ofs) x)
+    (VM2: vmatch (Vint n) y) :
+  <<VM: vmatch (psub_join m (Vptr b ofs) (Vint n)) (ptrsub32 x y)>>.        
+Proof.
+  unfold psub_join, Val.psub, ptrsub32.
+  inv VM1; inv VM2; eauto using psub_sound, poffset_sound, pmatch_lub_l with va;
+    des_ifs; ss; try econs; des_ifs; econs.
+Qed.
+
+Lemma ptrsub32_join_sound_r m b ofs n x y
+    (SF: Archi.ptr64 = false)
+    (VM1: vmatch (Vint n) x)
+    (VM2: vmatch (Vptr b ofs) y) :
+  <<VM: vmatch (psub_join m (Vint n) (Vptr b ofs)) (ptrsub32 x y)>>.        
+Proof.
+  unfold psub_join, Val.psub, ptrsub32.
+  inv VM1; inv VM2; eauto using psub_sound, poffset_sound, pmatch_lub_l with va;
+    des_ifs; ss; try econs; des_ifs; econs.
+Qed.
+
 (** Floating-point arithmetic operations *)
 
 Definition negf := unop_float Float.neg.
@@ -3190,6 +3292,10 @@ Definition ablock_storebytes (ab: ablock) (p: aptr) (ofs: Z) (sz: Z) :=
 Definition ablock_storebytes_anywhere (ab: ablock) (p: aptr) :=
   ablock_init (plub p ab.(ab_summary)).
 
+Definition bytes_not_pure_ifptr (m: mem) (b: block) :=
+  forall ofs v bytes av, Mem.loadbytes m b ofs (size_chunk Mptr) = Some bytes -> bytes_not_pure bytes = true ->
+                    Mem.load Mptr m b ofs = Some v -> vmatch v av -> exists ap, av = Ifptr ap.
+
 Definition smatch (m: mem) (b: block) (p: aptr) : Prop :=
   (forall chunk ofs v, Mem.load chunk m b ofs = Some v -> vmatch v (Ifptr p))
 /\(forall ofs b' ofs' q i, Mem.loadbytes m b ofs 1 = Some (Fragment (Vptr b' ofs') q i :: nil) -> pmatch b' ofs' p).
@@ -3197,13 +3303,61 @@ Definition smatch (m: mem) (b: block) (p: aptr) : Prop :=
 Remark loadbytes_load_ext:
   forall b m m',
   (forall ofs n bytes, Mem.loadbytes m' b ofs n = Some bytes -> n >= 0 -> Mem.loadbytes m b ofs n = Some bytes) ->
-  forall chunk ofs v, Mem.load chunk m' b ofs = Some v -> Mem.load chunk m b ofs = Some v.
+  forall chunk ofs v (CHUNK: chunk <> Mptr) (CHUNK2: chunk <> Many64), Mem.load chunk m' b ofs = Some v -> Mem.load chunk m b ofs = Some v.
 Proof.
   intros. exploit Mem.load_loadbytes; eauto. intros [bytes [A B]].
   exploit Mem.load_valid_access; eauto. intros [C D].
-  subst v. apply Mem.loadbytes_load; auto. apply H; auto. generalize (size_chunk_pos chunk); lia.
+  subst v. eapply H in A.
+  - eapply Mem.loadbytes_load in A; eauto.
+    rewrite Mem.normalize_mvs_not_ptr in *; eauto.
+  - generalize (size_chunk_pos chunk); lia.
+Qed.
+
+Remark loadbytes_load_ext_pure:
+  forall b m m',
+  (forall ofs n bytes, Mem.loadbytes m' b ofs n = Some bytes -> n >= 0 -> Mem.loadbytes m b ofs n = Some bytes) ->
+  forall chunk ofs v (PURE: forall bytes, Mem.loadbytes m b ofs (size_chunk chunk) = Some bytes -> Mem.change_check chunk bytes = false),
+    Mem.load chunk m' b ofs = Some v -> Mem.load chunk m b ofs = Some v.
+Proof.
+  Local Transparent Mem.load Mem.loadbytes. i.
+  exploit Mem.load_loadbytes; eauto. intros [bytes [A B]].
+  exploit H; eauto. { destruct chunk; ss; lia. } i.
+  exploit Mem.load_valid_access; eauto. intros [C D].
+  exploit Mem.loadbytes_load; eauto. i. subst. erewrite H2. f_equal. f_equal.
+  eapply Mem.change_check_fail_normalize_mvs_same. eapply PURE; eauto.
 Qed.
 
+Lemma load_ptr_all_ptr_frags chunk m b ofs b' ofs' bytes
+    (LOAD: Mem.load chunk m b ofs = Some (Vptr b' ofs'))
+    (LB: Mem.loadbytes m b ofs (size_chunk chunk) = Some bytes):
+  <<FRAGS: forallb is_ptr_mv bytes = true>>.
+Proof.
+  Local Transparent Mem.load Mem.loadbytes. unfold Mem.load in LOAD. des_ifs.
+  unfold decode_val in H0. destruct chunk; try by (ss; des_ifs).
+  - des_ifs. unfold Val.load_result in H0. des_ifs.
+    exploit Mem.ptr_proj_ptr_fragment; eauto. i.
+    eapply Mem.ptr_normalize_mvs_result_ptr in H.
+    unfold Mem.loadbytes in LB. des_ifs.
+  - des_ifs. unfold Val.load_result in H0.
+    exploit Mem.ptr_proj_ptr_fragment; eauto. i.
+    eapply Mem.ptr_normalize_mvs_result_ptr in H.
+    unfold Mem.loadbytes in LB. des_ifs.
+Qed.
+
+Lemma ptr_all_frags_pure_aux
+    chunk bytes (PTR: forallb is_ptr_mv bytes = true):
+  <<PURE: Mem.normalize_check chunk bytes = false>>.
+Proof.
+  r. unfold Mem.normalize_check. des_ifs.
+  - unfold Mem.is_mixed_mvs. erewrite PTR. ss. erewrite andb_false_r. ss.
+  - unfold Mem.is_mixed_mvs. erewrite PTR. ss. erewrite andb_false_r. ss.
+Qed.
+
+Lemma ptr_all_frags_pure
+    chunk bytes (PTR: forallb is_ptr_mv bytes = true):
+  <<PURE: Mem.change_check chunk bytes = false>>.
+Proof. r. unfold Mem.change_check. erewrite ptr_all_frags_pure_aux; eauto. Qed.
+
 Lemma smatch_ext:
   forall m b p m',
   smatch m b p ->
@@ -3211,7 +3365,35 @@ Lemma smatch_ext:
   smatch m' b p.
 Proof.
   intros. destruct H. split; intros.
-  eapply H; eauto. eapply loadbytes_load_ext; eauto.
+  destruct (classic (chunk = Mptr)).
+  2:{ destruct (classic (chunk = Many64)).
+      2:{ eapply H; eauto. eapply loadbytes_load_ext; eauto. }
+      subst. destruct v; try econs. exploit Mem.load_loadbytes; eauto. i. des.
+      assert (ONE: Mem.loadbytes m' b ofs 1 = Some (Mem.getN (Z.to_nat 1) ofs (Mem.mem_contents m') # b)).
+      { unfold Mem.loadbytes in H4. des_ifs.
+        assert (Mem.range_perm m' b ofs (ofs + 1) Cur Readable).
+        { ii. eapply r. unfold size_chunk. lia. }
+        unfold Mem.loadbytes. des_ifs. }
+      exploit load_ptr_all_ptr_frags; eauto. i. unfold Mem.normalize_mvs in H5.
+      erewrite ptr_all_frags_pure_aux in H5; eauto.
+      exploit H0; eauto. { lia. } i. ss. unfold decode_val in H5. des_ifs. ss.
+      unfold proj_value in H5. des_ifs. ss.
+      eapply H1 with (ofs:=ofs) (q:=q) (i:=n). rewrite H7.
+      repeat (eapply andb_prop in Heq0; des). clear Heq1. des_ifs. destruct q; ss.
+      clear - H4. unfold Mem.loadbytes in H4. des_ifs. rewrite H1. eauto. }
+  { subst. destruct v; try econs. unfold Mptr in *. des_ifs_safe. exploit Mem.load_loadbytes; eauto. i. des.
+      assert (ONE: Mem.loadbytes m' b ofs 1 = Some (Mem.getN (Z.to_nat 1) ofs (Mem.mem_contents m') # b)).
+      { unfold Mem.loadbytes in H3. des_ifs.
+        assert (Mem.range_perm m' b ofs (ofs + 1) Cur Readable).
+        { ii. eapply r. unfold size_chunk. lia. }
+        unfold Mem.loadbytes. des_ifs. }
+      exploit load_ptr_all_ptr_frags; eauto. i. unfold Mem.normalize_mvs in H4.
+      erewrite ptr_all_frags_pure_aux in H4; eauto.
+      exploit H0; eauto. { lia. } i.  ss. unfold decode_val in H4. des_ifs. ss.
+      unfold proj_value in H4. des_ifs. ss.
+      eapply H1 with (ofs:=ofs) (q:=q) (i:=n). rewrite H6.
+      repeat (eapply andb_prop in Heq2; des). clear Heq1. des_ifs. destruct q; ss.
+      clear - H3. unfold Mem.loadbytes in H3. des_ifs. rewrite H1. eauto. }
   eapply H1; eauto. apply H0; eauto. lia.
 Qed.
 
@@ -3363,6 +3545,15 @@ Proof.
 + apply pmatch_vplub. eapply B; eauto.
 Qed.
 
+Lemma pure_bytes_frags_exclusive bytes mvsb mvsf
+    (LEN: (length bytes > 0)%nat)
+    (BYTES: proj_bytes bytes = Some mvsb)
+    (FRAGS: proj_fragment bytes = Some mvsf):
+  False.
+Proof.
+  destruct bytes; [inv LEN|]. unfold proj_bytes, proj_fragment; ss. des_ifs.
+Qed.
+
 Lemma smatch_storebytes:
   forall m b ofs bytes m' b' p p',
   Mem.storebytes m b ofs bytes = Some m' ->
@@ -3375,6 +3566,9 @@ Proof.
   exploit Mem.load_loadbytes; eauto. intros (bytes' & P & Q).
   destruct bytes' as [ | byte1' bytes'].
   exploit Mem.loadbytes_length; eauto. intros. destruct chunk; discriminate.
+  assert (PURE: Mem.normalize_check chunk (byte1' :: bytes') = false).
+  { i. exploit load_ptr_all_ptr_frags; eauto. i. eapply ptr_all_frags_pure_aux; eauto. }
+  unfold Mem.normalize_mvs in Q. erewrite PURE in Q.
   generalize (decode_val_shape chunk byte1' bytes'). rewrite <- Q.
   intros DEC; inv DEC; try contradiction.
   assert (v = Vptr bx ofsx).
@@ -3392,7 +3586,10 @@ Qed.
 
 Definition bmatch (m: mem) (b: block) (ab: ablock) : Prop :=
   smatch m b ab.(ab_summary) /\
-  forall chunk ofs v, Mem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk ab ofs).
+  (forall chunk ofs v, Mem.load chunk m b ofs = Some v -> vmatch v (ablock_load chunk ab ofs)) /\
+  (forall ofs v bytes chunk (CHUNK: chunk = Mptr \/ chunk = Many64),
+      Mem.loadbytes m b ofs (size_chunk chunk) = Some bytes -> (Mem.change_check chunk bytes = true) ->
+      Mem.load chunk m b ofs = Some v -> exists ap, (ablock_load chunk ab ofs) = Ifptr ap).
 
 Lemma bmatch_ext:
   forall m b ab m',
@@ -3400,9 +3597,32 @@ Lemma bmatch_ext:
   (forall ofs n bytes, Mem.loadbytes m' b ofs n = Some bytes -> n >= 0 -> Mem.loadbytes m b ofs n = Some bytes) ->
   bmatch m' b ab.
 Proof.
-  intros. destruct H as [A B]. split; intros.
+  intros. destruct H as [A [B C]]. split; intros.
   apply smatch_ext with m; auto.
-  eapply B; eauto. eapply loadbytes_load_ext; eauto.
+  split; intros.
+  - destruct (classic (chunk = Mptr)).
+    { subst. exploit Mem.load_loadbytes; eauto. i. des.
+      exploit H0; eauto. { ss. } i.
+      exploit Mem.load_valid_access; try eapply H; eauto. i. destruct H4.
+      destruct (Mem.change_check Mptr bytes) eqn:BYTES.
+      { exploit Mem.loadbytes_load; eauto. i. exploit C; try eapply H6; eauto. i. des.
+        rewrite H7. destruct v; try by econs. exploit load_ptr_all_ptr_frags; eauto. i.
+        unfold Mem.normalize_mvs in H6. erewrite ptr_all_frags_pure in BYTES; eauto. clarify. }
+      eapply B. eapply loadbytes_load_ext_pure; eauto. i. clarify. }
+    rename H1 into NOTPTR.
+    destruct (classic (chunk = Many64)).
+    { subst. exploit Mem.load_loadbytes; eauto. i. des.
+      exploit H0; eauto. { ss. } i.
+      exploit Mem.load_valid_access; try eapply H; eauto. i. destruct H4.
+      destruct (Mem.change_check Mptr bytes) eqn:BYTES.
+      { exploit Mem.loadbytes_load; eauto. i. exploit C; try eapply H6; eauto. i. des.
+        rewrite H7. destruct v; try by econs. exploit load_ptr_all_ptr_frags; eauto. i.
+        unfold Mem.normalize_mvs in H6. erewrite ptr_all_frags_pure in BYTES; eauto. clarify. }
+      eapply B. eapply loadbytes_load_ext_pure; eauto. i. clarify. }
+    eapply B; eauto. eapply loadbytes_load_ext; eauto.
+  - exploit H0; eauto. { destruct chunk; ss. } i.
+    exploit Mem.load_valid_access; try eapply H; eauto. i. destruct H4.
+    exploit Mem.loadbytes_load. eauto. eauto. i. eapply C; eauto.
 Qed.
 
 Lemma bmatch_inv:
@@ -3421,7 +3641,7 @@ Lemma ablock_load_sound:
   bmatch m b ab ->
   vmatch v (ablock_load chunk ab ofs).
 Proof.
-  intros. destruct H0. eauto.
+  intros. destruct H0. destruct H1. eauto.
 Qed.
 
 Lemma ablock_load_anywhere_sound:
@@ -3437,9 +3657,13 @@ Qed.
 Lemma ablock_init_sound:
   forall m b p, smatch m b p -> bmatch m b (ablock_init p).
 Proof.
-  intros; split; auto; intros.
+  intros; split; auto; intros. split; intros.
   unfold ablock_load, ablock_init; simpl. rewrite ZTree.gempty.
   eapply vnormalize_cast; eauto. eapply H; eauto.
+  unfold ablock_init, ablock_load. ss. rewrite ZTree.gempty.
+  des; subst.
+  - unfold vnormalize, Mptr. des_ifs. eauto.
+  - ss. eauto.
 Qed.
 
 Lemma ablock_store_anywhere_sound:
@@ -3545,6 +3769,21 @@ Proof.
   destruct c, c'; intros; try discriminate; simpl; auto with va.
 Qed.
 
+
+Lemma all_undef_pure
+    bytes (UNDEF: bytes_all_undef bytes = true):
+  <<PURE: bytes_not_pure bytes = false>>.
+Proof.
+  ginduction bytes; ss. i. unfold bytes_not_pure. r. apply andb_prop in UNDEF. des.
+  exploit IHbytes; eauto. i. eapply orb_false_iff in H. des. rewrite orb_false_iff. split.
+  - unfold proj_fragment_byte_mixed in *. eapply andb_false_iff in H. des.
+    { ss. rewrite H. destruct a; ss. }
+    ss. rewrite H. destruct a; ss. eapply andb_false_r.
+  - unfold proj_fragment_mixed in *. eapply andb_false_iff in H0. des.
+    { ss. rewrite H0. destruct a; ss. }
+    ss. rewrite H0. destruct a; ss. eapply andb_false_r.
+Qed.
+
 Lemma ablock_store_sound:
   forall chunk m b ofs v m' ab av,
   Mem.store chunk m b ofs v = Some m' ->
@@ -3552,8 +3791,46 @@ Lemma ablock_store_sound:
   vmatch v av ->
   bmatch m' b (ablock_store chunk ab ofs av).
 Proof.
-  intros until av; intros STORE BIN VIN. destruct BIN as [BIN1 BIN2]. split.
-  eapply smatch_store; eauto.
+  intros until av; intros STORE BIN VIN. destruct BIN as [BIN1 [BIN2 BIN3]]. split.
+  eapply smatch_store; eauto. split; cycle 1.
+  { intros ofs' v' bytes' chunk' CHK LB NPURE LOAD.
+    des; cycle 1.
+    { subst. unfold ablock_load.
+      destruct ((ab_contents (ablock_store chunk ab ofs av)) ## ofs') as [[chunk1 av1]|] eqn:C; cycle 1.
+      { unfold vnormalize. des_ifs; eauto. }
+      destruct (chunk_compat Many64 chunk1) eqn:COMPAT; cycle 1.
+      { unfold vnormalize. des_ifs; eauto. }
+      exploit chunk_compat_true; eauto. intros (U & V & W).
+      exploit ablock_store_contents; eauto. intros [(P & Q & R) | (P & Q)].
+      - subst. exfalso.
+        assert (Mem.change_check chunk bytes' = false).
+        { rewrite U in LB. i. exploit Mem.store_pure_memval_check; eauto. }
+        destruct chunk; ss. clarify.
+      - assert (Mem.load Many64 m b ofs' = Some v').
+        { rewrite <- LOAD. symmetry. eapply Mem.load_store_other; eauto.
+          rewrite U. auto. }
+        assert (Mem.loadbytes m b ofs' (size_chunk Many64) = Some bytes').
+        { rewrite <- LB. symmetry. eapply Mem.loadbytes_store_other; eauto.
+          rewrite U. auto. }
+        exploit BIN3; eauto. unfold ablock_load. rewrite P, COMPAT. eauto. }
+    subst. unfold ablock_load.
+    destruct ((ab_contents (ablock_store chunk ab ofs av)) ## ofs') as [[chunk1 av1]|] eqn:C; cycle 1.
+    { unfold vnormalize. des_ifs; eauto. }
+    destruct (chunk_compat Mptr chunk1) eqn:COMPAT; cycle 1.
+    { unfold vnormalize. des_ifs; eauto. }
+    exploit chunk_compat_true; eauto. intros (U & V & W).
+    exploit ablock_store_contents; eauto. intros [(P & Q & R) | (P & Q)].
+    - subst. exfalso.
+      assert (Mem.change_check chunk bytes' = false).
+      { rewrite U in LB. i. exploit Mem.store_pure_memval_check; eauto. }
+      destruct chunk; ss. unfold Mptr in NPURE. des_ifs; clarify.
+    - assert (Mem.load Mptr m b ofs' = Some v').
+      { rewrite <- LOAD. symmetry. eapply Mem.load_store_other; eauto.
+        rewrite U. auto. }
+      assert (Mem.loadbytes m b ofs' (size_chunk Mptr) = Some bytes').
+      { rewrite <- LB. symmetry. eapply Mem.loadbytes_store_other; eauto.
+        rewrite U. auto. }
+      exploit BIN3; try eapply H; eauto. unfold ablock_load. rewrite P, COMPAT. eauto. }
   intros chunk' ofs' v' LOAD.
   assert (SUMMARY: vmatch v' (vnormalize chunk' (Ifptr (vplub av ab.(ab_summary))))).
   { exploit smatch_store; eauto. intros [A B]. eapply vnormalize_cast; eauto. }
@@ -3595,6 +3872,11 @@ Proof.
   eapply smatch_storebytes; eauto.
 Qed.
 
+Lemma ablock_storebytes_anywhere_zero_sound m p b' ab
+    (BM: bmatch m b' ab):
+  <<STBM: bmatch m b' (ablock_storebytes_anywhere ab p)>>.
+Proof. destruct BM as [A B]. apply ablock_init_sound. eapply smatch_ge; eauto. eapply pge_lub_r. Qed.
+
 Lemma ablock_storebytes_contents:
   forall ab p i sz j chunk' av',
   (ablock_storebytes ab p i sz).(ab_contents)##j = Some(ACval chunk' av') ->
@@ -3615,8 +3897,31 @@ Lemma ablock_storebytes_sound:
   bmatch m b ab ->
   bmatch m' b (ablock_storebytes ab p ofs sz).
 Proof.
-  intros until sz; intros STORE LENGTH CONTENTS BM. destruct BM as [BM1 BM2]. split.
+  intros until sz; intros STORE LENGTH CONTENTS BM. destruct BM as [BM1 [BM2 BM3]]. split.
   eapply smatch_storebytes; eauto.
+  split; cycle 1.
+  { i. unfold ablock_load.
+    destruct (ab_contents (ablock_storebytes ab p ofs sz))##ofs0 as [[chunk' av]|] eqn:C; auto.
+    2:{ unfold vnormalize. des; subst; ss. des_ifs; esplits; eauto. eauto. }
+    destruct (chunk_compat chunk chunk') eqn:COMPAT; auto.
+    2:{ unfold vnormalize. des; subst; ss. des_ifs; esplits; eauto. eauto. }
+    exploit chunk_compat_true; eauto. intros (U & V & W).
+    exploit ablock_storebytes_contents; eauto. intros [A B].
+    inv CHUNK; subst.
+    - assert (Mem.load Mptr m b ofs0 = Some v).
+      { rewrite <- H1. symmetry. eapply Mem.load_storebytes_other; eauto.
+        rewrite U. rewrite LENGTH. right. lia. }
+      assert (Mem.loadbytes m b ofs0 (size_chunk Mptr) = Some bytes0).
+      { rewrite <- H. symmetry. eapply Mem.loadbytes_storebytes_other; eauto.
+        rewrite U. destruct chunk'; ss. rewrite U. rewrite LENGTH. lia. }
+      exploit BM3; try eapply H2; eauto. unfold ablock_load. rewrite A, COMPAT. eauto.
+    - assert (Mem.load Many64 m b ofs0 = Some v).
+      { rewrite <- H1. symmetry. eapply Mem.load_storebytes_other; eauto.
+        rewrite U. rewrite LENGTH. right. lia. }
+      assert (Mem.loadbytes m b ofs0 (size_chunk Many64) = Some bytes0).
+      { rewrite <- H. symmetry. eapply Mem.loadbytes_storebytes_other; eauto.
+        rewrite U. destruct chunk'; ss. rewrite U. rewrite LENGTH. lia. }
+      exploit BM3; try eapply H2; eauto. unfold ablock_load. rewrite A, COMPAT. eauto. }
   intros chunk' ofs' v' LOAD'.
   assert (SUMMARY: vmatch v' (vnormalize chunk' (Ifptr (plub p ab.(ab_summary))))).
   { exploit smatch_storebytes; eauto. intros [A B]. eapply vnormalize_cast; eauto. }
@@ -3631,6 +3936,33 @@ Proof.
   exploit BM2; eauto. unfold ablock_load. rewrite A. rewrite COMPAT. auto.
 Qed.
 
+Lemma ablock_storebytes_zero_sound m b ofs p ab
+    (BM: bmatch m b ab):
+  <<STBM: bmatch m b (ablock_storebytes ab p ofs 0)>>.
+Proof.
+  destruct BM as [BM1 [BM2 BM3]]. split.
+  { ss. eapply smatch_ge; eauto. eapply pge_lub_r. }
+  split; cycle 1.
+  {  i. unfold ablock_load.
+    destruct (ab_contents (ablock_storebytes ab p ofs 0))##ofs0 as [[chunk' av]|] eqn:C; auto.
+    2:{ unfold vnormalize. des; subst; ss. des_ifs; esplits; eauto. eauto. }
+    destruct (chunk_compat chunk chunk') eqn:COMPAT; auto.
+    2:{ unfold vnormalize. des; subst; ss. des_ifs; esplits; eauto. eauto. }
+    exploit chunk_compat_true; eauto. intros (U & V & W).
+    exploit ablock_storebytes_contents; eauto. intros [A B].
+    exploit BM3; try eapply H1; eauto. unfold ablock_load. des_ifs. }
+  intros chunk' ofs' v' LOAD'. ss. unfold ablock_load.
+  assert (SUMMARY: vmatch v' (vnormalize chunk' (Ifptr (plub p ab.(ab_summary))))).
+  { destruct BM1 as [A B]. exploit A; eauto. i. eapply vnormalize_cast; eauto.
+    eapply vmatch_ge; eauto. eapply vge_ip_ip. eapply pge_lub_r. }
+  unfold ablock_load.
+  destruct (ab_contents (ablock_storebytes ab p ofs 0))##ofs' as [[chunk av]|] eqn:C; auto.
+  destruct (chunk_compat chunk' chunk) eqn:COMPAT; auto.
+  exploit chunk_compat_true; eauto. intros (U & V & W).
+  exploit ablock_storebytes_contents; eauto. intros [A B].
+  exploit BM2; eauto. unfold ablock_load. rewrite A. rewrite COMPAT. auto.
+Qed.
+
 (** Boolean equality *)
 
 Definition bbeq (ab1 ab2: ablock) : bool :=
@@ -3661,7 +3993,12 @@ Lemma bbeq_sound:
   forall m b, bmatch m b ab1 <-> bmatch m b ab2.
 Proof.
   intros. exploit bbeq_load; eauto. intros [A B].
-  unfold bmatch. rewrite A. intuition. rewrite <- B; eauto. rewrite B; eauto.
+  unfold bmatch. rewrite A. intuition. rewrite <- B; eauto.
+  - subst. exploit H3; try eapply H5; eauto. i. des. exists ap. rewrite <- B. eauto.
+  - subst. exploit H3; try eapply H5; eauto. i. des. exists ap. rewrite <- B. eauto.
+  - rewrite B; eauto.
+  - subst. exploit H3; try eapply H5; eauto. i. des. exists ap. rewrite <- H6. eauto.
+  - subst. exploit H3; try eapply H5; eauto. i. des. exists ap. rewrite <- H6. eauto.
 Qed.
 
 (** Least upper bound *)
@@ -3697,7 +4034,7 @@ Qed.
 Lemma bmatch_lub_l:
   forall m b x y, bmatch m b x -> bmatch m b (blub x y).
 Proof.
-  intros. destruct H as [BM1 BM2]. split; unfold blub; simpl.
+  intros. destruct H as [BM1 [BM2 BM3]]. split; unfold blub; simpl;[|split].
 - apply smatch_lub_l; auto.
 - intros.
   assert (SUMMARY: vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))
@@ -3711,12 +4048,32 @@ Proof.
   destruct (chunk_eq chunkx chunky); auto. subst chunky.
   destruct (chunk_compat chunk chunkx); auto.
   intros. eapply vmatch_ge; eauto. apply vnormalize_monotone. apply vge_lub_l.
+- i. exploit BM3; eauto. i. des_safe. unfold ablock_load in *. ss.
+  unfold ablock_load; simpl. rewrite ZTree.gcombine by auto.
+  unfold combine_acontents;
+  destruct (ab_contents x)##ofs as [[chunkx avx]|], (ab_contents y)##ofs as [[chunky avy]|]; auto.
+  2:{ unfold vnormalize. des; subst; ss; des_ifs; eauto. }
+  2:{ unfold vnormalize. des; subst; ss; des_ifs; eauto. }
+  2:{ unfold vnormalize. des; subst; ss; des_ifs; eauto. }
+  destruct (chunk_eq chunkx chunky); auto. subst chunky.
+  2:{ unfold vnormalize. des; subst; ss; des_ifs; eauto. }
+  destruct (chunk_compat chunk chunkx); auto.
+  2:{ unfold vnormalize. des; subst; ss; des_ifs; eauto. }
+  des; subst; cycle 1.
+  + unfold vnormalize in H2. des_ifs. ss. des_ifs; eauto.
+  + unfold Mptr in *. des_ifs_safe. unfold vnormalize in H2. des_ifs.
+    * ss. des_ifs; eauto; unfold sgn in *; des_ifs; unfold uns in *; des_ifs.
+    * ss. des_ifs; eauto; unfold sgn in *; des_ifs; unfold uns in *; des_ifs.
+    * ss. des_ifs; eauto; unfold sgn in *; des_ifs; unfold uns in *; des_ifs.
+    * ss. des_ifs; eauto.
+    * ss. des_ifs; eauto.
+    * ss. des_ifs; eauto.
 Qed.
 
 Lemma bmatch_lub_r:
   forall m b x y, bmatch m b y -> bmatch m b (blub x y).
 Proof.
-  intros. destruct H as [BM1 BM2]. split; unfold blub; simpl.
+  intros. destruct H as [BM1 [BM2 BM3]]. split; unfold blub; simpl; [|split].
 - apply smatch_lub_r; auto.
 - intros.
   assert (SUMMARY: vmatch v (vnormalize chunk (Ifptr (plub (ab_summary x) (ab_summary y))))
@@ -3730,6 +4087,27 @@ Proof.
   destruct (chunk_eq chunkx chunky); auto. subst chunky.
   destruct (chunk_compat chunk chunkx); auto.
   intros. eapply vmatch_ge; eauto. apply vnormalize_monotone. apply vge_lub_r.
+- i. exploit BM3; eauto. i. des_safe. unfold ablock_load in *. ss.
+  unfold ablock_load; simpl. rewrite ZTree.gcombine by auto.
+  unfold combine_acontents;
+  destruct (ab_contents x)##ofs as [[chunkx avx]|], (ab_contents y)##ofs as [[chunky avy]|]; auto.
+  2:{ unfold vnormalize. des; subst; ss; des_ifs; eauto. }
+  2:{ unfold vnormalize. des; subst; ss; des_ifs; eauto. }
+  2:{ unfold vnormalize. des; subst; ss; des_ifs; eauto. }
+  destruct (chunk_eq chunkx chunky); auto. subst chunky.
+  2:{ unfold vnormalize. des; subst; ss; des_ifs; eauto. }
+  destruct (chunk_compat chunk chunkx); auto.
+  2:{ unfold vnormalize. des; subst; ss; des_ifs; eauto. }
+  rewrite vlub_comm.
+  des; subst; cycle 1.
+  + unfold vnormalize in H2. des_ifs. ss. des_ifs; eauto.
+  + unfold Mptr in *. des_ifs_safe. unfold vnormalize in H2. des_ifs.
+    * ss. des_ifs; eauto; unfold sgn in *; des_ifs; unfold uns in *; des_ifs.
+    * ss. des_ifs; eauto; unfold sgn in *; des_ifs; unfold uns in *; des_ifs.
+    * ss. des_ifs; eauto; unfold sgn in *; des_ifs; unfold uns in *; des_ifs.
+    * ss. des_ifs; eauto.
+    * ss. des_ifs; eauto.
+    * ss. des_ifs; eauto.
 Qed.
 
 (** * Abstracting read-only global variables *)
@@ -3811,13 +4189,34 @@ Proof.
   apply H0. congruence.
 Qed.
 
+Lemma romatch_capture m b addr m' rm
+    (CAP: Mem.capture m b addr m')
+    (RM: romatch m rm):
+  romatch m' rm.
+Proof.
+  i. apply romatch_ext with m; auto; i.
+  - erewrite <- Mem.loadbytes_capture_unchanged; eauto.
+  - unfold Mem.perm in *. inv CAP. rewrite ACCESS; eauto.
+Qed.
+
+Lemma romatch_capture_list m blks addrs m' rm
+    (CAP: Mem.capture_list m blks addrs m')
+    (RM: romatch m rm):
+  romatch m' rm.
+Proof.
+  ginduction blks; ss; i; [inv CAP; eauto|].
+  inv CAP. eapply IHblks; eauto. eapply romatch_capture; eauto.
+Qed.
+
+
 (** * Abstracting memory states *)
 
 Record amem : Type := AMem {
   am_stack: ablock;
   am_glob: PTree.t ablock;
   am_nonstack: aptr;
-  am_top: aptr
+  am_top: aptr;
+  am_concrete_stack: bool;
 }.
 
 Record mmatch (m: mem) (am: amem) : Prop := mk_mem_match {
@@ -3835,17 +4234,24 @@ Record mmatch (m: mem) (am: amem) : Prop := mk_mem_match {
     bc b <> BCinvalid ->
     smatch m b am.(am_top);
   mmatch_below:
-    bc_below bc (Mem.nextblock m)
+    bc_below bc (Mem.nextblock m);
+  mmatch_logical: forall b,
+    bc b = BCinvalid -> m.(Mem.mem_concrete)!b = None;
+  mmatch_logical_stack: forall sp,
+    bc sp = BCstack ->
+    am.(am_concrete_stack) = false ->
+    m.(Mem.mem_concrete)!sp = None;
 }.
 
-Definition minit (p: aptr) :=
+Definition minit (p: aptr) (concstack: bool):=
   {| am_stack := ablock_init p;
      am_glob := PTree.empty _;
      am_nonstack := p;
-     am_top := p |}.
+     am_top := p;
+     am_concrete_stack := concstack |}.
 
-Definition mbot := minit Pbot.
-Definition mtop := minit Ptop.
+Definition mbot := minit Pbot false.
+Definition mtop := minit Ptop true.
 
 Definition load (chunk: memory_chunk) (rm: romem) (m: amem) (p: aptr) : aval :=
   match p with
@@ -3875,7 +4281,7 @@ Definition load (chunk: memory_chunk) (rm: romem) (m: amem) (p: aptr) : aval :=
   end.
 
 Definition loadv (chunk: memory_chunk) (rm: romem) (m: amem) (addr: aval) : aval :=
-  load chunk rm m (aptr_of_aval addr).
+  load chunk rm m (aptr_of_aval addr (m.(am_concrete_stack))).
 
 Definition store (chunk: memory_chunk) (m: amem) (p: aptr) (av: aval) : amem :=
   {| am_stack :=
@@ -3900,11 +4306,12 @@ Definition store (chunk: memory_chunk) (m: amem) (p: aptr) (av: aval) : amem :=
        | Gl _ _ | Glo _ | Glob | Nonstack | Ptop => vplub av m.(am_nonstack)
        | _ => m.(am_nonstack)
        end;
-     am_top := vplub av m.(am_top)
+     am_top := vplub av m.(am_top);
+     am_concrete_stack := m.(am_concrete_stack);
   |}.
 
 Definition storev (chunk: memory_chunk) (m: amem) (addr: aval) (v: aval): amem :=
-  store chunk m (aptr_of_aval addr) v.
+  store chunk m (aptr_of_aval addr (m.(am_concrete_stack))) v.
 
 Definition loadbytes (m: amem) (rm: romem) (p: aptr) : aptr :=
   match p with
@@ -3946,7 +4353,8 @@ Definition storebytes (m: amem) (dst: aptr) (sz: Z) (p: aptr) : amem :=
        | Gl _ _ | Glo _ | Glob | Nonstack | Ptop => plub p m.(am_nonstack)
        | _ => m.(am_nonstack)
        end;
-     am_top := plub p m.(am_top)
+     am_top := plub p m.(am_top);
+     am_concrete_stack := m.(am_concrete_stack);
   |}.
 
 Theorem load_sound:
@@ -3982,6 +4390,65 @@ Proof.
   eapply vnormalize_cast; eauto. eapply mmatch_top; eauto.
 Qed.
 
+Lemma captured_valid m am z b
+    (MM: mmatch m am)
+    (CPT: m.(Mem.mem_concrete) ! b = Some z) :
+  <<VLDBLK: bc b <> BCinvalid>>.
+Proof.
+  destruct (classic (bc b = BCinvalid)); eauto.
+  exploit mmatch_logical; eauto. i. clarify.
+Qed.
+
+Lemma captured_not_stack m am z b
+    (MM: mmatch m am)
+    (LSTK: am.(am_concrete_stack) = false)
+    (CPT: m.(Mem.mem_concrete) ! b = Some z) :
+  <<VLDBLK: bc b <> BCstack>>.
+Proof.
+  destruct (classic (bc b = BCstack)); eauto.
+  exploit mmatch_logical_stack; eauto. i. clarify.
+Qed.
+
+Lemma denormalized_not_stack m am z b o
+    (MM: mmatch m am)
+    (LSTK: am.(am_concrete_stack) = false)
+    (DENO: Mem.denormalize z m = Some (b, o)) :
+  <<VLDBLK: bc b <> BCstack>>.
+Proof. eapply Mem.denormalize_info in DENO. des. eapply captured_not_stack; eauto. Qed.
+
+Lemma denormalized_valid m am z b o
+    (MM: mmatch m am)
+    (DENO: Mem.denormalize z m = Some (b, o)) :
+  <<VLDBLK: bc b <> BCinvalid>>.
+Proof. eapply Mem.denormalize_info in DENO. des. eapply captured_valid; eauto. Qed.
+
+Lemma denormalized_nonstack m am z b o
+    (MM: mmatch m am)
+    (LSTK: am.(am_concrete_stack) = false)
+    (DENO: Mem.denormalize z m = Some (b, o)) :
+  <<NSTK: pmatch b (Ptrofs.repr o) Nonstack>>.
+Proof. econs. eapply denormalized_not_stack; eauto. eapply denormalized_valid; eauto. Qed.
+
+Lemma to_ptr_not_stack m am n b o
+    (MM: mmatch m am)
+    (LSTK: am.(am_concrete_stack) = false)
+    (TOPTR: Mem.to_ptr (Vlong n) m = Some (Vptr b o)) :
+  <<VLDBLK: bc b <> BCstack>>.
+Proof. unfold Mem.to_ptr in TOPTR. des_ifs. eapply denormalized_not_stack; eauto. Qed.
+
+Lemma to_ptr_valid m am n b o
+    (MM: mmatch m am)
+    (TOPTR: Mem.to_ptr (Vlong n) m = Some (Vptr b o)) :
+  <<VLDBLK: bc b <> BCinvalid>>.
+Proof. unfold Mem.to_ptr in TOPTR. des_ifs. eapply denormalized_valid; eauto. Qed.
+
+Lemma to_ptr_nonstack m am n b o
+    (MM: mmatch m am)
+    (LSTK: am.(am_concrete_stack) = false)
+    (TOPTR: Mem.to_ptr (Vlong n) m = Some (Vptr b o)) :
+  <<NSTK: pmatch b o Nonstack>>.
+Proof. unfold Mem.to_ptr in TOPTR. des_ifs. eapply denormalized_nonstack; eauto. Qed.
+
 Theorem loadv_sound:
   forall chunk m addr v rm am aaddr,
   Mem.loadv chunk m addr = Some v ->
@@ -3990,8 +4457,41 @@ Theorem loadv_sound:
   vmatch addr aaddr ->
   vmatch v (loadv chunk rm am aaddr).
 Proof.
-  intros. destruct addr; simpl in H; try discriminate.
-  eapply load_sound; eauto. apply match_aptr_of_aval; auto.
+  intros. destruct addr; unfold Mem.loadv in H; simpl in H; try discriminate.
+  { des_ifs.
+    assert (bc b <> BCinvalid).
+    { eapply denormalized_valid; eauto. }
+    eapply Mem.denormalize_info in Heq2. des.
+    replace z with (Ptrofs.unsigned (Ptrofs.repr z)) in H.
+    2:{ rewrite Ptrofs.unsigned_repr; eauto. }
+    unfold loadv. inv H2; simpl in *.
+    - des_ifs.
+      + exploit mmatch_top; eauto. i. unfold smatch in H2. des.
+        eapply vnormalize_cast; eauto.
+      + assert (bc b <> BCstack).
+        { ii. exploit mmatch_logical_stack; eauto. i. clarify. }
+        eapply vnormalize_cast; eauto. eapply mmatch_nonstack; eauto.
+    - destruct (am_concrete_stack am) eqn:CONCSTK.
+      + eapply vnormalize_cast; eauto. eapply mmatch_top; eauto.
+      + assert (bc b <> BCstack).
+        { ii. exploit mmatch_logical_stack; eauto. i. clarify. }
+        destruct p; try (eapply vnormalize_cast; eauto; eapply mmatch_top; eauto).
+        { eapply vnormalize_cast; eauto. eapply mmatch_nonstack; eauto. }
+        { eapply vnormalize_cast; eauto. eapply mmatch_nonstack; eauto. }
+        { eapply vnormalize_cast; eauto. eapply mmatch_nonstack; eauto. }
+        { eapply vnormalize_cast; eauto. eapply mmatch_nonstack; eauto. }
+        { eapply vnormalize_cast; eauto. eapply mmatch_nonstack; eauto. } }
+  inv H2.
+  - simpl. eapply load_sound; eauto.
+  - unfold loadv. ss.
+    simpl. destruct (am_concrete_stack am) eqn:CONCSTK.
+    { ss. eapply vnormalize_cast; eauto. eapply mmatch_top; eauto.
+      ii. inv H6; ii; rewrite H2 in *; clarify. }
+    inv H6; ss; try (eapply vnormalize_cast; eauto; eapply mmatch_top; eauto; ii; rewrite H2 in *; clarify).
+    + eapply vnormalize_cast; eauto. eapply mmatch_nonstack; eauto; ii; Eq.
+    + eapply vnormalize_cast; eauto. eapply mmatch_nonstack; eauto; ii; Eq.
+    + eapply vnormalize_cast; eauto. eapply mmatch_nonstack; eauto; ii; Eq.
+    + eapply vnormalize_cast; eauto. eapply mmatch_nonstack; eauto; ii; Eq.
 Qed.
 
 Theorem store_sound:
@@ -4058,6 +4558,28 @@ Proof.
 
 - (* Below *)
   erewrite Mem.nextblock_store by eauto. eapply mmatch_below; eauto.
+
+- (* invalid logical *)
+  rewrite <- Mem.concrete_store with (chunk:=chunk) (m1:=m) (b:=b) (ofs:=Ptrofs.unsigned ofs) (v:=v); auto. inversion MM.
+  apply mmatch_logical0. auto.
+
+- (* logical stack *)
+  rewrite <- Mem.concrete_store with (chunk:=chunk) (m1:=m) (b:=b) (ofs:=Ptrofs.unsigned ofs) (v:=v); auto. inversion MM.
+  apply mmatch_logical_stack0; auto.   
+Qed.
+
+Lemma mmatch_top':
+  forall m am, mmatch m am -> mmatch m mtop.
+Proof.
+  intros. constructor; simpl; intros.
+- apply ablock_init_sound. apply smatch_ge with (ab_summary (am_stack am)).
+  eapply mmatch_stack; eauto. constructor.
+- rewrite PTree.gempty in H1; discriminate.
+- eapply smatch_ge. eapply mmatch_nonstack; eauto. constructor.
+- eapply smatch_ge. eapply mmatch_top; eauto. constructor.
+- eapply mmatch_below; eauto.
+- inversion H; auto.
+- inversion H1.
 Qed.
 
 Theorem storev_sound:
@@ -4069,7 +4591,85 @@ Theorem storev_sound:
   mmatch m' (storev chunk am aaddr av).
 Proof.
   intros. destruct addr; simpl in H; try discriminate.
-  eapply store_sound; eauto. apply match_aptr_of_aval; auto.
+  { des_ifs. eapply Mem.denormalize_info in Heq0. des.
+    assert (bc b <> BCinvalid).
+    { eapply captured_valid; eauto. }
+    replace z with (Ptrofs.unsigned (Ptrofs.repr z)) in H.
+    2:{ rewrite Ptrofs.unsigned_repr; eauto. }
+    unfold storev. inv H1.
+    - simpl. rewrite Heq. econs; ss; i.
+      + assert (DFL: bc b <> BCstack -> bmatch m' b0 (am_stack am)).
+        { intros. apply bmatch_inv with m. eapply mmatch_stack; eauto.
+          intros. eapply Mem.loadbytes_store_other; eauto. left; congruence. }
+        destruct (am_concrete_stack am) eqn:CONCSTK.
+        { simpl. eapply ablock_store_anywhere_sound; eauto. eapply mmatch_stack; eauto. }
+        assert (bc b <> BCstack).
+        { ii. exploit mmatch_logical_stack; eauto. i. clarify. }
+        assert (b <> b0); eauto.
+        { ii. subst. rewrite H1 in H4. clarify. }
+      + des_ifs; rewrite PTree.gempty in H4; congruence.
+      + assert (DFL: smatch m' b0 (vplub av (am_nonstack am))); eauto.
+        { eapply smatch_store; eauto. eapply mmatch_nonstack; eauto. }
+        des_ifs; ss.
+      + eapply smatch_store; eauto. eapply mmatch_top; eauto.
+      + erewrite Mem.nextblock_store by eauto. eapply mmatch_below; eauto.
+      + rewrite <- Mem.concrete_store with
+          (chunk:=chunk) (m1:=m) (b:=b) (ofs:=(Ptrofs.unsigned (Ptrofs.repr (Int64.unsigned i - caddr)))) (v:=v); auto.
+        eapply mmatch_logical; eauto.
+      + rewrite <- Mem.concrete_store with
+          (chunk:=chunk) (m1:=m) (b:=b) (ofs:=(Ptrofs.unsigned (Ptrofs.repr (Int64.unsigned i - caddr)))) (v:=v); auto.
+        eapply mmatch_logical_stack; eauto.
+    - simpl. econs; ss; i.
+      + assert (DFL: bc b <> BCstack -> bmatch m' b0 (am_stack am)).
+        { intros. apply bmatch_inv with m. eapply mmatch_stack; eauto.
+          intros. eapply Mem.loadbytes_store_other; eauto. left; congruence. }
+        destruct (am_concrete_stack am) eqn:CONCSTK.
+        { simpl. eapply ablock_store_anywhere_sound; eauto. eapply mmatch_stack; eauto. }
+        assert (bc b <> BCstack).
+        { ii. exploit mmatch_logical_stack; eauto. i. clarify. }
+        assert (b <> b0).
+        { ii. subst. rewrite H1 in H4. clarify. }
+        destruct p; try (eapply ablock_store_anywhere_sound; eauto; eapply mmatch_stack; eauto); eauto.
+      + des_ifs; rewrite PTree.gempty in H4; congruence.
+      + assert (DFL: smatch m' b0 (vplub av (am_nonstack am))); eauto.
+        { eapply smatch_store; eauto. eapply mmatch_nonstack; eauto. }
+        des_ifs; ss.
+      + eapply smatch_store; eauto. eapply mmatch_top; eauto.
+      + erewrite Mem.nextblock_store by eauto. eapply mmatch_below; eauto.
+      + rewrite <- Mem.concrete_store with
+          (chunk:=chunk) (m1:=m) (b:=b) (ofs:=(Ptrofs.unsigned (Ptrofs.repr (Int64.unsigned i - caddr)))) (v:=v); auto.
+        eapply mmatch_logical; eauto.
+      + rewrite <- Mem.concrete_store with
+          (chunk:=chunk) (m1:=m) (b:=b) (ofs:=(Ptrofs.unsigned (Ptrofs.repr (Int64.unsigned i - caddr)))) (v:=v); auto.
+        eapply mmatch_logical_stack; eauto. }
+  inv H1.
+  - eapply store_sound; eauto.
+  - simpl. econs; ss; i.
+    + assert (DFL: bc b <> BCstack -> bmatch m' b0 (am_stack am)).
+      { intros. apply bmatch_inv with m. eapply mmatch_stack; eauto.
+        intros. eapply Mem.loadbytes_store_other; eauto. left; congruence. }
+      destruct (am_concrete_stack am) eqn:CONCSTK.
+      { simpl. eapply ablock_store_anywhere_sound; eauto. eapply mmatch_stack; eauto. }
+      destruct (classic (bc b = BCstack)).
+      2:{ des_ifs; eauto; inv H6; try rewrite H5 in *; clarify.
+          eapply ablock_store_anywhere_sound; eauto. eapply mmatch_stack; eauto. }
+      assert (b0 = b) by (eapply bc_stack; eauto). subst b0.
+      inv H6; ss; Eq.
+      { eapply ablock_store_anywhere_sound; eauto. eapply mmatch_stack; eauto. }
+      { eapply ablock_store_anywhere_sound; eauto. eapply mmatch_stack; eauto. }
+      { eapply ablock_store_anywhere_sound; eauto. eapply mmatch_stack; eauto. }
+    + des_ifs; rewrite PTree.gempty in H3; congruence.
+    + assert (DFL: smatch m' b0 (vplub av (am_nonstack am))); eauto.
+      { eapply smatch_store; eauto. eapply mmatch_nonstack; eauto. }
+      des_ifs; ss.
+    + eapply smatch_store; eauto. eapply mmatch_top; eauto.
+    + erewrite Mem.nextblock_store by eauto. eapply mmatch_below; eauto.
+    + rewrite <- Mem.concrete_store with
+        (chunk:=chunk) (m1:=m) (b:=b) (ofs:=Ptrofs.unsigned i) (v:=v); auto.
+      eapply mmatch_logical; eauto.
+    + rewrite <- Mem.concrete_store with
+        (chunk:=chunk) (m1:=m) (b:=b) (ofs:=Ptrofs.unsigned i) (v:=v); auto.
+      eapply mmatch_logical_stack; eauto.
 Qed.
 
 Theorem loadbytes_sound:
@@ -4105,6 +4705,54 @@ Proof.
   eapply smatch_loadbytes; eauto. eapply mmatch_top; eauto with va.
 Qed.
 
+Theorem storebytes_zero_sound m am p q
+    (MM: mmatch m am):
+  <<STBMM: mmatch m (storebytes am p 0 q)>>.
+Proof.
+  unfold storebytes; constructor; simpl; intros.
+- destruct p; try by (eapply mmatch_stack; eauto).
+  + eapply ablock_storebytes_zero_sound. eapply mmatch_stack; eauto.
+  + eapply ablock_storebytes_anywhere_zero_sound; eauto. eapply mmatch_stack; eauto.
+  + eapply ablock_storebytes_anywhere_zero_sound; eauto. eapply mmatch_stack; eauto.
+- (* Globals *)
+  destruct p; try by (eapply mmatch_glob; eauto).
+  + rewrite PTree.gsspec in H0. destruct (peq id id0).
+    subst id0; inv H0.
+    (* assert (b' = b) by (eapply bc_glob; eauto). subst b'. *)
+    eapply ablock_storebytes_zero_sound; eauto.
+    destruct (am_glob am)!id as [ab0|] eqn:GL.
+    eapply mmatch_glob; eauto.
+    apply ablock_init_sound. eapply mmatch_nonstack; eauto; congruence.
+    eapply mmatch_glob; eauto.
+  + rewrite PTree.gsspec in H0. destruct (peq id id0).
+    subst id0; inv H0.
+    (* assert (b' = b) by (eapply bc_glob; eauto). subst b'. *)
+    eapply ablock_storebytes_anywhere_zero_sound; eauto.
+    destruct (am_glob am)!id as [ab0|] eqn:GL.
+    eapply mmatch_glob; eauto.
+    apply ablock_init_sound. eapply mmatch_nonstack; eauto; congruence.
+    eapply mmatch_glob; eauto.
+  + rewrite PTree.gempty in H0; congruence.
+  + rewrite PTree.gempty in H0; congruence.
+  + rewrite PTree.gempty in H0; congruence.
+
+- (* Nonstack *)
+  destruct p; try by (eapply mmatch_nonstack; eauto).
+  all : (eapply smatch_ge; eauto; try eapply mmatch_nonstack; eauto; eapply pge_lub_r).
+
+- (* Top *)
+  eapply smatch_ge; eauto. eapply mmatch_top; eauto. eapply pge_lub_r.
+
+- (* Below *)
+  eapply mmatch_below; eauto.
+
+- (* invalid logical *)
+  eapply mmatch_logical; eauto.
+
+- (* logical stack *)
+  eapply mmatch_logical_stack; eauto.
+Qed.
+
 Theorem storebytes_sound:
   forall m b ofs bytes m' am p sz q,
   Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m' ->
@@ -4170,6 +4818,14 @@ Proof.
 
 - (* Below *)
   erewrite Mem.nextblock_storebytes by eauto. eapply mmatch_below; eauto.
+
+- (* invalid logical *)
+  rewrite <- Mem.concrete_storebytes with (m1:=m) (b:=b) (ofs:=Ptrofs.unsigned ofs) (bytes:=bytes); auto. inversion MM.
+  apply mmatch_logical0. auto.
+
+- (* logical stack *)
+  rewrite <- Mem.concrete_storebytes with (m1:=m) (b:=b) (ofs:=Ptrofs.unsigned ofs) (bytes:=bytes); auto. inversion MM.
+  apply mmatch_logical_stack0; auto.
 Qed.
 
 Lemma mmatch_ext:
@@ -4177,9 +4833,11 @@ Lemma mmatch_ext:
   mmatch m am ->
   (forall b ofs n bytes, bc b <> BCinvalid -> n >= 0 -> Mem.loadbytes m' b ofs n = Some bytes -> Mem.loadbytes m b ofs n = Some bytes) ->
   Ple (Mem.nextblock m) (Mem.nextblock m') ->
+  (forall b, bc b = BCinvalid -> m'.(Mem.mem_concrete)!b = None) ->
+  (forall b, bc b = BCstack -> am.(am_concrete_stack) = false -> m'.(Mem.mem_concrete)!b = None) ->
   mmatch m' am.
 Proof.
-  intros. inv H. constructor; intros.
+  intros. inv H. constructor; intros; auto.
 - apply bmatch_ext with m; auto with va.
 - apply bmatch_ext with m; eauto with va.
 - apply smatch_ext with m; auto with va.
@@ -4196,18 +4854,10 @@ Proof.
   intros. apply mmatch_ext with m; auto.
   intros. eapply Mem.loadbytes_free_2; eauto.
   erewrite <- Mem.nextblock_free by eauto. extlia.
-Qed.
-
-Lemma mmatch_top':
-  forall m am, mmatch m am -> mmatch m mtop.
-Proof.
-  intros. constructor; simpl; intros.
-- apply ablock_init_sound. apply smatch_ge with (ab_summary (am_stack am)).
-  eapply mmatch_stack; eauto. constructor.
-- rewrite PTree.gempty in H1; discriminate.
-- eapply smatch_ge. eapply mmatch_nonstack; eauto. constructor.
-- eapply smatch_ge. eapply mmatch_top; eauto. constructor.
-- eapply mmatch_below; eauto.
+  intros. rewrite <- Mem.concrete_free with (m1:=m) (bf:=b) (lo:=lo) (hi:=hi); auto. inversion H0.
+  apply mmatch_logical0. auto.
+  rewrite <- Mem.concrete_free with (m1:=m) (bf:=b) (lo:=lo) (hi:=hi); auto.
+  inversion H0. intros. apply mmatch_logical_stack0; auto.
 Qed.
 
 (** Boolean equality *)
@@ -4216,25 +4866,31 @@ Definition mbeq (m1 m2: amem) : bool :=
   eq_aptr m1.(am_top) m2.(am_top)
   && eq_aptr m1.(am_nonstack) m2.(am_nonstack)
   && bbeq m1.(am_stack) m2.(am_stack)
-  && PTree.beq bbeq m1.(am_glob) m2.(am_glob).
+  && PTree.beq bbeq m1.(am_glob) m2.(am_glob)
+  && PTree.beq bbeq m1.(am_glob) m2.(am_glob)
+  && eqb m1.(am_concrete_stack) m2.(am_concrete_stack).
 
 Lemma mbeq_sound:
   forall m1 m2, mbeq m1 m2 = true -> forall m, mmatch m m1 <-> mmatch m m2.
 Proof.
-  unfold mbeq; intros. InvBooleans. rewrite PTree.beq_correct in H1.
+  unfold mbeq; intros. InvBooleans. rewrite PTree.beq_correct in H2.
   split; intros M; inv M; constructor; intros.
 - erewrite <- bbeq_sound; eauto.
-- specialize (H1 id). rewrite H4 in H1. destruct (am_glob m1)!id eqn:G; try contradiction.
+- specialize (H2 id). rewrite H6 in H2. destruct (am_glob m1)!id eqn:G; try contradiction.
   erewrite <- bbeq_sound; eauto.
 - rewrite <- H; eauto.
 - rewrite <- H0; eauto.
 - auto.
+- auto.
+- apply mmatch_logical_stack0. auto. rewrite eqb_true_iff in H1. rewrite H1. auto.
 - erewrite bbeq_sound; eauto.
-- specialize (H1 id). rewrite H4 in H1. destruct (am_glob m2)!id eqn:G; try contradiction.
+- specialize (H2 id). rewrite H6 in H2. destruct (am_glob m2)!id eqn:G; try contradiction.
   erewrite bbeq_sound; eauto.
 - rewrite H; eauto.
 - rewrite H0; eauto.
 - auto.
+- auto.
+- apply mmatch_logical_stack0. auto. rewrite eqb_true_iff in H1. rewrite <- H1. auto.
 Qed.
 
 (** Least upper bound *)
@@ -4249,7 +4905,8 @@ Definition mlub (m1 m2: amem) : amem :=
 {| am_stack := blub m1.(am_stack) m2.(am_stack);
    am_glob  := PTree.combine combine_ablock m1.(am_glob) m2.(am_glob);
    am_nonstack := plub m1.(am_nonstack) m2.(am_nonstack);
-   am_top := plub m1.(am_top) m2.(am_top) |}.
+   am_top := plub m1.(am_top) m2.(am_top);
+   am_concrete_stack := (m1.(am_concrete_stack)) || (m2.(am_concrete_stack)) |}.
 
 Lemma mmatch_lub_l:
   forall m x y, mmatch m x -> mmatch m (mlub x y).
@@ -4264,6 +4921,9 @@ Proof.
 - apply smatch_lub_l; auto.
 - apply smatch_lub_l; auto.
 - auto.
+- auto.
+- apply orb_false_elim in H0. destruct H0 as [HX HY].
+  apply mmatch_logical_stack0; auto.
 Qed.
 
 Lemma mmatch_lub_r:
@@ -4279,6 +4939,9 @@ Proof.
 - apply smatch_lub_r; auto.
 - apply smatch_lub_r; auto.
 - auto.
+- auto.
+- apply orb_false_elim in H0. destruct H0 as [HX HY].
+  apply mmatch_logical_stack0; auto.
 Qed.
 
 End MATCH.
@@ -4321,10 +4984,11 @@ Proof.
   {
     intros. inv H3; constructor; auto; inv H4; eapply PM; eauto.
   }
-  destruct B as [[B1 B2] B3]. split. split.
+  destruct B as [[B1 B2] [B3 B4]]. split; [|split]. split.
 - intros. apply VM; eauto.
 - intros. apply PM; eauto.
 - intros. apply VM; eauto.
+- intros. eapply B4; eauto.
 Qed.
 
 Definition bc_incr (bc1 bc2: block_classification) : Prop :=
@@ -4356,9 +5020,10 @@ Qed.
 
 Lemma bmatch_incr: forall m b ab, bmatch bc1 m b ab -> bmatch bc2 m b ab.
 Proof.
-  intros. destruct H as [B1 B2]. split.
+  intros. destruct H as [B1 [B2 B3]]. split; [|split].
   apply smatch_incr; auto.
   intros. apply vmatch_incr; eauto.
+  eauto.
 Qed.
 
 End MATCH_INCR.
@@ -4444,6 +5109,14 @@ Proof.
 - (* perm inv *)
   intros. exploit inj_of_bc_inv; eauto. intros (A & B & C); subst.
   rewrite Z.add_0_r in H2. auto.
+- (* src concrete *)
+  intros b1 b2 delta addr INJ CONCRETE.
+  unfold inj_of_bc in INJ.
+  destruct (bc b1); inversion INJ; subst; rewrite CONCRETE; rewrite Z.sub_0_r; auto.
+- (* src private *)
+  intros. inversion H. apply mmatch_logical0.
+  unfold inj_of_bc in NOINJECT.
+  destruct (bc b); inversion NOINJECT. reflexivity.  
 Qed.
 
 Lemma inj_of_bc_preserves_globals:
@@ -4486,6 +5159,11 @@ Proof.
   - apply SM; auto.
   - apply SM; auto.
   - red; intros. eapply Mem.valid_block_inject_1. eapply inj_of_bc_valid; eauto. eauto.
+  (* invalid logical *)
+  - inversion H.
+    apply mi_src_concrete_private.
+    unfold inj_of_bc. rewrite H0. auto.
+  - inversion H1.
 Qed.
 
 (** * Abstracting RTL register environments *)
diff --git a/cfrontend/Cexec.v b/cfrontend/Cexec.v
index d763c98c..8254056f 100644
--- a/cfrontend/Cexec.v
+++ b/cfrontend/Cexec.v
@@ -18,7 +18,7 @@ Require Import String Coqlib Decidableplus.
 Require Import Errors Maps Integers Floats.
 Require Import AST Values Memory Events Globalenvs Builtins Determinism.
 Require Import Ctypes Cop Csyntax Csem.
-Require Cstrategy.
+(* Require Cstrategy. *)
 
 Local Open Scope string_scope.
 Local Open Scope list_scope.
@@ -219,55 +219,55 @@ Definition do_volatile_store (w: world) (chunk: memory_chunk) (m: mem) (b: block
     do m' <- Mem.store chunk m b (Ptrofs.unsigned ofs) v;
     Some(w, E0, m').
 
-Lemma do_volatile_load_sound:
-  forall w chunk m b ofs w' t v,
-  do_volatile_load w chunk m b ofs = Some(w', t, v) ->
-  volatile_load ge chunk m b ofs t v /\ possible_trace w t w'.
-Proof.
-  intros until v. unfold do_volatile_load. mydestr.
-  destruct p as [ev w'']. mydestr.
-  split. constructor; auto. apply Genv.invert_find_symbol; auto.
-  apply val_of_eventval_sound; auto.
-  econstructor. constructor; eauto. constructor.
-  split. constructor; auto. constructor.
-Qed.
-
-Lemma do_volatile_load_complete:
-  forall w chunk m b ofs w' t v,
-  volatile_load ge chunk m b ofs t v -> possible_trace w t w' ->
-  do_volatile_load w chunk m b ofs = Some(w', t, v).
-Proof.
-  unfold do_volatile_load; intros. inv H; simpl in *.
-  rewrite H1. rewrite (Genv.find_invert_symbol _ _ H2). inv H0. inv H8. inv H6. rewrite H9.
-  rewrite (val_of_eventval_complete _ _ _ H3). auto.
-  rewrite H1. rewrite H2. inv H0. auto.
-Qed.
-
-Lemma do_volatile_store_sound:
-  forall w chunk m b ofs v w' t m',
-  do_volatile_store w chunk m b ofs v = Some(w', t, m') ->
-  volatile_store ge chunk m b ofs v t m' /\ possible_trace w t w'.
-Proof.
-  intros until m'. unfold do_volatile_store. mydestr.
-  split. constructor; auto. apply Genv.invert_find_symbol; auto.
-  apply eventval_of_val_sound; auto.
-  econstructor. constructor; eauto. constructor.
-  split. constructor; auto. constructor.
-Qed.
-
-Lemma do_volatile_store_complete:
-  forall w chunk m b ofs v w' t m',
-  volatile_store ge chunk m b ofs v t m' -> possible_trace w t w' ->
-  do_volatile_store w chunk m b ofs v = Some(w', t, m').
-Proof.
-  unfold do_volatile_store; intros. inv H; simpl in *.
-  rewrite H1. rewrite (Genv.find_invert_symbol _ _ H2).
-  rewrite (eventval_of_val_complete _ _ _ H3).
-  inv H0. inv H8. inv H6. rewrite H9. auto.
-  rewrite H1. rewrite H2. inv H0. auto.
-Qed.
-
-(** Accessing locations *)
+(* Lemma do_volatile_load_sound: *)
+(*   forall w chunk m b ofs w' t v, *)
+(*   do_volatile_load w chunk m b ofs = Some(w', t, v) -> *)
+(*   volatile_load ge chunk m b ofs t v /\ possible_trace w t w'. *)
+(* Proof. *)
+(*   (* intros until v. unfold do_volatile_load. mydestr. *) *)
+(*   (* destruct p as [ev w'']. mydestr. *) *)
+(*   (* split. constructor; auto. apply Genv.invert_find_symbol; auto. *) *)
+(*   (* apply val_of_eventval_sound; auto. *) *)
+(*   (* econstructor. constructor; eauto. constructor. *) *)
+(*   (* split. constructor; auto. constructor. *) *)
+(* Qed. *)
+
+(* Lemma do_volatile_load_complete: *)
+(*   forall w chunk m b ofs w' t v, *)
+(*   volatile_load ge chunk m b ofs t v -> possible_trace w t w' -> *)
+(*   do_volatile_load w chunk m b ofs = Some(w', t, v). *)
+(* Proof. *)
+(*   unfold do_volatile_load; intros. inv H; simpl in *. *)
+(*   rewrite H1. rewrite (Genv.find_invert_symbol _ _ H2). inv H0. inv H8. inv H6. rewrite H9. *)
+(*   rewrite (val_of_eventval_complete _ _ _ H3). auto. *)
+(*   rewrite H1. rewrite H2. inv H0. auto. *)
+(* Qed. *)
+
+(* Lemma do_volatile_store_sound: *)
+(*   forall w chunk m b ofs v w' t m', *)
+(*   do_volatile_store w chunk m b ofs v = Some(w', t, m') -> *)
+(*   volatile_store ge chunk m b ofs v t m' /\ possible_trace w t w'. *)
+(* Proof. *)
+(*   (* intros until m'. unfold do_volatile_store. mydestr. *) *)
+(*   (* split. constructor; auto. apply Genv.invert_find_symbol; auto. *) *)
+(*   (* apply eventval_of_val_sound; auto. *) *)
+(*   (* econstructor. constructor; eauto. constructor. *) *)
+(*   (* split. constructor; auto. constructor. *) *)
+(* Qed. *)
+
+(* Lemma do_volatile_store_complete: *)
+(*   forall w chunk m b ofs v w' t m', *)
+(*   volatile_store ge chunk m b ofs v t m' -> possible_trace w t w' -> *)
+(*   do_volatile_store w chunk m b ofs v = Some(w', t, m'). *)
+(* Proof. *)
+(*   unfold do_volatile_store; intros. inv H; simpl in *. *)
+(*   rewrite H1. rewrite (Genv.find_invert_symbol _ _ H2). *)
+(*   rewrite (eventval_of_val_complete _ _ _ H3). *)
+(*   inv H0. inv H8. inv H6. rewrite H9. auto. *)
+(*   rewrite H1. rewrite H2. inv H0. auto. *)
+(* Qed. *)
+
+(* (** Accessing locations *) *)
 
 Definition do_deref_loc (w: world) (ty: type) (m: mem) (b: block) (ofs: ptrofs) : option (world * trace * val) :=
   match access_mode ty with
@@ -330,58 +330,58 @@ Definition do_assign_loc (w: world) (ty: type) (m: mem) (b: block) (ofs: ptrofs)
   | _ => None
   end.
 
-Lemma do_deref_loc_sound:
-  forall w ty m b ofs w' t v,
-  do_deref_loc w ty m b ofs = Some(w', t, v) ->
-  deref_loc ge ty m b ofs t v /\ possible_trace w t w'.
-Proof.
-  unfold do_deref_loc; intros until v.
-  destruct (access_mode ty) eqn:?; mydestr.
-  intros. exploit do_volatile_load_sound; eauto. intuition. eapply deref_loc_volatile; eauto.
-  split. eapply deref_loc_value; eauto. constructor.
-  split. eapply deref_loc_reference; eauto. constructor.
-  split. eapply deref_loc_copy; eauto. constructor.
-Qed.
-
-Lemma do_deref_loc_complete:
-  forall w ty m b ofs w' t v,
-  deref_loc ge ty m b ofs t v -> possible_trace w t w' ->
-  do_deref_loc w ty m b ofs = Some(w', t, v).
-Proof.
-  unfold do_deref_loc; intros. inv H.
-  inv H0. rewrite H1; rewrite H2; rewrite H3; auto.
-  rewrite H1; rewrite H2. apply do_volatile_load_complete; auto.
-  inv H0. rewrite H1. auto.
-  inv H0. rewrite H1. auto.
-Qed.
-
-Lemma do_assign_loc_sound:
-  forall w ty m b ofs v w' t m',
-  do_assign_loc w ty m b ofs v = Some(w', t, m') ->
-  assign_loc ge ty m b ofs v t m' /\ possible_trace w t w'.
-Proof.
-  unfold do_assign_loc; intros until m'.
-  destruct (access_mode ty) eqn:?; mydestr.
-  intros. exploit do_volatile_store_sound; eauto. intuition. eapply assign_loc_volatile; eauto.
-  split. eapply assign_loc_value; eauto. constructor.
-  destruct v; mydestr. destruct a as [P [Q R]].
-  split. eapply assign_loc_copy; eauto. constructor.
-Qed.
-
-Lemma do_assign_loc_complete:
-  forall w ty m b ofs v w' t m',
-  assign_loc ge ty m b ofs v t m' -> possible_trace w t w' ->
-  do_assign_loc w ty m b ofs v = Some(w', t, m').
-Proof.
-  unfold do_assign_loc; intros. inv H.
-  inv H0. rewrite H1; rewrite H2; rewrite H3; auto.
-  rewrite H1; rewrite H2. apply do_volatile_store_complete; auto.
-  rewrite H1. destruct (check_assign_copy ty b ofs b' ofs').
-  inv H0. rewrite H5; rewrite H6; auto.
-  elim n. red; tauto.
-Qed.
-
-(** External calls *)
+(* Lemma do_deref_loc_sound: *)
+(*   forall w ty m b ofs w' t v, *)
+(*   do_deref_loc w ty m b ofs = Some(w', t, v) -> *)
+(*   deref_loc ge ty m b ofs t v /\ possible_trace w t w'. *)
+(* Proof. *)
+(*   unfold do_deref_loc; intros until v. *)
+(*   destruct (access_mode ty) eqn:?; mydestr. *)
+(*   intros. exploit do_volatile_load_sound; eauto. intuition. eapply deref_loc_volatile; eauto. *)
+(*   split. eapply deref_loc_value; eauto. constructor. *)
+(*   split. eapply deref_loc_reference; eauto. constructor. *)
+(*   split. eapply deref_loc_copy; eauto. constructor. *)
+(* Qed. *)
+
+(* Lemma do_deref_loc_complete: *)
+(*   forall w ty m b ofs w' t v, *)
+(*   deref_loc ge ty m b ofs t v -> possible_trace w t w' -> *)
+(*   do_deref_loc w ty m b ofs = Some(w', t, v). *)
+(* Proof. *)
+(*   unfold do_deref_loc; intros. inv H. *)
+(*   inv H0. rewrite H1; rewrite H2; rewrite H3; auto. *)
+(*   rewrite H1; rewrite H2. apply do_volatile_load_complete; auto. *)
+(*   inv H0. rewrite H1. auto. *)
+(*   inv H0. rewrite H1. auto. *)
+(* Qed. *)
+
+(* Lemma do_assign_loc_sound: *)
+(*   forall w ty m b ofs v w' t m', *)
+(*   do_assign_loc w ty m b ofs v = Some(w', t, m') -> *)
+(*   assign_loc ge ty m b ofs v t m' /\ possible_trace w t w'. *)
+(* Proof. *)
+(*   unfold do_assign_loc; intros until m'. *)
+(*   destruct (access_mode ty) eqn:?; mydestr. *)
+(*   intros. exploit do_volatile_store_sound; eauto. intuition. eapply assign_loc_volatile; eauto. *)
+(*   split. eapply assign_loc_value; eauto. constructor. *)
+(*   destruct v; mydestr. destruct a as [P [Q R]]. *)
+(*   split. eapply assign_loc_copy; eauto. constructor. *)
+(* Qed. *)
+
+(* Lemma do_assign_loc_complete: *)
+(*   forall w ty m b ofs v w' t m', *)
+(*   assign_loc ge ty m b ofs v t m' -> possible_trace w t w' -> *)
+(*   do_assign_loc w ty m b ofs v = Some(w', t, m'). *)
+(* Proof. *)
+(*   unfold do_assign_loc; intros. inv H. *)
+(*   inv H0. rewrite H1; rewrite H2; rewrite H3; auto. *)
+(*   rewrite H1; rewrite H2. apply do_volatile_store_complete; auto. *)
+(*   rewrite H1. destruct (check_assign_copy ty b ofs b' ofs'). *)
+(*   inv H0. rewrite H5; rewrite H6; auto. *)
+(*   elim n. red; tauto. *)
+(* Qed. *)
+
+(* (** External calls *) *)
 
 Variable do_external_function:
   string -> signature -> Senv.t -> world -> list val -> mem -> option (world * trace * val * mem).
@@ -531,128 +531,129 @@ Definition do_external (ef: external_function):
   | EF_annot_val kind text targ => do_ef_annot_val text targ
   | EF_inline_asm text sg clob => do_inline_assembly text sg ge
   | EF_debug kind text targs => do_ef_debug kind text targs
+  | _ => do_ef_free
   end.
 
-Lemma do_ef_external_sound:
-  forall ef w vargs m w' t vres m',
-  do_external ef w vargs m = Some(w', t, vres, m') ->
-  external_call ef ge vargs m t vres m' /\ possible_trace w t w'.
-Proof with try congruence.
-  intros until m'.
-  assert (SIZE: forall v sz, do_alloc_size v = Some sz -> v = Vptrofs sz).
-  { intros until sz; unfold Vptrofs; destruct v; simpl; destruct Archi.ptr64 eqn:SF; 
-    intros EQ; inv EQ; f_equal; symmetry; eauto with ptrofs. }
-  assert (BF_EX: forall name sg,
-    do_builtin_or_external name sg w vargs m = Some (w', t, vres, m') ->
-    builtin_or_external_sem name sg ge vargs m t vres m' /\ possible_trace w t w').
-  { unfold do_builtin_or_external, builtin_or_external_sem; intros. 
-    destruct (lookup_builtin_function name sg ) as [bf|].
-  - destruct (builtin_function_sem bf vargs) as [vres1|] eqn:BF; inv H.
-    split. constructor; auto. constructor.
-  - eapply do_external_function_sound; eauto.
-  }
-  destruct ef; simpl.
-- (* EF_external *)
-  eapply do_external_function_sound; eauto.
-- (* EF_builtin *)
-  eapply BF_EX; eauto.
-- (* EF_runtime *)
-  eapply BF_EX; eauto.
-- (* EF_vload *)
-  unfold do_ef_volatile_load. destruct vargs... destruct v... destruct vargs...
-  mydestr. destruct p as [[w'' t''] v]; mydestr.
-  exploit do_volatile_load_sound; eauto. intuition. econstructor; eauto.
-- (* EF_vstore *)
-  unfold do_ef_volatile_store. destruct vargs... destruct v... destruct vargs... destruct vargs...
-  mydestr. destruct p as [[w'' t''] m'']. mydestr.
-  exploit do_volatile_store_sound; eauto. intuition. econstructor; eauto.
-- (* EF_malloc *)
-  unfold do_ef_malloc. destruct vargs... destruct vargs... mydestr.
-  destruct (Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned i)) as [m1 b] eqn:?. mydestr.
-  split. apply SIZE in Heqo. subst v. econstructor; eauto. constructor.
-- (* EF_free *)
-  unfold do_ef_free. destruct vargs... destruct v... 
-+ destruct vargs... mydestr; InvBooleans; subst i.
-  replace (Vint Int.zero) with Vnullptr. split; constructor.
-  apply negb_true_iff in H0. unfold Vnullptr; rewrite H0; auto.
-+ destruct vargs... mydestr; InvBooleans; subst i.
-  replace (Vlong Int64.zero) with Vnullptr. split; constructor.
-  unfold Vnullptr; rewrite H0; auto.
-+ destruct vargs... mydestr.
-  split. apply SIZE in Heqo0. econstructor; eauto. congruence. lia.
-  constructor.
-- (* EF_memcpy *)
-  unfold do_ef_memcpy. destruct vargs... destruct v... destruct vargs...
-  destruct v... destruct vargs... mydestr. 
-  apply Decidable_sound in Heqb1. red in Heqb1.
-  split. econstructor; eauto; tauto. constructor.
-- (* EF_annot *)
-  unfold do_ef_annot. mydestr.
-  split. constructor. apply list_eventval_of_val_sound; auto.
-  econstructor. constructor; eauto. constructor.
-- (* EF_annot_val *)
-  unfold do_ef_annot_val. destruct vargs... destruct vargs... mydestr.
-  split. constructor. apply eventval_of_val_sound; auto.
-  econstructor. constructor; eauto. constructor.
-- (* EF_inline_asm *)
-  eapply do_inline_assembly_sound; eauto.
-- (* EF_debug *)
-  unfold do_ef_debug. mydestr. split; constructor.
-Qed.
-
-Lemma do_ef_external_complete:
-  forall ef w vargs m w' t vres m',
-  external_call ef ge vargs m t vres m' -> possible_trace w t w' ->
-  do_external ef w vargs m = Some(w', t, vres, m').
-Proof.
-  intros.
-  assert (SIZE: forall n, do_alloc_size (Vptrofs n) = Some n).
-  { unfold Vptrofs, do_alloc_size; intros; destruct Archi.ptr64 eqn:SF. 
-    rewrite Ptrofs.of_int64_to_int64; auto.
-    rewrite Ptrofs.of_int_to_int; auto. }
-  assert (BF_EX: forall name sg,
-    builtin_or_external_sem name sg ge vargs m t vres m' ->
-    do_builtin_or_external name sg w vargs m = Some (w', t, vres, m')).
-  { unfold do_builtin_or_external, builtin_or_external_sem; intros.
-    destruct (lookup_builtin_function name sg) as [bf|].
-  - inv H1. inv H0. rewrite H2. auto.
-  - eapply do_external_function_complete; eauto.
-  }
-  destruct ef; simpl in *.
-- (* EF_external *)
-  eapply do_external_function_complete; eauto.
-- (* EF_builtin *)
-  eapply BF_EX; eauto.
-- (* EF_runtime *)
-  eapply BF_EX; eauto.
-- (* EF_vload *)
-  inv H; unfold do_ef_volatile_load.
-  exploit do_volatile_load_complete; eauto. intros EQ; rewrite EQ; auto.
-- (* EF_vstore *)
-  inv H; unfold do_ef_volatile_store.
-  exploit do_volatile_store_complete; eauto. intros EQ; rewrite EQ; auto.
-- (* EF_malloc *)
-  inv H; unfold do_ef_malloc.
-  inv H0. erewrite SIZE by eauto. rewrite H1, H2. auto.
-- (* EF_free *)
-  inv H; unfold do_ef_free.
-+ inv H0. rewrite H1. erewrite SIZE by eauto. rewrite zlt_true. rewrite H3. auto. lia.
-+ inv H0. unfold Vnullptr; destruct Archi.ptr64; auto.
-- (* EF_memcpy *)
-  inv H; unfold do_ef_memcpy.
-  inv H0. rewrite Decidable_complete. rewrite H7; rewrite H8; auto.
-  red. tauto.
-- (* EF_annot *)
-  inv H; unfold do_ef_annot. inv H0. inv H6. inv H4.
-  rewrite (list_eventval_of_val_complete _ _ _ H1). auto.
-- (* EF_annot_val *)
-  inv H; unfold do_ef_annot_val. inv H0. inv H6. inv H4.
-  rewrite (eventval_of_val_complete _ _ _ H1). auto.
-- (* EF_inline_asm *)
-  eapply do_inline_assembly_complete; eauto.
-- (* EF_debug *)
-  inv H. inv H0. reflexivity.
-Qed.
+(* Lemma do_ef_external_sound: *)
+(*   forall ef w vargs m w' t vres m', *)
+(*   do_external ef w vargs m = Some(w', t, vres, m') -> *)
+(*   external_call ef ge vargs m t vres m' /\ possible_trace w t w'. *)
+(* Proof with try congruence. *)
+(* (*   intros until m'. *) *)
+(* (*   assert (SIZE: forall v sz, do_alloc_size v = Some sz -> v = Vptrofs sz). *) *)
+(* (*   { intros until sz; unfold Vptrofs; destruct v; simpl; destruct Archi.ptr64 eqn:SF;  *) *)
+(* (*     intros EQ; inv EQ; f_equal; symmetry; eauto with ptrofs. } *) *)
+(* (*   assert (BF_EX: forall name sg, *) *)
+(* (*     do_builtin_or_external name sg w vargs m = Some (w', t, vres, m') -> *) *)
+(* (*     builtin_or_external_sem name sg ge vargs m t vres m' /\ possible_trace w t w'). *) *)
+(* (*   { unfold do_builtin_or_external, builtin_or_external_sem; intros.  *) *)
+(* (*     destruct (lookup_builtin_function name sg ) as [bf|]. *) *)
+(* (*   - destruct (builtin_function_sem bf vargs) as [vres1|] eqn:BF; inv H. *) *)
+(* (*     split. constructor; auto. constructor. *) *)
+(* (*   - eapply do_external_function_sound; eauto. *) *)
+(* (*   } *) *)
+(* (*   destruct ef; simpl. *) *)
+(* (* - (* EF_external *) *) *)
+(* (*   eapply do_external_function_sound; eauto. *) *)
+(* (* - (* EF_builtin *) *) *)
+(* (*   eapply BF_EX; eauto. *) *)
+(* (* - (* EF_runtime *) *) *)
+(* (*   eapply BF_EX; eauto. *) *)
+(* (* - (* EF_vload *) *) *)
+(* (*   unfold do_ef_volatile_load. destruct vargs... destruct v... destruct vargs... *) *)
+(* (*   mydestr. destruct p as [[w'' t''] v]; mydestr. *) *)
+(* (*   exploit do_volatile_load_sound; eauto. intuition. econstructor; eauto. *) *)
+(* (* - (* EF_vstore *) *) *)
+(* (*   unfold do_ef_volatile_store. destruct vargs... destruct v... destruct vargs... destruct vargs... *) *)
+(* (*   mydestr. destruct p as [[w'' t''] m'']. mydestr. *) *)
+(* (*   exploit do_volatile_store_sound; eauto. intuition. econstructor; eauto. *) *)
+(* (* - (* EF_malloc *) *) *)
+(* (*   unfold do_ef_malloc. destruct vargs... destruct vargs... mydestr. *) *)
+(* (*   destruct (Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned i)) as [m1 b] eqn:?. mydestr. *) *)
+(* (*   split. apply SIZE in Heqo. subst v. econstructor; eauto. constructor. *) *)
+(* (* - (* EF_free *) *) *)
+(* (*   unfold do_ef_free. destruct vargs... destruct v...  *) *)
+(* (* + destruct vargs... mydestr; InvBooleans; subst i. *) *)
+(* (*   replace (Vint Int.zero) with Vnullptr. split; constructor. *) *)
+(* (*   apply negb_true_iff in H0. unfold Vnullptr; rewrite H0; auto. *) *)
+(* (* + destruct vargs... mydestr; InvBooleans; subst i. *) *)
+(* (*   replace (Vlong Int64.zero) with Vnullptr. split; constructor. *) *)
+(* (*   unfold Vnullptr; rewrite H0; auto. *) *)
+(* (* + destruct vargs... mydestr. *) *)
+(* (*   split. apply SIZE in Heqo0. econstructor; eauto. congruence. lia. *) *)
+(* (*   constructor. *) *)
+(* (* - (* EF_memcpy *) *) *)
+(* (*   unfold do_ef_memcpy. destruct vargs... destruct v... destruct vargs... *) *)
+(* (*   destruct v... destruct vargs... mydestr.  *) *)
+(* (*   apply Decidable_sound in Heqb1. red in Heqb1. *) *)
+(* (*   split. econstructor; eauto; tauto. constructor. *) *)
+(* (* - (* EF_annot *) *) *)
+(* (*   unfold do_ef_annot. mydestr. *) *)
+(* (*   split. constructor. apply list_eventval_of_val_sound; auto. *) *)
+(* (*   econstructor. constructor; eauto. constructor. *) *)
+(* (* - (* EF_annot_val *) *) *)
+(* (*   unfold do_ef_annot_val. destruct vargs... destruct vargs... mydestr. *) *)
+(* (*   split. constructor. apply eventval_of_val_sound; auto. *) *)
+(* (*   econstructor. constructor; eauto. constructor. *) *)
+(* (* - (* EF_inline_asm *) *) *)
+(* (*   eapply do_inline_assembly_sound; eauto. *) *)
+(* (* - (* EF_debug *) *) *)
+(*   (*   unfold do_ef_debug. mydestr. split; constructor. *) *)
+(* Qed. *)
+
+(* Lemma do_ef_external_complete: *)
+(*   forall ef w vargs m w' t vres m', *)
+(*   external_call ef ge vargs m t vres m' -> possible_trace w t w' -> *)
+(*   do_external ef w vargs m = Some(w', t, vres, m'). *)
+(* Proof. *)
+(* (*   intros. *) *)
+(* (*   assert (SIZE: forall n, do_alloc_size (Vptrofs n) = Some n). *) *)
+(* (*   { unfold Vptrofs, do_alloc_size; intros; destruct Archi.ptr64 eqn:SF.  *) *)
+(* (*     rewrite Ptrofs.of_int64_to_int64; auto. *) *)
+(* (*     rewrite Ptrofs.of_int_to_int; auto. } *) *)
+(* (*   assert (BF_EX: forall name sg, *) *)
+(* (*     builtin_or_external_sem name sg ge vargs m t vres m' -> *) *)
+(* (*     do_builtin_or_external name sg w vargs m = Some (w', t, vres, m')). *) *)
+(* (*   { unfold do_builtin_or_external, builtin_or_external_sem; intros. *) *)
+(* (*     destruct (lookup_builtin_function name sg) as [bf|]. *) *)
+(* (*   - inv H1. inv H0. rewrite H2. auto. *) *)
+(* (*   - eapply do_external_function_complete; eauto. *) *)
+(* (*   } *) *)
+(* (*   destruct ef; simpl in *. *) *)
+(* (* - (* EF_external *) *) *)
+(* (*   eapply do_external_function_complete; eauto. *) *)
+(* (* - (* EF_builtin *) *) *)
+(* (*   eapply BF_EX; eauto. *) *)
+(* (* - (* EF_runtime *) *) *)
+(* (*   eapply BF_EX; eauto. *) *)
+(* (* - (* EF_vload *) *) *)
+(* (*   inv H; unfold do_ef_volatile_load. *) *)
+(* (*   exploit do_volatile_load_complete; eauto. intros EQ; rewrite EQ; auto. *) *)
+(* (* - (* EF_vstore *) *) *)
+(* (*   inv H; unfold do_ef_volatile_store. *) *)
+(* (*   exploit do_volatile_store_complete; eauto. intros EQ; rewrite EQ; auto. *) *)
+(* (* - (* EF_malloc *) *) *)
+(* (*   inv H; unfold do_ef_malloc. *) *)
+(* (*   inv H0. erewrite SIZE by eauto. rewrite H1, H2. auto. *) *)
+(* (* - (* EF_free *) *) *)
+(* (*   inv H; unfold do_ef_free. *) *)
+(* (* + inv H0. rewrite H1. erewrite SIZE by eauto. rewrite zlt_true. rewrite H3. auto. lia. *) *)
+(* (* + inv H0. unfold Vnullptr; destruct Archi.ptr64; auto. *) *)
+(* (* - (* EF_memcpy *) *) *)
+(* (*   inv H; unfold do_ef_memcpy. *) *)
+(* (*   inv H0. rewrite Decidable_complete. rewrite H7; rewrite H8; auto. *) *)
+(* (*   red. tauto. *) *)
+(* (* - (* EF_annot *) *) *)
+(* (*   inv H; unfold do_ef_annot. inv H0. inv H6. inv H4. *) *)
+(* (*   rewrite (list_eventval_of_val_complete _ _ _ H1). auto. *) *)
+(* (* - (* EF_annot_val *) *) *)
+(* (*   inv H; unfold do_ef_annot_val. inv H0. inv H6. inv H4. *) *)
+(* (*   rewrite (eventval_of_val_complete _ _ _ H1). auto. *) *)
+(* (* - (* EF_inline_asm *) *) *)
+(* (*   eapply do_inline_assembly_complete; eauto. *) *)
+(* (* - (* EF_debug *) *) *)
+(*   (*   inv H. inv H0. reflexivity. *) *)
+(* Qed. *)
 
 (** * Reduction of expressions *)
 
@@ -1196,666 +1197,662 @@ Proof.
   exists ((v, ty) :: vtl); simpl. rewrite A; rewrite B; rewrite H. auto.
 Qed.
 
-Lemma topred_ok:
-  forall k a m rd,
-  reduction_ok k a m rd ->
-  reducts_ok k a m (topred rd).
-Proof.
-  intros. unfold topred; split; simpl; intros.
-  destruct H0; try contradiction. inv H0. exists a; exists k; auto.
-  congruence.
-Qed.
-
-Lemma stuck_ok:
-  forall k a m,
-  ~imm_safe_t k a m ->
-  reducts_ok k a m stuck.
-Proof.
-  intros. unfold stuck; split; simpl; intros.
-  destruct H0; try contradiction. inv H0. exists a; exists k; intuition. red. destruct k; auto.
-  congruence.
-Qed.
-
-Lemma wrong_kind_ok:
-  forall k a m,
-  k <> Cstrategy.expr_kind a ->
-  reducts_ok k a m stuck.
-Proof.
-  intros. apply stuck_ok. red; intros. exploit Cstrategy.imm_safe_kind; eauto.
-  eapply imm_safe_t_imm_safe; eauto.
-Qed.
-
-Lemma not_invert_ok:
-  forall k a m,
-  match a with
-  | Eloc _ _ _ => False
-  | Eval _ _ => False
-  | _ => invert_expr_prop a m -> False
-  end ->
-  reducts_ok k a m stuck.
-Proof.
-  intros. apply stuck_ok. red; intros.
-  exploit imm_safe_t_inv; eauto. destruct a; auto.
-Qed.
-
-Lemma incontext_ok:
-  forall k a m C res k' a',
-  reducts_ok k' a' m res ->
-  a = C a' ->
-  context k' k C ->
-  match k' with LV => is_loc a' = None | RV => is_val a' = None end ->
-  reducts_ok k a m (incontext C res).
-Proof.
-  unfold reducts_ok, incontext; intros. destruct H. split; intros.
-  exploit list_in_map_inv; eauto. intros [[C1 rd1] [P Q]]. inv P.
-  exploit H; eauto. intros [a'' [k'' [U [V W]]]].
-  exists a''; exists k''. split. eapply context_compose; eauto. rewrite V; auto.
-  destruct res; simpl in H4; try congruence. destruct k'; intuition congruence.
-Qed.
-
-Lemma incontext2_ok:
-  forall k a m k1 a1 res1 k2 a2 res2 C1 C2,
-  reducts_ok k1 a1 m res1 ->
-  reducts_ok k2 a2 m res2 ->
-  a = C1 a1 -> a = C2 a2 ->
-  context k1 k C1 -> context k2 k C2 ->
-  match k1 with LV => is_loc a1 = None | RV => is_val a1 = None end
-  \/ match k2 with LV => is_loc a2 = None | RV => is_val a2 = None end ->
-  reducts_ok k a m (incontext2 C1 res1 C2 res2).
-Proof.
-  unfold reducts_ok, incontext2, incontext; intros. destruct H; destruct H0; split; intros.
-  destruct (in_app_or _ _ _ H8).
-  exploit list_in_map_inv; eauto. intros [[C' rd'] [P Q]]. inv P.
-  exploit H; eauto. intros [a'' [k'' [U [V W]]]].
-  exists a''; exists k''. split. eapply context_compose; eauto. rewrite V; auto.
-  exploit list_in_map_inv; eauto. intros [[C' rd'] [P Q]]. inv P.
-  exploit H0; eauto. intros [a'' [k'' [U [V W]]]].
-  exists a''; exists k''. split. eapply context_compose; eauto. rewrite H2; rewrite V; auto.
-  destruct res1; simpl in H8; try congruence. destruct res2; simpl in H8; try congruence.
-  destruct H5. destruct k1; intuition congruence. destruct k2; intuition congruence.
-Qed.
-
-Lemma incontext_list_ok:
-  forall ef tyargs al ty m res,
-  list_reducts_ok al m res ->
-  is_val_list al = None ->
-  reducts_ok RV (Ebuiltin ef tyargs al ty) m
-                (incontext (fun x => Ebuiltin ef tyargs x ty) res).
-Proof.
-  unfold reducts_ok, incontext; intros. destruct H. split; intros.
-  exploit list_in_map_inv; eauto. intros [[C1 rd1] [P Q]]. inv P.
-  exploit H; eauto. intros [a'' [k'' [U [V W]]]].
-  exists a''; exists k''. split. eauto. rewrite V; auto.
-  destruct res; simpl in H2. elim H1; auto. congruence.
-Qed.
-
-Lemma incontext2_list_ok:
-  forall a1 a2 ty m res1 res2,
-  reducts_ok RV a1 m res1 ->
-  list_reducts_ok a2 m res2 ->
-  is_val a1 = None \/ is_val_list a2 = None ->
-  reducts_ok RV (Ecall a1 a2 ty) m
-               (incontext2 (fun x => Ecall x a2 ty) res1
-                           (fun x => Ecall a1 x ty) res2).
-Proof.
-  unfold reducts_ok, incontext2, incontext; intros. destruct H; destruct H0; split; intros.
-  destruct (in_app_or _ _ _ H4).
-  exploit list_in_map_inv; eauto. intros [[C' rd'] [P Q]]. inv P.
-  exploit H; eauto. intros [a'' [k'' [U [V W]]]].
-  exists a''; exists k''. split. eauto. rewrite V; auto.
-  exploit list_in_map_inv; eauto. intros [[C' rd'] [P Q]]. inv P.
-  exploit H0; eauto. intros [a'' [k'' [U [V W]]]].
-  exists a''; exists k''. split. eauto. rewrite V; auto.
-  destruct res1; simpl in H4; try congruence. destruct res2; simpl in H4; try congruence.
-  tauto.
-Qed.
-
-Lemma incontext2_list_ok':
-  forall a1 a2 m res1 res2,
-  reducts_ok RV a1 m res1 ->
-  list_reducts_ok a2 m res2 ->
-  list_reducts_ok (Econs a1 a2) m
-               (incontext2 (fun x => Econs x a2) res1
-                           (fun x => Econs a1 x) res2).
-Proof.
-  unfold reducts_ok, list_reducts_ok, incontext2, incontext; intros.
-  destruct H; destruct H0. split; intros.
-  destruct (in_app_or _ _ _ H3).
-  exploit list_in_map_inv; eauto. intros [[C' rd'] [P Q]]. inv P.
-  exploit H; eauto. intros [a'' [k'' [U [V W]]]].
-  exists a''; exists k''. split. eauto. rewrite V; auto.
-  exploit list_in_map_inv; eauto. intros [[C' rd'] [P Q]]. inv P.
-  exploit H0; eauto. intros [a'' [k'' [U [V W]]]].
-  exists a''; exists k''. split. eauto. rewrite V; auto.
-  destruct res1; simpl in H3; try congruence. destruct res2; simpl in H3; try congruence.
-  simpl. destruct (is_val a1). destruct (is_val_list a2). congruence. intuition congruence. intuition congruence.
-Qed.
-
-Lemma is_val_list_all_values:
-  forall al vtl, is_val_list al = Some vtl -> exprlist_all_values al.
-Proof.
-  induction al; simpl; intros. auto.
-  destruct (is_val r1) as [[v ty]|] eqn:?; try discriminate.
-  destruct (is_val_list al) as [vtl'|] eqn:?; try discriminate.
-  rewrite (is_val_inv _ _ _ Heqo). eauto.
-Qed.
-
-Ltac myinv :=
-  match goal with
-  | [ H: False |- _ ] => destruct H
-  | [ H: _ /\ _ |- _ ] => destruct H; myinv
-  | [ H: exists _, _ |- _ ] => destruct H; myinv
-  | _ => idtac
-  end.
-
-Theorem step_expr_sound:
-  forall a k m, reducts_ok k a m (step_expr k a m)
-with step_exprlist_sound:
-  forall al m, list_reducts_ok al m (step_exprlist al m).
-Proof with (try (apply not_invert_ok; simpl; intro; myinv; intuition congruence; fail)).
-  induction a; intros; simpl; destruct k; try (apply wrong_kind_ok; simpl; congruence).
-(* Eval *)
-  split; intros. tauto. simpl; congruence.
-(* Evar *)
-  destruct (e!x) as [[b ty']|] eqn:?.
-  destruct (type_eq ty ty')...
-  subst. apply topred_ok; auto. apply red_var_local; auto.
-  destruct (Genv.find_symbol ge x) as [b|] eqn:?...
-  apply topred_ok; auto. apply red_var_global; auto.
-(* Efield *)
-  destruct (is_val a) as [[v ty'] | ] eqn:?.
-  rewrite (is_val_inv _ _ _ Heqo).
-  destruct v...
-  destruct ty'...
-  (* top struct *)
-  destruct (ge.(genv_cenv)!i0) as [co|] eqn:?...
-  destruct (field_offset ge f (co_members co)) as [delta|] eqn:?...
-  apply topred_ok; auto. eapply red_field_struct; eauto.
-  (* top union *)
-  destruct (ge.(genv_cenv)!i0) as [co|] eqn:?...
-  apply topred_ok; auto. eapply red_field_union; eauto.
-  (* in depth *)
-  eapply incontext_ok; eauto.
-(* Evalof *)
-  destruct (is_loc a) as [[[b ofs] ty'] | ] eqn:?. rewrite (is_loc_inv _ _ _ _ Heqo).
-  (* top *)
-  destruct (type_eq ty ty')... subst ty'.
-  destruct (do_deref_loc w ty m b ofs) as [[[w' t] v] | ] eqn:?.
-  exploit do_deref_loc_sound; eauto. intros [A B].
-  apply topred_ok; auto. red. split. apply red_rvalof; auto. exists w'; auto.
-  apply not_invert_ok; simpl; intros; myinv. exploit do_deref_loc_complete; eauto. congruence.
-  (* depth *)
-  eapply incontext_ok; eauto.
-(* Ederef *)
-  destruct (is_val a) as [[v ty'] | ] eqn:?. rewrite (is_val_inv _ _ _ Heqo).
-  (* top *)
-  destruct v... apply topred_ok; auto. apply red_deref; auto.
-  (* depth *)
-  eapply incontext_ok; eauto.
-(* Eaddrof *)
-  destruct (is_loc a) as [[[b ofs] ty'] | ] eqn:?. rewrite (is_loc_inv _ _ _ _ Heqo).
-  (* top *)
-  apply topred_ok; auto. split. apply red_addrof; auto. exists w; constructor.
-  (* depth *)
-  eapply incontext_ok; eauto.
-(* unop *)
-  destruct (is_val a) as [[v ty'] | ] eqn:?. rewrite (is_val_inv _ _ _ Heqo).
-  (* top *)
-  destruct (sem_unary_operation op v ty' m) as [v'|] eqn:?...
-  apply topred_ok; auto. split. apply red_unop; auto. exists w; constructor.
-  (* depth *)
-  eapply incontext_ok; eauto.
-(* binop *)
-  destruct (is_val a1) as [[v1 ty1] | ] eqn:?.
-  destruct (is_val a2) as [[v2 ty2] | ] eqn:?.
-  rewrite (is_val_inv _ _ _ Heqo). rewrite (is_val_inv _ _ _ Heqo0).
-  (* top *)
-  destruct (sem_binary_operation ge op v1 ty1 v2 ty2 m) as [v|] eqn:?...
-  apply topred_ok; auto. split. apply red_binop; auto. exists w; constructor.
-  (* depth *)
-  eapply incontext2_ok; eauto.
-  eapply incontext2_ok; eauto.
-(* cast *)
-  destruct (is_val a) as [[v ty'] | ] eqn:?. rewrite (is_val_inv _ _ _ Heqo).
-  (* top *)
-  destruct (sem_cast v ty' ty m) as [v'|] eqn:?...
-  apply topred_ok; auto. split. apply red_cast; auto. exists w; constructor.
-  (* depth *)
-  eapply incontext_ok; eauto.
-(* seqand *)
-  destruct (is_val a1) as [[v ty'] | ] eqn:?. rewrite (is_val_inv _ _ _ Heqo).
-  (* top *)
-  destruct (bool_val v ty' m) as [v'|] eqn:?... destruct v'.
-  apply topred_ok; auto. split. eapply red_seqand_true; eauto. exists w; constructor.
-  apply topred_ok; auto. split. eapply red_seqand_false; eauto. exists w; constructor.
-  (* depth *)
-  eapply incontext_ok; eauto.
-(* seqor *)
-  destruct (is_val a1) as [[v ty'] | ] eqn:?. rewrite (is_val_inv _ _ _ Heqo).
-  (* top *)
-  destruct (bool_val v ty' m) as [v'|] eqn:?... destruct v'.
-  apply topred_ok; auto. split. eapply red_seqor_true; eauto. exists w; constructor.
-  apply topred_ok; auto. split. eapply red_seqor_false; eauto. exists w; constructor.
-  (* depth *)
-  eapply incontext_ok; eauto.
-(* condition *)
-  destruct (is_val a1) as [[v ty'] | ] eqn:?. rewrite (is_val_inv _ _ _ Heqo).
-  (* top *)
-  destruct (bool_val v ty' m) as [v'|] eqn:?...
-  apply topred_ok; auto. split. eapply red_condition; eauto. exists w; constructor.
-  (* depth *)
-  eapply incontext_ok; eauto.
-(* sizeof *)
-  apply topred_ok; auto. split. apply red_sizeof. exists w; constructor.
-(* alignof *)
-  apply topred_ok; auto. split. apply red_alignof. exists w; constructor.
-(* assign *)
-  destruct (is_loc a1) as [[[b ofs] ty1] | ] eqn:?.
-  destruct (is_val a2) as [[v2 ty2] | ] eqn:?.
-  rewrite (is_loc_inv _ _ _ _ Heqo). rewrite (is_val_inv _ _ _ Heqo0).
-  (* top *)
-  destruct (type_eq ty1 ty)... subst ty1.
-  destruct (sem_cast v2 ty2 ty m) as [v|] eqn:?...
-  destruct (do_assign_loc w ty m b ofs v) as [[[w' t] m']|] eqn:?.
-  exploit do_assign_loc_sound; eauto. intros [P Q].
-  apply topred_ok; auto. split. apply red_assign; auto. exists w'; auto.
-  apply not_invert_ok; simpl; intros; myinv. exploit do_assign_loc_complete; eauto. congruence.
-  (* depth *)
-  eapply incontext2_ok; eauto.
-  eapply incontext2_ok; eauto.
-(* assignop *)
-  destruct (is_loc a1) as [[[b ofs] ty1] | ] eqn:?.
-  destruct (is_val a2) as [[v2 ty2] | ] eqn:?.
-  rewrite (is_loc_inv _ _ _ _ Heqo). rewrite (is_val_inv _ _ _ Heqo0).
-  (* top *)
-  destruct (type_eq ty1 ty)... subst ty1.
-  destruct (do_deref_loc w ty m b ofs) as [[[w' t] v] | ] eqn:?.
-  exploit do_deref_loc_sound; eauto. intros [A B].
-  apply topred_ok; auto. red. split. apply red_assignop; auto. exists w'; auto.
-  apply not_invert_ok; simpl; intros; myinv. exploit do_deref_loc_complete; eauto. congruence.
-  (* depth *)
-  eapply incontext2_ok; eauto.
-  eapply incontext2_ok; eauto.
-(* postincr *)
-  destruct (is_loc a) as [[[b ofs] ty'] | ] eqn:?. rewrite (is_loc_inv _ _ _ _ Heqo).
-  (* top *)
-  destruct (type_eq ty' ty)... subst ty'.
-  destruct (do_deref_loc w ty m b ofs) as [[[w' t] v] | ] eqn:?.
-  exploit do_deref_loc_sound; eauto. intros [A B].
-  apply topred_ok; auto. red. split. apply red_postincr; auto. exists w'; auto.
-  apply not_invert_ok; simpl; intros; myinv. exploit do_deref_loc_complete; eauto. congruence.
-  (* depth *)
-  eapply incontext_ok; eauto.
-(* comma *)
-  destruct (is_val a1) as [[v ty'] | ] eqn:?. rewrite (is_val_inv _ _ _ Heqo).
-  (* top *)
-  destruct (type_eq (typeof a2) ty)... subst ty.
-  apply topred_ok; auto. split. apply red_comma; auto. exists w; constructor.
-  (* depth *)
-  eapply incontext_ok; eauto.
-(* call *)
-  destruct (is_val a) as [[vf tyf] | ] eqn:?.
-  destruct (is_val_list rargs) as [vtl | ] eqn:?.
-  rewrite (is_val_inv _ _ _ Heqo). exploit is_val_list_all_values; eauto. intros ALLVAL.
-  (* top *)
-  destruct (classify_fun tyf) as [tyargs tyres cconv|] eqn:?...
-  destruct (Genv.find_funct ge vf) as [fd|] eqn:?...
-  destruct (sem_cast_arguments vtl tyargs m) as [vargs|] eqn:?...
-  destruct (type_eq (type_of_fundef fd) (Tfunction tyargs tyres cconv))...
-  apply topred_ok; auto. red. split; auto. eapply red_call; eauto.
-  eapply sem_cast_arguments_sound; eauto.
-  apply not_invert_ok; simpl; intros; myinv. specialize (H ALLVAL). myinv. congruence.
-  apply not_invert_ok; simpl; intros; myinv. specialize (H ALLVAL). myinv.
-  exploit sem_cast_arguments_complete; eauto. intros [vtl' [P Q]]. congruence.
-  apply not_invert_ok; simpl; intros; myinv. specialize (H ALLVAL). myinv. congruence.
-  apply not_invert_ok; simpl; intros; myinv. specialize (H ALLVAL). myinv. congruence.
-  (* depth *)
-  eapply incontext2_list_ok; eauto.
-  eapply incontext2_list_ok; eauto.
-(* builtin *)
-  destruct (is_val_list rargs) as [vtl | ] eqn:?.
-  exploit is_val_list_all_values; eauto. intros ALLVAL.
-  (* top *)
-  destruct (sem_cast_arguments vtl tyargs m) as [vargs|] eqn:?...
-  destruct (do_external ef w vargs m) as [[[[? ?] v] m'] | ] eqn:?...
-  exploit do_ef_external_sound; eauto. intros [EC PT].
-  apply topred_ok; auto. red. split; auto. eapply red_builtin; eauto.
-  eapply sem_cast_arguments_sound; eauto.
-  exists w0; auto.
-  apply not_invert_ok; simpl; intros; myinv. specialize (H ALLVAL). myinv.
-  assert (x = vargs).
-    exploit sem_cast_arguments_complete; eauto. intros [vtl' [A B]]. congruence.
-  subst x. exploit do_ef_external_complete; eauto. congruence.
-  apply not_invert_ok; simpl; intros; myinv. specialize (H ALLVAL). myinv.
-  exploit sem_cast_arguments_complete; eauto. intros [vtl' [A B]]. congruence.
-  (* depth *)
-  eapply incontext_list_ok; eauto.
-
-(* loc *)
-  split; intros. tauto. simpl; congruence.
-(* paren *)
-  destruct (is_val a) as [[v ty'] | ] eqn:?. rewrite (is_val_inv _ _ _ Heqo).
-  (* top *)
-  destruct (sem_cast v ty' tycast m) as [v'|] eqn:?...
-  apply topred_ok; auto. split. apply red_paren; auto. exists w; constructor.
-  (* depth *)
-  eapply incontext_ok; eauto.
-
-  induction al; simpl; intros.
-(* nil *)
-  split; intros. tauto. simpl; congruence.
-(* cons *)
-  eapply incontext2_list_ok'; eauto.
-Qed.
-
-Lemma step_exprlist_val_list:
-  forall m al, is_val_list al <> None -> step_exprlist al m = nil.
-Proof.
-  induction al; simpl; intros.
-  auto.
-  destruct (is_val r1) as [[v1 ty1]|] eqn:?; try congruence.
-  destruct (is_val_list al) eqn:?; try congruence.
-  rewrite (is_val_inv _ _ _ Heqo).
-  rewrite IHal. auto. congruence.
-Qed.
+(* Lemma topred_ok: *)
+(*   forall k a m rd, *)
+(*   reduction_ok k a m rd -> *)
+(*   reducts_ok k a m (topred rd). *)
+(* Proof. *)
+(*   intros. unfold topred; split; simpl; intros. *)
+(*   destruct H0; try contradiction. inv H0. exists a; exists k; auto. *)
+(*   congruence. *)
+(* Qed. *)
+
+(* Lemma stuck_ok: *)
+(*   forall k a m, *)
+(*   ~imm_safe_t k a m -> *)
+(*   reducts_ok k a m stuck. *)
+(* Proof. *)
+(*   intros. unfold stuck; split; simpl; intros. *)
+(*   destruct H0; try contradiction. inv H0. exists a; exists k; intuition. red. destruct k; auto. *)
+(*   congruence. *)
+(* Qed. *)
+
+(* Lemma wrong_kind_ok: *)
+(*   forall k a m, *)
+(*   k <> Cstrategy.expr_kind a -> *)
+(*   reducts_ok k a m stuck. *)
+(* Proof. *)
+(*   intros. apply stuck_ok. red; intros. exploit Cstrategy.imm_safe_kind; eauto. *)
+(*   eapply imm_safe_t_imm_safe; eauto. *)
+(* Qed. *)
+
+(* Lemma not_invert_ok: *)
+(*   forall k a m, *)
+(*   match a with *)
+(*   | Eloc _ _ _ => False *)
+(*   | Eval _ _ => False *)
+(*   | _ => invert_expr_prop a m -> False *)
+(*   end -> *)
+(*   reducts_ok k a m stuck. *)
+(* Proof. *)
+(*   intros. apply stuck_ok. red; intros. *)
+(*   exploit imm_safe_t_inv; eauto. destruct a; auto. *)
+(* Qed. *)
+
+(* Lemma incontext_ok: *)
+(*   forall k a m C res k' a', *)
+(*   reducts_ok k' a' m res -> *)
+(*   a = C a' -> *)
+(*   context k' k C -> *)
+(*   match k' with LV => is_loc a' = None | RV => is_val a' = None end -> *)
+(*   reducts_ok k a m (incontext C res). *)
+(* Proof. *)
+(*   unfold reducts_ok, incontext; intros. destruct H. split; intros. *)
+(*   exploit list_in_map_inv; eauto. intros [[C1 rd1] [P Q]]. inv P. *)
+(*   exploit H; eauto. intros [a'' [k'' [U [V W]]]]. *)
+(*   exists a''; exists k''. split. eapply context_compose; eauto. rewrite V; auto. *)
+(*   destruct res; simpl in H4; try congruence. destruct k'; intuition congruence. *)
+(* Qed. *)
+
+(* Lemma incontext2_ok: *)
+(*   forall k a m k1 a1 res1 k2 a2 res2 C1 C2, *)
+(*   reducts_ok k1 a1 m res1 -> *)
+(*   reducts_ok k2 a2 m res2 -> *)
+(*   a = C1 a1 -> a = C2 a2 -> *)
+(*   context k1 k C1 -> context k2 k C2 -> *)
+(*   match k1 with LV => is_loc a1 = None | RV => is_val a1 = None end *)
+(*   \/ match k2 with LV => is_loc a2 = None | RV => is_val a2 = None end -> *)
+(*   reducts_ok k a m (incontext2 C1 res1 C2 res2). *)
+(* Proof. *)
+(*   unfold reducts_ok, incontext2, incontext; intros. destruct H; destruct H0; split; intros. *)
+(*   destruct (in_app_or _ _ _ H8). *)
+(*   exploit list_in_map_inv; eauto. intros [[C' rd'] [P Q]]. inv P. *)
+(*   exploit H; eauto. intros [a'' [k'' [U [V W]]]]. *)
+(*   exists a''; exists k''. split. eapply context_compose; eauto. rewrite V; auto. *)
+(*   exploit list_in_map_inv; eauto. intros [[C' rd'] [P Q]]. inv P. *)
+(*   exploit H0; eauto. intros [a'' [k'' [U [V W]]]]. *)
+(*   exists a''; exists k''. split. eapply context_compose; eauto. rewrite H2; rewrite V; auto. *)
+(*   destruct res1; simpl in H8; try congruence. destruct res2; simpl in H8; try congruence. *)
+(*   destruct H5. destruct k1; intuition congruence. destruct k2; intuition congruence. *)
+(* Qed. *)
+
+(* Lemma incontext_list_ok: *)
+(*   forall ef tyargs al ty m res, *)
+(*   list_reducts_ok al m res -> *)
+(*   is_val_list al = None -> *)
+(*   reducts_ok RV (Ebuiltin ef tyargs al ty) m *)
+(*                 (incontext (fun x => Ebuiltin ef tyargs x ty) res). *)
+(* Proof. *)
+(*   unfold reducts_ok, incontext; intros. destruct H. split; intros. *)
+(*   exploit list_in_map_inv; eauto. intros [[C1 rd1] [P Q]]. inv P. *)
+(*   exploit H; eauto. intros [a'' [k'' [U [V W]]]]. *)
+(*   exists a''; exists k''. split. eauto. rewrite V; auto. *)
+(*   destruct res; simpl in H2. elim H1; auto. congruence. *)
+(* Qed. *)
+
+(* Lemma incontext2_list_ok: *)
+(*   forall a1 a2 ty m res1 res2, *)
+(*   reducts_ok RV a1 m res1 -> *)
+(*   list_reducts_ok a2 m res2 -> *)
+(*   is_val a1 = None \/ is_val_list a2 = None -> *)
+(*   reducts_ok RV (Ecall a1 a2 ty) m *)
+(*                (incontext2 (fun x => Ecall x a2 ty) res1 *)
+(*                            (fun x => Ecall a1 x ty) res2). *)
+(* Proof. *)
+(*   unfold reducts_ok, incontext2, incontext; intros. destruct H; destruct H0; split; intros. *)
+(*   destruct (in_app_or _ _ _ H4). *)
+(*   exploit list_in_map_inv; eauto. intros [[C' rd'] [P Q]]. inv P. *)
+(*   exploit H; eauto. intros [a'' [k'' [U [V W]]]]. *)
+(*   exists a''; exists k''. split. eauto. rewrite V; auto. *)
+(*   exploit list_in_map_inv; eauto. intros [[C' rd'] [P Q]]. inv P. *)
+(*   exploit H0; eauto. intros [a'' [k'' [U [V W]]]]. *)
+(*   exists a''; exists k''. split. eauto. rewrite V; auto. *)
+(*   destruct res1; simpl in H4; try congruence. destruct res2; simpl in H4; try congruence. *)
+(*   tauto. *)
+(* Qed. *)
+
+(* Lemma incontext2_list_ok': *)
+(*   forall a1 a2 m res1 res2, *)
+(*   reducts_ok RV a1 m res1 -> *)
+(*   list_reducts_ok a2 m res2 -> *)
+(*   list_reducts_ok (Econs a1 a2) m *)
+(*                (incontext2 (fun x => Econs x a2) res1 *)
+(*                            (fun x => Econs a1 x) res2). *)
+(* Proof. *)
+(*   unfold reducts_ok, list_reducts_ok, incontext2, incontext; intros. *)
+(*   destruct H; destruct H0. split; intros. *)
+(*   destruct (in_app_or _ _ _ H3). *)
+(*   exploit list_in_map_inv; eauto. intros [[C' rd'] [P Q]]. inv P. *)
+(*   exploit H; eauto. intros [a'' [k'' [U [V W]]]]. *)
+(*   exists a''; exists k''. split. eauto. rewrite V; auto. *)
+(*   exploit list_in_map_inv; eauto. intros [[C' rd'] [P Q]]. inv P. *)
+(*   exploit H0; eauto. intros [a'' [k'' [U [V W]]]]. *)
+(*   exists a''; exists k''. split. eauto. rewrite V; auto. *)
+(*   destruct res1; simpl in H3; try congruence. destruct res2; simpl in H3; try congruence. *)
+(*   simpl. destruct (is_val a1). destruct (is_val_list a2). congruence. intuition congruence. intuition congruence. *)
+(* Qed. *)
+
+(* Lemma is_val_list_all_values: *)
+(*   forall al vtl, is_val_list al = Some vtl -> exprlist_all_values al. *)
+(* Proof. *)
+(*   induction al; simpl; intros. auto. *)
+(*   destruct (is_val r1) as [[v ty]|] eqn:?; try discriminate. *)
+(*   destruct (is_val_list al) as [vtl'|] eqn:?; try discriminate. *)
+(*   rewrite (is_val_inv _ _ _ Heqo). eauto. *)
+(* Qed. *)
+
+(* Ltac myinv := *)
+(*   match goal with *)
+(*   | [ H: False |- _ ] => destruct H *)
+(*   | [ H: _ /\ _ |- _ ] => destruct H; myinv *)
+(*   | [ H: exists _, _ |- _ ] => destruct H; myinv *)
+(*   | _ => idtac *)
+(*   end. *)
+
+(* Theorem step_expr_sound: *)
+(*   forall a k m, reducts_ok k a m (step_expr k a m) *)
+(* with step_exprlist_sound: *)
+(*   forall al m, list_reducts_ok al m (step_exprlist al m). *)
+(* Proof with (try (apply not_invert_ok; simpl; intro; myinv; intuition congruence; fail)). *)
+(*   induction a; intros; simpl; destruct k; try (apply wrong_kind_ok; simpl; congruence). *)
+(* (* Eval *) *)
+(*   split; intros. tauto. simpl; congruence. *)
+(* (* Evar *) *)
+(*   destruct (e!x) as [[b ty']|] eqn:?. *)
+(*   destruct (type_eq ty ty')... *)
+(*   subst. apply topred_ok; auto. apply red_var_local; auto. *)
+(*   destruct (Genv.find_symbol ge x) as [b|] eqn:?... *)
+(*   apply topred_ok; auto. apply red_var_global; auto. *)
+(* (* Efield *) *)
+(*   destruct (is_val a) as [[v ty'] | ] eqn:?. *)
+(*   rewrite (is_val_inv _ _ _ Heqo). *)
+(*   destruct v... *)
+(*   destruct ty'... *)
+(*   (* top struct *) *)
+(*   destruct (ge.(genv_cenv)!i0) as [co|] eqn:?... *)
+(*   destruct (field_offset ge f (co_members co)) as [delta|] eqn:?... *)
+(*   apply topred_ok; auto. eapply red_field_struct; eauto. *)
+(*   (* top union *) *)
+(*   destruct (ge.(genv_cenv)!i0) as [co|] eqn:?... *)
+(*   apply topred_ok; auto. eapply red_field_union; eauto. *)
+(*   (* in depth *) *)
+(*   eapply incontext_ok; eauto. *)
+(* (* Evalof *) *)
+(*   destruct (is_loc a) as [[[b ofs] ty'] | ] eqn:?. rewrite (is_loc_inv _ _ _ _ Heqo). *)
+(*   (* top *) *)
+(*   destruct (type_eq ty ty')... subst ty'. *)
+(*   destruct (do_deref_loc w ty m b ofs) as [[[w' t] v] | ] eqn:?. *)
+(*   exploit do_deref_loc_sound; eauto. intros [A B]. *)
+(*   apply topred_ok; auto. red. split. apply red_rvalof; auto. exists w'; auto. *)
+(*   apply not_invert_ok; simpl; intros; myinv. exploit do_deref_loc_complete; eauto. congruence. *)
+(*   (* depth *) *)
+(*   eapply incontext_ok; eauto. *)
+(* (* Ederef *) *)
+(*   destruct (is_val a) as [[v ty'] | ] eqn:?. rewrite (is_val_inv _ _ _ Heqo). *)
+(*   (* top *) *)
+(*   destruct v... apply topred_ok; auto. apply red_deref; auto. *)
+(*   (* depth *) *)
+(*   eapply incontext_ok; eauto. *)
+(* (* Eaddrof *) *)
+(*   destruct (is_loc a) as [[[b ofs] ty'] | ] eqn:?. rewrite (is_loc_inv _ _ _ _ Heqo). *)
+(*   (* top *) *)
+(*   apply topred_ok; auto. split. apply red_addrof; auto. exists w; constructor. *)
+(*   (* depth *) *)
+(*   eapply incontext_ok; eauto. *)
+(* (* unop *) *)
+(*   destruct (is_val a) as [[v ty'] | ] eqn:?. rewrite (is_val_inv _ _ _ Heqo). *)
+(*   (* top *) *)
+(*   destruct (sem_unary_operation op v ty' m) as [v'|] eqn:?... *)
+(*   apply topred_ok; auto. split. apply red_unop; auto. exists w; constructor. *)
+(*   (* depth *) *)
+(*   eapply incontext_ok; eauto. *)
+(* (* binop *) *)
+(*   destruct (is_val a1) as [[v1 ty1] | ] eqn:?. *)
+(*   destruct (is_val a2) as [[v2 ty2] | ] eqn:?. *)
+(*   rewrite (is_val_inv _ _ _ Heqo). rewrite (is_val_inv _ _ _ Heqo0). *)
+(*   (* top *) *)
+(*   destruct (sem_binary_operation ge op v1 ty1 v2 ty2 m) as [v|] eqn:?... *)
+(*   apply topred_ok; auto. split. apply red_binop; auto. exists w; constructor. *)
+(*   (* depth *) *)
+(*   eapply incontext2_ok; eauto. *)
+(*   eapply incontext2_ok; eauto. *)
+(* (* cast *) *)
+(*   destruct (is_val a) as [[v ty'] | ] eqn:?. rewrite (is_val_inv _ _ _ Heqo). *)
+(*   (* top *) *)
+(*   destruct (sem_cast v ty' ty m) as [v'|] eqn:?... *)
+(*   apply topred_ok; auto. split. apply red_cast; auto. exists w; constructor. *)
+(*   (* depth *) *)
+(*   eapply incontext_ok; eauto. *)
+(* (* seqand *) *)
+(*   destruct (is_val a1) as [[v ty'] | ] eqn:?. rewrite (is_val_inv _ _ _ Heqo). *)
+(*   (* top *) *)
+(*   destruct (bool_val v ty' m) as [v'|] eqn:?... destruct v'. *)
+(*   apply topred_ok; auto. split. eapply red_seqand_true; eauto. exists w; constructor. *)
+(*   apply topred_ok; auto. split. eapply red_seqand_false; eauto. exists w; constructor. *)
+(*   (* depth *) *)
+(*   eapply incontext_ok; eauto. *)
+(* (* seqor *) *)
+(*   destruct (is_val a1) as [[v ty'] | ] eqn:?. rewrite (is_val_inv _ _ _ Heqo). *)
+(*   (* top *) *)
+(*   destruct (bool_val v ty' m) as [v'|] eqn:?... destruct v'. *)
+(*   apply topred_ok; auto. split. eapply red_seqor_true; eauto. exists w; constructor. *)
+(*   apply topred_ok; auto. split. eapply red_seqor_false; eauto. exists w; constructor. *)
+(*   (* depth *) *)
+(*   eapply incontext_ok; eauto. *)
+(* (* condition *) *)
+(*   destruct (is_val a1) as [[v ty'] | ] eqn:?. rewrite (is_val_inv _ _ _ Heqo). *)
+(*   (* top *) *)
+(*   destruct (bool_val v ty' m) as [v'|] eqn:?... *)
+(*   apply topred_ok; auto. split. eapply red_condition; eauto. exists w; constructor. *)
+(*   (* depth *) *)
+(*   eapply incontext_ok; eauto. *)
+(* (* sizeof *) *)
+(*   apply topred_ok; auto. split. apply red_sizeof. exists w; constructor. *)
+(* (* alignof *) *)
+(*   apply topred_ok; auto. split. apply red_alignof. exists w; constructor. *)
+(* (* assign *) *)
+(*   destruct (is_loc a1) as [[[b ofs] ty1] | ] eqn:?. *)
+(*   destruct (is_val a2) as [[v2 ty2] | ] eqn:?. *)
+(*   rewrite (is_loc_inv _ _ _ _ Heqo). rewrite (is_val_inv _ _ _ Heqo0). *)
+(*   (* top *) *)
+(*   destruct (type_eq ty1 ty)... subst ty1. *)
+(*   destruct (sem_cast v2 ty2 ty m) as [v|] eqn:?... *)
+(*   destruct (do_assign_loc w ty m b ofs v) as [[[w' t] m']|] eqn:?. *)
+(*   exploit do_assign_loc_sound; eauto. intros [P Q]. *)
+(*   apply topred_ok; auto. split. apply red_assign; auto. exists w'; auto. *)
+(*   apply not_invert_ok; simpl; intros; myinv. exploit do_assign_loc_complete; eauto. congruence. *)
+(*   (* depth *) *)
+(*   eapply incontext2_ok; eauto. *)
+(*   eapply incontext2_ok; eauto. *)
+(* (* assignop *) *)
+(*   destruct (is_loc a1) as [[[b ofs] ty1] | ] eqn:?. *)
+(*   destruct (is_val a2) as [[v2 ty2] | ] eqn:?. *)
+(*   rewrite (is_loc_inv _ _ _ _ Heqo). rewrite (is_val_inv _ _ _ Heqo0). *)
+(*   (* top *) *)
+(*   destruct (type_eq ty1 ty)... subst ty1. *)
+(*   destruct (do_deref_loc w ty m b ofs) as [[[w' t] v] | ] eqn:?. *)
+(*   exploit do_deref_loc_sound; eauto. intros [A B]. *)
+(*   apply topred_ok; auto. red. split. apply red_assignop; auto. exists w'; auto. *)
+(*   apply not_invert_ok; simpl; intros; myinv. exploit do_deref_loc_complete; eauto. congruence. *)
+(*   (* depth *) *)
+(*   eapply incontext2_ok; eauto. *)
+(*   eapply incontext2_ok; eauto. *)
+(* (* postincr *) *)
+(*   destruct (is_loc a) as [[[b ofs] ty'] | ] eqn:?. rewrite (is_loc_inv _ _ _ _ Heqo). *)
+(*   (* top *) *)
+(*   destruct (type_eq ty' ty)... subst ty'. *)
+(*   destruct (do_deref_loc w ty m b ofs) as [[[w' t] v] | ] eqn:?. *)
+(*   exploit do_deref_loc_sound; eauto. intros [A B]. *)
+(*   apply topred_ok; auto. red. split. apply red_postincr; auto. exists w'; auto. *)
+(*   apply not_invert_ok; simpl; intros; myinv. exploit do_deref_loc_complete; eauto. congruence. *)
+(*   (* depth *) *)
+(*   eapply incontext_ok; eauto. *)
+(* (* comma *) *)
+(*   destruct (is_val a1) as [[v ty'] | ] eqn:?. rewrite (is_val_inv _ _ _ Heqo). *)
+(*   (* top *) *)
+(*   destruct (type_eq (typeof a2) ty)... subst ty. *)
+(*   apply topred_ok; auto. split. apply red_comma; auto. exists w; constructor. *)
+(*   (* depth *) *)
+(*   eapply incontext_ok; eauto. *)
+(* (* call *) *)
+(*   destruct (is_val a) as [[vf tyf] | ] eqn:?. *)
+(*   destruct (is_val_list rargs) as [vtl | ] eqn:?. *)
+(*   rewrite (is_val_inv _ _ _ Heqo). exploit is_val_list_all_values; eauto. intros ALLVAL. *)
+(*   (* top *) *)
+(*   destruct (classify_fun tyf) as [tyargs tyres cconv|] eqn:?... *)
+(*   destruct (Genv.find_funct ge vf) as [fd|] eqn:?... *)
+(*   destruct (sem_cast_arguments vtl tyargs m) as [vargs|] eqn:?... *)
+(*   destruct (type_eq (type_of_fundef fd) (Tfunction tyargs tyres cconv))... *)
+(*   apply topred_ok; auto. red. split; auto. eapply red_call; eauto. *)
+(*   eapply sem_cast_arguments_sound; eauto. *)
+(*   apply not_invert_ok; simpl; intros; myinv. specialize (H ALLVAL). myinv. congruence. *)
+(*   apply not_invert_ok; simpl; intros; myinv. specialize (H ALLVAL). myinv. *)
+(*   exploit sem_cast_arguments_complete; eauto. intros [vtl' [P Q]]. congruence. *)
+(*   apply not_invert_ok; simpl; intros; myinv. specialize (H ALLVAL). myinv. congruence. *)
+(*   apply not_invert_ok; simpl; intros; myinv. specialize (H ALLVAL). myinv. congruence. *)
+(*   (* depth *) *)
+(*   eapply incontext2_list_ok; eauto. *)
+(*   eapply incontext2_list_ok; eauto. *)
+(* (* builtin *) *)
+(*   destruct (is_val_list rargs) as [vtl | ] eqn:?. *)
+(*   exploit is_val_list_all_values; eauto. intros ALLVAL. *)
+(*   (* top *) *)
+(*   destruct (sem_cast_arguments vtl tyargs m) as [vargs|] eqn:?... *)
+(*   destruct (do_external ef w vargs m) as [[[[? ?] v] m'] | ] eqn:?... *)
+(*   exploit do_ef_external_sound; eauto. intros [EC PT]. *)
+(*   apply topred_ok; auto. red. split; auto. eapply red_builtin; eauto. *)
+(*   eapply sem_cast_arguments_sound; eauto. *)
+(*   exists w0; auto. *)
+(*   apply not_invert_ok; simpl; intros; myinv. specialize (H ALLVAL). myinv. *)
+(*   assert (x = vargs). *)
+(*     exploit sem_cast_arguments_complete; eauto. intros [vtl' [A B]]. congruence. *)
+(*   subst x. exploit do_ef_external_complete; eauto. congruence. *)
+(*   apply not_invert_ok; simpl; intros; myinv. specialize (H ALLVAL). myinv. *)
+(*   exploit sem_cast_arguments_complete; eauto. intros [vtl' [A B]]. congruence. *)
+(*   (* depth *) *)
+(*   eapply incontext_list_ok; eauto. *)
+
+(* (* loc *) *)
+(*   split; intros. tauto. simpl; congruence. *)
+(* (* paren *) *)
+(*   destruct (is_val a) as [[v ty'] | ] eqn:?. rewrite (is_val_inv _ _ _ Heqo). *)
+(*   (* top *) *)
+(*   destruct (sem_cast v ty' tycast m) as [v'|] eqn:?... *)
+(*   apply topred_ok; auto. split. apply red_paren; auto. exists w; constructor. *)
+(*   (* depth *) *)
+(*   eapply incontext_ok; eauto. *)
+
+(*   induction al; simpl; intros. *)
+(* (* nil *) *)
+(*   split; intros. tauto. simpl; congruence. *)
+(* (* cons *) *)
+(*   eapply incontext2_list_ok'; eauto. *)
+(* Qed. *)
+
+(* Lemma step_exprlist_val_list: *)
+(*   forall m al, is_val_list al <> None -> step_exprlist al m = nil. *)
+(* Proof. *)
+(*   induction al; simpl; intros. *)
+(*   auto. *)
+(*   destruct (is_val r1) as [[v1 ty1]|] eqn:?; try congruence. *)
+(*   destruct (is_val_list al) eqn:?; try congruence. *)
+(*   rewrite (is_val_inv _ _ _ Heqo). *)
+(*   rewrite IHal. auto. congruence. *)
+(* Qed. *)
 
 (** Completeness part 1: [step_expr] contains all possible non-error reducts. *)
 
-Lemma lred_topred:
-  forall l1 m1 l2 m2,
-  lred ge e l1 m1 l2 m2 ->
-  exists rule, step_expr LV l1 m1 = topred (Lred rule l2 m2).
-Proof.
-  induction 1; simpl.
-(* var local *)
-  rewrite H. rewrite dec_eq_true. econstructor; eauto.
-(* var global *)
-  rewrite H; rewrite H0. econstructor; eauto.
-(* deref *)
-  econstructor; eauto.
-(* field struct *)
-  rewrite H, H0; econstructor; eauto.
-(* field union *)
-  rewrite H; econstructor; eauto.
-Qed.
-
-Lemma rred_topred:
-  forall w' r1 m1 t r2 m2,
-  rred ge r1 m1 t r2 m2 -> possible_trace w t w' ->
-  exists rule, step_expr RV r1 m1 = topred (Rred rule r2 m2 t).
-Proof.
-  induction 1; simpl; intros.
-(* valof *)
-  rewrite dec_eq_true.
-  rewrite (do_deref_loc_complete _ _ _ _ _ _ _ _ H H0). econstructor; eauto.
-(* addrof *)
-  inv H. econstructor; eauto.
-(* unop *)
-  inv H0. rewrite H; econstructor; eauto.
-(* binop *)
-  inv H0. rewrite H; econstructor; eauto.
-(* cast *)
-  inv H0. rewrite H; econstructor; eauto.
-(* seqand *)
-  inv H0. rewrite H; econstructor; eauto.
-  inv H0. rewrite H; econstructor; eauto.
-(* seqor *)
-  inv H0. rewrite H; econstructor; eauto.
-  inv H0. rewrite H; econstructor; eauto.
-(* condition *)
-  inv H0. rewrite H; econstructor; eauto.
-(* sizeof *)
-  inv H. econstructor; eauto.
-(* alignof *)
-  inv H. econstructor; eauto.
-(* assign *)
-  rewrite dec_eq_true. rewrite H. rewrite (do_assign_loc_complete _ _ _ _ _ _ _ _ _ H0 H1).
-  econstructor; eauto.
-(* assignop *)
-  rewrite dec_eq_true. rewrite (do_deref_loc_complete _ _ _ _ _ _ _ _ H H0).
-  econstructor; eauto.
-(* postincr *)
-  rewrite dec_eq_true. subst. rewrite (do_deref_loc_complete _ _ _ _ _ _ _ _ H H1).
-  econstructor; eauto.
-(* comma *)
-  inv H0. rewrite dec_eq_true. econstructor; eauto.
-(* paren *)
-  inv H0. rewrite H; econstructor; eauto.
-(* builtin *)
-  exploit sem_cast_arguments_complete; eauto. intros [vtl [A B]].
-  exploit do_ef_external_complete; eauto. intros C.
-  rewrite A. rewrite B. rewrite C. econstructor; eauto.
-Qed.
-
-Lemma callred_topred:
-  forall a fd args ty m,
-  callred ge a m fd args ty ->
-  exists rule, step_expr RV a m = topred (Callred rule fd args ty m).
-Proof.
-  induction 1; simpl.
-  rewrite H2. exploit sem_cast_arguments_complete; eauto. intros [vtl [A B]].
-  rewrite A; rewrite H; rewrite B; rewrite H1; rewrite dec_eq_true. econstructor; eauto.
-Qed.
+(* Lemma lred_topred: *)
+(*   forall l1 m1 l2 m2, *)
+(*   lred ge e l1 m1 l2 m2 -> *)
+(*   exists rule, step_expr LV l1 m1 = topred (Lred rule l2 m2). *)
+(* Proof. *)
+(*   induction 1; simpl. *)
+(* (* var local *) *)
+(*   rewrite H. rewrite dec_eq_true. econstructor; eauto. *)
+(* (* var global *) *)
+(*   rewrite H; rewrite H0. econstructor; eauto. *)
+(* (* deref *) *)
+(*   econstructor; eauto. *)
+(* (* field struct *) *)
+(*   rewrite H, H0; econstructor; eauto. *)
+(* (* field union *) *)
+(*   rewrite H; econstructor; eauto. *)
+(* Qed. *)
+
+(* Lemma rred_topred: *)
+(*   forall w' r1 m1 t r2 m2, *)
+(*   rred ge r1 m1 t r2 m2 -> possible_trace w t w' -> *)
+(*   exists rule, step_expr RV r1 m1 = topred (Rred rule r2 m2 t). *)
+(* Proof. *)
+(*   induction 1; simpl; intros. *)
+(* (* valof *) *)
+(*   rewrite dec_eq_true. *)
+(*   rewrite (do_deref_loc_complete _ _ _ _ _ _ _ _ H H0). econstructor; eauto. *)
+(* (* addrof *) *)
+(*   inv H. econstructor; eauto. *)
+(* (* unop *) *)
+(*   inv H0. rewrite H; econstructor; eauto. *)
+(* (* binop *) *)
+(*   inv H0. rewrite H; econstructor; eauto. *)
+(* (* cast *) *)
+(*   inv H0. rewrite H; econstructor; eauto. *)
+(* (* seqand *) *)
+(*   inv H0. rewrite H; econstructor; eauto. *)
+(*   inv H0. rewrite H; econstructor; eauto. *)
+(* (* seqor *) *)
+(*   inv H0. rewrite H; econstructor; eauto. *)
+(*   inv H0. rewrite H; econstructor; eauto. *)
+(* (* condition *) *)
+(*   inv H0. rewrite H; econstructor; eauto. *)
+(* (* sizeof *) *)
+(*   inv H. econstructor; eauto. *)
+(* (* alignof *) *)
+(*   inv H. econstructor; eauto. *)
+(* (* assign *) *)
+(*   rewrite dec_eq_true. rewrite H. rewrite (do_assign_loc_complete _ _ _ _ _ _ _ _ _ H0 H1). *)
+(*   econstructor; eauto. *)
+(* (* assignop *) *)
+(*   rewrite dec_eq_true. rewrite (do_deref_loc_complete _ _ _ _ _ _ _ _ H H0). *)
+(*   econstructor; eauto. *)
+(* (* postincr *) *)
+(*   rewrite dec_eq_true. subst. rewrite (do_deref_loc_complete _ _ _ _ _ _ _ _ H H1). *)
+(*   econstructor; eauto. *)
+(* (* comma *) *)
+(*   inv H0. rewrite dec_eq_true. econstructor; eauto. *)
+(* (* paren *) *)
+(*   inv H0. rewrite H; econstructor; eauto. *)
+(* (* builtin *) *)
+(*   exploit sem_cast_arguments_complete; eauto. intros [vtl [A B]]. *)
+(*   exploit do_ef_external_complete; eauto. intros C. *)
+(*   rewrite A. rewrite B. rewrite C. econstructor; eauto. *)
+(* Qed. *)
+
+(* Lemma callred_topred: *)
+(*   forall a fd args ty m, *)
+(*   callred ge a m fd args ty -> *)
+(*   exists rule, step_expr RV a m = topred (Callred rule fd args ty m). *)
+(* Proof. *)
+(*   induction 1; simpl. *)
+(*   rewrite H2. exploit sem_cast_arguments_complete; eauto. intros [vtl [A B]]. *)
+(*   rewrite A; rewrite H; rewrite B; rewrite H1; rewrite dec_eq_true. econstructor; eauto. *)
+(* Qed. *)
 
 Definition reducts_incl {A B: Type} (C: A -> B) (res1: reducts A) (res2: reducts B) : Prop :=
   forall C1 rd, In (C1, rd) res1 -> In ((fun x => C(C1 x)), rd) res2.
 
-Lemma reducts_incl_trans:
-  forall (A1 A2: Type) (C: A1 -> A2) res1 res2, reducts_incl C res1 res2 ->
-  forall (A3: Type) (C': A2 -> A3) res3,
-  reducts_incl C' res2 res3 ->
-  reducts_incl (fun x => C'(C x)) res1 res3.
-Proof.
-  unfold reducts_incl; intros. auto.
-Qed.
-
-Lemma reducts_incl_nil:
-  forall (A B: Type) (C: A -> B) res,
-  reducts_incl C nil res.
-Proof.
-  intros; red. intros; contradiction.
-Qed.
-
-Lemma reducts_incl_val:
-  forall (A: Type) a m v ty (C: expr -> A) res,
-  is_val a = Some(v, ty) -> reducts_incl C (step_expr RV a m) res.
-Proof.
-  intros. rewrite (is_val_inv _ _ _ H). apply reducts_incl_nil.
-Qed.
-
-Lemma reducts_incl_loc:
-  forall (A: Type) a m b ofs ty (C: expr -> A) res,
-  is_loc a = Some(b, ofs, ty) -> reducts_incl C (step_expr LV a m) res.
-Proof.
-  intros. rewrite (is_loc_inv _ _ _ _ H). apply reducts_incl_nil.
-Qed.
-
-Lemma reducts_incl_listval:
-  forall (A: Type) a m vtl (C: exprlist -> A) res,
-  is_val_list a = Some vtl -> reducts_incl C (step_exprlist a m) res.
-Proof.
-  intros. rewrite step_exprlist_val_list. apply reducts_incl_nil. congruence.
-Qed.
-
-Lemma reducts_incl_incontext:
-  forall (A B: Type) (C: A -> B) res,
-  reducts_incl C res (incontext C res).
-Proof.
-  unfold reducts_incl, incontext. intros.
-  set (f := fun z : (expr -> A) * reduction => (fun x : expr => C (fst z x), snd z)).
-  change (In (f (C1, rd)) (map f res)). apply in_map. auto.
-Qed.
-
-Lemma reducts_incl_incontext2_left:
-  forall (A1 A2 B: Type) (C1: A1 -> B) res1 (C2: A2 -> B) res2,
-  reducts_incl C1 res1 (incontext2 C1 res1 C2 res2).
-Proof.
-  unfold reducts_incl, incontext2, incontext. intros.
-  rewrite in_app_iff. left.
-  set (f := fun z : (expr -> A1) * reduction => (fun x : expr => C1 (fst z x), snd z)).
-  change (In (f (C0, rd)) (map f res1)). apply in_map; auto.
-Qed.
-
-Lemma reducts_incl_incontext2_right:
-  forall (A1 A2 B: Type) (C1: A1 -> B) res1 (C2: A2 -> B) res2,
-  reducts_incl C2 res2 (incontext2 C1 res1 C2 res2).
-Proof.
-  unfold reducts_incl, incontext2, incontext. intros.
-  rewrite in_app_iff. right.
-  set (f := fun z : (expr -> A2) * reduction => (fun x : expr => C2 (fst z x), snd z)).
-  change (In (f (C0, rd)) (map f res2)). apply in_map; auto.
-Qed.
-
-Local Hint Resolve reducts_incl_val reducts_incl_loc reducts_incl_listval
-                   reducts_incl_incontext reducts_incl_incontext2_left
-                   reducts_incl_incontext2_right : core.
-
-Lemma step_expr_context:
-  forall from to C, context from to C ->
-  forall a m, reducts_incl C (step_expr from a m) (step_expr to (C a) m)
-with step_exprlist_context:
-  forall from C, contextlist from C ->
-  forall a m, reducts_incl C (step_expr from a m) (step_exprlist (C a) m).
-Proof.
-  induction 1; simpl; intros.
-(* top *)
-  red. destruct (step_expr k a m); auto.
-  try (* no eta in 8.3 *)
-   (intros;
-    replace (fun x => C1 x) with C1 by (apply extensionality; auto);
-    auto).
-(* deref *)
-  eapply reducts_incl_trans with (C' := fun x => Ederef x ty); eauto.
-  destruct (is_val (C a)) as [[v ty']|] eqn:?; eauto.
-(* field *)
-  eapply reducts_incl_trans with (C' := fun x => Efield x f ty); eauto.
-  destruct (is_val (C a)) as [[v ty']|] eqn:?; eauto.
-(* valof *)
-  eapply reducts_incl_trans with (C' := fun x => Evalof x ty); eauto.
-  destruct (is_loc (C a)) as [[[b ofs] ty']|] eqn:?; eauto.
-(* addrof *)
-  eapply reducts_incl_trans with (C' := fun x => Eaddrof x ty); eauto.
-  destruct (is_loc (C a)) as [[[b ofs] ty']|] eqn:?; eauto.
-(* unop *)
-  eapply reducts_incl_trans with (C' := fun x => Eunop op x ty); eauto.
-  destruct (is_val (C a)) as [[v ty']|] eqn:?; eauto.
-(* binop left *)
-  eapply reducts_incl_trans with (C' := fun x => Ebinop op x e2 ty); eauto.
-  destruct (is_val (C a)) as [[v ty']|] eqn:?; eauto.
-(* binop right *)
-  eapply reducts_incl_trans with (C' := fun x => Ebinop op e1 x ty); eauto.
-  destruct (is_val e1) as [[v1 ty1]|] eqn:?; eauto.
-  destruct (is_val (C a)) as [[v2 ty2]|] eqn:?; eauto.
-(* cast *)
-  eapply reducts_incl_trans with (C' := fun x => Ecast x ty); eauto.
-  destruct (is_val (C a)) as [[v ty']|] eqn:?; eauto.
-(* seqand *)
-  eapply reducts_incl_trans with (C' := fun x => Eseqand x r2 ty); eauto.
-  destruct (is_val (C a)) as [[v ty']|] eqn:?; eauto.
-(* seqor *)
-  eapply reducts_incl_trans with (C' := fun x => Eseqor x r2 ty); eauto.
-  destruct (is_val (C a)) as [[v ty']|] eqn:?; eauto.
-(* condition *)
-  eapply reducts_incl_trans with (C' := fun x => Econdition x r2 r3 ty); eauto.
-  destruct (is_val (C a)) as [[v ty']|] eqn:?; eauto.
-(* assign left *)
-  eapply reducts_incl_trans with (C' := fun x => Eassign x e2 ty); eauto.
-  destruct (is_loc (C a)) as [[[b ofs] ty']|] eqn:?; eauto.
-(* assign right *)
-  eapply reducts_incl_trans with (C' := fun x => Eassign e1 x ty); eauto.
-  destruct (is_loc e1) as [[[b ofs] ty1]|] eqn:?; eauto.
-  destruct (is_val (C a)) as [[v2 ty2]|] eqn:?; eauto.
-(* assignop left *)
-  eapply reducts_incl_trans with (C' := fun x => Eassignop op x e2 tyres ty); eauto.
-  destruct (is_loc (C a)) as [[[b ofs] ty']|] eqn:?; eauto.
-(* assignop right *)
-  eapply reducts_incl_trans with (C' := fun x => Eassignop op e1 x tyres ty); eauto.
-  destruct (is_loc e1) as [[[b ofs] ty1]|] eqn:?; eauto.
-  destruct (is_val (C a)) as [[v2 ty2]|] eqn:?; eauto.
-(* postincr *)
-  eapply reducts_incl_trans with (C' := fun x => Epostincr id x ty); eauto.
-  destruct (is_loc (C a)) as [[[b ofs] ty']|] eqn:?; eauto.
-(* call left *)
-  eapply reducts_incl_trans with (C' := fun x => Ecall x el ty); eauto.
-  destruct (is_val (C a)) as [[v ty']|] eqn:?; eauto.
-(* call right *)
-  eapply reducts_incl_trans with (C' := fun x => Ecall e1 x ty). apply step_exprlist_context. auto.
-  destruct (is_val e1) as [[v1 ty1]|] eqn:?; eauto.
-  destruct (is_val_list (C a)) as [vl|] eqn:?; eauto.
-(* builtin *)
-  eapply reducts_incl_trans with (C' := fun x => Ebuiltin ef tyargs x ty). apply step_exprlist_context. auto.
-  destruct (is_val_list (C a)) as [vl|] eqn:?; eauto.
-(* comma *)
-  eapply reducts_incl_trans with (C' := fun x => Ecomma x e2 ty); eauto.
-  destruct (is_val (C a)) as [[v ty']|] eqn:?; eauto.
-(* paren *)
-  eapply reducts_incl_trans with (C' := fun x => Eparen x tycast ty); eauto.
-  destruct (is_val (C a)) as [[v ty']|] eqn:?; eauto.
-
-  induction 1; simpl; intros.
-(* cons left *)
-  eapply reducts_incl_trans with (C' := fun x => Econs x el).
-  apply step_expr_context; eauto. eauto.
-(* binop right *)
-  eapply reducts_incl_trans with (C' := fun x => Econs e1 x).
-  apply step_exprlist_context; eauto. eauto.
-Qed.
-
-(** Completeness part 2: if we can reduce to [Stuckstate], [step_expr]
-    contains at least one [Stuckred] reduction. *)
-
-Lemma not_stuckred_imm_safe:
-  forall m a k,
-  (forall C, ~In (C, Stuckred) (step_expr k a m)) -> imm_safe_t k a m.
-Proof.
-  intros. generalize (step_expr_sound a k m). intros [A B].
-  destruct (step_expr k a m) as [|[C rd] res] eqn:?.
-  specialize (B (eq_refl _)). destruct k.
-  destruct a; simpl in B; try congruence. constructor.
-  destruct a; simpl in B; try congruence. constructor.
-  assert (NOTSTUCK: rd <> Stuckred).
-    red; intros. elim (H C); subst rd; auto with coqlib.
-  exploit A. eauto with coqlib. intros [a' [k' [P [Q R]]]].
-  destruct k'; destruct rd; simpl in R; intuition.
-  subst a. eapply imm_safe_t_lred; eauto.
-  subst a. destruct H1 as [w' PT]. eapply imm_safe_t_rred; eauto.
-  subst. eapply imm_safe_t_callred; eauto.
-Qed.
-
-Lemma not_imm_safe_stuck_red:
-  forall m a k C,
-  context k RV C ->
-  ~imm_safe_t k a m ->
-  exists C', In (C', Stuckred) (step_expr RV (C a) m).
-Proof.
-  intros.
-  assert (exists C', In (C', Stuckred) (step_expr k a m)).
-    destruct (classic (exists C', In (C', Stuckred) (step_expr k a m))); auto.
-    elim H0. apply not_stuckred_imm_safe. apply not_ex_all_not. auto.
-  destruct H1 as [C' IN].
-  specialize (step_expr_context _ _ _ H a m). unfold reducts_incl.
-  intro.
-  exists (fun x => (C (C' x))). apply H1; auto.
-Qed.
-
-(** Connections between [imm_safe_t] and [imm_safe] *)
-
-Lemma imm_safe_imm_safe_t:
-  forall k a m,
-  imm_safe ge e k a m ->
-  imm_safe_t k a m \/
-  exists C, exists a1, exists t, exists a1', exists m',
-    context RV k C /\ a = C a1 /\ rred ge a1 m t a1' m' /\ forall w', ~possible_trace w t w'.
-Proof.
-  intros. inv H.
-  left. apply imm_safe_t_val.
-  left. apply imm_safe_t_loc.
-  left. eapply imm_safe_t_lred; eauto.
-  destruct (classic (exists w', possible_trace w t w')) as [[w' A] | A].
-  left. eapply imm_safe_t_rred; eauto.
-  right. exists C; exists e0; exists t; exists e'; exists m'; intuition. apply A; exists w'; auto.
-  left. eapply imm_safe_t_callred; eauto.
-Qed.
+(* Lemma reducts_incl_trans: *)
+(*   forall (A1 A2: Type) (C: A1 -> A2) res1 res2, reducts_incl C res1 res2 -> *)
+(*   forall (A3: Type) (C': A2 -> A3) res3, *)
+(*   reducts_incl C' res2 res3 -> *)
+(*   reducts_incl (fun x => C'(C x)) res1 res3. *)
+(* Proof. *)
+(*   unfold reducts_incl; intros. auto. *)
+(* Qed. *)
+
+(* Lemma reducts_incl_nil: *)
+(*   forall (A B: Type) (C: A -> B) res, *)
+(*   reducts_incl C nil res. *)
+(* Proof. *)
+(*   intros; red. intros; contradiction. *)
+(* Qed. *)
+
+(* Lemma reducts_incl_val: *)
+(*   forall (A: Type) a m v ty (C: expr -> A) res, *)
+(*   is_val a = Some(v, ty) -> reducts_incl C (step_expr RV a m) res. *)
+(* Proof. *)
+(*   intros. rewrite (is_val_inv _ _ _ H). apply reducts_incl_nil. *)
+(* Qed. *)
+
+(* Lemma reducts_incl_loc: *)
+(*   forall (A: Type) a m b ofs ty (C: expr -> A) res, *)
+(*   is_loc a = Some(b, ofs, ty) -> reducts_incl C (step_expr LV a m) res. *)
+(* Proof. *)
+(*   intros. rewrite (is_loc_inv _ _ _ _ H). apply reducts_incl_nil. *)
+(* Qed. *)
+
+(* Lemma reducts_incl_listval: *)
+(*   forall (A: Type) a m vtl (C: exprlist -> A) res, *)
+(*   is_val_list a = Some vtl -> reducts_incl C (step_exprlist a m) res. *)
+(* Proof. *)
+(*   intros. rewrite step_exprlist_val_list. apply reducts_incl_nil. congruence. *)
+(* Qed. *)
+
+(* Lemma reducts_incl_incontext: *)
+(*   forall (A B: Type) (C: A -> B) res, *)
+(*   reducts_incl C res (incontext C res). *)
+(* Proof. *)
+(*   unfold reducts_incl, incontext. intros. *)
+(*   set (f := fun z : (expr -> A) * reduction => (fun x : expr => C (fst z x), snd z)). *)
+(*   change (In (f (C1, rd)) (map f res)). apply in_map. auto. *)
+(* Qed. *)
+
+(* Lemma reducts_incl_incontext2_left: *)
+(*   forall (A1 A2 B: Type) (C1: A1 -> B) res1 (C2: A2 -> B) res2, *)
+(*   reducts_incl C1 res1 (incontext2 C1 res1 C2 res2). *)
+(* Proof. *)
+(*   unfold reducts_incl, incontext2, incontext. intros. *)
+(*   rewrite in_app_iff. left. *)
+(*   set (f := fun z : (expr -> A1) * reduction => (fun x : expr => C1 (fst z x), snd z)). *)
+(*   change (In (f (C0, rd)) (map f res1)). apply in_map; auto. *)
+(* Qed. *)
+
+(* Lemma reducts_incl_incontext2_right: *)
+(*   forall (A1 A2 B: Type) (C1: A1 -> B) res1 (C2: A2 -> B) res2, *)
+(*   reducts_incl C2 res2 (incontext2 C1 res1 C2 res2). *)
+(* Proof. *)
+(*   unfold reducts_incl, incontext2, incontext. intros. *)
+(*   rewrite in_app_iff. right. *)
+(*   set (f := fun z : (expr -> A2) * reduction => (fun x : expr => C2 (fst z x), snd z)). *)
+(*   change (In (f (C0, rd)) (map f res2)). apply in_map; auto. *)
+(* Qed. *)
+
+(* Lemma step_expr_context: *)
+(*   forall from to C, context from to C -> *)
+(*   forall a m, reducts_incl C (step_expr from a m) (step_expr to (C a) m) *)
+(* with step_exprlist_context: *)
+(*   forall from C, contextlist from C -> *)
+(*   forall a m, reducts_incl C (step_expr from a m) (step_exprlist (C a) m). *)
+(* Proof. *)
+(*   induction 1; simpl; intros. *)
+(* (* top *) *)
+(*   red. destruct (step_expr k a m); auto. *)
+(*   try (* no eta in 8.3 *) *)
+(*    (intros; *)
+(*     replace (fun x => C1 x) with C1 by (apply extensionality; auto); *)
+(*     auto). *)
+(* (* deref *) *)
+(*   eapply reducts_incl_trans with (C' := fun x => Ederef x ty); eauto. *)
+(*   destruct (is_val (C a)) as [[v ty']|] eqn:?; eauto. *)
+(* (* field *) *)
+(*   eapply reducts_incl_trans with (C' := fun x => Efield x f ty); eauto. *)
+(*   destruct (is_val (C a)) as [[v ty']|] eqn:?; eauto. *)
+(* (* valof *) *)
+(*   eapply reducts_incl_trans with (C' := fun x => Evalof x ty); eauto. *)
+(*   destruct (is_loc (C a)) as [[[b ofs] ty']|] eqn:?; eauto. *)
+(* (* addrof *) *)
+(*   eapply reducts_incl_trans with (C' := fun x => Eaddrof x ty); eauto. *)
+(*   destruct (is_loc (C a)) as [[[b ofs] ty']|] eqn:?; eauto. *)
+(* (* unop *) *)
+(*   eapply reducts_incl_trans with (C' := fun x => Eunop op x ty); eauto. *)
+(*   destruct (is_val (C a)) as [[v ty']|] eqn:?; eauto. *)
+(* (* binop left *) *)
+(*   eapply reducts_incl_trans with (C' := fun x => Ebinop op x e2 ty); eauto. *)
+(*   destruct (is_val (C a)) as [[v ty']|] eqn:?; eauto. *)
+(* (* binop right *) *)
+(*   eapply reducts_incl_trans with (C' := fun x => Ebinop op e1 x ty); eauto. *)
+(*   destruct (is_val e1) as [[v1 ty1]|] eqn:?; eauto. *)
+(*   destruct (is_val (C a)) as [[v2 ty2]|] eqn:?; eauto. *)
+(* (* cast *) *)
+(*   eapply reducts_incl_trans with (C' := fun x => Ecast x ty); eauto. *)
+(*   destruct (is_val (C a)) as [[v ty']|] eqn:?; eauto. *)
+(* (* seqand *) *)
+(*   eapply reducts_incl_trans with (C' := fun x => Eseqand x r2 ty); eauto. *)
+(*   destruct (is_val (C a)) as [[v ty']|] eqn:?; eauto. *)
+(* (* seqor *) *)
+(*   eapply reducts_incl_trans with (C' := fun x => Eseqor x r2 ty); eauto. *)
+(*   destruct (is_val (C a)) as [[v ty']|] eqn:?; eauto. *)
+(* (* condition *) *)
+(*   eapply reducts_incl_trans with (C' := fun x => Econdition x r2 r3 ty); eauto. *)
+(*   destruct (is_val (C a)) as [[v ty']|] eqn:?; eauto. *)
+(* (* assign left *) *)
+(*   eapply reducts_incl_trans with (C' := fun x => Eassign x e2 ty); eauto. *)
+(*   destruct (is_loc (C a)) as [[[b ofs] ty']|] eqn:?; eauto. *)
+(* (* assign right *) *)
+(*   eapply reducts_incl_trans with (C' := fun x => Eassign e1 x ty); eauto. *)
+(*   destruct (is_loc e1) as [[[b ofs] ty1]|] eqn:?; eauto. *)
+(*   destruct (is_val (C a)) as [[v2 ty2]|] eqn:?; eauto. *)
+(* (* assignop left *) *)
+(*   eapply reducts_incl_trans with (C' := fun x => Eassignop op x e2 tyres ty); eauto. *)
+(*   destruct (is_loc (C a)) as [[[b ofs] ty']|] eqn:?; eauto. *)
+(* (* assignop right *) *)
+(*   eapply reducts_incl_trans with (C' := fun x => Eassignop op e1 x tyres ty); eauto. *)
+(*   destruct (is_loc e1) as [[[b ofs] ty1]|] eqn:?; eauto. *)
+(*   destruct (is_val (C a)) as [[v2 ty2]|] eqn:?; eauto. *)
+(* (* postincr *) *)
+(*   eapply reducts_incl_trans with (C' := fun x => Epostincr id x ty); eauto. *)
+(*   destruct (is_loc (C a)) as [[[b ofs] ty']|] eqn:?; eauto. *)
+(* (* call left *) *)
+(*   eapply reducts_incl_trans with (C' := fun x => Ecall x el ty); eauto. *)
+(*   destruct (is_val (C a)) as [[v ty']|] eqn:?; eauto. *)
+(* (* call right *) *)
+(*   eapply reducts_incl_trans with (C' := fun x => Ecall e1 x ty). apply step_exprlist_context. auto. *)
+(*   destruct (is_val e1) as [[v1 ty1]|] eqn:?; eauto. *)
+(*   destruct (is_val_list (C a)) as [vl|] eqn:?; eauto. *)
+(* (* builtin *) *)
+(*   eapply reducts_incl_trans with (C' := fun x => Ebuiltin ef tyargs x ty). apply step_exprlist_context. auto. *)
+(*   destruct (is_val_list (C a)) as [vl|] eqn:?; eauto. *)
+(* (* comma *) *)
+(*   eapply reducts_incl_trans with (C' := fun x => Ecomma x e2 ty); eauto. *)
+(*   destruct (is_val (C a)) as [[v ty']|] eqn:?; eauto. *)
+(* (* paren *) *)
+(*   eapply reducts_incl_trans with (C' := fun x => Eparen x tycast ty); eauto. *)
+(*   destruct (is_val (C a)) as [[v ty']|] eqn:?; eauto. *)
+
+(*   induction 1; simpl; intros. *)
+(* (* cons left *) *)
+(*   eapply reducts_incl_trans with (C' := fun x => Econs x el). *)
+(*   apply step_expr_context; eauto. eauto. *)
+(* (* binop right *) *)
+(*   eapply reducts_incl_trans with (C' := fun x => Econs e1 x). *)
+(*   apply step_exprlist_context; eauto. eauto. *)
+(* Qed. *)
+
+(* (** Completeness part 2: if we can reduce to [Stuckstate], [step_expr] *)
+(*     contains at least one [Stuckred] reduction. *) *)
+
+(* Lemma not_stuckred_imm_safe: *)
+(*   forall m a k, *)
+(*   (forall C, ~In (C, Stuckred) (step_expr k a m)) -> imm_safe_t k a m. *)
+(* Proof. *)
+(*   intros. generalize (step_expr_sound a k m). intros [A B]. *)
+(*   destruct (step_expr k a m) as [|[C rd] res] eqn:?. *)
+(*   specialize (B (eq_refl _)). destruct k. *)
+(*   destruct a; simpl in B; try congruence. constructor. *)
+(*   destruct a; simpl in B; try congruence. constructor. *)
+(*   assert (NOTSTUCK: rd <> Stuckred). *)
+(*     red; intros. elim (H C); subst rd; auto with coqlib. *)
+(*   exploit A. eauto with coqlib. intros [a' [k' [P [Q R]]]]. *)
+(*   destruct k'; destruct rd; simpl in R; intuition. *)
+(*   subst a. eapply imm_safe_t_lred; eauto. *)
+(*   subst a. destruct H1 as [w' PT]. eapply imm_safe_t_rred; eauto. *)
+(*   subst. eapply imm_safe_t_callred; eauto. *)
+(* Qed. *)
+
+(* Lemma not_imm_safe_stuck_red: *)
+(*   forall m a k C, *)
+(*   context k RV C -> *)
+(*   ~imm_safe_t k a m -> *)
+(*   exists C', In (C', Stuckred) (step_expr RV (C a) m). *)
+(* Proof. *)
+(*   intros. *)
+(*   assert (exists C', In (C', Stuckred) (step_expr k a m)). *)
+(*     destruct (classic (exists C', In (C', Stuckred) (step_expr k a m))); auto. *)
+(*     elim H0. apply not_stuckred_imm_safe. apply not_ex_all_not. auto. *)
+(*   destruct H1 as [C' IN]. *)
+(*   specialize (step_expr_context _ _ _ H a m). unfold reducts_incl. *)
+(*   intro. *)
+(*   exists (fun x => (C (C' x))). apply H1; auto. *)
+(* Qed. *)
+
+(* (** Connections between [imm_safe_t] and [imm_safe] *) *)
+
+(* Lemma imm_safe_imm_safe_t: *)
+(*   forall k a m, *)
+(*   imm_safe ge e k a m -> *)
+(*   imm_safe_t k a m \/ *)
+(*   exists C, exists a1, exists t, exists a1', exists m', *)
+(*     context RV k C /\ a = C a1 /\ rred ge a1 m t a1' m' /\ forall w', ~possible_trace w t w'. *)
+(* Proof. *)
+(*   intros. inv H. *)
+(*   left. apply imm_safe_t_val. *)
+(*   left. apply imm_safe_t_loc. *)
+(*   left. eapply imm_safe_t_lred; eauto. *)
+(*   destruct (classic (exists w', possible_trace w t w')) as [[w' A] | A]. *)
+(*   left. eapply imm_safe_t_rred; eauto. *)
+(*   right. exists C; exists e0; exists t; exists e'; exists m'; intuition. apply A; exists w'; auto. *)
+(*   left. eapply imm_safe_t_callred; eauto. *)
+(* Qed. *)
 
 (** A state can "crash the world" if it can make an observable transition
   whose trace is not accepted by the external world. *)
@@ -1863,19 +1860,19 @@ Qed.
 Definition can_crash_world (w: world) (S: state) : Prop :=
   exists t, exists S', Csem.step ge S t S' /\ forall w', ~possible_trace w t w'.
 
-Theorem not_imm_safe_t:
-  forall K C a m f k,
-  context K RV C ->
-  ~imm_safe_t K a m ->
-  Csem.step ge (ExprState f (C a) k e m) E0 Stuckstate \/ can_crash_world w (ExprState f (C a) k e m).
-Proof.
-  intros. destruct (classic (imm_safe ge e K a m)).
-  exploit imm_safe_imm_safe_t; eauto.
-  intros [A | [C1 [a1 [t [a1' [m' [A [B [D E]]]]]]]]]. contradiction.
-  right. red. exists t; econstructor; split; auto.
-  left. rewrite B. eapply step_rred with (C := fun x => C(C1 x)). eauto. eauto.
-  left. left. eapply step_stuck; eauto.
-Qed.
+(* Theorem not_imm_safe_t: *)
+(*   forall K C a m f k, *)
+(*   context K RV C -> *)
+(*   ~imm_safe_t K a m -> *)
+(*   Csem.step ge (ExprState f (C a) k e m) E0 Stuckstate \/ can_crash_world w (ExprState f (C a) k e m). *)
+(* Proof. *)
+(*   intros. destruct (classic (imm_safe ge e K a m)). *)
+(*   exploit imm_safe_imm_safe_t; eauto. *)
+(*   intros [A | [C1 [a1 [t [a1' [m' [A [B [D E]]]]]]]]]. contradiction. *)
+(*   right. red. exists t; econstructor; split; auto. *)
+(*   left. rewrite B. eapply step_rred with (C := fun x => C(C1 x)). eauto. eauto. *)
+(*   left. left. eapply step_stuck; eauto. *)
+(* Qed. *)
 
 End EXPRS.
 
@@ -1889,23 +1886,23 @@ Fixpoint do_alloc_variables (e: env) (m: mem) (l: list (ident * type)) {struct l
       do_alloc_variables (PTree.set id (b1, ty) e) m1 l'
 end.
 
-Lemma do_alloc_variables_sound:
-  forall l e m, alloc_variables ge e m l (fst (do_alloc_variables e m l)) (snd (do_alloc_variables e m l)).
-Proof.
-  induction l; intros; simpl.
-  constructor.
-  destruct a as [id ty]. destruct (Mem.alloc m 0 (sizeof ge ty)) as [m1 b1] eqn:?; simpl.
-  econstructor; eauto.
-Qed.
-
-Lemma do_alloc_variables_complete:
-  forall e1 m1 l e2 m2, alloc_variables ge e1 m1 l e2 m2 ->
-  do_alloc_variables e1 m1 l = (e2, m2).
-Proof.
-  induction 1; simpl.
-  auto.
-  rewrite H; rewrite IHalloc_variables; auto.
-Qed.
+(* Lemma do_alloc_variables_sound: *)
+(*   forall l e m, alloc_variables ge e m l (fst (do_alloc_variables e m l)) (snd (do_alloc_variables e m l)). *)
+(* Proof. *)
+(*   induction l; intros; simpl. *)
+(*   constructor. *)
+(*   destruct a as [id ty]. destruct (Mem.alloc m 0 (sizeof ge ty)) as [m1 b1] eqn:?; simpl. *)
+(*   econstructor; eauto. *)
+(* Qed. *)
+
+(* Lemma do_alloc_variables_complete: *)
+(*   forall e1 m1 l e2 m2, alloc_variables ge e1 m1 l e2 m2 -> *)
+(*   do_alloc_variables e1 m1 l = (e2, m2). *)
+(* Proof. *)
+(*   induction 1; simpl. *)
+(*   auto. *)
+(*   rewrite H; rewrite IHalloc_variables; auto. *)
+(* Qed. *)
 
 Function sem_bind_parameters (w: world) (e: env) (m: mem) (l: list (ident * type)) (lv: list val)
                           {struct l} : option mem :=
@@ -1922,25 +1919,25 @@ Function sem_bind_parameters (w: world) (e: env) (m: mem) (l: list (ident * type
    | _, _ => None
 end.
 
-Lemma sem_bind_parameters_sound : forall w e m l lv m',
-  sem_bind_parameters w e m l lv = Some m' ->
-  bind_parameters ge e m l lv m'.
-Proof.
-   intros; functional induction (sem_bind_parameters w e m l lv); try discriminate.
-   inversion H; constructor; auto.
-   exploit do_assign_loc_sound; eauto. intros [A B]. econstructor; eauto.
-Qed.
-
-Lemma sem_bind_parameters_complete : forall w e m l lv m',
-  bind_parameters ge e m l lv m' ->
-  sem_bind_parameters w e m l lv = Some m'.
-Proof.
-   induction 1; simpl; auto.
-   rewrite H. rewrite dec_eq_true.
-   assert (possible_trace w E0 w) by constructor.
-   rewrite (do_assign_loc_complete _ _ _ _ _ _ _ _ _ H0 H2).
-   simpl. auto.
-Qed.
+(* Lemma sem_bind_parameters_sound : forall w e m l lv m', *)
+(*   sem_bind_parameters w e m l lv = Some m' -> *)
+(*   bind_parameters ge e m l lv m'. *)
+(* Proof. *)
+(*    intros; functional induction (sem_bind_parameters w e m l lv); try discriminate. *)
+(*    inversion H; constructor; auto. *)
+(*    exploit do_assign_loc_sound; eauto. intros [A B]. econstructor; eauto. *)
+(* Qed. *)
+
+(* Lemma sem_bind_parameters_complete : forall w e m l lv m', *)
+(*   bind_parameters ge e m l lv m' -> *)
+(*   sem_bind_parameters w e m l lv = Some m'. *)
+(* Proof. *)
+(*    induction 1; simpl; auto. *)
+(*    rewrite H. rewrite dec_eq_true. *)
+(*    assert (possible_trace w E0 w) by constructor. *)
+(*    rewrite (do_assign_loc_complete _ _ _ _ _ _ _ _ _ H0 H2). *)
+(*    simpl. auto. *)
+(* Qed. *)
 
 Inductive transition : Type := TR (rule: string) (t: trace) (S': state).
 
@@ -2077,160 +2074,160 @@ Definition do_step (w: world) (s: state) : list transition :=
   | _ => nil
   end.
 
-Ltac myinv :=
-  match goal with
-  | [ |- In _ nil -> _ ] => let X := fresh "X" in intro X; elim X
-  | [ |- In _ (ret _ _) -> _ ] =>
-        let X := fresh "X" in
-        intro X; elim X; clear X;
-        [let EQ := fresh "EQ" in intro EQ; unfold ret in EQ; inv EQ; myinv | myinv]
-  | [ |- In _ (_ :: nil) -> _ ] =>
-        let X := fresh "X" in
-        intro X; elim X; clear X; [let EQ := fresh "EQ" in intro EQ; inv EQ; myinv | myinv]
-  | [ |- In _ (match ?x with Some _ => _ | None => _ end) -> _ ] => destruct x eqn:?; myinv
-  | [ |- In _ (match ?x with false => _ | true => _ end) -> _ ] => destruct x eqn:?; myinv
-  | [ |- In _ (match ?x with left _ => _ | right _ => _ end) -> _ ] => destruct x; myinv
-  | _ => idtac
-  end.
-
-Local Hint Extern 3 => exact I : core.
-
-Theorem do_step_sound:
-  forall w S rule t S',
-  In (TR rule t S') (do_step w S) ->
-  Csem.step ge S t S' \/ (t = E0 /\ S' = Stuckstate /\ can_crash_world w S).
-Proof with try (left; right; econstructor; eauto; fail).
-  intros until S'. destruct S; simpl.
-(* State *)
-  destruct s; myinv...
-  (* skip *)
-  destruct k; myinv...
-  (* break *)
-  destruct k; myinv...
-  (* continue *)
-  destruct k; myinv...
-  (* goto *)
-  destruct p as [s' k']. myinv...
-(* ExprState *)
-  destruct (is_val r) as [[v ty]|] eqn:?.
-  (* expression is a value *)
-  rewrite (is_val_inv _ _ _ Heqo).
-  destruct k; myinv...
-  (* expression reduces *)
-  intros. exploit list_in_map_inv; eauto. intros [[C rd] [A B]].
-  generalize (step_expr_sound e w r RV m). unfold reducts_ok. intros [P Q].
-  exploit P; eauto. intros [a' [k' [CTX [EQ RD]]]].
-  unfold expr_final_state in A. simpl in A.
-  destruct k'; destruct rd; inv A; simpl in RD; try contradiction.
-  (* lred *)
-  left; left; apply step_lred; auto.
-  (* stuck lred *)
-  exploit not_imm_safe_t; eauto. intros [R | R]; eauto.
-  (* rred *)
-  destruct RD. left; left; apply step_rred; auto.
-  (* callred *)
-  destruct RD; subst m'. left; left; apply step_call; eauto.
-  (* stuck rred *)
-  exploit not_imm_safe_t; eauto. intros [R | R]; eauto.
-(* callstate *)
-  destruct fd; myinv.
-  (* internal *)
-  destruct (do_alloc_variables empty_env m (fn_params f ++ fn_vars f)) as [e m1] eqn:?.
-  myinv. left; right; apply step_internal_function with m1. auto.
-  change e with (fst (e,m1)). change m1 with (snd (e,m1)) at 2. rewrite <- Heqp.
-  apply do_alloc_variables_sound. eapply sem_bind_parameters_sound; eauto.
-  (* external *)
-  destruct p as [[[w' tr] v] m']. myinv. left; right; constructor.
-  eapply do_ef_external_sound; eauto.
-(* returnstate *)
-  destruct k; myinv...
-(* stuckstate *)
-  contradiction.
-Qed.
-
-Remark estep_not_val:
-  forall f a k e m t S, estep ge (ExprState f a k e m) t S -> is_val a = None.
-Proof.
-  intros.
-  assert (forall b from to C, context from to C -> (from = to /\ C = fun x => x) \/ is_val (C b) = None).
-    induction 1; simpl; auto.
-  inv H.
-  destruct (H0 a0 _ _ _ H9) as [[A B] | A]. subst. inv H8; auto. auto.
-  destruct (H0 a0 _ _ _ H9) as [[A B] | A]. subst. inv H8; auto. auto.
-  destruct (H0 a0 _ _ _ H9) as [[A B] | A]. subst. inv H8; auto. auto.
-  destruct (H0 a0 _ _ _ H8) as [[A B] | A]. subst. destruct a0; auto. elim H9. constructor. auto.
-Qed.
-
-Theorem do_step_complete:
-  forall w S t S' w',
-  possible_trace w t w' -> Csem.step ge S t S' -> exists rule, In (TR rule t S') (do_step w S).
-Proof with (unfold ret; eauto with coqlib).
-  intros until w'; intros PT H.
-  destruct H.
-  (* Expression step *)
-  inversion H; subst; exploit estep_not_val; eauto; intro NOTVAL.
-(* lred *)
-  unfold do_step; rewrite NOTVAL.
-  exploit lred_topred; eauto. instantiate (1 := w). intros (rule & STEP).
-  exists rule. change (TR rule E0 (ExprState f (C a') k e m')) with (expr_final_state f k e (C, Lred rule a' m')).
-  apply in_map.
-  generalize (step_expr_context e w _ _ _ H1 a m). unfold reducts_incl.
-  intro. replace C with (fun x => C x). apply H2.
-  rewrite STEP. unfold topred; auto with coqlib.
-  apply extensionality; auto.
-(* rred *)
-  unfold do_step; rewrite NOTVAL.
-  exploit rred_topred; eauto. instantiate (1 := e). intros (rule & STEP).
-  exists rule.
-  change (TR rule t (ExprState f (C a') k e m')) with (expr_final_state f k e (C, Rred rule a' m' t)).
-  apply in_map.
-  generalize (step_expr_context e w _ _ _ H1 a m). unfold reducts_incl.
-  intro. replace C with (fun x => C x). apply H2.
-  rewrite STEP; unfold topred; auto with coqlib.
-  apply extensionality; auto.
-(* callred *)
-  unfold do_step; rewrite NOTVAL.
-  exploit callred_topred; eauto. instantiate (1 := w). instantiate (1 := e).
-  intros (rule & STEP). exists rule.
-  change (TR rule E0 (Callstate fd vargs (Kcall f e C ty k) m)) with (expr_final_state f k e (C, Callred rule fd vargs ty m)).
-  apply in_map.
-  generalize (step_expr_context e w _ _ _ H1 a m). unfold reducts_incl.
-  intro. replace C with (fun x => C x). apply H2.
-  rewrite STEP; unfold topred; auto with coqlib.
-  apply extensionality; auto.
-(* stuck *)
-  exploit not_imm_safe_stuck_red. eauto. red; intros; elim H1. eapply imm_safe_t_imm_safe. eauto.
-  instantiate (1 := w). intros [C' IN].
-  simpl do_step. rewrite NOTVAL.
-  exists "step_stuck".
-  change (TR "step_stuck" E0 Stuckstate) with (expr_final_state f k e (C', Stuckred)).
-  apply in_map. auto.
-
-  (* Statement step *)
-  inv H; simpl; econstructor...
-  rewrite H0...
-  rewrite H0...
-  rewrite H0...
-  destruct H0; subst s0...
-  destruct H0; subst s0...
-  rewrite H0...
-  rewrite H0...
-  rewrite pred_dec_false...
-  rewrite H0...
-  rewrite H0...
-  destruct H0; subst x...
-  rewrite H0...
-  rewrite H0; rewrite H1...
-  rewrite H1. red in H0. destruct k; try contradiction...
-  rewrite H0...
-  destruct H0; subst x...
-  rewrite H0...
-
-  (* Call step *)
-  rewrite pred_dec_true; auto. rewrite (do_alloc_variables_complete _ _ _ _ _ H1).
-  rewrite (sem_bind_parameters_complete _ _ _ _ _ _ H2)...
-  exploit do_ef_external_complete; eauto. intro EQ; rewrite EQ. auto with coqlib.
-Qed.
+(* Ltac myinv := *)
+(*   match goal with *)
+(*   | [ |- In _ nil -> _ ] => let X := fresh "X" in intro X; elim X *)
+(*   | [ |- In _ (ret _ _) -> _ ] => *)
+(*         let X := fresh "X" in *)
+(*         intro X; elim X; clear X; *)
+(*         [let EQ := fresh "EQ" in intro EQ; unfold ret in EQ; inv EQ; myinv | myinv] *)
+(*   | [ |- In _ (_ :: nil) -> _ ] => *)
+(*         let X := fresh "X" in *)
+(*         intro X; elim X; clear X; [let EQ := fresh "EQ" in intro EQ; inv EQ; myinv | myinv] *)
+(*   | [ |- In _ (match ?x with Some _ => _ | None => _ end) -> _ ] => destruct x eqn:?; myinv *)
+(*   | [ |- In _ (match ?x with false => _ | true => _ end) -> _ ] => destruct x eqn:?; myinv *)
+(*   | [ |- In _ (match ?x with left _ => _ | right _ => _ end) -> _ ] => destruct x; myinv *)
+(*   | _ => idtac *)
+(*   end. *)
+
+(* Local Hint Extern 3 => exact I : core. *)
+
+(* Theorem do_step_sound: *)
+(*   forall w S rule t S', *)
+(*   In (TR rule t S') (do_step w S) -> *)
+(*   Csem.step ge S t S' \/ (t = E0 /\ S' = Stuckstate /\ can_crash_world w S). *)
+(* Proof with try (left; right; econstructor; eauto; fail). *)
+(*   intros until S'. destruct S; simpl. *)
+(* (* State *) *)
+(*   destruct s; myinv... *)
+(*   (* skip *) *)
+(*   destruct k; myinv... *)
+(*   (* break *) *)
+(*   destruct k; myinv... *)
+(*   (* continue *) *)
+(*   destruct k; myinv... *)
+(*   (* goto *) *)
+(*   destruct p as [s' k']. myinv... *)
+(* (* ExprState *) *)
+(*   destruct (is_val r) as [[v ty]|] eqn:?. *)
+(*   (* expression is a value *) *)
+(*   rewrite (is_val_inv _ _ _ Heqo). *)
+(*   destruct k; myinv... *)
+(*   (* expression reduces *) *)
+(*   intros. exploit list_in_map_inv; eauto. intros [[C rd] [A B]]. *)
+(*   generalize (step_expr_sound e w r RV m). unfold reducts_ok. intros [P Q]. *)
+(*   exploit P; eauto. intros [a' [k' [CTX [EQ RD]]]]. *)
+(*   unfold expr_final_state in A. simpl in A. *)
+(*   destruct k'; destruct rd; inv A; simpl in RD; try contradiction. *)
+(*   (* lred *) *)
+(*   left; left; apply step_lred; auto. *)
+(*   (* stuck lred *) *)
+(*   exploit not_imm_safe_t; eauto. intros [R | R]; eauto. *)
+(*   (* rred *) *)
+(*   destruct RD. left; left; apply step_rred; auto. *)
+(*   (* callred *) *)
+(*   destruct RD; subst m'. left; left; apply step_call; eauto. *)
+(*   (* stuck rred *) *)
+(*   exploit not_imm_safe_t; eauto. intros [R | R]; eauto. *)
+(* (* callstate *) *)
+(*   destruct fd; myinv. *)
+(*   (* internal *) *)
+(*   destruct (do_alloc_variables empty_env m (fn_params f ++ fn_vars f)) as [e m1] eqn:?. *)
+(*   myinv. left; right; apply step_internal_function with m1. auto. *)
+(*   change e with (fst (e,m1)). change m1 with (snd (e,m1)) at 2. rewrite <- Heqp. *)
+(*   apply do_alloc_variables_sound. eapply sem_bind_parameters_sound; eauto. *)
+(*   (* external *) *)
+(*   destruct p as [[[w' tr] v] m']. myinv. left; right; constructor. *)
+(*   eapply do_ef_external_sound; eauto. *)
+(* (* returnstate *) *)
+(*   destruct k; myinv... *)
+(* (* stuckstate *) *)
+(*   contradiction. *)
+(* Qed. *)
+
+(* Remark estep_not_val: *)
+(*   forall f a k e m t S, estep ge (ExprState f a k e m) t S -> is_val a = None. *)
+(* Proof. *)
+(*   intros. *)
+(*   assert (forall b from to C, context from to C -> (from = to /\ C = fun x => x) \/ is_val (C b) = None). *)
+(*     induction 1; simpl; auto. *)
+(*   inv H. *)
+(*   destruct (H0 a0 _ _ _ H9) as [[A B] | A]. subst. inv H8; auto. auto. *)
+(*   destruct (H0 a0 _ _ _ H9) as [[A B] | A]. subst. inv H8; auto. auto. *)
+(*   destruct (H0 a0 _ _ _ H9) as [[A B] | A]. subst. inv H8; auto. auto. *)
+(*   destruct (H0 a0 _ _ _ H8) as [[A B] | A]. subst. destruct a0; auto. elim H9. constructor. auto. *)
+(* Qed. *)
+
+(* Theorem do_step_complete: *)
+(*   forall w S t S' w', *)
+(*   possible_trace w t w' -> Csem.step ge S t S' -> exists rule, In (TR rule t S') (do_step w S). *)
+(* Proof with (unfold ret; eauto with coqlib). *)
+(*   intros until w'; intros PT H. *)
+(*   destruct H. *)
+(*   (* Expression step *) *)
+(*   inversion H; subst; exploit estep_not_val; eauto; intro NOTVAL. *)
+(* (* lred *) *)
+(*   unfold do_step; rewrite NOTVAL. *)
+(*   exploit lred_topred; eauto. instantiate (1 := w). intros (rule & STEP). *)
+(*   exists rule. change (TR rule E0 (ExprState f (C a') k e m')) with (expr_final_state f k e (C, Lred rule a' m')). *)
+(*   apply in_map. *)
+(*   generalize (step_expr_context e w _ _ _ H1 a m). unfold reducts_incl. *)
+(*   intro. replace C with (fun x => C x). apply H2. *)
+(*   rewrite STEP. unfold topred; auto with coqlib. *)
+(*   apply extensionality; auto. *)
+(* (* rred *) *)
+(*   unfold do_step; rewrite NOTVAL. *)
+(*   exploit rred_topred; eauto. instantiate (1 := e). intros (rule & STEP). *)
+(*   exists rule. *)
+(*   change (TR rule t (ExprState f (C a') k e m')) with (expr_final_state f k e (C, Rred rule a' m' t)). *)
+(*   apply in_map. *)
+(*   generalize (step_expr_context e w _ _ _ H1 a m). unfold reducts_incl. *)
+(*   intro. replace C with (fun x => C x). apply H2. *)
+(*   rewrite STEP; unfold topred; auto with coqlib. *)
+(*   apply extensionality; auto. *)
+(* (* callred *) *)
+(*   unfold do_step; rewrite NOTVAL. *)
+(*   exploit callred_topred; eauto. instantiate (1 := w). instantiate (1 := e). *)
+(*   intros (rule & STEP). exists rule. *)
+(*   change (TR rule E0 (Callstate fd vargs (Kcall f e C ty k) m)) with (expr_final_state f k e (C, Callred rule fd vargs ty m)). *)
+(*   apply in_map. *)
+(*   generalize (step_expr_context e w _ _ _ H1 a m). unfold reducts_incl. *)
+(*   intro. replace C with (fun x => C x). apply H2. *)
+(*   rewrite STEP; unfold topred; auto with coqlib. *)
+(*   apply extensionality; auto. *)
+(* (* stuck *) *)
+(*   exploit not_imm_safe_stuck_red. eauto. red; intros; elim H1. eapply imm_safe_t_imm_safe. eauto. *)
+(*   instantiate (1 := w). intros [C' IN]. *)
+(*   simpl do_step. rewrite NOTVAL. *)
+(*   exists "step_stuck". *)
+(*   change (TR "step_stuck" E0 Stuckstate) with (expr_final_state f k e (C', Stuckred)). *)
+(*   apply in_map. auto. *)
+
+(*   (* Statement step *) *)
+(*   inv H; simpl; econstructor... *)
+(*   rewrite H0... *)
+(*   rewrite H0... *)
+(*   rewrite H0... *)
+(*   destruct H0; subst s0... *)
+(*   destruct H0; subst s0... *)
+(*   rewrite H0... *)
+(*   rewrite H0... *)
+(*   rewrite pred_dec_false... *)
+(*   rewrite H0... *)
+(*   rewrite H0... *)
+(*   destruct H0; subst x... *)
+(*   rewrite H0... *)
+(*   rewrite H0; rewrite H1... *)
+(*   rewrite H1. red in H0. destruct k; try contradiction... *)
+(*   rewrite H0... *)
+(*   destruct H0; subst x... *)
+(*   rewrite H0... *)
+
+(*   (* Call step *) *)
+(*   rewrite pred_dec_true; auto. rewrite (do_alloc_variables_complete _ _ _ _ _ H1). *)
+(*   rewrite (sem_bind_parameters_complete _ _ _ _ _ _ H2)... *)
+(*   exploit do_ef_external_complete; eauto. intro EQ; rewrite EQ. auto with coqlib. *)
+(* Qed. *)
 
 End EXEC.
 
diff --git a/cfrontend/Clight.v b/cfrontend/Clight.v
index 3b21be28..4b7e1914 100644
--- a/cfrontend/Clight.v
+++ b/cfrontend/Clight.v
@@ -31,6 +31,7 @@ Require Import Globalenvs.
 Require Import Smallstep.
 Require Import Ctypes.
 Require Import Cop.
+Require Import Simulation.
 
 (** * Abstract syntax *)
 
@@ -203,17 +204,17 @@ Definition temp_env := PTree.t val.
   memory load is performed.  If the type [ty] indicates an access by
   reference or by copy, the pointer [Vptr b ofs] is returned. *)
 
-Inductive deref_loc (ty: type) (m: mem) (b: block) (ofs: ptrofs) : val -> Prop :=
+Inductive deref_loc (ty: type) (m: mem) (vp: val) : val -> Prop :=
   | deref_loc_value: forall chunk v,
       access_mode ty = By_value chunk ->
-      Mem.loadv chunk m (Vptr b ofs) = Some v ->
-      deref_loc ty m b ofs v
+      Mem.loadv chunk m vp = Some v ->
+      deref_loc ty m vp v
   | deref_loc_reference:
       access_mode ty = By_reference ->
-      deref_loc ty m b ofs (Vptr b ofs)
+      deref_loc ty m vp vp
   | deref_loc_copy:
       access_mode ty = By_copy ->
-      deref_loc ty m b ofs (Vptr b ofs).
+      deref_loc ty m vp vp.
 
 (** Symmetrically, [assign_loc ty m b ofs v m'] returns the
   memory state after storing the value [v] in the datum
@@ -221,13 +222,14 @@ Inductive deref_loc (ty: type) (m: mem) (b: block) (ofs: ptrofs) : val -> Prop :
   This is allowed only if [ty] indicates an access by value or by copy.
   [m'] is the updated memory state. *)
 
-Inductive assign_loc (ce: composite_env) (ty: type) (m: mem) (b: block) (ofs: ptrofs):
+Inductive assign_loc (ce: composite_env) (ty: type) (m: mem) (vp: val):
                                             val -> mem -> Prop :=
   | assign_loc_value: forall v chunk m',
       access_mode ty = By_value chunk ->
-      Mem.storev chunk m (Vptr b ofs) v = Some m' ->
-      assign_loc ce ty m b ofs v m'
-  | assign_loc_copy: forall b' ofs' bytes m',
+      Mem.storev chunk m vp v = Some m' ->
+      assign_loc ce ty m vp v m'
+  | assign_loc_copy: forall b ofs b' ofs' bytes m' vp' (TOPTR1: Mem.to_ptr vp m = Some (Vptr b ofs))
+                                                  (TOPTR2: Mem.to_ptr vp' m = Some (Vptr b' ofs')) (SZ: sizeof ce ty > 0),
       access_mode ty = By_copy ->
       (sizeof ce ty > 0 -> (alignof_blockcopy ce ty | Ptrofs.unsigned ofs')) ->
       (sizeof ce ty > 0 -> (alignof_blockcopy ce ty | Ptrofs.unsigned ofs)) ->
@@ -236,7 +238,11 @@ Inductive assign_loc (ce: composite_env) (ty: type) (m: mem) (b: block) (ofs: pt
               \/ Ptrofs.unsigned ofs + sizeof ce ty <= Ptrofs.unsigned ofs' ->
       Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ce ty) = Some bytes ->
       Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m' ->
-      assign_loc ce ty m b ofs (Vptr b' ofs') m'.
+      assign_loc ce ty m vp vp' m'
+  | assing_loc_copy_zero: forall vp' (SZ: sizeof ce ty = 0),
+      access_mode ty = By_copy ->
+      assign_loc ce ty m vp vp' m
+.
 
 Section SEMANTICS.
 
@@ -275,7 +281,7 @@ Inductive bind_parameters (e: env):
   | bind_parameters_cons:
       forall m id ty params v1 vl b m1 m2,
       PTree.get id e = Some(b, ty) ->
-      assign_loc ge ty m b Ptrofs.zero v1 m1 ->
+      assign_loc ge ty m (Vptr b Ptrofs.zero) v1 m1 ->
       bind_parameters e m1 params vl m2 ->
       bind_parameters e m ((id, ty) :: params) (v1 :: vl) m2.
 
@@ -368,9 +374,9 @@ Inductive eval_expr: expr -> val -> Prop :=
   | eval_Etempvar:  forall id ty v,
       le!id = Some v ->
       eval_expr (Etempvar id ty) v
-  | eval_Eaddrof: forall a ty loc ofs,
-      eval_lvalue a loc ofs ->
-      eval_expr (Eaddrof a ty) (Vptr loc ofs)
+  | eval_Eaddrof: forall a ty v,
+      eval_lvalue a v ->
+      eval_expr (Eaddrof a ty) v
   | eval_Eunop:  forall op a ty v1 v,
       eval_expr a v1 ->
       sem_unary_operation op v1 (typeof a) m = Some v ->
@@ -388,37 +394,43 @@ Inductive eval_expr: expr -> val -> Prop :=
       eval_expr (Esizeof ty1 ty) (Vptrofs (Ptrofs.repr (sizeof ge ty1)))
   | eval_Ealignof: forall ty1 ty,
       eval_expr (Ealignof ty1 ty) (Vptrofs (Ptrofs.repr (alignof ge ty1)))
-  | eval_Elvalue: forall a loc ofs v,
-      eval_lvalue a loc ofs ->
-      deref_loc (typeof a) m loc ofs v ->
+  | eval_Elvalue: forall a v lv,
+      eval_lvalue a lv ->
+      deref_loc (typeof a) m lv v ->
       eval_expr a v
 
 (** [eval_lvalue ge e m a b ofs] defines the evaluation of expression [a]
   in l-value position.  The result is the memory location [b, ofs]
   that contains the value of the expression [a]. *)
 
-with eval_lvalue: expr -> block -> ptrofs -> Prop :=
+with eval_lvalue: expr -> val -> Prop :=
   | eval_Evar_local:   forall id l ty,
       e!id = Some(l, ty) ->
-      eval_lvalue (Evar id ty) l Ptrofs.zero
+      eval_lvalue (Evar id ty) (Vptr l Ptrofs.zero)
   | eval_Evar_global: forall id l ty,
       e!id = None ->
       Genv.find_symbol ge id = Some l ->
-      eval_lvalue (Evar id ty) l Ptrofs.zero
-  | eval_Ederef: forall a ty l ofs,
-      eval_expr a (Vptr l ofs) ->
-      eval_lvalue (Ederef a ty) l ofs
- | eval_Efield_struct:   forall a i ty l ofs id co att delta,
-      eval_expr a (Vptr l ofs) ->
+      eval_lvalue (Evar id ty) (Vptr l Ptrofs.zero)
+  | eval_Ederef: forall a ty v,
+      eval_expr a v ->
+      is_ptr_val v = true ->
+      eval_lvalue (Ederef a ty) v
+ | eval_Efield_struct:   forall a i ty id co att delta v v',
+      eval_expr a v ->
+      is_ptr_val v = true ->
       typeof a = Tstruct id att ->
       ge.(genv_cenv)!id = Some co ->
       field_offset ge i (co_members co) = OK delta ->
-      eval_lvalue (Efield a i ty) l (Ptrofs.add ofs (Ptrofs.repr delta))
- | eval_Efield_union:   forall a i ty l ofs id co att,
-      eval_expr a (Vptr l ofs) ->
+      v' = (if Archi.ptr64
+            then Val.addl v (Vptrofs (Ptrofs.repr delta))
+            else Val.add v (Vptrofs (Ptrofs.repr delta))) ->
+      eval_lvalue (Efield a i ty) v'
+ | eval_Efield_union:   forall a i ty id co att v,
+      eval_expr a v ->
+      is_ptr_val v = true ->
       typeof a = Tunion id att ->
       ge.(genv_cenv)!id = Some co ->
-      eval_lvalue (Efield a i ty) l ofs.
+      eval_lvalue (Efield a i ty) v.
 
 Scheme eval_expr_ind2 := Minimality for eval_expr Sort Prop
   with eval_lvalue_ind2 := Minimality for eval_lvalue Sort Prop.
@@ -547,11 +559,12 @@ Variable function_entry: function -> list val -> mem -> env -> temp_env -> mem -
 
 Inductive step: state -> trace -> state -> Prop :=
 
-  | step_assign:   forall f a1 a2 k e le m loc ofs v2 v m',
-      eval_lvalue e le m a1 loc ofs ->
+  | step_assign:   forall f a1 a2 k e le m lv v2 v m',
+      eval_lvalue e le m a1 lv ->
       eval_expr e le m a2 v2 ->
       sem_cast v2 (typeof a2) (typeof a1) m = Some v ->
-      assign_loc ge (typeof a1) m loc ofs v m' ->
+      (* Mem.to_ptr lv m = Some (Vptr loc ofs) -> *)
+      assign_loc ge (typeof a1) m lv v m' ->
       step (State f (Sassign a1 a2) k e le m)
         E0 (State f Sskip k e le m')
 
@@ -679,12 +692,36 @@ Inductive initial_state (p: program): state -> Prop :=
       type_of_fundef f = Tfunction Tnil type_int32s cc_default ->
       initial_state p (Callstate f nil Kstop m0).
 
+Inductive glob_capture (p: program) : state -> state -> Prop :=
+  | glob_capture_intro
+      f m pbs m'
+      (* (INIT: initial_state p (Callstate nil f nil m)) *)
+      (NONSTATIC: Genv.non_static_glob (Genv.globalenv p) (Genv.genv_public (Genv.globalenv p)) = pbs)
+      (CAPTURE: Genv.capture_init_mem m pbs m') :
+    glob_capture p (Callstate f nil Kstop m) (Callstate f nil Kstop m').
+
 (** A final state is a [Returnstate] with an empty continuation. *)
 
 Inductive final_state: state -> int -> Prop :=
   | final_state_intro: forall r m,
       final_state (Returnstate (Vint r) Kstop m) r.
 
+Definition state_mem (st: state) : mem :=
+  match st with
+  | State _ _ _ _ _ m => m
+  | Callstate _ _ _ m => m
+  | Returnstate _ _ m => m
+  end.
+
+Definition concrete_snapshot (ge: Senv.t) (st: state) (id: ident) : option Z :=
+  if Senv.public_symbol ge id
+  then (match Senv.find_symbol ge id with
+        | Some b => Maps.PTree.get b (state_mem st).(Mem.mem_concrete)
+        | None => None
+        end
+    )
+  else None.
+
 End SEMANTICS.
 
 (** The two semantics for function parameters.  First, parameters as local variables. *)
@@ -712,20 +749,37 @@ Inductive function_entry2 (ge: genv)  (f: function) (vargs: list val) (m: mem) (
 
 Definition step2 (ge: genv) := step ge (function_entry2 ge).
 
+(** Non-determinate state *)
+
+Definition is_external (ge: genv) (s:state) : Prop :=
+  match s with
+  | State f s k e le m =>
+    match s with
+    | Sbuiltin optid ef tyargs al => is_external_ef ef
+    | _ => False
+    end
+  | Callstate f args k m =>
+    match f with
+    | External ef targs tres cconv => is_external_ef ef
+    | _ => False
+    end
+  | _ => False
+  end.
+
 (** Wrapping up these definitions in two small-step semantics. *)
 
 Definition semantics1 (p: program) :=
   let ge := globalenv p in
-  Semantics_gen step1 (initial_state p) final_state ge ge.
+  Semantics_gen step1 (initial_state p) (glob_capture p) (concrete_snapshot (Genv.globalenv p)) final_state is_external ge ge.
 
 Definition semantics2 (p: program) :=
   let ge := globalenv p in
-  Semantics_gen step2 (initial_state p) final_state ge ge.
+  Semantics_gen step2 (initial_state p) (glob_capture p) (concrete_snapshot (Genv.globalenv p)) final_state is_external ge ge.
 
 (** This semantics is receptive to changes in events. *)
 
 Lemma semantics_receptive:
-  forall (p: program), receptive (semantics1 p).
+  forall (p: program)s (INT: ~ is_external (globalenv p) s), receptive_at (semantics1 p) s.
 Proof.
   intros. unfold semantics1.
   set (ge := globalenv p). constructor; simpl; intros.
@@ -741,6 +795,7 @@ Proof.
   exists (Returnstate vres2 k m2). econstructor; eauto.
 (* trace length *)
   red; simpl; intros. inv H; simpl; try lia.
+  ss. 
   eapply external_call_trace_length; eauto.
   eapply external_call_trace_length; eauto.
 Qed.
diff --git a/cfrontend/ClightBigstep.v b/cfrontend/ClightBigstep.v
index 644c4c6c..d2d4bdb3 100644
--- a/cfrontend/ClightBigstep.v
+++ b/cfrontend/ClightBigstep.v
@@ -30,556 +30,556 @@ Require Import Ctypes.
 Require Import Cop.
 Require Import Clight.
 
-Section BIGSTEP.
-
-Variable ge: genv.
-
-(** ** Big-step semantics for terminating statements and functions *)
-
-(** The execution of a statement produces an ``outcome'', indicating
-  how the execution terminated: either normally or prematurely
-  through the execution of a [break], [continue] or [return] statement. *)
-
-Inductive outcome: Type :=
-   | Out_break: outcome                 (**r terminated by [break] *)
-   | Out_continue: outcome              (**r terminated by [continue] *)
-   | Out_normal: outcome                (**r terminated normally *)
-   | Out_return: option (val * type) -> outcome. (**r terminated by [return] *)
-
-Inductive out_normal_or_continue : outcome -> Prop :=
-  | Out_normal_or_continue_N: out_normal_or_continue Out_normal
-  | Out_normal_or_continue_C: out_normal_or_continue Out_continue.
-
-Inductive out_break_or_return : outcome -> outcome -> Prop :=
-  | Out_break_or_return_B: out_break_or_return Out_break Out_normal
-  | Out_break_or_return_R: forall ov,
-      out_break_or_return (Out_return ov) (Out_return ov).
-
-Definition outcome_switch (out: outcome) : outcome :=
-  match out with
-  | Out_break => Out_normal
-  | o => o
-  end.
-
-Definition outcome_result_value (out: outcome) (t: type) (v: val) (m: mem): Prop :=
-  match out, t with
-  | Out_normal, Tvoid => v = Vundef
-  | Out_return None, Tvoid => v = Vundef
-  | Out_return (Some (v',t')), ty => ty <> Tvoid /\ sem_cast v' t' t m = Some v
-  | _, _ => False
-  end.
-
-(** [exec_stmt ge e m1 s t m2 out] describes the execution of
-  the statement [s].  [out] is the outcome for this execution.
-  [m1] is the initial memory state, [m2] the final memory state.
-  [t] is the trace of input/output events performed during this
-  evaluation. *)
-
-Inductive exec_stmt: env -> temp_env -> mem -> statement -> trace -> temp_env -> mem -> outcome -> Prop :=
-  | exec_Sskip:   forall e le m,
-      exec_stmt e le m Sskip
-               E0 le m Out_normal
-  | exec_Sassign:   forall e le m a1 a2 loc ofs v2 v m',
-      eval_lvalue ge e le m a1 loc ofs ->
-      eval_expr ge e le m a2 v2 ->
-      sem_cast v2 (typeof a2) (typeof a1) m = Some v ->
-      assign_loc ge (typeof a1) m loc ofs v m' ->
-      exec_stmt e le m (Sassign a1 a2)
-               E0 le m' Out_normal
-  | exec_Sset:     forall e le m id a v,
-      eval_expr ge e le m a v ->
-      exec_stmt e le m (Sset id a)
-               E0 (PTree.set id v le) m Out_normal
-  | exec_Scall:   forall e le m optid a al tyargs tyres cconv vf vargs f t m' vres,
-      classify_fun (typeof a) = fun_case_f tyargs tyres cconv ->
-      eval_expr ge e le m a vf ->
-      eval_exprlist ge e le m al tyargs vargs ->
-      Genv.find_funct ge vf = Some f ->
-      type_of_fundef f = Tfunction tyargs tyres cconv ->
-      eval_funcall m f vargs t m' vres ->
-      exec_stmt e le m (Scall optid a al)
-                t (set_opttemp optid vres le) m' Out_normal
-  | exec_Sbuiltin:   forall e le m optid ef al tyargs vargs t m' vres,
-      eval_exprlist ge e le m al tyargs vargs ->
-      external_call ef ge vargs m t vres m' ->
-      exec_stmt e le m (Sbuiltin optid ef tyargs al)
-                t (set_opttemp optid vres le) m' Out_normal
-  | exec_Sseq_1:   forall e le m s1 s2 t1 le1 m1 t2 le2 m2 out,
-      exec_stmt e le m s1 t1 le1 m1 Out_normal ->
-      exec_stmt e le1 m1 s2 t2 le2 m2 out ->
-      exec_stmt e le m (Ssequence s1 s2)
-                (t1 ** t2) le2 m2 out
-  | exec_Sseq_2:   forall e le m s1 s2 t1 le1 m1 out,
-      exec_stmt e le m s1 t1 le1 m1 out ->
-      out <> Out_normal ->
-      exec_stmt e le m (Ssequence s1 s2)
-                t1 le1 m1 out
-  | exec_Sifthenelse: forall e le m a s1 s2 v1 b t le' m' out,
-      eval_expr ge e le m a v1 ->
-      bool_val v1 (typeof a) m = Some b ->
-      exec_stmt e le m (if b then s1 else s2) t le' m' out ->
-      exec_stmt e le m (Sifthenelse a s1 s2)
-                t le' m' out
-  | exec_Sreturn_none:   forall e le m,
-      exec_stmt e le m (Sreturn None)
-               E0 le m (Out_return None)
-  | exec_Sreturn_some: forall e le m a v,
-      eval_expr ge e le m a v ->
-      exec_stmt e le m (Sreturn (Some a))
-                E0 le m (Out_return (Some (v, typeof a)))
-  | exec_Sbreak:   forall e le m,
-      exec_stmt e le m Sbreak
-               E0 le m Out_break
-  | exec_Scontinue:   forall e le m,
-      exec_stmt e le m Scontinue
-               E0 le m Out_continue
-  | exec_Sloop_stop1: forall e le m s1 s2 t le' m' out' out,
-      exec_stmt e le m s1 t le' m' out' ->
-      out_break_or_return out' out ->
-      exec_stmt e le m (Sloop s1 s2)
-                t le' m' out
-  | exec_Sloop_stop2: forall e le m s1 s2 t1 le1 m1 out1 t2 le2 m2 out2 out,
-      exec_stmt e le m s1 t1 le1 m1 out1 ->
-      out_normal_or_continue out1 ->
-      exec_stmt e le1 m1 s2 t2 le2 m2 out2 ->
-      out_break_or_return out2 out ->
-      exec_stmt e le m (Sloop s1 s2)
-                (t1**t2) le2 m2 out
-  | exec_Sloop_loop: forall e le m s1 s2 t1 le1 m1 out1 t2 le2 m2 t3 le3 m3 out,
-      exec_stmt e le m s1 t1 le1 m1 out1 ->
-      out_normal_or_continue out1 ->
-      exec_stmt e le1 m1 s2 t2 le2 m2 Out_normal ->
-      exec_stmt e le2 m2 (Sloop s1 s2) t3 le3 m3 out ->
-      exec_stmt e le m (Sloop s1 s2)
-                (t1**t2**t3) le3 m3 out
-  | exec_Sswitch:   forall e le m a t v n sl le1 m1 out,
-      eval_expr ge e le m a v ->
-      sem_switch_arg v (typeof a) = Some n ->
-      exec_stmt e le m (seq_of_labeled_statement (select_switch n sl)) t le1 m1 out ->
-      exec_stmt e le m (Sswitch a sl)
-                t le1 m1 (outcome_switch out)
-
-(** [eval_funcall m1 fd args t m2 res] describes the invocation of
-  function [fd] with arguments [args].  [res] is the value returned
-  by the call.  *)
-
-with eval_funcall: mem -> fundef -> list val -> trace -> mem -> val -> Prop :=
-  | eval_funcall_internal: forall le m f vargs t e m1 m2 m3 out vres m4,
-      alloc_variables ge empty_env m (f.(fn_params) ++ f.(fn_vars)) e m1 ->
-      list_norepet (var_names f.(fn_params) ++ var_names f.(fn_vars)) ->
-      bind_parameters ge e m1 f.(fn_params) vargs m2 ->
-      exec_stmt e (create_undef_temps f.(fn_temps)) m2 f.(fn_body) t le m3 out ->
-      outcome_result_value out f.(fn_return) vres m3 ->
-      Mem.free_list m3 (blocks_of_env ge e) = Some m4 ->
-      eval_funcall m (Internal f) vargs t m4 vres
-  | eval_funcall_external: forall m ef targs tres cconv vargs t vres m',
-      external_call ef ge vargs m t vres m' ->
-      eval_funcall m (External ef targs tres cconv) vargs t m' vres.
-
-Scheme exec_stmt_ind2 := Minimality for exec_stmt Sort Prop
-  with eval_funcall_ind2 := Minimality for eval_funcall Sort Prop.
-Combined Scheme exec_stmt_funcall_ind from exec_stmt_ind2, eval_funcall_ind2.
-
-(** ** Big-step semantics for diverging statements and functions *)
-
-(** Coinductive semantics for divergence.
-  [execinf_stmt ge e m s t] holds if the execution of statement [s]
-  diverges, i.e. loops infinitely.  [t] is the possibly infinite
-  trace of observable events performed during the execution. *)
-
-CoInductive execinf_stmt: env -> temp_env -> mem -> statement -> traceinf -> Prop :=
-  | execinf_Scall:   forall e le m optid a al vf tyargs tyres cconv vargs f t,
-      classify_fun (typeof a) = fun_case_f tyargs tyres cconv ->
-      eval_expr ge e le m a vf ->
-      eval_exprlist ge e le m al tyargs vargs ->
-      Genv.find_funct ge vf = Some f ->
-      type_of_fundef f = Tfunction tyargs tyres cconv ->
-      evalinf_funcall m f vargs t ->
-      execinf_stmt e le m (Scall optid a al) t
-  | execinf_Sseq_1:   forall e le m s1 s2 t,
-      execinf_stmt e le m s1 t ->
-      execinf_stmt e le m (Ssequence s1 s2) t
-  | execinf_Sseq_2:   forall e le m s1 s2 t1 le1 m1 t2,
-      exec_stmt e le m s1 t1 le1 m1 Out_normal ->
-      execinf_stmt e le1 m1 s2 t2 ->
-      execinf_stmt e le m (Ssequence s1 s2) (t1 *** t2)
-  | execinf_Sifthenelse: forall e le m a s1 s2 v1 b t,
-      eval_expr ge e le m a v1 ->
-      bool_val v1 (typeof a) m = Some b ->
-      execinf_stmt e le m (if b then s1 else s2) t ->
-      execinf_stmt e le m (Sifthenelse a s1 s2) t
-  | execinf_Sloop_body1: forall e le m s1 s2 t,
-      execinf_stmt e le m s1 t ->
-      execinf_stmt e le m (Sloop s1 s2) t
-  | execinf_Sloop_body2: forall e le m s1 s2 t1 le1 m1 out1 t2,
-      exec_stmt e le m s1 t1 le1 m1 out1 ->
-      out_normal_or_continue out1 ->
-      execinf_stmt e le1 m1 s2 t2 ->
-      execinf_stmt e le m (Sloop s1 s2) (t1***t2)
-  | execinf_Sloop_loop: forall e le m s1 s2 t1 le1 m1 out1 t2 le2 m2 t3,
-      exec_stmt e le m s1 t1 le1 m1 out1 ->
-      out_normal_or_continue out1 ->
-      exec_stmt e le1 m1 s2 t2 le2 m2 Out_normal ->
-      execinf_stmt e le2 m2 (Sloop s1 s2) t3 ->
-      execinf_stmt e le m (Sloop s1 s2) (t1***t2***t3)
-  | execinf_Sswitch:   forall e le m a t v n sl,
-      eval_expr ge e le m a v ->
-      sem_switch_arg v (typeof a) = Some n ->
-      execinf_stmt e le m (seq_of_labeled_statement (select_switch n sl)) t ->
-      execinf_stmt e le m (Sswitch a sl) t
-
-(** [evalinf_funcall ge m fd args t] holds if the invocation of function
-    [fd] on arguments [args] diverges, with observable trace [t]. *)
-
-with evalinf_funcall: mem -> fundef -> list val -> traceinf -> Prop :=
-  | evalinf_funcall_internal: forall m f vargs t e m1 m2,
-      alloc_variables ge empty_env m (f.(fn_params) ++ f.(fn_vars)) e m1 ->
-      list_norepet (var_names f.(fn_params) ++ var_names f.(fn_vars)) ->
-      bind_parameters ge e m1 f.(fn_params) vargs m2 ->
-      execinf_stmt e (create_undef_temps f.(fn_temps)) m2 f.(fn_body) t ->
-      evalinf_funcall m (Internal f) vargs t.
-
-End BIGSTEP.
-
-(** Big-step execution of a whole program.  *)
-
-Inductive bigstep_program_terminates (p: program): trace -> int -> Prop :=
-  | bigstep_program_terminates_intro: forall b f m0 m1 t r,
-      let ge := globalenv p in
-      Genv.init_mem p = Some m0 ->
-      Genv.find_symbol ge p.(prog_main) = Some b ->
-      Genv.find_funct_ptr ge b = Some f ->
-      type_of_fundef f = Tfunction Tnil type_int32s cc_default ->
-      eval_funcall ge m0 f nil t m1 (Vint r) ->
-      bigstep_program_terminates p t r.
-
-Inductive bigstep_program_diverges (p: program): traceinf -> Prop :=
-  | bigstep_program_diverges_intro: forall b f m0 t,
-      let ge := globalenv p in
-      Genv.init_mem p = Some m0 ->
-      Genv.find_symbol ge p.(prog_main) = Some b ->
-      Genv.find_funct_ptr ge b = Some f ->
-      type_of_fundef f = Tfunction Tnil type_int32s cc_default ->
-      evalinf_funcall ge m0 f nil t ->
-      bigstep_program_diverges p t.
-
-Definition bigstep_semantics (p: program) :=
-  Bigstep_semantics (bigstep_program_terminates p) (bigstep_program_diverges p).
-
-(** * Implication from big-step semantics to transition semantics *)
-
-Section BIGSTEP_TO_TRANSITIONS.
-
-Variable prog: program.
-Let ge : genv := globalenv prog.
-
-Inductive outcome_state_match
-       (e: env) (le: temp_env) (m: mem) (f: function) (k: cont): outcome -> state -> Prop :=
-  | osm_normal:
-      outcome_state_match e le m f k Out_normal (State f Sskip k e le m)
-  | osm_break:
-      outcome_state_match e le m f k Out_break (State f Sbreak k e le m)
-  | osm_continue:
-      outcome_state_match e le m f k Out_continue (State f Scontinue k e le m)
-  | osm_return_none: forall k',
-      call_cont k' = call_cont k ->
-      outcome_state_match e le m f k
-        (Out_return None) (State f (Sreturn None) k' e le m)
-  | osm_return_some: forall a v k',
-      call_cont k' = call_cont k ->
-      eval_expr ge e le m a v ->
-      outcome_state_match e le m f k
-        (Out_return (Some (v,typeof a))) (State f (Sreturn (Some a)) k' e le m).
-
-Lemma is_call_cont_call_cont:
-  forall k, is_call_cont k -> call_cont k = k.
-Proof.
-  destruct k; simpl; intros; contradiction || auto.
-Qed.
-
-Lemma exec_stmt_eval_funcall_steps:
-  (forall e le m s t le' m' out,
-   exec_stmt ge e le m s t le' m' out ->
-   forall f k, exists S,
-   star step1 ge (State f s k e le m) t S
-   /\ outcome_state_match e le' m' f k out S)
-/\
-  (forall m fd args t m' res,
-   eval_funcall ge m fd args t m' res ->
-   forall k,
-   is_call_cont k ->
-   star step1 ge (Callstate fd args k m) t (Returnstate res k m')).
-Proof.
-  apply exec_stmt_funcall_ind; intros.
-
-(* skip *)
-  econstructor; split. apply star_refl. constructor.
-
-(* assign *)
-  econstructor; split. apply star_one. econstructor; eauto. constructor.
-
-(* set *)
-  econstructor; split. apply star_one. econstructor; eauto. constructor.
-
-(* call *)
-  econstructor; split.
-  eapply star_left. econstructor; eauto.
-  eapply star_right. apply H5. simpl; auto. econstructor. reflexivity. traceEq.
-  constructor.
-
-(* builtin *)
-  econstructor; split. apply star_one. econstructor; eauto. constructor.
-
-(* sequence 2 *)
-  destruct (H0 f (Kseq s2 k)) as [S1 [A1 B1]]. inv B1.
-  destruct (H2 f k) as [S2 [A2 B2]].
-  econstructor; split.
-  eapply star_left. econstructor.
-  eapply star_trans. eexact A1.
-  eapply star_left. constructor. eexact A2.
-  reflexivity. reflexivity. traceEq.
-  auto.
-
-(* sequence 1 *)
-  destruct (H0 f (Kseq s2 k)) as [S1 [A1 B1]].
-  set (S2 :=
-    match out with
-    | Out_break => State f Sbreak k e le1 m1
-    | Out_continue => State f Scontinue k e le1 m1
-    | _ => S1
-    end).
-  exists S2; split.
-  eapply star_left. econstructor.
-  eapply star_trans. eexact A1.
-  unfold S2; inv B1.
-    congruence.
-    apply star_one. apply step_break_seq.
-    apply star_one. apply step_continue_seq.
-    apply star_refl.
-    apply star_refl.
-  reflexivity. traceEq.
-  unfold S2; inv B1; congruence || econstructor; eauto.
-
-(* ifthenelse *)
-  destruct (H2 f k) as [S1 [A1 B1]].
-  exists S1; split.
-  eapply star_left. 2: eexact A1. eapply step_ifthenelse; eauto. traceEq.
-  auto.
-
-(* return none *)
-  econstructor; split. apply star_refl. constructor. auto.
-
-(* return some *)
-  econstructor; split. apply star_refl. econstructor; eauto.
-
-(* break *)
-  econstructor; split. apply star_refl. constructor.
-
-(* continue *)
-  econstructor; split. apply star_refl. constructor.
-
-(* loop stop 1 *)
-  destruct (H0 f (Kloop1 s1 s2 k)) as [S1 [A1 B1]].
-  set (S2 :=
-    match out' with
-    | Out_break => State f Sskip k e le' m'
-    | _ => S1
-    end).
-  exists S2; split.
-  eapply star_left. eapply step_loop.
-  eapply star_trans. eexact A1.
-  unfold S2. inversion H1; subst.
-  inv B1. apply star_one. constructor.
-  apply star_refl.
-  reflexivity. traceEq.
-  unfold S2. inversion H1; subst. constructor. inv B1; econstructor; eauto.
-
-(* loop stop 2 *)
-  destruct (H0 f (Kloop1 s1 s2 k)) as [S1 [A1 B1]].
-  destruct (H3 f (Kloop2 s1 s2 k)) as [S2 [A2 B2]].
-  set (S3 :=
-    match out2 with
-    | Out_break => State f Sskip k e le2 m2
-    | _ => S2
-    end).
-  exists S3; split.
-  eapply star_left. eapply step_loop.
-  eapply star_trans. eexact A1.
-  eapply star_left with (s2 := State f s2 (Kloop2 s1 s2 k) e le1 m1).
-  inv H1; inv B1; constructor; auto.
-  eapply star_trans. eexact A2.
-  unfold S3. inversion H4; subst.
-  inv B2. apply star_one. constructor. apply star_refl.
-  reflexivity. reflexivity. reflexivity. traceEq.
-  unfold S3. inversion H4; subst. constructor. inv B2; econstructor; eauto.
-
-(* loop loop *)
-  destruct (H0 f (Kloop1 s1 s2 k)) as [S1 [A1 B1]].
-  destruct (H3 f (Kloop2 s1 s2 k)) as [S2 [A2 B2]].
-  destruct (H5 f k) as [S3 [A3 B3]].
-  exists S3; split.
-  eapply star_left. eapply step_loop.
-  eapply star_trans. eexact A1.
-  eapply star_left with (s2 := State f s2 (Kloop2 s1 s2 k) e le1 m1).
-  inv H1; inv B1; constructor; auto.
-  eapply star_trans. eexact A2.
-  eapply star_left with (s2 := State f (Sloop s1 s2) k e le2 m2).
-  inversion H4; subst; inv B2; constructor; auto.
-  eexact A3.
-  reflexivity. reflexivity. reflexivity. reflexivity. traceEq.
-  auto.
-
-(* switch *)
-  destruct (H2 f (Kswitch k)) as [S1 [A1 B1]].
-  set (S2 :=
-    match out with
-    | Out_normal => State f Sskip k e le1 m1
-    | Out_break => State f Sskip k e le1 m1
-    | Out_continue => State f Scontinue k e le1 m1
-    | _ => S1
-    end).
-  exists S2; split.
-  eapply star_left. eapply step_switch; eauto.
-  eapply star_trans. eexact A1.
-  unfold S2; inv B1.
-    apply star_one. constructor. auto.
-    apply star_one. constructor. auto.
-    apply star_one. constructor.
-    apply star_refl.
-    apply star_refl.
-  reflexivity. traceEq.
-  unfold S2. inv B1; simpl; econstructor; eauto.
-
-(* call internal *)
-  destruct (H3 f k) as [S1 [A1 B1]].
-  eapply star_left. eapply step_internal_function; eauto. econstructor; eauto.
-  eapply star_right. eexact A1.
-   inv B1; simpl in H4; try contradiction.
-  (* Out_normal *)
-  assert (fn_return f = Tvoid /\ vres = Vundef).
-    destruct (fn_return f); auto || contradiction.
-  destruct H7. subst vres. apply step_skip_call; auto.
-  (* Out_return None *)
-  assert (fn_return f = Tvoid /\ vres = Vundef).
-    destruct (fn_return f); auto || contradiction.
-  destruct H8. subst vres.
-  rewrite <- (is_call_cont_call_cont k H6). rewrite <- H7.
-  apply step_return_0; auto.
-  (* Out_return Some *)
-  destruct H4.
-  rewrite <- (is_call_cont_call_cont k H6). rewrite <- H7.
-  eapply step_return_1; eauto.
-  reflexivity. traceEq.
-
-(* call external *)
-  apply star_one. apply step_external_function; auto.
-Qed.
-
-Lemma exec_stmt_steps:
-   forall e le m s t le' m' out,
-   exec_stmt ge e le m s t le' m' out ->
-   forall f k, exists S,
-   star step1 ge (State f s k e le m) t S
-   /\ outcome_state_match e le' m' f k out S.
-Proof (proj1 exec_stmt_eval_funcall_steps).
-
-Lemma eval_funcall_steps:
-   forall m fd args t m' res,
-   eval_funcall ge m fd args t m' res ->
-   forall k,
-   is_call_cont k ->
-   star step1 ge (Callstate fd args k m) t (Returnstate res k m').
-Proof (proj2 exec_stmt_eval_funcall_steps).
-
-Definition order (x y: unit) := False.
-
-Lemma evalinf_funcall_forever:
-  forall m fd args T k,
-  evalinf_funcall ge m fd args T ->
-  forever_N step1 order ge tt (Callstate fd args k m) T.
-Proof.
-  cofix CIH_FUN.
-  assert (forall e le m s T f k,
-          execinf_stmt ge e le m s T ->
-          forever_N step1 order ge tt (State f s k e le m) T).
-  cofix CIH_STMT.
-  intros. inv H.
-
-(* call  *)
-  eapply forever_N_plus.
-  apply plus_one. eapply step_call; eauto.
-  eapply CIH_FUN. eauto. traceEq.
-
-(* seq 1 *)
-  eapply forever_N_plus.
-  apply plus_one. econstructor.
-  apply CIH_STMT; eauto. traceEq.
-(* seq 2 *)
-  destruct (exec_stmt_steps _ _ _ _ _ _ _ _ H0 f (Kseq s2 k)) as [S1 [A1 B1]].
-  inv B1.
-  eapply forever_N_plus.
-  eapply plus_left. constructor. eapply star_trans. eexact A1.
-  apply star_one. constructor. reflexivity. reflexivity.
-  apply CIH_STMT; eauto. traceEq.
-
-(* ifthenelse *)
-  eapply forever_N_plus.
-  apply plus_one. eapply step_ifthenelse with (b := b); eauto.
-  apply CIH_STMT; eauto. traceEq.
-
-(* loop body 1 *)
-  eapply forever_N_plus.
-  eapply plus_one. constructor.
-  apply CIH_STMT; eauto. traceEq.
-(* loop body 2 *)
-  destruct (exec_stmt_steps _ _ _ _ _ _ _ _ H0 f (Kloop1 s1 s2 k)) as [S1 [A1 B1]].
-  eapply forever_N_plus with (s2 := State f s2 (Kloop2 s1 s2 k) e le1 m1).
-  eapply plus_left. constructor.
-  eapply star_right. eexact A1.
-  inv H1; inv B1; constructor; auto.
-  reflexivity. reflexivity.
-  apply CIH_STMT; eauto. traceEq.
-(* loop loop *)
-  destruct (exec_stmt_steps _ _ _ _ _ _ _ _ H0 f (Kloop1 s1 s2 k)) as [S1 [A1 B1]].
-  destruct (exec_stmt_steps _ _ _ _ _ _ _ _ H2 f (Kloop2 s1 s2 k)) as [S2 [A2 B2]].
-  eapply forever_N_plus with (s2 := State f (Sloop s1 s2) k e le2 m2).
-  eapply plus_left. constructor.
-  eapply star_trans. eexact A1.
-  eapply star_left. inv H1; inv B1; constructor; auto.
-  eapply star_right. eexact A2.
-  inv B2. constructor.
-  reflexivity. reflexivity. reflexivity. reflexivity.
-  apply CIH_STMT; eauto. traceEq.
-
-(* switch *)
-  eapply forever_N_plus.
-  eapply plus_one. eapply step_switch; eauto.
-  apply CIH_STMT; eauto.
-  traceEq.
-
-(* call internal *)
-  intros. inv H0.
-  eapply forever_N_plus.
-  eapply plus_one. econstructor; eauto. econstructor; eauto.
-  apply H; eauto.
-  traceEq.
-Qed.
-
-Theorem bigstep_semantics_sound:
-  bigstep_sound (bigstep_semantics prog) (semantics1 prog).
-Proof.
-  constructor; simpl; intros.
-(* termination *)
-  inv H. econstructor; econstructor.
-  split. econstructor; eauto.
-  split. eapply eval_funcall_steps. eauto. red; auto.
-  econstructor.
-(* divergence *)
-  inv H. econstructor.
-  split. econstructor; eauto.
-  eapply forever_N_forever with (order := order).
-  red; intros. constructor; intros. red in H. elim H.
-  eapply evalinf_funcall_forever; eauto.
-Qed.
-
-End BIGSTEP_TO_TRANSITIONS.
+(* Section BIGSTEP. *)
+
+(* Variable ge: genv. *)
+
+(* (** ** Big-step semantics for terminating statements and functions *) *)
+
+(* (** The execution of a statement produces an ``outcome'', indicating *)
+(*   how the execution terminated: either normally or prematurely *)
+(*   through the execution of a [break], [continue] or [return] statement. *) *)
+
+(* Inductive outcome: Type := *)
+(*    | Out_break: outcome                 (**r terminated by [break] *) *)
+(*    | Out_continue: outcome              (**r terminated by [continue] *) *)
+(*    | Out_normal: outcome                (**r terminated normally *) *)
+(*    | Out_return: option (val * type) -> outcome. (**r terminated by [return] *) *)
+
+(* Inductive out_normal_or_continue : outcome -> Prop := *)
+(*   | Out_normal_or_continue_N: out_normal_or_continue Out_normal *)
+(*   | Out_normal_or_continue_C: out_normal_or_continue Out_continue. *)
+
+(* Inductive out_break_or_return : outcome -> outcome -> Prop := *)
+(*   | Out_break_or_return_B: out_break_or_return Out_break Out_normal *)
+(*   | Out_break_or_return_R: forall ov, *)
+(*       out_break_or_return (Out_return ov) (Out_return ov). *)
+
+(* Definition outcome_switch (out: outcome) : outcome := *)
+(*   match out with *)
+(*   | Out_break => Out_normal *)
+(*   | o => o *)
+(*   end. *)
+
+(* Definition outcome_result_value (out: outcome) (t: type) (v: val) (m: mem): Prop := *)
+(*   match out, t with *)
+(*   | Out_normal, Tvoid => v = Vundef *)
+(*   | Out_return None, Tvoid => v = Vundef *)
+(*   | Out_return (Some (v',t')), ty => ty <> Tvoid /\ sem_cast v' t' t m = Some v *)
+(*   | _, _ => False *)
+(*   end. *)
+
+(* (** [exec_stmt ge e m1 s t m2 out] describes the execution of *)
+(*   the statement [s].  [out] is the outcome for this execution. *)
+(*   [m1] is the initial memory state, [m2] the final memory state. *)
+(*   [t] is the trace of input/output events performed during this *)
+(*   evaluation. *) *)
+
+(* Inductive exec_stmt: env -> temp_env -> mem -> statement -> trace -> temp_env -> mem -> outcome -> Prop := *)
+(*   | exec_Sskip:   forall e le m, *)
+(*       exec_stmt e le m Sskip *)
+(*                E0 le m Out_normal *)
+(*   | exec_Sassign:   forall e le m a1 a2 loc ofs v2 v m', *)
+(*       eval_lvalue ge e le m a1 loc ofs -> *)
+(*       eval_expr ge e le m a2 v2 -> *)
+(*       sem_cast v2 (typeof a2) (typeof a1) m = Some v -> *)
+(*       assign_loc ge (typeof a1) m loc ofs v m' -> *)
+(*       exec_stmt e le m (Sassign a1 a2) *)
+(*                E0 le m' Out_normal *)
+(*   | exec_Sset:     forall e le m id a v, *)
+(*       eval_expr ge e le m a v -> *)
+(*       exec_stmt e le m (Sset id a) *)
+(*                E0 (PTree.set id v le) m Out_normal *)
+(*   | exec_Scall:   forall e le m optid a al tyargs tyres cconv vf vargs f t m' vres, *)
+(*       classify_fun (typeof a) = fun_case_f tyargs tyres cconv -> *)
+(*       eval_expr ge e le m a vf -> *)
+(*       eval_exprlist ge e le m al tyargs vargs -> *)
+(*       Genv.find_funct ge vf = Some f -> *)
+(*       type_of_fundef f = Tfunction tyargs tyres cconv -> *)
+(*       eval_funcall m f vargs t m' vres -> *)
+(*       exec_stmt e le m (Scall optid a al) *)
+(*                 t (set_opttemp optid vres le) m' Out_normal *)
+(*   | exec_Sbuiltin:   forall e le m optid ef al tyargs vargs t m' vres, *)
+(*       eval_exprlist ge e le m al tyargs vargs -> *)
+(*       external_call ef ge vargs m t vres m' -> *)
+(*       exec_stmt e le m (Sbuiltin optid ef tyargs al) *)
+(*                 t (set_opttemp optid vres le) m' Out_normal *)
+(*   | exec_Sseq_1:   forall e le m s1 s2 t1 le1 m1 t2 le2 m2 out, *)
+(*       exec_stmt e le m s1 t1 le1 m1 Out_normal -> *)
+(*       exec_stmt e le1 m1 s2 t2 le2 m2 out -> *)
+(*       exec_stmt e le m (Ssequence s1 s2) *)
+(*                 (t1 ** t2) le2 m2 out *)
+(*   | exec_Sseq_2:   forall e le m s1 s2 t1 le1 m1 out, *)
+(*       exec_stmt e le m s1 t1 le1 m1 out -> *)
+(*       out <> Out_normal -> *)
+(*       exec_stmt e le m (Ssequence s1 s2) *)
+(*                 t1 le1 m1 out *)
+(*   | exec_Sifthenelse: forall e le m a s1 s2 v1 b t le' m' out, *)
+(*       eval_expr ge e le m a v1 -> *)
+(*       bool_val v1 (typeof a) m = Some b -> *)
+(*       exec_stmt e le m (if b then s1 else s2) t le' m' out -> *)
+(*       exec_stmt e le m (Sifthenelse a s1 s2) *)
+(*                 t le' m' out *)
+(*   | exec_Sreturn_none:   forall e le m, *)
+(*       exec_stmt e le m (Sreturn None) *)
+(*                E0 le m (Out_return None) *)
+(*   | exec_Sreturn_some: forall e le m a v, *)
+(*       eval_expr ge e le m a v -> *)
+(*       exec_stmt e le m (Sreturn (Some a)) *)
+(*                 E0 le m (Out_return (Some (v, typeof a))) *)
+(*   | exec_Sbreak:   forall e le m, *)
+(*       exec_stmt e le m Sbreak *)
+(*                E0 le m Out_break *)
+(*   | exec_Scontinue:   forall e le m, *)
+(*       exec_stmt e le m Scontinue *)
+(*                E0 le m Out_continue *)
+(*   | exec_Sloop_stop1: forall e le m s1 s2 t le' m' out' out, *)
+(*       exec_stmt e le m s1 t le' m' out' -> *)
+(*       out_break_or_return out' out -> *)
+(*       exec_stmt e le m (Sloop s1 s2) *)
+(*                 t le' m' out *)
+(*   | exec_Sloop_stop2: forall e le m s1 s2 t1 le1 m1 out1 t2 le2 m2 out2 out, *)
+(*       exec_stmt e le m s1 t1 le1 m1 out1 -> *)
+(*       out_normal_or_continue out1 -> *)
+(*       exec_stmt e le1 m1 s2 t2 le2 m2 out2 -> *)
+(*       out_break_or_return out2 out -> *)
+(*       exec_stmt e le m (Sloop s1 s2) *)
+(*                 (t1**t2) le2 m2 out *)
+(*   | exec_Sloop_loop: forall e le m s1 s2 t1 le1 m1 out1 t2 le2 m2 t3 le3 m3 out, *)
+(*       exec_stmt e le m s1 t1 le1 m1 out1 -> *)
+(*       out_normal_or_continue out1 -> *)
+(*       exec_stmt e le1 m1 s2 t2 le2 m2 Out_normal -> *)
+(*       exec_stmt e le2 m2 (Sloop s1 s2) t3 le3 m3 out -> *)
+(*       exec_stmt e le m (Sloop s1 s2) *)
+(*                 (t1**t2**t3) le3 m3 out *)
+(*   | exec_Sswitch:   forall e le m a t v n sl le1 m1 out, *)
+(*       eval_expr ge e le m a v -> *)
+(*       sem_switch_arg v (typeof a) = Some n -> *)
+(*       exec_stmt e le m (seq_of_labeled_statement (select_switch n sl)) t le1 m1 out -> *)
+(*       exec_stmt e le m (Sswitch a sl) *)
+(*                 t le1 m1 (outcome_switch out) *)
+
+(* (** [eval_funcall m1 fd args t m2 res] describes the invocation of *)
+(*   function [fd] with arguments [args].  [res] is the value returned *)
+(*   by the call.  *) *)
+
+(* with eval_funcall: mem -> fundef -> list val -> trace -> mem -> val -> Prop := *)
+(*   | eval_funcall_internal: forall le m f vargs t e m1 m2 m3 out vres m4, *)
+(*       alloc_variables ge empty_env m (f.(fn_params) ++ f.(fn_vars)) e m1 -> *)
+(*       list_norepet (var_names f.(fn_params) ++ var_names f.(fn_vars)) -> *)
+(*       bind_parameters ge e m1 f.(fn_params) vargs m2 -> *)
+(*       exec_stmt e (create_undef_temps f.(fn_temps)) m2 f.(fn_body) t le m3 out -> *)
+(*       outcome_result_value out f.(fn_return) vres m3 -> *)
+(*       Mem.free_list m3 (blocks_of_env ge e) = Some m4 -> *)
+(*       eval_funcall m (Internal f) vargs t m4 vres *)
+(*   | eval_funcall_external: forall m ef targs tres cconv vargs t vres m', *)
+(*       external_call ef ge vargs m t vres m' -> *)
+(*       eval_funcall m (External ef targs tres cconv) vargs t m' vres. *)
+
+(* Scheme exec_stmt_ind2 := Minimality for exec_stmt Sort Prop *)
+(*   with eval_funcall_ind2 := Minimality for eval_funcall Sort Prop. *)
+(* Combined Scheme exec_stmt_funcall_ind from exec_stmt_ind2, eval_funcall_ind2. *)
+
+(* (** ** Big-step semantics for diverging statements and functions *) *)
+
+(* (** Coinductive semantics for divergence. *)
+(*   [execinf_stmt ge e m s t] holds if the execution of statement [s] *)
+(*   diverges, i.e. loops infinitely.  [t] is the possibly infinite *)
+(*   trace of observable events performed during the execution. *) *)
+
+(* CoInductive execinf_stmt: env -> temp_env -> mem -> statement -> traceinf -> Prop := *)
+(*   | execinf_Scall:   forall e le m optid a al vf tyargs tyres cconv vargs f t, *)
+(*       classify_fun (typeof a) = fun_case_f tyargs tyres cconv -> *)
+(*       eval_expr ge e le m a vf -> *)
+(*       eval_exprlist ge e le m al tyargs vargs -> *)
+(*       Genv.find_funct ge vf = Some f -> *)
+(*       type_of_fundef f = Tfunction tyargs tyres cconv -> *)
+(*       evalinf_funcall m f vargs t -> *)
+(*       execinf_stmt e le m (Scall optid a al) t *)
+(*   | execinf_Sseq_1:   forall e le m s1 s2 t, *)
+(*       execinf_stmt e le m s1 t -> *)
+(*       execinf_stmt e le m (Ssequence s1 s2) t *)
+(*   | execinf_Sseq_2:   forall e le m s1 s2 t1 le1 m1 t2, *)
+(*       exec_stmt e le m s1 t1 le1 m1 Out_normal -> *)
+(*       execinf_stmt e le1 m1 s2 t2 -> *)
+(*       execinf_stmt e le m (Ssequence s1 s2) (t1 *** t2) *)
+(*   | execinf_Sifthenelse: forall e le m a s1 s2 v1 b t, *)
+(*       eval_expr ge e le m a v1 -> *)
+(*       bool_val v1 (typeof a) m = Some b -> *)
+(*       execinf_stmt e le m (if b then s1 else s2) t -> *)
+(*       execinf_stmt e le m (Sifthenelse a s1 s2) t *)
+(*   | execinf_Sloop_body1: forall e le m s1 s2 t, *)
+(*       execinf_stmt e le m s1 t -> *)
+(*       execinf_stmt e le m (Sloop s1 s2) t *)
+(*   | execinf_Sloop_body2: forall e le m s1 s2 t1 le1 m1 out1 t2, *)
+(*       exec_stmt e le m s1 t1 le1 m1 out1 -> *)
+(*       out_normal_or_continue out1 -> *)
+(*       execinf_stmt e le1 m1 s2 t2 -> *)
+(*       execinf_stmt e le m (Sloop s1 s2) (t1***t2) *)
+(*   | execinf_Sloop_loop: forall e le m s1 s2 t1 le1 m1 out1 t2 le2 m2 t3, *)
+(*       exec_stmt e le m s1 t1 le1 m1 out1 -> *)
+(*       out_normal_or_continue out1 -> *)
+(*       exec_stmt e le1 m1 s2 t2 le2 m2 Out_normal -> *)
+(*       execinf_stmt e le2 m2 (Sloop s1 s2) t3 -> *)
+(*       execinf_stmt e le m (Sloop s1 s2) (t1***t2***t3) *)
+(*   | execinf_Sswitch:   forall e le m a t v n sl, *)
+(*       eval_expr ge e le m a v -> *)
+(*       sem_switch_arg v (typeof a) = Some n -> *)
+(*       execinf_stmt e le m (seq_of_labeled_statement (select_switch n sl)) t -> *)
+(*       execinf_stmt e le m (Sswitch a sl) t *)
+
+(* (** [evalinf_funcall ge m fd args t] holds if the invocation of function *)
+(*     [fd] on arguments [args] diverges, with observable trace [t]. *) *)
+
+(* with evalinf_funcall: mem -> fundef -> list val -> traceinf -> Prop := *)
+(*   | evalinf_funcall_internal: forall m f vargs t e m1 m2, *)
+(*       alloc_variables ge empty_env m (f.(fn_params) ++ f.(fn_vars)) e m1 -> *)
+(*       list_norepet (var_names f.(fn_params) ++ var_names f.(fn_vars)) -> *)
+(*       bind_parameters ge e m1 f.(fn_params) vargs m2 -> *)
+(*       execinf_stmt e (create_undef_temps f.(fn_temps)) m2 f.(fn_body) t -> *)
+(*       evalinf_funcall m (Internal f) vargs t. *)
+
+(* End BIGSTEP. *)
+
+(* (** Big-step execution of a whole program.  *) *)
+
+(* Inductive bigstep_program_terminates (p: program): trace -> int -> Prop := *)
+(*   | bigstep_program_terminates_intro: forall b f m0 m1 t r, *)
+(*       let ge := globalenv p in *)
+(*       Genv.init_mem p = Some m0 -> *)
+(*       Genv.find_symbol ge p.(prog_main) = Some b -> *)
+(*       Genv.find_funct_ptr ge b = Some f -> *)
+(*       type_of_fundef f = Tfunction Tnil type_int32s cc_default -> *)
+(*       eval_funcall ge m0 f nil t m1 (Vint r) -> *)
+(*       bigstep_program_terminates p t r. *)
+
+(* Inductive bigstep_program_diverges (p: program): traceinf -> Prop := *)
+(*   | bigstep_program_diverges_intro: forall b f m0 t, *)
+(*       let ge := globalenv p in *)
+(*       Genv.init_mem p = Some m0 -> *)
+(*       Genv.find_symbol ge p.(prog_main) = Some b -> *)
+(*       Genv.find_funct_ptr ge b = Some f -> *)
+(*       type_of_fundef f = Tfunction Tnil type_int32s cc_default -> *)
+(*       evalinf_funcall ge m0 f nil t -> *)
+(*       bigstep_program_diverges p t. *)
+
+(* Definition bigstep_semantics (p: program) := *)
+(*   Bigstep_semantics (bigstep_program_terminates p) (bigstep_program_diverges p). *)
+
+(* (** * Implication from big-step semantics to transition semantics *) *)
+
+(* Section BIGSTEP_TO_TRANSITIONS. *)
+
+(* Variable prog: program. *)
+(* Let ge : genv := globalenv prog. *)
+
+(* Inductive outcome_state_match *)
+(*        (e: env) (le: temp_env) (m: mem) (f: function) (k: cont): outcome -> state -> Prop := *)
+(*   | osm_normal: *)
+(*       outcome_state_match e le m f k Out_normal (State f Sskip k e le m) *)
+(*   | osm_break: *)
+(*       outcome_state_match e le m f k Out_break (State f Sbreak k e le m) *)
+(*   | osm_continue: *)
+(*       outcome_state_match e le m f k Out_continue (State f Scontinue k e le m) *)
+(*   | osm_return_none: forall k', *)
+(*       call_cont k' = call_cont k -> *)
+(*       outcome_state_match e le m f k *)
+(*         (Out_return None) (State f (Sreturn None) k' e le m) *)
+(*   | osm_return_some: forall a v k', *)
+(*       call_cont k' = call_cont k -> *)
+(*       eval_expr ge e le m a v -> *)
+(*       outcome_state_match e le m f k *)
+(*         (Out_return (Some (v,typeof a))) (State f (Sreturn (Some a)) k' e le m). *)
+
+(* Lemma is_call_cont_call_cont: *)
+(*   forall k, is_call_cont k -> call_cont k = k. *)
+(* Proof. *)
+(*   destruct k; simpl; intros; contradiction || auto. *)
+(* Qed. *)
+
+(* Lemma exec_stmt_eval_funcall_steps: *)
+(*   (forall e le m s t le' m' out, *)
+(*    exec_stmt ge e le m s t le' m' out -> *)
+(*    forall f k, exists S, *)
+(*    star step1 ge (State f s k e le m) t S *)
+(*    /\ outcome_state_match e le' m' f k out S) *)
+(* /\ *)
+(*   (forall m fd args t m' res, *)
+(*    eval_funcall ge m fd args t m' res -> *)
+(*    forall k, *)
+(*    is_call_cont k -> *)
+(*    star step1 ge (Callstate fd args k m) t (Returnstate res k m')). *)
+(* Proof. *)
+(*   apply exec_stmt_funcall_ind; intros. *)
+
+(* (* skip *) *)
+(*   econstructor; split. apply star_refl. constructor. *)
+
+(* (* assign *) *)
+(*   econstructor; split. apply star_one. econstructor; eauto. constructor. *)
+
+(* (* set *) *)
+(*   econstructor; split. apply star_one. econstructor; eauto. constructor. *)
+
+(* (* call *) *)
+(*   econstructor; split. *)
+(*   eapply star_left. econstructor; eauto. *)
+(*   eapply star_right. apply H5. simpl; auto. econstructor. reflexivity. traceEq. *)
+(*   constructor. *)
+
+(* (* builtin *) *)
+(*   econstructor; split. apply star_one. econstructor; eauto. constructor. *)
+
+(* (* sequence 2 *) *)
+(*   destruct (H0 f (Kseq s2 k)) as [S1 [A1 B1]]. inv B1. *)
+(*   destruct (H2 f k) as [S2 [A2 B2]]. *)
+(*   econstructor; split. *)
+(*   eapply star_left. econstructor. *)
+(*   eapply star_trans. eexact A1. *)
+(*   eapply star_left. constructor. eexact A2. *)
+(*   reflexivity. reflexivity. traceEq. *)
+(*   auto. *)
+
+(* (* sequence 1 *) *)
+(*   destruct (H0 f (Kseq s2 k)) as [S1 [A1 B1]]. *)
+(*   set (S2 := *)
+(*     match out with *)
+(*     | Out_break => State f Sbreak k e le1 m1 *)
+(*     | Out_continue => State f Scontinue k e le1 m1 *)
+(*     | _ => S1 *)
+(*     end). *)
+(*   exists S2; split. *)
+(*   eapply star_left. econstructor. *)
+(*   eapply star_trans. eexact A1. *)
+(*   unfold S2; inv B1. *)
+(*     congruence. *)
+(*     apply star_one. apply step_break_seq. *)
+(*     apply star_one. apply step_continue_seq. *)
+(*     apply star_refl. *)
+(*     apply star_refl. *)
+(*   reflexivity. traceEq. *)
+(*   unfold S2; inv B1; congruence || econstructor; eauto. *)
+
+(* (* ifthenelse *) *)
+(*   destruct (H2 f k) as [S1 [A1 B1]]. *)
+(*   exists S1; split. *)
+(*   eapply star_left. 2: eexact A1. eapply step_ifthenelse; eauto. traceEq. *)
+(*   auto. *)
+
+(* (* return none *) *)
+(*   econstructor; split. apply star_refl. constructor. auto. *)
+
+(* (* return some *) *)
+(*   econstructor; split. apply star_refl. econstructor; eauto. *)
+
+(* (* break *) *)
+(*   econstructor; split. apply star_refl. constructor. *)
+
+(* (* continue *) *)
+(*   econstructor; split. apply star_refl. constructor. *)
+
+(* (* loop stop 1 *) *)
+(*   destruct (H0 f (Kloop1 s1 s2 k)) as [S1 [A1 B1]]. *)
+(*   set (S2 := *)
+(*     match out' with *)
+(*     | Out_break => State f Sskip k e le' m' *)
+(*     | _ => S1 *)
+(*     end). *)
+(*   exists S2; split. *)
+(*   eapply star_left. eapply step_loop. *)
+(*   eapply star_trans. eexact A1. *)
+(*   unfold S2. inversion H1; subst. *)
+(*   inv B1. apply star_one. constructor. *)
+(*   apply star_refl. *)
+(*   reflexivity. traceEq. *)
+(*   unfold S2. inversion H1; subst. constructor. inv B1; econstructor; eauto. *)
+
+(* (* loop stop 2 *) *)
+(*   destruct (H0 f (Kloop1 s1 s2 k)) as [S1 [A1 B1]]. *)
+(*   destruct (H3 f (Kloop2 s1 s2 k)) as [S2 [A2 B2]]. *)
+(*   set (S3 := *)
+(*     match out2 with *)
+(*     | Out_break => State f Sskip k e le2 m2 *)
+(*     | _ => S2 *)
+(*     end). *)
+(*   exists S3; split. *)
+(*   eapply star_left. eapply step_loop. *)
+(*   eapply star_trans. eexact A1. *)
+(*   eapply star_left with (s2 := State f s2 (Kloop2 s1 s2 k) e le1 m1). *)
+(*   inv H1; inv B1; constructor; auto. *)
+(*   eapply star_trans. eexact A2. *)
+(*   unfold S3. inversion H4; subst. *)
+(*   inv B2. apply star_one. constructor. apply star_refl. *)
+(*   reflexivity. reflexivity. reflexivity. traceEq. *)
+(*   unfold S3. inversion H4; subst. constructor. inv B2; econstructor; eauto. *)
+
+(* (* loop loop *) *)
+(*   destruct (H0 f (Kloop1 s1 s2 k)) as [S1 [A1 B1]]. *)
+(*   destruct (H3 f (Kloop2 s1 s2 k)) as [S2 [A2 B2]]. *)
+(*   destruct (H5 f k) as [S3 [A3 B3]]. *)
+(*   exists S3; split. *)
+(*   eapply star_left. eapply step_loop. *)
+(*   eapply star_trans. eexact A1. *)
+(*   eapply star_left with (s2 := State f s2 (Kloop2 s1 s2 k) e le1 m1). *)
+(*   inv H1; inv B1; constructor; auto. *)
+(*   eapply star_trans. eexact A2. *)
+(*   eapply star_left with (s2 := State f (Sloop s1 s2) k e le2 m2). *)
+(*   inversion H4; subst; inv B2; constructor; auto. *)
+(*   eexact A3. *)
+(*   reflexivity. reflexivity. reflexivity. reflexivity. traceEq. *)
+(*   auto. *)
+
+(* (* switch *) *)
+(*   destruct (H2 f (Kswitch k)) as [S1 [A1 B1]]. *)
+(*   set (S2 := *)
+(*     match out with *)
+(*     | Out_normal => State f Sskip k e le1 m1 *)
+(*     | Out_break => State f Sskip k e le1 m1 *)
+(*     | Out_continue => State f Scontinue k e le1 m1 *)
+(*     | _ => S1 *)
+(*     end). *)
+(*   exists S2; split. *)
+(*   eapply star_left. eapply step_switch; eauto. *)
+(*   eapply star_trans. eexact A1. *)
+(*   unfold S2; inv B1. *)
+(*     apply star_one. constructor. auto. *)
+(*     apply star_one. constructor. auto. *)
+(*     apply star_one. constructor. *)
+(*     apply star_refl. *)
+(*     apply star_refl. *)
+(*   reflexivity. traceEq. *)
+(*   unfold S2. inv B1; simpl; econstructor; eauto. *)
+
+(* (* call internal *) *)
+(*   destruct (H3 f k) as [S1 [A1 B1]]. *)
+(*   eapply star_left. eapply step_internal_function; eauto. econstructor; eauto. *)
+(*   eapply star_right. eexact A1. *)
+(*    inv B1; simpl in H4; try contradiction. *)
+(*   (* Out_normal *) *)
+(*   assert (fn_return f = Tvoid /\ vres = Vundef). *)
+(*     destruct (fn_return f); auto || contradiction. *)
+(*   destruct H7. subst vres. apply step_skip_call; auto. *)
+(*   (* Out_return None *) *)
+(*   assert (fn_return f = Tvoid /\ vres = Vundef). *)
+(*     destruct (fn_return f); auto || contradiction. *)
+(*   destruct H8. subst vres. *)
+(*   rewrite <- (is_call_cont_call_cont k H6). rewrite <- H7. *)
+(*   apply step_return_0; auto. *)
+(*   (* Out_return Some *) *)
+(*   destruct H4. *)
+(*   rewrite <- (is_call_cont_call_cont k H6). rewrite <- H7. *)
+(*   eapply step_return_1; eauto. *)
+(*   reflexivity. traceEq. *)
+
+(* (* call external *) *)
+(*   apply star_one. apply step_external_function; auto. *)
+(* Qed. *)
+
+(* Lemma exec_stmt_steps: *)
+(*    forall e le m s t le' m' out, *)
+(*    exec_stmt ge e le m s t le' m' out -> *)
+(*    forall f k, exists S, *)
+(*    star step1 ge (State f s k e le m) t S *)
+(*    /\ outcome_state_match e le' m' f k out S. *)
+(* Proof (proj1 exec_stmt_eval_funcall_steps). *)
+
+(* Lemma eval_funcall_steps: *)
+(*    forall m fd args t m' res, *)
+(*    eval_funcall ge m fd args t m' res -> *)
+(*    forall k, *)
+(*    is_call_cont k -> *)
+(*    star step1 ge (Callstate fd args k m) t (Returnstate res k m'). *)
+(* Proof (proj2 exec_stmt_eval_funcall_steps). *)
+
+(* Definition order (x y: unit) := False. *)
+
+(* Lemma evalinf_funcall_forever: *)
+(*   forall m fd args T k, *)
+(*   evalinf_funcall ge m fd args T -> *)
+(*   forever_N step1 order ge tt (Callstate fd args k m) T. *)
+(* Proof. *)
+(*   cofix CIH_FUN. *)
+(*   assert (forall e le m s T f k, *)
+(*           execinf_stmt ge e le m s T -> *)
+(*           forever_N step1 order ge tt (State f s k e le m) T). *)
+(*   cofix CIH_STMT. *)
+(*   intros. inv H. *)
+
+(* (* call  *) *)
+(*   eapply forever_N_plus. *)
+(*   apply plus_one. eapply step_call; eauto. *)
+(*   eapply CIH_FUN. eauto. traceEq. *)
+
+(* (* seq 1 *) *)
+(*   eapply forever_N_plus. *)
+(*   apply plus_one. econstructor. *)
+(*   apply CIH_STMT; eauto. traceEq. *)
+(* (* seq 2 *) *)
+(*   destruct (exec_stmt_steps _ _ _ _ _ _ _ _ H0 f (Kseq s2 k)) as [S1 [A1 B1]]. *)
+(*   inv B1. *)
+(*   eapply forever_N_plus. *)
+(*   eapply plus_left. constructor. eapply star_trans. eexact A1. *)
+(*   apply star_one. constructor. reflexivity. reflexivity. *)
+(*   apply CIH_STMT; eauto. traceEq. *)
+
+(* (* ifthenelse *) *)
+(*   eapply forever_N_plus. *)
+(*   apply plus_one. eapply step_ifthenelse with (b := b); eauto. *)
+(*   apply CIH_STMT; eauto. traceEq. *)
+
+(* (* loop body 1 *) *)
+(*   eapply forever_N_plus. *)
+(*   eapply plus_one. constructor. *)
+(*   apply CIH_STMT; eauto. traceEq. *)
+(* (* loop body 2 *) *)
+(*   destruct (exec_stmt_steps _ _ _ _ _ _ _ _ H0 f (Kloop1 s1 s2 k)) as [S1 [A1 B1]]. *)
+(*   eapply forever_N_plus with (s2 := State f s2 (Kloop2 s1 s2 k) e le1 m1). *)
+(*   eapply plus_left. constructor. *)
+(*   eapply star_right. eexact A1. *)
+(*   inv H1; inv B1; constructor; auto. *)
+(*   reflexivity. reflexivity. *)
+(*   apply CIH_STMT; eauto. traceEq. *)
+(* (* loop loop *) *)
+(*   destruct (exec_stmt_steps _ _ _ _ _ _ _ _ H0 f (Kloop1 s1 s2 k)) as [S1 [A1 B1]]. *)
+(*   destruct (exec_stmt_steps _ _ _ _ _ _ _ _ H2 f (Kloop2 s1 s2 k)) as [S2 [A2 B2]]. *)
+(*   eapply forever_N_plus with (s2 := State f (Sloop s1 s2) k e le2 m2). *)
+(*   eapply plus_left. constructor. *)
+(*   eapply star_trans. eexact A1. *)
+(*   eapply star_left. inv H1; inv B1; constructor; auto. *)
+(*   eapply star_right. eexact A2. *)
+(*   inv B2. constructor. *)
+(*   reflexivity. reflexivity. reflexivity. reflexivity. *)
+(*   apply CIH_STMT; eauto. traceEq. *)
+
+(* (* switch *) *)
+(*   eapply forever_N_plus. *)
+(*   eapply plus_one. eapply step_switch; eauto. *)
+(*   apply CIH_STMT; eauto. *)
+(*   traceEq. *)
+
+(* (* call internal *) *)
+(*   intros. inv H0. *)
+(*   eapply forever_N_plus. *)
+(*   eapply plus_one. econstructor; eauto. econstructor; eauto. *)
+(*   apply H; eauto. *)
+(*   traceEq. *)
+(* Qed. *)
+
+(* Theorem bigstep_semantics_sound: *)
+(*   bigstep_sound (bigstep_semantics prog) (semantics1 prog). *)
+(* Proof. *)
+(*   constructor; simpl; intros. *)
+(* (* termination *) *)
+(*   inv H. econstructor; econstructor. *)
+(*   split. econstructor; eauto. *)
+(*   split. eapply eval_funcall_steps. eauto. red; auto. *)
+(*   econstructor. *)
+(* (* divergence *) *)
+(*   inv H. econstructor. *)
+(*   split. econstructor; eauto. *)
+(*   eapply forever_N_forever with (order := order). *)
+(*   red; intros. constructor; intros. red in H. elim H. *)
+(*   eapply evalinf_funcall_forever; eauto. *)
+(* Qed. *)
+
+(* End BIGSTEP_TO_TRANSITIONS. *)
diff --git a/cfrontend/ClightD.v b/cfrontend/ClightD.v
new file mode 100644
index 00000000..a6a2a47e
--- /dev/null
+++ b/cfrontend/ClightD.v
@@ -0,0 +1,202 @@
+(** Determinacy *)
+Require Import Clight.
+Require Import Coqlib CoqlibC sflib.
+Require Import Globalenvs Events.
+Require Import Smallstep Simulation.
+
+Ltac Determ_aux EVALEXPR EVALLVAL :=
+  try congruence; try Eq;
+  match goal with
+  | [ H: ?H1 /\ ?H2 |- _ ] => inv H; Determ_aux EVALEXPR EVALLVAL
+  | [ H: ?H1 \/ ?H2 |- _ ] => inv H; Determ_aux EVALEXPR EVALLVAL
+  | [ H: is_call_cont ?k |- _ ] =>
+    contradiction || (clear H; Determ_aux EVALEXPR EVALLVAL)
+  | [ H1: eval_expr _ _ _ _ ?a ?v1, H2: eval_expr _ _ _ _ ?a ?v2 |- _ ] =>
+          assert (v1 = v2) by (eapply EVALEXPR; eauto);
+          clear H1 H2; Determ_aux EVALEXPR EVALLVAL
+  | [ H1: eval_lvalue _ _ _ _ ?a ?v, H2: eval_lvalue _ _ _ _ ?a ?v' |- _ ] =>
+          assert (v = v') by (eapply EVALLVAL; eauto);
+          clear H1 H2; Determ_aux EVALEXPR EVALLVAL
+  end.
+
+Ltac terminate H :=
+  assert (False) by inv H; contradiction.
+
+Lemma eval_expr_determ:
+  forall ge e le m a v, eval_expr ge e le m a v -> forall v', eval_expr ge e le m a v' -> v = v'
+with eval_lvalue_determ:
+       forall ge e le m a v, eval_lvalue ge e le m a v -> forall v', eval_lvalue ge e le m a v' -> v = v'.
+Proof.
+  - induction 1; intros v' EV; inv EV; try Determ_aux eval_expr_determ eval_lvalue_determ;
+      try terminate H; try terminate H0; try terminate H1; try terminate H2.
+    exploit eval_lvalue_determ. eapply H. eauto. eauto. i. subst.
+    inv H0; inv H2; Eq.
+  - induction 1; intros v'' EV; inv EV; try Determ_aux eval_expr_determ eval_lvalue_determ.
+    Eq; eauto. exploit eval_expr_determ. eapply H. eapply H8. intros. subst. eauto.
+Qed.
+
+Let eval_exprlist_determ:
+  forall ge e le m bl tyl vl, eval_exprlist ge e le m bl tyl vl  -> forall vl', eval_exprlist ge e le m bl tyl vl' -> vl' = vl.
+Proof.
+  induction 1; intros v' EV; inv EV; f_equal; eauto.
+  exploit eval_expr_determ. apply H. apply H6. intros. subst.
+  rewrite H0 in H8. inv H8; auto.
+Qed.
+
+Let alloc_variables_determ:
+  forall ge env m vars e m1, alloc_variables ge env m vars e m1 -> forall e' m1', alloc_variables ge env m vars e' m1' -> e = e' /\ m1 = m1'.
+Proof.
+  induction 1; intros e' m1' EV; inv EV; f_equal; eauto. rewrite H in H8. inv H8. eapply IHalloc_variables; eauto.
+Qed.
+
+Let bind_parameters_determ:
+  forall ge e m params vargs m1, bind_parameters ge e m params vargs m1 -> forall m1', bind_parameters ge e m params vargs m1' -> m1 = m1'.
+Proof.
+  induction 1; intros m1' EV; inv EV; f_equal; eauto. Eq. replace m1 with m3 in *. eapply IHbind_parameters; eauto.
+  inv H0; inv H10; try congruence; try rewrite SZ0 in *; lia.
+Qed.
+
+Lemma semantics1_single_events p s (INT: ~ is_external (semantics1 p) (globalenv (semantics1 p)) s): single_events_at (semantics1 p) s.
+Proof.
+  red. intros. inv H; (try (exploit external_call_trace_length; eauto; intro T)); simpl; try lia; ss.
+Qed.
+
+Lemma semantics2_single_events p s (INT: ~ is_external (semantics2 p) (globalenv (semantics2 p)) s): single_events_at (semantics2 p) s.
+Proof.
+  red. intros. inv H; (try (exploit external_call_trace_length; eauto; intro T)); simpl; try lia; ss.
+Qed.
+
+Lemma initial_state_determ: forall p st0 st1,
+    Smallstep.initial_state (semantics1 p) st0 ->
+    Smallstep.initial_state (semantics1 p) st1 -> st0 = st1.
+Proof.
+  intros. inv H; inv H0. subst ge0 ge. Eq.
+Qed.
+
+Ltac Determ :=
+  try congruence; try Eq;
+  match goal with
+  | [ |- match_traces _ E0 E0 /\ (_ -> _) ]  =>
+    split; [constructor|intros _; Determ]
+  | [ H: ?H1 /\ ?H2 |- _ ] => inv H; Determ
+  | [ H: ?H1 \/ ?H2 |- _ ] => inv H; Determ
+  | [ H: is_call_cont ?k |- _ ] =>
+    contradiction || (clear H; Determ)
+  | [ H1: eval_expr _ _ _ _ ?a ?v1, H2: eval_expr _ _ _ _ ?a ?v2 |- _ ] =>
+          assert (v1 = v2) by (eapply eval_expr_determ; eauto);
+          clear H1 H2; Determ
+  | [ H1: eval_lvalue _ _ _ _ ?a ?v, H2: eval_lvalue _ _ _ _ ?a ?v' |- _ ] =>
+          assert (v = v') by (eapply eval_lvalue_determ; eauto);
+          clear H1 H2; Determ
+  | [ H1: eval_exprlist _ _ _ _ _ ?a ?v1, H2: eval_exprlist _ _ _ _ _ ?a ?v2 |- _ ] =>
+          assert (v1 = v2) by (eapply eval_exprlist_determ; eauto);
+          clear H1 H2; Determ
+  | [ H1: alloc_variables _ _ _ ?vars ?e ?m1, H2: alloc_variables _ _ _ ?vars ?e' ?m2 |- _ ] =>
+          assert (e = e' /\ m1 = m2) by (eapply alloc_variables_determ; eauto);
+          clear H1 H2; Determ
+  | [ H1: bind_parameters _ _ _ _ ?e ?m1, H2: bind_parameters _ _ _ _ ?e ?m2 |- _ ] =>
+          assert (m1 = m2) by (eapply bind_parameters_determ; eauto);
+          clear H1 H2; Determ
+  | _ => idtac
+  end.
+
+Lemma semantics1_determinate_at:
+  forall p s (INT: ~ is_external (semantics1 p) (globalenv (semantics1 p)) s),
+  deterministic_at (semantics1 p) s.
+Proof.
+  econstructor; eauto.
+  - intros. simpl in *. inv STEP0; inv STEP1; Determ; subst; eauto; try by (esplits; eauto); try by Eq.
+    + clarify.  inv H2; inv H15; Eq; clarify; eauto.
+      * rewrite SZ0 in *; lia.
+      * rewrite SZ in *; lia.
+    + ss. determ_tac external_call_determ.
+    + inv H; inv H6. Determ. subst; eauto.
+    + determ_tac external_call_determ.
+  - intros. inv FINAL; inv STEP.
+  - eapply semantics1_single_events. eauto.
+Qed.
+
+Lemma semantics2_determinate_at:
+  forall p s (INT: ~ is_external (semantics1 p) (globalenv (semantics2 p)) s),
+  deterministic_at (semantics2 p) s.
+Proof.
+  econstructor; eauto.
+  - intros. simpl in *. inv STEP0; inv STEP1; Determ; subst; eauto; try by (esplits; eauto); try by Eq.
+    + clarify.  inv H2; inv H15; Eq; clarify; eauto.
+      * rewrite SZ0 in *; lia.
+      * rewrite SZ in *; lia.
+    + ss. determ_tac external_call_determ.
+    + inv H; inv H6. Determ. subst; eauto.
+    + determ_tac external_call_determ.
+  - intros. inv FINAL; inv STEP.
+  - eapply semantics2_single_events. eauto.
+Qed.
+
+Lemma semantics1_receptive_at:
+  forall p s (INT: ~ is_external (semantics1 p) (globalenv (semantics1 p)) s),
+  receptive_at (semantics1 p) s.
+Proof.
+  intros. unfold semantics1.
+  set (ge := Clight.globalenv p). constructor; simpl; intros.
+(* receptiveness *)
+  assert (t1 = E0 -> exists s2, step1 ge s t2 s2).
+    intros. subst. inv H0. exists s1; auto.
+  inversion H; subst; auto.
+  (* builtin *)
+  ss.
+  exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
+  econstructor; econstructor; eauto.
+  (* external *)
+  ss.
+  exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
+  exists (Returnstate vres2 k m2). econstructor; eauto.
+(* trace length *)
+  red; simpl; intros. inv H; simpl; try lia; ss.
+  eapply external_call_trace_length; eauto.
+  eapply external_call_trace_length; eauto.
+Qed.
+
+Lemma semantics2_receptive_at:
+  forall p s (INT: ~ is_external (semantics2 p) (globalenv (semantics2 p)) s),
+  receptive_at (semantics2 p) s.
+Proof.
+  intros. unfold semantics2.
+  set (ge := Clight.globalenv p). constructor; simpl; intros.
+(* receptiveness *)
+  assert (t1 = E0 -> exists s2, step2 ge s t2 s2).
+    intros. subst. inv H0. exists s1; auto.
+  inversion H; subst; auto.
+  (* builtin *)
+  ss.
+  exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
+  econstructor; econstructor; eauto.
+  (* external *)
+  ss.
+  exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
+  exists (Returnstate vres2 k m2). econstructor; eauto.
+(* trace length *)
+  red; simpl; intros. inv H; simpl; try lia; ss.
+  eapply external_call_trace_length; eauto.
+  eapply external_call_trace_length; eauto.
+Qed.
+
+Theorem final_state_determ1: forall p st0 retv,
+    Smallstep.final_state (semantics1 p) st0 retv ->
+    Dfinal_state (semantics1 p) st0 retv.
+Proof.
+  econstructor; eauto.
+  - intros. inv FINAL1; inv FINAL0; Eq. auto.
+  - red. unfold not. intros. inv FINAL; inv H0.
+Qed.
+
+Theorem final_state_determ: forall p st0 retv,
+    Smallstep.final_state (semantics2 p) st0 retv ->
+    Dfinal_state (semantics2 p) st0 retv.
+Proof.
+  econstructor; eauto.
+  - intros. inv FINAL1; inv FINAL0; Eq. auto.
+  - red. unfold not. intros. inv FINAL; inv H0.
+Qed.
+
+Ltac DStep_tac1 := esplit; [(eapply semantics1_determinate_at; simpl in *; eauto)|].
+Ltac DStep_tac2 := esplit; [(eapply semantics2_determinate_at; simpl in *; eauto)|].
diff --git a/cfrontend/Cminorgenproof.v b/cfrontend/Cminorgenproof.v
index bc1c92ca..2730bfa8 100644
--- a/cfrontend/Cminorgenproof.v
+++ b/cfrontend/Cminorgenproof.v
@@ -17,8 +17,12 @@ Require Import FSets FSetAVL Orders Mergesort.
 Require Import Coqlib Maps Ordered Errors Integers Floats.
 Require Intv.
 Require Import AST Linking.
+Require Import CoqlibC Simulation CsharpminorD CminorD Classical.
+Require Import IntPtrRel PointerOp.
 Require Import Values Memory Events Globalenvs Smallstep.
 Require Import Csharpminor Switch Cminor Cminorgen.
+Require Import sflib.
+From Paco Require Import paco.
 
 Local Open Scope error_monad_scope.
 
@@ -39,6 +43,9 @@ Hypothesis TRANSL: match_prog prog tprog.
 Let ge : Csharpminor.genv := Genv.globalenv prog.
 Let tge: genv := Genv.globalenv tprog.
 
+Let sem := Csharpminor.semantics prog.
+Let tsem := Cminor.semantics tprog.
+
 Lemma symbols_preserved:
   forall (s: ident), Genv.find_symbol tge s = Genv.find_symbol ge s.
 Proof (Genv.find_symbol_transf_partial TRANSL).
@@ -47,6 +54,9 @@ Lemma senv_preserved:
   Senv.equiv ge tge.
 Proof (Genv.senv_transf_partial TRANSL).
 
+Lemma same_public: prog_public prog = prog_public tprog.
+Proof. inv TRANSL. des; eauto. Qed.
+
 Lemma function_ptr_translated:
   forall (b: block) (f: Csharpminor.fundef),
   Genv.find_funct_ptr ge b = Some f ->
@@ -143,7 +153,8 @@ Lemma nextblock_storev:
   forall chunk m addr v m',
   Mem.storev chunk m addr v = Some m' -> Mem.nextblock m' = Mem.nextblock m.
 Proof.
-  unfold Mem.storev; intros. destruct addr; try discriminate.
+  unfold Mem.storev; intros. destruct addr; try discriminate. des_ifs.
+  eapply Mem.nextblock_store; eauto.
   eapply Mem.nextblock_store; eauto.
 Qed.
 
@@ -1276,6 +1287,13 @@ Ltac TrivialExists :=
   | _ => idtac
   end.
 
+Ltac binv :=
+  match goal with
+  | [ H: false = true |- _ ] => inv H
+  | [ H: true = false |- _ ] => inv H
+  | _ => idtac
+  end.
+
 (** Compatibility of [eval_unop] with respect to [Val.inject]. *)
 
 Lemma eval_unop_compat:
@@ -1387,6 +1405,9 @@ Proof.
   destruct (Int.ltu i0 Int64.iwordsize'); constructor.
 - TrivialExists; inv H0; inv H1; simpl; auto.
   destruct (Int.ltu i0 Int64.iwordsize'); constructor.
+- destruct Archi.ptr64 eqn:SF; TrivialExists.
++ eapply Val.psubl_inject; eauto.
++ eapply Val.psub_inject; eauto.
 - (* cmp *)
   TrivialExists. inv H0; inv H1; auto. apply val_inject_val_of_optbool.
 - (* cmpu *)
@@ -1421,6 +1442,88 @@ Proof.
   discriminate.
 Qed.
 
+(* move lemma. make lemma like psub_join_common *)
+Lemma eval_binop_wrapper_compat
+  f op v1 tv1 v2 tv2 v m tm
+  (EVAL: eval_binop_wrapper op v1 v2 m = Some v)
+  (VINJ1: Val.inject f v1 tv1)
+  (VINJ2: Val.inject f v2 tv2)
+  (MINJ: Mem.inject f m tm):
+  exists tv,
+    <<EVAL': eval_binop_wrapper op tv1 tv2 tm = Some tv>>
+  /\ <<VINJ: Val.inject f v tv>>.
+Proof.
+  destruct (ptr_binop op) eqn:PTROP; cycle 1.
+  { rewrite eval_binop_no_ptr_binop in *; eauto. eapply eval_binop_compat; eauto. }
+  destruct op; simpl in PTROP; binv.
+(* psub *)
+- unfold_wrapper. simpl in *. unfold psub_join_cminor in *. destruct Archi.ptr64 eqn:SF.
++ eapply some_injective in EVAL. exploit psubl_join_common_inject; try eapply EVAL; eauto. i. des; subst.
+  esplits; eauto.
++ eapply some_injective in EVAL. exploit psub_join_common_inject; try eapply EVAL; eauto. i. des; subst.
+  esplits; eauto.
+(* cmpu *)
+- unfold eval_binop_wrapper in *. simpl in *. destruct Archi.ptr64 eqn:SF; [simpl in *; inv PTROP|].
+  simpl in *. destruct v1, v2; simpl in *; inv EVAL; esplits; eauto.
++ inv VINJ1; inv VINJ2. simpl. esplits; eauto. apply val_inject_val_of_bool.
++ inv VINJ1; inv VINJ2. destruct (Int.eq i Int.zero) eqn:NULL.
+* unfold Val.cmpu_bool. rewrite SF, NULL in *. simpl in *.
+  fold (Mem.weak_valid_pointer m b (Ptrofs.unsigned i0)).
+  fold (Mem.weak_valid_pointer tm b2 (Ptrofs.unsigned (Ptrofs.add i0 (Ptrofs.repr delta)))).
+  destruct (Mem.weak_valid_pointer m b (Ptrofs.unsigned i0)) eqn: WVLD; simpl in *; [|clarify].
+  erewrite Mem.weak_valid_pointer_inject_val; eauto. esplits; eauto.
+  eapply val_inject_val_of_optbool.
+* destruct (cmpu_join m c (Vint i) (Vptr b i0)) eqn:CMPSRC; [|simpl in *; econs].
+  exploit cmpu_join_inject; try eapply CMPSRC; eauto. i. rewrite H.
+  eapply val_inject_val_of_bool.
++ inv VINJ1; inv VINJ2. destruct (Int.eq i0 Int.zero) eqn:NULL.
+* unfold Val.cmpu_bool. rewrite SF, NULL in *. simpl in *.
+  fold (Mem.weak_valid_pointer m b (Ptrofs.unsigned i)).
+  fold (Mem.weak_valid_pointer tm b2 (Ptrofs.unsigned (Ptrofs.add i (Ptrofs.repr delta)))).
+  destruct (Mem.weak_valid_pointer m b (Ptrofs.unsigned i)) eqn: WVLD; simpl in *; [|clarify].
+  erewrite Mem.weak_valid_pointer_inject_val; eauto. esplits; eauto.
+  eapply val_inject_val_of_optbool.
+* destruct (cmpu_join m c (Vptr b i) (Vint i0)) eqn:CMPSRC; [|simpl in *; econs].
+  exploit cmpu_join_inject; try eapply CMPSRC; eauto. i. rewrite H.
+  eapply val_inject_val_of_bool.
+(* cmplu *)
+- unfold eval_binop_wrapper in *. simpl in *. destruct Archi.ptr64 eqn:SF; [|simpl in *; inv PTROP].
+  simpl in *. destruct v1, v2; simpl in *; inv EVAL; try by (esplits; eauto).
++ inv VINJ1; inv VINJ2. simpl. esplits; eauto. apply val_inject_val_of_bool.
++ inv VINJ1; inv VINJ2. destruct (Int64.eq i Int64.zero) eqn:NULL.
+* unfold Val.cmplu_bool. rewrite SF, NULL in *. simpl in *.
+  fold (Mem.weak_valid_pointer m b (Ptrofs.unsigned i0)) in H0.
+  fold (Mem.weak_valid_pointer tm b2 (Ptrofs.unsigned (Ptrofs.add i0 (Ptrofs.repr delta)))).
+  destruct (Mem.weak_valid_pointer m b (Ptrofs.unsigned i0)) eqn: WVLD; simpl in *; [|clarify].
+  erewrite Mem.weak_valid_pointer_inject_val; eauto. esplits; eauto.
+  destruct c; simpl in H0; inv H0; econs.
+* destruct (cmplu_join m c (Vlong i) (Vptr b i0)) eqn:CMPSRC; [|simpl in *; inv H0].
+  exploit cmplu_join_inject; try eapply CMPSRC; eauto. i. rewrite H.
+  simpl in H0. esplits; eauto. inv H0. eapply val_inject_val_of_bool.
++ inv VINJ1; inv VINJ2. destruct (Int64.eq i0 Int64.zero) eqn:NULL.
+* unfold Val.cmplu_bool. rewrite SF, NULL in *. simpl in *.
+  fold (Mem.weak_valid_pointer m b (Ptrofs.unsigned i)) in H0.
+  fold (Mem.weak_valid_pointer tm b2 (Ptrofs.unsigned (Ptrofs.add i (Ptrofs.repr delta)))).
+  destruct (Mem.weak_valid_pointer m b (Ptrofs.unsigned i)) eqn: WVLD; simpl in *; [|clarify].
+  erewrite Mem.weak_valid_pointer_inject_val; eauto. esplits; eauto.
+  destruct c; simpl in H0; inv H0; econs.
+* destruct (cmplu_join m c (Vptr b i) (Vlong i0)) eqn:CMPSRC; [|simpl in *; inv H0].
+  exploit cmplu_join_inject; try eapply CMPSRC; eauto. i. rewrite H.
+  simpl in H0. esplits; eauto. inv H0. eapply val_inject_val_of_bool.
++ destruct (Val.cmplu_bool (Mem.valid_pointer m) c (Vptr b i) (Vptr b0 i0)) as [bi|] eqn:E.
+  2:{ simpl in *. rewrite E in H0. simpl in H0. inv H0. }
+  simpl in *. rewrite E in H0. simpl in *. inv H0.
+  replace (Val.cmplu_bool (Mem.valid_pointer tm) c tv1 tv2) with (Some bi).
+  inv VINJ1; inv VINJ2.
+  econstructor; split. simpl; eauto. apply val_inject_val_of_bool.
+  symmetry. eapply Val.cmplu_bool_inject; eauto.
+  intros; eapply Mem.valid_pointer_inject_val; eauto.
+  intros; eapply Mem.weak_valid_pointer_inject_val; eauto.
+  intros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.
+  intros; eapply Mem.different_pointers_inject; eauto.
+  simpl. rewrite E. eauto.
+Qed.
+
 (** * Correctness of Cminor construction functions *)
 
 (** Correctness of the variable accessor [var_addr] *)
@@ -1526,7 +1629,11 @@ Proof.
   (* Ebinop *)
   exploit IHeval_expr1; eauto. intros [tv1 [EVAL1 INJ1]].
   exploit IHeval_expr2; eauto. intros [tv2 [EVAL2 INJ2]].
+  destruct (ptr_binop op) eqn:PTRBIN; cycle 1.
+  rewrite Csharpminor.eval_binop_no_ptr_binop in *; eauto.
   exploit eval_binop_compat; eauto. intros [tv [EVAL INJ]].
+  exists tv; split. econstructor; eauto. rewrite Csharpminor.eval_binop_no_ptr_binop; eauto. auto.
+  exploit eval_binop_wrapper_compat; eauto. intros [tv [EVAL INJ]].
   exists tv; split. econstructor; eauto. auto.
   (* Eload *)
   exploit IHeval_expr; eauto. intros [tv1 [EVAL1 INJ1]].
@@ -1651,7 +1758,7 @@ Lemma match_is_call_cont:
   match_cont k tk cenv xenv cs ->
   Csharpminor.is_call_cont k ->
   exists tk',
-    star step tge (State tfn Sskip tk sp te tm)
+    DStar tsem (State tfn Sskip tk sp te tm)
                E0 (State tfn Sskip tk' sp te tm)
     /\ is_call_cont tk'
     /\ match_cont k tk' cenv nil cs.
@@ -1660,7 +1767,7 @@ Proof.
   econstructor; split. apply star_refl. split. exact I. econstructor; eauto.
   exploit IHmatch_cont; eauto.
   intros [tk' [A B]]. exists tk'; split.
-  eapply star_left; eauto. constructor. traceEq. auto.
+  eapply star_left; eauto. DStep_tac. constructor. traceEq. auto.
   econstructor; split. apply star_refl. split. exact I. econstructor; eauto.
 Qed.
 
@@ -1745,17 +1852,18 @@ Lemma switch_descent:
   exists k',
   transl_lblstmt_cont cenv xenv ls k k'
   /\ (forall f sp e m,
-      plus step tge (State f s k sp e m) E0 (State f body k' sp e m)).
+      DPlus tsem (State f s k sp e m) E0 (State f body k' sp e m)).
 Proof.
   induction ls; intros.
 - monadInv H. econstructor; split.
   econstructor.
-  intros. eapply plus_two. constructor. constructor. auto.
+  intros. eapply plus_two. DStep_tac. constructor. DStep_tac. constructor. auto.
 - monadInv H. exploit IHls; eauto. intros [k' [A B]].
   econstructor; split.
   econstructor; eauto.
   intros. eapply plus_star_trans. eauto.
-  eapply star_left. constructor. apply star_one. constructor.
+  eapply B.
+  eapply star_left. DStep_tac. constructor. apply star_one. DStep_tac. constructor.
   reflexivity. traceEq.
 Qed.
 
@@ -1765,7 +1873,7 @@ Lemma switch_ascent:
   forall k k1,
   transl_lblstmt_cont cenv xenv ls k k1 ->
   exists k2,
-  star step tge (State f (Sexit n) k1 sp e m)
+  DStar tsem (State f (Sexit n) k1 sp e m)
              E0 (State f (Sexit O) k2 sp e m)
   /\ transl_lblstmt_cont cenv xenv ls' k k2.
 Proof.
@@ -1773,7 +1881,7 @@ Proof.
 - exists k1; split; auto. apply star_refl.
 - inv H0. exploit IHlbl_stmt_tail; eauto. intros (k2 & P & Q).
   exists k2; split; auto.
-  eapply star_left. constructor. eapply star_left. constructor. eexact P.
+  eapply star_left. DStep_tac. constructor. eapply star_left. DStep_tac. constructor. eexact P.
   eauto. auto.
 Qed.
 
@@ -1799,13 +1907,13 @@ Lemma switch_match_states:
     (MK: match_cont k tk cenv xenv cs)
     (TK: transl_lblstmt_cont cenv xenv ls tk tk'),
   exists S,
-  plus step tge (State tfn (Sexit O) tk' (Vptr sp Ptrofs.zero) te tm) E0 S
+  DPlus tsem (State tfn (Sexit O) tk' (Vptr sp Ptrofs.zero) te tm) E0 S
   /\ match_states (Csharpminor.State fn (seq_of_lbl_stmt ls) k e le m) S.
 Proof.
   intros. inv TK.
-- econstructor; split. eapply plus_two. constructor. constructor. auto.
+- econstructor; split. eapply plus_two. DStep_tac. constructor. DStep_tac. constructor. auto.
   eapply match_state; eauto.
-- econstructor; split. eapply plus_left. constructor. apply star_one. constructor. auto.
+- econstructor; split. eapply plus_left. DStep_tac. constructor. apply star_one. DStep_tac. constructor. auto.
   simpl. eapply match_state_seq; eauto. simpl. eapply switch_match_cont; eauto.
 Qed.
 
@@ -1944,47 +2052,48 @@ Definition measure (S: Csharpminor.state) : nat :=
   end.
 
 Lemma transl_step_correct:
-  forall S1 t S2, Csharpminor.step ge S1 t S2 ->
+  forall S1 t S2, IStep sem S1 t S2 ->
   forall T1, match_states S1 T1 ->
-  (exists T2, plus step tge T1 t T2 /\ match_states S2 T2)
+  (exists T2, DPlus tsem T1 t T2 /\ match_states S2 T2)
   \/ (measure S2 < measure S1 /\ t = E0 /\ match_states S2 T1)%nat.
 Proof.
+  destruct 1. generalize dependent S2. rename H into INT.
   induction 1; intros T1 MSTATE; inv MSTATE.
 
 (* skip seq *)
   monadInv TR. left.
   dependent induction MK.
   econstructor; split.
-  apply plus_one. constructor.
+  apply plus_one. DStep_tac. constructor.
   econstructor; eauto.
   econstructor; split.
-  apply plus_one. constructor.
+  apply plus_one. DStep_tac. constructor.
   eapply match_state_seq; eauto.
   exploit IHMK; eauto. intros [T2 [A B]].
-  exists T2; split. eapply plus_left. constructor. apply plus_star; eauto. traceEq.
+  exists T2; split. eapply plus_left. DStep_tac. constructor. apply plus_star; eauto. traceEq.
   auto.
 (* skip block *)
   monadInv TR. left.
   dependent induction MK.
   econstructor; split.
-  apply plus_one. constructor.
+  apply plus_one. DStep_tac. constructor.
   econstructor; eauto.
   exploit IHMK; eauto. intros [T2 [A B]].
-  exists T2; split. eapply plus_left. constructor. apply plus_star; eauto. traceEq.
+  exists T2; split. eapply plus_left. DStep_tac. constructor. apply plus_star; eauto. traceEq.
   auto.
 (* skip call *)
   monadInv TR. left.
   exploit match_is_call_cont; eauto. intros [tk' [A [B C]]].
   exploit match_callstack_freelist; eauto. intros [tm' [P [Q R]]].
   econstructor; split.
-  eapply plus_right. eexact A. apply step_skip_call. auto. eauto. traceEq.
+  eapply plus_right. eexact A. DStep_tac. apply step_skip_call. auto. eauto. traceEq.
   econstructor; eauto.
 
 (* set *)
   monadInv TR.
   exploit transl_expr_correct; eauto. intros [tv [EVAL VINJ]].
   left; econstructor; split.
-  apply plus_one. econstructor; eauto.
+  apply plus_one. DStep_tac. econstructor; eauto.
   econstructor; eauto.
   eapply match_callstack_set_temp; eauto.
 
@@ -1996,15 +2105,21 @@ Proof.
   intros [tv2 [EVAL2 VINJ2]].
   exploit Mem.storev_mapped_inject; eauto. intros [tm' [STORE' MINJ']].
   left; econstructor; split.
-  apply plus_one. econstructor; eauto.
+  apply plus_one. DStep_tac. econstructor; eauto.
   econstructor; eauto.
   inv VINJ1; simpl in H1; try discriminate. unfold Mem.storev in STORE'.
+  { des_ifs.
+  rewrite (Mem.nextblock_store _ _ _ _ _ _ H1).
+  rewrite (Mem.nextblock_store _ _ _ _ _ _ STORE').
+  eapply match_callstack_invariant with f0 m tm; eauto.
+  intros. eapply Mem.perm_store_2; eauto.
+  intros. eapply Mem.perm_store_1; eauto. }
   rewrite (Mem.nextblock_store _ _ _ _ _ _ H1).
   rewrite (Mem.nextblock_store _ _ _ _ _ _ STORE').
   eapply match_callstack_invariant with f0 m tm; eauto.
   intros. eapply Mem.perm_store_2; eauto.
   intros. eapply Mem.perm_store_1; eauto.
-
+  
 (* call *)
   simpl in H1. exploit functions_translated; eauto. intros [tfd [FIND TRANS]].
   monadInv TR.
@@ -2016,22 +2131,24 @@ Proof.
   exploit transl_exprlist_correct; eauto.
   intros [tvargs [EVAL2 VINJ2]].
   left; econstructor; split.
-  apply plus_one. eapply step_call; eauto.
+  apply plus_one. DStep_tac. eapply step_call; eauto.
   apply sig_preserved; eauto.
   econstructor; eauto.
   eapply match_Kcall with (cenv' := cenv); eauto.
   red; auto.
 
 (* builtin *)
+  unfold is_internal in INT. simpl in INT.
   monadInv TR.
   exploit transl_exprlist_correct; eauto.
   intros [tvargs [EVAL2 VINJ2]].
   exploit match_callstack_match_globalenvs; eauto. intros [hi' MG].
   exploit external_call_mem_inject; eauto.
+  simpl in *. eapply external_call_spec; eauto.
   eapply inj_preserves_globals; eauto.
   intros [f' [vres' [tm' [EC [VINJ [MINJ' [UNMAPPED [OUTOFREACH [INCR SEPARATED]]]]]]]]].
   left; econstructor; split.
-  apply plus_one. econstructor. eauto.
+  apply plus_one. DStep_tac. econstructor. eauto.
   eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   assert (MCS': match_callstack f' m' tm'
                  (Frame cenv tfn e le te sp lo hi :: cs)
@@ -2051,7 +2168,7 @@ Opaque PTree.set.
 (* seq *)
   monadInv TR.
   left; econstructor; split.
-  apply plus_one. constructor.
+  apply plus_one. DStep_tac. constructor.
   econstructor; eauto.
   econstructor; eauto.
 (* seq 2 *)
@@ -2061,20 +2178,20 @@ Opaque PTree.set.
   monadInv TR.
   exploit transl_expr_correct; eauto. intros [tv [EVAL VINJ]].
   left; exists (State tfn (if b then x0 else x1) tk (Vptr sp Ptrofs.zero) te tm); split.
-  apply plus_one. eapply step_ifthenelse; eauto. eapply bool_of_val_inject; eauto.
+  apply plus_one. DStep_tac. eapply step_ifthenelse; eauto. eapply bool_of_val_inject; eauto.
   econstructor; eauto. destruct b; auto.
 
 (* loop *)
   monadInv TR.
   left; econstructor; split.
-  apply plus_one. constructor.
+  apply plus_one. DStep_tac. constructor.
   econstructor; eauto.
   econstructor; eauto. simpl. rewrite EQ; auto.
 
 (* block *)
   monadInv TR.
   left; econstructor; split.
-  apply plus_one. constructor.
+  apply plus_one. DStep_tac. constructor.
   econstructor; eauto.
   econstructor; eauto.
 
@@ -2082,33 +2199,34 @@ Opaque PTree.set.
   monadInv TR. left.
   dependent induction MK.
   econstructor; split.
-  apply plus_one. constructor.
+  apply plus_one. DStep_tac. constructor.
   econstructor; eauto. simpl. auto.
+  unfold is_internal in *. simpl in *.
   exploit IHMK; eauto. intros [T2 [A B]].
-  exists T2; split; auto. eapply plus_left. constructor. apply plus_star; eauto. traceEq.
+  exists T2; split; auto. eapply plus_left. DStep_tac. constructor. apply plus_star; eauto. traceEq.
   exploit IHMK; eauto. intros [T2 [A B]].
-  exists T2; split; auto. eapply plus_left.
+  exists T2; split; auto. eapply plus_left. DStep_tac.
   simpl. constructor. apply plus_star; eauto. traceEq.
 
 (* exit block 0 *)
   monadInv TR. left.
   dependent induction MK.
   econstructor; split.
-  simpl. apply plus_one. constructor.
+  simpl. apply plus_one. DStep_tac. constructor.
   econstructor; eauto.
   exploit IHMK; eauto. intros [T2 [A B]].
   exists T2; split; auto. simpl.
-  eapply plus_left. constructor. apply plus_star; eauto. traceEq.
+  eapply plus_left. DStep_tac. constructor. apply plus_star; eauto. traceEq.
 
 (* exit block n+1 *)
   monadInv TR. left.
   dependent induction MK.
   econstructor; split.
-  simpl. apply plus_one. constructor.
+  simpl. apply plus_one. DStep_tac. constructor.
   econstructor; eauto. auto.
   exploit IHMK; eauto. intros [T2 [A B]].
   exists T2; split; auto. simpl.
-  eapply plus_left. constructor. apply plus_star; eauto. traceEq.
+  eapply plus_left. DStep_tac. constructor. apply plus_star; eauto. traceEq.
 
 (* switch *)
   simpl in TR. destruct (switch_table cases O) as [tbl dfl] eqn:STBL. monadInv TR.
@@ -2123,7 +2241,7 @@ Opaque PTree.set.
   exploit switch_match_states; eauto. intros [T2 [F G]].
   left; exists T2; split.
   eapply plus_star_trans. eapply B.
-  eapply star_left. econstructor; eauto.
+  eapply star_left. DStep_tac. econstructor; eauto.
   eapply star_trans. eexact C.
   apply plus_star. eexact F.
   reflexivity. reflexivity. traceEq.
@@ -2133,7 +2251,7 @@ Opaque PTree.set.
   monadInv TR. left.
   exploit match_callstack_freelist; eauto. intros [tm' [A [B C]]].
   econstructor; split.
-  apply plus_one. eapply step_return_0. eauto.
+  apply plus_one. DStep_tac. eapply step_return_0. eauto.
   econstructor; eauto. eapply match_call_cont; eauto.
   simpl; auto.
 
@@ -2142,13 +2260,13 @@ Opaque PTree.set.
   exploit transl_expr_correct; eauto. intros [tv [EVAL VINJ]].
   exploit match_callstack_freelist; eauto. intros [tm' [A [B C]]].
   econstructor; split.
-  apply plus_one. eapply step_return_1. eauto. eauto.
+  apply plus_one. DStep_tac. eapply step_return_1. eauto. eauto.
   econstructor; eauto. eapply match_call_cont; eauto.
 
 (* label *)
   monadInv TR.
   left; econstructor; split.
-  apply plus_one. constructor.
+  apply plus_one. DStep_tac. constructor.
   econstructor; eauto.
 
 (* goto *)
@@ -2156,7 +2274,7 @@ Opaque PTree.set.
   exploit transl_find_label_body; eauto.
   intros [ts' [tk' [xenv' [A [B C]]]]].
   left; econstructor; split.
-  apply plus_one. apply step_goto. eexact A.
+  apply plus_one. DStep_tac. apply step_goto. eexact A.
   econstructor; eauto.
 
 (* internal call *)
@@ -2174,18 +2292,20 @@ Opaque PTree.set.
   exploit match_callstack_function_entry; eauto. simpl; eauto. simpl; auto.
   intros [f2 [MCS2 MINJ2]].
   left; econstructor; split.
-  apply plus_one. constructor; simpl; eauto.
+  apply plus_one. DStep_tac. constructor; simpl; eauto.
   econstructor. eexact TRBODY. eauto. eexact MINJ2. eexact MCS2.
   inv MK; simpl in ISCC; contradiction || econstructor; eauto.
 
-(* external call *)
+(* external call *) 
+  unfold is_internal in INT. simpl in INT.
   monadInv TR.
   exploit match_callstack_match_globalenvs; eauto. intros [hi MG].
   exploit external_call_mem_inject; eauto.
+  simpl in *. eapply external_call_spec; eauto.
   eapply inj_preserves_globals; eauto.
   intros [f' [vres' [tm' [EC [VINJ [MINJ' [UNMAPPED [OUTOFREACH [INCR SEPARATED]]]]]]]]].
   left; econstructor; split.
-  apply plus_one. econstructor.
+  apply plus_one. DStep_tac. econstructor.
   eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   econstructor; eauto.
   apply match_callstack_incr_bound with (Mem.nextblock m) (Mem.nextblock tm).
@@ -2198,7 +2318,7 @@ Opaque PTree.set.
 (* return *)
   inv MK. simpl.
   left; econstructor; split.
-  apply plus_one. econstructor; eauto.
+  apply plus_one. DStep_tac. econstructor; eauto.
   unfold set_optvar. destruct optid; simpl; econstructor; eauto.
   eapply match_callstack_set_temp; eauto.
 Qed.
@@ -2240,6 +2360,115 @@ Proof.
   constructor.
 Qed.
 
+Lemma match_states_bsim s1
+      (EXT: Csharpminor.is_external ge s1)
+      s2 t s2' (STEPTGT: Step tsem s2 t s2')
+      (MATCH: match_states s1 s2)
+      (SAFESRC: safe sem s1) :
+    (exists s1', Step sem s1 t s1' /\ match_states s1' s2')
+  \/ (~ trace_intact t /\ exists s1'' t', Star sem s1 t' s1'' /\ exists tl, t' = (trace_cut_pterm t) ** tl).
+Proof.
+  assert (SEQUIV: Senv.equiv tge ge) by (symmetry; apply senv_preserved).
+  unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+  { inv SAFESRC. inv MATCH. inv MK. inv STEPTGT. }
+  unfold Csharpminor.is_external in *. des_ifs.
+  (* builtin *)
+  - inv MATCH; try (monadInv TR); clarify.
+    inv STEPTGT; ss; clarify. inv SAFESRC; ss; clarify; try (by (des; clarify)).
+
+    exploit transl_exprlist_correct; eauto.
+    intros [tvargs [EVAL2 VINJ2]].
+    determ_tac eval_exprlist_determ.
+
+    exploit match_callstack_match_globalenvs; eauto. intros [hi' MG].
+    exploit external_call_mem_inject_backward.
+    2:{ eapply inj_preserves_globals; eauto. }
+    2:{ eapply external_call_symbols_preserved; eauto. }
+    all: eauto.
+    intros [[f' [vres' [sm' [EC [VINJ [MINJ' [UNMAPPED [OUTOFREACH [INCR SEPARATED]]]]]]]]] | [UBSRC | OOM]].
+    + left. esplits; eauto.
+      eapply Csharpminor.step_builtin; eauto.
+
+      assert (MCS': match_callstack f' sm' m'
+                                    (Frame cenv tfn e le te sp lo hi :: cs)
+                                    (Mem.nextblock sm') (Mem.nextblock m')).
+      apply match_callstack_incr_bound with (Mem.nextblock m) (Mem.nextblock tm).
+      eapply match_callstack_external_call; eauto.
+      intros. eapply external_call_max_perm; eauto.
+      extlia. extlia.
+      eapply external_call_nextblock; eauto.
+      eapply external_call_nextblock; eauto.
+      econstructor; eauto.
+      Opaque PTree.set.
+      unfold set_optvar. destruct o; simpl.
+      eapply match_callstack_set_temp; eauto. auto.
+    + exploit UBSRC; eauto. clarify.
+    + des. right. esplits; eauto. eapply star_one.
+      eapply Csharpminor.step_builtin; eauto.
+  (* external call *)
+  - inv MATCH; try (monadInv TR); clarify.
+    inv STEPTGT; ss; clarify. inv SAFESRC; ss; clarify; try (by (des; clarify)).
+
+    exploit match_callstack_match_globalenvs; eauto. intros [hi' MG].
+    exploit external_call_mem_inject_backward.
+    2:{ eapply inj_preserves_globals; eauto. }
+    2:{ eapply external_call_symbols_preserved; eauto. }
+    all: eauto.
+    intros [[f' [vres' [sm' [EC [VINJ [MINJ' [UNMAPPED [OUTOFREACH [INCR SEPARATED]]]]]]]]] | [UBSRC | OOM]].
+
+    + left. esplits; eauto.
+      eapply Csharpminor.step_external_function; eauto.
+
+      econstructor; eauto.
+      apply match_callstack_incr_bound with (Mem.nextblock m) (Mem.nextblock tm).
+      eapply match_callstack_external_call; eauto.
+      intros. eapply external_call_max_perm; eauto.
+      extlia. extlia.
+      eapply external_call_nextblock; eauto.
+      eapply external_call_nextblock; eauto.
+    + exploit UBSRC; eauto. clarify.
+    + des. right. esplits; eauto. eapply star_one.
+      eapply Csharpminor.step_external_function; eauto.
+Qed.
+
+Lemma match_states_xsim st_src0 st_tgt0 gmtgt
+    (MATCH: match_states st_src0 st_tgt0) :
+  xsim (Csharpminor.semantics prog) (Cminor.semantics tprog) gmtgt lt (measure st_src0)%nat st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold. destruct (classic (Csharpminor.is_external ge st_src0)); cycle 1.
+  (* not external *)
+  - left. econs. econs.
+    + i. exploit transl_step_correct; eauto. i. des.
+      * esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl|].
+        left. split; eauto. eapply CsharpminorD.semantics_receptive_at; auto.
+      * subst. esplits; [econs|right; esplits; eauto|].
+        { right. eapply CIH; eauto. }
+    + ii. eapply final_state_determ; eauto.
+      inv FINALSRC. inv MATCH. inv MK. inv MCS. inv RESINJ. econs.
+  (* external *)
+  - right. econs. i. econs.
+    + i. exploit match_states_bsim; eauto. i. des.
+      * left. esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl|].
+        left. eapply plus_one. eauto.
+      * right. esplits; eauto; [subst; eapply tr_rel_refl; eapply ev_rel_refl].
+    + i. unfold is_external in *. des_ifs; inv FINALTGT; inv MATCH. ss.
+    (* progress *)
+    + i. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify; [inv SAFESRC; ss|].
+      right. inv SAFESRC; ss; clarify; try (by (des; clarify)); inv MATCH; try (monadInv TR).
+      * exploit transl_exprlist_correct; eauto. intros [tvargs [EVAL2 VINJ2]].
+        exploit match_callstack_match_globalenvs; eauto. intros [hi' MG].
+        exploit external_call_mem_inject_backward_progress; eauto.
+        eapply inj_preserves_globals; eauto. i. des.
+        esplits. eapply step_builtin; eauto.
+        eapply external_call_symbols_preserved; eauto. eapply senv_preserved.
+      * exploit match_callstack_match_globalenvs; eauto. intros [hi' MG].
+        exploit external_call_mem_inject_backward_progress; eauto.
+        eapply inj_preserves_globals; eauto. i. des.
+        exploit external_call_symbols_preserved. apply senv_preserved. eauto. i.
+        esplits. eapply step_external_function; eauto.
+Qed.
+
 Lemma transl_final_states:
   forall S R r,
   match_states S R -> Csharpminor.final_state S r -> Cminor.final_state R r.
@@ -2247,14 +2476,77 @@ Proof.
   intros. inv H0. inv H. inv MK. inv RESINJ. constructor.
 Qed.
 
+Lemma non_static_equiv j l hi (MGE: match_globalenvs j hi):
+  Forall2 (fun b b' => j b = Some (b', 0)) (Genv.non_static_glob (Genv.globalenv prog) l) (Genv.non_static_glob (Genv.globalenv tprog) l).
+Proof.
+  induction l; ss.
+  destruct (Genv.find_symbol (Genv.globalenv prog) a) eqn:FS1; cycle 1.
+  - destruct (Genv.find_symbol (Genv.globalenv tprog) a) eqn:FS2; cycle 1.
+    { unfold Genv.public_symbol. des_ifs. }
+    destruct senv_preserved. des. unfold Senv.find_symbol in *. ss. erewrite H in FS2.
+    Local Transparent ge tge. unfold ge, fundef in *. ss. clarify.
+  - destruct (Genv.public_symbol (Genv.globalenv prog) a) eqn:PS1; cycle 1.
+    { des_ifs. destruct senv_preserved. des. ss. erewrite H0 in Heq.
+      unfold ge, fundef in *. clarify. }
+    destruct senv_preserved. des. ss. erewrite <- H0 in PS1.
+    unfold ge, tge, fundef in *. erewrite PS1. erewrite H, FS1. econs; eauto.
+    inv MGE. eapply DOMAIN. eapply SYMBOLS; eauto.
+Qed.
+
+Lemma transf_initial_capture S1 S2 S2'
+    (INITSRC: Csharpminor.initial_state prog S1)
+    (INITTGT: Cminor.initial_state tprog S2)
+    (MATCH: match_states S1 S2)
+    (CAPTGT: Cminor.glob_capture tprog S2 S2'):
+  exists S1', Csharpminor.glob_capture prog S1 S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (Csharpminor.concrete_snapshot ge S1') (concrete_snapshot tge S2').
+Proof.
+  specialize senv_preserved. intros SENVEQ.
+  inv CAPTGT. ss. rename m' into m2'.
+  rewrite Genv.globalenv_public in CAPTURE. erewrite <- same_public in CAPTURE; eauto.
+  inv MATCH. inv MK. inv ARGSINJ. inv ISCC. inv MCS.
+  exploit non_static_equiv. eapply H. instantiate (1:=AST.prog_public prog). intros EQUIV.
+  assert (exists m1', Genv.capture_init_mem m0 (Genv.non_static_glob (Genv.globalenv prog) (AST.prog_public prog)) m1' /\
+                     Mem.inject f0 m1' m2').
+  { clear - SENVEQ MINJ EQUIV CAPTURE. ginduction EQUIV; ss; ii.
+    - exists m0. inv CAPTURE. inv CAP. esplits; eauto. econs. econs.
+    - inv CAPTURE. inv CAP.
+      exploit Mem.capture_inject_backward; try eapply INJ; eauto.
+      { instantiate (2:=addr). instantiate (1:= m2). rewrite Z.sub_0_r. eauto. }
+      i. des. exploit IHEQUIV; try eapply MEM. eauto. econs; eauto. i. des.
+      inv H0. esplits; eauto. econs; eauto. econs; eauto. }
+  des. esplits; eauto.
+  - econs; try eapply H2; eauto. ss. rewrite Genv.globalenv_public. eauto.
+  - econs; eauto; cycle 1;[econs| |].
+    i. econs; eauto. econs; eauto.
+    { inv H2. eapply Mem.capture_list_nextblock in CAP. rewrite <- CAP; eauto. }
+    { inv CAPTURE. eapply Mem.capture_list_nextblock in CAP. rewrite <- CAP. eauto. }
+  - ii. unfold Csharpminor.concrete_snapshot, concrete_snapshot in *.
+    ss. destruct senv_preserved. des. unfold Senv.find_symbol, Senv.public_symbol in *. ss.
+    erewrite H6, H5. des_ifs; ss.
+    assert (f0 b = Some (b, 0)).
+    { inv H. exploit SYMBOLS; eauto. }
+    inv H3. exploit mi_src_concrete_public; eauto. i. erewrite H3. f_equal. lia.
+Unshelve. econs.
+Qed.
+
 Theorem transl_program_correct:
-  forward_simulation (Csharpminor.semantics prog) (Cminor.semantics tprog).
-Proof.
-  eapply forward_simulation_star; eauto.
-  apply senv_preserved.
-  eexact transl_initial_states.
-  eexact transl_final_states.
-  eexact transl_step_correct.
+  mixed_simulation (Csharpminor.semantics prog) (Cminor.semantics tprog).
+Proof.
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (S a). lia.
+  - econs. i. exploit transl_initial_states; eauto. i. des.
+    exists R. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. inversion INITSRC; subst. inversion H0; subst.
+      inv MK. inv ARGSINJ.
+      exploit transf_initial_capture; [eapply INITSRC|eapply H|eapply H0|eauto|].
+      i. des. esplits; eauto. apply match_states_xsim; auto.
+  - i. apply senv_preserved.
 Qed.
 
 End TRANSLATION.
diff --git a/cfrontend/Cop.v b/cfrontend/Cop.v
index f6524124..4f1b27de 100644
--- a/cfrontend/Cop.v
+++ b/cfrontend/Cop.v
@@ -24,6 +24,7 @@ Require Import Values.
 Require Import Memory.
 Require Import Ctypes.
 Require Archi.
+Require Import IntPtrRel.
 
 (** * Syntax of operators. *)
 
@@ -74,6 +75,7 @@ Inductive incr_or_decr : Type := Incr | Decr.
 (** ** Casts and truth values *)
 
 Inductive classify_cast_cases : Type :=
+  | cast_case_pointer2int                          (**r pointer -> integer *) 
   | cast_case_pointer                              (**r between pointer types or intptr_t types *)
   | cast_case_i2i (sz2:intsize) (si2:signedness)   (**r int -> int *)
   | cast_case_f2f                                  (**r double -> double *)
@@ -121,7 +123,7 @@ Definition classify_cast (tfrom tto: type) : classify_cast_cases :=
   | Tint sz2 si2 _, Tfloat F32 _ => cast_case_s2i sz2 si2
   | Tint sz2 si2 _, (Tpointer _ _ | Tarray _ _ _ | Tfunction _ _ _) =>
       if Archi.ptr64 then cast_case_l2i sz2 si2
-      else if intsize_eq sz2 I32 then cast_case_pointer
+      else if intsize_eq sz2 I32 then cast_case_pointer2int
       else cast_case_i2i sz2 si2
   (* To [long] *)
   | Tlong _ _, Tlong _ _ =>
@@ -130,7 +132,7 @@ Definition classify_cast (tfrom tto: type) : classify_cast_cases :=
   | Tlong si2 _, Tfloat F64 _ => cast_case_f2l si2
   | Tlong si2 _, Tfloat F32 _ => cast_case_s2l si2
   | Tlong si2 _, (Tpointer _ _ | Tarray _ _ _ | Tfunction _ _ _) =>
-      if Archi.ptr64 then cast_case_pointer else cast_case_i2l si2
+      if Archi.ptr64 then cast_case_pointer2int else cast_case_i2l si2
   (* To [float] *)
   | Tfloat F64 _, Tint sz1 si1 _ => cast_case_i2f si1
   | Tfloat F32 _, Tint sz1 si1 _ => cast_case_i2s si1
@@ -221,9 +223,38 @@ Definition cast_single_long (si : signedness) (f: float32) : option int64 :=
   | Unsigned => Float32.to_longu f
   end.
 
+Definition simple_cast (tfrom tto: type) : bool :=
+  match tto, tfrom with
+  (* To [int] other than [_Bool] *)
+  | Tint sz2 si2 _, (Tpointer _ _ | Tarray _ _ _ | Tfunction _ _ _) =>
+      if Archi.ptr64 then true
+      else if intsize_eq sz2 I32 then false
+      else true
+  (* To [long] *)
+  | Tlong si2 _, (Tpointer _ _ | Tarray _ _ _ | Tfunction _ _ _) =>
+      if Archi.ptr64 then false else true
+  | _, _ => true
+  end.
+
+Lemma simple_classify_cast_true
+      ty ty'
+  :
+    simple_cast ty ty' = false <-> classify_cast ty ty' = cast_case_pointer2int.
+Proof.
+  unfold simple_cast, classify_cast. des_ifs.
+Qed.
+
+Lemma simple_classify_cast_false
+      ty ty'
+  :
+    simple_cast ty ty' = true <-> classify_cast ty ty' <> cast_case_pointer2int.
+Proof.
+  unfold simple_cast, classify_cast. des_ifs.
+Qed.
+
 Definition sem_cast (v: val) (t1 t2: type) (m: mem): option val :=
   match classify_cast t1 t2 with
-  | cast_case_pointer =>
+  | cast_case_pointer | cast_case_pointer2int =>
       match v with
       | Vptr _ _ => Some v
       | Vint _ => if Archi.ptr64 then None else Some v
@@ -708,6 +739,100 @@ Definition classify_sub (ty1: type) (ty2: type) :=
   | _, _ => sub_default
   end.
 
+Definition _sem_ptr_sub (v1 v2: val) : option ptrofs :=
+  match v1, v2 with
+  | Vint n1, Vint n2 => if negb Archi.ptr64 then Some (Ptrofs.of_int (Int.sub n1 n2)) else None
+  | Vlong n1, Vlong n2 => if Archi.ptr64 then Some (Ptrofs.of_int64 (Int64.sub n1 n2)) else None
+  | Vptr b1 ofs1, Vptr b2 ofs2 => if eq_block b1 b2 then Some (Ptrofs.sub ofs1 ofs2) else None
+  | _, _ => None
+  end.
+
+Definition _sem_ptr_sub_join (v1 v2: val) (m:mem) : option ptrofs :=
+  match (_sem_ptr_sub (to_ptr_val m v1) (to_ptr_val m v2)),
+        (_sem_ptr_sub (to_int_val m v1) (to_int_val m v2)) with
+  | Some n1, Some n2 => if Ptrofs.eq n1 n2 then Some n1 else None
+  | Some n1, None => Some n1
+  | None, Some n2 => Some n2
+  | _, _ => None
+  end.
+
+Lemma _sem_ptr_sub_psub v1 v2 n (SF: Archi.ptr64 = false) :
+  _sem_ptr_sub v1 v2 = Some n <-> Val.psub v1 v2 = Vint (Ptrofs.to_int n).
+Proof.
+  unfold _sem_ptr_sub. rewrite SF. simpl.
+  destruct v1; destruct v2; split; i; simpl in *; try rewrite SF in *; inv H.
+  - rewrite Ptrofs.to_int_of_int; eauto.
+  - erewrite <- (Ptrofs.of_int_to_int SF n). des_ifs.
+  - destruct (eq_block b b0); inv H1; eauto.
+  - destruct (eq_block b b0); inv H1; eauto.
+    erewrite <- (Ptrofs.of_int_to_int SF n).
+    erewrite <- (Ptrofs.of_int_to_int SF (Ptrofs.sub i i0)). des_ifs.
+Qed.
+
+Lemma _sem_ptr_sub_psubl v1 v2 n (SF: Archi.ptr64 = true) :
+  _sem_ptr_sub v1 v2 = Some n <-> Val.psubl v1 v2 = Vlong (Ptrofs.to_int64 n).
+Proof.
+  unfold _sem_ptr_sub. rewrite SF. simpl.
+  destruct v1; destruct v2; split; i; simpl in *; try rewrite SF in *; inv H.
+  - rewrite Ptrofs.to_int64_of_int64; eauto.
+  - erewrite <- (Ptrofs.of_int64_to_int64 SF n). des_ifs.
+  - destruct (eq_block b b0); inv H1; eauto.
+  - destruct (eq_block b b0); inv H1; eauto.
+    erewrite <- (Ptrofs.of_int64_to_int64 SF n).
+    erewrite <- (Ptrofs.of_int64_to_int64 SF (Ptrofs.sub i i0)). des_ifs.
+Qed.
+
+Lemma _sem_ptr_sub_psub_fail
+    v1 v2
+    (SF: Archi.ptr64 = false) :
+  _sem_ptr_sub v1 v2 = None <-> Val.psub v1 v2 = Vundef.
+Proof.
+  unfold _sem_ptr_sub. rewrite SF. simpl.
+  destruct v1; destruct v2; split; i; simpl in *; try rewrite SF in *; inv H; eauto.
+  - destruct (eq_block b b0); inv H1; eauto.
+  - destruct (eq_block b b0); inv H1; eauto.
+Qed.
+
+Lemma _sem_ptr_sub_psubl_fail
+    v1 v2
+    (SF: Archi.ptr64 = true) :
+  _sem_ptr_sub v1 v2 = None <-> Val.psubl v1 v2 = Vundef.
+Proof.
+  unfold _sem_ptr_sub. rewrite SF. simpl.
+  destruct v1; destruct v2; split; i; simpl in *; try rewrite SF in *; inv H; eauto.
+  - destruct (eq_block b b0); inv H1; eauto.
+  - destruct (eq_block b b0); inv H1; eauto.
+Qed.
+
+Lemma _sem_ptr_sub_no_angelic
+    v1 v2 m rp ri
+    (PCMP: _sem_ptr_sub (to_ptr_val m v1) (to_ptr_val m v2) = Some rp)
+    (ICMP: _sem_ptr_sub (to_int_val m v1) (to_int_val m v2) = Some ri) :
+  <<NOANGELIC: rp = ri>>.
+Proof.
+  destruct Archi.ptr64 eqn:SF.
+  - rewrite _sem_ptr_sub_psubl in *; eauto.
+    exploit psubl_wrapper_no_angelic; eauto. i; des; inv H.
+    erewrite <- (Ptrofs.of_int64_to_int64 SF rp).
+    erewrite <- (Ptrofs.of_int64_to_int64 SF ri). des_ifs.
+  - rewrite _sem_ptr_sub_psub in *; eauto.
+    exploit psub_wrapper_no_angelic; eauto. i; des; inv H.
+    erewrite <- (Ptrofs.of_int_to_int SF rp).
+    erewrite <- (Ptrofs.of_int_to_int SF ri). des_ifs.
+Qed.
+
+Definition _sem_ptr_sub_join_common (v1 v2: val) (m: mem) : option ptrofs :=
+  match v1, v2 with
+  | Vint n1, Vint n2 => _sem_ptr_sub v1 v2
+  | Vlong n1, Vlong n2 => _sem_ptr_sub v1 v2
+  | Vptr _ _, Vptr _ _ => _sem_ptr_sub v1 v2
+  | Vptr _ _, Vint _ => _sem_ptr_sub_join v1 v2 m
+  | Vint _, Vptr _ _ => _sem_ptr_sub_join v1 v2 m
+  | Vptr _ _, Vlong _ => _sem_ptr_sub_join v1 v2 m
+  | Vlong _, Vptr _ _ => _sem_ptr_sub_join v1 v2 m
+  | _, _ => None
+  end.
+
 Definition sem_sub (cenv: composite_env) (v1:val) (t1:type) (v2: val) (t2:type) (m:mem): option val :=
   match classify_sub t1 t2 with
   | sub_case_pi ty si =>            (**r pointer minus integer *)
@@ -735,15 +860,13 @@ Definition sem_sub (cenv: composite_env) (v1:val) (t1:type) (v2: val) (t2:type)
       | _,  _ => None
       end
   | sub_case_pp ty =>          (**r pointer minus pointer *)
-      match v1,v2 with
-      | Vptr b1 ofs1, Vptr b2 ofs2 =>
-          if eq_block b1 b2 then
-            let sz := sizeof cenv ty in
-            if zlt 0 sz && zle sz Ptrofs.max_signed
-            then Some (Vptrofs (Ptrofs.divs (Ptrofs.sub ofs1 ofs2) (Ptrofs.repr sz)))
-            else None
+      match (_sem_ptr_sub_join_common v1 v2 m) with
+      | Some n =>
+          let sz := sizeof cenv ty in
+          if zlt 0 sz && zle sz Ptrofs.max_signed
+          then Some (Vptrofs (Ptrofs.divs n (Ptrofs.repr sz)))
           else None
-      | _, _ => None
+      | _ => None
       end
   | sub_default =>
       sem_binarith
@@ -935,8 +1058,8 @@ Definition classify_cmp (ty1: type) (ty2: type) :=
 Definition cmp_ptr (m: mem) (c: comparison) (v1 v2: val): option val :=
   option_map Val.of_bool
    (if Archi.ptr64
-    then Val.cmplu_bool (Mem.valid_pointer m) c v1 v2
-    else Val.cmpu_bool (Mem.valid_pointer m) c v1 v2).
+    then cmplu_join_common m c v1 v2
+    else cmpu_join_common m c v1 v2).
 
 Definition sem_cmp (c:comparison)
                   (v1: val) (t1: type) (v2: val) (t2: type)
@@ -1152,6 +1275,7 @@ Lemma sem_cast_inj:
 Proof.
   unfold sem_cast; intros; destruct (classify_cast ty1 ty); inv H0; TrivialInject.
 - econstructor; eauto.
+- econstructor; eauto.
 - erewrite weak_valid_pointer_inj by eauto. TrivialInject. 
 - erewrite weak_valid_pointer_inj by eauto. TrivialInject. 
 - destruct (ident_eq id1 id2); TrivialInject. econstructor; eauto.
@@ -1239,6 +1363,25 @@ Proof.
   destruct (Int.ltu i0 Int64.iwordsize'); inv H; auto.
 Qed.
 
+Hypothesis inj_perm: forall b1 b2 delta ofs k p,
+    f b1 = Some (b2, delta) ->
+    Mem.perm m b1 ofs k p -> Mem.perm m' b2 (ofs + delta) k p.
+
+Hypothesis src_concrete_private: forall b, f b = None -> Maps.PTree.get b (Mem.mem_concrete m) = None.
+
+Hypothesis mappedblocks: forall b b' delta, Mem.valid_block m b -> f b = Some (b', delta) -> Mem.valid_block m' b'.
+
+Hypothesis src_concrete_public: forall b1 b2 addr delta,
+    f b1 = Some (b2, delta) ->
+    Maps.PTree.get b1 (Mem.mem_concrete m) = Some addr ->
+    Maps.PTree.get b2 (Mem.mem_concrete m') = Some (addr - delta).
+
+Hypothesis representable: forall b b' delta ofs,
+    f b = Some (b', delta) ->
+    Mem.perm m b (Ptrofs.unsigned ofs) Max Nonempty \/
+    Mem.perm m b (Ptrofs.unsigned ofs - 1) Max Nonempty ->
+    delta >= 0 /\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.
+
 Remark sem_cmp_ptr_inj:
   forall c v1 v2 v tv1 tv2,
   cmp_ptr m c v1 v2 = Some v ->
@@ -1246,15 +1389,15 @@ Remark sem_cmp_ptr_inj:
   Val.inject f v2 tv2 ->
   exists tv, cmp_ptr m' c tv1 tv2 = Some tv /\ Val.inject f v tv.
 Proof.
-  unfold cmp_ptr; intros. 
+  unfold cmp_ptr; intros.
   remember (if Archi.ptr64
-       then Val.cmplu_bool (Mem.valid_pointer m) c v1 v2
-       else Val.cmpu_bool (Mem.valid_pointer m) c v1 v2) as ob.
+       then cmplu_join_common m c v1 v2
+       else cmpu_join_common m c v1 v2) as ob.
   destruct ob as [b|]; simpl in H; inv H.
   exists (Val.of_bool b); split; auto.
-  destruct Archi.ptr64. 
-  erewrite Val.cmplu_bool_inject by eauto. auto.
-  erewrite Val.cmpu_bool_inject by eauto. auto.
+  destruct Archi.ptr64.
+  erewrite cmplu_join_common_inj by eauto. auto.
+  erewrite cmpu_join_common_inj by eauto. auto.
 Qed.
 
 Remark sem_cmp_inj:
@@ -1284,6 +1427,66 @@ Proof.
   eapply sem_binarith_inject; eauto.
 Qed.
 
+Remark _sem_ptr_sub_inj
+    v1 v2 tv1 tv2 p
+    (PSUB: _sem_ptr_sub v1 v2 = Some p)
+    (INJ1: Val.inject f v1 tv1)
+    (INJ2: Val.inject f v2 tv2) :  
+  <<PSUB: _sem_ptr_sub tv1 tv2 = Some p>>.
+Proof.
+  unfold _sem_ptr_sub in PSUB.
+  inv INJ1; inv INJ2; TrivialInject; simpl in *; try rewrite Heqb; eauto.
+  destruct (eq_block b1 b0); try discriminate. subst b1.
+  rewrite H0 in H. inv H. rewrite dec_eq_true.
+  rewrite Ptrofs.sub_shifted. TrivialInject. eauto.
+Qed.
+         
+Remark _sem_ptr_sub_join_inj
+    v1 v2 tv1 tv2 p
+    (PSUB: _sem_ptr_sub_join v1 v2 m = Some p)
+    (INJ1: Val.inject f v1 tv1)
+    (INJ2: Val.inject f v2 tv2) :  
+  <<PSUB: _sem_ptr_sub_join tv1 tv2 m' = Some p>>.
+Proof.
+  exploit to_ptr_val_inject'; try eapply INJ1; eauto. exploit to_ptr_val_inject'; try eapply INJ2; eauto. 
+  exploit to_int_val_inject'; try eapply INJ1; eauto. exploit to_int_val_inject'; try eapply INJ2; eauto. 
+  i; des. unfold _sem_ptr_sub_join in PSUB. des_ifs.
+  - exploit _sem_ptr_sub_inj; try eapply Heq; eauto. intros PSUBT.
+    exploit _sem_ptr_sub_inj; try eapply Heq0; eauto. intros PSUBT'.
+    unfold _sem_ptr_sub_join. rewrite PSUBT, PSUBT'. des_ifs.
+  - exploit _sem_ptr_sub_inj; try eapply Heq; eauto. intros PSUBT.
+    unfold _sem_ptr_sub_join. rewrite PSUBT. des_ifs; eauto.
+    exploit _sem_ptr_sub_no_angelic; try eapply PSUBT; eauto. i.
+    des; subst. rewrite Ptrofs.eq_true in Heq2; ss.
+  - exploit _sem_ptr_sub_inj; try eapply Heq0; eauto. intros PSUBT'.
+    unfold _sem_ptr_sub_join. rewrite PSUBT'. des_ifs; eauto.
+    + exploit _sem_ptr_sub_no_angelic; try eapply PSUBT'; eauto. i.
+      des; subst. eauto.
+    + exploit _sem_ptr_sub_no_angelic; try eapply PSUBT'; eauto. i.
+      des; subst. rewrite Ptrofs.eq_true in Heq2; ss.
+Qed.
+
+Remark _sem_ptr_sub_join_common_inj
+    v1 v2 tv1 tv2 p
+    (PSUB: _sem_ptr_sub_join_common v1 v2 m = Some p)
+    (INJ1: Val.inject f v1 tv1)
+    (INJ2: Val.inject f v2 tv2) :  
+  <<PSUB: _sem_ptr_sub_join_common tv1 tv2 m' = Some p>>.
+Proof.
+  destruct v1; destruct v2; ss.
+  - exploit _sem_ptr_sub_join_inj; eauto. i.
+    inv INJ1; inv INJ2; ss.
+  - des_ifs. inv INJ1; inv INJ2; ss.
+  - exploit _sem_ptr_sub_join_inj; eauto. i.
+    inv INJ1; inv INJ2; ss.
+  - exploit _sem_ptr_sub_join_inj; eauto. i.
+    inv INJ1; inv INJ2; ss.
+  - exploit _sem_ptr_sub_join_inj; eauto. i.
+    inv INJ1; inv INJ2; ss.
+  - des_ifs. inv INJ1; inv INJ2; ss. clarify. des_ifs.
+    rewrite Ptrofs.sub_shifted. eauto.
+Qed.
+
 Lemma sem_binary_operation_inj:
   forall cenv op v1 ty1 v2 ty2 v tv1 tv2,
   sem_binary_operation cenv op v1 ty1 v2 ty2 m = Some v ->
@@ -1310,11 +1513,10 @@ Proof.
   unfold sem_sub in *; destruct (classify_sub ty1 ty2).
   + inv H0; inv H1; TrivialInject.
     econstructor. eauto. rewrite Ptrofs.sub_add_l. auto. 
-  + inv H0; inv H1; TrivialInject.
-    destruct (eq_block b1 b0); try discriminate. subst b1.
-    rewrite H0 in H2; inv H2. rewrite dec_eq_true.
+  + destruct (_sem_ptr_sub_join_common v1 v2 m) eqn:PSUB; ss.
+    exploit _sem_ptr_sub_join_common_inj; eauto. i. des. rewrite H2.
     destruct (zlt 0 (sizeof cenv ty) && zle (sizeof cenv ty) Ptrofs.max_signed); inv H.
-    rewrite Ptrofs.sub_shifted. TrivialInject.
+    esplits; eauto.
   + inv H0; inv H1; TrivialInject.
     econstructor. eauto. rewrite Ptrofs.sub_add_l. auto. 
   + eapply sem_binarith_inject; eauto; intros; exact I.
@@ -1399,6 +1601,11 @@ Proof.
   intros; eapply Mem.weak_valid_pointer_inject_val; eauto.
   intros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.
   intros; eapply Mem.different_pointers_inject; eauto.
+  eapply Mem.mi_perm; eapply Mem.mi_inj; eauto.
+  eapply Mem.mi_src_concrete_private; eauto.
+  intros. eapply Mem.mi_mappedblocks; eauto.
+  intros. eapply Mem.mi_src_concrete_public; eauto.
+  eapply Mem.mi_representable; eauto.
 Qed.
 
 Lemma bool_val_inject:
diff --git a/cfrontend/Csem.v b/cfrontend/Csem.v
index 724c1c9e..f8fca7a2 100644
--- a/cfrontend/Csem.v
+++ b/cfrontend/Csem.v
@@ -827,24 +827,54 @@ Inductive final_state: state -> int -> Prop :=
   | final_state_intro: forall r m,
       final_state (Returnstate (Vint r) Kstop m) r.
 
+(** Non-deterministic external state *)
+
+Definition is_external (ge: genv) (st: state) : Prop := False.
+
+Inductive glob_capture (p: program) : state -> state -> Prop :=
+  | glob_capture_intro
+      f m pbs m'
+      (* (INIT: initial_state p (Callstate nil f nil m)) *)
+      (NONSTATIC: Genv.non_static_glob (Genv.globalenv p) (Genv.genv_public (Genv.globalenv p)) = pbs)
+      (CAPTURE: Genv.capture_init_mem m pbs m') :
+    glob_capture p (Callstate f nil Kstop m) (Callstate f nil Kstop m').
+
+Definition state_mem (st: state) : mem :=
+  match st with
+  | State _ _ _ _ m => m
+  | ExprState _ _ _ _ m => m
+  | Callstate _ _ _ m => m
+  | Returnstate _ _ m => m
+  | Stuckstate => Mem.empty
+  end.
+
+Definition concrete_snapshot (ge: Senv.t) (st: state) (id: ident) : option Z :=
+  if Senv.public_symbol ge id
+  then (match Senv.find_symbol ge id with
+        | Some b => Maps.PTree.get b (state_mem st).(Mem.mem_concrete)
+        | None => None
+        end
+    )
+  else None.
+
 (** Wrapping up these definitions in a small-step semantics. *)
 
 Definition semantics (p: program) :=
-  Semantics_gen step (initial_state p) final_state (globalenv p) (globalenv p).
+  Semantics_gen step (initial_state p) (glob_capture p) (concrete_snapshot (Genv.globalenv p)) final_state is_external (globalenv p) (globalenv p).
 
 (** This semantics has the single-event property. *)
 
-Lemma semantics_single_events:
-  forall p, single_events (semantics p).
-Proof.
-  unfold semantics; intros; red; simpl; intros.
-  set (ge := globalenv p) in *.
-  assert (DEREF: forall chunk m b ofs t v, deref_loc ge chunk m b ofs t v -> (length t <= 1)%nat).
-    intros. inv H0; simpl; try lia. inv H3; simpl; try lia.
-  assert (ASSIGN: forall chunk m b ofs t v m', assign_loc ge chunk m b ofs v t m' -> (length t <= 1)%nat).
-    intros. inv H0; simpl; try lia. inv H3; simpl; try lia.
-  destruct H.
-  inv H; simpl; try lia. inv H0; eauto; simpl; try lia.
-  eapply external_call_trace_length; eauto.
-  inv H; simpl; try lia. eapply external_call_trace_length; eauto.
-Qed.
+(* Lemma semantics_single_events: *)
+(*   forall p, single_events (semantics p). *)
+(* Proof. *)
+(*   unfold semantics; intros; red; simpl; intros. *)
+(*   set (ge := globalenv p) in *. *)
+(*   assert (DEREF: forall chunk m b ofs t v, deref_loc ge chunk m b ofs t v -> (length t <= 1)%nat). *)
+(*     intros. inv H0; simpl; try lia. inv H3; simpl; try lia. *)
+(*   assert (ASSIGN: forall chunk m b ofs t v m', assign_loc ge chunk m b ofs v t m' -> (length t <= 1)%nat). *)
+(*     intros. inv H0; simpl; try lia. inv H3; simpl; try lia. *)
+(*   destruct H. *)
+(*   inv H; simpl; try lia. inv H0; eauto; simpl; try lia. *)
+(*   eapply external_call_trace_length; eauto. *)
+(*   inv H; simpl; try lia. eapply external_call_trace_length; eauto. *)
+(* Qed. *)
diff --git a/cfrontend/Csharpminor.v b/cfrontend/Csharpminor.v
index 4393640c..8ff7b467 100644
--- a/cfrontend/Csharpminor.v
+++ b/cfrontend/Csharpminor.v
@@ -24,6 +24,7 @@ Require Import Globalenvs.
 Require Import Switch.
 Require Cminor.
 Require Import Smallstep.
+Require Import Simulation.
 
 (** Abstract syntax *)
 
@@ -263,6 +264,17 @@ Definition eval_unop := Cminor.eval_unop.
 
 Definition eval_binop := Cminor.eval_binop.
 
+Definition eval_binop_wrapper := Cminor.eval_binop_wrapper.
+
+Ltac unfold_wrapper := unfold eval_binop_wrapper, Cminor.eval_binop_wrapper, Cminor.eval_binop_join in *.
+
+Lemma eval_binop_no_ptr_binop
+  op arg1 arg2 m
+  (NOPTRBIN: Cminor.ptr_binop op = false)
+  :
+  <<SAME: eval_binop_wrapper op arg1 arg2 m = eval_binop op arg1 arg2 m>>.
+Proof. unfold eval_binop, eval_binop_wrapper. eapply Cminor.eval_binop_no_ptr_binop. eauto. Qed.
+
 (** Allocation of local variables at function entry.  Each variable is
   bound to the reference to a fresh block of the appropriate size. *)
 
@@ -332,7 +344,7 @@ Inductive eval_expr: expr -> val -> Prop :=
   | eval_Ebinop: forall op a1 a2 v1 v2 v,
       eval_expr a1 v1 ->
       eval_expr a2 v2 ->
-      eval_binop op v1 v2 m = Some v ->
+      eval_binop_wrapper op v1 v2 m = Some v ->
       eval_expr (Ebinop op a1 a2) v
   | eval_Eload: forall chunk a v1 v,
       eval_expr a v1 ->
@@ -482,13 +494,54 @@ Inductive initial_state (p: program): state -> Prop :=
       funsig f = signature_main ->
       initial_state p (Callstate f nil Kstop m0).
 
+Inductive glob_capture (p: program) : state -> state -> Prop :=
+  | glob_capture_intro
+      f m pbs m'
+      (* (INIT: initial_state p (Callstate nil f nil m)) *)
+      (NONSTATIC: Genv.non_static_glob (Genv.globalenv p) (Genv.genv_public (Genv.globalenv p)) = pbs)
+      (CAPTURE: Genv.capture_init_mem m pbs m') :
+    glob_capture p (Callstate f nil Kstop m) (Callstate f nil Kstop m').
+
+Definition state_mem (st: state) : mem :=
+  match st with
+  | State _ _ _ _ _ m => m
+  | Callstate _ _ _ m => m
+  | Returnstate _ _ m => m
+  end.
+
+Definition concrete_snapshot (ge: Senv.t) (st: state) (id: ident) : option Z :=
+  if Senv.public_symbol ge id
+  then (match Senv.find_symbol ge id with
+        | Some b => Maps.PTree.get b (state_mem st).(Mem.mem_concrete)
+        | None => None
+        end
+    )
+  else None.
+
 (** A final state is a [Returnstate] with an empty continuation. *)
 
 Inductive final_state: state -> int -> Prop :=
   | final_state_intro: forall r m,
       final_state (Returnstate (Vint r) Kstop m) r.
 
+(** Non-deterministic external state *)
+
+Definition is_external (ge: genv) (s:state) : Prop :=
+  match s with
+  | State f s k e le m =>
+    match s with
+    | Sbuiltin optid ef al => is_external_ef ef
+    | _ => False
+    end
+  | Callstate f args k m =>
+    match f with
+    | External ef => is_external_ef ef
+    | _ => False
+    end
+  | _ => False
+  end.
+
 (** Wrapping up these definitions in a small-step semantics. *)
 
 Definition semantics (p: program) :=
-  Semantics step (initial_state p) final_state (Genv.globalenv p).
+  Semantics step (initial_state p) (glob_capture p) (concrete_snapshot (Genv.globalenv p)) final_state is_external (Genv.globalenv p).
diff --git a/cfrontend/CsharpminorD.v b/cfrontend/CsharpminorD.v
new file mode 100644
index 00000000..c1e337f2
--- /dev/null
+++ b/cfrontend/CsharpminorD.v
@@ -0,0 +1,109 @@
+Require Import Coqlib CoqlibC sflib.
+Require Import Globalenvs Events.
+Require Import Smallstep Simulation.
+Require Import Csharpminor.
+
+(** Determinacy *)
+
+Lemma semantics_single_events p s (INT: ~ Csharpminor.is_external (globalenv (Csharpminor.semantics p)) s):
+  single_events_at (Csharpminor.semantics p) s.
+Proof.
+  red. intros. inv H; (try (exploit external_call_trace_length; eauto; intro T)); simpl; try lia; ss.
+Qed.
+
+Let eval_expr_determ:
+  forall ge e le m a v, eval_expr ge e le m a v -> forall v', eval_expr ge e le m a v' -> v = v'.
+Proof.
+  induction 1; intros v' EV; inv EV; try congruence.
+  - inv H; inv H1; congruence.
+  - exploit IHeval_expr; eauto. intros; subst; Eq.
+  - exploit IHeval_expr1; eauto. exploit IHeval_expr2; eauto.
+    intros; subst; Eq.
+  - exploit IHeval_expr; eauto. intros; subst; Eq.
+Qed.
+
+Let eval_exprlist_determ:
+  forall ge e le m al vl, eval_exprlist ge e le m al vl -> forall vl', eval_exprlist ge e le m al vl' -> vl = vl'.
+Proof.
+  induction 1; intros vl' EV; inv EV; try congruence.
+  - exploit IHeval_exprlist; eauto. intros. subst.
+    exploit eval_expr_determ. eapply H3. eapply H. intros. subst; auto.
+Qed.
+
+Let alloc_variables_determ:
+  forall env m vars e m1, alloc_variables env m vars e m1 -> forall e' m1', alloc_variables env m vars e' m1' -> e = e' /\ m1 = m1'.
+Proof.
+  induction 1; intros e' m1' EV; inv EV; f_equal; eauto. rewrite H in H8.
+  inv H8. eapply IHalloc_variables; eauto.
+Qed.
+
+Lemma initial_state_determ: forall p st0 st1,
+    Smallstep.initial_state (Csharpminor.semantics p) st0 ->
+    Smallstep.initial_state (Csharpminor.semantics p) st1 -> st0 = st1.
+Proof.
+  intros. inv H; inv H0. subst ge0 ge. Eq.
+Qed.
+
+Ltac Determ :=
+  try congruence;
+  match goal with
+  | [ |- match_traces _ E0 E0 /\ (_ -> _) ]  =>
+          split; [constructor|intros _; Determ]
+  | [ H: is_call_cont ?k |- _ ] =>
+          contradiction || (clear H; Determ)
+  | [ H1: eval_expr _ _ _ _ ?a ?v1, H2: eval_expr _ _ _ _ ?a ?v2 |- _ ] =>
+          assert (v1 = v2) by (eapply eval_expr_determ; eauto);
+          clear H1 H2; Determ
+  | [ H1: eval_exprlist _ _ _ _ ?a ?v1, H2: eval_exprlist _ _ _ _ ?a ?v2 |- _ ] =>
+          assert (v1 = v2) by (eapply eval_exprlist_determ; eauto);
+          clear H1 H2; Determ
+  | [ H1: alloc_variables _ _ ?vars ?e ?m1, H2: alloc_variables _ _ ?vars ?e' ?m2 |- _ ] =>
+          assert (e = e' /\ m1 = m2) by (eapply alloc_variables_determ; eauto);
+          clear H1 H2; Determ
+  | _ => idtac
+  end.
+
+Lemma semantics_determinate_at:
+  forall (p: program) s (INT: ~ is_external (Genv.globalenv p) s), deterministic_at (semantics p) s.
+Proof.
+  econstructor; eauto.
+  - intros. simpl in *. inv STEP0; inv STEP1; Determ; subst; eauto; try by (clarify; subst; esplits; eauto).
+    + determ_tac external_call_determ.
+    + inv H0; inv H12; auto.
+    + inv H0; inv H12; auto.
+    + des; subst; eauto. erewrite H3 in H14. clarify.
+    + simpl in INT.
+      determ_tac external_call_determ.
+  - i. inv FINAL; inv STEP.
+  - unfold single_events_at. i. eapply semantics_single_events; eauto.
+Qed.
+
+Ltac simpl_case :=
+  match goal with
+  | [ H: match_traces _ E0 _ |- _ ] =>
+    inv H; do 2 econstructor; eauto
+  | [ H: match_traces _ _ E0 |- _ ] =>
+    inv H; do 2 econstructor; eauto
+  | _ => idtac
+  end.
+
+Lemma semantics_receptive_at:
+  forall (p: program) s (INT: ~ is_external (Genv.globalenv p) s), receptive_at (semantics p) s.
+Proof.
+  econstructor; eauto.
+  - intros. simpl in *.
+    inv H; simpl_case; try (exploit external_call_receptive; eauto; intros (vres2 & m2 & EXT);
+    (do 2 econstructor); eauto).
+  - unfold single_events_at. i. eapply semantics_single_events; eauto.
+Qed.
+
+Theorem final_state_determ: forall p st0 retv,
+    Smallstep.final_state (semantics p) st0 retv ->
+    Dfinal_state (semantics p) st0 retv.
+Proof.
+  econstructor; eauto.
+  - intros. inv FINAL1; inv FINAL0; auto.
+  - red. unfold not. intros. inv FINAL; inv H0.
+Qed.
+
+Ltac DStep_tac := esplit; [(eapply semantics_determinate_at; simpl in *; eauto)|].
diff --git a/cfrontend/Cshmgen.v b/cfrontend/Cshmgen.v
index 5bd12d00..889710ac 100644
--- a/cfrontend/Cshmgen.v
+++ b/cfrontend/Cshmgen.v
@@ -148,6 +148,7 @@ Definition make_cast_int (e: expr) (sz: intsize) (si: signedness) :=
 
 Definition make_cast (from to: type) (e: expr) :=
   match classify_cast from to with
+  | cast_case_pointer2int => OK e
   | cast_case_pointer => OK e
   | cast_case_i2i sz2 si2 => OK (make_cast_int e sz2 si2)
   | cast_case_f2f => OK e
@@ -282,10 +283,10 @@ Definition make_sub (ce: composite_env) (e1: expr) (ty1: type) (e2: expr) (ty2:
       do sz <- sizeof ce ty;
       if Archi.ptr64 then
         let n := make_longconst (Int64.repr sz) in
-        OK (Ebinop Odivl (Ebinop Osubl e1 e2) n)
+        OK (Ebinop Odivl (Ebinop Opsub e1 e2) n)
       else
         let n := make_intconst (Int.repr sz) in
-        OK (Ebinop Odiv (Ebinop Osub e1 e2) n)
+        OK (Ebinop Odiv (Ebinop Opsub e1 e2) n)
   | sub_case_pl ty =>
       do sz <- sizeof ce ty;
       if Archi.ptr64 then
diff --git a/cfrontend/Cshmgenproof.v b/cfrontend/Cshmgenproof.v
index 6e653e01..e083693e 100644
--- a/cfrontend/Cshmgenproof.v
+++ b/cfrontend/Cshmgenproof.v
@@ -14,9 +14,11 @@
 
 Require Import Coqlib Errors Maps Integers Floats.
 Require Import AST Linking.
+Require Import Simulation ClightD CsharpminorD Classical.
 Require Import Values Events Memory Globalenvs Smallstep.
 Require Import Ctypes Ctyping Cop Clight Cminor Csharpminor.
 Require Import Cshmgen.
+Require Import IntPtrRel.
 
 (** * Relational specification of the transformation *)
 
@@ -141,8 +143,8 @@ Qed.
 (** Transformation of expressions and statements. *)
 
 Lemma transl_expr_lvalue:
-  forall ge e le m a loc ofs ce ta,
-  Clight.eval_lvalue ge e le m a loc ofs ->
+  forall ge e le m a v ce ta,
+  Clight.eval_lvalue ge e le m a v ->
   transl_expr ce a = OK ta ->
   (exists tb, transl_lvalue ce a = OK tb /\ make_load tb (typeof a) = OK ta).
 Proof.
@@ -289,6 +291,46 @@ Hint Resolve make_intconst_correct make_floatconst_correct make_longconst_correc
 Hint Constructors eval_expr eval_exprlist: cshm.
 Hint Extern 2 (@eq trace _ _) => traceEq: cshm.
 
+Lemma cmpu_wrapper_int n n' m c :
+  eval_binop_wrapper (Ocmpu c) (Vint n) (Vint n') m = eval_binop (Ocmpu c) (Vint n) (Vint n') m.
+Proof.
+  destruct Archi.ptr64 eqn:SF.
+  { unfold_wrapper. simpl. rewrite SF. simpl. eauto. }
+  unfold_wrapper. simpl. unfold Val.cmpu. rewrite SF. simpl. eauto.
+Qed.
+
+Lemma cmplu_wrapper_long n n' m c :
+  eval_binop_wrapper (Ocmplu c) (Vlong n) (Vlong n') m = eval_binop (Ocmplu c) (Vlong n) (Vlong n') m.
+Proof.
+  destruct Archi.ptr64 eqn:SF; cycle 1. { unfold_wrapper. simpl. rewrite SF. simpl. eauto. }
+  unfold_wrapper. simpl. unfold Val.cmplu. rewrite SF. simpl. eauto.
+Qed.
+
+Lemma cmpu_null_wrapper_ptr b ofs m c v
+    (WVLD: Mem.weak_valid_pointer m b (Ptrofs.unsigned ofs) = true)
+    (EVAL: eval_binop (Ocmpu c) (Vptr b ofs) (Vint Int.zero) m = Some v)
+    (SUCCESS: v <> Vundef) :
+  eval_binop_wrapper (Ocmpu c) (Vptr b ofs) (Vint Int.zero) m = Some v.
+Proof.
+  destruct Archi.ptr64 eqn:SF. { unfold_wrapper. simpl. rewrite SF. simpl. eauto. }
+  simpl in EVAL. inv EVAL.
+  unfold_wrapper. simpl. unfold Val.cmpu. rewrite SF. simpl. eauto.
+  rewrite Int.eq_true, SF. eauto.
+Qed.
+  
+Lemma cmplu_null_wrapper_ptr b ofs m c v
+    (WVLD: Mem.weak_valid_pointer m b (Ptrofs.unsigned ofs) = true)
+    (EVAL: eval_binop (Ocmplu c) (Vptr b ofs) (Vlong Int64.zero) m = Some v)
+    (SUCCESS: v <> Vundef) :
+  eval_binop_wrapper (Ocmplu c) (Vptr b ofs) (Vlong Int64.zero) m = Some v.
+Proof.
+  destruct Archi.ptr64 eqn:SF; cycle 1. { unfold_wrapper. simpl. rewrite SF. simpl. eauto. }
+  unfold_wrapper. simpl. unfold Val.cmplu. rewrite SF. simpl.
+  simpl in EVAL. inv EVAL.
+  unfold_wrapper. simpl. unfold Val.cmplu, Val.cmplu_bool. rewrite SF. simpl.
+  rewrite Int64.eq_true. eauto.
+Qed.
+
 Lemma make_cmpu_ne_zero_correct:
   forall e le m a n,
   eval_expr ge e le m a (Vint n) ->
@@ -297,7 +339,7 @@ Proof.
   intros.
   assert (DEFAULT: eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero))
                                        (Vint (if Int.eq n Int.zero then Int.zero else Int.one))).
-  { econstructor; eauto with cshm. simpl. unfold Val.cmpu, Val.cmpu_bool.
+  { econstructor; eauto with cshm. eapply eval_binop_int_cmpu. simpl. unfold Val.cmpu, Val.cmpu_bool.
     unfold Int.cmpu. destruct (Int.eq n Int.zero); auto. }
   assert (CMP: forall ob,
                Val.of_optbool ob = Vint n ->
@@ -305,21 +347,57 @@ Proof.
   { intros. destruct ob; simpl in H0; inv H0. destruct b; inv H2.
     rewrite Int.eq_false. auto. apply Int.one_not_zero.
     rewrite Int.eq_true. auto. }
-  destruct a; simpl; auto. destruct b; auto.
+  destruct a; simpl; auto.
+  destruct (ptr_binop b) eqn:PTRBIN; cycle 1.
+  {
+  destruct b; auto.
 - inv H. econstructor; eauto. rewrite H6. decEq. decEq.
+  erewrite eval_binop_no_ptr_binop in H6; eauto.
   simpl in H6. inv H6. eauto.
 - inv H. econstructor; eauto. rewrite H6. decEq. decEq.
+  erewrite eval_binop_no_ptr_binop in H6; eauto.
   simpl in H6. inv H6. eauto.
 - inv H. econstructor; eauto. rewrite H6. decEq. decEq.
+  erewrite eval_binop_no_ptr_binop in H6; eauto.
   simpl in H6. inv H6. eauto.
 - inv H. econstructor; eauto. rewrite H6. decEq. decEq.
+  erewrite eval_binop_no_ptr_binop in H6; eauto.
   simpl in H6. inv H6. eauto.
 - inv H. econstructor; eauto. rewrite H6. decEq. decEq.
+  erewrite eval_binop_no_ptr_binop in H6; eauto.
   simpl in H6. unfold Val.cmpl in H6.
   destruct (Val.cmpl_bool c v1 v2) as [[]|]; inv H6; reflexivity.
 - inv H. econstructor; eauto. rewrite H6. decEq. decEq.
+  erewrite eval_binop_no_ptr_binop in H6; eauto.
   simpl in H6. unfold Val.cmplu in H6.
   destruct (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) as [[]|]; inv H6; reflexivity.
+  }
+  destruct b; simpl in PTRBIN; destruct Archi.ptr64 eqn:SF;
+    try rewrite SF in *; simpl in *; inv PTRBIN; eauto.
+- inv H. econstructor; eauto. rewrite H6. decEq. decEq.
+  unfold eval_binop_wrapper, Cminor.eval_binop_wrapper in *.
+  unfold ptr_binop, eval_binop_join in *. rewrite SF in *. simpl in *.
+  destruct v1; destruct v2; simpl in *; try inv H6; clear SF.
+  + eapply CMP. instantiate (1:= Some (if Int.cmpu c i i0 then true else false)).
+    destruct (Int.cmpu c i i0); simpl in *; eauto.
+  + destruct (Int.eq i Int.zero) eqn:NULL; eapply CMP; eauto.
+  + destruct (Int.eq i0 Int.zero) eqn:NULL; eapply CMP; eauto.
+- inv H. econstructor; eauto. rewrite H6. decEq. decEq.
+  unfold eval_binop_wrapper, Cminor.eval_binop_wrapper in *.
+  unfold ptr_binop, eval_binop_join in *. rewrite SF in *. simpl in *.
+  destruct v1; destruct v2; ss.
+  + destruct (Int64.cmpu c i i0) eqn:A; ss; inv H6; eauto.
+  + destruct (Int64.eq i Int64.zero) eqn:NULL; [des_ifs; destruct c; ss; clarify|].
+    { destruct (cmplu_join m c (Vlong i) (Vptr b i0)) eqn:A; ss; clarify; eauto.
+      destruct b0; ss; inv H0; eauto. }
+  + destruct (Int64.eq i0 Int64.zero) eqn:NULL; [des_ifs; destruct c; ss; clarify|].
+    { destruct (cmplu_join m c (Vptr b i) (Vlong i0)) eqn:A; ss; clarify; eauto.
+      destruct b0; ss; inv H0; eauto. }
+  + des_ifs.
+    { destruct (Ptrofs.cmpu c i i0) eqn:A; ss; clarify. }
+    { destruct c; ss; clarify. }
+    { destruct (Ptrofs.cmpu c i i0) eqn:A; ss; clarify. }
+    { destruct c; ss; clarify. }
 Qed.
 
 Lemma make_cmpu_ne_zero_correct_ptr:
@@ -331,20 +409,25 @@ Lemma make_cmpu_ne_zero_correct_ptr:
 Proof.
   intros.
   assert (DEFAULT: eval_expr ge e le m (Ebinop (Ocmpu Cne) a (make_intconst Int.zero)) Vone).
-  { econstructor; eauto with cshm. simpl. unfold Val.cmpu, Val.cmpu_bool.
+  { econstructor; eauto with cshm. eapply cmpu_null_wrapper_ptr; [eauto | |clarify]. simpl. unfold Val.cmpu, Val.cmpu_bool.
     unfold Mem.weak_valid_pointer in H1. rewrite H0, H1.
     rewrite Int.eq_true; auto. }
   assert (OF_OPTBOOL: forall ob, Some (Val.of_optbool ob) <> Some (Vptr b i)).
   { intros. destruct ob as [[]|]; discriminate. }
   assert (OF_BOOL: forall ob, option_map Val.of_bool ob <> Some (Vptr b i)).
   { intros. destruct ob as [[]|]; discriminate. }
-  destruct a; simpl; auto. destruct b0; auto.
-- inv H; eelim OF_OPTBOOL; eauto.
-- inv H; eelim OF_OPTBOOL; eauto.
-- inv H; eelim OF_OPTBOOL; eauto.
-- inv H; eelim OF_OPTBOOL; eauto.
-- inv H; eelim OF_BOOL; eauto.
-- inv H; eelim OF_BOOL; eauto.
+  destruct a; simpl; auto.
+  destruct (ptr_binop b0) eqn:PTRBIN; cycle 1. {
+  unfold ptr_binop in PTRBIN. rewrite H0 in *. simpl in *.
+  destruct b0; auto; inv H; erewrite eval_binop_no_ptr_binop in *; eauto; simpl in *.
+- eelim OF_OPTBOOL; eauto.
+- inv PTRBIN.
+- eelim OF_OPTBOOL; eauto.
+- eelim OF_OPTBOOL; eauto.
+- eelim OF_BOOL; eauto.
+- eelim OF_BOOL; eauto. }
+  destruct b0; auto; simpl in *; try rewrite H0 in *; inv PTRBIN.
+  inv H. exfalso. unfold_wrapper. unfold Val.of_optbool in H8. des_ifs.
 Qed.
 
 Lemma make_cast_int_correct:
@@ -413,19 +496,21 @@ Proof.
 - (* pointer (32 bits) -> bool *)
   eapply make_cmpu_ne_zero_correct_ptr; eauto.
 - (* long -> bool *)
-  econstructor; eauto with cshm.
+  econstructor; eauto with cshm. rewrite cmplu_wrapper_long; eauto.
   simpl. unfold Val.cmplu, Val.cmplu_bool, Int64.cmpu.
   destruct (Int64.eq i Int64.zero); auto.
 - (* pointer (64 bits) -> bool *)
-  econstructor; eauto with cshm.
+  econstructor; eauto with cshm. eapply cmplu_null_wrapper_ptr; [eauto| | clarify].
   simpl. unfold Val.cmplu, Val.cmplu_bool. unfold Mem.weak_valid_pointer in Heqb1.
   rewrite Heqb0, Heqb1. rewrite Int64.eq_true. reflexivity.
 - (* float -> bool *)
   econstructor; eauto with cshm.
+  unfold eval_binop_wrapper, Cminor.eval_binop_wrapper. simpl.
   simpl. unfold Val.cmpf, Val.cmpf_bool. rewrite Float.cmp_ne_eq.
   destruct (Float.cmp Ceq f Float.zero); auto.
 - (* single -> bool *)
   econstructor; eauto with cshm.
+  unfold eval_binop_wrapper, Cminor.eval_binop_wrapper. simpl.
   simpl. unfold Val.cmpfs, Val.cmpfs_bool. rewrite Float32.cmp_ne_eq.
   destruct (Float32.cmp Ceq f Float32.zero); auto.
 - (* struct *)
@@ -450,19 +535,19 @@ Proof.
 - (* ptr 32 bits *)
   exists Vone; split. eapply make_cmpu_ne_zero_correct_ptr; eauto. constructor.
 - (* long *)
-  econstructor; split. econstructor; eauto with cshm. simpl. unfold Val.cmplu. simpl. eauto.
+  econstructor; split. econstructor; eauto with cshm. rewrite cmplu_wrapper_long; eauto. simpl. unfold Val.cmplu. simpl. eauto.
   destruct (Int64.eq i Int64.zero); simpl; constructor.
 - (* ptr 64 bits *)
   exists Vone; split.
-  econstructor; eauto with cshm. simpl. unfold Val.cmplu, Val.cmplu_bool.
+  econstructor; eauto with cshm. eapply cmplu_null_wrapper_ptr; [eauto| |clarify]. simpl. unfold Val.cmplu, Val.cmplu_bool.
   unfold Mem.weak_valid_pointer in Heqb0. rewrite Heqb0, Heqb1, Int64.eq_true. reflexivity.
   constructor.
 - (* float *)
-  econstructor; split. econstructor; eauto with cshm. simpl. eauto.
+  econstructor; split. econstructor; eauto with cshm. rewrite eval_binop_no_ptr_binop; eauto. simpl. eauto.
   unfold Val.cmpf, Val.cmpf_bool. simpl. rewrite <- Float.cmp_ne_eq.
   destruct (Float.cmp Cne f Float.zero); constructor.
 - (* single *)
-  econstructor; split. econstructor; eauto with cshm. simpl. eauto.
+  econstructor; split. econstructor; eauto with cshm. rewrite eval_binop_no_ptr_binop; eauto. simpl. eauto.
   unfold Val.cmpfs, Val.cmpfs_bool. simpl. rewrite <- Float32.cmp_ne_eq.
   destruct (Float32.cmp Cne f Float32.zero); constructor.
 Qed.
@@ -501,21 +586,21 @@ Lemma make_notbool_correct:
 Proof.
   unfold sem_notbool, bool_val, make_notbool; intros until m; intros SEM MAKE EV1.
   destruct (classify_bool tya); inv MAKE; destruct va; simpl in SEM; InvEval.
-- econstructor; eauto with cshm. simpl. unfold Val.cmpu, Val.cmpu_bool, Int.cmpu.
+- econstructor; eauto with cshm. rewrite cmpu_wrapper_int. simpl. unfold Val.cmpu, Val.cmpu_bool, Int.cmpu.
   destruct (Int.eq i Int.zero); auto.
 - destruct Archi.ptr64 eqn:SF; inv SEM.
   destruct (Mem.weak_valid_pointer m b (Ptrofs.unsigned i)) eqn:V; simpl in H0; inv H0.
-  econstructor; eauto with cshm. simpl. unfold Val.cmpu, Val.cmpu_bool.
+  econstructor; eauto with cshm. eapply cmpu_null_wrapper_ptr; [eauto| |clarify]. simpl. unfold Val.cmpu, Val.cmpu_bool.
   unfold Mem.weak_valid_pointer in V. rewrite SF, V, Int.eq_true. auto.
-- econstructor; eauto with cshm. simpl. unfold Val.cmplu, Val.cmplu_bool, Int64.cmpu.
+- econstructor; eauto with cshm. rewrite cmplu_wrapper_long. simpl. unfold Val.cmplu, Val.cmplu_bool, Int64.cmpu.
   destruct (Int64.eq i Int64.zero); auto.
 - destruct Archi.ptr64 eqn:SF; inv SEM.
   destruct (Mem.weak_valid_pointer m b (Ptrofs.unsigned i)) eqn:V; simpl in H0; inv H0.
-  econstructor; eauto with cshm. simpl. unfold Val.cmplu, Val.cmplu_bool.
+  econstructor; eauto with cshm. eapply cmplu_null_wrapper_ptr; [eauto| |clarify]. simpl. unfold Val.cmplu, Val.cmplu_bool.
   unfold Mem.weak_valid_pointer in V. rewrite SF, V, Int64.eq_true. auto.
-- econstructor; eauto with cshm. simpl. unfold Val.cmpf, Val.cmpf_bool.
+- econstructor; eauto with cshm. rewrite eval_binop_no_ptr_binop; eauto. simpl. unfold Val.cmpf, Val.cmpf_bool.
   destruct (Float.cmp Ceq f Float.zero); auto.
-- econstructor; eauto with cshm. simpl. unfold Val.cmpfs, Val.cmpfs_bool.
+- econstructor; eauto with cshm. rewrite eval_binop_no_ptr_binop; eauto. simpl. unfold Val.cmpfs, Val.cmpfs_bool.
   destruct (Float32.cmp Ceq f Float32.zero); auto.
 Qed.
 
@@ -559,17 +644,17 @@ Variable sem_single: float32 -> float32 -> option val.
 Variables iop iopu fop sop lop lopu: binary_operation.
 
 Hypothesis iop_ok:
-  forall x y m, eval_binop iop (Vint x) (Vint y) m = sem_int Signed x y.
+  forall x y m, eval_binop_wrapper iop (Vint x) (Vint y) m = sem_int Signed x y.
 Hypothesis iopu_ok:
-  forall x y m, eval_binop iopu (Vint x) (Vint y) m = sem_int Unsigned x y.
+  forall x y m, eval_binop_wrapper iopu (Vint x) (Vint y) m = sem_int Unsigned x y.
 Hypothesis lop_ok:
-  forall x y m, eval_binop lop (Vlong x) (Vlong y) m = sem_long Signed x y.
+  forall x y m, eval_binop_wrapper lop (Vlong x) (Vlong y) m = sem_long Signed x y.
 Hypothesis lopu_ok:
-  forall x y m, eval_binop lopu (Vlong x) (Vlong y) m = sem_long Unsigned x y.
+  forall x y m, eval_binop_wrapper lopu (Vlong x) (Vlong y) m = sem_long Unsigned x y.
 Hypothesis fop_ok:
-  forall x y m, eval_binop fop (Vfloat x) (Vfloat y) m = sem_float x y.
+  forall x y m, eval_binop_wrapper fop (Vfloat x) (Vfloat y) m = sem_float x y.
 Hypothesis sop_ok:
-  forall x y m, eval_binop sop (Vsingle x) (Vsingle y) m = sem_single x y.
+  forall x y m, eval_binop_wrapper sop (Vsingle x) (Vsingle y) m = sem_single x y.
 
 Lemma make_binarith_correct:
   binary_constructor_correct
@@ -630,14 +715,14 @@ Proof.
     destruct Archi.ptr64 eqn:SF; inv EQ0; rewrite (transl_sizeof _ _ _ _ LINK EQ).
   - destruct va; InvEval; destruct vb; inv SEM.
   + eauto with cshm.
-  + econstructor; eauto with cshm.
+  + econstructor; eauto with cshm. rewrite eval_binop_no_ptr_binop; eauto.
     simpl. rewrite SF. f_equal. f_equal. f_equal.
     assert (Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)).
     { destruct si; simpl; apply Ptrofs.agree64_repr; auto. }
     auto with ptrofs.
   - destruct va; InvEval; destruct vb; inv SEM.
   + eauto with cshm.
-  + econstructor; eauto with cshm.
+  + econstructor; eauto with cshm. rewrite eval_binop_no_ptr_binop; eauto.
     simpl. rewrite SF. f_equal. f_equal. f_equal.
     assert (Ptrofs.agree32 (ptrofs_of_int si i0) i0) by (destruct si; simpl; auto with ptrofs).
     auto with ptrofs.
@@ -651,11 +736,11 @@ Proof.
     destruct Archi.ptr64 eqn:SF; inv EQ0; rewrite (transl_sizeof _ _ _ _ LINK EQ).
   - destruct va; InvEval; destruct vb; inv SEM.
   + eauto with cshm.
-  + econstructor; eauto with cshm.
+  + econstructor; eauto with cshm. rewrite eval_binop_no_ptr_binop; eauto.
     simpl. rewrite SF. f_equal. f_equal. f_equal. auto with ptrofs.
   - destruct va; InvEval; destruct vb; inv SEM.
   + eauto with cshm.
-  + econstructor; eauto with cshm.
+  + econstructor; eauto with cshm. rewrite eval_binop_no_ptr_binop; eauto.
     simpl. rewrite SF. f_equal. f_equal. f_equal.
     assert (Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0)) by (apply Ptrofs.agree32_repr; auto).
     auto with ptrofs.
@@ -666,26 +751,52 @@ Proof.
 - eapply make_binarith_correct; eauto; intros; auto.
 Qed.
 
+Lemma psub_common_pusbl v1 v2 v m
+    (SF: Archi.ptr64 = true)
+    (PSUBC: _sem_ptr_sub_join_common v1 v2 m = Some v) :
+  <<PSUB: psubl_join m v1 v2 = (Vptrofs v)>>.
+Proof.
+  unfold _sem_ptr_sub_join_common, _sem_ptr_sub_join, _sem_ptr_sub in PSUBC.
+  destruct v1, v2; ss; try rewrite SF in *; try by (des_ifs; clarify).
+  - inv PSUBC. unfold psubl_join.
+    erewrite val_join_angelic_vi; eauto; try by ss.
+    { simpl. rewrite SF. unfold Vptrofs. des_ifs. rewrite Ptrofs.to_int64_of_int64; eauto. }
+    { eapply psubl_wrapper_no_angelic; eauto. }
+  - unfold psubl_join. des_ifs; ss; des_ifs;
+      try by (unfold Vptrofs; des_ifs; rewrite Ptrofs.to_int64_of_int64; eauto).
+    exploit Ptrofs.same_if_eq; eauto. i. rewrite H. unfold Vptrofs. des_ifs.
+    rewrite Ptrofs.to_int64_of_int64; eauto. eapply val_join_same_val. ss.
+  - unfold psubl_join. des_ifs; ss; des_ifs;
+      try by (unfold Vptrofs; des_ifs; rewrite Ptrofs.to_int64_of_int64; eauto).
+    exploit Ptrofs.same_if_eq; eauto. i. rewrite H. unfold Vptrofs. des_ifs.
+    rewrite Ptrofs.to_int64_of_int64; eauto. eapply val_join_same_val. ss.
+  - unfold psubl_join. des_ifs.
+    erewrite val_join_angelic_vp; eauto.
+    { simpl. rewrite SF. simpl. des_ifs. }
+    { ss. des_ifs. }
+    { eapply psubl_wrapper_no_angelic; eauto. }
+    { ss. rewrite SF. des_ifs. }
+Qed.
+
 Lemma make_sub_correct: binary_constructor_correct (make_sub cunit.(prog_comp_env)) (sem_sub prog.(prog_comp_env)).
 Proof.
   red; unfold make_sub, sem_sub;
   intros until m; intros SEM MAKE EV1 EV2;
-  destruct (classify_sub tya tyb); try (monadInv MAKE).
+  destruct (classify_sub tya tyb) eqn:CLASS; try (monadInv MAKE).
 - destruct Archi.ptr64 eqn:SF; inv EQ0; rewrite (transl_sizeof _ _ _ _ LINK EQ).
 + destruct va; InvEval; destruct vb; inv SEM; eauto with cshm.
-  econstructor; eauto with cshm.
+  econstructor; eauto with cshm. rewrite eval_binop_no_ptr_binop; eauto.
   simpl. rewrite SF. apply f_equal. apply f_equal. apply f_equal.
   assert (Ptrofs.agree64 (ptrofs_of_int si i0) (cast_int_long si i0)).
   { destruct si; simpl; apply Ptrofs.agree64_repr; auto. }
   auto with ptrofs.
 + destruct va; InvEval; destruct vb; inv SEM; eauto with cshm.
-  econstructor; eauto with cshm. simpl. rewrite SF. apply f_equal. apply f_equal. apply f_equal.
+  econstructor; eauto with cshm. rewrite eval_binop_no_ptr_binop; eauto. simpl. rewrite SF. apply f_equal. apply f_equal. apply f_equal.
   assert (Ptrofs.agree32 (ptrofs_of_int si i0) i0) by (destruct si; simpl; auto with ptrofs).
   auto with ptrofs.
 - rewrite (transl_sizeof _ _ _ _ LINK EQ) in EQ0. clear EQ.
   set (sz := Ctypes.sizeof (prog_comp_env prog) ty) in *.
-  destruct va; InvEval; destruct vb; InvEval.
-  destruct (eq_block b0 b1); try discriminate.
+  destruct (_sem_ptr_sub_join_common va vb m) eqn:PSUB; try by inv SEM.
   destruct (zlt 0 sz); try discriminate.
   destruct (zle sz Ptrofs.max_signed); simpl in SEM; inv SEM.
   assert (E1: Ptrofs.signed (Ptrofs.repr sz) = sz).
@@ -696,8 +807,18 @@ Proof.
     replace Int64.max_signed with Ptrofs.max_signed.
     generalize Int64.min_signed_neg; lia.
     unfold Ptrofs.max_signed, Ptrofs.half_modulus; rewrite Ptrofs.modulus_eq64 by auto. reflexivity. }
-  econstructor; eauto with cshm.
-  rewrite SF, dec_eq_true. simpl.
+  econstructor; [|eauto with cshm|].
+  { instantiate (1:= Vlong (Ptrofs.to_int64 i)). econs; eauto.
+    unfold_wrapper. ss. unfold psub_join_cminor. des_ifs_safe. unfold psubl_join_common.
+    unfold _sem_ptr_sub_join_common, _sem_ptr_sub_join, _sem_ptr_sub in PSUB.
+    destruct va; destruct vb; ss.
+    - exfalso. des_ifs.
+    - des_ifs. rewrite Ptrofs.to_int64_of_int64; eauto.
+    - f_equal. eapply psub_common_pusbl; eauto.
+    - exfalso. des_ifs.
+    - f_equal. eapply psub_common_pusbl; eauto.
+    - des_ifs. }
+  rewrite eval_binop_no_ptr_binop; eauto. simpl.
   predSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.zero.
   rewrite H in E; rewrite Int64.signed_zero in E; extlia.
   predSpec Int64.eq Int64.eq_spec (Int64.repr sz) Int64.mone.
@@ -710,7 +831,10 @@ Proof.
     generalize Int.min_signed_neg; lia.
     unfold Ptrofs.max_signed, Ptrofs.half_modulus, Ptrofs.modulus, Ptrofs.wordsize, Wordsize_Ptrofs.wordsize. rewrite SF. reflexivity.
   }
-  econstructor; eauto with cshm. rewrite SF, dec_eq_true. simpl.
+  econstructor; [|eauto with cshm|].
+  { instantiate (1:= Vint (Ptrofs.to_int i)). econs; eauto. unfold _sem_ptr_sub_join in PSUB.
+    unfold eval_binop_wrapper. unfold Cminor.eval_binop_wrapper. ss. }
+  rewrite eval_binop_no_ptr_binop; eauto. simpl.
   predSpec Int.eq Int.eq_spec (Int.repr sz) Int.zero.
   rewrite H in E; rewrite Int.signed_zero in E; extlia.
   predSpec Int.eq Int.eq_spec (Int.repr sz) Int.mone.
@@ -720,10 +844,11 @@ Proof.
 - destruct Archi.ptr64 eqn:SF; inv EQ0; rewrite (transl_sizeof _ _ _ _ LINK EQ).
 + destruct va; InvEval; destruct vb; inv SEM; eauto with cshm.
   econstructor; eauto with cshm.
+  rewrite eval_binop_no_ptr_binop; eauto.
   simpl. rewrite SF. apply f_equal. apply f_equal. apply f_equal.
   auto with ptrofs.
 + destruct va; InvEval; destruct vb; inv SEM; eauto with cshm.
-  econstructor; eauto with cshm. simpl. rewrite SF. apply f_equal. apply f_equal. apply f_equal.
+  econstructor; eauto with cshm. rewrite eval_binop_no_ptr_binop; eauto. simpl. rewrite SF. apply f_equal. apply f_equal. apply f_equal.
   assert (Ptrofs.agree32 (Ptrofs.of_int64 i0) (Int64.loword i0)) by (apply Ptrofs.agree32_repr; auto).
   auto with ptrofs.
 - eapply make_binarith_correct; eauto; intros; auto.
@@ -807,15 +932,15 @@ Proof.
   destruct (classify_shift tya tyb); inv MAKE;
   destruct va; try discriminate; destruct vb; try discriminate.
 - destruct (Int.ltu i0 Int.iwordsize) eqn:E; inv SEM.
-  econstructor; eauto. simpl; rewrite E; auto.
+  econstructor; eauto. rewrite eval_binop_no_ptr_binop; eauto. simpl; rewrite E; auto.
 - destruct (Int64.ltu i0 Int64.iwordsize) eqn:E; inv SEM.
   exploit small_shift_amount_1; eauto. intros [A B].
-  econstructor; eauto with cshm. simpl. rewrite A.
+  econstructor; eauto with cshm. rewrite eval_binop_no_ptr_binop; eauto. simpl. rewrite A.
   f_equal; f_equal. unfold Int64.shl', Int64.shl. rewrite B; auto.
 - destruct (Int64.ltu i0 (Int64.repr 32)) eqn:E; inv SEM.
-  econstructor; eauto with cshm. simpl. rewrite small_shift_amount_2; auto.
+  econstructor; eauto with cshm. rewrite eval_binop_no_ptr_binop; eauto. simpl. rewrite small_shift_amount_2; auto.
 - destruct (Int.ltu i0 Int64.iwordsize') eqn:E; inv SEM.
-  econstructor; eauto with cshm. simpl. rewrite E.
+  econstructor; eauto with cshm. rewrite eval_binop_no_ptr_binop; eauto. simpl. rewrite E.
   unfold Int64.shl', Int64.shl. rewrite small_shift_amount_3; auto.
 Qed.
 
@@ -826,17 +951,17 @@ Proof.
   destruct (classify_shift tya tyb); inv MAKE;
   destruct va; try discriminate; destruct vb; try discriminate.
 - destruct (Int.ltu i0 Int.iwordsize) eqn:E; inv SEM.
-  destruct s; inv H0; econstructor; eauto; simpl; rewrite E; auto.
+  destruct s; inv H0; econstructor; eauto; rewrite eval_binop_no_ptr_binop; eauto; simpl; rewrite E; auto.
 - destruct (Int64.ltu i0 Int64.iwordsize) eqn:E; inv SEM.
   exploit small_shift_amount_1; eauto. intros [A B].
-  destruct s; inv H0; econstructor; eauto with cshm; simpl; rewrite A;
+  destruct s; inv H0; econstructor; eauto with cshm; rewrite eval_binop_no_ptr_binop; eauto; simpl; rewrite A;
   f_equal; f_equal.
   unfold Int64.shr', Int64.shr; rewrite B; auto.
   unfold Int64.shru', Int64.shru; rewrite B; auto.
 - destruct (Int64.ltu i0 (Int64.repr 32)) eqn:E; inv SEM.
-  destruct s; inv H0; econstructor; eauto with cshm; simpl; rewrite small_shift_amount_2; auto.
+  destruct s; inv H0; econstructor; eauto with cshm; rewrite eval_binop_no_ptr_binop; eauto;simpl; rewrite small_shift_amount_2; auto.
 - destruct (Int.ltu i0 Int64.iwordsize') eqn:E; inv SEM.
-  destruct s; inv H0; econstructor; eauto with cshm; simpl; rewrite E.
+  destruct s; inv H0; econstructor; eauto with cshm; rewrite eval_binop_no_ptr_binop; eauto; simpl; rewrite E.
   unfold Int64.shr', Int64.shr; rewrite small_shift_amount_3; auto.
   unfold Int64.shru', Int64.shru; rewrite small_shift_amount_3; auto.
 Qed.
@@ -849,10 +974,7 @@ Lemma make_cmp_ptr_correct:
   eval_expr ge e le m (make_cmp_ptr cmp a b) v.
 Proof.
   unfold cmp_ptr, make_cmp_ptr; intros.
-  destruct Archi.ptr64.
-- econstructor; eauto.
-- econstructor; eauto. simpl. unfold Val.cmpu.
-  destruct (Val.cmpu_bool (Mem.valid_pointer m) cmp va vb) as [bo|]; inv H. auto.
+  destruct va, vb; simpl in *; inv H; econs; eauto.
 Qed.
 
 Remark make_ptrofs_of_int_correct:
@@ -941,16 +1063,16 @@ Proof.
 Qed.
 
 Lemma make_load_correct:
-  forall addr ty code b ofs v e le m,
+  forall addr ty code lv v e le m,
   make_load addr ty = OK code ->
-  eval_expr ge e le m addr (Vptr b ofs) ->
-  deref_loc ty m b ofs v ->
+  eval_expr ge e le m addr lv ->
+  deref_loc ty m lv v ->
   eval_expr ge e le m code v.
 Proof.
   unfold make_load; intros until m; intros MKLOAD EVEXP DEREF.
   inv DEREF.
   (* scalar *)
-  rewrite H in MKLOAD. inv MKLOAD. apply eval_Eload with (Vptr b ofs); auto.
+  rewrite H in MKLOAD. inv MKLOAD. apply eval_Eload with lv; eauto.
   (* by reference *)
   rewrite H in MKLOAD. inv MKLOAD. auto.
   (* by copy *)
@@ -958,32 +1080,40 @@ Proof.
 Qed.
 
 Lemma make_memcpy_correct:
-  forall f dst src ty k e le m b ofs v m' s,
-  eval_expr ge e le m dst (Vptr b ofs) ->
-  eval_expr ge e le m src v ->
-  assign_loc prog.(prog_comp_env) ty m b ofs v m' ->
+  forall f dst src ty k e le m vsrc m' s vdst,
+  eval_expr ge e le m dst vdst ->
+  eval_expr ge e le m src vsrc ->
+  assign_loc prog.(prog_comp_env) ty m vdst vsrc m' ->
   access_mode ty = By_copy ->
   make_memcpy cunit.(prog_comp_env) dst src ty = OK s ->
   step ge (State f s k e le m) E0 (State f Sskip k e le m').
 Proof.
   intros. inv H1; try congruence.
+  2:{ monadInv H3.
+      exploit transl_alignof_blockcopy. eexact LINK. eauto. intros [A B]. rewrite A, B.
+      change le with (set_optvar None Vundef le) at 2.
+      econstructor.
+      econstructor. eauto. econstructor. eauto. constructor.
+      econs 2; eauto. }
   monadInv H3.
   exploit transl_alignof_blockcopy. eexact LINK. eauto. intros [A B]. rewrite A, B.
   change le with (set_optvar None Vundef le) at 2.
   econstructor.
   econstructor. eauto. econstructor. eauto. constructor.
   econstructor; eauto.
+  destruct (zeq x 0).
+  { subst. lia. }
   apply alignof_blockcopy_1248.
   apply sizeof_pos.
   apply sizeof_alignof_blockcopy_compat.
 Qed.
 
 Lemma make_store_correct:
-  forall addr ty rhs code e le m b ofs v m' f k,
+  forall addr ty rhs code e le m vaddr v m' f k,
   make_store cunit.(prog_comp_env) addr ty rhs = OK code ->
-  eval_expr ge e le m addr (Vptr b ofs) ->
+  eval_expr ge e le m addr vaddr ->
   eval_expr ge e le m rhs v ->
-  assign_loc prog.(prog_comp_env) ty m b ofs v m' ->
+  assign_loc prog.(prog_comp_env) ty m vaddr v m' ->
   step ge (State f code k e le m) E0 (State f Sskip k e le m').
 Proof.
   unfold make_store. intros until k; intros MKSTORE EV1 EV2 ASSIGN.
@@ -993,7 +1123,11 @@ Proof.
   econstructor; eauto.
   (* by copy *)
   rewrite H in MKSTORE.
-  eapply make_memcpy_correct with (b := b) (v := Vptr b' ofs'); eauto.
+  eapply make_memcpy_correct with (vdst:=vaddr); eauto.
+  (* by copy zero *)
+  rewrite H in MKSTORE.
+  eapply make_memcpy_correct. eapply EV1. eapply EV2.
+  econs 3; eauto. eauto. eauto.
 Qed.
 
 Lemma make_normalization_correct:
@@ -1026,6 +1160,9 @@ Variable prog: Clight.program.
 Variable tprog: Csharpminor.program.
 Hypothesis TRANSL: match_prog prog tprog.
 
+Let sem := semantics2 prog.
+Let tsem := Csharpminor.semantics tprog.
+
 Let ge := globalenv prog.
 Let tge := Genv.globalenv tprog.
 
@@ -1037,6 +1174,10 @@ Lemma senv_preserved:
   Senv.equiv ge tge.
 Proof (Genv.senv_match TRANSL).
 
+Lemma same_public:
+  prog_public prog = AST.prog_public tprog.
+Proof. inv TRANSL. des; eauto. Qed.
+
 Lemma function_ptr_translated:
   forall v f,
   Genv.find_funct_ptr ge v = Some f ->
@@ -1217,10 +1358,10 @@ Lemma transl_expr_lvalue_correct:
    Clight.eval_expr ge e le m a v ->
    forall ta (TR: transl_expr cunit.(prog_comp_env) a = OK ta) ,
    Csharpminor.eval_expr tge te le m ta v)
-/\(forall a b ofs,
-   Clight.eval_lvalue ge e le m a b ofs ->
+/\(forall a v,
+   Clight.eval_lvalue ge e le m a v ->
    forall ta (TR: transl_lvalue cunit.(prog_comp_env) a = OK ta),
-   Csharpminor.eval_expr tge te le m ta (Vptr b ofs)).
+   Csharpminor.eval_expr tge te le m ta v).
 Proof.
   apply eval_expr_lvalue_ind; intros; try (monadInv TR).
 - (* const int *)
@@ -1234,7 +1375,7 @@ Proof.
 - (* temp var *)
   constructor; auto.
 - (* addrof *)
-  simpl in TR. auto.
+  simpl in TR. exploit H0. eauto. i; des; eauto.
 - (* unop *)
   eapply transl_unop_correct; eauto.
 - (* binop *)
@@ -1258,7 +1399,7 @@ Proof.
 - (* deref *)
   simpl in TR. eauto.
 - (* field struct *)
-  unfold make_field_access in EQ0. rewrite H1 in EQ0.
+  unfold make_field_access in EQ0. rewrite H2 in EQ0.
   destruct (prog_comp_env cunit)!id as [co'|] eqn:CO; monadInv EQ0.
   exploit field_offset_stable. eexact LINK. eauto. instantiate (1 := i). intros [A B].
   rewrite <- B in EQ1.
@@ -1266,11 +1407,15 @@ Proof.
   subst x0.
   destruct Archi.ptr64 eqn:SF.
 + eapply eval_Ebinop; eauto using make_longconst_correct.
-  simpl. rewrite SF. apply f_equal. apply f_equal. apply f_equal. auto with ptrofs.
+  unfold_wrapper.
+  simpl. (* rewrite SF. *) apply f_equal. apply f_equal. unfold Vptrofs. rewrite SF. f_equal.
+  erewrite <- (Ptrofs.to_int64_of_int64 SF (Int64.repr delta)). f_equal. auto with ptrofs.
 + eapply eval_Ebinop; eauto using make_intconst_correct.
-  simpl. rewrite SF. apply f_equal. apply f_equal. apply f_equal. auto with ptrofs.
+  unfold_wrapper.
+  simpl. (* rewrite SF. *) apply f_equal. apply f_equal. unfold Vptrofs. rewrite SF. f_equal.
+  erewrite <- (Ptrofs.to_int_of_int SF (Int.repr delta)). f_equal. auto with ptrofs.
 - (* field union *)
-  unfold make_field_access in EQ0; rewrite H1 in EQ0; monadInv EQ0.
+  unfold make_field_access in EQ0; rewrite H2 in EQ0; monadInv EQ0.
   auto.
 Qed.
 
@@ -1282,11 +1427,11 @@ Lemma transl_expr_correct:
 Proof (proj1 transl_expr_lvalue_correct).
 
 Lemma transl_lvalue_correct:
-   forall a b ofs,
-   Clight.eval_lvalue ge e le m a b ofs ->
+   forall a v,
+   Clight.eval_lvalue ge e le m a v ->
    forall ta, transl_lvalue cunit.(prog_comp_env) a = OK ta ->
-   Csharpminor.eval_expr tge te le m ta (Vptr b ofs).
-Proof (proj2 transl_expr_lvalue_correct).
+   Csharpminor.eval_expr tge te le m ta v.
+Proof. eapply (proj2 transl_expr_lvalue_correct). Qed.
 
 Lemma transl_arglist_correct:
   forall al tyl vl,
@@ -1338,10 +1483,10 @@ Inductive match_transl: stmt -> cont -> stmt -> cont -> Prop :=
 Lemma match_transl_step:
   forall ts tk ts' tk' f te le m,
   match_transl (Sblock ts) tk ts' tk' ->
-  star step tge (State f ts' tk' te le m) E0 (State f ts (Kblock tk) te le m).
+  DStar tsem (State f ts' tk' te le m) E0 (State f ts (Kblock tk) te le m).
 Proof.
   intros. inv H.
-  apply star_one. constructor.
+  apply star_one. DStep_tac. constructor.
   apply star_refl.
 Qed.
 
@@ -1557,10 +1702,11 @@ Qed.
 (** The simulation proof *)
 
 Lemma transl_step:
-  forall S1 t S2, Clight.step2 ge S1 t S2 ->
+  forall S1 t S2, IStep sem S1 t S2 ->
   forall T1, match_states S1 T1 ->
-  exists T2, plus step tge T1 t T2 /\ match_states S2 T2.
+  exists T2, DPlus tsem T1 t T2 /\ match_states S2 T2.
 Proof.
+  destruct 1. generalize dependent S2. rename H into INT.
   induction 1; intros T1 MST; inv MST.
 
 - (* assign *)
@@ -1571,14 +1717,16 @@ Proof.
     destruct (access_mode (typeof a1)); monadInv EQ3; auto. }
   destruct SAME; subst ts' tk'.
   econstructor; split.
-  apply plus_one. eapply make_store_correct; eauto.
+  apply plus_one. DStep_tac.
+  { des_ifs. unfold make_store in *. des_ifs. monadInv EQ3; ss. }
+  eapply make_store_correct; eauto.
   eapply transl_lvalue_correct; eauto. eapply make_cast_correct; eauto.
   eapply transl_expr_correct; eauto.
   eapply match_states_skip; eauto.
 
 - (* set *)
   monadInv TR. inv MTR. econstructor; split.
-  apply plus_one. econstructor. eapply transl_expr_correct; eauto.
+  apply plus_one. DStep_tac. econstructor. eapply transl_expr_correct; eauto.
   eapply match_states_skip; eauto.
 
 - (* call *)
@@ -1604,7 +1752,7 @@ Proof.
   destruct EITHER as [(EK & ES) | (id & EI & EK & ES)]; rewrite EK, ES.
   + (* without normalization of return value *)
     econstructor; split.
-    apply plus_one. eapply step_call; eauto.
+    apply plus_one. DStep_tac. eapply step_call; eauto.
     eapply transl_expr_correct with (cunit := cu); eauto.
     eapply transl_arglist_correct with (cunit := cu); eauto.
     econstructor; eauto.
@@ -1613,7 +1761,7 @@ Proof.
   + (* with normalization of return value *)
     subst optid.
     econstructor; split.
-    eapply plus_two. apply step_seq. eapply step_call; eauto. 
+    eapply plus_two. DStep_tac. apply step_seq. DStep_tac. eapply step_call; eauto. 
     eapply transl_expr_correct with (cunit := cu); eauto.
     eapply transl_arglist_correct with (cunit := cu); eauto.
     traceEq.
@@ -1625,7 +1773,7 @@ Proof.
 - (* builtin *)
   monadInv TR. inv MTR.
   econstructor; split.
-  apply plus_one. econstructor.
+  apply plus_one. DStep_tac. econstructor.
   eapply transl_arglist_correct; eauto.
   eapply external_call_symbols_preserved with (ge1 := ge). apply senv_preserved. eauto.
   eapply match_states_skip; eauto.
@@ -1633,26 +1781,26 @@ Proof.
 - (* seq *)
   monadInv TR. inv MTR.
   econstructor; split.
-  apply plus_one. constructor.
+  apply plus_one. DStep_tac. constructor.
   econstructor; eauto. constructor.
   econstructor; eauto.
 
 - (* skip seq *)
   monadInv TR. inv MTR. inv MK.
   econstructor; split.
-  apply plus_one. apply step_skip_seq.
+  apply plus_one. DStep_tac. apply step_skip_seq.
   econstructor; eauto. constructor.
 
 - (* continue seq *)
   monadInv TR. inv MTR. inv MK.
   econstructor; split.
-  apply plus_one. constructor.
+  apply plus_one. DStep_tac. constructor.
   econstructor; eauto. simpl. reflexivity. constructor.
 
 - (* break seq *)
   monadInv TR. inv MTR. inv MK.
   econstructor; split.
-  apply plus_one. constructor.
+  apply plus_one. DStep_tac. constructor.
   econstructor; eauto. simpl. reflexivity. constructor.
 
 - (* ifthenelse *)
@@ -1661,16 +1809,16 @@ Proof.
   exploit transl_expr_correct; eauto.
   intros [v [A B]].
   econstructor; split.
-  apply plus_one. apply step_ifthenelse with (v := v) (b := b); auto.
+  apply plus_one. DStep_tac. apply step_ifthenelse with (v := v) (b := b); eauto.
   destruct b; econstructor; eauto; constructor.
 
 - (* loop *)
   monadInv TR.
   econstructor; split.
   eapply star_plus_trans. eapply match_transl_step; eauto.
-  eapply plus_left. constructor.
-  eapply star_left. constructor.
-  apply star_one. constructor.
+  eapply plus_left. DStep_tac. constructor.
+  eapply star_left. DStep_tac. constructor.
+  apply star_one. DStep_tac. constructor.
   reflexivity. reflexivity. traceEq.
   econstructor; eauto. constructor. econstructor; eauto.
 
@@ -1680,24 +1828,25 @@ Proof.
   destruct H0. inv MK.
   econstructor; split.
   eapply plus_left.
-  destruct H0; subst ts'. 2:constructor. constructor.
-  apply star_one. constructor. traceEq.
+  DStep_tac. des_ifs; des; clarify.
+  destruct H0; subst ts'. ss. ss. 2:constructor. constructor.
+  apply star_one. DStep_tac. constructor. traceEq.
   econstructor; eauto. constructor. econstructor; eauto.
 
 - (* break loop1 *)
   monadInv TR. inv MTR. inv MK.
   econstructor; split.
-  eapply plus_left. constructor.
-  eapply star_left. constructor.
-  eapply star_left. constructor.
-  apply star_one. constructor.
+  eapply plus_left. DStep_tac. constructor.
+  eapply star_left. DStep_tac. constructor.
+  eapply star_left. DStep_tac. constructor.
+  apply star_one. DStep_tac. constructor.
   reflexivity. reflexivity. traceEq.
   eapply match_states_skip; eauto.
 
 - (* skip loop2 *)
   monadInv TR. inv MTR. inv MK.
   econstructor; split.
-  apply plus_one. constructor.
+  apply plus_one. DStep_tac. constructor.
   econstructor; eauto.
   simpl. rewrite H6; simpl. rewrite H8; simpl. eauto.
   constructor.
@@ -1705,15 +1854,15 @@ Proof.
 - (* break loop2 *)
   monadInv TR. inv MTR. inv MK.
   econstructor; split.
-  eapply plus_left. constructor.
-  apply star_one. constructor.
+  eapply plus_left. DStep_tac. constructor.
+  apply star_one. DStep_tac. constructor.
   traceEq.
   eapply match_states_skip; eauto.
 
 - (* return none *)
   monadInv TR. inv MTR.
   econstructor; split.
-  apply plus_one. constructor.
+  apply plus_one. DStep_tac. constructor.
   eapply match_env_free_blocks; eauto.
   eapply match_returnstate with (ce := prog_comp_env cu); eauto.
   eapply match_cont_call_cont. eauto.
@@ -1722,7 +1871,7 @@ Proof.
 - (* return some *)
   monadInv TR. inv MTR.
   econstructor; split.
-  apply plus_one. constructor.
+  apply plus_one. DStep_tac. constructor.
   eapply make_cast_correct; eauto. eapply transl_expr_correct; eauto.
   eapply match_env_free_blocks; eauto.
   eapply match_returnstate with (ce := prog_comp_env cu); eauto.
@@ -1733,7 +1882,7 @@ Proof.
   monadInv TR. inv MTR.
   exploit match_cont_is_call_cont; eauto. intros [A B].
   econstructor; split.
-  apply plus_one. apply step_skip_call. auto.
+  apply plus_one. DStep_tac. apply step_skip_call. auto.
   eapply match_env_free_blocks; eauto.
   eapply match_returnstate with (ce := prog_comp_env cu); eauto.
   constructor.
@@ -1748,7 +1897,7 @@ Proof.
   exploit transl_expr_correct; eauto. intro EV.
   econstructor; split.
   eapply star_plus_trans. eapply match_transl_step; eauto.
-  apply plus_one. econstructor; eauto. traceEq.
+  apply plus_one. DStep_tac. econstructor; eauto. traceEq.
   econstructor; eauto.
   apply transl_lbl_stmt_2. apply transl_lbl_stmt_1. eauto.
   constructor.
@@ -1759,19 +1908,19 @@ Proof.
     destruct H; subst x; monadInv TR; inv MTR; auto.
   destruct H0. inv MK.
   econstructor; split.
-  apply plus_one. destruct H0; subst ts'. 2:constructor. constructor.
+  apply plus_one. DStep_tac. des_ifs; des; clarify. destruct H0; subst ts'. 2:constructor. constructor.
   eapply match_states_skip; eauto.
 
 - (* continue switch *)
   monadInv TR. inv MTR. inv MK.
   econstructor; split.
-  apply plus_one. constructor.
+  apply plus_one. DStep_tac. constructor.
   econstructor; eauto. simpl. reflexivity. constructor.
 
 - (* label *)
   monadInv TR. inv MTR.
   econstructor; split.
-  apply plus_one. constructor.
+  apply plus_one. DStep_tac. constructor.
   econstructor; eauto. constructor.
 
 - (* goto *)
@@ -1781,7 +1930,7 @@ Proof.
   rewrite H.
   intros [ts' [tk'' [nbrk' [ncnt' [A [B C]]]]]].
   econstructor; split.
-  apply plus_one. constructor. simpl. eexact A.
+  apply plus_one. DStep_tac. constructor. simpl. eexact A.
   econstructor; eauto. constructor.
 
 - (* internal function *)
@@ -1791,7 +1940,7 @@ Proof.
   apply match_env_empty.
   intros [te1 [C D]].
   econstructor; split.
-  apply plus_one. eapply step_internal_function.
+  apply plus_one. DStep_tac. eapply step_internal_function.
   simpl. erewrite transl_vars_names by eauto. assumption.
   simpl. assumption.
   simpl. assumption.
@@ -1807,7 +1956,7 @@ Proof.
   inv TR.
   exploit match_cont_is_call_cont; eauto. intros [A B].
   econstructor; split.
-  apply plus_one. constructor.
+  apply plus_one. DStep_tac. constructor.
   eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   eapply match_returnstate with (ce := ce); eauto.
   apply has_rettype_wt_val. 
@@ -1819,16 +1968,85 @@ Proof.
   inv MK.
   + (* without normalization *)
     econstructor; split.
-    apply plus_one. constructor.
+    apply plus_one. DStep_tac. constructor.
     econstructor; eauto. simpl; reflexivity. constructor.
   + (* with normalization *)
     econstructor; split.
-    eapply plus_three. econstructor. econstructor. constructor.
+    eapply plus_three. DStep_tac. econstructor. DStep_tac. econstructor. DStep_tac. constructor.
     simpl. apply H13. eauto. apply PTree.gss.
     traceEq.
     simpl. rewrite PTree.set2. econstructor; eauto. simpl; reflexivity. constructor.
 Qed.
 
+From Paco Require Import paco.
+
+Lemma match_states_bsim s1
+      (EXT: Clight.is_external ge s1)
+      s2 t s2'
+      (STEPTGT: Step tsem s2 t s2')
+      (MATCH: match_states s1 s2)
+      (SAFESRC: safe sem s1) :
+    (exists s1', Step sem s1 t s1' /\ match_states s1' s2')
+  \/ (~ trace_intact t /\ exists s1'' t', Star sem s1 t' s1'' /\ exists tl, t' = (trace_cut_pterm t) ** tl).
+Proof.
+  assert (SEQUIV: Senv.equiv tge ge) by (symmetry; apply senv_preserved).
+  unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+  { inv SAFESRC. inv MATCH. inv MK. inv STEPTGT. }
+  unfold Clight.is_external in *. des_ifs.
+  (* builtin *)
+  - inv MATCH; try (monadInv TR); clarify. inv MTR.
+    inv STEPTGT; ss; clarify. inv SAFESRC; ss; clarify; try (by (des; clarify)).
+
+    exploit transl_arglist_correct; eauto. i.
+    exploit CsharpminorD.eval_exprlist_determ. eapply H9. eapply H. i. subst.
+    left. esplits. eapply Clight.step_builtin; eauto.
+    eapply external_call_symbols_preserved; eauto.
+    eapply match_states_skip; eauto.
+  (* external call *)
+  - inv MATCH; try (monadInv TR); clarify.
+    inv STEPTGT; ss; clarify; inv TR.
+    inv SAFESRC; ss; clarify; try (by (des; clarify)).
+
+    left. esplits. eapply Clight.step_external_function; eauto.
+    eapply external_call_symbols_preserved; eauto.
+
+    eapply match_returnstate with (ce := ce); eauto.
+    apply has_rettype_wt_val. 
+    replace (rettype_of_type tres) with (sig_res (ef_sig ef)).
+    eapply external_call_well_typed_gen; eauto.
+    rewrite H0. simpl. eauto.
+Qed.
+
+Lemma match_states_xsim
+    st_src0 st_tgt0 gmtgt
+    (MATCH: match_states st_src0 st_tgt0) :
+  xsim (Clight.semantics2 prog) (Csharpminor.semantics tprog) gmtgt lt 0%nat st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold.
+  destruct (classic (Clight.is_external ge st_src0)); cycle 1.
+  (* not external *)
+  - left. econs. econs.
+    + i. exploit transl_step; eauto. i. des.
+      * esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl|].
+        left. split; eauto. eapply semantics2_receptive_at; auto.
+    + ii. eapply final_state_determ; eauto. inv FINALSRC. inv MATCH. inv MK. econs.
+  (* external *)
+  - right. econs. i. econs.
+    + i. exploit match_states_bsim; eauto. i. des.
+      * left. esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl|].
+        left. eapply plus_one. eauto.
+      * right. esplits; eauto. subst. eapply tr_rel_refl. eapply ev_rel_refl.
+    + i. unfold is_external in *. des_ifs; inv FINALTGT; inv MATCH. inv MK. ss.
+    (* progress *)
+    + i. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify; [inv SAFESRC; ss|].
+      right. inv SAFESRC; ss; clarify; try (by (des; clarify)); inv MATCH; try (monadInv TR); clarify.
+      * inv MTR. exploit transl_arglist_correct; eauto. i. esplits. eapply step_builtin; eauto.
+        eapply external_call_symbols_preserved; eauto. eapply senv_preserved.
+      * inv TR. exploit external_call_symbols_preserved. apply senv_preserved. eauto. i.
+        esplits. eapply step_external_function; eauto.
+Qed.
+
 Lemma transl_initial_states:
   forall S, Clight.initial_state prog S ->
   exists R, initial_state tprog R /\ match_states S R.
@@ -1851,14 +2069,49 @@ Proof.
   intros. inv H0. inv H. inv MK. constructor.
 Qed.
 
-Theorem transl_program_correct:
-  forward_simulation (Clight.semantics2 prog) (Csharpminor.semantics tprog).
+Lemma non_static_equiv l:
+  Genv.non_static_glob (Genv.globalenv prog) l = Genv.non_static_glob (Genv.globalenv tprog) l.
 Proof.
-  eapply forward_simulation_plus.
-  apply senv_preserved.
-  eexact transl_initial_states.
-  eexact transl_final_states.
-  eexact transl_step.
+  induction l; ss.
+  specialize senv_preserved. i. unfold ge, tge in H. r in H. des.
+  specialize (H0 a). unfold Clight.fundef in *.
+  unfold Senv.public_symbol in H0. ss.
+  erewrite H0. erewrite H. des_ifs. erewrite IHl. eauto.
+Qed.
+
+Lemma transf_initial_capture S1 S2 S2'
+    (INITSRC: Clight.initial_state prog S1)
+    (INITTGT: Csharpminor.initial_state tprog S2)
+    (MATCH: match_states S1 S2)
+    (CAPTGT: Csharpminor.glob_capture tprog S2 S2'):
+  exists S1', Clight.glob_capture prog S1 S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (Clight.concrete_snapshot ge S1') (Csharpminor.concrete_snapshot tge S2').
+Proof.
+  inv CAPTGT. ss. rewrite Genv.globalenv_public in CAPTURE.
+  rewrite <- same_public in CAPTURE. erewrite <- non_static_equiv in CAPTURE.
+  inv MATCH. inv MK. esplits.
+  - econs; eauto. rewrite Genv.globalenv_public. eauto.
+  - econs; eauto. econs.
+  - unfold Clight.concrete_snapshot, Csharpminor.concrete_snapshot. ii.
+    destruct senv_preserved. des. ss. rewrite H0, H1. ss.
+Unshelve. econs.
+Qed.
+
+Theorem transl_program_correct:
+  mixed_simulation (semantics2 prog) (semantics tprog).
+Proof.
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (S a). lia.
+  - econs. i. exploit transl_initial_states; eauto. i. des.
+    exists R. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. exploit transf_initial_capture; eauto. i. des. esplits; eauto.
+      subst. ss. apply match_states_xsim; auto.
+  - i. apply senv_preserved.
 Qed.
 
 End CORRECTNESS.
diff --git a/cfrontend/Cstrategy.v b/cfrontend/Cstrategy.v
index 6365f85c..d48e2d9b 100644
--- a/cfrontend/Cstrategy.v
+++ b/cfrontend/Cstrategy.v
@@ -1431,11 +1431,19 @@ Qed.
 
 End STRATEGY.
 
+(** Non-deterministic external state *)
+
+Definition is_external (ge: genv) (st: state) : Prop := False.
+
+Definition glob_capture (st st': state) : Prop := False.
+
+Definition concrete_sanpshot (ge: Senv.t) (st: state) (id: ident) : option Z := None.
+
 (** The semantics that follows the strategy. *)
 
 Definition semantics (p: program) :=
   let ge := globalenv p in
-  Semantics_gen step (initial_state p) final_state ge ge.
+  Semantics_gen step (initial_state p) glob_capture (concrete_sanpshot ge) final_state is_external ge ge.
 
 (** This semantics is receptive to changes in events. *)
 
@@ -1478,116 +1486,116 @@ Proof.
   inv H. eapply volatile_store_receptive; eauto.
 Qed.
 
-Lemma semantics_strongly_receptive:
-  forall p, strongly_receptive (semantics p).
-Proof.
-  intros. constructor; simpl; intros.
-(* receptiveness *)
-  set (ge := globalenv p) in *.
-  inversion H; subst.
-  inv H1.
-  (* valof volatile *)
-  exploit deref_loc_receptive; eauto. intros [A [v' B]].
-  econstructor; econstructor. left; eapply step_rvalof_volatile; eauto.
-  (* assign *)
-  exploit assign_loc_receptive; eauto. intro EQ; rewrite EQ in H.
-  econstructor; econstructor; eauto.
-  (* assignop *)
-  destruct t0 as [ | ev0 t0]; simpl in H10.
-  subst t2. exploit assign_loc_receptive; eauto. intros EQ; rewrite EQ in H.
-  econstructor; econstructor; eauto.
-  inv H10. exploit deref_loc_receptive; eauto. intros [EQ [v1' A]]. subst t0.
-  destruct (sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m) as [v3'|] eqn:?.
-  destruct (sem_cast v3' tyres (typeof l) m) as [v4'|] eqn:?.
-  destruct (classic (exists t2', exists m'', assign_loc ge (typeof l) m b ofs v4' t2' m'')).
-  destruct H1 as [t2' [m'' P]].
-  econstructor; econstructor. left; eapply step_assignop with (v1 := v1'); eauto. simpl; reflexivity.
-  econstructor; econstructor. left; eapply step_assignop_stuck with (v1 := v1'); eauto.
-  rewrite Heqo; rewrite Heqo0. intros; red; intros; elim H1. exists t0; exists m'0; auto.
-  econstructor; econstructor. left; eapply step_assignop_stuck with (v1 := v1'); eauto.
-  rewrite Heqo; rewrite Heqo0; auto.
-  econstructor; econstructor. left; eapply step_assignop_stuck with (v1 := v1'); eauto.
-  rewrite Heqo; auto.
-  (* assignop stuck *)
-  exploit deref_loc_receptive; eauto. intros [EQ [v1' A]]. subst t1.
-  destruct (sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m) as [v3'|] eqn:?.
-  destruct (sem_cast v3' tyres (typeof l) m) as [v4'|] eqn:?.
-  destruct (classic (exists t2', exists m'', assign_loc ge (typeof l) m b ofs v4' t2' m'')).
-  destruct H1 as [t2' [m'' P]].
-  econstructor; econstructor. left; eapply step_assignop with (v1 := v1'); eauto. simpl; reflexivity.
-  econstructor; econstructor. left; eapply step_assignop_stuck with (v1 := v1'); eauto.
-  rewrite Heqo; rewrite Heqo0. intros; red; intros; elim H1. exists t2; exists m'; auto.
-  econstructor; econstructor. left; eapply step_assignop_stuck with (v1 := v1'); eauto.
-  rewrite Heqo; rewrite Heqo0; auto.
-  econstructor; econstructor. left; eapply step_assignop_stuck with (v1 := v1'); eauto.
-  rewrite Heqo; auto.
-  (* postincr *)
-  destruct t0 as [ | ev0 t0]; simpl in H9.
-  subst t2. exploit assign_loc_receptive; eauto. intros EQ; rewrite EQ in H.
-  econstructor; econstructor; eauto.
-  inv H9. exploit deref_loc_receptive; eauto. intros [EQ [v1' A]]. subst t0.
-  destruct (sem_incrdecr ge id v1' (typeof l) m) as [v2'|] eqn:?.
-  destruct (sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m) as [v3'|] eqn:?.
-  destruct (classic (exists t2', exists m'', assign_loc ge (typeof l) m b ofs v3' t2' m'')).
-  destruct H1 as [t2' [m'' P]].
-  econstructor; econstructor. left; eapply step_postincr with (v1 := v1'); eauto. simpl; reflexivity.
-  econstructor; econstructor. left; eapply step_postincr_stuck with (v1 := v1'); eauto.
-  rewrite Heqo; rewrite Heqo0. intros; red; intros; elim H1. exists t0; exists m'0; auto.
-  econstructor; econstructor. left; eapply step_postincr_stuck with (v1 := v1'); eauto.
-  rewrite Heqo; rewrite Heqo0; auto.
-  econstructor; econstructor. left; eapply step_postincr_stuck with (v1 := v1'); eauto.
-  rewrite Heqo; auto.
-  (* postincr stuck *)
-  exploit deref_loc_receptive; eauto. intros [EQ [v1' A]]. subst t1.
-  destruct (sem_incrdecr ge id v1' (typeof l) m) as [v2'|] eqn:?.
-  destruct (sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m) as [v3'|] eqn:?.
-  destruct (classic (exists t2', exists m'', assign_loc ge (typeof l) m b ofs v3' t2' m'')).
-  destruct H1 as [t2' [m'' P]].
-  econstructor; econstructor. left; eapply step_postincr with (v1 := v1'); eauto. simpl; reflexivity.
-  econstructor; econstructor. left; eapply step_postincr_stuck with (v1 := v1'); eauto.
-  rewrite Heqo; rewrite Heqo0. intros; red; intros; elim H1. exists t2; exists m'; auto.
-  econstructor; econstructor. left; eapply step_postincr_stuck with (v1 := v1'); eauto.
-  rewrite Heqo; rewrite Heqo0; auto.
-  econstructor; econstructor. left; eapply step_postincr_stuck with (v1 := v1'); eauto.
-  rewrite Heqo; auto.
-  (* builtin *)
-  exploit external_call_trace_length; eauto. destruct t1; simpl; intros.
-  exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
-  econstructor; econstructor. left; eapply step_builtin; eauto.
-  extlia.
-  (* external calls *)
-  inv H1.
-  exploit external_call_trace_length; eauto. destruct t1; simpl; intros.
-  exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
-  exists (Returnstate vres2 k m2); exists E0; right; econstructor; eauto.
-  extlia.
-(* well-behaved traces *)
-  red; intros. inv H; inv H0; simpl; auto.
-  (* valof volatile *)
-  exploit deref_loc_trace; eauto. destruct t; auto. destruct t; tauto.
-  (* assign *)
-  exploit assign_loc_trace; eauto. destruct t; auto. destruct t; simpl; tauto.
-  (* assignop *)
-  exploit deref_loc_trace; eauto. exploit assign_loc_trace; eauto.
-  destruct t1. destruct t2. simpl; auto. destruct t2; simpl; tauto.
-  destruct t1. destruct t2. simpl; auto. destruct t2; simpl; tauto.
-  tauto.
-  (* assignop stuck *)
-  exploit deref_loc_trace; eauto. destruct t; auto. destruct t; tauto.
-  (* postincr *)
-  exploit deref_loc_trace; eauto. exploit assign_loc_trace; eauto.
-  destruct t1. destruct t2. simpl; auto. destruct t2; simpl; tauto.
-  destruct t1. destruct t2. simpl; auto. destruct t2; simpl; tauto.
-  tauto.
-  (* postincr stuck *)
-  exploit deref_loc_trace; eauto. destruct t; auto. destruct t; tauto.
-  (* builtins *)
-  exploit external_call_trace_length; eauto.
-  destruct t; simpl; auto. destruct t; simpl; auto. intros; extlia.
-  (* external calls *)
-  exploit external_call_trace_length; eauto.
-  destruct t; simpl; auto. destruct t; simpl; auto. intros; extlia.
-Qed.
+(* Lemma semantics_strongly_receptive: *)
+(*   forall p, strongly_receptive (semantics p). *)
+(* Proof. *)
+(*   intros. constructor; simpl; intros. *)
+(* (* receptiveness *) *)
+(*   set (ge := globalenv p) in *. *)
+(*   inversion H; subst. *)
+(*   inv H1. *)
+(*   (* valof volatile *) *)
+(*   exploit deref_loc_receptive; eauto. intros [A [v' B]]. *)
+(*   econstructor; econstructor. left; eapply step_rvalof_volatile; eauto. *)
+(*   (* assign *) *)
+(*   exploit assign_loc_receptive; eauto. intro EQ; rewrite EQ in H. *)
+(*   econstructor; econstructor; eauto. *)
+(*   (* assignop *) *)
+(*   destruct t0 as [ | ev0 t0]; simpl in H10. *)
+(*   subst t2. exploit assign_loc_receptive; eauto. intros EQ; rewrite EQ in H. *)
+(*   econstructor; econstructor; eauto. *)
+(*   inv H10. exploit deref_loc_receptive; eauto. intros [EQ [v1' A]]. subst t0. *)
+(*   destruct (sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m) as [v3'|] eqn:?. *)
+(*   destruct (sem_cast v3' tyres (typeof l) m) as [v4'|] eqn:?. *)
+(*   destruct (classic (exists t2', exists m'', assign_loc ge (typeof l) m b ofs v4' t2' m'')). *)
+(*   destruct H1 as [t2' [m'' P]]. *)
+(*   econstructor; econstructor. left; eapply step_assignop with (v1 := v1'); eauto. simpl; reflexivity. *)
+(*   econstructor; econstructor. left; eapply step_assignop_stuck with (v1 := v1'); eauto. *)
+(*   rewrite Heqo; rewrite Heqo0. intros; red; intros; elim H1. exists t0; exists m'0; auto. *)
+(*   econstructor; econstructor. left; eapply step_assignop_stuck with (v1 := v1'); eauto. *)
+(*   rewrite Heqo; rewrite Heqo0; auto. *)
+(*   econstructor; econstructor. left; eapply step_assignop_stuck with (v1 := v1'); eauto. *)
+(*   rewrite Heqo; auto. *)
+(*   (* assignop stuck *) *)
+(*   exploit deref_loc_receptive; eauto. intros [EQ [v1' A]]. subst t1. *)
+(*   destruct (sem_binary_operation ge op v1' (typeof l) v2 (typeof r) m) as [v3'|] eqn:?. *)
+(*   destruct (sem_cast v3' tyres (typeof l) m) as [v4'|] eqn:?. *)
+(*   destruct (classic (exists t2', exists m'', assign_loc ge (typeof l) m b ofs v4' t2' m'')). *)
+(*   destruct H1 as [t2' [m'' P]]. *)
+(*   econstructor; econstructor. left; eapply step_assignop with (v1 := v1'); eauto. simpl; reflexivity. *)
+(*   econstructor; econstructor. left; eapply step_assignop_stuck with (v1 := v1'); eauto. *)
+(*   rewrite Heqo; rewrite Heqo0. intros; red; intros; elim H1. exists t2; exists m'; auto. *)
+(*   econstructor; econstructor. left; eapply step_assignop_stuck with (v1 := v1'); eauto. *)
+(*   rewrite Heqo; rewrite Heqo0; auto. *)
+(*   econstructor; econstructor. left; eapply step_assignop_stuck with (v1 := v1'); eauto. *)
+(*   rewrite Heqo; auto. *)
+(*   (* postincr *) *)
+(*   destruct t0 as [ | ev0 t0]; simpl in H9. *)
+(*   subst t2. exploit assign_loc_receptive; eauto. intros EQ; rewrite EQ in H. *)
+(*   econstructor; econstructor; eauto. *)
+(*   inv H9. exploit deref_loc_receptive; eauto. intros [EQ [v1' A]]. subst t0. *)
+(*   destruct (sem_incrdecr ge id v1' (typeof l) m) as [v2'|] eqn:?. *)
+(*   destruct (sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m) as [v3'|] eqn:?. *)
+(*   destruct (classic (exists t2', exists m'', assign_loc ge (typeof l) m b ofs v3' t2' m'')). *)
+(*   destruct H1 as [t2' [m'' P]]. *)
+(*   econstructor; econstructor. left; eapply step_postincr with (v1 := v1'); eauto. simpl; reflexivity. *)
+(*   econstructor; econstructor. left; eapply step_postincr_stuck with (v1 := v1'); eauto. *)
+(*   rewrite Heqo; rewrite Heqo0. intros; red; intros; elim H1. exists t0; exists m'0; auto. *)
+(*   econstructor; econstructor. left; eapply step_postincr_stuck with (v1 := v1'); eauto. *)
+(*   rewrite Heqo; rewrite Heqo0; auto. *)
+(*   econstructor; econstructor. left; eapply step_postincr_stuck with (v1 := v1'); eauto. *)
+(*   rewrite Heqo; auto. *)
+(*   (* postincr stuck *) *)
+(*   exploit deref_loc_receptive; eauto. intros [EQ [v1' A]]. subst t1. *)
+(*   destruct (sem_incrdecr ge id v1' (typeof l) m) as [v2'|] eqn:?. *)
+(*   destruct (sem_cast v2' (incrdecr_type (typeof l)) (typeof l) m) as [v3'|] eqn:?. *)
+(*   destruct (classic (exists t2', exists m'', assign_loc ge (typeof l) m b ofs v3' t2' m'')). *)
+(*   destruct H1 as [t2' [m'' P]]. *)
+(*   econstructor; econstructor. left; eapply step_postincr with (v1 := v1'); eauto. simpl; reflexivity. *)
+(*   econstructor; econstructor. left; eapply step_postincr_stuck with (v1 := v1'); eauto. *)
+(*   rewrite Heqo; rewrite Heqo0. intros; red; intros; elim H1. exists t2; exists m'; auto. *)
+(*   econstructor; econstructor. left; eapply step_postincr_stuck with (v1 := v1'); eauto. *)
+(*   rewrite Heqo; rewrite Heqo0; auto. *)
+(*   econstructor; econstructor. left; eapply step_postincr_stuck with (v1 := v1'); eauto. *)
+(*   rewrite Heqo; auto. *)
+(*   (* builtin *) *)
+(*   exploit external_call_trace_length; eauto. destruct t1; simpl; intros. *)
+(*   exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]]. *)
+(*   econstructor; econstructor. left; eapply step_builtin; eauto. *)
+(*   extlia. *)
+(*   (* external calls *) *)
+(*   inv H1. *)
+(*   exploit external_call_trace_length; eauto. destruct t1; simpl; intros. *)
+(*   exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]]. *)
+(*   exists (Returnstate vres2 k m2); exists E0; right; econstructor; eauto. *)
+(*   extlia. *)
+(* (* well-behaved traces *) *)
+(*   red; intros. inv H; inv H0; simpl; auto. *)
+(*   (* valof volatile *) *)
+(*   exploit deref_loc_trace; eauto. destruct t; auto. destruct t; tauto. *)
+(*   (* assign *) *)
+(*   exploit assign_loc_trace; eauto. destruct t; auto. destruct t; simpl; tauto. *)
+(*   (* assignop *) *)
+(*   exploit deref_loc_trace; eauto. exploit assign_loc_trace; eauto. *)
+(*   destruct t1. destruct t2. simpl; auto. destruct t2; simpl; tauto. *)
+(*   destruct t1. destruct t2. simpl; auto. destruct t2; simpl; tauto. *)
+(*   tauto. *)
+(*   (* assignop stuck *) *)
+(*   exploit deref_loc_trace; eauto. destruct t; auto. destruct t; tauto. *)
+(*   (* postincr *) *)
+(*   exploit deref_loc_trace; eauto. exploit assign_loc_trace; eauto. *)
+(*   destruct t1. destruct t2. simpl; auto. destruct t2; simpl; tauto. *)
+(*   destruct t1. destruct t2. simpl; auto. destruct t2; simpl; tauto. *)
+(*   tauto. *)
+(*   (* postincr stuck *) *)
+(*   exploit deref_loc_trace; eauto. destruct t; auto. destruct t; tauto. *)
+(*   (* builtins *) *)
+(*   exploit external_call_trace_length; eauto. *)
+(*   destruct t; simpl; auto. destruct t; simpl; auto. intros; extlia. *)
+(*   (* external calls *) *)
+(*   exploit external_call_trace_length; eauto. *)
+(*   destruct t; simpl; auto. destruct t; simpl; auto. intros; extlia. *)
+(* Qed. *)
 
 (** The main simulation result. *)
 
@@ -1612,1452 +1620,1452 @@ Qed.
 
 (** * A big-step semantics for CompCert C implementing the reduction strategy. *)
 
-Section BIGSTEP.
-
-Variable ge: genv.
-
-(** The execution of a statement produces an ``outcome'', indicating
-  how the execution terminated: either normally or prematurely
-  through the execution of a [break], [continue] or [return] statement. *)
-
-Inductive outcome: Type :=
-   | Out_break: outcome                 (**r terminated by [break] *)
-   | Out_continue: outcome              (**r terminated by [continue] *)
-   | Out_normal: outcome                (**r terminated normally *)
-   | Out_return: option (val * type) -> outcome. (**r terminated by [return] *)
-
-Inductive out_normal_or_continue : outcome -> Prop :=
-  | Out_normal_or_continue_N: out_normal_or_continue Out_normal
-  | Out_normal_or_continue_C: out_normal_or_continue Out_continue.
-
-Inductive out_break_or_return : outcome -> outcome -> Prop :=
-  | Out_break_or_return_B: out_break_or_return Out_break Out_normal
-  | Out_break_or_return_R: forall ov,
-      out_break_or_return (Out_return ov) (Out_return ov).
-
-Definition outcome_switch (out: outcome) : outcome :=
-  match out with
-  | Out_break => Out_normal
-  | o => o
-  end.
-
-Definition outcome_result_value (out: outcome) (t: type) (v: val) (m: mem) : Prop :=
-  match out, t with
-  | Out_normal, Tvoid => v = Vundef
-  | Out_return None, Tvoid => v = Vundef
-  | Out_return (Some (v', ty')), ty => ty <> Tvoid /\ sem_cast v' ty' ty m = Some v
-  | _, _ => False
-  end.
-
-(** [eval_expression ge e m1 a t m2 a'] describes the evaluation of the
-  complex expression e.  [v] is the resulting value, [m2] the final
-  memory state, and [t] the trace of input/output events performed
-  during this evaluation.  *)
-
-Inductive eval_expression: env -> mem -> expr -> trace -> mem -> val -> Prop :=
-  | eval_expression_intro: forall e m a t m' a' v,
-      eval_expr e m RV a t m' a' -> eval_simple_rvalue ge e m' a' v ->
-      eval_expression e m a t m' v
-
-with eval_expr: env -> mem -> kind -> expr -> trace -> mem -> expr -> Prop :=
-  | eval_val: forall e m v ty,
-      eval_expr e m RV (Eval v ty) E0 m (Eval v ty)
-  | eval_var: forall e m x ty,
-      eval_expr e m LV (Evar x ty) E0 m (Evar x ty)
-  | eval_field: forall e m a t m' a' f ty,
-      eval_expr e m RV a t m' a' ->
-      eval_expr e m LV (Efield a f ty) t m' (Efield a' f ty)
-  | eval_valof: forall e m a t m' a' ty,
-      type_is_volatile (typeof a) = false ->
-      eval_expr e m LV a t m' a' ->
-      eval_expr e m RV (Evalof a ty) t m' (Evalof a' ty)
-  | eval_valof_volatile: forall e m a t1 m' a' ty b ofs t2 v,
-      type_is_volatile (typeof a) = true ->
-      eval_expr e m LV a t1 m' a' ->
-      eval_simple_lvalue ge e m' a' b ofs ->
-      deref_loc ge (typeof a) m' b ofs t2 v ->
-      ty = typeof a ->
-      eval_expr e m RV (Evalof a ty) (t1 ** t2) m' (Eval v ty)
-  | eval_deref: forall e m a t m' a' ty,
-      eval_expr e m RV a t m' a' ->
-      eval_expr e m LV (Ederef a ty) t m' (Ederef a' ty)
-  | eval_addrof: forall e m a t m' a' ty,
-      eval_expr e m LV a t m' a' ->
-      eval_expr e m RV (Eaddrof a ty) t m' (Eaddrof a' ty)
-  | eval_unop: forall e m a t m' a' op ty,
-      eval_expr e m RV a t m' a' ->
-      eval_expr e m RV (Eunop op a ty) t m' (Eunop op a' ty)
-  | eval_binop: forall e m a1 t1 m' a1' a2 t2 m'' a2' op ty,
-      eval_expr e m RV a1 t1 m' a1' -> eval_expr e m' RV a2 t2 m'' a2' ->
-      eval_expr e m RV (Ebinop op a1 a2 ty) (t1 ** t2) m'' (Ebinop op a1' a2' ty)
-  | eval_cast: forall e m a t m' a' ty,
-      eval_expr e m RV a t m' a' ->
-      eval_expr e m RV (Ecast a ty) t m' (Ecast a' ty)
-  | eval_seqand_true: forall e m a1 a2 ty t1 m' a1' v1 t2 m'' a2' v2 v,
-      eval_expr e m RV a1 t1 m' a1' -> eval_simple_rvalue ge e m' a1' v1 ->
-      bool_val v1 (typeof a1) m' = Some true ->
-      eval_expr e m' RV a2 t2 m'' a2' -> eval_simple_rvalue ge e m'' a2' v2 ->
-      sem_cast v2 (typeof a2) type_bool m'' = Some v ->
-      eval_expr e m RV (Eseqand a1 a2 ty) (t1**t2) m'' (Eval v ty)
-  | eval_seqand_false: forall e m a1 a2 ty t1 m' a1' v1,
-      eval_expr e m RV a1 t1 m' a1' -> eval_simple_rvalue ge e m' a1' v1 ->
-      bool_val v1 (typeof a1) m' = Some false ->
-      eval_expr e m RV (Eseqand a1 a2 ty) t1 m' (Eval (Vint Int.zero) ty)
-  | eval_seqor_false: forall e m a1 a2 ty t1 m' a1' v1 t2 m'' a2' v2 v,
-      eval_expr e m RV a1 t1 m' a1' -> eval_simple_rvalue ge e m' a1' v1 ->
-      bool_val v1 (typeof a1) m' = Some false ->
-      eval_expr e m' RV a2 t2 m'' a2' -> eval_simple_rvalue ge e m'' a2' v2 ->
-      sem_cast v2 (typeof a2) type_bool m'' = Some v ->
-      eval_expr e m RV (Eseqor a1 a2 ty) (t1**t2) m'' (Eval v ty)
-  | eval_seqor_true: forall e m a1 a2 ty t1 m' a1' v1,
-      eval_expr e m RV a1 t1 m' a1' -> eval_simple_rvalue ge e m' a1' v1 ->
-      bool_val v1 (typeof a1) m' = Some true ->
-      eval_expr e m RV (Eseqor a1 a2 ty) t1 m' (Eval (Vint Int.one) ty)
-  | eval_condition: forall e m a1 a2 a3 ty t1 m' a1' v1 t2 m'' a' v' b v,
-      eval_expr e m RV a1 t1 m' a1' -> eval_simple_rvalue ge e m' a1' v1 ->
-      bool_val v1 (typeof a1) m' = Some b ->
-      eval_expr e m' RV (if b then a2 else a3) t2 m'' a' -> eval_simple_rvalue ge e m'' a' v' ->
-      sem_cast v' (typeof (if b then a2 else a3)) ty m'' = Some v ->
-      eval_expr e m RV (Econdition a1 a2 a3 ty) (t1**t2) m'' (Eval v ty)
-  | eval_sizeof: forall e m ty' ty,
-      eval_expr e m RV (Esizeof ty' ty) E0 m (Esizeof ty' ty)
-  | eval_alignof: forall e m ty' ty,
-      eval_expr e m RV (Ealignof ty' ty) E0 m (Ealignof ty' ty)
-  | eval_assign: forall e m l r ty t1 m1 l' t2 m2 r' b ofs v v' t3 m3,
-      eval_expr e m LV l t1 m1 l' -> eval_expr e m1 RV r t2 m2 r' ->
-      eval_simple_lvalue ge e m2 l' b ofs ->
-      eval_simple_rvalue ge e m2 r' v ->
-      sem_cast v (typeof r) (typeof l) m2 = Some v' ->
-      assign_loc ge (typeof l) m2 b ofs v' t3 m3 ->
-      ty = typeof l ->
-      eval_expr e m RV (Eassign l r ty) (t1**t2**t3) m3 (Eval v' ty)
-  | eval_assignop: forall e m op l r tyres ty t1 m1 l' t2 m2 r' b ofs
-                          v1 v2 v3 v4 t3 t4 m3,
-      eval_expr e m LV l t1 m1 l' -> eval_expr e m1 RV r t2 m2 r' ->
-      eval_simple_lvalue ge e m2 l' b ofs ->
-      deref_loc ge (typeof l) m2 b ofs t3 v1 ->
-      eval_simple_rvalue ge e m2 r' v2 ->
-      sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m2 = Some v3 ->
-      sem_cast v3 tyres (typeof l) m2 = Some v4 ->
-      assign_loc ge (typeof l) m2 b ofs v4 t4 m3 ->
-      ty = typeof l ->
-      eval_expr e m RV (Eassignop op l r tyres ty) (t1**t2**t3**t4) m3 (Eval v4 ty)
-  | eval_postincr: forall e m id l ty t1 m1 l' b ofs v1 v2 v3 m2 t2 t3,
-      eval_expr e m LV l t1 m1 l' ->
-      eval_simple_lvalue ge e m1 l' b ofs ->
-      deref_loc ge ty m1 b ofs t2 v1 ->
-      sem_incrdecr ge id v1 ty m1 = Some v2 ->
-      sem_cast v2 (incrdecr_type ty) ty m1 = Some v3 ->
-      assign_loc ge ty m1 b ofs v3 t3 m2 ->
-      ty = typeof l ->
-      eval_expr e m RV (Epostincr id l ty) (t1**t2**t3) m2 (Eval v1 ty)
-  | eval_comma: forall e m r1 r2 ty t1 m1 r1' v1 t2 m2 r2',
-      eval_expr e m RV r1 t1 m1 r1' ->
-      eval_simple_rvalue ge e m1 r1' v1 ->
-      eval_expr e m1 RV r2 t2 m2 r2' ->
-      ty = typeof r2 ->
-      eval_expr e m RV (Ecomma r1 r2 ty) (t1**t2) m2 r2'
-  | eval_call: forall e m rf rargs ty t1 m1 rf' t2 m2 rargs' vf vargs
-                      targs tres cconv fd t3 m3 vres,
-      eval_expr e m RV rf t1 m1 rf' -> eval_exprlist e m1 rargs t2 m2 rargs' ->
-      eval_simple_rvalue ge e m2 rf' vf ->
-      eval_simple_list ge e m2 rargs' targs vargs ->
-      classify_fun (typeof rf) = fun_case_f targs tres cconv ->
-      Genv.find_funct ge vf = Some fd ->
-      type_of_fundef fd = Tfunction targs tres cconv ->
-      eval_funcall m2 fd vargs t3 m3 vres ->
-      eval_expr e m RV (Ecall rf rargs ty) (t1**t2**t3) m3 (Eval vres ty)
-
-with eval_exprlist: env -> mem -> exprlist -> trace -> mem -> exprlist -> Prop :=
-  | eval_nil: forall e m,
-      eval_exprlist e m Enil E0 m Enil
-  | eval_cons: forall e m a1 al t1 m1 a1' t2 m2 al',
-      eval_expr e m RV a1 t1 m1 a1' -> eval_exprlist e m1 al t2 m2 al' ->
-      eval_exprlist e m (Econs a1 al) (t1**t2) m2 (Econs a1' al')
-
-(** [exec_stmt ge e m1 s t m2 out] describes the execution of
-  the statement [s].  [out] is the outcome for this execution.
-  [m1] is the initial memory state, [m2] the final memory state.
-  [t] is the trace of input/output events performed during this
-  evaluation. *)
-
-with exec_stmt: env -> mem -> statement -> trace -> mem -> outcome -> Prop :=
-  | exec_Sskip:   forall e m,
-      exec_stmt e m Sskip
-               E0 m Out_normal
-  | exec_Sdo:     forall e m a t m' v,
-      eval_expression e m a t m' v ->
-      exec_stmt e m (Sdo a)
-                t m' Out_normal
-  | exec_Sseq_1:   forall e m s1 s2 t1 m1 t2 m2 out,
-      exec_stmt e m s1 t1 m1 Out_normal ->
-      exec_stmt e m1 s2 t2 m2 out ->
-      exec_stmt e m (Ssequence s1 s2)
-                (t1 ** t2) m2 out
-  | exec_Sseq_2:   forall e m s1 s2 t1 m1 out,
-      exec_stmt e m s1 t1 m1 out ->
-      out <> Out_normal ->
-      exec_stmt e m (Ssequence s1 s2)
-                t1 m1 out
-  | exec_Sifthenelse: forall e m a s1 s2 t1 m1 v1 t2 m2 b out,
-      eval_expression e m a t1 m1 v1 ->
-      bool_val v1 (typeof a) m1 = Some b ->
-      exec_stmt e m1 (if b then s1 else s2) t2 m2 out ->
-      exec_stmt e m (Sifthenelse a s1 s2)
-                (t1**t2) m2 out
-  | exec_Sreturn_none:   forall e m,
-      exec_stmt e m (Sreturn None)
-               E0 m (Out_return None)
-  | exec_Sreturn_some: forall e m a t m' v,
-      eval_expression e m a t m' v ->
-      exec_stmt e m (Sreturn (Some a))
-                t m' (Out_return (Some(v, typeof a)))
-  | exec_Sbreak:   forall e m,
-      exec_stmt e m Sbreak
-               E0 m Out_break
-  | exec_Scontinue:   forall e m,
-      exec_stmt e m Scontinue
-               E0 m Out_continue
-  | exec_Swhile_false: forall e m a s t m' v,
-      eval_expression e m a t m' v ->
-      bool_val v (typeof a) m' = Some false ->
-      exec_stmt e m (Swhile a s)
-                t m' Out_normal
-  | exec_Swhile_stop: forall e m a s t1 m1 v t2 m2 out' out,
-      eval_expression e m a t1 m1 v ->
-      bool_val v (typeof a) m1 = Some true ->
-      exec_stmt e m1 s t2 m2 out' ->
-      out_break_or_return out' out ->
-      exec_stmt e m (Swhile a s)
-                (t1**t2) m2 out
-  | exec_Swhile_loop: forall e m a s t1 m1 v t2 m2 out1 t3 m3 out,
-      eval_expression e m a t1 m1 v ->
-      bool_val v (typeof a) m1 = Some true ->
-      exec_stmt e m1 s t2 m2 out1 ->
-      out_normal_or_continue out1 ->
-      exec_stmt e m2 (Swhile a s) t3 m3 out ->
-      exec_stmt e m (Swhile a s)
-                (t1 ** t2 ** t3) m3 out
-  | exec_Sdowhile_false: forall e m s a t1 m1 out1 t2 m2 v,
-      exec_stmt e m s t1 m1 out1 ->
-      out_normal_or_continue out1 ->
-      eval_expression e m1 a t2 m2 v ->
-      bool_val v (typeof a) m2 = Some false ->
-      exec_stmt e m (Sdowhile a s)
-                (t1 ** t2) m2 Out_normal
-  | exec_Sdowhile_stop: forall e m s a t m1 out1 out,
-      exec_stmt e m s t m1 out1 ->
-      out_break_or_return out1 out ->
-      exec_stmt e m (Sdowhile a s)
-                t m1 out
-  | exec_Sdowhile_loop: forall e m s a t1 m1 out1 t2 m2 v t3 m3 out,
-      exec_stmt e m s t1 m1 out1 ->
-      out_normal_or_continue out1 ->
-      eval_expression e m1 a t2 m2 v ->
-      bool_val v (typeof a) m2 = Some true ->
-      exec_stmt e m2 (Sdowhile a s) t3 m3 out ->
-      exec_stmt e m (Sdowhile a s)
-                (t1 ** t2 ** t3) m3 out
-  | exec_Sfor_start: forall e m s a1 a2 a3 out m1 m2 t1 t2,
-      exec_stmt e m a1 t1 m1 Out_normal ->
-      exec_stmt e m1 (Sfor Sskip a2 a3 s) t2 m2 out ->
-      exec_stmt e m (Sfor a1 a2 a3 s)
-                (t1 ** t2) m2 out
-  | exec_Sfor_false: forall e m s a2 a3 t m' v,
-      eval_expression e m a2 t m' v ->
-      bool_val v (typeof a2) m' = Some false ->
-      exec_stmt e m (Sfor Sskip a2 a3 s)
-                t m' Out_normal
-  | exec_Sfor_stop: forall e m s a2 a3 t1 m1 v t2 m2 out1 out,
-      eval_expression e m a2 t1 m1 v ->
-      bool_val v (typeof a2) m1 = Some true ->
-      exec_stmt e m1 s t2 m2 out1 ->
-      out_break_or_return out1 out ->
-      exec_stmt e m (Sfor Sskip a2 a3 s)
-                (t1 ** t2) m2 out
-  | exec_Sfor_loop: forall e m s a2 a3 t1 m1 v t2 m2 out1 t3 m3 t4 m4 out,
-      eval_expression e m a2 t1 m1 v ->
-      bool_val v (typeof a2) m1 = Some true ->
-      exec_stmt e m1 s t2 m2 out1 ->
-      out_normal_or_continue out1 ->
-      exec_stmt e m2 a3 t3 m3 Out_normal ->
-      exec_stmt e m3 (Sfor Sskip a2 a3 s) t4 m4 out ->
-      exec_stmt e m (Sfor Sskip a2 a3 s)
-                (t1 ** t2 ** t3 ** t4) m4 out
-  | exec_Sswitch:   forall e m a sl t1 m1 v n t2 m2 out,
-      eval_expression e m a t1 m1 v ->
-      sem_switch_arg v (typeof a) = Some n ->
-      exec_stmt e m1 (seq_of_labeled_statement (select_switch n sl)) t2 m2 out ->
-      exec_stmt e m (Sswitch a sl)
-                (t1 ** t2) m2 (outcome_switch out)
-
-(** [eval_funcall m1 fd args t m2 res] describes the invocation of
-  function [fd] with arguments [args].  [res] is the value returned
-  by the call.  *)
-
-with eval_funcall: mem -> fundef -> list val -> trace -> mem -> val -> Prop :=
-  | eval_funcall_internal: forall m f vargs t e m1 m2 m3 out vres m4,
-      list_norepet (var_names f.(fn_params) ++ var_names f.(fn_vars)) ->
-      alloc_variables ge empty_env m (f.(fn_params) ++ f.(fn_vars)) e m1 ->
-      bind_parameters ge e m1 f.(fn_params) vargs m2 ->
-      exec_stmt e m2 f.(fn_body) t m3 out ->
-      outcome_result_value out f.(fn_return) vres m3 ->
-      Mem.free_list m3 (blocks_of_env ge e) = Some m4 ->
-      eval_funcall m (Internal f) vargs t m4 vres
-  | eval_funcall_external: forall m ef targs tres cconv vargs t vres m',
-      external_call ef ge vargs m t vres m' ->
-      eval_funcall m (External ef targs tres cconv) vargs t m' vres.
-
-Scheme eval_expression_ind5 := Minimality for eval_expression Sort Prop
-  with eval_expr_ind5 := Minimality for eval_expr Sort Prop
-  with eval_exprlist_ind5 := Minimality for eval_exprlist Sort Prop
-  with exec_stmt_ind5 := Minimality for exec_stmt Sort Prop
-  with eval_funcall_ind5 := Minimality for eval_funcall Sort Prop.
-
-Combined Scheme bigstep_induction from
-        eval_expression_ind5,  eval_expr_ind5,  eval_exprlist_ind5,
-        exec_stmt_ind5, eval_funcall_ind5.
-
-(** [evalinf_expr ge e m1 K a T] denotes the fact that expression [a]
-  diverges in initial state [m1].  [T] is the trace of input/output
-  events performed during this evaluation.  *)
-
-CoInductive evalinf_expr: env -> mem -> kind -> expr -> traceinf -> Prop :=
-  | evalinf_field: forall e m a t f ty,
-      evalinf_expr e m RV a t ->
-      evalinf_expr e m LV (Efield a f ty) t
-  | evalinf_valof: forall e m a t ty,
-      evalinf_expr e m LV a t ->
-      evalinf_expr e m RV (Evalof a ty) t
-  | evalinf_deref: forall e m a t ty,
-      evalinf_expr e m RV a t ->
-      evalinf_expr e m LV (Ederef a ty) t
-  | evalinf_addrof: forall e m a t ty,
-      evalinf_expr e m LV a t ->
-      evalinf_expr e m RV (Eaddrof a ty) t
-  | evalinf_unop: forall e m a t op ty,
-      evalinf_expr e m RV a t ->
-      evalinf_expr e m RV (Eunop op a ty) t
-  | evalinf_binop_left: forall e m a1 t1 a2 op ty,
-      evalinf_expr e m RV a1 t1 ->
-      evalinf_expr e m RV (Ebinop op a1 a2 ty) t1
-  | evalinf_binop_right: forall e m a1 t1 m' a1' a2 t2 op ty,
-      eval_expr e m RV a1 t1 m' a1' -> evalinf_expr e m' RV a2 t2 ->
-      evalinf_expr e m RV (Ebinop op a1 a2 ty) (t1 *** t2)
-  | evalinf_cast: forall e m a t ty,
-      evalinf_expr e m RV a t ->
-      evalinf_expr e m RV (Ecast a ty) t
-  | evalinf_seqand: forall e m a1 a2 ty t1,
-      evalinf_expr e m RV a1 t1 ->
-      evalinf_expr e m RV (Eseqand a1 a2 ty) t1
-  | evalinf_seqand_2: forall e m a1 a2 ty t1 m' a1' v1 t2,
-      eval_expr e m RV a1 t1 m' a1' -> eval_simple_rvalue ge e m' a1' v1 ->
-      bool_val v1 (typeof a1) m' = Some true ->
-      evalinf_expr e m' RV a2 t2 ->
-      evalinf_expr e m RV (Eseqand a1 a2 ty) (t1***t2)
-  | evalinf_seqor: forall e m a1 a2 ty t1,
-      evalinf_expr e m RV a1 t1 ->
-      evalinf_expr e m RV (Eseqor a1 a2 ty) t1
-  | evalinf_seqor_2: forall e m a1 a2 ty t1 m' a1' v1 t2,
-      eval_expr e m RV a1 t1 m' a1' -> eval_simple_rvalue ge e m' a1' v1 ->
-      bool_val v1 (typeof a1) m' = Some false ->
-      evalinf_expr e m' RV a2 t2 ->
-      evalinf_expr e m RV (Eseqor a1 a2 ty) (t1***t2)
-  | evalinf_condition: forall e m a1 a2 a3 ty t1,
-      evalinf_expr e m RV a1 t1 ->
-      evalinf_expr e m RV (Econdition a1 a2 a3 ty) t1
-  | evalinf_condition_2: forall e m a1 a2 a3 ty t1 m' a1' v1 t2 b,
-      eval_expr e m RV a1 t1 m' a1' -> eval_simple_rvalue ge e m' a1' v1 ->
-      bool_val v1 (typeof a1) m' = Some b ->
-      evalinf_expr e m' RV (if b then a2 else a3) t2 ->
-      evalinf_expr e m RV (Econdition a1 a2 a3 ty) (t1***t2)
-  | evalinf_assign_left: forall e m a1 t1 a2 ty,
-      evalinf_expr e m LV a1 t1 ->
-      evalinf_expr e m RV (Eassign a1 a2 ty) t1
-  | evalinf_assign_right: forall e m a1 t1 m' a1' a2 t2 ty,
-      eval_expr e m LV a1 t1 m' a1' -> evalinf_expr e m' RV a2 t2 ->
-      evalinf_expr e m RV (Eassign a1 a2 ty) (t1 *** t2)
-  | evalinf_assignop_left: forall e m a1 t1 a2 op tyres ty,
-      evalinf_expr e m LV a1 t1 ->
-      evalinf_expr e m RV (Eassignop op a1 a2 tyres ty) t1
-  | evalinf_assignop_right: forall e m a1 t1 m' a1' a2 t2 op tyres ty,
-      eval_expr e m LV a1 t1 m' a1' -> evalinf_expr e m' RV a2 t2 ->
-      evalinf_expr e m RV (Eassignop op a1 a2 tyres ty) (t1 *** t2)
-  | evalinf_postincr: forall e m a t id ty,
-      evalinf_expr e m LV a t ->
-      evalinf_expr e m RV (Epostincr id a ty) t
-  | evalinf_comma_left: forall e m a1 t1 a2 ty,
-      evalinf_expr e m RV a1 t1 ->
-      evalinf_expr e m RV (Ecomma a1 a2 ty) t1
-  | evalinf_comma_right: forall e m a1 t1 m1 a1' v1 a2 t2 ty,
-      eval_expr e m RV a1 t1 m1 a1' -> eval_simple_rvalue ge e m1 a1' v1 ->
-      ty = typeof a2 ->
-      evalinf_expr e m1 RV a2 t2 ->
-      evalinf_expr e m RV (Ecomma a1 a2 ty) (t1 *** t2)
-  | evalinf_call_left: forall e m a1 t1 a2 ty,
-      evalinf_expr e m RV a1 t1 ->
-      evalinf_expr e m RV (Ecall a1 a2 ty) t1
-  | evalinf_call_right: forall e m a1 t1 m1 a1' a2 t2 ty,
-      eval_expr e m RV a1 t1 m1 a1' ->
-      evalinf_exprlist e m1 a2 t2 ->
-      evalinf_expr e m RV (Ecall a1 a2 ty) (t1 *** t2)
-  | evalinf_call: forall e m rf rargs ty t1 m1 rf' t2 m2 rargs' vf vargs
-                      targs tres cconv fd t3,
-      eval_expr e m RV rf t1 m1 rf' -> eval_exprlist e m1 rargs t2 m2 rargs' ->
-      eval_simple_rvalue ge e m2 rf' vf ->
-      eval_simple_list ge e m2 rargs' targs vargs ->
-      classify_fun (typeof rf) = fun_case_f targs tres cconv ->
-      Genv.find_funct ge vf = Some fd ->
-      type_of_fundef fd = Tfunction targs tres cconv ->
-      evalinf_funcall m2 fd vargs t3 ->
-      evalinf_expr e m RV (Ecall rf rargs ty) (t1***t2***t3)
-
-with evalinf_exprlist: env -> mem -> exprlist -> traceinf -> Prop :=
-  | evalinf_cons_left: forall e m a1 al t1,
-      evalinf_expr e m RV a1 t1 ->
-      evalinf_exprlist e m (Econs a1 al) t1
-  | evalinf_cons_right: forall e m a1 al t1 m1 a1' t2,
-      eval_expr e m RV a1 t1 m1 a1' -> evalinf_exprlist e m1 al t2 ->
-      evalinf_exprlist e m (Econs a1 al) (t1***t2)
-
-(** [execinf_stmt ge e m1 s t] describes the diverging execution of
-  the statement [s].  *)
-
-with execinf_stmt: env -> mem -> statement -> traceinf -> Prop :=
-  | execinf_Sdo:     forall e m a t,
-      evalinf_expr e m RV a t ->
-      execinf_stmt e m (Sdo a) t
-  | execinf_Sseq_1:   forall e m s1 s2 t1,
-      execinf_stmt e m s1 t1 ->
-      execinf_stmt e m (Ssequence s1 s2) t1
-  | execinf_Sseq_2:   forall e m s1 s2 t1 m1 t2,
-      exec_stmt e m s1 t1 m1 Out_normal ->
-      execinf_stmt e m1 s2 t2 ->
-      execinf_stmt e m (Ssequence s1 s2) (t1***t2)
-  | execinf_Sifthenelse_test: forall e m a s1 s2 t1,
-      evalinf_expr e m RV a t1 ->
-      execinf_stmt e m (Sifthenelse a s1 s2) t1
-  | execinf_Sifthenelse: forall e m a s1 s2 t1 m1 v1 t2 b,
-      eval_expression e m a t1 m1 v1 ->
-      bool_val v1 (typeof a) m1 = Some b ->
-      execinf_stmt e m1 (if b then s1 else s2) t2 ->
-      execinf_stmt e m (Sifthenelse a s1 s2) (t1***t2)
-  | execinf_Sreturn_some: forall e m a t,
-      evalinf_expr e m RV a t ->
-      execinf_stmt e m (Sreturn (Some a)) t
-  | execinf_Swhile_test: forall e m a s t1,
-      evalinf_expr e m RV a t1 ->
-      execinf_stmt e m (Swhile a s) t1
-  | execinf_Swhile_body: forall e m a s t1 m1 v t2,
-      eval_expression e m a t1 m1 v ->
-      bool_val v (typeof a) m1 = Some true ->
-      execinf_stmt e m1 s t2 ->
-      execinf_stmt e m (Swhile a s) (t1***t2)
-  | execinf_Swhile_loop: forall e m a s t1 m1 v t2 m2 out1 t3,
-      eval_expression e m a t1 m1 v ->
-      bool_val v (typeof a) m1 = Some true ->
-      exec_stmt e m1 s t2 m2 out1 ->
-      out_normal_or_continue out1 ->
-      execinf_stmt e m2 (Swhile a s) t3 ->
-      execinf_stmt e m (Swhile a s) (t1***t2***t3)
-  | execinf_Sdowhile_body: forall e m s a t1,
-      execinf_stmt e m s t1 ->
-      execinf_stmt e m (Sdowhile a s) t1
-  | execinf_Sdowhile_test: forall e m s a t1 m1 out1 t2,
-      exec_stmt e m s t1 m1 out1 ->
-      out_normal_or_continue out1 ->
-      evalinf_expr e m1 RV a t2 ->
-      execinf_stmt e m (Sdowhile a s) (t1***t2)
-  | execinf_Sdowhile_loop: forall e m s a t1 m1 out1 t2 m2 v t3,
-      exec_stmt e m s t1 m1 out1 ->
-      out_normal_or_continue out1 ->
-      eval_expression e m1 a t2 m2 v ->
-      bool_val v (typeof a) m2 = Some true ->
-      execinf_stmt e m2 (Sdowhile a s) t3 ->
-      execinf_stmt e m (Sdowhile a s) (t1***t2***t3)
-  | execinf_Sfor_start_1: forall e m s a1 a2 a3 t1,
-      execinf_stmt e m a1 t1 ->
-      execinf_stmt e m (Sfor a1 a2 a3 s) t1
-  | execinf_Sfor_start_2: forall e m s a1 a2 a3 m1 t1 t2,
-      exec_stmt e m a1 t1 m1 Out_normal -> a1 <> Sskip ->
-      execinf_stmt e m1 (Sfor Sskip a2 a3 s) t2 ->
-      execinf_stmt e m (Sfor a1 a2 a3 s) (t1***t2)
-  | execinf_Sfor_test: forall e m s a2 a3 t,
-      evalinf_expr e m RV a2 t ->
-      execinf_stmt e m (Sfor Sskip a2 a3 s) t
-  | execinf_Sfor_body: forall e m s a2 a3 t1 m1 v t2,
-      eval_expression e m a2 t1 m1 v ->
-      bool_val v (typeof a2) m1 = Some true ->
-      execinf_stmt e m1 s t2 ->
-      execinf_stmt e m (Sfor Sskip a2 a3 s) (t1***t2)
-  | execinf_Sfor_next: forall e m s a2 a3 t1 m1 v t2 m2 out1 t3,
-      eval_expression e m a2 t1 m1 v ->
-      bool_val v (typeof a2) m1 = Some true ->
-      exec_stmt e m1 s t2 m2 out1 ->
-      out_normal_or_continue out1 ->
-      execinf_stmt e m2 a3 t3 ->
-      execinf_stmt e m (Sfor Sskip a2 a3 s) (t1***t2***t3)
-  | execinf_Sfor_loop: forall e m s a2 a3 t1 m1 v t2 m2 out1 t3 m3 t4,
-      eval_expression e m a2 t1 m1 v ->
-      bool_val v (typeof a2) m1 = Some true ->
-      exec_stmt e m1 s t2 m2 out1 ->
-      out_normal_or_continue out1 ->
-      exec_stmt e m2 a3 t3 m3 Out_normal ->
-      execinf_stmt e m3 (Sfor Sskip a2 a3 s) t4 ->
-      execinf_stmt e m (Sfor Sskip a2 a3 s) (t1***t2***t3***t4)
-  | execinf_Sswitch_expr:   forall e m a sl t1,
-      evalinf_expr e m RV a t1 ->
-      execinf_stmt e m (Sswitch a sl) t1
-  | execinf_Sswitch_body:   forall e m a sl t1 m1 v n t2,
-      eval_expression e m a t1 m1 v ->
-      sem_switch_arg v (typeof a) = Some n ->
-      execinf_stmt e m1 (seq_of_labeled_statement (select_switch n sl)) t2 ->
-      execinf_stmt e m (Sswitch a sl) (t1***t2)
-
-(** [evalinf_funcall m1 fd args t m2 res] describes a diverging
-  invocation of function [fd] with arguments [args].  *)
-
-with evalinf_funcall: mem -> fundef -> list val -> traceinf -> Prop :=
-  | evalinf_funcall_internal: forall m f vargs t e m1 m2,
-      list_norepet (var_names f.(fn_params) ++ var_names f.(fn_vars)) ->
-      alloc_variables ge empty_env m (f.(fn_params) ++ f.(fn_vars)) e m1 ->
-      bind_parameters ge e m1 f.(fn_params) vargs m2 ->
-      execinf_stmt e m2 f.(fn_body) t ->
-      evalinf_funcall m (Internal f) vargs t.
-
-(** ** Implication from big-step semantics to transition semantics *)
-
-Inductive outcome_state_match
-       (e: env) (m: mem) (f: function) (k: cont): outcome -> state -> Prop :=
-  | osm_normal:
-      outcome_state_match e m f k Out_normal (State f Sskip k e m)
-  | osm_break:
-      outcome_state_match e m f k Out_break (State f Sbreak k e m)
-  | osm_continue:
-      outcome_state_match e m f k Out_continue (State f Scontinue k e m)
-  | osm_return_none: forall k',
-      call_cont k' = call_cont k ->
-      outcome_state_match e m f k
-        (Out_return None) (State f (Sreturn None) k' e m)
-  | osm_return_some: forall v ty k',
-      call_cont k' = call_cont k ->
-      outcome_state_match e m f k
-        (Out_return (Some (v, ty))) (ExprState f (Eval v ty) (Kreturn k') e m).
-
-Lemma is_call_cont_call_cont:
-  forall k, is_call_cont k -> call_cont k = k.
-Proof.
-  destruct k; simpl; intros; contradiction || auto.
-Qed.
-
-Lemma leftcontext_compose:
-  forall k2 k3 C2, leftcontext k2 k3 C2 ->
-  forall k1 C1, leftcontext k1 k2 C1 ->
-  leftcontext k1 k3 (fun x => C2(C1 x))
-with leftcontextlist_compose:
-  forall k2 C2, leftcontextlist k2 C2 ->
-  forall k1 C1, leftcontext k1 k2 C1 ->
-  leftcontextlist k1 (fun x => C2(C1 x)).
-Proof.
-  induction 1; intros; try (constructor; eauto).
-  replace (fun x => C1 x) with C1. auto. apply extensionality; auto.
-  induction 1; intros; constructor; eauto.
-Qed.
-
-Lemma exprlist_app_leftcontext:
-  forall rl1 rl2,
-  simplelist rl1 = true -> leftcontextlist RV (fun x => exprlist_app rl1 (Econs x rl2)).
-Proof.
-  induction rl1; simpl; intros.
-  apply lctx_list_head. constructor.
-  destruct (andb_prop _ _ H). apply lctx_list_tail. auto. auto.
-Qed.
-
-Lemma exprlist_app_simple:
-  forall rl1 rl2,
-  simplelist (exprlist_app rl1 rl2) = simplelist rl1 && simplelist rl2.
-Proof.
-  induction rl1; intros; simpl. auto. rewrite IHrl1. apply andb_assoc.
-Qed.
-
-Lemma bigstep_to_steps:
-  (forall e m a t m' v,
-   eval_expression e m a t m' v ->
-   forall f k,
-   star step ge (ExprState f a k e m) t (ExprState f (Eval v (typeof a)) k e m'))
-/\(forall e m K a t m' a',
-   eval_expr e m K a t m' a' ->
-   forall C f k, leftcontext K RV C ->
-   simple a' = true /\ typeof a' = typeof a /\
-   star step ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m'))
-/\(forall e m al t m' al',
-   eval_exprlist e m al t m' al' ->
-   forall a1 al2 ty C f k, leftcontext RV RV C -> simple a1 = true -> simplelist al2 = true ->
-   simplelist al' = true /\
-   star step ge (ExprState f (C (Ecall a1 (exprlist_app al2 al) ty)) k e m)
-              t (ExprState f (C (Ecall a1 (exprlist_app al2 al') ty)) k e m'))
-/\(forall e m s t m' out,
-   exec_stmt e m s t m' out ->
-   forall f k,
-   exists S,
-   star step ge (State f s k e m) t S /\ outcome_state_match e m' f k out S)
-/\(forall m fd args t m' res,
-   eval_funcall m fd args t m' res ->
-   forall k,
-   is_call_cont k ->
-   star step ge (Callstate fd args k m) t (Returnstate res k m')).
-Proof.
-  apply bigstep_induction; intros.
-(* expression, general *)
-  exploit (H0 (fun x => x) f k). constructor. intros [A [B C]].
-  assert (match a' with Eval _ _ => False | _ => True end ->
-          star step ge (ExprState f a k e m) t (ExprState f (Eval v (typeof a)) k e m')).
-   intro. eapply star_right. eauto. left. eapply step_expr; eauto. traceEq.
-  destruct a'; auto.
-  simpl in B. rewrite B in C. inv H1. auto.
-
-(* val *)
-  simpl; intuition. apply star_refl.
-(* var *)
-  simpl; intuition. apply star_refl.
-(* field *)
-  exploit (H0 (fun x => C(Efield x f ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]].
-  simpl; intuition; eauto.
-(* valof *)
-  exploit (H1 (fun x => C(Evalof x ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]].
-  simpl; intuition; eauto. rewrite A; rewrite B; rewrite H; auto.
-(* valof volatile *)
-  exploit (H1 (fun x => C(Evalof x ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]].
-  simpl; intuition.
-  eapply star_right. eexact D.
-  left. eapply step_rvalof_volatile; eauto. rewrite H4; eauto. congruence. congruence.
-  traceEq.
-(* deref *)
-  exploit (H0 (fun x => C(Ederef x ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]].
-  simpl; intuition; eauto.
-(* addrof *)
-  exploit (H0 (fun x => C(Eaddrof x ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]].
-  simpl; intuition; eauto.
-(* unop *)
-  exploit (H0 (fun x => C(Eunop op x ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]].
-  simpl; intuition; eauto.
-(* binop *)
-  exploit (H0 (fun x => C(Ebinop op x a2 ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]].
-  exploit (H2 (fun x => C(Ebinop op a1' x ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. auto. intros [E [F G]].
-  simpl; intuition. eapply star_trans; eauto.
-(* cast *)
-  exploit (H0 (fun x => C(Ecast x ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]].
-  simpl; intuition; eauto.
-(* seqand true *)
-  exploit (H0 (fun x => C(Eseqand x a2 ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]].
-  exploit (H4 (fun x => C(Eparen x type_bool ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. intros [E [F G]].
-  simpl; intuition. eapply star_trans. eexact D.
-  eapply star_left. left; eapply step_seqand_true; eauto. rewrite B; auto.
-  eapply star_right. eexact G.
-  left; eapply step_paren; eauto. rewrite F; eauto.
-  eauto. eauto. traceEq.
-(* seqand false *)
-  exploit (H0 (fun x => C(Eseqand x a2 ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]].
-  simpl; intuition. eapply star_right. eexact D.
-  left; eapply step_seqand_false; eauto. rewrite B; auto.
-  traceEq.
-(* seqor false *)
-  exploit (H0 (fun x => C(Eseqor x a2 ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]].
-  exploit (H4 (fun x => C(Eparen x type_bool ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. intros [E [F G]].
-  simpl; intuition. eapply star_trans. eexact D.
-  eapply star_left. left; eapply step_seqor_false; eauto. rewrite B; auto.
-  eapply star_right. eexact G.
-  left; eapply step_paren; eauto. rewrite F; eauto.
-  eauto. eauto. traceEq.
-(* seqor true *)
-  exploit (H0 (fun x => C(Eseqor x a2 ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]].
-  simpl; intuition. eapply star_right. eexact D.
-  left; eapply step_seqor_true; eauto. rewrite B; auto.
-  traceEq.
-(* condition *)
-  exploit (H0 (fun x => C(Econdition x a2 a3 ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]].
-  exploit (H4 (fun x => C(Eparen x ty ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. intros [E [F G]].
-  simpl. split; auto. split; auto.
-  eapply star_trans. eexact D.
-  eapply star_left. left; eapply step_condition; eauto. rewrite B; eauto.
-  eapply star_right. eexact G. left; eapply step_paren; eauto. congruence.
-  reflexivity. reflexivity. traceEq.
-(* sizeof *)
-  simpl; intuition. apply star_refl.
-(* alignof *)
-  simpl; intuition. apply star_refl.
-(* assign *)
-  exploit (H0 (fun x => C(Eassign x r ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]].
-  exploit (H2 (fun x => C(Eassign l' x ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. auto. intros [E [F G]].
-  simpl; intuition.
-  eapply star_trans. eexact D.
-  eapply star_right. eexact G.
-  left. eapply step_assign; eauto. congruence. rewrite B; eauto. congruence.
-  reflexivity. traceEq.
-(* assignop *)
-  exploit (H0 (fun x => C(Eassignop op x r tyres ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]].
-  exploit (H2 (fun x => C(Eassignop op l' x tyres ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. auto. intros [E [F G]].
-  simpl; intuition.
-  eapply star_trans. eexact D.
-  eapply star_right. eexact G.
-  left. eapply step_assignop; eauto.
-  rewrite B; eauto. rewrite B; rewrite F; eauto. congruence. rewrite B; eauto. congruence.
-  reflexivity. traceEq.
-(* postincr *)
-  exploit (H0 (fun x => C(Epostincr id x ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]].
-  simpl; intuition.
-  eapply star_right. eexact D.
-  left. eapply step_postincr; eauto. congruence.
-  traceEq.
-(* comma *)
-  exploit (H0 (fun x => C(Ecomma x r2 ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]].
-  exploit (H3 C). auto. intros [E [F G]].
-  simpl; intuition. congruence.
-  eapply star_trans. eexact D.
-  eapply star_left. left; eapply step_comma; eauto.
-  eexact G.
-  reflexivity. traceEq.
-(* call *)
-  exploit (H0 (fun x => C(Ecall x rargs ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]].
-  exploit (H2 rf' Enil ty C); eauto. intros [E F].
-  simpl; intuition.
-  eapply star_trans. eexact D.
-  eapply star_trans. eexact F.
-  eapply star_left. left; eapply step_call; eauto. congruence.
-  eapply star_right. eapply H9. red; auto.
-  right; constructor.
-  reflexivity. reflexivity. reflexivity. traceEq.
-(* nil *)
-  simpl; intuition. apply star_refl.
-(* cons *)
-  exploit (H0 (fun x => C(Ecall a0 (exprlist_app al2 (Econs x al)) ty))).
-    eapply leftcontext_compose; eauto. repeat constructor. auto.
-    apply exprlist_app_leftcontext; auto. intros [A [B D]].
-  exploit (H2 a0 (exprlist_app al2 (Econs a1' Enil))); eauto.
-  rewrite exprlist_app_simple. simpl. rewrite H5; rewrite A; auto.
-  repeat rewrite exprlist_app_assoc. simpl.
-  intros [E F].
-  simpl; intuition.
-  eapply star_trans; eauto.
-
-(* skip *)
-  econstructor; split. apply star_refl. constructor.
-
-(* do *)
-  econstructor; split.
-  eapply star_left. right; constructor.
-  eapply star_right. apply H0. right; constructor.
-  reflexivity. traceEq.
-  constructor.
-
-(* sequence 2 *)
-  destruct (H0 f (Kseq s2 k)) as [S1 [A1 B1]]; auto. inv B1.
-  destruct (H2 f k) as [S2 [A2 B2]]; auto.
-  econstructor; split.
-  eapply star_left. right; econstructor.
-  eapply star_trans. eexact A1.
-  eapply star_left. right; constructor. eexact A2.
-  reflexivity. reflexivity. traceEq.
-  auto.
-
-(* sequence 1 *)
-  destruct (H0 f (Kseq s2 k)) as [S1 [A1 B1]]; auto.
-  set (S2 :=
-    match out with
-    | Out_break => State f Sbreak k e m1
-    | Out_continue => State f Scontinue k e m1
-    | _ => S1
-    end).
-  exists S2; split.
-  eapply star_left. right; econstructor.
-  eapply star_trans. eexact A1.
-  unfold S2; inv B1.
-    congruence.
-    apply star_one. right; apply step_break_seq.
-    apply star_one. right; apply step_continue_seq.
-    apply star_refl.
-    apply star_refl.
-  reflexivity. traceEq.
-  unfold S2; inv B1; congruence || econstructor; eauto.
-
-(* ifthenelse *)
-  destruct (H3 f k) as [S1 [A1 B1]]; auto.
-  exists S1; split.
-  eapply star_left. right; apply step_ifthenelse_1.
-  eapply star_trans. eapply H0.
-  eapply star_left. 2: eexact A1. right; eapply step_ifthenelse_2; eauto.
-  reflexivity. reflexivity. traceEq.
-  auto.
-
-(* return none *)
-  econstructor; split. apply star_refl. constructor. auto.
-
-(* return some *)
-  econstructor; split.
-  eapply star_left. right; apply step_return_1.
-  eapply H0. traceEq.
-  econstructor; eauto.
-
-(* break *)
-  econstructor; split. apply star_refl. constructor.
-
-(* continue *)
-  econstructor; split. apply star_refl. constructor.
-
-(* while false *)
-  econstructor; split.
-  eapply star_left. right; apply step_while.
-  eapply star_right. apply H0. right; eapply step_while_false; eauto.
-  reflexivity. traceEq.
-  constructor.
-
-(* while stop *)
-  destruct (H3 f (Kwhile2 a s k)) as [S1 [A1 B1]].
-  set (S2 :=
-    match out' with
-    | Out_break => State f Sskip k e m2
-    | _ => S1
-    end).
-  exists S2; split.
-  eapply star_left. right; apply step_while.
-  eapply star_trans. apply H0.
-  eapply star_left. right; eapply step_while_true; eauto.
-  eapply star_trans. eexact A1.
-  unfold S2. inversion H4; subst.
-  inv B1. apply star_one. right; constructor.
-  apply star_refl.
-  reflexivity. reflexivity. reflexivity. traceEq.
-  unfold S2. inversion H4; subst. constructor. inv B1; econstructor; eauto.
-
-(* while loop *)
-  destruct (H3 f (Kwhile2 a s k)) as [S1 [A1 B1]].
-  destruct (H6 f k) as [S2 [A2 B2]]; auto.
-  exists S2; split.
-  eapply star_left. right; apply step_while.
-  eapply star_trans. apply H0.
-  eapply star_left. right; eapply step_while_true; eauto.
-  eapply star_trans. eexact A1.
-  eapply star_left.
-  inv H4; inv B1; right; apply step_skip_or_continue_while; auto.
-  eexact A2.
-  reflexivity. reflexivity. reflexivity. reflexivity. traceEq.
-  auto.
-
-(* dowhile false *)
-  destruct (H0 f (Kdowhile1 a s k)) as [S1 [A1 B1]].
-  exists (State f Sskip k e m2); split.
-  eapply star_left. right; constructor.
-  eapply star_trans. eexact A1.
-  eapply star_left.
-  inv H1; inv B1; right; eapply step_skip_or_continue_dowhile; eauto.
-  eapply star_right. apply H3.
-  right; eapply step_dowhile_false; eauto.
-  reflexivity. reflexivity. reflexivity. traceEq.
-  constructor.
-
-(* dowhile stop *)
-  destruct (H0 f (Kdowhile1 a s k)) as [S1 [A1 B1]].
-  set (S2 :=
-    match out1 with
-    | Out_break => State f Sskip k e m1
-    | _ => S1
-    end).
-  exists S2; split.
-  eapply star_left. right; apply step_dowhile.
-  eapply star_trans. eexact A1.
-  unfold S2. inversion H1; subst.
-  inv B1. apply star_one. right; constructor.
-  apply star_refl.
-  reflexivity. traceEq.
-  unfold S2. inversion H1; subst. constructor. inv B1; econstructor; eauto.
-
-(* dowhile loop *)
-  destruct (H0 f (Kdowhile1 a s k)) as [S1 [A1 B1]].
-  destruct (H6 f k) as [S2 [A2 B2]]; auto.
-  exists S2; split.
-  eapply star_left. right; constructor.
-  eapply star_trans. eexact A1.
-  eapply star_left.
-  inv H1; inv B1; right; eapply step_skip_or_continue_dowhile; eauto.
-  eapply star_trans. apply H3.
-  eapply star_left. right; eapply step_dowhile_true; eauto.
-  eexact A2.
-  reflexivity. reflexivity. reflexivity. reflexivity. traceEq.
-  auto.
-
-(* for start *)
-  assert (a1 = Sskip \/ a1 <> Sskip). destruct a1; auto; right; congruence.
-  destruct H3.
-  subst a1. inv H. apply H2; auto.
-  destruct (H0 f (Kseq (Sfor Sskip a2 a3 s) k)) as [S1 [A1 B1]]; auto. inv B1.
-  destruct (H2 f k) as [S2 [A2 B2]]; auto.
-  exists S2; split.
-  eapply star_left. right; apply step_for_start; auto.
-  eapply star_trans. eexact A1.
-  eapply star_left. right; constructor. eexact A2.
-  reflexivity. reflexivity. traceEq.
-  auto.
-
-(* for false *)
-  econstructor; split.
-  eapply star_left. right; apply step_for.
-  eapply star_right. apply H0. right; eapply step_for_false; eauto.
-  reflexivity. traceEq.
-  constructor.
-
-(* for stop *)
-  destruct (H3 f (Kfor3 a2 a3 s k)) as [S1 [A1 B1]].
-  set (S2 :=
-    match out1 with
-    | Out_break => State f Sskip k e m2
-    | _ => S1
-    end).
-  exists S2; split.
-  eapply star_left. right; apply step_for.
-  eapply star_trans. apply H0.
-  eapply star_left. right; eapply step_for_true; eauto.
-  eapply star_trans. eexact A1.
-  unfold S2. inversion H4; subst.
-  inv B1. apply star_one. right; constructor.
-  apply star_refl.
-  reflexivity. reflexivity. reflexivity. traceEq.
-  unfold S2. inversion H4; subst. constructor. inv B1; econstructor; eauto.
-
-(* for loop *)
-  destruct (H3 f (Kfor3 a2 a3 s k)) as [S1 [A1 B1]].
-  destruct (H6 f (Kfor4 a2 a3 s k)) as [S2 [A2 B2]]; auto. inv B2.
-  destruct (H8 f k) as [S3 [A3 B3]]; auto.
-  exists S3; split.
-  eapply star_left. right; apply step_for.
-  eapply star_trans. apply H0.
-  eapply star_left. right; eapply step_for_true; eauto.
-  eapply star_trans. eexact A1.
-  eapply star_trans with (s2 := State f a3 (Kfor4 a2 a3 s k) e m2).
-  inv H4; inv B1.
-  apply star_one. right; constructor; auto.
-  apply star_one. right; constructor; auto.
-  eapply star_trans. eexact A2.
-  eapply star_left. right; constructor.
-  eexact A3.
-  reflexivity. reflexivity. reflexivity. reflexivity.
-  reflexivity. reflexivity. traceEq.
-  auto.
-
-(* switch *)
-  destruct (H3 f (Kswitch2 k)) as [S1 [A1 B1]].
-  set (S2 :=
-    match out with
-    | Out_normal => State f Sskip k e m2
-    | Out_break => State f Sskip k e m2
-    | Out_continue => State f Scontinue k e m2
-    | _ => S1
-    end).
-  exists S2; split.
-  eapply star_left. right; eapply step_switch.
-  eapply star_trans. apply H0.
-  eapply star_left. right; eapply step_expr_switch. eauto.
-  eapply star_trans. eexact A1.
-  unfold S2; inv B1.
-    apply star_one. right; constructor. auto.
-    apply star_one. right; constructor. auto.
-    apply star_one. right; constructor.
-    apply star_refl.
-    apply star_refl.
-  reflexivity. reflexivity. reflexivity. traceEq.
-  unfold S2. inv B1; simpl; econstructor; eauto.
-
-(* call internal *)
-  destruct (H3 f k) as [S1 [A1 B1]].
-  eapply star_left. right; eapply step_internal_function; eauto.
-  eapply star_right. eexact A1.
-  inv B1; simpl in H4; try contradiction.
-  (* Out_normal *)
-  assert (fn_return f = Tvoid /\ vres = Vundef).
-    destruct (fn_return f); auto || contradiction.
-  destruct H7 as [P Q]. subst vres. right; eapply step_skip_call; eauto.
-  (* Out_return None *)
-  assert (fn_return f = Tvoid /\ vres = Vundef).
-    destruct (fn_return f); auto || contradiction.
-  destruct H8 as [P Q]. subst vres.
-  rewrite <- (is_call_cont_call_cont k H6). rewrite <- H7.
-  right; apply step_return_0; auto.
-  (* Out_return Some *)
-  destruct H4. rewrite <- (is_call_cont_call_cont k H6). rewrite <- H7.
-  right; eapply step_return_2; eauto.
-  reflexivity. traceEq.
-
-(* call external *)
-  apply star_one. right; apply step_external_function; auto.
-Qed.
-
-Lemma eval_expression_to_steps:
-   forall e m a t m' v,
-   eval_expression e m a t m' v ->
-   forall f k,
-   star step ge (ExprState f a k e m) t (ExprState f (Eval v (typeof a)) k e m').
-Proof (proj1 bigstep_to_steps).
-
-Lemma eval_expr_to_steps:
-   forall e m K a t m' a',
-   eval_expr e m K a t m' a' ->
-   forall C f k, leftcontext K RV C ->
-   simple a' = true /\ typeof a' = typeof a /\
-   star step ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m').
-Proof (proj1 (proj2 bigstep_to_steps)).
-
-Lemma eval_exprlist_to_steps:
-   forall e m al t m' al',
-   eval_exprlist e m al t m' al' ->
-   forall a1 al2 ty C f k, leftcontext RV RV C -> simple a1 = true -> simplelist al2 = true ->
-   simplelist al' = true /\
-   star step ge (ExprState f (C (Ecall a1 (exprlist_app al2 al) ty)) k e m)
-              t (ExprState f (C (Ecall a1 (exprlist_app al2 al') ty)) k e m').
-Proof (proj1 (proj2 (proj2 bigstep_to_steps))).
-
-Lemma exec_stmt_to_steps:
-   forall e m s t m' out,
-   exec_stmt e m s t m' out ->
-   forall f k,
-   exists S,
-   star step ge (State f s k e m) t S /\ outcome_state_match e m' f k out S.
-Proof (proj1 (proj2 (proj2 (proj2 bigstep_to_steps)))).
-
-Lemma eval_funcall_to_steps:
-  forall m fd args t m' res,
-  eval_funcall m fd args t m' res ->
-  forall k,
-  is_call_cont k ->
-  star step ge (Callstate fd args k m) t (Returnstate res k m').
-Proof (proj2 (proj2 (proj2 (proj2 bigstep_to_steps)))).
-
-Fixpoint esize (a: expr) : nat :=
-  match a with
-  | Eloc _ _ _ => 1%nat
-  | Evar _ _ => 1%nat
-  | Ederef r1 _ => S(esize r1)
-  | Efield l1 _ _ => S(esize l1)
-  | Eval _ _ => O
-  | Evalof l1 _ => S(esize l1)
-  | Eaddrof l1 _ => S(esize l1)
-  | Eunop _ r1 _ => S(esize r1)
-  | Ebinop _ r1 r2 _ => S(esize r1 + esize r2)%nat
-  | Ecast r1 _ => S(esize r1)
-  | Eseqand r1 r2 _ => S(esize r1)
-  | Eseqor r1 r2 _ => S(esize r1)
-  | Econdition r1 _ _ _ => S(esize r1)
-  | Esizeof _ _ => 1%nat
-  | Ealignof _ _ => 1%nat
-  | Eassign l1 r2 _ => S(esize l1 + esize r2)%nat
-  | Eassignop _ l1 r2 _ _ => S(esize l1 + esize r2)%nat
-  | Epostincr _ l1 _ => S(esize l1)
-  | Ecomma r1 r2 _ => S(esize r1 + esize r2)%nat
-  | Ecall r1 rl2 _ => S(esize r1 + esizelist rl2)%nat
-  | Ebuiltin ef tyargs rl _ => S(esizelist rl)
-  | Eparen r1 _ _ => S(esize r1)
-  end
-
-with esizelist (el: exprlist) : nat :=
-  match el with
-  | Enil => O
-  | Econs r1 rl2 => S(esize r1 + esizelist rl2)%nat
-  end.
-
-Lemma leftcontext_size:
-  forall from to C,
-  leftcontext from to C ->
-  forall e1 e2,
-  (esize e1 < esize e2)%nat ->
-  (esize (C e1) < esize (C e2))%nat
-with leftcontextlist_size:
-  forall from C,
-  leftcontextlist from C ->
-  forall e1 e2,
-  (esize e1 < esize e2)%nat ->
-  (esizelist (C e1) < esizelist (C e2))%nat.
-Proof.
-  induction 1; intros; simpl; auto with arith.
-  exploit leftcontextlist_size; eauto. auto with arith.
-  exploit leftcontextlist_size; eauto. auto with arith.
-  induction 1; intros; simpl; auto with arith.
-  exploit leftcontext_size; eauto. auto with arith.
-Qed.
-
-Lemma evalinf_funcall_steps:
-  forall m fd args t k,
-  evalinf_funcall m fd args t ->
-  forever_N step lt ge O (Callstate fd args k m) t.
-Proof.
-  cofix COF.
-
-  assert (COS:
-    forall e m s t f k,
-    execinf_stmt e m s t ->
-    forever_N step lt ge O (State f s k e m) t).
-  cofix COS.
-
-  assert (COE:
-    forall e m K a t C f k,
-    evalinf_expr e m K a t ->
-    leftcontext K RV C ->
-    forever_N step lt ge (esize a) (ExprState f (C a) k e m) t).
-  cofix COE.
-
-  assert (COEL:
-    forall e m a t C f k a1 al ty,
-    evalinf_exprlist e m a t ->
-    leftcontext RV RV C -> simple a1 = true -> simplelist al = true ->
-    forever_N step lt ge (esizelist a)
-                   (ExprState f (C (Ecall a1 (exprlist_app al a) ty)) k e m) t).
-  cofix COEL.
-  intros. inv H.
-(* cons left *)
-  eapply forever_N_star with (a2 := (esize a0)). apply star_refl. simpl; lia.
-  eapply COE with (C := fun x => C(Ecall a1 (exprlist_app al (Econs x al0)) ty)).
-  eauto. eapply leftcontext_compose; eauto. constructor. auto.
-  apply exprlist_app_leftcontext; auto. traceEq.
-(* cons right *)
-  destruct (eval_expr_to_steps _ _ _ _ _ _ _ H3
-             (fun x => C(Ecall a1 (exprlist_app al (Econs x al0)) ty)) f k)
-  as [P [Q R]].
-  eapply leftcontext_compose; eauto. repeat constructor. auto.
-  apply exprlist_app_leftcontext; auto.
-  eapply forever_N_star with (a2 := (esizelist al0)).
-  eexact R. simpl; lia.
-  change (Econs a1' al0) with (exprlist_app (Econs a1' Enil) al0).
-  rewrite <- exprlist_app_assoc.
-  eapply COEL. eauto. auto. auto.
-  rewrite exprlist_app_simple. simpl. rewrite H2; rewrite P; auto.
-  auto.
-
-  intros. inv H.
-(* field *)
-  eapply forever_N_star with (a2 := (esize a0)). apply star_refl. simpl; lia.
-  eapply COE with (C := fun x => C(Efield x f0 ty)). eauto.
-  eapply leftcontext_compose; eauto. repeat constructor. traceEq.
-(* valof *)
-  eapply forever_N_star with (a2 := (esize a0)). apply star_refl. simpl; lia.
-  eapply COE with (C := fun x => C(Evalof x ty)). eauto.
-  eapply leftcontext_compose; eauto. repeat constructor. traceEq.
-(* deref *)
-  eapply forever_N_star with (a2 := (esize a0)). apply star_refl. simpl; lia.
-  eapply COE with (C := fun x => C(Ederef x ty)). eauto.
-  eapply leftcontext_compose; eauto. repeat constructor. traceEq.
-(* addrof *)
-  eapply forever_N_star with (a2 := (esize a0)). apply star_refl. simpl; lia.
-  eapply COE with (C := fun x => C(Eaddrof x ty)). eauto.
-  eapply leftcontext_compose; eauto. repeat constructor. traceEq.
-(* unop *)
-  eapply forever_N_star with (a2 := (esize a0)). apply star_refl. simpl; lia.
-  eapply COE with (C := fun x => C(Eunop op x ty)). eauto.
-  eapply leftcontext_compose; eauto. repeat constructor. traceEq.
-(* binop left *)
-  eapply forever_N_star with (a2 := (esize a1)). apply star_refl. simpl; lia.
-  eapply COE with (C := fun x => C(Ebinop op x a2 ty)). eauto.
-  eapply leftcontext_compose; eauto. repeat constructor. traceEq.
-(* binop right *)
-  destruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ebinop op x a2 ty)) f k)
-  as [P [Q R]].
-  eapply leftcontext_compose; eauto. repeat constructor.
-  eapply forever_N_star with (a2 := (esize a2)). eexact R. simpl; lia.
-  eapply COE with (C := fun x => C(Ebinop op a1' x ty)). eauto.
-  eapply leftcontext_compose; eauto. repeat constructor. auto. traceEq.
-(* cast *)
-  eapply forever_N_star with (a2 := (esize a0)). apply star_refl. simpl; lia.
-  eapply COE with (C := fun x => C(Ecast x ty)). eauto.
-  eapply leftcontext_compose; eauto. repeat constructor. traceEq.
-(* seqand left *)
-  eapply forever_N_star with (a2 := (esize a1)). apply star_refl. simpl; lia.
-  eapply COE with (C := fun x => C(Eseqand x a2 ty)). eauto.
-  eapply leftcontext_compose; eauto. repeat constructor. traceEq.
-(* seqand 2 *)
-  destruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eseqand x a2 ty)) f k)
-  as [P [Q R]].
-  eapply leftcontext_compose; eauto. repeat constructor.
-  eapply forever_N_plus. eapply plus_right. eexact R.
-  left; eapply step_seqand_true; eauto. rewrite Q; eauto.
-  reflexivity.
-  eapply COE with (C := fun x => (C (Eparen x type_bool ty))). eauto.
-  eapply leftcontext_compose; eauto. repeat constructor. traceEq.
-(* seqor left *)
-  eapply forever_N_star with (a2 := (esize a1)). apply star_refl. simpl; lia.
-  eapply COE with (C := fun x => C(Eseqor x a2 ty)). eauto.
-  eapply leftcontext_compose; eauto. repeat constructor. traceEq.
-(* seqor 2 *)
-  destruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eseqor x a2 ty)) f k)
-  as [P [Q R]].
-  eapply leftcontext_compose; eauto. repeat constructor.
-  eapply forever_N_plus. eapply plus_right. eexact R.
-  left; eapply step_seqor_false; eauto. rewrite Q; eauto.
-  reflexivity.
-  eapply COE with (C := fun x => (C (Eparen x type_bool ty))). eauto.
-  eapply leftcontext_compose; eauto. repeat constructor. traceEq.
-(* condition top *)
-  eapply forever_N_star with (a2 := (esize a1)). apply star_refl. simpl; lia.
-  eapply COE with (C := fun x => C(Econdition x a2 a3 ty)). eauto.
-  eapply leftcontext_compose; eauto. repeat constructor. traceEq.
-(* condition *)
-  destruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Econdition x a2 a3 ty)) f k)
-  as [P [Q R]].
-  eapply leftcontext_compose; eauto. repeat constructor.
-  eapply forever_N_plus. eapply plus_right. eexact R.
-  left; eapply step_condition; eauto. rewrite Q; eauto.
-  reflexivity.
-  eapply COE with (C := fun x => (C (Eparen x ty ty))). eauto.
-  eapply leftcontext_compose; eauto. repeat constructor. traceEq.
-(* assign left *)
-  eapply forever_N_star with (a2 := (esize a1)). apply star_refl. simpl; lia.
-  eapply COE with (C := fun x => C(Eassign x a2 ty)). eauto.
-  eapply leftcontext_compose; eauto. repeat constructor. traceEq.
-(* assign right *)
-  destruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eassign x a2 ty)) f k)
-  as [P [Q R]].
-  eapply leftcontext_compose; eauto. repeat constructor.
-  eapply forever_N_star with (a2 := (esize a2)). eexact R. simpl; lia.
-  eapply COE with (C := fun x => C(Eassign a1' x ty)). eauto.
-  eapply leftcontext_compose; eauto. repeat constructor. auto. traceEq.
-(* assignop left *)
-  eapply forever_N_star with (a2 := (esize a1)). apply star_refl. simpl; lia.
-  eapply COE with (C := fun x => C(Eassignop op x a2 tyres ty)). eauto.
-  eapply leftcontext_compose; eauto. repeat constructor. traceEq.
-(* assignop right *)
-  destruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eassignop op x a2 tyres ty)) f k)
-  as [P [Q R]].
-  eapply leftcontext_compose; eauto. repeat constructor.
-  eapply forever_N_star with (a2 := (esize a2)). eexact R. simpl; lia.
-  eapply COE with (C := fun x => C(Eassignop op a1' x tyres ty)). eauto.
-  eapply leftcontext_compose; eauto. repeat constructor. auto. traceEq.
-(* postincr *)
-  eapply forever_N_star with (a2 := (esize a0)). apply star_refl. simpl; lia.
-  eapply COE with (C := fun x => C(Epostincr id x ty)). eauto.
-  eapply leftcontext_compose; eauto. repeat constructor. traceEq.
-(* comma left *)
-  eapply forever_N_star with (a2 := (esize a1)). apply star_refl. simpl; lia.
-  eapply COE with (C := fun x => C(Ecomma x a2 ty)). eauto.
-  eapply leftcontext_compose; eauto. repeat constructor. traceEq.
-(* comma right *)
-  destruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecomma x a2 (typeof a2))) f k)
-  as [P [Q R]].
-  eapply leftcontext_compose; eauto. repeat constructor.
-  eapply forever_N_plus. eapply plus_right. eexact R.
-  left; eapply step_comma; eauto. reflexivity.
-  eapply COE with (C := C); eauto. traceEq.
-(* call left *)
-  eapply forever_N_star with (a2 := (esize a1)). apply star_refl. simpl; lia.
-  eapply COE with (C := fun x => C(Ecall x a2 ty)). eauto.
-  eapply leftcontext_compose; eauto. repeat constructor. traceEq.
-(* call right *)
-  destruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecall x a2 ty)) f k)
-  as [P [Q R]].
-  eapply leftcontext_compose; eauto. repeat constructor.
-  eapply forever_N_star with (a2 := (esizelist a2)). eexact R. simpl; lia.
-  eapply COEL with (al := Enil). eauto. auto. auto. auto. traceEq.
-(* call *)
-  destruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecall x rargs ty)) f k)
-  as [P [Q R]].
-  eapply leftcontext_compose; eauto. repeat constructor.
-  destruct (eval_exprlist_to_steps _ _ _ _ _ _ H2 rf' Enil ty C f k)
-  as [S T]. auto. auto. simpl; auto.
-  eapply forever_N_plus. eapply plus_right.
-  eapply star_trans. eexact R. eexact T. reflexivity.
-  simpl. left; eapply step_call; eauto. congruence. reflexivity.
-  apply COF. eauto. traceEq.
-
-(* statements *)
-  intros. inv H.
-(* do *)
-  eapply forever_N_plus. apply plus_one; right; constructor.
-  eapply COE with (C := fun x => x); eauto. constructor. traceEq.
-(* seq 1 *)
-  eapply forever_N_plus. apply plus_one; right; constructor.
-  eapply COS; eauto. traceEq.
-(* seq 2 *)
-  destruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kseq s2 k)) as [S1 [A1 B1]]; auto. inv B1.
-  eapply forever_N_plus.
-  eapply plus_left. right; constructor.
-  eapply star_right. eauto. right; constructor.
-  reflexivity. reflexivity.
-  eapply COS; eauto. traceEq.
-(* if test *)
-  eapply forever_N_plus. apply plus_one; right; constructor.
-  eapply COE with (C := fun x => x); eauto. constructor. traceEq.
-(* if true/false *)
-  eapply forever_N_plus.
-  eapply plus_left. right; constructor.
-  eapply star_right. eapply eval_expression_to_steps; eauto.
-  right. eapply step_ifthenelse_2 with (b := b). auto.
-  reflexivity. reflexivity.
-  eapply COS; eauto. traceEq.
-(* return some *)
-  eapply forever_N_plus. apply plus_one; right; constructor.
-  eapply COE with (C := fun x => x); eauto. constructor. traceEq.
-(* while test *)
-  eapply forever_N_plus. apply plus_one; right; constructor.
-  eapply COE with (C := fun x => x); eauto. constructor. traceEq.
-(* while body *)
-  eapply forever_N_plus.
-  eapply plus_left. right; constructor.
-  eapply star_right. eapply eval_expression_to_steps; eauto.
-  right; apply step_while_true; auto.
-  reflexivity. reflexivity.
-  eapply COS; eauto. traceEq.
-(* while loop *)
-  destruct (exec_stmt_to_steps _ _ _ _ _ _ H2 f (Kwhile2 a s0 k)) as [S1 [A1 B1]]; auto.
-  eapply forever_N_plus.
-  eapply plus_left. right; constructor.
-  eapply star_trans. eapply eval_expression_to_steps; eauto.
-  eapply star_left. right; apply step_while_true; auto.
-  eapply star_trans. eexact A1.
-  inv H3; inv B1; apply star_one; right; apply step_skip_or_continue_while; auto.
-  reflexivity. reflexivity. reflexivity. reflexivity.
-  eapply COS; eauto. traceEq.
-(* dowhile body *)
-  eapply forever_N_plus. apply plus_one; right; constructor.
-  eapply COS; eauto. traceEq.
-(* dowhile test *)
-  destruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kdowhile1 a s0 k)) as [S1 [A1 B1]]; auto.
-  eapply forever_N_plus.
-  eapply plus_left. right; constructor.
-  eapply star_trans. eexact A1.
-  eapply star_one. right. inv H1; inv B1; apply step_skip_or_continue_dowhile; auto.
-  reflexivity. reflexivity.
-  eapply COE with (C := fun x => x); eauto. constructor. traceEq.
-(* dowhile loop *)
-  destruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kdowhile1 a s0 k)) as [S1 [A1 B1]]; auto.
-  eapply forever_N_plus.
-  eapply plus_left. right; constructor.
-  eapply star_trans. eexact A1.
-  eapply star_left. right. inv H1; inv B1; apply step_skip_or_continue_dowhile; auto.
-  eapply star_right. eapply eval_expression_to_steps; eauto.
-  right; apply step_dowhile_true; auto.
-  reflexivity. reflexivity. reflexivity. reflexivity.
-  eapply COS; eauto. traceEq.
-(* for start 1 *)
-  assert (a1 <> Sskip). red; intros; subst a1; inv H0.
-  eapply forever_N_plus. apply plus_one. right. constructor. auto.
-  eapply COS; eauto. traceEq.
-(* for start 2 *)
-  destruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kseq (Sfor Sskip a2 a3 s0) k)) as [S1 [A1 B1]]; auto. inv B1.
-  eapply forever_N_plus.
-  eapply plus_left. right; constructor. auto.
-  eapply star_trans. eexact A1.
-  apply star_one. right; constructor.
-  reflexivity. reflexivity.
-  eapply COS; eauto. traceEq.
-(* for test *)
-  eapply forever_N_plus. apply plus_one; right; apply step_for.
-  eapply COE with (C := fun x => x); eauto. constructor. traceEq.
-(* for body *)
-  eapply forever_N_plus.
-  eapply plus_left. right; apply step_for.
-  eapply star_right. eapply eval_expression_to_steps; eauto.
-  right; apply step_for_true; auto.
-  reflexivity. reflexivity.
-  eapply COS; eauto. traceEq.
-(* for next *)
-  destruct (exec_stmt_to_steps _ _ _ _ _ _ H2 f (Kfor3 a2 a3 s0 k)) as [S1 [A1 B1]]; auto.
-  eapply forever_N_plus.
-  eapply plus_left. right; apply step_for.
-  eapply star_trans. eapply eval_expression_to_steps; eauto.
-  eapply star_left. right; apply step_for_true; auto.
-  eapply star_trans. eexact A1.
-  inv H3; inv B1; apply star_one; right; apply step_skip_or_continue_for3; auto.
-  reflexivity. reflexivity. reflexivity. reflexivity.
-  eapply COS; eauto. traceEq.
-(* for loop *)
-  destruct (exec_stmt_to_steps _ _ _ _ _ _ H2 f (Kfor3 a2 a3 s0 k)) as [S1 [A1 B1]]; auto.
-  destruct (exec_stmt_to_steps _ _ _ _ _ _ H4 f (Kfor4 a2 a3 s0 k)) as [S2 [A2 B2]]; auto. inv B2.
-  eapply forever_N_plus.
-  eapply plus_left. right; apply step_for.
-  eapply star_trans. eapply eval_expression_to_steps; eauto.
-  eapply star_left. right; apply step_for_true; auto.
-  eapply star_trans. eexact A1.
-  eapply star_left.
-  inv H3; inv B1; right; apply step_skip_or_continue_for3; auto.
-  eapply star_right. eexact A2.
-  right; constructor.
-  reflexivity. reflexivity. reflexivity. reflexivity. reflexivity. reflexivity.
-  eapply COS; eauto. traceEq.
-(* switch expr *)
-  eapply forever_N_plus. apply plus_one; right; constructor.
-  eapply COE with (C := fun x => x); eauto. constructor. traceEq.
-(* switch body *)
-  eapply forever_N_plus.
-  eapply plus_left. right; constructor.
-  eapply star_right. eapply eval_expression_to_steps; eauto.
-  right; constructor. eauto.
-  reflexivity. reflexivity.
-  eapply COS; eauto. traceEq.
-
-(* funcalls *)
-  intros. inv H.
-  eapply forever_N_plus. apply plus_one. right; econstructor; eauto.
-  eapply COS; eauto. traceEq.
-Qed.
-
-End BIGSTEP.
-
-(** ** Whole-program behaviors, big-step style. *)
-
-Inductive bigstep_program_terminates (p: program): trace -> int -> Prop :=
-  | bigstep_program_terminates_intro: forall b f m0 m1 t r,
-      let ge := globalenv p in
-      Genv.init_mem p = Some m0 ->
-      Genv.find_symbol ge p.(prog_main) = Some b ->
-      Genv.find_funct_ptr ge b = Some f ->
-      type_of_fundef f = Tfunction Tnil type_int32s cc_default ->
-      eval_funcall ge m0 f nil t m1 (Vint r) ->
-      bigstep_program_terminates p t r.
-
-Inductive bigstep_program_diverges (p: program): traceinf -> Prop :=
-  | bigstep_program_diverges_intro: forall b f m0 t,
-      let ge := globalenv p in
-      Genv.init_mem p = Some m0 ->
-      Genv.find_symbol ge p.(prog_main) = Some b ->
-      Genv.find_funct_ptr ge b = Some f ->
-      type_of_fundef f = Tfunction Tnil type_int32s cc_default ->
-      evalinf_funcall ge m0 f nil t ->
-      bigstep_program_diverges p t.
-
-Definition bigstep_semantics (p: program) :=
-  Bigstep_semantics (bigstep_program_terminates p) (bigstep_program_diverges p).
-
-Theorem bigstep_semantics_sound:
-  forall p, bigstep_sound (bigstep_semantics p) (semantics p).
-Proof.
-  intros; constructor; intros.
-(* termination *)
-  inv H. econstructor; econstructor.
-  split. econstructor; eauto.
-  split. apply eval_funcall_to_steps. eauto. red; auto.
-  econstructor.
-(* divergence *)
-  inv H. econstructor.
-  split. econstructor; eauto.
-  eapply forever_N_forever with (order := lt).
-  apply lt_wf.
-  eapply evalinf_funcall_steps; eauto.
-Qed.
+(* Section BIGSTEP. *)
+
+(* Variable ge: genv. *)
+
+(* (** The execution of a statement produces an ``outcome'', indicating *)
+(*   how the execution terminated: either normally or prematurely *)
+(*   through the execution of a [break], [continue] or [return] statement. *) *)
+
+(* Inductive outcome: Type := *)
+(*    | Out_break: outcome                 (**r terminated by [break] *) *)
+(*    | Out_continue: outcome              (**r terminated by [continue] *) *)
+(*    | Out_normal: outcome                (**r terminated normally *) *)
+(*    | Out_return: option (val * type) -> outcome. (**r terminated by [return] *) *)
+
+(* Inductive out_normal_or_continue : outcome -> Prop := *)
+(*   | Out_normal_or_continue_N: out_normal_or_continue Out_normal *)
+(*   | Out_normal_or_continue_C: out_normal_or_continue Out_continue. *)
+
+(* Inductive out_break_or_return : outcome -> outcome -> Prop := *)
+(*   | Out_break_or_return_B: out_break_or_return Out_break Out_normal *)
+(*   | Out_break_or_return_R: forall ov, *)
+(*       out_break_or_return (Out_return ov) (Out_return ov). *)
+
+(* Definition outcome_switch (out: outcome) : outcome := *)
+(*   match out with *)
+(*   | Out_break => Out_normal *)
+(*   | o => o *)
+(*   end. *)
+
+(* Definition outcome_result_value (out: outcome) (t: type) (v: val) (m: mem) : Prop := *)
+(*   match out, t with *)
+(*   | Out_normal, Tvoid => v = Vundef *)
+(*   | Out_return None, Tvoid => v = Vundef *)
+(*   | Out_return (Some (v', ty')), ty => ty <> Tvoid /\ sem_cast v' ty' ty m = Some v *)
+(*   | _, _ => False *)
+(*   end. *)
+
+(* (** [eval_expression ge e m1 a t m2 a'] describes the evaluation of the *)
+(*   complex expression e.  [v] is the resulting value, [m2] the final *)
+(*   memory state, and [t] the trace of input/output events performed *)
+(*   during this evaluation.  *) *)
+
+(* Inductive eval_expression: env -> mem -> expr -> trace -> mem -> val -> Prop := *)
+(*   | eval_expression_intro: forall e m a t m' a' v, *)
+(*       eval_expr e m RV a t m' a' -> eval_simple_rvalue ge e m' a' v -> *)
+(*       eval_expression e m a t m' v *)
+
+(* with eval_expr: env -> mem -> kind -> expr -> trace -> mem -> expr -> Prop := *)
+(*   | eval_val: forall e m v ty, *)
+(*       eval_expr e m RV (Eval v ty) E0 m (Eval v ty) *)
+(*   | eval_var: forall e m x ty, *)
+(*       eval_expr e m LV (Evar x ty) E0 m (Evar x ty) *)
+(*   | eval_field: forall e m a t m' a' f ty, *)
+(*       eval_expr e m RV a t m' a' -> *)
+(*       eval_expr e m LV (Efield a f ty) t m' (Efield a' f ty) *)
+(*   | eval_valof: forall e m a t m' a' ty, *)
+(*       type_is_volatile (typeof a) = false -> *)
+(*       eval_expr e m LV a t m' a' -> *)
+(*       eval_expr e m RV (Evalof a ty) t m' (Evalof a' ty) *)
+(*   | eval_valof_volatile: forall e m a t1 m' a' ty b ofs t2 v, *)
+(*       type_is_volatile (typeof a) = true -> *)
+(*       eval_expr e m LV a t1 m' a' -> *)
+(*       eval_simple_lvalue ge e m' a' b ofs -> *)
+(*       deref_loc ge (typeof a) m' b ofs t2 v -> *)
+(*       ty = typeof a -> *)
+(*       eval_expr e m RV (Evalof a ty) (t1 ** t2) m' (Eval v ty) *)
+(*   | eval_deref: forall e m a t m' a' ty, *)
+(*       eval_expr e m RV a t m' a' -> *)
+(*       eval_expr e m LV (Ederef a ty) t m' (Ederef a' ty) *)
+(*   | eval_addrof: forall e m a t m' a' ty, *)
+(*       eval_expr e m LV a t m' a' -> *)
+(*       eval_expr e m RV (Eaddrof a ty) t m' (Eaddrof a' ty) *)
+(*   | eval_unop: forall e m a t m' a' op ty, *)
+(*       eval_expr e m RV a t m' a' -> *)
+(*       eval_expr e m RV (Eunop op a ty) t m' (Eunop op a' ty) *)
+(*   | eval_binop: forall e m a1 t1 m' a1' a2 t2 m'' a2' op ty, *)
+(*       eval_expr e m RV a1 t1 m' a1' -> eval_expr e m' RV a2 t2 m'' a2' -> *)
+(*       eval_expr e m RV (Ebinop op a1 a2 ty) (t1 ** t2) m'' (Ebinop op a1' a2' ty) *)
+(*   | eval_cast: forall e m a t m' a' ty, *)
+(*       eval_expr e m RV a t m' a' -> *)
+(*       eval_expr e m RV (Ecast a ty) t m' (Ecast a' ty) *)
+(*   | eval_seqand_true: forall e m a1 a2 ty t1 m' a1' v1 t2 m'' a2' v2 v, *)
+(*       eval_expr e m RV a1 t1 m' a1' -> eval_simple_rvalue ge e m' a1' v1 -> *)
+(*       bool_val v1 (typeof a1) m' = Some true -> *)
+(*       eval_expr e m' RV a2 t2 m'' a2' -> eval_simple_rvalue ge e m'' a2' v2 -> *)
+(*       sem_cast v2 (typeof a2) type_bool m'' = Some v -> *)
+(*       eval_expr e m RV (Eseqand a1 a2 ty) (t1**t2) m'' (Eval v ty) *)
+(*   | eval_seqand_false: forall e m a1 a2 ty t1 m' a1' v1, *)
+(*       eval_expr e m RV a1 t1 m' a1' -> eval_simple_rvalue ge e m' a1' v1 -> *)
+(*       bool_val v1 (typeof a1) m' = Some false -> *)
+(*       eval_expr e m RV (Eseqand a1 a2 ty) t1 m' (Eval (Vint Int.zero) ty) *)
+(*   | eval_seqor_false: forall e m a1 a2 ty t1 m' a1' v1 t2 m'' a2' v2 v, *)
+(*       eval_expr e m RV a1 t1 m' a1' -> eval_simple_rvalue ge e m' a1' v1 -> *)
+(*       bool_val v1 (typeof a1) m' = Some false -> *)
+(*       eval_expr e m' RV a2 t2 m'' a2' -> eval_simple_rvalue ge e m'' a2' v2 -> *)
+(*       sem_cast v2 (typeof a2) type_bool m'' = Some v -> *)
+(*       eval_expr e m RV (Eseqor a1 a2 ty) (t1**t2) m'' (Eval v ty) *)
+(*   | eval_seqor_true: forall e m a1 a2 ty t1 m' a1' v1, *)
+(*       eval_expr e m RV a1 t1 m' a1' -> eval_simple_rvalue ge e m' a1' v1 -> *)
+(*       bool_val v1 (typeof a1) m' = Some true -> *)
+(*       eval_expr e m RV (Eseqor a1 a2 ty) t1 m' (Eval (Vint Int.one) ty) *)
+(*   | eval_condition: forall e m a1 a2 a3 ty t1 m' a1' v1 t2 m'' a' v' b v, *)
+(*       eval_expr e m RV a1 t1 m' a1' -> eval_simple_rvalue ge e m' a1' v1 -> *)
+(*       bool_val v1 (typeof a1) m' = Some b -> *)
+(*       eval_expr e m' RV (if b then a2 else a3) t2 m'' a' -> eval_simple_rvalue ge e m'' a' v' -> *)
+(*       sem_cast v' (typeof (if b then a2 else a3)) ty m'' = Some v -> *)
+(*       eval_expr e m RV (Econdition a1 a2 a3 ty) (t1**t2) m'' (Eval v ty) *)
+(*   | eval_sizeof: forall e m ty' ty, *)
+(*       eval_expr e m RV (Esizeof ty' ty) E0 m (Esizeof ty' ty) *)
+(*   | eval_alignof: forall e m ty' ty, *)
+(*       eval_expr e m RV (Ealignof ty' ty) E0 m (Ealignof ty' ty) *)
+(*   | eval_assign: forall e m l r ty t1 m1 l' t2 m2 r' b ofs v v' t3 m3, *)
+(*       eval_expr e m LV l t1 m1 l' -> eval_expr e m1 RV r t2 m2 r' -> *)
+(*       eval_simple_lvalue ge e m2 l' b ofs -> *)
+(*       eval_simple_rvalue ge e m2 r' v -> *)
+(*       sem_cast v (typeof r) (typeof l) m2 = Some v' -> *)
+(*       assign_loc ge (typeof l) m2 b ofs v' t3 m3 -> *)
+(*       ty = typeof l -> *)
+(*       eval_expr e m RV (Eassign l r ty) (t1**t2**t3) m3 (Eval v' ty) *)
+(*   | eval_assignop: forall e m op l r tyres ty t1 m1 l' t2 m2 r' b ofs *)
+(*                           v1 v2 v3 v4 t3 t4 m3, *)
+(*       eval_expr e m LV l t1 m1 l' -> eval_expr e m1 RV r t2 m2 r' -> *)
+(*       eval_simple_lvalue ge e m2 l' b ofs -> *)
+(*       deref_loc ge (typeof l) m2 b ofs t3 v1 -> *)
+(*       eval_simple_rvalue ge e m2 r' v2 -> *)
+(*       sem_binary_operation ge op v1 (typeof l) v2 (typeof r) m2 = Some v3 -> *)
+(*       sem_cast v3 tyres (typeof l) m2 = Some v4 -> *)
+(*       assign_loc ge (typeof l) m2 b ofs v4 t4 m3 -> *)
+(*       ty = typeof l -> *)
+(*       eval_expr e m RV (Eassignop op l r tyres ty) (t1**t2**t3**t4) m3 (Eval v4 ty) *)
+(*   | eval_postincr: forall e m id l ty t1 m1 l' b ofs v1 v2 v3 m2 t2 t3, *)
+(*       eval_expr e m LV l t1 m1 l' -> *)
+(*       eval_simple_lvalue ge e m1 l' b ofs -> *)
+(*       deref_loc ge ty m1 b ofs t2 v1 -> *)
+(*       sem_incrdecr ge id v1 ty m1 = Some v2 -> *)
+(*       sem_cast v2 (incrdecr_type ty) ty m1 = Some v3 -> *)
+(*       assign_loc ge ty m1 b ofs v3 t3 m2 -> *)
+(*       ty = typeof l -> *)
+(*       eval_expr e m RV (Epostincr id l ty) (t1**t2**t3) m2 (Eval v1 ty) *)
+(*   | eval_comma: forall e m r1 r2 ty t1 m1 r1' v1 t2 m2 r2', *)
+(*       eval_expr e m RV r1 t1 m1 r1' -> *)
+(*       eval_simple_rvalue ge e m1 r1' v1 -> *)
+(*       eval_expr e m1 RV r2 t2 m2 r2' -> *)
+(*       ty = typeof r2 -> *)
+(*       eval_expr e m RV (Ecomma r1 r2 ty) (t1**t2) m2 r2' *)
+(*   | eval_call: forall e m rf rargs ty t1 m1 rf' t2 m2 rargs' vf vargs *)
+(*                       targs tres cconv fd t3 m3 vres, *)
+(*       eval_expr e m RV rf t1 m1 rf' -> eval_exprlist e m1 rargs t2 m2 rargs' -> *)
+(*       eval_simple_rvalue ge e m2 rf' vf -> *)
+(*       eval_simple_list ge e m2 rargs' targs vargs -> *)
+(*       classify_fun (typeof rf) = fun_case_f targs tres cconv -> *)
+(*       Genv.find_funct ge vf = Some fd -> *)
+(*       type_of_fundef fd = Tfunction targs tres cconv -> *)
+(*       eval_funcall m2 fd vargs t3 m3 vres -> *)
+(*       eval_expr e m RV (Ecall rf rargs ty) (t1**t2**t3) m3 (Eval vres ty) *)
+
+(* with eval_exprlist: env -> mem -> exprlist -> trace -> mem -> exprlist -> Prop := *)
+(*   | eval_nil: forall e m, *)
+(*       eval_exprlist e m Enil E0 m Enil *)
+(*   | eval_cons: forall e m a1 al t1 m1 a1' t2 m2 al', *)
+(*       eval_expr e m RV a1 t1 m1 a1' -> eval_exprlist e m1 al t2 m2 al' -> *)
+(*       eval_exprlist e m (Econs a1 al) (t1**t2) m2 (Econs a1' al') *)
+
+(* (** [exec_stmt ge e m1 s t m2 out] describes the execution of *)
+(*   the statement [s].  [out] is the outcome for this execution. *)
+(*   [m1] is the initial memory state, [m2] the final memory state. *)
+(*   [t] is the trace of input/output events performed during this *)
+(*   evaluation. *) *)
+
+(* with exec_stmt: env -> mem -> statement -> trace -> mem -> outcome -> Prop := *)
+(*   | exec_Sskip:   forall e m, *)
+(*       exec_stmt e m Sskip *)
+(*                E0 m Out_normal *)
+(*   | exec_Sdo:     forall e m a t m' v, *)
+(*       eval_expression e m a t m' v -> *)
+(*       exec_stmt e m (Sdo a) *)
+(*                 t m' Out_normal *)
+(*   | exec_Sseq_1:   forall e m s1 s2 t1 m1 t2 m2 out, *)
+(*       exec_stmt e m s1 t1 m1 Out_normal -> *)
+(*       exec_stmt e m1 s2 t2 m2 out -> *)
+(*       exec_stmt e m (Ssequence s1 s2) *)
+(*                 (t1 ** t2) m2 out *)
+(*   | exec_Sseq_2:   forall e m s1 s2 t1 m1 out, *)
+(*       exec_stmt e m s1 t1 m1 out -> *)
+(*       out <> Out_normal -> *)
+(*       exec_stmt e m (Ssequence s1 s2) *)
+(*                 t1 m1 out *)
+(*   | exec_Sifthenelse: forall e m a s1 s2 t1 m1 v1 t2 m2 b out, *)
+(*       eval_expression e m a t1 m1 v1 -> *)
+(*       bool_val v1 (typeof a) m1 = Some b -> *)
+(*       exec_stmt e m1 (if b then s1 else s2) t2 m2 out -> *)
+(*       exec_stmt e m (Sifthenelse a s1 s2) *)
+(*                 (t1**t2) m2 out *)
+(*   | exec_Sreturn_none:   forall e m, *)
+(*       exec_stmt e m (Sreturn None) *)
+(*                E0 m (Out_return None) *)
+(*   | exec_Sreturn_some: forall e m a t m' v, *)
+(*       eval_expression e m a t m' v -> *)
+(*       exec_stmt e m (Sreturn (Some a)) *)
+(*                 t m' (Out_return (Some(v, typeof a))) *)
+(*   | exec_Sbreak:   forall e m, *)
+(*       exec_stmt e m Sbreak *)
+(*                E0 m Out_break *)
+(*   | exec_Scontinue:   forall e m, *)
+(*       exec_stmt e m Scontinue *)
+(*                E0 m Out_continue *)
+(*   | exec_Swhile_false: forall e m a s t m' v, *)
+(*       eval_expression e m a t m' v -> *)
+(*       bool_val v (typeof a) m' = Some false -> *)
+(*       exec_stmt e m (Swhile a s) *)
+(*                 t m' Out_normal *)
+(*   | exec_Swhile_stop: forall e m a s t1 m1 v t2 m2 out' out, *)
+(*       eval_expression e m a t1 m1 v -> *)
+(*       bool_val v (typeof a) m1 = Some true -> *)
+(*       exec_stmt e m1 s t2 m2 out' -> *)
+(*       out_break_or_return out' out -> *)
+(*       exec_stmt e m (Swhile a s) *)
+(*                 (t1**t2) m2 out *)
+(*   | exec_Swhile_loop: forall e m a s t1 m1 v t2 m2 out1 t3 m3 out, *)
+(*       eval_expression e m a t1 m1 v -> *)
+(*       bool_val v (typeof a) m1 = Some true -> *)
+(*       exec_stmt e m1 s t2 m2 out1 -> *)
+(*       out_normal_or_continue out1 -> *)
+(*       exec_stmt e m2 (Swhile a s) t3 m3 out -> *)
+(*       exec_stmt e m (Swhile a s) *)
+(*                 (t1 ** t2 ** t3) m3 out *)
+(*   | exec_Sdowhile_false: forall e m s a t1 m1 out1 t2 m2 v, *)
+(*       exec_stmt e m s t1 m1 out1 -> *)
+(*       out_normal_or_continue out1 -> *)
+(*       eval_expression e m1 a t2 m2 v -> *)
+(*       bool_val v (typeof a) m2 = Some false -> *)
+(*       exec_stmt e m (Sdowhile a s) *)
+(*                 (t1 ** t2) m2 Out_normal *)
+(*   | exec_Sdowhile_stop: forall e m s a t m1 out1 out, *)
+(*       exec_stmt e m s t m1 out1 -> *)
+(*       out_break_or_return out1 out -> *)
+(*       exec_stmt e m (Sdowhile a s) *)
+(*                 t m1 out *)
+(*   | exec_Sdowhile_loop: forall e m s a t1 m1 out1 t2 m2 v t3 m3 out, *)
+(*       exec_stmt e m s t1 m1 out1 -> *)
+(*       out_normal_or_continue out1 -> *)
+(*       eval_expression e m1 a t2 m2 v -> *)
+(*       bool_val v (typeof a) m2 = Some true -> *)
+(*       exec_stmt e m2 (Sdowhile a s) t3 m3 out -> *)
+(*       exec_stmt e m (Sdowhile a s) *)
+(*                 (t1 ** t2 ** t3) m3 out *)
+(*   | exec_Sfor_start: forall e m s a1 a2 a3 out m1 m2 t1 t2, *)
+(*       exec_stmt e m a1 t1 m1 Out_normal -> *)
+(*       exec_stmt e m1 (Sfor Sskip a2 a3 s) t2 m2 out -> *)
+(*       exec_stmt e m (Sfor a1 a2 a3 s) *)
+(*                 (t1 ** t2) m2 out *)
+(*   | exec_Sfor_false: forall e m s a2 a3 t m' v, *)
+(*       eval_expression e m a2 t m' v -> *)
+(*       bool_val v (typeof a2) m' = Some false -> *)
+(*       exec_stmt e m (Sfor Sskip a2 a3 s) *)
+(*                 t m' Out_normal *)
+(*   | exec_Sfor_stop: forall e m s a2 a3 t1 m1 v t2 m2 out1 out, *)
+(*       eval_expression e m a2 t1 m1 v -> *)
+(*       bool_val v (typeof a2) m1 = Some true -> *)
+(*       exec_stmt e m1 s t2 m2 out1 -> *)
+(*       out_break_or_return out1 out -> *)
+(*       exec_stmt e m (Sfor Sskip a2 a3 s) *)
+(*                 (t1 ** t2) m2 out *)
+(*   | exec_Sfor_loop: forall e m s a2 a3 t1 m1 v t2 m2 out1 t3 m3 t4 m4 out, *)
+(*       eval_expression e m a2 t1 m1 v -> *)
+(*       bool_val v (typeof a2) m1 = Some true -> *)
+(*       exec_stmt e m1 s t2 m2 out1 -> *)
+(*       out_normal_or_continue out1 -> *)
+(*       exec_stmt e m2 a3 t3 m3 Out_normal -> *)
+(*       exec_stmt e m3 (Sfor Sskip a2 a3 s) t4 m4 out -> *)
+(*       exec_stmt e m (Sfor Sskip a2 a3 s) *)
+(*                 (t1 ** t2 ** t3 ** t4) m4 out *)
+(*   | exec_Sswitch:   forall e m a sl t1 m1 v n t2 m2 out, *)
+(*       eval_expression e m a t1 m1 v -> *)
+(*       sem_switch_arg v (typeof a) = Some n -> *)
+(*       exec_stmt e m1 (seq_of_labeled_statement (select_switch n sl)) t2 m2 out -> *)
+(*       exec_stmt e m (Sswitch a sl) *)
+(*                 (t1 ** t2) m2 (outcome_switch out) *)
+
+(* (** [eval_funcall m1 fd args t m2 res] describes the invocation of *)
+(*   function [fd] with arguments [args].  [res] is the value returned *)
+(*   by the call.  *) *)
+
+(* with eval_funcall: mem -> fundef -> list val -> trace -> mem -> val -> Prop := *)
+(*   | eval_funcall_internal: forall m f vargs t e m1 m2 m3 out vres m4, *)
+(*       list_norepet (var_names f.(fn_params) ++ var_names f.(fn_vars)) -> *)
+(*       alloc_variables ge empty_env m (f.(fn_params) ++ f.(fn_vars)) e m1 -> *)
+(*       bind_parameters ge e m1 f.(fn_params) vargs m2 -> *)
+(*       exec_stmt e m2 f.(fn_body) t m3 out -> *)
+(*       outcome_result_value out f.(fn_return) vres m3 -> *)
+(*       Mem.free_list m3 (blocks_of_env ge e) = Some m4 -> *)
+(*       eval_funcall m (Internal f) vargs t m4 vres *)
+(*   | eval_funcall_external: forall m ef targs tres cconv vargs t vres m', *)
+(*       external_call ef ge vargs m t vres m' -> *)
+(*       eval_funcall m (External ef targs tres cconv) vargs t m' vres. *)
+
+(* Scheme eval_expression_ind5 := Minimality for eval_expression Sort Prop *)
+(*   with eval_expr_ind5 := Minimality for eval_expr Sort Prop *)
+(*   with eval_exprlist_ind5 := Minimality for eval_exprlist Sort Prop *)
+(*   with exec_stmt_ind5 := Minimality for exec_stmt Sort Prop *)
+(*   with eval_funcall_ind5 := Minimality for eval_funcall Sort Prop. *)
+
+(* Combined Scheme bigstep_induction from *)
+(*         eval_expression_ind5,  eval_expr_ind5,  eval_exprlist_ind5, *)
+(*         exec_stmt_ind5, eval_funcall_ind5. *)
+
+(* (** [evalinf_expr ge e m1 K a T] denotes the fact that expression [a] *)
+(*   diverges in initial state [m1].  [T] is the trace of input/output *)
+(*   events performed during this evaluation.  *) *)
+
+(* CoInductive evalinf_expr: env -> mem -> kind -> expr -> traceinf -> Prop := *)
+(*   | evalinf_field: forall e m a t f ty, *)
+(*       evalinf_expr e m RV a t -> *)
+(*       evalinf_expr e m LV (Efield a f ty) t *)
+(*   | evalinf_valof: forall e m a t ty, *)
+(*       evalinf_expr e m LV a t -> *)
+(*       evalinf_expr e m RV (Evalof a ty) t *)
+(*   | evalinf_deref: forall e m a t ty, *)
+(*       evalinf_expr e m RV a t -> *)
+(*       evalinf_expr e m LV (Ederef a ty) t *)
+(*   | evalinf_addrof: forall e m a t ty, *)
+(*       evalinf_expr e m LV a t -> *)
+(*       evalinf_expr e m RV (Eaddrof a ty) t *)
+(*   | evalinf_unop: forall e m a t op ty, *)
+(*       evalinf_expr e m RV a t -> *)
+(*       evalinf_expr e m RV (Eunop op a ty) t *)
+(*   | evalinf_binop_left: forall e m a1 t1 a2 op ty, *)
+(*       evalinf_expr e m RV a1 t1 -> *)
+(*       evalinf_expr e m RV (Ebinop op a1 a2 ty) t1 *)
+(*   | evalinf_binop_right: forall e m a1 t1 m' a1' a2 t2 op ty, *)
+(*       eval_expr e m RV a1 t1 m' a1' -> evalinf_expr e m' RV a2 t2 -> *)
+(*       evalinf_expr e m RV (Ebinop op a1 a2 ty) (t1 *** t2) *)
+(*   | evalinf_cast: forall e m a t ty, *)
+(*       evalinf_expr e m RV a t -> *)
+(*       evalinf_expr e m RV (Ecast a ty) t *)
+(*   | evalinf_seqand: forall e m a1 a2 ty t1, *)
+(*       evalinf_expr e m RV a1 t1 -> *)
+(*       evalinf_expr e m RV (Eseqand a1 a2 ty) t1 *)
+(*   | evalinf_seqand_2: forall e m a1 a2 ty t1 m' a1' v1 t2, *)
+(*       eval_expr e m RV a1 t1 m' a1' -> eval_simple_rvalue ge e m' a1' v1 -> *)
+(*       bool_val v1 (typeof a1) m' = Some true -> *)
+(*       evalinf_expr e m' RV a2 t2 -> *)
+(*       evalinf_expr e m RV (Eseqand a1 a2 ty) (t1***t2) *)
+(*   | evalinf_seqor: forall e m a1 a2 ty t1, *)
+(*       evalinf_expr e m RV a1 t1 -> *)
+(*       evalinf_expr e m RV (Eseqor a1 a2 ty) t1 *)
+(*   | evalinf_seqor_2: forall e m a1 a2 ty t1 m' a1' v1 t2, *)
+(*       eval_expr e m RV a1 t1 m' a1' -> eval_simple_rvalue ge e m' a1' v1 -> *)
+(*       bool_val v1 (typeof a1) m' = Some false -> *)
+(*       evalinf_expr e m' RV a2 t2 -> *)
+(*       evalinf_expr e m RV (Eseqor a1 a2 ty) (t1***t2) *)
+(*   | evalinf_condition: forall e m a1 a2 a3 ty t1, *)
+(*       evalinf_expr e m RV a1 t1 -> *)
+(*       evalinf_expr e m RV (Econdition a1 a2 a3 ty) t1 *)
+(*   | evalinf_condition_2: forall e m a1 a2 a3 ty t1 m' a1' v1 t2 b, *)
+(*       eval_expr e m RV a1 t1 m' a1' -> eval_simple_rvalue ge e m' a1' v1 -> *)
+(*       bool_val v1 (typeof a1) m' = Some b -> *)
+(*       evalinf_expr e m' RV (if b then a2 else a3) t2 -> *)
+(*       evalinf_expr e m RV (Econdition a1 a2 a3 ty) (t1***t2) *)
+(*   | evalinf_assign_left: forall e m a1 t1 a2 ty, *)
+(*       evalinf_expr e m LV a1 t1 -> *)
+(*       evalinf_expr e m RV (Eassign a1 a2 ty) t1 *)
+(*   | evalinf_assign_right: forall e m a1 t1 m' a1' a2 t2 ty, *)
+(*       eval_expr e m LV a1 t1 m' a1' -> evalinf_expr e m' RV a2 t2 -> *)
+(*       evalinf_expr e m RV (Eassign a1 a2 ty) (t1 *** t2) *)
+(*   | evalinf_assignop_left: forall e m a1 t1 a2 op tyres ty, *)
+(*       evalinf_expr e m LV a1 t1 -> *)
+(*       evalinf_expr e m RV (Eassignop op a1 a2 tyres ty) t1 *)
+(*   | evalinf_assignop_right: forall e m a1 t1 m' a1' a2 t2 op tyres ty, *)
+(*       eval_expr e m LV a1 t1 m' a1' -> evalinf_expr e m' RV a2 t2 -> *)
+(*       evalinf_expr e m RV (Eassignop op a1 a2 tyres ty) (t1 *** t2) *)
+(*   | evalinf_postincr: forall e m a t id ty, *)
+(*       evalinf_expr e m LV a t -> *)
+(*       evalinf_expr e m RV (Epostincr id a ty) t *)
+(*   | evalinf_comma_left: forall e m a1 t1 a2 ty, *)
+(*       evalinf_expr e m RV a1 t1 -> *)
+(*       evalinf_expr e m RV (Ecomma a1 a2 ty) t1 *)
+(*   | evalinf_comma_right: forall e m a1 t1 m1 a1' v1 a2 t2 ty, *)
+(*       eval_expr e m RV a1 t1 m1 a1' -> eval_simple_rvalue ge e m1 a1' v1 -> *)
+(*       ty = typeof a2 -> *)
+(*       evalinf_expr e m1 RV a2 t2 -> *)
+(*       evalinf_expr e m RV (Ecomma a1 a2 ty) (t1 *** t2) *)
+(*   | evalinf_call_left: forall e m a1 t1 a2 ty, *)
+(*       evalinf_expr e m RV a1 t1 -> *)
+(*       evalinf_expr e m RV (Ecall a1 a2 ty) t1 *)
+(*   | evalinf_call_right: forall e m a1 t1 m1 a1' a2 t2 ty, *)
+(*       eval_expr e m RV a1 t1 m1 a1' -> *)
+(*       evalinf_exprlist e m1 a2 t2 -> *)
+(*       evalinf_expr e m RV (Ecall a1 a2 ty) (t1 *** t2) *)
+(*   | evalinf_call: forall e m rf rargs ty t1 m1 rf' t2 m2 rargs' vf vargs *)
+(*                       targs tres cconv fd t3, *)
+(*       eval_expr e m RV rf t1 m1 rf' -> eval_exprlist e m1 rargs t2 m2 rargs' -> *)
+(*       eval_simple_rvalue ge e m2 rf' vf -> *)
+(*       eval_simple_list ge e m2 rargs' targs vargs -> *)
+(*       classify_fun (typeof rf) = fun_case_f targs tres cconv -> *)
+(*       Genv.find_funct ge vf = Some fd -> *)
+(*       type_of_fundef fd = Tfunction targs tres cconv -> *)
+(*       evalinf_funcall m2 fd vargs t3 -> *)
+(*       evalinf_expr e m RV (Ecall rf rargs ty) (t1***t2***t3) *)
+
+(* with evalinf_exprlist: env -> mem -> exprlist -> traceinf -> Prop := *)
+(*   | evalinf_cons_left: forall e m a1 al t1, *)
+(*       evalinf_expr e m RV a1 t1 -> *)
+(*       evalinf_exprlist e m (Econs a1 al) t1 *)
+(*   | evalinf_cons_right: forall e m a1 al t1 m1 a1' t2, *)
+(*       eval_expr e m RV a1 t1 m1 a1' -> evalinf_exprlist e m1 al t2 -> *)
+(*       evalinf_exprlist e m (Econs a1 al) (t1***t2) *)
+
+(* (** [execinf_stmt ge e m1 s t] describes the diverging execution of *)
+(*   the statement [s].  *) *)
+
+(* with execinf_stmt: env -> mem -> statement -> traceinf -> Prop := *)
+(*   | execinf_Sdo:     forall e m a t, *)
+(*       evalinf_expr e m RV a t -> *)
+(*       execinf_stmt e m (Sdo a) t *)
+(*   | execinf_Sseq_1:   forall e m s1 s2 t1, *)
+(*       execinf_stmt e m s1 t1 -> *)
+(*       execinf_stmt e m (Ssequence s1 s2) t1 *)
+(*   | execinf_Sseq_2:   forall e m s1 s2 t1 m1 t2, *)
+(*       exec_stmt e m s1 t1 m1 Out_normal -> *)
+(*       execinf_stmt e m1 s2 t2 -> *)
+(*       execinf_stmt e m (Ssequence s1 s2) (t1***t2) *)
+(*   | execinf_Sifthenelse_test: forall e m a s1 s2 t1, *)
+(*       evalinf_expr e m RV a t1 -> *)
+(*       execinf_stmt e m (Sifthenelse a s1 s2) t1 *)
+(*   | execinf_Sifthenelse: forall e m a s1 s2 t1 m1 v1 t2 b, *)
+(*       eval_expression e m a t1 m1 v1 -> *)
+(*       bool_val v1 (typeof a) m1 = Some b -> *)
+(*       execinf_stmt e m1 (if b then s1 else s2) t2 -> *)
+(*       execinf_stmt e m (Sifthenelse a s1 s2) (t1***t2) *)
+(*   | execinf_Sreturn_some: forall e m a t, *)
+(*       evalinf_expr e m RV a t -> *)
+(*       execinf_stmt e m (Sreturn (Some a)) t *)
+(*   | execinf_Swhile_test: forall e m a s t1, *)
+(*       evalinf_expr e m RV a t1 -> *)
+(*       execinf_stmt e m (Swhile a s) t1 *)
+(*   | execinf_Swhile_body: forall e m a s t1 m1 v t2, *)
+(*       eval_expression e m a t1 m1 v -> *)
+(*       bool_val v (typeof a) m1 = Some true -> *)
+(*       execinf_stmt e m1 s t2 -> *)
+(*       execinf_stmt e m (Swhile a s) (t1***t2) *)
+(*   | execinf_Swhile_loop: forall e m a s t1 m1 v t2 m2 out1 t3, *)
+(*       eval_expression e m a t1 m1 v -> *)
+(*       bool_val v (typeof a) m1 = Some true -> *)
+(*       exec_stmt e m1 s t2 m2 out1 -> *)
+(*       out_normal_or_continue out1 -> *)
+(*       execinf_stmt e m2 (Swhile a s) t3 -> *)
+(*       execinf_stmt e m (Swhile a s) (t1***t2***t3) *)
+(*   | execinf_Sdowhile_body: forall e m s a t1, *)
+(*       execinf_stmt e m s t1 -> *)
+(*       execinf_stmt e m (Sdowhile a s) t1 *)
+(*   | execinf_Sdowhile_test: forall e m s a t1 m1 out1 t2, *)
+(*       exec_stmt e m s t1 m1 out1 -> *)
+(*       out_normal_or_continue out1 -> *)
+(*       evalinf_expr e m1 RV a t2 -> *)
+(*       execinf_stmt e m (Sdowhile a s) (t1***t2) *)
+(*   | execinf_Sdowhile_loop: forall e m s a t1 m1 out1 t2 m2 v t3, *)
+(*       exec_stmt e m s t1 m1 out1 -> *)
+(*       out_normal_or_continue out1 -> *)
+(*       eval_expression e m1 a t2 m2 v -> *)
+(*       bool_val v (typeof a) m2 = Some true -> *)
+(*       execinf_stmt e m2 (Sdowhile a s) t3 -> *)
+(*       execinf_stmt e m (Sdowhile a s) (t1***t2***t3) *)
+(*   | execinf_Sfor_start_1: forall e m s a1 a2 a3 t1, *)
+(*       execinf_stmt e m a1 t1 -> *)
+(*       execinf_stmt e m (Sfor a1 a2 a3 s) t1 *)
+(*   | execinf_Sfor_start_2: forall e m s a1 a2 a3 m1 t1 t2, *)
+(*       exec_stmt e m a1 t1 m1 Out_normal -> a1 <> Sskip -> *)
+(*       execinf_stmt e m1 (Sfor Sskip a2 a3 s) t2 -> *)
+(*       execinf_stmt e m (Sfor a1 a2 a3 s) (t1***t2) *)
+(*   | execinf_Sfor_test: forall e m s a2 a3 t, *)
+(*       evalinf_expr e m RV a2 t -> *)
+(*       execinf_stmt e m (Sfor Sskip a2 a3 s) t *)
+(*   | execinf_Sfor_body: forall e m s a2 a3 t1 m1 v t2, *)
+(*       eval_expression e m a2 t1 m1 v -> *)
+(*       bool_val v (typeof a2) m1 = Some true -> *)
+(*       execinf_stmt e m1 s t2 -> *)
+(*       execinf_stmt e m (Sfor Sskip a2 a3 s) (t1***t2) *)
+(*   | execinf_Sfor_next: forall e m s a2 a3 t1 m1 v t2 m2 out1 t3, *)
+(*       eval_expression e m a2 t1 m1 v -> *)
+(*       bool_val v (typeof a2) m1 = Some true -> *)
+(*       exec_stmt e m1 s t2 m2 out1 -> *)
+(*       out_normal_or_continue out1 -> *)
+(*       execinf_stmt e m2 a3 t3 -> *)
+(*       execinf_stmt e m (Sfor Sskip a2 a3 s) (t1***t2***t3) *)
+(*   | execinf_Sfor_loop: forall e m s a2 a3 t1 m1 v t2 m2 out1 t3 m3 t4, *)
+(*       eval_expression e m a2 t1 m1 v -> *)
+(*       bool_val v (typeof a2) m1 = Some true -> *)
+(*       exec_stmt e m1 s t2 m2 out1 -> *)
+(*       out_normal_or_continue out1 -> *)
+(*       exec_stmt e m2 a3 t3 m3 Out_normal -> *)
+(*       execinf_stmt e m3 (Sfor Sskip a2 a3 s) t4 -> *)
+(*       execinf_stmt e m (Sfor Sskip a2 a3 s) (t1***t2***t3***t4) *)
+(*   | execinf_Sswitch_expr:   forall e m a sl t1, *)
+(*       evalinf_expr e m RV a t1 -> *)
+(*       execinf_stmt e m (Sswitch a sl) t1 *)
+(*   | execinf_Sswitch_body:   forall e m a sl t1 m1 v n t2, *)
+(*       eval_expression e m a t1 m1 v -> *)
+(*       sem_switch_arg v (typeof a) = Some n -> *)
+(*       execinf_stmt e m1 (seq_of_labeled_statement (select_switch n sl)) t2 -> *)
+(*       execinf_stmt e m (Sswitch a sl) (t1***t2) *)
+
+(* (** [evalinf_funcall m1 fd args t m2 res] describes a diverging *)
+(*   invocation of function [fd] with arguments [args].  *) *)
+
+(* with evalinf_funcall: mem -> fundef -> list val -> traceinf -> Prop := *)
+(*   | evalinf_funcall_internal: forall m f vargs t e m1 m2, *)
+(*       list_norepet (var_names f.(fn_params) ++ var_names f.(fn_vars)) -> *)
+(*       alloc_variables ge empty_env m (f.(fn_params) ++ f.(fn_vars)) e m1 -> *)
+(*       bind_parameters ge e m1 f.(fn_params) vargs m2 -> *)
+(*       execinf_stmt e m2 f.(fn_body) t -> *)
+(*       evalinf_funcall m (Internal f) vargs t. *)
+
+(* (** ** Implication from big-step semantics to transition semantics *) *)
+
+(* Inductive outcome_state_match *)
+(*        (e: env) (m: mem) (f: function) (k: cont): outcome -> state -> Prop := *)
+(*   | osm_normal: *)
+(*       outcome_state_match e m f k Out_normal (State f Sskip k e m) *)
+(*   | osm_break: *)
+(*       outcome_state_match e m f k Out_break (State f Sbreak k e m) *)
+(*   | osm_continue: *)
+(*       outcome_state_match e m f k Out_continue (State f Scontinue k e m) *)
+(*   | osm_return_none: forall k', *)
+(*       call_cont k' = call_cont k -> *)
+(*       outcome_state_match e m f k *)
+(*         (Out_return None) (State f (Sreturn None) k' e m) *)
+(*   | osm_return_some: forall v ty k', *)
+(*       call_cont k' = call_cont k -> *)
+(*       outcome_state_match e m f k *)
+(*         (Out_return (Some (v, ty))) (ExprState f (Eval v ty) (Kreturn k') e m). *)
+
+(* Lemma is_call_cont_call_cont: *)
+(*   forall k, is_call_cont k -> call_cont k = k. *)
+(* Proof. *)
+(*   destruct k; simpl; intros; contradiction || auto. *)
+(* Qed. *)
+
+(* Lemma leftcontext_compose: *)
+(*   forall k2 k3 C2, leftcontext k2 k3 C2 -> *)
+(*   forall k1 C1, leftcontext k1 k2 C1 -> *)
+(*   leftcontext k1 k3 (fun x => C2(C1 x)) *)
+(* with leftcontextlist_compose: *)
+(*   forall k2 C2, leftcontextlist k2 C2 -> *)
+(*   forall k1 C1, leftcontext k1 k2 C1 -> *)
+(*   leftcontextlist k1 (fun x => C2(C1 x)). *)
+(* Proof. *)
+(*   induction 1; intros; try (constructor; eauto). *)
+(*   replace (fun x => C1 x) with C1. auto. apply extensionality; auto. *)
+(*   induction 1; intros; constructor; eauto. *)
+(* Qed. *)
+
+(* Lemma exprlist_app_leftcontext: *)
+(*   forall rl1 rl2, *)
+(*   simplelist rl1 = true -> leftcontextlist RV (fun x => exprlist_app rl1 (Econs x rl2)). *)
+(* Proof. *)
+(*   induction rl1; simpl; intros. *)
+(*   apply lctx_list_head. constructor. *)
+(*   destruct (andb_prop _ _ H). apply lctx_list_tail. auto. auto. *)
+(* Qed. *)
+
+(* Lemma exprlist_app_simple: *)
+(*   forall rl1 rl2, *)
+(*   simplelist (exprlist_app rl1 rl2) = simplelist rl1 && simplelist rl2. *)
+(* Proof. *)
+(*   induction rl1; intros; simpl. auto. rewrite IHrl1. apply andb_assoc. *)
+(* Qed. *)
+
+(* Lemma bigstep_to_steps: *)
+(*   (forall e m a t m' v, *)
+(*    eval_expression e m a t m' v -> *)
+(*    forall f k, *)
+(*    star step ge (ExprState f a k e m) t (ExprState f (Eval v (typeof a)) k e m')) *)
+(* /\(forall e m K a t m' a', *)
+(*    eval_expr e m K a t m' a' -> *)
+(*    forall C f k, leftcontext K RV C -> *)
+(*    simple a' = true /\ typeof a' = typeof a /\ *)
+(*    star step ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m')) *)
+(* /\(forall e m al t m' al', *)
+(*    eval_exprlist e m al t m' al' -> *)
+(*    forall a1 al2 ty C f k, leftcontext RV RV C -> simple a1 = true -> simplelist al2 = true -> *)
+(*    simplelist al' = true /\ *)
+(*    star step ge (ExprState f (C (Ecall a1 (exprlist_app al2 al) ty)) k e m) *)
+(*               t (ExprState f (C (Ecall a1 (exprlist_app al2 al') ty)) k e m')) *)
+(* /\(forall e m s t m' out, *)
+(*    exec_stmt e m s t m' out -> *)
+(*    forall f k, *)
+(*    exists S, *)
+(*    star step ge (State f s k e m) t S /\ outcome_state_match e m' f k out S) *)
+(* /\(forall m fd args t m' res, *)
+(*    eval_funcall m fd args t m' res -> *)
+(*    forall k, *)
+(*    is_call_cont k -> *)
+(*    star step ge (Callstate fd args k m) t (Returnstate res k m')). *)
+(* Proof. *)
+(*   apply bigstep_induction; intros. *)
+(* (* expression, general *) *)
+(*   exploit (H0 (fun x => x) f k). constructor. intros [A [B C]]. *)
+(*   assert (match a' with Eval _ _ => False | _ => True end -> *)
+(*           star step ge (ExprState f a k e m) t (ExprState f (Eval v (typeof a)) k e m')). *)
+(*    intro. eapply star_right. eauto. left. eapply step_expr; eauto. traceEq. *)
+(*   destruct a'; auto. *)
+(*   simpl in B. rewrite B in C. inv H1. auto. *)
+
+(* (* val *) *)
+(*   simpl; intuition. apply star_refl. *)
+(* (* var *) *)
+(*   simpl; intuition. apply star_refl. *)
+(* (* field *) *)
+(*   exploit (H0 (fun x => C(Efield x f ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]]. *)
+(*   simpl; intuition; eauto. *)
+(* (* valof *) *)
+(*   exploit (H1 (fun x => C(Evalof x ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]]. *)
+(*   simpl; intuition; eauto. rewrite A; rewrite B; rewrite H; auto. *)
+(* (* valof volatile *) *)
+(*   exploit (H1 (fun x => C(Evalof x ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]]. *)
+(*   simpl; intuition. *)
+(*   eapply star_right. eexact D. *)
+(*   left. eapply step_rvalof_volatile; eauto. rewrite H4; eauto. congruence. congruence. *)
+(*   traceEq. *)
+(* (* deref *) *)
+(*   exploit (H0 (fun x => C(Ederef x ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]]. *)
+(*   simpl; intuition; eauto. *)
+(* (* addrof *) *)
+(*   exploit (H0 (fun x => C(Eaddrof x ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]]. *)
+(*   simpl; intuition; eauto. *)
+(* (* unop *) *)
+(*   exploit (H0 (fun x => C(Eunop op x ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]]. *)
+(*   simpl; intuition; eauto. *)
+(* (* binop *) *)
+(*   exploit (H0 (fun x => C(Ebinop op x a2 ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]]. *)
+(*   exploit (H2 (fun x => C(Ebinop op a1' x ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. auto. intros [E [F G]]. *)
+(*   simpl; intuition. eapply star_trans; eauto. *)
+(* (* cast *) *)
+(*   exploit (H0 (fun x => C(Ecast x ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]]. *)
+(*   simpl; intuition; eauto. *)
+(* (* seqand true *) *)
+(*   exploit (H0 (fun x => C(Eseqand x a2 ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]]. *)
+(*   exploit (H4 (fun x => C(Eparen x type_bool ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. intros [E [F G]]. *)
+(*   simpl; intuition. eapply star_trans. eexact D. *)
+(*   eapply star_left. left; eapply step_seqand_true; eauto. rewrite B; auto. *)
+(*   eapply star_right. eexact G. *)
+(*   left; eapply step_paren; eauto. rewrite F; eauto. *)
+(*   eauto. eauto. traceEq. *)
+(* (* seqand false *) *)
+(*   exploit (H0 (fun x => C(Eseqand x a2 ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]]. *)
+(*   simpl; intuition. eapply star_right. eexact D. *)
+(*   left; eapply step_seqand_false; eauto. rewrite B; auto. *)
+(*   traceEq. *)
+(* (* seqor false *) *)
+(*   exploit (H0 (fun x => C(Eseqor x a2 ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]]. *)
+(*   exploit (H4 (fun x => C(Eparen x type_bool ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. intros [E [F G]]. *)
+(*   simpl; intuition. eapply star_trans. eexact D. *)
+(*   eapply star_left. left; eapply step_seqor_false; eauto. rewrite B; auto. *)
+(*   eapply star_right. eexact G. *)
+(*   left; eapply step_paren; eauto. rewrite F; eauto. *)
+(*   eauto. eauto. traceEq. *)
+(* (* seqor true *) *)
+(*   exploit (H0 (fun x => C(Eseqor x a2 ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]]. *)
+(*   simpl; intuition. eapply star_right. eexact D. *)
+(*   left; eapply step_seqor_true; eauto. rewrite B; auto. *)
+(*   traceEq. *)
+(* (* condition *) *)
+(*   exploit (H0 (fun x => C(Econdition x a2 a3 ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]]. *)
+(*   exploit (H4 (fun x => C(Eparen x ty ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. intros [E [F G]]. *)
+(*   simpl. split; auto. split; auto. *)
+(*   eapply star_trans. eexact D. *)
+(*   eapply star_left. left; eapply step_condition; eauto. rewrite B; eauto. *)
+(*   eapply star_right. eexact G. left; eapply step_paren; eauto. congruence. *)
+(*   reflexivity. reflexivity. traceEq. *)
+(* (* sizeof *) *)
+(*   simpl; intuition. apply star_refl. *)
+(* (* alignof *) *)
+(*   simpl; intuition. apply star_refl. *)
+(* (* assign *) *)
+(*   exploit (H0 (fun x => C(Eassign x r ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]]. *)
+(*   exploit (H2 (fun x => C(Eassign l' x ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. auto. intros [E [F G]]. *)
+(*   simpl; intuition. *)
+(*   eapply star_trans. eexact D. *)
+(*   eapply star_right. eexact G. *)
+(*   left. eapply step_assign; eauto. congruence. rewrite B; eauto. congruence. *)
+(*   reflexivity. traceEq. *)
+(* (* assignop *) *)
+(*   exploit (H0 (fun x => C(Eassignop op x r tyres ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]]. *)
+(*   exploit (H2 (fun x => C(Eassignop op l' x tyres ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. auto. intros [E [F G]]. *)
+(*   simpl; intuition. *)
+(*   eapply star_trans. eexact D. *)
+(*   eapply star_right. eexact G. *)
+(*   left. eapply step_assignop; eauto. *)
+(*   rewrite B; eauto. rewrite B; rewrite F; eauto. congruence. rewrite B; eauto. congruence. *)
+(*   reflexivity. traceEq. *)
+(* (* postincr *) *)
+(*   exploit (H0 (fun x => C(Epostincr id x ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]]. *)
+(*   simpl; intuition. *)
+(*   eapply star_right. eexact D. *)
+(*   left. eapply step_postincr; eauto. congruence. *)
+(*   traceEq. *)
+(* (* comma *) *)
+(*   exploit (H0 (fun x => C(Ecomma x r2 ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]]. *)
+(*   exploit (H3 C). auto. intros [E [F G]]. *)
+(*   simpl; intuition. congruence. *)
+(*   eapply star_trans. eexact D. *)
+(*   eapply star_left. left; eapply step_comma; eauto. *)
+(*   eexact G. *)
+(*   reflexivity. traceEq. *)
+(* (* call *) *)
+(*   exploit (H0 (fun x => C(Ecall x rargs ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. intros [A [B D]]. *)
+(*   exploit (H2 rf' Enil ty C); eauto. intros [E F]. *)
+(*   simpl; intuition. *)
+(*   eapply star_trans. eexact D. *)
+(*   eapply star_trans. eexact F. *)
+(*   eapply star_left. left; eapply step_call; eauto. congruence. *)
+(*   eapply star_right. eapply H9. red; auto. *)
+(*   right; constructor. *)
+(*   reflexivity. reflexivity. reflexivity. traceEq. *)
+(* (* nil *) *)
+(*   simpl; intuition. apply star_refl. *)
+(* (* cons *) *)
+(*   exploit (H0 (fun x => C(Ecall a0 (exprlist_app al2 (Econs x al)) ty))). *)
+(*     eapply leftcontext_compose; eauto. repeat constructor. auto. *)
+(*     apply exprlist_app_leftcontext; auto. intros [A [B D]]. *)
+(*   exploit (H2 a0 (exprlist_app al2 (Econs a1' Enil))); eauto. *)
+(*   rewrite exprlist_app_simple. simpl. rewrite H5; rewrite A; auto. *)
+(*   repeat rewrite exprlist_app_assoc. simpl. *)
+(*   intros [E F]. *)
+(*   simpl; intuition. *)
+(*   eapply star_trans; eauto. *)
+
+(* (* skip *) *)
+(*   econstructor; split. apply star_refl. constructor. *)
+
+(* (* do *) *)
+(*   econstructor; split. *)
+(*   eapply star_left. right; constructor. *)
+(*   eapply star_right. apply H0. right; constructor. *)
+(*   reflexivity. traceEq. *)
+(*   constructor. *)
+
+(* (* sequence 2 *) *)
+(*   destruct (H0 f (Kseq s2 k)) as [S1 [A1 B1]]; auto. inv B1. *)
+(*   destruct (H2 f k) as [S2 [A2 B2]]; auto. *)
+(*   econstructor; split. *)
+(*   eapply star_left. right; econstructor. *)
+(*   eapply star_trans. eexact A1. *)
+(*   eapply star_left. right; constructor. eexact A2. *)
+(*   reflexivity. reflexivity. traceEq. *)
+(*   auto. *)
+
+(* (* sequence 1 *) *)
+(*   destruct (H0 f (Kseq s2 k)) as [S1 [A1 B1]]; auto. *)
+(*   set (S2 := *)
+(*     match out with *)
+(*     | Out_break => State f Sbreak k e m1 *)
+(*     | Out_continue => State f Scontinue k e m1 *)
+(*     | _ => S1 *)
+(*     end). *)
+(*   exists S2; split. *)
+(*   eapply star_left. right; econstructor. *)
+(*   eapply star_trans. eexact A1. *)
+(*   unfold S2; inv B1. *)
+(*     congruence. *)
+(*     apply star_one. right; apply step_break_seq. *)
+(*     apply star_one. right; apply step_continue_seq. *)
+(*     apply star_refl. *)
+(*     apply star_refl. *)
+(*   reflexivity. traceEq. *)
+(*   unfold S2; inv B1; congruence || econstructor; eauto. *)
+
+(* (* ifthenelse *) *)
+(*   destruct (H3 f k) as [S1 [A1 B1]]; auto. *)
+(*   exists S1; split. *)
+(*   eapply star_left. right; apply step_ifthenelse_1. *)
+(*   eapply star_trans. eapply H0. *)
+(*   eapply star_left. 2: eexact A1. right; eapply step_ifthenelse_2; eauto. *)
+(*   reflexivity. reflexivity. traceEq. *)
+(*   auto. *)
+
+(* (* return none *) *)
+(*   econstructor; split. apply star_refl. constructor. auto. *)
+
+(* (* return some *) *)
+(*   econstructor; split. *)
+(*   eapply star_left. right; apply step_return_1. *)
+(*   eapply H0. traceEq. *)
+(*   econstructor; eauto. *)
+
+(* (* break *) *)
+(*   econstructor; split. apply star_refl. constructor. *)
+
+(* (* continue *) *)
+(*   econstructor; split. apply star_refl. constructor. *)
+
+(* (* while false *) *)
+(*   econstructor; split. *)
+(*   eapply star_left. right; apply step_while. *)
+(*   eapply star_right. apply H0. right; eapply step_while_false; eauto. *)
+(*   reflexivity. traceEq. *)
+(*   constructor. *)
+
+(* (* while stop *) *)
+(*   destruct (H3 f (Kwhile2 a s k)) as [S1 [A1 B1]]. *)
+(*   set (S2 := *)
+(*     match out' with *)
+(*     | Out_break => State f Sskip k e m2 *)
+(*     | _ => S1 *)
+(*     end). *)
+(*   exists S2; split. *)
+(*   eapply star_left. right; apply step_while. *)
+(*   eapply star_trans. apply H0. *)
+(*   eapply star_left. right; eapply step_while_true; eauto. *)
+(*   eapply star_trans. eexact A1. *)
+(*   unfold S2. inversion H4; subst. *)
+(*   inv B1. apply star_one. right; constructor. *)
+(*   apply star_refl. *)
+(*   reflexivity. reflexivity. reflexivity. traceEq. *)
+(*   unfold S2. inversion H4; subst. constructor. inv B1; econstructor; eauto. *)
+
+(* (* while loop *) *)
+(*   destruct (H3 f (Kwhile2 a s k)) as [S1 [A1 B1]]. *)
+(*   destruct (H6 f k) as [S2 [A2 B2]]; auto. *)
+(*   exists S2; split. *)
+(*   eapply star_left. right; apply step_while. *)
+(*   eapply star_trans. apply H0. *)
+(*   eapply star_left. right; eapply step_while_true; eauto. *)
+(*   eapply star_trans. eexact A1. *)
+(*   eapply star_left. *)
+(*   inv H4; inv B1; right; apply step_skip_or_continue_while; auto. *)
+(*   eexact A2. *)
+(*   reflexivity. reflexivity. reflexivity. reflexivity. traceEq. *)
+(*   auto. *)
+
+(* (* dowhile false *) *)
+(*   destruct (H0 f (Kdowhile1 a s k)) as [S1 [A1 B1]]. *)
+(*   exists (State f Sskip k e m2); split. *)
+(*   eapply star_left. right; constructor. *)
+(*   eapply star_trans. eexact A1. *)
+(*   eapply star_left. *)
+(*   inv H1; inv B1; right; eapply step_skip_or_continue_dowhile; eauto. *)
+(*   eapply star_right. apply H3. *)
+(*   right; eapply step_dowhile_false; eauto. *)
+(*   reflexivity. reflexivity. reflexivity. traceEq. *)
+(*   constructor. *)
+
+(* (* dowhile stop *) *)
+(*   destruct (H0 f (Kdowhile1 a s k)) as [S1 [A1 B1]]. *)
+(*   set (S2 := *)
+(*     match out1 with *)
+(*     | Out_break => State f Sskip k e m1 *)
+(*     | _ => S1 *)
+(*     end). *)
+(*   exists S2; split. *)
+(*   eapply star_left. right; apply step_dowhile. *)
+(*   eapply star_trans. eexact A1. *)
+(*   unfold S2. inversion H1; subst. *)
+(*   inv B1. apply star_one. right; constructor. *)
+(*   apply star_refl. *)
+(*   reflexivity. traceEq. *)
+(*   unfold S2. inversion H1; subst. constructor. inv B1; econstructor; eauto. *)
+
+(* (* dowhile loop *) *)
+(*   destruct (H0 f (Kdowhile1 a s k)) as [S1 [A1 B1]]. *)
+(*   destruct (H6 f k) as [S2 [A2 B2]]; auto. *)
+(*   exists S2; split. *)
+(*   eapply star_left. right; constructor. *)
+(*   eapply star_trans. eexact A1. *)
+(*   eapply star_left. *)
+(*   inv H1; inv B1; right; eapply step_skip_or_continue_dowhile; eauto. *)
+(*   eapply star_trans. apply H3. *)
+(*   eapply star_left. right; eapply step_dowhile_true; eauto. *)
+(*   eexact A2. *)
+(*   reflexivity. reflexivity. reflexivity. reflexivity. traceEq. *)
+(*   auto. *)
+
+(* (* for start *) *)
+(*   assert (a1 = Sskip \/ a1 <> Sskip). destruct a1; auto; right; congruence. *)
+(*   destruct H3. *)
+(*   subst a1. inv H. apply H2; auto. *)
+(*   destruct (H0 f (Kseq (Sfor Sskip a2 a3 s) k)) as [S1 [A1 B1]]; auto. inv B1. *)
+(*   destruct (H2 f k) as [S2 [A2 B2]]; auto. *)
+(*   exists S2; split. *)
+(*   eapply star_left. right; apply step_for_start; auto. *)
+(*   eapply star_trans. eexact A1. *)
+(*   eapply star_left. right; constructor. eexact A2. *)
+(*   reflexivity. reflexivity. traceEq. *)
+(*   auto. *)
+
+(* (* for false *) *)
+(*   econstructor; split. *)
+(*   eapply star_left. right; apply step_for. *)
+(*   eapply star_right. apply H0. right; eapply step_for_false; eauto. *)
+(*   reflexivity. traceEq. *)
+(*   constructor. *)
+
+(* (* for stop *) *)
+(*   destruct (H3 f (Kfor3 a2 a3 s k)) as [S1 [A1 B1]]. *)
+(*   set (S2 := *)
+(*     match out1 with *)
+(*     | Out_break => State f Sskip k e m2 *)
+(*     | _ => S1 *)
+(*     end). *)
+(*   exists S2; split. *)
+(*   eapply star_left. right; apply step_for. *)
+(*   eapply star_trans. apply H0. *)
+(*   eapply star_left. right; eapply step_for_true; eauto. *)
+(*   eapply star_trans. eexact A1. *)
+(*   unfold S2. inversion H4; subst. *)
+(*   inv B1. apply star_one. right; constructor. *)
+(*   apply star_refl. *)
+(*   reflexivity. reflexivity. reflexivity. traceEq. *)
+(*   unfold S2. inversion H4; subst. constructor. inv B1; econstructor; eauto. *)
+
+(* (* for loop *) *)
+(*   destruct (H3 f (Kfor3 a2 a3 s k)) as [S1 [A1 B1]]. *)
+(*   destruct (H6 f (Kfor4 a2 a3 s k)) as [S2 [A2 B2]]; auto. inv B2. *)
+(*   destruct (H8 f k) as [S3 [A3 B3]]; auto. *)
+(*   exists S3; split. *)
+(*   eapply star_left. right; apply step_for. *)
+(*   eapply star_trans. apply H0. *)
+(*   eapply star_left. right; eapply step_for_true; eauto. *)
+(*   eapply star_trans. eexact A1. *)
+(*   eapply star_trans with (s2 := State f a3 (Kfor4 a2 a3 s k) e m2). *)
+(*   inv H4; inv B1. *)
+(*   apply star_one. right; constructor; auto. *)
+(*   apply star_one. right; constructor; auto. *)
+(*   eapply star_trans. eexact A2. *)
+(*   eapply star_left. right; constructor. *)
+(*   eexact A3. *)
+(*   reflexivity. reflexivity. reflexivity. reflexivity. *)
+(*   reflexivity. reflexivity. traceEq. *)
+(*   auto. *)
+
+(* (* switch *) *)
+(*   destruct (H3 f (Kswitch2 k)) as [S1 [A1 B1]]. *)
+(*   set (S2 := *)
+(*     match out with *)
+(*     | Out_normal => State f Sskip k e m2 *)
+(*     | Out_break => State f Sskip k e m2 *)
+(*     | Out_continue => State f Scontinue k e m2 *)
+(*     | _ => S1 *)
+(*     end). *)
+(*   exists S2; split. *)
+(*   eapply star_left. right; eapply step_switch. *)
+(*   eapply star_trans. apply H0. *)
+(*   eapply star_left. right; eapply step_expr_switch. eauto. *)
+(*   eapply star_trans. eexact A1. *)
+(*   unfold S2; inv B1. *)
+(*     apply star_one. right; constructor. auto. *)
+(*     apply star_one. right; constructor. auto. *)
+(*     apply star_one. right; constructor. *)
+(*     apply star_refl. *)
+(*     apply star_refl. *)
+(*   reflexivity. reflexivity. reflexivity. traceEq. *)
+(*   unfold S2. inv B1; simpl; econstructor; eauto. *)
+
+(* (* call internal *) *)
+(*   destruct (H3 f k) as [S1 [A1 B1]]. *)
+(*   eapply star_left. right; eapply step_internal_function; eauto. *)
+(*   eapply star_right. eexact A1. *)
+(*   inv B1; simpl in H4; try contradiction. *)
+(*   (* Out_normal *) *)
+(*   assert (fn_return f = Tvoid /\ vres = Vundef). *)
+(*     destruct (fn_return f); auto || contradiction. *)
+(*   destruct H7 as [P Q]. subst vres. right; eapply step_skip_call; eauto. *)
+(*   (* Out_return None *) *)
+(*   assert (fn_return f = Tvoid /\ vres = Vundef). *)
+(*     destruct (fn_return f); auto || contradiction. *)
+(*   destruct H8 as [P Q]. subst vres. *)
+(*   rewrite <- (is_call_cont_call_cont k H6). rewrite <- H7. *)
+(*   right; apply step_return_0; auto. *)
+(*   (* Out_return Some *) *)
+(*   destruct H4. rewrite <- (is_call_cont_call_cont k H6). rewrite <- H7. *)
+(*   right; eapply step_return_2; eauto. *)
+(*   reflexivity. traceEq. *)
+
+(* (* call external *) *)
+(*   apply star_one. right; apply step_external_function; auto. *)
+(* Qed. *)
+
+(* Lemma eval_expression_to_steps: *)
+(*    forall e m a t m' v, *)
+(*    eval_expression e m a t m' v -> *)
+(*    forall f k, *)
+(*    star step ge (ExprState f a k e m) t (ExprState f (Eval v (typeof a)) k e m'). *)
+(* Proof (proj1 bigstep_to_steps). *)
+
+(* Lemma eval_expr_to_steps: *)
+(*    forall e m K a t m' a', *)
+(*    eval_expr e m K a t m' a' -> *)
+(*    forall C f k, leftcontext K RV C -> *)
+(*    simple a' = true /\ typeof a' = typeof a /\ *)
+(*    star step ge (ExprState f (C a) k e m) t (ExprState f (C a') k e m'). *)
+(* Proof (proj1 (proj2 bigstep_to_steps)). *)
+
+(* Lemma eval_exprlist_to_steps: *)
+(*    forall e m al t m' al', *)
+(*    eval_exprlist e m al t m' al' -> *)
+(*    forall a1 al2 ty C f k, leftcontext RV RV C -> simple a1 = true -> simplelist al2 = true -> *)
+(*    simplelist al' = true /\ *)
+(*    star step ge (ExprState f (C (Ecall a1 (exprlist_app al2 al) ty)) k e m) *)
+(*               t (ExprState f (C (Ecall a1 (exprlist_app al2 al') ty)) k e m'). *)
+(* Proof (proj1 (proj2 (proj2 bigstep_to_steps))). *)
+
+(* Lemma exec_stmt_to_steps: *)
+(*    forall e m s t m' out, *)
+(*    exec_stmt e m s t m' out -> *)
+(*    forall f k, *)
+(*    exists S, *)
+(*    star step ge (State f s k e m) t S /\ outcome_state_match e m' f k out S. *)
+(* Proof (proj1 (proj2 (proj2 (proj2 bigstep_to_steps)))). *)
+
+(* Lemma eval_funcall_to_steps: *)
+(*   forall m fd args t m' res, *)
+(*   eval_funcall m fd args t m' res -> *)
+(*   forall k, *)
+(*   is_call_cont k -> *)
+(*   star step ge (Callstate fd args k m) t (Returnstate res k m'). *)
+(* Proof (proj2 (proj2 (proj2 (proj2 bigstep_to_steps)))). *)
+
+(* Fixpoint esize (a: expr) : nat := *)
+(*   match a with *)
+(*   | Eloc _ _ _ => 1%nat *)
+(*   | Evar _ _ => 1%nat *)
+(*   | Ederef r1 _ => S(esize r1) *)
+(*   | Efield l1 _ _ => S(esize l1) *)
+(*   | Eval _ _ => O *)
+(*   | Evalof l1 _ => S(esize l1) *)
+(*   | Eaddrof l1 _ => S(esize l1) *)
+(*   | Eunop _ r1 _ => S(esize r1) *)
+(*   | Ebinop _ r1 r2 _ => S(esize r1 + esize r2)%nat *)
+(*   | Ecast r1 _ => S(esize r1) *)
+(*   | Eseqand r1 r2 _ => S(esize r1) *)
+(*   | Eseqor r1 r2 _ => S(esize r1) *)
+(*   | Econdition r1 _ _ _ => S(esize r1) *)
+(*   | Esizeof _ _ => 1%nat *)
+(*   | Ealignof _ _ => 1%nat *)
+(*   | Eassign l1 r2 _ => S(esize l1 + esize r2)%nat *)
+(*   | Eassignop _ l1 r2 _ _ => S(esize l1 + esize r2)%nat *)
+(*   | Epostincr _ l1 _ => S(esize l1) *)
+(*   | Ecomma r1 r2 _ => S(esize r1 + esize r2)%nat *)
+(*   | Ecall r1 rl2 _ => S(esize r1 + esizelist rl2)%nat *)
+(*   | Ebuiltin ef tyargs rl _ => S(esizelist rl) *)
+(*   | Eparen r1 _ _ => S(esize r1) *)
+(*   end *)
+
+(* with esizelist (el: exprlist) : nat := *)
+(*   match el with *)
+(*   | Enil => O *)
+(*   | Econs r1 rl2 => S(esize r1 + esizelist rl2)%nat *)
+(*   end. *)
+
+(* Lemma leftcontext_size: *)
+(*   forall from to C, *)
+(*   leftcontext from to C -> *)
+(*   forall e1 e2, *)
+(*   (esize e1 < esize e2)%nat -> *)
+(*   (esize (C e1) < esize (C e2))%nat *)
+(* with leftcontextlist_size: *)
+(*   forall from C, *)
+(*   leftcontextlist from C -> *)
+(*   forall e1 e2, *)
+(*   (esize e1 < esize e2)%nat -> *)
+(*   (esizelist (C e1) < esizelist (C e2))%nat. *)
+(* Proof. *)
+(*   induction 1; intros; simpl; auto with arith. *)
+(*   exploit leftcontextlist_size; eauto. auto with arith. *)
+(*   exploit leftcontextlist_size; eauto. auto with arith. *)
+(*   induction 1; intros; simpl; auto with arith. *)
+(*   exploit leftcontext_size; eauto. auto with arith. *)
+(* Qed. *)
+
+(* Lemma evalinf_funcall_steps: *)
+(*   forall m fd args t k, *)
+(*   evalinf_funcall m fd args t -> *)
+(*   forever_N step lt ge O (Callstate fd args k m) t. *)
+(* Proof. *)
+(*   cofix COF. *)
+
+(*   assert (COS: *)
+(*     forall e m s t f k, *)
+(*     execinf_stmt e m s t -> *)
+(*     forever_N step lt ge O (State f s k e m) t). *)
+(*   cofix COS. *)
+
+(*   assert (COE: *)
+(*     forall e m K a t C f k, *)
+(*     evalinf_expr e m K a t -> *)
+(*     leftcontext K RV C -> *)
+(*     forever_N step lt ge (esize a) (ExprState f (C a) k e m) t). *)
+(*   cofix COE. *)
+
+(*   assert (COEL: *)
+(*     forall e m a t C f k a1 al ty, *)
+(*     evalinf_exprlist e m a t -> *)
+(*     leftcontext RV RV C -> simple a1 = true -> simplelist al = true -> *)
+(*     forever_N step lt ge (esizelist a) *)
+(*                    (ExprState f (C (Ecall a1 (exprlist_app al a) ty)) k e m) t). *)
+(*   cofix COEL. *)
+(*   intros. inv H. *)
+(* (* cons left *) *)
+(*   eapply forever_N_star with (a2 := (esize a0)). apply star_refl. simpl; lia. *)
+(*   eapply COE with (C := fun x => C(Ecall a1 (exprlist_app al (Econs x al0)) ty)). *)
+(*   eauto. eapply leftcontext_compose; eauto. constructor. auto. *)
+(*   apply exprlist_app_leftcontext; auto. traceEq. *)
+(* (* cons right *) *)
+(*   destruct (eval_expr_to_steps _ _ _ _ _ _ _ H3 *)
+(*              (fun x => C(Ecall a1 (exprlist_app al (Econs x al0)) ty)) f k) *)
+(*   as [P [Q R]]. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. auto. *)
+(*   apply exprlist_app_leftcontext; auto. *)
+(*   eapply forever_N_star with (a2 := (esizelist al0)). *)
+(*   eexact R. simpl; lia. *)
+(*   change (Econs a1' al0) with (exprlist_app (Econs a1' Enil) al0). *)
+(*   rewrite <- exprlist_app_assoc. *)
+(*   eapply COEL. eauto. auto. auto. *)
+(*   rewrite exprlist_app_simple. simpl. rewrite H2; rewrite P; auto. *)
+(*   auto. *)
+
+(*   intros. inv H. *)
+(* (* field *) *)
+(*   eapply forever_N_star with (a2 := (esize a0)). apply star_refl. simpl; lia. *)
+(*   eapply COE with (C := fun x => C(Efield x f0 ty)). eauto. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. traceEq. *)
+(* (* valof *) *)
+(*   eapply forever_N_star with (a2 := (esize a0)). apply star_refl. simpl; lia. *)
+(*   eapply COE with (C := fun x => C(Evalof x ty)). eauto. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. traceEq. *)
+(* (* deref *) *)
+(*   eapply forever_N_star with (a2 := (esize a0)). apply star_refl. simpl; lia. *)
+(*   eapply COE with (C := fun x => C(Ederef x ty)). eauto. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. traceEq. *)
+(* (* addrof *) *)
+(*   eapply forever_N_star with (a2 := (esize a0)). apply star_refl. simpl; lia. *)
+(*   eapply COE with (C := fun x => C(Eaddrof x ty)). eauto. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. traceEq. *)
+(* (* unop *) *)
+(*   eapply forever_N_star with (a2 := (esize a0)). apply star_refl. simpl; lia. *)
+(*   eapply COE with (C := fun x => C(Eunop op x ty)). eauto. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. traceEq. *)
+(* (* binop left *) *)
+(*   eapply forever_N_star with (a2 := (esize a1)). apply star_refl. simpl; lia. *)
+(*   eapply COE with (C := fun x => C(Ebinop op x a2 ty)). eauto. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. traceEq. *)
+(* (* binop right *) *)
+(*   destruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ebinop op x a2 ty)) f k) *)
+(*   as [P [Q R]]. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. *)
+(*   eapply forever_N_star with (a2 := (esize a2)). eexact R. simpl; lia. *)
+(*   eapply COE with (C := fun x => C(Ebinop op a1' x ty)). eauto. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. auto. traceEq. *)
+(* (* cast *) *)
+(*   eapply forever_N_star with (a2 := (esize a0)). apply star_refl. simpl; lia. *)
+(*   eapply COE with (C := fun x => C(Ecast x ty)). eauto. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. traceEq. *)
+(* (* seqand left *) *)
+(*   eapply forever_N_star with (a2 := (esize a1)). apply star_refl. simpl; lia. *)
+(*   eapply COE with (C := fun x => C(Eseqand x a2 ty)). eauto. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. traceEq. *)
+(* (* seqand 2 *) *)
+(*   destruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eseqand x a2 ty)) f k) *)
+(*   as [P [Q R]]. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. *)
+(*   eapply forever_N_plus. eapply plus_right. eexact R. *)
+(*   left; eapply step_seqand_true; eauto. rewrite Q; eauto. *)
+(*   reflexivity. *)
+(*   eapply COE with (C := fun x => (C (Eparen x type_bool ty))). eauto. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. traceEq. *)
+(* (* seqor left *) *)
+(*   eapply forever_N_star with (a2 := (esize a1)). apply star_refl. simpl; lia. *)
+(*   eapply COE with (C := fun x => C(Eseqor x a2 ty)). eauto. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. traceEq. *)
+(* (* seqor 2 *) *)
+(*   destruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eseqor x a2 ty)) f k) *)
+(*   as [P [Q R]]. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. *)
+(*   eapply forever_N_plus. eapply plus_right. eexact R. *)
+(*   left; eapply step_seqor_false; eauto. rewrite Q; eauto. *)
+(*   reflexivity. *)
+(*   eapply COE with (C := fun x => (C (Eparen x type_bool ty))). eauto. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. traceEq. *)
+(* (* condition top *) *)
+(*   eapply forever_N_star with (a2 := (esize a1)). apply star_refl. simpl; lia. *)
+(*   eapply COE with (C := fun x => C(Econdition x a2 a3 ty)). eauto. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. traceEq. *)
+(* (* condition *) *)
+(*   destruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Econdition x a2 a3 ty)) f k) *)
+(*   as [P [Q R]]. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. *)
+(*   eapply forever_N_plus. eapply plus_right. eexact R. *)
+(*   left; eapply step_condition; eauto. rewrite Q; eauto. *)
+(*   reflexivity. *)
+(*   eapply COE with (C := fun x => (C (Eparen x ty ty))). eauto. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. traceEq. *)
+(* (* assign left *) *)
+(*   eapply forever_N_star with (a2 := (esize a1)). apply star_refl. simpl; lia. *)
+(*   eapply COE with (C := fun x => C(Eassign x a2 ty)). eauto. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. traceEq. *)
+(* (* assign right *) *)
+(*   destruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eassign x a2 ty)) f k) *)
+(*   as [P [Q R]]. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. *)
+(*   eapply forever_N_star with (a2 := (esize a2)). eexact R. simpl; lia. *)
+(*   eapply COE with (C := fun x => C(Eassign a1' x ty)). eauto. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. auto. traceEq. *)
+(* (* assignop left *) *)
+(*   eapply forever_N_star with (a2 := (esize a1)). apply star_refl. simpl; lia. *)
+(*   eapply COE with (C := fun x => C(Eassignop op x a2 tyres ty)). eauto. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. traceEq. *)
+(* (* assignop right *) *)
+(*   destruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Eassignop op x a2 tyres ty)) f k) *)
+(*   as [P [Q R]]. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. *)
+(*   eapply forever_N_star with (a2 := (esize a2)). eexact R. simpl; lia. *)
+(*   eapply COE with (C := fun x => C(Eassignop op a1' x tyres ty)). eauto. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. auto. traceEq. *)
+(* (* postincr *) *)
+(*   eapply forever_N_star with (a2 := (esize a0)). apply star_refl. simpl; lia. *)
+(*   eapply COE with (C := fun x => C(Epostincr id x ty)). eauto. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. traceEq. *)
+(* (* comma left *) *)
+(*   eapply forever_N_star with (a2 := (esize a1)). apply star_refl. simpl; lia. *)
+(*   eapply COE with (C := fun x => C(Ecomma x a2 ty)). eauto. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. traceEq. *)
+(* (* comma right *) *)
+(*   destruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecomma x a2 (typeof a2))) f k) *)
+(*   as [P [Q R]]. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. *)
+(*   eapply forever_N_plus. eapply plus_right. eexact R. *)
+(*   left; eapply step_comma; eauto. reflexivity. *)
+(*   eapply COE with (C := C); eauto. traceEq. *)
+(* (* call left *) *)
+(*   eapply forever_N_star with (a2 := (esize a1)). apply star_refl. simpl; lia. *)
+(*   eapply COE with (C := fun x => C(Ecall x a2 ty)). eauto. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. traceEq. *)
+(* (* call right *) *)
+(*   destruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecall x a2 ty)) f k) *)
+(*   as [P [Q R]]. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. *)
+(*   eapply forever_N_star with (a2 := (esizelist a2)). eexact R. simpl; lia. *)
+(*   eapply COEL with (al := Enil). eauto. auto. auto. auto. traceEq. *)
+(* (* call *) *)
+(*   destruct (eval_expr_to_steps _ _ _ _ _ _ _ H1 (fun x => C(Ecall x rargs ty)) f k) *)
+(*   as [P [Q R]]. *)
+(*   eapply leftcontext_compose; eauto. repeat constructor. *)
+(*   destruct (eval_exprlist_to_steps _ _ _ _ _ _ H2 rf' Enil ty C f k) *)
+(*   as [S T]. auto. auto. simpl; auto. *)
+(*   eapply forever_N_plus. eapply plus_right. *)
+(*   eapply star_trans. eexact R. eexact T. reflexivity. *)
+(*   simpl. left; eapply step_call; eauto. congruence. reflexivity. *)
+(*   apply COF. eauto. traceEq. *)
+
+(* (* statements *) *)
+(*   intros. inv H. *)
+(* (* do *) *)
+(*   eapply forever_N_plus. apply plus_one; right; constructor. *)
+(*   eapply COE with (C := fun x => x); eauto. constructor. traceEq. *)
+(* (* seq 1 *) *)
+(*   eapply forever_N_plus. apply plus_one; right; constructor. *)
+(*   eapply COS; eauto. traceEq. *)
+(* (* seq 2 *) *)
+(*   destruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kseq s2 k)) as [S1 [A1 B1]]; auto. inv B1. *)
+(*   eapply forever_N_plus. *)
+(*   eapply plus_left. right; constructor. *)
+(*   eapply star_right. eauto. right; constructor. *)
+(*   reflexivity. reflexivity. *)
+(*   eapply COS; eauto. traceEq. *)
+(* (* if test *) *)
+(*   eapply forever_N_plus. apply plus_one; right; constructor. *)
+(*   eapply COE with (C := fun x => x); eauto. constructor. traceEq. *)
+(* (* if true/false *) *)
+(*   eapply forever_N_plus. *)
+(*   eapply plus_left. right; constructor. *)
+(*   eapply star_right. eapply eval_expression_to_steps; eauto. *)
+(*   right. eapply step_ifthenelse_2 with (b := b). auto. *)
+(*   reflexivity. reflexivity. *)
+(*   eapply COS; eauto. traceEq. *)
+(* (* return some *) *)
+(*   eapply forever_N_plus. apply plus_one; right; constructor. *)
+(*   eapply COE with (C := fun x => x); eauto. constructor. traceEq. *)
+(* (* while test *) *)
+(*   eapply forever_N_plus. apply plus_one; right; constructor. *)
+(*   eapply COE with (C := fun x => x); eauto. constructor. traceEq. *)
+(* (* while body *) *)
+(*   eapply forever_N_plus. *)
+(*   eapply plus_left. right; constructor. *)
+(*   eapply star_right. eapply eval_expression_to_steps; eauto. *)
+(*   right; apply step_while_true; auto. *)
+(*   reflexivity. reflexivity. *)
+(*   eapply COS; eauto. traceEq. *)
+(* (* while loop *) *)
+(*   destruct (exec_stmt_to_steps _ _ _ _ _ _ H2 f (Kwhile2 a s0 k)) as [S1 [A1 B1]]; auto. *)
+(*   eapply forever_N_plus. *)
+(*   eapply plus_left. right; constructor. *)
+(*   eapply star_trans. eapply eval_expression_to_steps; eauto. *)
+(*   eapply star_left. right; apply step_while_true; auto. *)
+(*   eapply star_trans. eexact A1. *)
+(*   inv H3; inv B1; apply star_one; right; apply step_skip_or_continue_while; auto. *)
+(*   reflexivity. reflexivity. reflexivity. reflexivity. *)
+(*   eapply COS; eauto. traceEq. *)
+(* (* dowhile body *) *)
+(*   eapply forever_N_plus. apply plus_one; right; constructor. *)
+(*   eapply COS; eauto. traceEq. *)
+(* (* dowhile test *) *)
+(*   destruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kdowhile1 a s0 k)) as [S1 [A1 B1]]; auto. *)
+(*   eapply forever_N_plus. *)
+(*   eapply plus_left. right; constructor. *)
+(*   eapply star_trans. eexact A1. *)
+(*   eapply star_one. right. inv H1; inv B1; apply step_skip_or_continue_dowhile; auto. *)
+(*   reflexivity. reflexivity. *)
+(*   eapply COE with (C := fun x => x); eauto. constructor. traceEq. *)
+(* (* dowhile loop *) *)
+(*   destruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kdowhile1 a s0 k)) as [S1 [A1 B1]]; auto. *)
+(*   eapply forever_N_plus. *)
+(*   eapply plus_left. right; constructor. *)
+(*   eapply star_trans. eexact A1. *)
+(*   eapply star_left. right. inv H1; inv B1; apply step_skip_or_continue_dowhile; auto. *)
+(*   eapply star_right. eapply eval_expression_to_steps; eauto. *)
+(*   right; apply step_dowhile_true; auto. *)
+(*   reflexivity. reflexivity. reflexivity. reflexivity. *)
+(*   eapply COS; eauto. traceEq. *)
+(* (* for start 1 *) *)
+(*   assert (a1 <> Sskip). red; intros; subst a1; inv H0. *)
+(*   eapply forever_N_plus. apply plus_one. right. constructor. auto. *)
+(*   eapply COS; eauto. traceEq. *)
+(* (* for start 2 *) *)
+(*   destruct (exec_stmt_to_steps _ _ _ _ _ _ H0 f (Kseq (Sfor Sskip a2 a3 s0) k)) as [S1 [A1 B1]]; auto. inv B1. *)
+(*   eapply forever_N_plus. *)
+(*   eapply plus_left. right; constructor. auto. *)
+(*   eapply star_trans. eexact A1. *)
+(*   apply star_one. right; constructor. *)
+(*   reflexivity. reflexivity. *)
+(*   eapply COS; eauto. traceEq. *)
+(* (* for test *) *)
+(*   eapply forever_N_plus. apply plus_one; right; apply step_for. *)
+(*   eapply COE with (C := fun x => x); eauto. constructor. traceEq. *)
+(* (* for body *) *)
+(*   eapply forever_N_plus. *)
+(*   eapply plus_left. right; apply step_for. *)
+(*   eapply star_right. eapply eval_expression_to_steps; eauto. *)
+(*   right; apply step_for_true; auto. *)
+(*   reflexivity. reflexivity. *)
+(*   eapply COS; eauto. traceEq. *)
+(* (* for next *) *)
+(*   destruct (exec_stmt_to_steps _ _ _ _ _ _ H2 f (Kfor3 a2 a3 s0 k)) as [S1 [A1 B1]]; auto. *)
+(*   eapply forever_N_plus. *)
+(*   eapply plus_left. right; apply step_for. *)
+(*   eapply star_trans. eapply eval_expression_to_steps; eauto. *)
+(*   eapply star_left. right; apply step_for_true; auto. *)
+(*   eapply star_trans. eexact A1. *)
+(*   inv H3; inv B1; apply star_one; right; apply step_skip_or_continue_for3; auto. *)
+(*   reflexivity. reflexivity. reflexivity. reflexivity. *)
+(*   eapply COS; eauto. traceEq. *)
+(* (* for loop *) *)
+(*   destruct (exec_stmt_to_steps _ _ _ _ _ _ H2 f (Kfor3 a2 a3 s0 k)) as [S1 [A1 B1]]; auto. *)
+(*   destruct (exec_stmt_to_steps _ _ _ _ _ _ H4 f (Kfor4 a2 a3 s0 k)) as [S2 [A2 B2]]; auto. inv B2. *)
+(*   eapply forever_N_plus. *)
+(*   eapply plus_left. right; apply step_for. *)
+(*   eapply star_trans. eapply eval_expression_to_steps; eauto. *)
+(*   eapply star_left. right; apply step_for_true; auto. *)
+(*   eapply star_trans. eexact A1. *)
+(*   eapply star_left. *)
+(*   inv H3; inv B1; right; apply step_skip_or_continue_for3; auto. *)
+(*   eapply star_right. eexact A2. *)
+(*   right; constructor. *)
+(*   reflexivity. reflexivity. reflexivity. reflexivity. reflexivity. reflexivity. *)
+(*   eapply COS; eauto. traceEq. *)
+(* (* switch expr *) *)
+(*   eapply forever_N_plus. apply plus_one; right; constructor. *)
+(*   eapply COE with (C := fun x => x); eauto. constructor. traceEq. *)
+(* (* switch body *) *)
+(*   eapply forever_N_plus. *)
+(*   eapply plus_left. right; constructor. *)
+(*   eapply star_right. eapply eval_expression_to_steps; eauto. *)
+(*   right; constructor. eauto. *)
+(*   reflexivity. reflexivity. *)
+(*   eapply COS; eauto. traceEq. *)
+
+(* (* funcalls *) *)
+(*   intros. inv H. *)
+(*   eapply forever_N_plus. apply plus_one. right; econstructor; eauto. *)
+(*   eapply COS; eauto. traceEq. *)
+(* Qed. *)
+
+(* End BIGSTEP. *)
+
+(* (** ** Whole-program behaviors, big-step style. *) *)
+
+(* Inductive bigstep_program_terminates (p: program): trace -> int -> Prop := *)
+(*   | bigstep_program_terminates_intro: forall b f m0 m1 t r, *)
+(*       let ge := globalenv p in *)
+(*       Genv.init_mem p = Some m0 -> *)
+(*       Genv.find_symbol ge p.(prog_main) = Some b -> *)
+(*       Genv.find_funct_ptr ge b = Some f -> *)
+(*       type_of_fundef f = Tfunction Tnil type_int32s cc_default -> *)
+(*       eval_funcall ge m0 f nil t m1 (Vint r) -> *)
+(*       bigstep_program_terminates p t r. *)
+
+(* Inductive bigstep_program_diverges (p: program): traceinf -> Prop := *)
+(*   | bigstep_program_diverges_intro: forall b f m0 t, *)
+(*       let ge := globalenv p in *)
+(*       Genv.init_mem p = Some m0 -> *)
+(*       Genv.find_symbol ge p.(prog_main) = Some b -> *)
+(*       Genv.find_funct_ptr ge b = Some f -> *)
+(*       type_of_fundef f = Tfunction Tnil type_int32s cc_default -> *)
+(*       evalinf_funcall ge m0 f nil t -> *)
+(*       bigstep_program_diverges p t. *)
+
+(* Definition bigstep_semantics (p: program) := *)
+(*   Bigstep_semantics (bigstep_program_terminates p) (bigstep_program_diverges p). *)
+
+(* Theorem bigstep_semantics_sound: *)
+(*   forall p, bigstep_sound (bigstep_semantics p) (semantics p). *)
+(* Proof. *)
+(*   intros; constructor; intros. *)
+(* (* termination *) *)
+(*   inv H. econstructor; econstructor. *)
+(*   split. econstructor; eauto. *)
+(*   split. apply eval_funcall_to_steps. eauto. red; auto. *)
+(*   econstructor. *)
+(* (* divergence *) *)
+(*   inv H. econstructor. *)
+(*   split. econstructor; eauto. *)
+(*   eapply forever_N_forever with (order := lt). *)
+(*   apply lt_wf. *)
+(*   eapply evalinf_funcall_steps; eauto. *)
+(* Qed. *)
diff --git a/cfrontend/Ctyping.v b/cfrontend/Ctyping.v
index 5f0a3e5b..abde3927 100644
--- a/cfrontend/Ctyping.v
+++ b/cfrontend/Ctyping.v
@@ -1525,8 +1525,12 @@ Proof with (try discriminate).
   {
     intros ob EQ. destruct ob as [b|]; inv EQ. eauto.
   }
+  assert (Z: forall v1 v2, cmp_ptr m c v1 v2 = Some v -> wt_val v (Tint I32 Signed noattr)).
+  {
+    unfold cmp_ptr. ii. clear - Y H1. des_ifs; eauto.
+  }
   destruct (classify_cmp ty1 ty2).
-- inv H; eauto.
+ - inv H; eauto.
 - DestructCases; eauto.
 - DestructCases; eauto.
 - DestructCases; eauto.
@@ -1663,6 +1667,7 @@ Lemma wt_deref_loc:
 Proof.
   induction 1.
 - (* by value, non volatile *)
+  unfold Mem.loadv in H1.
   simpl in H1. exploit Mem.load_result; eauto. intros EQ; rewrite EQ.
   apply wt_decode_val; auto.
 - (* by value, volatile *)
diff --git a/cfrontend/Initializersproof.v b/cfrontend/Initializersproof.v
index 10ccbeff..26ba00ee 100644
--- a/cfrontend/Initializersproof.v
+++ b/cfrontend/Initializersproof.v
@@ -19,877 +19,877 @@ Require Import Initializers.
 
 Open Scope error_monad_scope.
 
-Section SOUNDNESS.
-
-Variable ge: genv.
-
-(** * Simple expressions and their big-step semantics *)
-
-(** An expression is simple if it contains no assignments and no
-  function calls. *)
-
-Fixpoint simple (a: expr) : Prop :=
-  match a with
-  | Eloc _ _ _ => True
-  | Evar _ _ => True
-  | Ederef r _ => simple r
-  | Efield l1 _ _ => simple l1
-  | Eval _ _ => True
-  | Evalof l _ => simple l
-  | Eaddrof l _ => simple l
-  | Eunop _ r1 _ => simple r1
-  | Ebinop _ r1 r2 _ => simple r1 /\ simple r2
-  | Ecast r1 _ => simple r1
-  | Eseqand r1 r2 _ => simple r1 /\ simple r2
-  | Eseqor r1 r2 _ => simple r1 /\ simple r2
-  | Econdition r1 r2 r3 _ => simple r1 /\ simple r2 /\ simple r3
-  | Esizeof _ _ => True
-  | Ealignof _ _ => True
-  | Eassign _ _ _ => False
-  | Eassignop _ _ _ _ _ => False
-  | Epostincr _ _ _ => False
-  | Ecomma r1 r2 _ => simple r1 /\ simple r2
-  | Ecall _ _ _ => False
-  | Ebuiltin _ _ _ _ => False
-  | Eparen r1 _ _ => simple r1
-  end.
-
-(** A big-step semantics for simple expressions.  Similar to the
-  big-step semantics from [Cstrategy], with the addition of
-  conditionals, comma and paren operators.  It is a pity we do not
-  share definitions with [Cstrategy], but such sharing raises
-  technical difficulties. *)
-
-Section SIMPLE_EXPRS.
-
-Variable e: env.
-Variable m: mem.
-
-Inductive eval_simple_lvalue: expr -> block -> ptrofs -> Prop :=
-  | esl_loc: forall b ofs ty,
-      eval_simple_lvalue (Eloc b ofs ty) b ofs
-  | esl_var_local: forall x ty b,
-      e!x = Some(b, ty) ->
-      eval_simple_lvalue (Evar x ty) b Ptrofs.zero
-  | esl_var_global: forall x ty b,
-      e!x = None ->
-      Genv.find_symbol ge x = Some b ->
-      eval_simple_lvalue (Evar x ty) b Ptrofs.zero
-  | esl_deref: forall r ty b ofs,
-      eval_simple_rvalue r (Vptr b ofs) ->
-      eval_simple_lvalue (Ederef r ty) b ofs
-  | esl_field_struct: forall r f ty b ofs id co a delta,
-      eval_simple_rvalue r (Vptr b ofs) ->
-      typeof r = Tstruct id a -> ge.(genv_cenv)!id = Some co -> field_offset ge f (co_members co) = OK delta ->
-      eval_simple_lvalue (Efield r f ty) b (Ptrofs.add ofs (Ptrofs.repr delta))
-  | esl_field_union: forall r f ty b ofs id a,
-      eval_simple_rvalue r (Vptr b ofs) ->
-      typeof r = Tunion id a ->
-      eval_simple_lvalue (Efield r f ty) b ofs
-
-with eval_simple_rvalue: expr -> val -> Prop :=
-  | esr_val: forall v ty,
-      eval_simple_rvalue (Eval v ty) v
-  | esr_rvalof: forall b ofs l ty v,
-      eval_simple_lvalue l b ofs ->
-      ty = typeof l ->
-      deref_loc ge ty m b ofs E0 v ->
-      eval_simple_rvalue (Evalof l ty) v
-  | esr_addrof: forall b ofs l ty,
-      eval_simple_lvalue l b ofs ->
-      eval_simple_rvalue (Eaddrof l ty) (Vptr b ofs)
-  | esr_unop: forall op r1 ty v1 v,
-      eval_simple_rvalue r1 v1 ->
-      sem_unary_operation op v1 (typeof r1) m = Some v ->
-      eval_simple_rvalue (Eunop op r1 ty) v
-  | esr_binop: forall op r1 r2 ty v1 v2 v,
-      eval_simple_rvalue r1 v1 -> eval_simple_rvalue r2 v2 ->
-      sem_binary_operation ge op v1 (typeof r1) v2 (typeof r2) m = Some v ->
-      eval_simple_rvalue (Ebinop op r1 r2 ty) v
-  | esr_cast: forall ty r1 v1 v,
-      eval_simple_rvalue r1 v1 ->
-      sem_cast v1 (typeof r1) ty m = Some v ->
-      eval_simple_rvalue (Ecast r1 ty) v
-  | esr_sizeof: forall ty1 ty,
-      eval_simple_rvalue (Esizeof ty1 ty) (Vptrofs (Ptrofs.repr (sizeof ge ty1)))
-  | esr_alignof: forall ty1 ty,
-      eval_simple_rvalue (Ealignof ty1 ty) (Vptrofs (Ptrofs.repr (alignof ge ty1)))
-  | esr_seqand_true: forall r1 r2 ty v1 v2 v3,
-      eval_simple_rvalue r1 v1 -> bool_val v1 (typeof r1) m = Some true ->
-      eval_simple_rvalue r2 v2 ->
-      sem_cast v2 (typeof r2) type_bool m = Some v3 ->
-      eval_simple_rvalue (Eseqand r1 r2 ty) v3
-  | esr_seqand_false: forall r1 r2 ty v1,
-      eval_simple_rvalue r1 v1 -> bool_val v1 (typeof r1) m = Some false ->
-      eval_simple_rvalue (Eseqand r1 r2 ty) (Vint Int.zero)
-  | esr_seqor_false: forall r1 r2 ty v1 v2 v3,
-      eval_simple_rvalue r1 v1 -> bool_val v1 (typeof r1) m = Some false ->
-      eval_simple_rvalue r2 v2 ->
-      sem_cast v2 (typeof r2) type_bool m = Some v3 ->
-      eval_simple_rvalue (Eseqor r1 r2 ty) v3
-  | esr_seqor_true: forall r1 r2 ty v1,
-      eval_simple_rvalue r1 v1 -> bool_val v1 (typeof r1) m = Some true ->
-      eval_simple_rvalue (Eseqor r1 r2 ty) (Vint Int.one)
-  | esr_condition: forall r1 r2 r3 ty v v1 b v',
-      eval_simple_rvalue r1 v1 -> bool_val v1 (typeof r1) m = Some b ->
-      eval_simple_rvalue (if b then r2 else r3) v' ->
-      sem_cast v' (typeof (if b then r2 else r3)) ty m = Some v ->
-      eval_simple_rvalue (Econdition r1 r2 r3 ty) v
-  | esr_comma: forall r1 r2 ty v1 v,
-      eval_simple_rvalue r1 v1 -> eval_simple_rvalue r2 v ->
-      eval_simple_rvalue (Ecomma r1 r2 ty) v
-  | esr_paren: forall r tycast ty v v',
-      eval_simple_rvalue r v -> sem_cast v (typeof r) tycast m = Some v' ->
-      eval_simple_rvalue (Eparen r tycast ty) v'.
-
-End SIMPLE_EXPRS.
-
-(** * Correctness of the big-step semantics with respect to reduction sequences *)
-
-(** In this section, we show that if a simple expression [a] reduces to
-  some value (with the transition semantics from module [Csem]),
-  then it evaluates to this value (with the big-step semantics above). *)
-
-Definition compat_eval (k: kind) (e: env) (a a': expr) (m: mem) : Prop :=
-  typeof a = typeof a' /\
-  match k with
-  | LV => forall b ofs, eval_simple_lvalue e m a' b ofs -> eval_simple_lvalue e m a b ofs
-  | RV => forall v, eval_simple_rvalue e m a' v -> eval_simple_rvalue e m a v
-  end.
-
-Lemma lred_simple:
-  forall e l m l' m', lred ge e l m l' m' -> simple l -> simple l'.
-Proof.
-  induction 1; simpl; tauto.
-Qed.
-
-Lemma lred_compat:
-  forall e l m l' m', lred ge e l m l' m' ->
-  m = m' /\ compat_eval LV e l l' m.
-Proof.
-  induction 1; simpl; split; auto; split; auto; intros bx ofsx EV; inv EV.
-  apply esl_var_local; auto.
-  apply esl_var_global; auto.
-  constructor. constructor.
-  eapply esl_field_struct; eauto. constructor. simpl; eauto.
-  eapply esl_field_union; eauto. constructor. simpl; eauto.
-Qed.
-
-Lemma rred_simple:
-  forall r m t r' m', rred ge r m t r' m' -> simple r -> simple r'.
-Proof.
-  induction 1; simpl; intuition. destruct b; auto.
-Qed.
-
-Lemma rred_compat:
-  forall e r m r' m', rred ge r m E0 r' m' ->
-  simple r ->
-  m = m' /\ compat_eval RV e r r' m.
-Proof.
-  intros until m'; intros RED SIMP. inv RED; simpl in SIMP; try contradiction; split; auto; split; auto; intros vx EV.
-  inv EV. econstructor. constructor. auto. auto.
-  inv EV. econstructor. constructor.
-  inv EV. econstructor; eauto. constructor.
-  inv EV. econstructor; eauto. constructor. constructor.
-  inv EV. econstructor; eauto. constructor.
-  inv EV. eapply esr_seqand_true; eauto. constructor.
-  inv EV. eapply esr_seqand_false; eauto. constructor.
-  inv EV. eapply esr_seqor_true; eauto. constructor.
-  inv EV. eapply esr_seqor_false; eauto. constructor.
-  inv EV. eapply esr_condition; eauto. constructor.
-  inv EV. constructor.
-  inv EV. constructor.
-  econstructor; eauto. constructor.
-  inv EV. econstructor. constructor. auto.
-Qed.
-
-Lemma compat_eval_context:
-  forall e a a' m from to C,
-  context from to C ->
-  compat_eval from e a a' m ->
-  compat_eval to e (C a) (C a') m.
-Proof.
-  induction 1; intros CE; auto;
-  try (generalize (IHcontext CE); intros [TY EV]; red; split; simpl; auto; intros).
-  inv H0. constructor; auto.
-  inv H0.
-    eapply esl_field_struct; eauto. rewrite TY; eauto.
-    eapply esl_field_union; eauto. rewrite TY; eauto.
-  inv H0. econstructor. eauto. auto. auto.
-  inv H0. econstructor; eauto.
-  inv H0. econstructor; eauto. congruence.
-  inv H0. econstructor; eauto. congruence.
-  inv H0. econstructor; eauto. congruence.
-  inv H0. econstructor; eauto. congruence.
-  inv H0.
-    eapply esr_seqand_true; eauto. rewrite TY; auto.
-    eapply esr_seqand_false; eauto. rewrite TY; auto.
-  inv H0.
-    eapply esr_seqor_false; eauto. rewrite TY; auto.
-    eapply esr_seqor_true; eauto. rewrite TY; auto.
-  inv H0. eapply esr_condition; eauto. congruence.
-  inv H0.
-  inv H0.
-  inv H0.
-  inv H0.
-  inv H0.
-  inv H0.
-  red; split; intros. auto. inv H0.
-  red; split; intros. auto. inv H0.
-  inv H0. econstructor; eauto.
-  inv H0. econstructor; eauto. congruence.
-Qed.
-
-Lemma simple_context_1:
-  forall a from to C, context from to C -> simple (C a) -> simple a.
-Proof.
-  induction 1; simpl; tauto.
-Qed.
-
-Lemma simple_context_2:
-  forall a a', simple a' -> forall from to C, context from to C -> simple (C a) -> simple (C a').
-Proof.
-  induction 2; simpl; try tauto.
-Qed.
-
-Lemma compat_eval_steps_aux f r e m r' m' s2 :
-  simple r ->
-  star step ge s2 nil (ExprState f r' Kstop e m') ->
-  estep ge (ExprState f r Kstop e m) nil s2 ->
-  exists r1,
-    s2 = ExprState f r1 Kstop e m /\
-    compat_eval RV e r r1 m /\ simple r1.
-Proof.
-  intros.
-  inv H1.
-  (* lred *)
-  assert (S: simple a) by (eapply simple_context_1; eauto).
-  exploit lred_compat; eauto. intros [A B]. subst m'0.
-  econstructor; split. eauto. split.
-  eapply compat_eval_context; eauto.
-  eapply simple_context_2; eauto. eapply lred_simple; eauto.
-  (* rred *)
-  assert (S: simple a) by (eapply simple_context_1; eauto).
-  exploit rred_compat; eauto. intros [A B]. subst m'0.
-  econstructor; split. eauto. split.
-  eapply compat_eval_context; eauto.
-  eapply simple_context_2; eauto. eapply rred_simple; eauto.
-  (* callred *)
-  assert (S: simple a) by (eapply simple_context_1; eauto).
-  inv H8; simpl in S; contradiction.
-  (* stuckred *)
-  inv H0. destruct H1; inv H0.
-Qed.
-
-Lemma compat_eval_steps:
-  forall f r e m  r' m',
-  star step ge (ExprState f r Kstop e m) E0 (ExprState f r' Kstop e m') ->
-  simple r ->
-  m' = m /\ compat_eval RV e r r' m.
-Proof.
-  intros.
-  remember (ExprState f r Kstop e m) as S1.
-  remember E0 as t.
-  remember (ExprState f r' Kstop e m') as S2.
-  revert S1 t S2 H r m r' m' HeqS1 Heqt HeqS2 H0.
-  induction 1; intros; subst.
-  (* base case *)
-  inv HeqS2. split. auto. red; auto.
-  (* inductive case *)
-  destruct (app_eq_nil t1 t2); auto. subst. inv H.
-  (* expression step *)
-  exploit compat_eval_steps_aux; eauto.
-  intros [r1 [A [B C]]]. subst s2.
-  exploit IHstar; eauto. intros [D E].
-  split. auto. destruct B; destruct E. split. congruence. auto.
-  (* statement steps *)
-  inv H1.
-Qed.
-
-Theorem eval_simple_steps:
-  forall f r e m v ty m',
-  star step ge (ExprState f r Kstop e m) E0 (ExprState f (Eval v ty) Kstop e m') ->
-  simple r ->
-  m' = m /\ ty = typeof r /\ eval_simple_rvalue e m r v.
-Proof.
-  intros. exploit compat_eval_steps; eauto. intros [A [B C]].
-  intuition. apply C. constructor.
-Qed.
-
-(** * Soundness of the compile-time evaluator *)
-
-(** A global environment [ge] induces a memory injection mapping
-  our symbolic pointers [Vptr id ofs] to run-time pointers
-  [Vptr b ofs] where [Genv.find_symbol ge id = Some b]. *)
-
-Definition inj (b: block) :=
-  match Genv.find_symbol ge b with
-  | Some b' => Some (b', 0)
-  | None => None
-  end.
-
-Lemma mem_empty_not_valid_pointer:
-  forall b ofs, Mem.valid_pointer Mem.empty b ofs = false.
-Proof.
-  intros. unfold Mem.valid_pointer. destruct (Mem.perm_dec Mem.empty b ofs Cur Nonempty); auto.
-  eelim Mem.perm_empty; eauto.
-Qed.
-
-Lemma mem_empty_not_weak_valid_pointer:
-  forall b ofs, Mem.weak_valid_pointer Mem.empty b ofs = false.
-Proof.
-  intros. unfold Mem.weak_valid_pointer.
-  now rewrite !mem_empty_not_valid_pointer.
-Qed.
-
-Lemma sem_cast_match:
-  forall v1 ty1 ty2 m v2 v1' v2',
-  sem_cast v1 ty1 ty2 m = Some v2 ->
-  do_cast v1' ty1 ty2 = OK v2' ->
-  Val.inject inj v1' v1 ->
-  Val.inject inj v2' v2.
-Proof.
-  intros. unfold do_cast in H0. destruct (sem_cast v1' ty1 ty2 Mem.empty) as [v2''|] eqn:E; inv H0.
-  exploit (sem_cast_inj inj Mem.empty m).
-  intros. rewrite mem_empty_not_weak_valid_pointer in H2. discriminate.
-  eexact E. eauto.
-  intros [v' [A B]]. congruence.
-Qed.
-
-Lemma bool_val_match:
-  forall v ty b v' m,
-  bool_val v ty Mem.empty = Some b ->
-  Val.inject inj v v' ->
-  bool_val v' ty m = Some b.
-Proof.
-  intros. eapply bool_val_inj; eauto. intros. rewrite mem_empty_not_weak_valid_pointer in H2; discriminate.
-Qed.
-
-(** Soundness of [constval] with respect to the big-step semantics *)
-
-Lemma constval_rvalue:
-  forall m a v,
-  eval_simple_rvalue empty_env m a v ->
-  forall v',
-  constval ge a = OK v' ->
-  Val.inject inj v' v
-with constval_lvalue:
-  forall m a b ofs,
-  eval_simple_lvalue empty_env m a b ofs ->
-  forall v',
-  constval ge a = OK v' ->
-  Val.inject inj v' (Vptr b ofs).
-Proof.
-  (* rvalue *)
-  induction 1; intros vres CV; simpl in CV; try (monadInv CV).
-  (* val *)
-  destruct v; monadInv CV; constructor.
-  (* rval *)
-  inv H1; rewrite H2 in CV; try congruence. eauto. eauto.
-  (* addrof *)
-  eauto.
-  (* unop *)
-  destruct (sem_unary_operation op x (typeof r1) Mem.empty) as [v1'|] eqn:E; inv EQ0.
-  exploit (sem_unary_operation_inj inj Mem.empty m).
-  intros. rewrite mem_empty_not_weak_valid_pointer in H2; discriminate.
-  eexact E. eauto.
-  intros [v' [A B]]. congruence.
-  (* binop *)
-  destruct (sem_binary_operation ge op x (typeof r1) x0 (typeof r2) Mem.empty) as [v1'|] eqn:E; inv EQ2.
-  exploit (sem_binary_operation_inj inj Mem.empty m).
-  intros. rewrite mem_empty_not_valid_pointer in H3; discriminate.
-  intros. rewrite mem_empty_not_weak_valid_pointer in H3; discriminate.
-  intros. rewrite mem_empty_not_weak_valid_pointer in H3; discriminate.
-  intros. rewrite mem_empty_not_valid_pointer in H3; discriminate.
-  eauto. eauto. eauto.
-  intros [v' [A B]]. congruence.
-  (* cast *)
-  eapply sem_cast_match; eauto.
-  (* sizeof *)
-  auto.
-  (* alignof *)
-  auto.
-  (* seqand *)
-  destruct (bool_val x (typeof r1) Mem.empty) as [b|] eqn:E; inv EQ2.
-  exploit bool_val_match. eexact E. eauto. instantiate (1 := m). intros E'.
-  assert (b = true) by congruence. subst b.
-  eapply sem_cast_match; eauto.
-  destruct (bool_val x (typeof r1) Mem.empty) as [b|] eqn:E; inv EQ2.
-  exploit bool_val_match. eexact E. eauto. instantiate (1 := m). intros E'.
-  assert (b = false) by congruence. subst b. inv H2. auto.
-  (* seqor *)
-  destruct (bool_val x (typeof r1) Mem.empty) as [b|] eqn:E; inv EQ2.
-  exploit bool_val_match. eexact E. eauto. instantiate (1 := m). intros E'.
-  assert (b = false) by congruence. subst b.
-  eapply sem_cast_match; eauto.
-  destruct (bool_val x (typeof r1) Mem.empty) as [b|] eqn:E; inv EQ2.
-  exploit bool_val_match. eexact E. eauto. instantiate (1 := m). intros E'.
-  assert (b = true) by congruence. subst b. inv H2. auto.
-  (* conditional *)
-  destruct (bool_val x (typeof r1) Mem.empty) as [b'|] eqn:E; inv EQ3.
-  exploit bool_val_match. eexact E. eauto. instantiate (1 := m). intros E'.
-  assert (b' = b) by congruence. subst b'.
-  destruct b; eapply sem_cast_match; eauto.
-  (* comma *)
-  auto.
-  (* paren *)
-  eapply sem_cast_match; eauto.
-
-  (* lvalue *)
-  induction 1; intros v' CV; simpl in CV; try (monadInv CV).
-  (* var local *)
-  unfold empty_env in H. rewrite PTree.gempty in H. congruence.
-  (* var_global *)
-  econstructor. unfold inj. rewrite H0. eauto. auto.
-  (* deref *)
-  eauto.
-  (* field struct *)
-  rewrite H0 in CV. monadInv CV. unfold lookup_composite in EQ; rewrite H1 in EQ; monadInv EQ.
-  exploit constval_rvalue; eauto. intro MV. inv MV.
-  replace x0 with delta by congruence. rewrite Ptrofs.add_assoc. rewrite (Ptrofs.add_commut (Ptrofs.repr delta0)).
-  simpl; destruct Archi.ptr64 eqn:SF;
-  econstructor; eauto; rewrite ! Ptrofs.add_assoc; f_equal; f_equal; symmetry; auto with ptrofs.
-  destruct Archi.ptr64; auto.
-  (* field union *)
-  rewrite H0 in CV. eauto.
-Qed.
-
-Lemma constval_simple:
-  forall a v, constval ge a = OK v -> simple a.
-Proof.
-  induction a; simpl; intros vx CV; try (monadInv CV); eauto.
-  destruct (typeof a); discriminate || eauto.
-  monadInv CV. eauto.
-  destruct (access_mode ty); discriminate || eauto.
-  intuition eauto.
-Qed.
-
-(** Soundness of [constval] with respect to the reduction semantics. *)
-
-Theorem constval_steps:
-  forall f r m v v' ty m',
-  star step ge (ExprState f r Kstop empty_env m) E0 (ExprState f (Eval v' ty) Kstop empty_env m') ->
-  constval ge r = OK v ->
-  m' = m /\ ty = typeof r /\ Val.inject inj v v'.
-Proof.
-  intros. exploit eval_simple_steps; eauto. eapply constval_simple; eauto.
-  intros [A [B C]]. intuition. eapply constval_rvalue; eauto.
-Qed.
-
-(** * Relational specification of the translation of initializers *)
-
-Definition tr_padding (frm to: Z) : list init_data :=
-  if zlt frm to then Init_space (to - frm) :: nil else nil.
-
-Inductive tr_init: type -> initializer -> list init_data -> Prop :=
-  | tr_init_sgl: forall ty a d,
-      transl_init_single ge ty a = OK d ->
-      tr_init ty (Init_single a) (d :: nil)
-  | tr_init_arr: forall tyelt nelt attr il d,
-      tr_init_array tyelt il (Z.max 0 nelt) d ->
-      tr_init (Tarray tyelt nelt attr) (Init_array il) d
-  | tr_init_str: forall id attr il co d,
-      lookup_composite ge id = OK co -> co_su co = Struct ->
-      tr_init_struct (Tstruct id attr) (co_members co) il 0 d ->
-      tr_init (Tstruct id attr) (Init_struct il) d
-  | tr_init_uni: forall id attr f i1 co ty1 d,
-      lookup_composite ge id = OK co -> co_su co = Union -> field_type f (co_members co) = OK ty1 ->
-      tr_init ty1 i1 d ->
-      tr_init (Tunion id attr) (Init_union f i1)
-              (d ++ tr_padding (sizeof ge ty1) (sizeof ge (Tunion id attr)))
-
-with tr_init_array: type -> initializer_list -> Z -> list init_data -> Prop :=
-  | tr_init_array_nil_0: forall ty,
-      tr_init_array ty Init_nil 0 nil
-  | tr_init_array_nil_pos: forall ty sz,
-      0 < sz ->
-      tr_init_array ty Init_nil sz (Init_space (sz * sizeof ge ty) :: nil)
-  | tr_init_array_cons: forall ty i il sz d1 d2,
-      tr_init ty i d1 -> tr_init_array ty il (sz - 1) d2 ->
-      tr_init_array ty (Init_cons i il) sz (d1 ++ d2)
-
-with tr_init_struct: type -> members -> initializer_list -> Z -> list init_data -> Prop :=
-  | tr_init_struct_nil: forall ty pos,
-      tr_init_struct ty nil Init_nil pos (tr_padding pos (sizeof ge ty))
-  | tr_init_struct_cons: forall ty f1 ty1 fl i1 il pos d1 d2,
-      let pos1 := align pos (alignof ge ty1) in
-      tr_init ty1 i1 d1 ->
-      tr_init_struct ty fl il (pos1 + sizeof ge ty1) d2 ->
-      tr_init_struct ty ((f1, ty1) :: fl) (Init_cons i1 il)
-                     pos (tr_padding pos pos1 ++ d1 ++ d2).
-
-Lemma transl_padding_spec:
-  forall frm to k, padding frm to k = rev (tr_padding frm to) ++ k.
-Proof.
-  unfold padding, tr_padding; intros. 
-  destruct (zlt frm to); auto.
-Qed.
-
-Lemma transl_init_rec_spec:
-  forall i ty k res,
-  transl_init_rec ge ty i k = OK res ->
-  exists d, tr_init ty i d /\ res = rev d ++ k
-
-with transl_init_array_spec:
-  forall il ty sz k res,
-  transl_init_array ge ty il sz k = OK res ->
-  exists d, tr_init_array ty il sz d /\ res = rev d ++ k
-
-with transl_init_struct_spec:
-  forall il ty fl pos k res,
-  transl_init_struct ge ty fl il pos k = OK res ->
-  exists d, tr_init_struct ty fl il pos d /\ res = rev d ++ k.
-
-Proof.
-Local Opaque sizeof.
-- destruct i; intros until res; intros TR; simpl in TR.
-+ monadInv TR. exists (x :: nil); split; auto. constructor; auto.
-+ destruct ty; try discriminate.
-  destruct (transl_init_array_spec _ _ _ _ _ TR) as (d & A & B).
-  exists d; split; auto. constructor; auto.
-+ destruct ty; try discriminate. monadInv TR. destruct (co_su x) eqn:SU; try discriminate.
-  destruct (transl_init_struct_spec _ _ _ _ _ _ EQ0) as (d & A & B).
-  exists d; split; auto. econstructor; eauto.
-+ destruct ty; try discriminate.
-  monadInv TR. destruct (co_su x) eqn:SU; monadInv EQ0.
-  destruct (transl_init_rec_spec _ _ _ _ EQ0) as (d & A & B).
-  exists (d ++ tr_padding (sizeof ge x0) (sizeof ge (Tunion i0 a))); split.
-  econstructor; eauto.
-  rewrite rev_app_distr, app_ass, B. apply transl_padding_spec. 
-
-- destruct il; intros until res; intros TR; simpl in TR.
-+ destruct (zeq sz 0). 
-  inv TR. exists (@nil init_data); split; auto. constructor.
-  destruct (zle 0 sz).
-  inv TR. econstructor; split. constructor. lia. auto.
-  discriminate.
-+ monadInv TR. 
-  destruct (transl_init_rec_spec _ _ _ _ EQ) as (d1 & A1 & B1).
-  destruct (transl_init_array_spec _ _ _ _ _ EQ0) as (d2 & A2 & B2).
-  exists (d1 ++ d2); split. econstructor; eauto. 
-  subst res x. rewrite rev_app_distr, app_ass. auto.
-
-- destruct il; intros until res; intros TR; simpl in TR.
-+ destruct fl; inv TR. econstructor; split. constructor. apply transl_padding_spec.
-+ destruct fl as [ | [f1 ty1] fl ]; monadInv TR.
-  destruct (transl_init_rec_spec _ _ _ _ EQ) as (d1 & A1 & B1).
-  destruct (transl_init_struct_spec _ _ _ _ _ _ EQ0) as (d2 & A2 & B2).
-  exists (tr_padding pos (align pos (alignof ge ty1)) ++ d1 ++ d2); split.
-  econstructor; eauto.
-  rewrite ! rev_app_distr. subst res x. rewrite ! app_ass. rewrite transl_padding_spec. auto.
-Qed.
-
-Theorem transl_init_spec:
-  forall ty i d, transl_init ge ty i = OK d -> tr_init ty i d.
-Proof.
-  unfold transl_init; intros. monadInv H. 
-  exploit transl_init_rec_spec; eauto. intros (d & A & B). 
-  subst x. unfold rev'; rewrite <- rev_alt. 
-  rewrite rev_app_distr; simpl. rewrite rev_involutive. auto.
-Qed.
-
-(** * Soundness of the translation of initializers *)
-
-(** Soundness for single initializers. *)
-
-Theorem transl_init_single_steps:
-  forall ty a data f m v1 ty1 m' v chunk b ofs m'',
-  transl_init_single ge ty a = OK data ->
-  star step ge (ExprState f a Kstop empty_env m) E0 (ExprState f (Eval v1 ty1) Kstop empty_env m') ->
-  sem_cast v1 ty1 ty m' = Some v ->
-  access_mode ty = By_value chunk ->
-  Mem.store chunk m' b ofs v = Some m'' ->
-  Genv.store_init_data ge m b ofs data = Some m''.
-Proof.
-  intros. monadInv H. monadInv EQ. 
-  exploit constval_steps; eauto. intros [A [B C]]. subst m' ty1.
-  exploit sem_cast_match; eauto. intros D.
-  unfold Genv.store_init_data.
-  inv D.
-- (* int *)
-  remember Archi.ptr64 as ptr64.  destruct ty; try discriminate EQ0.
-+ destruct i0; inv EQ0.
-  destruct s; simpl in H2; inv H2. rewrite <- Mem.store_signed_unsigned_8; auto. auto.
-  destruct s; simpl in H2; inv H2. rewrite <- Mem.store_signed_unsigned_16; auto. auto.
-  simpl in H2; inv H2. assumption.
-  simpl in H2; inv H2. assumption.
-+ destruct ptr64; inv EQ0. simpl in H2; unfold Mptr in H2; rewrite <- Heqptr64 in H2; inv H2. assumption.
-- (* Long *)
-  remember Archi.ptr64 as ptr64. destruct ty; inv EQ0.
-+ simpl in H2; inv H2. assumption.
-+ simpl in H2; unfold Mptr in H2; destruct Archi.ptr64; inv H4. 
-  inv H2; assumption.
-- (* float *)
-  destruct ty; try discriminate.
-  destruct f1; inv EQ0; simpl in H2; inv H2; assumption.
-- (* single *)
-  destruct ty; try discriminate.
-  destruct f1; inv EQ0; simpl in H2; inv H2; assumption.
-- (* pointer *)
-  unfold inj in H.
-  assert (data = Init_addrof b1 ofs1 /\ chunk = Mptr).
-  { remember Archi.ptr64 as ptr64.
-    destruct ty; inversion EQ0.
-    destruct i; inv H5. unfold Mptr. destruct Archi.ptr64; inv H6; inv H2; auto.
-    subst ptr64. unfold Mptr. destruct Archi.ptr64; inv H5; inv H2; auto.
-    inv H2. auto. }
-  destruct H4; subst. destruct (Genv.find_symbol ge b1); inv H.
-  rewrite Ptrofs.add_zero in H3. auto.
-- (* undef *)
-  discriminate.
-Qed.
-
-(** Size properties for initializers. *)
-
-Lemma transl_init_single_size:
-  forall ty a data,
-  transl_init_single ge ty a = OK data ->
-  init_data_size data = sizeof ge ty.
-Proof.
-  intros. monadInv H. monadInv EQ. remember Archi.ptr64 as ptr64. destruct x.
-- monadInv EQ0.
-- destruct ty; try discriminate.
-  destruct i0; inv EQ0; auto.
-  destruct ptr64; inv EQ0. 
-Local Transparent sizeof.
-  unfold sizeof. rewrite <- Heqptr64; auto.
-- destruct ty; inv EQ0; auto. 
-  unfold sizeof. destruct Archi.ptr64; inv H0; auto.
-- destruct ty; try discriminate.
-  destruct f0; inv EQ0; auto.
-- destruct ty; try discriminate.
-  destruct f0; inv EQ0; auto.
-- destruct ty; try discriminate.
-  destruct i0; inv EQ0; auto.
-  destruct Archi.ptr64 eqn:SF; inv H0. simpl. rewrite SF; auto.
-  destruct ptr64; inv EQ0. simpl. rewrite <- Heqptr64; auto.
-  inv EQ0. unfold init_data_size, sizeof. auto.
-Qed.
-
-Notation idlsize := init_data_list_size.
-
-Remark padding_size:
-  forall frm to, frm <= to -> idlsize (tr_padding frm to) = to - frm.
-Proof.
-  unfold tr_padding; intros. destruct (zlt frm to).
-  simpl. extlia.
-  simpl. lia.
-Qed.
-
-Remark idlsize_app:
-  forall d1 d2, idlsize (d1 ++ d2) = idlsize d1 + idlsize d2.
-Proof.
-  induction d1; simpl; intros.
-  auto.
-  rewrite IHd1. lia.
-Qed.
-
-Remark union_field_size:
-  forall f ty fl, field_type f fl = OK ty -> sizeof ge ty <= sizeof_union ge fl.
-Proof.
-  induction fl as [|[i t]]; simpl; intros.
-- inv H.
-- destruct (ident_eq f i).
-  + inv H. extlia.
-  + specialize (IHfl H). extlia.
-Qed.
-
-Hypothesis ce_consistent: composite_env_consistent ge.
-
-Lemma tr_init_size:
-  forall i ty data,
-  tr_init ty i data ->
-  idlsize data = sizeof ge ty
-with tr_init_array_size:
-  forall ty il sz data,
-  tr_init_array ty il sz data ->
-  idlsize data = sizeof ge ty * sz
-with tr_init_struct_size:
-  forall ty fl il pos data,
-  tr_init_struct ty fl il pos data ->
-  sizeof_struct ge pos fl <= sizeof ge ty ->
-  idlsize data + pos = sizeof ge ty.
-Proof.
-Local Opaque sizeof.
-- destruct 1; simpl.
-+ erewrite transl_init_single_size by eauto. lia.
-+ Local Transparent sizeof. simpl. eapply tr_init_array_size; eauto. 
-+ replace (idlsize d) with (idlsize d + 0) by lia.
-  eapply tr_init_struct_size; eauto. simpl.
-  unfold lookup_composite in H. destruct (ge.(genv_cenv)!id) as [co'|] eqn:?; inv H.
-  erewrite co_consistent_sizeof by (eapply ce_consistent; eauto).
-  unfold sizeof_composite. rewrite H0. apply align_le.
-  destruct (co_alignof_two_p co) as [n EQ]. rewrite EQ. apply two_power_nat_pos.
-+ rewrite idlsize_app, padding_size. 
-  exploit tr_init_size; eauto. intros EQ; rewrite EQ. lia.
-  simpl. unfold lookup_composite in H. destruct (ge.(genv_cenv)!id) as [co'|] eqn:?; inv H.
-  apply Z.le_trans with (sizeof_union ge (co_members co)).
-  eapply union_field_size; eauto.
-  erewrite co_consistent_sizeof by (eapply ce_consistent; eauto).
-  unfold sizeof_composite. rewrite H0. apply align_le.
-  destruct (co_alignof_two_p co) as [n EQ]. rewrite EQ. apply two_power_nat_pos.
-
-- destruct 1; simpl.
-+ lia.
-+ rewrite Z.mul_comm.
-  assert (0 <= sizeof ge ty * sz).
-  { apply Zmult_gt_0_le_0_compat. lia. generalize (sizeof_pos ge ty); lia. }
-  extlia.
-+ rewrite idlsize_app. 
-  erewrite tr_init_size by eauto. 
-  erewrite tr_init_array_size by eauto.
-  ring.
-
-- destruct 1; simpl; intros.
-+ rewrite padding_size by auto. lia.
-+ rewrite ! idlsize_app, padding_size. 
-  erewrite tr_init_size by eauto. 
-  rewrite <- (tr_init_struct_size _ _ _ _ _ H0 H1). lia.
-  unfold pos1. apply align_le. apply alignof_pos. 
-Qed.
-
-(** A semantics for general initializers *)
-
-Definition dummy_function := mkfunction Tvoid cc_default nil nil Sskip.
-
-Fixpoint fields_of_struct (fl: members) (pos: Z) : list (Z * type) :=
-  match fl with
-  | nil => nil
-  | (id1, ty1) :: fl' =>
-      (align pos (alignof ge ty1), ty1) :: fields_of_struct fl' (align pos (alignof ge ty1) + sizeof ge ty1)
-  end.
-
-Inductive exec_init: mem -> block -> Z -> type -> initializer -> mem -> Prop :=
-  | exec_init_single: forall m b ofs ty a v1 ty1 chunk m' v m'',
-      star step ge (ExprState dummy_function a Kstop empty_env m)
-                E0 (ExprState dummy_function (Eval v1 ty1) Kstop empty_env m') ->
-      sem_cast v1 ty1 ty m' = Some v ->
-      access_mode ty = By_value chunk ->
-      Mem.store chunk m' b ofs v = Some m'' ->
-      exec_init m b ofs ty (Init_single a) m''
-  | exec_init_array_: forall m b ofs ty sz a il m',
-      exec_init_array m b ofs ty sz il m' ->
-      exec_init m b ofs (Tarray ty sz a) (Init_array il) m'
-  | exec_init_struct: forall m b ofs id a il co m',
-      ge.(genv_cenv)!id = Some co -> co_su co = Struct ->
-      exec_init_list m b ofs (fields_of_struct (co_members co) 0) il m' ->
-      exec_init m b ofs (Tstruct id a) (Init_struct il) m'
-  | exec_init_union: forall m b ofs id a f i ty co m',
-      ge.(genv_cenv)!id = Some co -> co_su co = Union ->
-      field_type f (co_members co) = OK ty ->
-      exec_init m b ofs ty i m' ->
-      exec_init m b ofs (Tunion id a) (Init_union f i) m'
-
-with exec_init_array: mem -> block -> Z -> type -> Z -> initializer_list -> mem -> Prop :=
-  | exec_init_array_nil: forall m b ofs ty sz,
-      sz >= 0 ->
-      exec_init_array m b ofs ty sz Init_nil m
-  | exec_init_array_cons: forall m b ofs ty sz i1 il m' m'',
-      exec_init m b ofs ty i1 m' ->
-      exec_init_array m' b (ofs + sizeof ge ty) ty (sz - 1) il m'' ->
-      exec_init_array m b ofs ty sz (Init_cons i1 il) m''
-
-with exec_init_list: mem -> block -> Z -> list (Z * type) -> initializer_list -> mem -> Prop :=
-  | exec_init_list_nil: forall m b ofs,
-      exec_init_list m b ofs nil Init_nil m
-  | exec_init_list_cons: forall m b ofs pos ty l i1 il m' m'',
-      exec_init m b (ofs + pos) ty i1 m' ->
-      exec_init_list m' b ofs l il m'' ->
-      exec_init_list m b ofs ((pos, ty) :: l) (Init_cons i1 il) m''.
-
-Scheme exec_init_ind3 := Minimality for exec_init Sort Prop
-  with exec_init_array_ind3 := Minimality for exec_init_array Sort Prop
-  with exec_init_list_ind3 := Minimality for exec_init_list Sort Prop.
-Combined Scheme exec_init_scheme from exec_init_ind3, exec_init_array_ind3, exec_init_list_ind3.
-
-Remark exec_init_array_length:
-  forall m b ofs ty sz il m',
-  exec_init_array m b ofs ty sz il m' -> sz >= 0.
-Proof.
-  induction 1; lia.
-Qed.
-
-Lemma store_init_data_list_app:
-  forall data1 m b ofs m' data2 m'',
-  Genv.store_init_data_list ge m b ofs data1 = Some m' ->
-  Genv.store_init_data_list ge m' b (ofs + idlsize data1) data2 = Some m'' ->
-  Genv.store_init_data_list ge m b ofs (data1 ++ data2) = Some m''.
-Proof.
-  induction data1; simpl; intros.
-  inv H. rewrite Z.add_0_r in H0. auto.
-  destruct (Genv.store_init_data ge m b ofs a); try discriminate.
-  rewrite Z.add_assoc in H0. eauto.
-Qed.
-
-Remark store_init_data_list_padding:
-  forall frm to b ofs m,
-  Genv.store_init_data_list ge m b ofs (tr_padding frm to) = Some m.
-Proof.
-  intros. unfold tr_padding. destruct (zlt frm to); auto.
-Qed.
-
-Lemma tr_init_sound:
-  (forall m b ofs ty i m', exec_init m b ofs ty i m' ->
-   forall data, tr_init ty i data ->
-   Genv.store_init_data_list ge m b ofs data = Some m')
-/\(forall m b ofs ty sz il m', exec_init_array m b ofs ty sz il m' ->
-   forall data, tr_init_array ty il sz data ->
-   Genv.store_init_data_list ge m b ofs data = Some m')
-/\(forall m b ofs l il m', exec_init_list m b ofs l il m' ->
-   forall ty fl data pos,
-   l = fields_of_struct fl pos ->
-   tr_init_struct ty fl il pos data ->
-   Genv.store_init_data_list ge m b (ofs + pos) data = Some m').
-Proof.
-Local Opaque sizeof.
-  apply exec_init_scheme; simpl; intros.
-- (* single *)
-  inv H3. simpl. erewrite transl_init_single_steps by eauto. auto.
-- (* array *)
-  inv H1. replace (Z.max 0 sz) with sz in H7. eauto.
-  assert (sz >= 0) by (eapply exec_init_array_length; eauto). extlia.
-- (* struct *)
-  inv H3. unfold lookup_composite in H7. rewrite H in H7. inv H7. 
-  replace ofs with (ofs + 0) by lia. eauto.
-- (* union *)
-  inv H4. unfold lookup_composite in H9. rewrite H in H9. inv H9. rewrite H1 in H12; inv H12. 
-  eapply store_init_data_list_app. eauto.
-  apply store_init_data_list_padding.
-
-- (* array, empty *)
-  inv H0; auto.
-- (* array, nonempty *)
-  inv H3.
-  eapply store_init_data_list_app.
-  eauto.
-  rewrite (tr_init_size _ _ _ H7). eauto.
-
-- (* struct, empty *)
-  inv H0. apply store_init_data_list_padding.
-- (* struct, nonempty *)
-  inv H4. simpl in H3; inv H3. 
-  eapply store_init_data_list_app. apply store_init_data_list_padding.
-  rewrite padding_size.
-  replace (ofs + pos0 + (pos2 - pos0)) with (ofs + pos2) by lia.
-  eapply store_init_data_list_app.
-  eauto.
-  rewrite (tr_init_size _ _ _ H9).
-  rewrite <- Z.add_assoc. eapply H2. eauto. eauto.
-  apply align_le. apply alignof_pos.
-Qed.
-
-End SOUNDNESS.
-
-Theorem transl_init_sound:
-  forall p m b ty i m' data,
-  exec_init (globalenv p) m b 0 ty i m' ->
-  transl_init (prog_comp_env p) ty i = OK data ->
-  Genv.store_init_data_list (globalenv p) m b 0 data = Some m'.
-Proof.
-  intros.
-  set (ge := globalenv p) in *.
-  change (prog_comp_env p) with (genv_cenv ge) in H0.
-  destruct (tr_init_sound ge) as (A & B & C).
-  eapply build_composite_env_consistent. apply prog_comp_env_eq.
-  eapply A; eauto. apply transl_init_spec; auto.
-Qed.
+(* Section SOUNDNESS. *)
+
+(* Variable ge: genv. *)
+
+(* (** * Simple expressions and their big-step semantics *) *)
+
+(* (** An expression is simple if it contains no assignments and no *)
+(*   function calls. *) *)
+
+(* Fixpoint simple (a: expr) : Prop := *)
+(*   match a with *)
+(*   | Eloc _ _ _ => True *)
+(*   | Evar _ _ => True *)
+(*   | Ederef r _ => simple r *)
+(*   | Efield l1 _ _ => simple l1 *)
+(*   | Eval _ _ => True *)
+(*   | Evalof l _ => simple l *)
+(*   | Eaddrof l _ => simple l *)
+(*   | Eunop _ r1 _ => simple r1 *)
+(*   | Ebinop _ r1 r2 _ => simple r1 /\ simple r2 *)
+(*   | Ecast r1 _ => simple r1 *)
+(*   | Eseqand r1 r2 _ => simple r1 /\ simple r2 *)
+(*   | Eseqor r1 r2 _ => simple r1 /\ simple r2 *)
+(*   | Econdition r1 r2 r3 _ => simple r1 /\ simple r2 /\ simple r3 *)
+(*   | Esizeof _ _ => True *)
+(*   | Ealignof _ _ => True *)
+(*   | Eassign _ _ _ => False *)
+(*   | Eassignop _ _ _ _ _ => False *)
+(*   | Epostincr _ _ _ => False *)
+(*   | Ecomma r1 r2 _ => simple r1 /\ simple r2 *)
+(*   | Ecall _ _ _ => False *)
+(*   | Ebuiltin _ _ _ _ => False *)
+(*   | Eparen r1 _ _ => simple r1 *)
+(*   end. *)
+
+(* (** A big-step semantics for simple expressions.  Similar to the *)
+(*   big-step semantics from [Cstrategy], with the addition of *)
+(*   conditionals, comma and paren operators.  It is a pity we do not *)
+(*   share definitions with [Cstrategy], but such sharing raises *)
+(*   technical difficulties. *) *)
+
+(* Section SIMPLE_EXPRS. *)
+
+(* Variable e: env. *)
+(* Variable m: mem. *)
+
+(* Inductive eval_simple_lvalue: expr -> block -> ptrofs -> Prop := *)
+(*   | esl_loc: forall b ofs ty, *)
+(*       eval_simple_lvalue (Eloc b ofs ty) b ofs *)
+(*   | esl_var_local: forall x ty b, *)
+(*       e!x = Some(b, ty) -> *)
+(*       eval_simple_lvalue (Evar x ty) b Ptrofs.zero *)
+(*   | esl_var_global: forall x ty b, *)
+(*       e!x = None -> *)
+(*       Genv.find_symbol ge x = Some b -> *)
+(*       eval_simple_lvalue (Evar x ty) b Ptrofs.zero *)
+(*   | esl_deref: forall r ty b ofs, *)
+(*       eval_simple_rvalue r (Vptr b ofs) -> *)
+(*       eval_simple_lvalue (Ederef r ty) b ofs *)
+(*   | esl_field_struct: forall r f ty b ofs id co a delta, *)
+(*       eval_simple_rvalue r (Vptr b ofs) -> *)
+(*       typeof r = Tstruct id a -> ge.(genv_cenv)!id = Some co -> field_offset ge f (co_members co) = OK delta -> *)
+(*       eval_simple_lvalue (Efield r f ty) b (Ptrofs.add ofs (Ptrofs.repr delta)) *)
+(*   | esl_field_union: forall r f ty b ofs id a, *)
+(*       eval_simple_rvalue r (Vptr b ofs) -> *)
+(*       typeof r = Tunion id a -> *)
+(*       eval_simple_lvalue (Efield r f ty) b ofs *)
+
+(* with eval_simple_rvalue: expr -> val -> Prop := *)
+(*   | esr_val: forall v ty, *)
+(*       eval_simple_rvalue (Eval v ty) v *)
+(*   | esr_rvalof: forall b ofs l ty v, *)
+(*       eval_simple_lvalue l b ofs -> *)
+(*       ty = typeof l -> *)
+(*       deref_loc ge ty m b ofs E0 v -> *)
+(*       eval_simple_rvalue (Evalof l ty) v *)
+(*   | esr_addrof: forall b ofs l ty, *)
+(*       eval_simple_lvalue l b ofs -> *)
+(*       eval_simple_rvalue (Eaddrof l ty) (Vptr b ofs) *)
+(*   | esr_unop: forall op r1 ty v1 v, *)
+(*       eval_simple_rvalue r1 v1 -> *)
+(*       sem_unary_operation op v1 (typeof r1) m = Some v -> *)
+(*       eval_simple_rvalue (Eunop op r1 ty) v *)
+(*   | esr_binop: forall op r1 r2 ty v1 v2 v, *)
+(*       eval_simple_rvalue r1 v1 -> eval_simple_rvalue r2 v2 -> *)
+(*       sem_binary_operation ge op v1 (typeof r1) v2 (typeof r2) m = Some v -> *)
+(*       eval_simple_rvalue (Ebinop op r1 r2 ty) v *)
+(*   | esr_cast: forall ty r1 v1 v, *)
+(*       eval_simple_rvalue r1 v1 -> *)
+(*       sem_cast v1 (typeof r1) ty m = Some v -> *)
+(*       eval_simple_rvalue (Ecast r1 ty) v *)
+(*   | esr_sizeof: forall ty1 ty, *)
+(*       eval_simple_rvalue (Esizeof ty1 ty) (Vptrofs (Ptrofs.repr (sizeof ge ty1))) *)
+(*   | esr_alignof: forall ty1 ty, *)
+(*       eval_simple_rvalue (Ealignof ty1 ty) (Vptrofs (Ptrofs.repr (alignof ge ty1))) *)
+(*   | esr_seqand_true: forall r1 r2 ty v1 v2 v3, *)
+(*       eval_simple_rvalue r1 v1 -> bool_val v1 (typeof r1) m = Some true -> *)
+(*       eval_simple_rvalue r2 v2 -> *)
+(*       sem_cast v2 (typeof r2) type_bool m = Some v3 -> *)
+(*       eval_simple_rvalue (Eseqand r1 r2 ty) v3 *)
+(*   | esr_seqand_false: forall r1 r2 ty v1, *)
+(*       eval_simple_rvalue r1 v1 -> bool_val v1 (typeof r1) m = Some false -> *)
+(*       eval_simple_rvalue (Eseqand r1 r2 ty) (Vint Int.zero) *)
+(*   | esr_seqor_false: forall r1 r2 ty v1 v2 v3, *)
+(*       eval_simple_rvalue r1 v1 -> bool_val v1 (typeof r1) m = Some false -> *)
+(*       eval_simple_rvalue r2 v2 -> *)
+(*       sem_cast v2 (typeof r2) type_bool m = Some v3 -> *)
+(*       eval_simple_rvalue (Eseqor r1 r2 ty) v3 *)
+(*   | esr_seqor_true: forall r1 r2 ty v1, *)
+(*       eval_simple_rvalue r1 v1 -> bool_val v1 (typeof r1) m = Some true -> *)
+(*       eval_simple_rvalue (Eseqor r1 r2 ty) (Vint Int.one) *)
+(*   | esr_condition: forall r1 r2 r3 ty v v1 b v', *)
+(*       eval_simple_rvalue r1 v1 -> bool_val v1 (typeof r1) m = Some b -> *)
+(*       eval_simple_rvalue (if b then r2 else r3) v' -> *)
+(*       sem_cast v' (typeof (if b then r2 else r3)) ty m = Some v -> *)
+(*       eval_simple_rvalue (Econdition r1 r2 r3 ty) v *)
+(*   | esr_comma: forall r1 r2 ty v1 v, *)
+(*       eval_simple_rvalue r1 v1 -> eval_simple_rvalue r2 v -> *)
+(*       eval_simple_rvalue (Ecomma r1 r2 ty) v *)
+(*   | esr_paren: forall r tycast ty v v', *)
+(*       eval_simple_rvalue r v -> sem_cast v (typeof r) tycast m = Some v' -> *)
+(*       eval_simple_rvalue (Eparen r tycast ty) v'. *)
+
+(* End SIMPLE_EXPRS. *)
+
+(* (** * Correctness of the big-step semantics with respect to reduction sequences *) *)
+
+(* (** In this section, we show that if a simple expression [a] reduces to *)
+(*   some value (with the transition semantics from module [Csem]), *)
+(*   then it evaluates to this value (with the big-step semantics above). *) *)
+
+(* Definition compat_eval (k: kind) (e: env) (a a': expr) (m: mem) : Prop := *)
+(*   typeof a = typeof a' /\ *)
+(*   match k with *)
+(*   | LV => forall b ofs, eval_simple_lvalue e m a' b ofs -> eval_simple_lvalue e m a b ofs *)
+(*   | RV => forall v, eval_simple_rvalue e m a' v -> eval_simple_rvalue e m a v *)
+(*   end. *)
+
+(* Lemma lred_simple: *)
+(*   forall e l m l' m', lred ge e l m l' m' -> simple l -> simple l'. *)
+(* Proof. *)
+(*   induction 1; simpl; tauto. *)
+(* Qed. *)
+
+(* Lemma lred_compat: *)
+(*   forall e l m l' m', lred ge e l m l' m' -> *)
+(*   m = m' /\ compat_eval LV e l l' m. *)
+(* Proof. *)
+(*   induction 1; simpl; split; auto; split; auto; intros bx ofsx EV; inv EV. *)
+(*   apply esl_var_local; auto. *)
+(*   apply esl_var_global; auto. *)
+(*   constructor. constructor. *)
+(*   eapply esl_field_struct; eauto. constructor. simpl; eauto. *)
+(*   eapply esl_field_union; eauto. constructor. simpl; eauto. *)
+(* Qed. *)
+
+(* Lemma rred_simple: *)
+(*   forall r m t r' m', rred ge r m t r' m' -> simple r -> simple r'. *)
+(* Proof. *)
+(*   induction 1; simpl; intuition. destruct b; auto. *)
+(* Qed. *)
+
+(* Lemma rred_compat: *)
+(*   forall e r m r' m', rred ge r m E0 r' m' -> *)
+(*   simple r -> *)
+(*   m = m' /\ compat_eval RV e r r' m. *)
+(* Proof. *)
+(*   intros until m'; intros RED SIMP. inv RED; simpl in SIMP; try contradiction; split; auto; split; auto; intros vx EV. *)
+(*   inv EV. econstructor. constructor. auto. auto. *)
+(*   inv EV. econstructor. constructor. *)
+(*   inv EV. econstructor; eauto. constructor. *)
+(*   inv EV. econstructor; eauto. constructor. constructor. *)
+(*   inv EV. econstructor; eauto. constructor. *)
+(*   inv EV. eapply esr_seqand_true; eauto. constructor. *)
+(*   inv EV. eapply esr_seqand_false; eauto. constructor. *)
+(*   inv EV. eapply esr_seqor_true; eauto. constructor. *)
+(*   inv EV. eapply esr_seqor_false; eauto. constructor. *)
+(*   inv EV. eapply esr_condition; eauto. constructor. *)
+(*   inv EV. constructor. *)
+(*   inv EV. constructor. *)
+(*   econstructor; eauto. constructor. *)
+(*   inv EV. econstructor. constructor. auto. *)
+(* Qed. *)
+
+(* Lemma compat_eval_context: *)
+(*   forall e a a' m from to C, *)
+(*   context from to C -> *)
+(*   compat_eval from e a a' m -> *)
+(*   compat_eval to e (C a) (C a') m. *)
+(* Proof. *)
+(*   induction 1; intros CE; auto; *)
+(*   try (generalize (IHcontext CE); intros [TY EV]; red; split; simpl; auto; intros). *)
+(*   inv H0. constructor; auto. *)
+(*   inv H0. *)
+(*     eapply esl_field_struct; eauto. rewrite TY; eauto. *)
+(*     eapply esl_field_union; eauto. rewrite TY; eauto. *)
+(*   inv H0. econstructor. eauto. auto. auto. *)
+(*   inv H0. econstructor; eauto. *)
+(*   inv H0. econstructor; eauto. congruence. *)
+(*   inv H0. econstructor; eauto. congruence. *)
+(*   inv H0. econstructor; eauto. congruence. *)
+(*   inv H0. econstructor; eauto. congruence. *)
+(*   inv H0. *)
+(*     eapply esr_seqand_true; eauto. rewrite TY; auto. *)
+(*     eapply esr_seqand_false; eauto. rewrite TY; auto. *)
+(*   inv H0. *)
+(*     eapply esr_seqor_false; eauto. rewrite TY; auto. *)
+(*     eapply esr_seqor_true; eauto. rewrite TY; auto. *)
+(*   inv H0. eapply esr_condition; eauto. congruence. *)
+(*   inv H0. *)
+(*   inv H0. *)
+(*   inv H0. *)
+(*   inv H0. *)
+(*   inv H0. *)
+(*   inv H0. *)
+(*   red; split; intros. auto. inv H0. *)
+(*   red; split; intros. auto. inv H0. *)
+(*   inv H0. econstructor; eauto. *)
+(*   inv H0. econstructor; eauto. congruence. *)
+(* Qed. *)
+
+(* Lemma simple_context_1: *)
+(*   forall a from to C, context from to C -> simple (C a) -> simple a. *)
+(* Proof. *)
+(*   induction 1; simpl; tauto. *)
+(* Qed. *)
+
+(* Lemma simple_context_2: *)
+(*   forall a a', simple a' -> forall from to C, context from to C -> simple (C a) -> simple (C a'). *)
+(* Proof. *)
+(*   induction 2; simpl; try tauto. *)
+(* Qed. *)
+
+(* Lemma compat_eval_steps_aux f r e m r' m' s2 : *)
+(*   simple r -> *)
+(*   star step ge s2 nil (ExprState f r' Kstop e m') -> *)
+(*   estep ge (ExprState f r Kstop e m) nil s2 -> *)
+(*   exists r1, *)
+(*     s2 = ExprState f r1 Kstop e m /\ *)
+(*     compat_eval RV e r r1 m /\ simple r1. *)
+(* Proof. *)
+(*   intros. *)
+(*   inv H1. *)
+(*   (* lred *) *)
+(*   assert (S: simple a) by (eapply simple_context_1; eauto). *)
+(*   exploit lred_compat; eauto. intros [A B]. subst m'0. *)
+(*   econstructor; split. eauto. split. *)
+(*   eapply compat_eval_context; eauto. *)
+(*   eapply simple_context_2; eauto. eapply lred_simple; eauto. *)
+(*   (* rred *) *)
+(*   assert (S: simple a) by (eapply simple_context_1; eauto). *)
+(*   exploit rred_compat; eauto. intros [A B]. subst m'0. *)
+(*   econstructor; split. eauto. split. *)
+(*   eapply compat_eval_context; eauto. *)
+(*   eapply simple_context_2; eauto. eapply rred_simple; eauto. *)
+(*   (* callred *) *)
+(*   assert (S: simple a) by (eapply simple_context_1; eauto). *)
+(*   inv H8; simpl in S; contradiction. *)
+(*   (* stuckred *) *)
+(*   inv H0. destruct H1; inv H0. *)
+(* Qed. *)
+
+(* Lemma compat_eval_steps: *)
+(*   forall f r e m  r' m', *)
+(*   star step ge (ExprState f r Kstop e m) E0 (ExprState f r' Kstop e m') -> *)
+(*   simple r -> *)
+(*   m' = m /\ compat_eval RV e r r' m. *)
+(* Proof. *)
+(*   intros. *)
+(*   remember (ExprState f r Kstop e m) as S1. *)
+(*   remember E0 as t. *)
+(*   remember (ExprState f r' Kstop e m') as S2. *)
+(*   revert S1 t S2 H r m r' m' HeqS1 Heqt HeqS2 H0. *)
+(*   induction 1; intros; subst. *)
+(*   (* base case *) *)
+(*   inv HeqS2. split. auto. red; auto. *)
+(*   (* inductive case *) *)
+(*   destruct (app_eq_nil t1 t2); auto. subst. inv H. *)
+(*   (* expression step *) *)
+(*   exploit compat_eval_steps_aux; eauto. *)
+(*   intros [r1 [A [B C]]]. subst s2. *)
+(*   exploit IHstar; eauto. intros [D E]. *)
+(*   split. auto. destruct B; destruct E. split. congruence. auto. *)
+(*   (* statement steps *) *)
+(*   inv H1. *)
+(* Qed. *)
+
+(* Theorem eval_simple_steps: *)
+(*   forall f r e m v ty m', *)
+(*   star step ge (ExprState f r Kstop e m) E0 (ExprState f (Eval v ty) Kstop e m') -> *)
+(*   simple r -> *)
+(*   m' = m /\ ty = typeof r /\ eval_simple_rvalue e m r v. *)
+(* Proof. *)
+(*   intros. exploit compat_eval_steps; eauto. intros [A [B C]]. *)
+(*   intuition. apply C. constructor. *)
+(* Qed. *)
+
+(* (** * Soundness of the compile-time evaluator *) *)
+
+(* (** A global environment [ge] induces a memory injection mapping *)
+(*   our symbolic pointers [Vptr id ofs] to run-time pointers *)
+(*   [Vptr b ofs] where [Genv.find_symbol ge id = Some b]. *) *)
+
+(* Definition inj (b: block) := *)
+(*   match Genv.find_symbol ge b with *)
+(*   | Some b' => Some (b', 0) *)
+(*   | None => None *)
+(*   end. *)
+
+(* Lemma mem_empty_not_valid_pointer: *)
+(*   forall b ofs, Mem.valid_pointer Mem.empty b ofs = false. *)
+(* Proof. *)
+(*   intros. unfold Mem.valid_pointer. destruct (Mem.perm_dec Mem.empty b ofs Cur Nonempty); auto. *)
+(*   eelim Mem.perm_empty; eauto. *)
+(* Qed. *)
+
+(* Lemma mem_empty_not_weak_valid_pointer: *)
+(*   forall b ofs, Mem.weak_valid_pointer Mem.empty b ofs = false. *)
+(* Proof. *)
+(*   intros. unfold Mem.weak_valid_pointer. *)
+(*   now rewrite !mem_empty_not_valid_pointer. *)
+(* Qed. *)
+
+(* Lemma sem_cast_match: *)
+(*   forall v1 ty1 ty2 m v2 v1' v2', *)
+(*   sem_cast v1 ty1 ty2 m = Some v2 -> *)
+(*   do_cast v1' ty1 ty2 = OK v2' -> *)
+(*   Val.inject inj v1' v1 -> *)
+(*   Val.inject inj v2' v2. *)
+(* Proof. *)
+(*   intros. unfold do_cast in H0. destruct (sem_cast v1' ty1 ty2 Mem.empty) as [v2''|] eqn:E; inv H0. *)
+(*   exploit (sem_cast_inj inj Mem.empty m). *)
+(*   intros. rewrite mem_empty_not_weak_valid_pointer in H2. discriminate. *)
+(*   eexact E. eauto. *)
+(*   intros [v' [A B]]. congruence. *)
+(* Qed. *)
+
+(* Lemma bool_val_match: *)
+(*   forall v ty b v' m, *)
+(*   bool_val v ty Mem.empty = Some b -> *)
+(*   Val.inject inj v v' -> *)
+(*   bool_val v' ty m = Some b. *)
+(* Proof. *)
+(*   intros. eapply bool_val_inj; eauto. intros. rewrite mem_empty_not_weak_valid_pointer in H2; discriminate. *)
+(* Qed. *)
+
+(* (** Soundness of [constval] with respect to the big-step semantics *) *)
+
+(* Lemma constval_rvalue: *)
+(*   forall m a v, *)
+(*   eval_simple_rvalue empty_env m a v -> *)
+(*   forall v', *)
+(*   constval ge a = OK v' -> *)
+(*   Val.inject inj v' v *)
+(* with constval_lvalue: *)
+(*   forall m a b ofs, *)
+(*   eval_simple_lvalue empty_env m a b ofs -> *)
+(*   forall v', *)
+(*   constval ge a = OK v' -> *)
+(*   Val.inject inj v' (Vptr b ofs). *)
+(* Proof. *)
+(*   (* rvalue *) *)
+(*   induction 1; intros vres CV; simpl in CV; try (monadInv CV). *)
+(*   (* val *) *)
+(*   destruct v; monadInv CV; constructor. *)
+(*   (* rval *) *)
+(*   inv H1; rewrite H2 in CV; try congruence. eauto. eauto. *)
+(*   (* addrof *) *)
+(*   eauto. *)
+(*   (* unop *) *)
+(*   destruct (sem_unary_operation op x (typeof r1) Mem.empty) as [v1'|] eqn:E; inv EQ0. *)
+(*   exploit (sem_unary_operation_inj inj Mem.empty m). *)
+(*   intros. rewrite mem_empty_not_weak_valid_pointer in H2; discriminate. *)
+(*   eexact E. eauto. *)
+(*   intros [v' [A B]]. congruence. *)
+(*   (* binop *) *)
+(*   destruct (sem_binary_operation ge op x (typeof r1) x0 (typeof r2) Mem.empty) as [v1'|] eqn:E; inv EQ2. *)
+(*   exploit (sem_binary_operation_inj inj Mem.empty m). *)
+(*   intros. rewrite mem_empty_not_valid_pointer in H3; discriminate. *)
+(*   intros. rewrite mem_empty_not_weak_valid_pointer in H3; discriminate. *)
+(*   intros. rewrite mem_empty_not_weak_valid_pointer in H3; discriminate. *)
+(*   intros. rewrite mem_empty_not_valid_pointer in H3; discriminate. *)
+(*   eauto. eauto. eauto. *)
+(*   intros [v' [A B]]. congruence. *)
+(*   (* cast *) *)
+(*   eapply sem_cast_match; eauto. *)
+(*   (* sizeof *) *)
+(*   auto. *)
+(*   (* alignof *) *)
+(*   auto. *)
+(*   (* seqand *) *)
+(*   destruct (bool_val x (typeof r1) Mem.empty) as [b|] eqn:E; inv EQ2. *)
+(*   exploit bool_val_match. eexact E. eauto. instantiate (1 := m). intros E'. *)
+(*   assert (b = true) by congruence. subst b. *)
+(*   eapply sem_cast_match; eauto. *)
+(*   destruct (bool_val x (typeof r1) Mem.empty) as [b|] eqn:E; inv EQ2. *)
+(*   exploit bool_val_match. eexact E. eauto. instantiate (1 := m). intros E'. *)
+(*   assert (b = false) by congruence. subst b. inv H2. auto. *)
+(*   (* seqor *) *)
+(*   destruct (bool_val x (typeof r1) Mem.empty) as [b|] eqn:E; inv EQ2. *)
+(*   exploit bool_val_match. eexact E. eauto. instantiate (1 := m). intros E'. *)
+(*   assert (b = false) by congruence. subst b. *)
+(*   eapply sem_cast_match; eauto. *)
+(*   destruct (bool_val x (typeof r1) Mem.empty) as [b|] eqn:E; inv EQ2. *)
+(*   exploit bool_val_match. eexact E. eauto. instantiate (1 := m). intros E'. *)
+(*   assert (b = true) by congruence. subst b. inv H2. auto. *)
+(*   (* conditional *) *)
+(*   destruct (bool_val x (typeof r1) Mem.empty) as [b'|] eqn:E; inv EQ3. *)
+(*   exploit bool_val_match. eexact E. eauto. instantiate (1 := m). intros E'. *)
+(*   assert (b' = b) by congruence. subst b'. *)
+(*   destruct b; eapply sem_cast_match; eauto. *)
+(*   (* comma *) *)
+(*   auto. *)
+(*   (* paren *) *)
+(*   eapply sem_cast_match; eauto. *)
+
+(*   (* lvalue *) *)
+(*   induction 1; intros v' CV; simpl in CV; try (monadInv CV). *)
+(*   (* var local *) *)
+(*   unfold empty_env in H. rewrite PTree.gempty in H. congruence. *)
+(*   (* var_global *) *)
+(*   econstructor. unfold inj. rewrite H0. eauto. auto. *)
+(*   (* deref *) *)
+(*   eauto. *)
+(*   (* field struct *) *)
+(*   rewrite H0 in CV. monadInv CV. unfold lookup_composite in EQ; rewrite H1 in EQ; monadInv EQ. *)
+(*   exploit constval_rvalue; eauto. intro MV. inv MV. *)
+(*   replace x0 with delta by congruence. rewrite Ptrofs.add_assoc. rewrite (Ptrofs.add_commut (Ptrofs.repr delta0)). *)
+(*   simpl; destruct Archi.ptr64 eqn:SF; *)
+(*   econstructor; eauto; rewrite ! Ptrofs.add_assoc; f_equal; f_equal; symmetry; auto with ptrofs. *)
+(*   destruct Archi.ptr64; auto. *)
+(*   (* field union *) *)
+(*   rewrite H0 in CV. eauto. *)
+(* Qed. *)
+
+(* Lemma constval_simple: *)
+(*   forall a v, constval ge a = OK v -> simple a. *)
+(* Proof. *)
+(*   induction a; simpl; intros vx CV; try (monadInv CV); eauto. *)
+(*   destruct (typeof a); discriminate || eauto. *)
+(*   monadInv CV. eauto. *)
+(*   destruct (access_mode ty); discriminate || eauto. *)
+(*   intuition eauto. *)
+(* Qed. *)
+
+(* (** Soundness of [constval] with respect to the reduction semantics. *) *)
+
+(* Theorem constval_steps: *)
+(*   forall f r m v v' ty m', *)
+(*   star step ge (ExprState f r Kstop empty_env m) E0 (ExprState f (Eval v' ty) Kstop empty_env m') -> *)
+(*   constval ge r = OK v -> *)
+(*   m' = m /\ ty = typeof r /\ Val.inject inj v v'. *)
+(* Proof. *)
+(*   intros. exploit eval_simple_steps; eauto. eapply constval_simple; eauto. *)
+(*   intros [A [B C]]. intuition. eapply constval_rvalue; eauto. *)
+(* Qed. *)
+
+(* (** * Relational specification of the translation of initializers *) *)
+
+(* Definition tr_padding (frm to: Z) : list init_data := *)
+(*   if zlt frm to then Init_space (to - frm) :: nil else nil. *)
+
+(* Inductive tr_init: type -> initializer -> list init_data -> Prop := *)
+(*   | tr_init_sgl: forall ty a d, *)
+(*       transl_init_single ge ty a = OK d -> *)
+(*       tr_init ty (Init_single a) (d :: nil) *)
+(*   | tr_init_arr: forall tyelt nelt attr il d, *)
+(*       tr_init_array tyelt il (Z.max 0 nelt) d -> *)
+(*       tr_init (Tarray tyelt nelt attr) (Init_array il) d *)
+(*   | tr_init_str: forall id attr il co d, *)
+(*       lookup_composite ge id = OK co -> co_su co = Struct -> *)
+(*       tr_init_struct (Tstruct id attr) (co_members co) il 0 d -> *)
+(*       tr_init (Tstruct id attr) (Init_struct il) d *)
+(*   | tr_init_uni: forall id attr f i1 co ty1 d, *)
+(*       lookup_composite ge id = OK co -> co_su co = Union -> field_type f (co_members co) = OK ty1 -> *)
+(*       tr_init ty1 i1 d -> *)
+(*       tr_init (Tunion id attr) (Init_union f i1) *)
+(*               (d ++ tr_padding (sizeof ge ty1) (sizeof ge (Tunion id attr))) *)
+
+(* with tr_init_array: type -> initializer_list -> Z -> list init_data -> Prop := *)
+(*   | tr_init_array_nil_0: forall ty, *)
+(*       tr_init_array ty Init_nil 0 nil *)
+(*   | tr_init_array_nil_pos: forall ty sz, *)
+(*       0 < sz -> *)
+(*       tr_init_array ty Init_nil sz (Init_space (sz * sizeof ge ty) :: nil) *)
+(*   | tr_init_array_cons: forall ty i il sz d1 d2, *)
+(*       tr_init ty i d1 -> tr_init_array ty il (sz - 1) d2 -> *)
+(*       tr_init_array ty (Init_cons i il) sz (d1 ++ d2) *)
+
+(* with tr_init_struct: type -> members -> initializer_list -> Z -> list init_data -> Prop := *)
+(*   | tr_init_struct_nil: forall ty pos, *)
+(*       tr_init_struct ty nil Init_nil pos (tr_padding pos (sizeof ge ty)) *)
+(*   | tr_init_struct_cons: forall ty f1 ty1 fl i1 il pos d1 d2, *)
+(*       let pos1 := align pos (alignof ge ty1) in *)
+(*       tr_init ty1 i1 d1 -> *)
+(*       tr_init_struct ty fl il (pos1 + sizeof ge ty1) d2 -> *)
+(*       tr_init_struct ty ((f1, ty1) :: fl) (Init_cons i1 il) *)
+(*                      pos (tr_padding pos pos1 ++ d1 ++ d2). *)
+
+(* Lemma transl_padding_spec: *)
+(*   forall frm to k, padding frm to k = rev (tr_padding frm to) ++ k. *)
+(* Proof. *)
+(*   unfold padding, tr_padding; intros.  *)
+(*   destruct (zlt frm to); auto. *)
+(* Qed. *)
+
+(* Lemma transl_init_rec_spec: *)
+(*   forall i ty k res, *)
+(*   transl_init_rec ge ty i k = OK res -> *)
+(*   exists d, tr_init ty i d /\ res = rev d ++ k *)
+
+(* with transl_init_array_spec: *)
+(*   forall il ty sz k res, *)
+(*   transl_init_array ge ty il sz k = OK res -> *)
+(*   exists d, tr_init_array ty il sz d /\ res = rev d ++ k *)
+
+(* with transl_init_struct_spec: *)
+(*   forall il ty fl pos k res, *)
+(*   transl_init_struct ge ty fl il pos k = OK res -> *)
+(*   exists d, tr_init_struct ty fl il pos d /\ res = rev d ++ k. *)
+
+(* Proof. *)
+(* Local Opaque sizeof. *)
+(* - destruct i; intros until res; intros TR; simpl in TR. *)
+(* + monadInv TR. exists (x :: nil); split; auto. constructor; auto. *)
+(* + destruct ty; try discriminate. *)
+(*   destruct (transl_init_array_spec _ _ _ _ _ TR) as (d & A & B). *)
+(*   exists d; split; auto. constructor; auto. *)
+(* + destruct ty; try discriminate. monadInv TR. destruct (co_su x) eqn:SU; try discriminate. *)
+(*   destruct (transl_init_struct_spec _ _ _ _ _ _ EQ0) as (d & A & B). *)
+(*   exists d; split; auto. econstructor; eauto. *)
+(* + destruct ty; try discriminate. *)
+(*   monadInv TR. destruct (co_su x) eqn:SU; monadInv EQ0. *)
+(*   destruct (transl_init_rec_spec _ _ _ _ EQ0) as (d & A & B). *)
+(*   exists (d ++ tr_padding (sizeof ge x0) (sizeof ge (Tunion i0 a))); split. *)
+(*   econstructor; eauto. *)
+(*   rewrite rev_app_distr, app_ass, B. apply transl_padding_spec.  *)
+
+(* - destruct il; intros until res; intros TR; simpl in TR. *)
+(* + destruct (zeq sz 0).  *)
+(*   inv TR. exists (@nil init_data); split; auto. constructor. *)
+(*   destruct (zle 0 sz). *)
+(*   inv TR. econstructor; split. constructor. lia. auto. *)
+(*   discriminate. *)
+(* + monadInv TR.  *)
+(*   destruct (transl_init_rec_spec _ _ _ _ EQ) as (d1 & A1 & B1). *)
+(*   destruct (transl_init_array_spec _ _ _ _ _ EQ0) as (d2 & A2 & B2). *)
+(*   exists (d1 ++ d2); split. econstructor; eauto.  *)
+(*   subst res x. rewrite rev_app_distr, app_ass. auto. *)
+
+(* - destruct il; intros until res; intros TR; simpl in TR. *)
+(* + destruct fl; inv TR. econstructor; split. constructor. apply transl_padding_spec. *)
+(* + destruct fl as [ | [f1 ty1] fl ]; monadInv TR. *)
+(*   destruct (transl_init_rec_spec _ _ _ _ EQ) as (d1 & A1 & B1). *)
+(*   destruct (transl_init_struct_spec _ _ _ _ _ _ EQ0) as (d2 & A2 & B2). *)
+(*   exists (tr_padding pos (align pos (alignof ge ty1)) ++ d1 ++ d2); split. *)
+(*   econstructor; eauto. *)
+(*   rewrite ! rev_app_distr. subst res x. rewrite ! app_ass. rewrite transl_padding_spec. auto. *)
+(* Qed. *)
+
+(* Theorem transl_init_spec: *)
+(*   forall ty i d, transl_init ge ty i = OK d -> tr_init ty i d. *)
+(* Proof. *)
+(*   unfold transl_init; intros. monadInv H.  *)
+(*   exploit transl_init_rec_spec; eauto. intros (d & A & B).  *)
+(*   subst x. unfold rev'; rewrite <- rev_alt.  *)
+(*   rewrite rev_app_distr; simpl. rewrite rev_involutive. auto. *)
+(* Qed. *)
+
+(* (** * Soundness of the translation of initializers *) *)
+
+(* (** Soundness for single initializers. *) *)
+
+(* Theorem transl_init_single_steps: *)
+(*   forall ty a data f m v1 ty1 m' v chunk b ofs m'', *)
+(*   transl_init_single ge ty a = OK data -> *)
+(*   star step ge (ExprState f a Kstop empty_env m) E0 (ExprState f (Eval v1 ty1) Kstop empty_env m') -> *)
+(*   sem_cast v1 ty1 ty m' = Some v -> *)
+(*   access_mode ty = By_value chunk -> *)
+(*   Mem.store chunk m' b ofs v = Some m'' -> *)
+(*   Genv.store_init_data ge m b ofs data = Some m''. *)
+(* Proof. *)
+(*   intros. monadInv H. monadInv EQ.  *)
+(*   exploit constval_steps; eauto. intros [A [B C]]. subst m' ty1. *)
+(*   exploit sem_cast_match; eauto. intros D. *)
+(*   unfold Genv.store_init_data. *)
+(*   inv D. *)
+(* - (* int *) *)
+(*   remember Archi.ptr64 as ptr64.  destruct ty; try discriminate EQ0. *)
+(* + destruct i0; inv EQ0. *)
+(*   destruct s; simpl in H2; inv H2. rewrite <- Mem.store_signed_unsigned_8; auto. auto. *)
+(*   destruct s; simpl in H2; inv H2. rewrite <- Mem.store_signed_unsigned_16; auto. auto. *)
+(*   simpl in H2; inv H2. assumption. *)
+(*   simpl in H2; inv H2. assumption. *)
+(* + destruct ptr64; inv EQ0. simpl in H2; unfold Mptr in H2; rewrite <- Heqptr64 in H2; inv H2. assumption. *)
+(* - (* Long *) *)
+(*   remember Archi.ptr64 as ptr64. destruct ty; inv EQ0. *)
+(* + simpl in H2; inv H2. assumption. *)
+(* + simpl in H2; unfold Mptr in H2; destruct Archi.ptr64; inv H4.  *)
+(*   inv H2; assumption. *)
+(* - (* float *) *)
+(*   destruct ty; try discriminate. *)
+(*   destruct f1; inv EQ0; simpl in H2; inv H2; assumption. *)
+(* - (* single *) *)
+(*   destruct ty; try discriminate. *)
+(*   destruct f1; inv EQ0; simpl in H2; inv H2; assumption. *)
+(* - (* pointer *) *)
+(*   unfold inj in H. *)
+(*   assert (data = Init_addrof b1 ofs1 /\ chunk = Mptr). *)
+(*   { remember Archi.ptr64 as ptr64. *)
+(*     destruct ty; inversion EQ0. *)
+(*     destruct i; inv H5. unfold Mptr. destruct Archi.ptr64; inv H6; inv H2; auto. *)
+(*     subst ptr64. unfold Mptr. destruct Archi.ptr64; inv H5; inv H2; auto. *)
+(*     inv H2. auto. } *)
+(*   destruct H4; subst. destruct (Genv.find_symbol ge b1); inv H. *)
+(*   rewrite Ptrofs.add_zero in H3. auto. *)
+(* - (* undef *) *)
+(*   discriminate. *)
+(* Qed. *)
+
+(* (** Size properties for initializers. *) *)
+
+(* Lemma transl_init_single_size: *)
+(*   forall ty a data, *)
+(*   transl_init_single ge ty a = OK data -> *)
+(*   init_data_size data = sizeof ge ty. *)
+(* Proof. *)
+(*   intros. monadInv H. monadInv EQ. remember Archi.ptr64 as ptr64. destruct x. *)
+(* - monadInv EQ0. *)
+(* - destruct ty; try discriminate. *)
+(*   destruct i0; inv EQ0; auto. *)
+(*   destruct ptr64; inv EQ0.  *)
+(* Local Transparent sizeof. *)
+(*   unfold sizeof. rewrite <- Heqptr64; auto. *)
+(* - destruct ty; inv EQ0; auto.  *)
+(*   unfold sizeof. destruct Archi.ptr64; inv H0; auto. *)
+(* - destruct ty; try discriminate. *)
+(*   destruct f0; inv EQ0; auto. *)
+(* - destruct ty; try discriminate. *)
+(*   destruct f0; inv EQ0; auto. *)
+(* - destruct ty; try discriminate. *)
+(*   destruct i0; inv EQ0; auto. *)
+(*   destruct Archi.ptr64 eqn:SF; inv H0. simpl. rewrite SF; auto. *)
+(*   destruct ptr64; inv EQ0. simpl. rewrite <- Heqptr64; auto. *)
+(*   inv EQ0. unfold init_data_size, sizeof. auto. *)
+(* Qed. *)
+
+(* Notation idlsize := init_data_list_size. *)
+
+(* Remark padding_size: *)
+(*   forall frm to, frm <= to -> idlsize (tr_padding frm to) = to - frm. *)
+(* Proof. *)
+(*   unfold tr_padding; intros. destruct (zlt frm to). *)
+(*   simpl. extlia. *)
+(*   simpl. lia. *)
+(* Qed. *)
+
+(* Remark idlsize_app: *)
+(*   forall d1 d2, idlsize (d1 ++ d2) = idlsize d1 + idlsize d2. *)
+(* Proof. *)
+(*   induction d1; simpl; intros. *)
+(*   auto. *)
+(*   rewrite IHd1. lia. *)
+(* Qed. *)
+
+(* Remark union_field_size: *)
+(*   forall f ty fl, field_type f fl = OK ty -> sizeof ge ty <= sizeof_union ge fl. *)
+(* Proof. *)
+(*   induction fl as [|[i t]]; simpl; intros. *)
+(* - inv H. *)
+(* - destruct (ident_eq f i). *)
+(*   + inv H. extlia. *)
+(*   + specialize (IHfl H). extlia. *)
+(* Qed. *)
+
+(* Hypothesis ce_consistent: composite_env_consistent ge. *)
+
+(* Lemma tr_init_size: *)
+(*   forall i ty data, *)
+(*   tr_init ty i data -> *)
+(*   idlsize data = sizeof ge ty *)
+(* with tr_init_array_size: *)
+(*   forall ty il sz data, *)
+(*   tr_init_array ty il sz data -> *)
+(*   idlsize data = sizeof ge ty * sz *)
+(* with tr_init_struct_size: *)
+(*   forall ty fl il pos data, *)
+(*   tr_init_struct ty fl il pos data -> *)
+(*   sizeof_struct ge pos fl <= sizeof ge ty -> *)
+(*   idlsize data + pos = sizeof ge ty. *)
+(* Proof. *)
+(* Local Opaque sizeof. *)
+(* - destruct 1; simpl. *)
+(* + erewrite transl_init_single_size by eauto. lia. *)
+(* + Local Transparent sizeof. simpl. eapply tr_init_array_size; eauto.  *)
+(* + replace (idlsize d) with (idlsize d + 0) by lia. *)
+(*   eapply tr_init_struct_size; eauto. simpl. *)
+(*   unfold lookup_composite in H. destruct (ge.(genv_cenv)!id) as [co'|] eqn:?; inv H. *)
+(*   erewrite co_consistent_sizeof by (eapply ce_consistent; eauto). *)
+(*   unfold sizeof_composite. rewrite H0. apply align_le. *)
+(*   destruct (co_alignof_two_p co) as [n EQ]. rewrite EQ. apply two_power_nat_pos. *)
+(* + rewrite idlsize_app, padding_size.  *)
+(*   exploit tr_init_size; eauto. intros EQ; rewrite EQ. lia. *)
+(*   simpl. unfold lookup_composite in H. destruct (ge.(genv_cenv)!id) as [co'|] eqn:?; inv H. *)
+(*   apply Z.le_trans with (sizeof_union ge (co_members co)). *)
+(*   eapply union_field_size; eauto. *)
+(*   erewrite co_consistent_sizeof by (eapply ce_consistent; eauto). *)
+(*   unfold sizeof_composite. rewrite H0. apply align_le. *)
+(*   destruct (co_alignof_two_p co) as [n EQ]. rewrite EQ. apply two_power_nat_pos. *)
+
+(* - destruct 1; simpl. *)
+(* + lia. *)
+(* + rewrite Z.mul_comm. *)
+(*   assert (0 <= sizeof ge ty * sz). *)
+(*   { apply Zmult_gt_0_le_0_compat. lia. generalize (sizeof_pos ge ty); lia. } *)
+(*   extlia. *)
+(* + rewrite idlsize_app.  *)
+(*   erewrite tr_init_size by eauto.  *)
+(*   erewrite tr_init_array_size by eauto. *)
+(*   ring. *)
+
+(* - destruct 1; simpl; intros. *)
+(* + rewrite padding_size by auto. lia. *)
+(* + rewrite ! idlsize_app, padding_size.  *)
+(*   erewrite tr_init_size by eauto.  *)
+(*   rewrite <- (tr_init_struct_size _ _ _ _ _ H0 H1). lia. *)
+(*   unfold pos1. apply align_le. apply alignof_pos.  *)
+(* Qed. *)
+
+(* (** A semantics for general initializers *) *)
+
+(* Definition dummy_function := mkfunction Tvoid cc_default nil nil Sskip. *)
+
+(* Fixpoint fields_of_struct (fl: members) (pos: Z) : list (Z * type) := *)
+(*   match fl with *)
+(*   | nil => nil *)
+(*   | (id1, ty1) :: fl' => *)
+(*       (align pos (alignof ge ty1), ty1) :: fields_of_struct fl' (align pos (alignof ge ty1) + sizeof ge ty1) *)
+(*   end. *)
+
+(* Inductive exec_init: mem -> block -> Z -> type -> initializer -> mem -> Prop := *)
+(*   | exec_init_single: forall m b ofs ty a v1 ty1 chunk m' v m'', *)
+(*       star step ge (ExprState dummy_function a Kstop empty_env m) *)
+(*                 E0 (ExprState dummy_function (Eval v1 ty1) Kstop empty_env m') -> *)
+(*       sem_cast v1 ty1 ty m' = Some v -> *)
+(*       access_mode ty = By_value chunk -> *)
+(*       Mem.store chunk m' b ofs v = Some m'' -> *)
+(*       exec_init m b ofs ty (Init_single a) m'' *)
+(*   | exec_init_array_: forall m b ofs ty sz a il m', *)
+(*       exec_init_array m b ofs ty sz il m' -> *)
+(*       exec_init m b ofs (Tarray ty sz a) (Init_array il) m' *)
+(*   | exec_init_struct: forall m b ofs id a il co m', *)
+(*       ge.(genv_cenv)!id = Some co -> co_su co = Struct -> *)
+(*       exec_init_list m b ofs (fields_of_struct (co_members co) 0) il m' -> *)
+(*       exec_init m b ofs (Tstruct id a) (Init_struct il) m' *)
+(*   | exec_init_union: forall m b ofs id a f i ty co m', *)
+(*       ge.(genv_cenv)!id = Some co -> co_su co = Union -> *)
+(*       field_type f (co_members co) = OK ty -> *)
+(*       exec_init m b ofs ty i m' -> *)
+(*       exec_init m b ofs (Tunion id a) (Init_union f i) m' *)
+
+(* with exec_init_array: mem -> block -> Z -> type -> Z -> initializer_list -> mem -> Prop := *)
+(*   | exec_init_array_nil: forall m b ofs ty sz, *)
+(*       sz >= 0 -> *)
+(*       exec_init_array m b ofs ty sz Init_nil m *)
+(*   | exec_init_array_cons: forall m b ofs ty sz i1 il m' m'', *)
+(*       exec_init m b ofs ty i1 m' -> *)
+(*       exec_init_array m' b (ofs + sizeof ge ty) ty (sz - 1) il m'' -> *)
+(*       exec_init_array m b ofs ty sz (Init_cons i1 il) m'' *)
+
+(* with exec_init_list: mem -> block -> Z -> list (Z * type) -> initializer_list -> mem -> Prop := *)
+(*   | exec_init_list_nil: forall m b ofs, *)
+(*       exec_init_list m b ofs nil Init_nil m *)
+(*   | exec_init_list_cons: forall m b ofs pos ty l i1 il m' m'', *)
+(*       exec_init m b (ofs + pos) ty i1 m' -> *)
+(*       exec_init_list m' b ofs l il m'' -> *)
+(*       exec_init_list m b ofs ((pos, ty) :: l) (Init_cons i1 il) m''. *)
+
+(* Scheme exec_init_ind3 := Minimality for exec_init Sort Prop *)
+(*   with exec_init_array_ind3 := Minimality for exec_init_array Sort Prop *)
+(*   with exec_init_list_ind3 := Minimality for exec_init_list Sort Prop. *)
+(* Combined Scheme exec_init_scheme from exec_init_ind3, exec_init_array_ind3, exec_init_list_ind3. *)
+
+(* Remark exec_init_array_length: *)
+(*   forall m b ofs ty sz il m', *)
+(*   exec_init_array m b ofs ty sz il m' -> sz >= 0. *)
+(* Proof. *)
+(*   induction 1; lia. *)
+(* Qed. *)
+
+(* Lemma store_init_data_list_app: *)
+(*   forall data1 m b ofs m' data2 m'', *)
+(*   Genv.store_init_data_list ge m b ofs data1 = Some m' -> *)
+(*   Genv.store_init_data_list ge m' b (ofs + idlsize data1) data2 = Some m'' -> *)
+(*   Genv.store_init_data_list ge m b ofs (data1 ++ data2) = Some m''. *)
+(* Proof. *)
+(*   induction data1; simpl; intros. *)
+(*   inv H. rewrite Z.add_0_r in H0. auto. *)
+(*   destruct (Genv.store_init_data ge m b ofs a); try discriminate. *)
+(*   rewrite Z.add_assoc in H0. eauto. *)
+(* Qed. *)
+
+(* Remark store_init_data_list_padding: *)
+(*   forall frm to b ofs m, *)
+(*   Genv.store_init_data_list ge m b ofs (tr_padding frm to) = Some m. *)
+(* Proof. *)
+(*   intros. unfold tr_padding. destruct (zlt frm to); auto. *)
+(* Qed. *)
+
+(* Lemma tr_init_sound: *)
+(*   (forall m b ofs ty i m', exec_init m b ofs ty i m' -> *)
+(*    forall data, tr_init ty i data -> *)
+(*    Genv.store_init_data_list ge m b ofs data = Some m') *)
+(* /\(forall m b ofs ty sz il m', exec_init_array m b ofs ty sz il m' -> *)
+(*    forall data, tr_init_array ty il sz data -> *)
+(*    Genv.store_init_data_list ge m b ofs data = Some m') *)
+(* /\(forall m b ofs l il m', exec_init_list m b ofs l il m' -> *)
+(*    forall ty fl data pos, *)
+(*    l = fields_of_struct fl pos -> *)
+(*    tr_init_struct ty fl il pos data -> *)
+(*    Genv.store_init_data_list ge m b (ofs + pos) data = Some m'). *)
+(* Proof. *)
+(* Local Opaque sizeof. *)
+(*   apply exec_init_scheme; simpl; intros. *)
+(* - (* single *) *)
+(*   inv H3. simpl. erewrite transl_init_single_steps by eauto. auto. *)
+(* - (* array *) *)
+(*   inv H1. replace (Z.max 0 sz) with sz in H7. eauto. *)
+(*   assert (sz >= 0) by (eapply exec_init_array_length; eauto). extlia. *)
+(* - (* struct *) *)
+(*   inv H3. unfold lookup_composite in H7. rewrite H in H7. inv H7.  *)
+(*   replace ofs with (ofs + 0) by lia. eauto. *)
+(* - (* union *) *)
+(*   inv H4. unfold lookup_composite in H9. rewrite H in H9. inv H9. rewrite H1 in H12; inv H12.  *)
+(*   eapply store_init_data_list_app. eauto. *)
+(*   apply store_init_data_list_padding. *)
+
+(* - (* array, empty *) *)
+(*   inv H0; auto. *)
+(* - (* array, nonempty *) *)
+(*   inv H3. *)
+(*   eapply store_init_data_list_app. *)
+(*   eauto. *)
+(*   rewrite (tr_init_size _ _ _ H7). eauto. *)
+
+(* - (* struct, empty *) *)
+(*   inv H0. apply store_init_data_list_padding. *)
+(* - (* struct, nonempty *) *)
+(*   inv H4. simpl in H3; inv H3.  *)
+(*   eapply store_init_data_list_app. apply store_init_data_list_padding. *)
+(*   rewrite padding_size. *)
+(*   replace (ofs + pos0 + (pos2 - pos0)) with (ofs + pos2) by lia. *)
+(*   eapply store_init_data_list_app. *)
+(*   eauto. *)
+(*   rewrite (tr_init_size _ _ _ H9). *)
+(*   rewrite <- Z.add_assoc. eapply H2. eauto. eauto. *)
+(*   apply align_le. apply alignof_pos. *)
+(* Qed. *)
+
+(* End SOUNDNESS. *)
+
+(* Theorem transl_init_sound: *)
+(*   forall p m b ty i m' data, *)
+(*   exec_init (globalenv p) m b 0 ty i m' -> *)
+(*   transl_init (prog_comp_env p) ty i = OK data -> *)
+(*   Genv.store_init_data_list (globalenv p) m b 0 data = Some m'. *)
+(* Proof. *)
+(*   intros. *)
+(*   set (ge := globalenv p) in *. *)
+(*   change (prog_comp_env p) with (genv_cenv ge) in H0. *)
+(*   destruct (tr_init_sound ge) as (A & B & C). *)
+(*   eapply build_composite_env_consistent. apply prog_comp_env_eq. *)
+(*   eapply A; eauto. apply transl_init_spec; auto. *)
+(* Qed. *)
diff --git a/cfrontend/SimplExpr.v b/cfrontend/SimplExpr.v
index c7e57a54..0855669c 100644
--- a/cfrontend/SimplExpr.v
+++ b/cfrontend/SimplExpr.v
@@ -105,10 +105,13 @@ Fixpoint eval_simpl_expr (a: expr) : option val :=
   | Econst_single n _ => Some(Vsingle n)
   | Econst_long n _ => Some(Vlong n)
   | Ecast b ty =>
-      match eval_simpl_expr b with
-      | None => None
-      | Some v => sem_cast v (typeof b) ty Mem.empty
-      end
+      if simple_cast (typeof b) ty
+      then
+        match eval_simpl_expr b with
+        | None => None
+        | Some v => sem_cast v (typeof b) ty Mem.empty
+        end
+      else None
   | _ => None
   end.
 
@@ -160,6 +163,10 @@ Definition make_set (id: ident) (l: expr) : statement :=
       Sbuiltin (Some id) (EF_vload chunk) (Tcons typtr Tnil) ((Eaddrof l typtr):: nil)
   end.
 
+(* make capture. input type is Void* *)
+Definition make_intptr_cast (id:ident) (r: expr) : list statement :=
+  Sbuiltin (Some id) EF_capture (Tcons (Tpointer Tvoid noattr) Tnil) (r::nil) :: nil.
+
 (** Translation of a "valof" operation.
   If the l-value accessed is of volatile type, we go through a temporary. *)
 
@@ -227,6 +234,25 @@ Definition sd_seqbool_val (tmp: ident) (ty: type) :=
 Definition sd_seqbool_set (ty: type) (sd: set_destination) :=
   let tmp :=  sd_temp sd in SDcons type_bool ty tmp sd.
 
+(* printf has longer typelist than exprlist *)
+Fixpoint capture_args (el:list expr) (tyl:typelist) : mon (list statement * list expr) :=
+  match el with
+  | nil => ret (nil, nil)
+  | e :: el'=> match tyl with
+             | Tnil => do (sl, al) <- capture_args el' Tnil; ret (sl, e::al)
+                 
+             (* error (msg "Error: capture. exprlist is longer than typelist") *)
+             | Tcons ty tyl' =>
+                 (do (sl, al) <- capture_args el' tyl';
+                  if simple_cast (typeof e) ty
+                  then
+                    ret (sl, e::al)
+                  else
+                    do t <- gensym (typeof e);
+                    ret (make_intptr_cast t e ++ sl, (Etempvar t (typeof e)) :: al))
+             end
+  end.
+
 Fixpoint transl_expr (dst: destination) (a: Csyntax.expr) : mon (list statement * expr) :=
   match a with
   | Csyntax.Eloc b ofs ty =>
@@ -268,6 +294,9 @@ Fixpoint transl_expr (dst: destination) (a: Csyntax.expr) : mon (list statement
       do (sl2, a2) <- transl_expr For_val r2;
       ret (finish dst (sl1 ++ sl2) (Ebinop op a1 a2 ty))
   | Csyntax.Ecast r1 ty =>
+      if simple_cast (Csyntax.typeof r1) ty
+      then
+      (* simple cast *)
       match dst with
       | For_val | For_set _ =>
           do (sl1, a1) <- transl_expr For_val r1;
@@ -275,6 +304,19 @@ Fixpoint transl_expr (dst: destination) (a: Csyntax.expr) : mon (list statement
       | For_effects =>
           transl_expr For_effects r1
       end
+      else
+      (* non simple cast *)
+      match dst with
+      | For_val | For_set _ =>
+          do (sl1, a1) <- transl_expr For_val r1;
+          do t <- gensym (typeof a1);
+          ret (finish dst (sl1 ++ make_intptr_cast t a1)
+                          (Etempvar t ty))
+      | For_effects =>
+          do (sl1, a1) <- transl_expr For_val r1;
+          do t <- gensym (typeof a1);
+          ret (sl1 ++ make_intptr_cast t a1, a1)
+      end        
   | Csyntax.Eseqand r1 r2 ty =>
       do (sl1, a1) <- transl_expr For_val r1;
       match dst with
@@ -337,6 +379,8 @@ Fixpoint transl_expr (dst: destination) (a: Csyntax.expr) : mon (list statement
       do (sl2, a2) <- transl_expr For_val r2;
       let ty1 := Csyntax.typeof l1 in
       let ty2 := Csyntax.typeof r2 in
+      if (simple_cast (typeof a2) ty1)
+      then
       match dst with
       | For_val | For_set _ =>
           do t <- gensym ty1;
@@ -347,11 +391,26 @@ Fixpoint transl_expr (dst: destination) (a: Csyntax.expr) : mon (list statement
           ret (sl1 ++ sl2 ++ make_assign a1 a2 :: nil,
                dummy_expr)
       end
+      else
+        match dst with
+        | For_val | For_set _ =>
+            do t1 <- gensym (typeof a2);
+            do t2 <- gensym ty1;
+            ret (finish dst
+                   (sl1 ++ sl2 ++ make_intptr_cast t1 a2 ++
+                      Sset t2 (Ecast (Etempvar t1 (typeof a2)) ty1) :: make_assign a1 (Etempvar t2 ty1) :: nil)
+                   (Etempvar t2 ty1))
+        | For_effects =>
+            do t <- gensym (typeof a2);
+            ret (sl1 ++ sl2 ++ make_intptr_cast t a2 ++ make_assign a1 (Etempvar t (typeof a2)) :: nil,
+                 dummy_expr)
+        end 
   | Csyntax.Eassignop op l1 r2 tyres ty =>
       let ty1 := Csyntax.typeof l1 in
       do (sl1, a1) <- transl_expr For_val l1;
       do (sl2, a2) <- transl_expr For_val r2;
       do (sl3, a3) <- transl_valof ty1 a1;
+      if simple_cast tyres ty1 then
       match dst with
       | For_val | For_set _ =>
           do t <- gensym ty1;
@@ -364,6 +423,21 @@ Fixpoint transl_expr (dst: destination) (a: Csyntax.expr) : mon (list statement
           ret (sl1 ++ sl2 ++ sl3 ++ make_assign a1 (Ebinop op a3 a2 tyres) :: nil,
                dummy_expr)
       end
+      else
+      match dst with
+      | For_val | For_set _ =>
+          do t1 <- gensym tyres;
+          do t2 <- gensym ty1;
+          ret (finish dst
+                 (sl1 ++ sl2 ++ sl3 ++ make_intptr_cast t1 (Ebinop op a3 a2 tyres) ++
+                  Sset t2 (Ecast (Etempvar t1 tyres) ty1) ::
+                  make_assign a1 (Etempvar t2 ty1) :: nil)
+                 (Etempvar t2 ty1))
+      | For_effects =>
+          do t <- gensym tyres;
+          ret (sl1 ++ sl2 ++ sl3 ++ make_intptr_cast t (Ebinop op a3 a2 tyres) ++ make_assign a1 (Etempvar t tyres) :: nil,
+               dummy_expr)
+      end        
   | Csyntax.Epostincr id l1 ty =>
       let ty1 := Csyntax.typeof l1 in
       do (sl1, a1) <- transl_expr For_val l1;
@@ -384,6 +458,20 @@ Fixpoint transl_expr (dst: destination) (a: Csyntax.expr) : mon (list statement
       do (sl2, a2) <- transl_expr dst r2;
       ret (sl1 ++ sl2, a2)
   | Csyntax.Ecall r1 rl2 ty =>
+    match classify_fun (Csyntax.typeof r1) with
+    | fun_case_f targs tres cc =>
+      do (sl1, a1) <- transl_expr For_val r1;
+      do (sl2, al2) <- transl_exprlist rl2;
+      do (sl3, al3) <- capture_args al2 targs;
+      match dst with
+      | For_val | For_set _ =>
+          do t <- gensym ty;
+          ret (finish dst (sl1 ++ sl2 ++ sl3 ++ Scall (Some t) a1 al3 :: nil)
+                          (Etempvar t ty))
+      | For_effects =>
+          ret (sl1 ++ sl2 ++ sl3 ++ Scall None a1 al3 :: nil, dummy_expr)
+      end
+    | fun_default =>
       do (sl1, a1) <- transl_expr For_val r1;
       do (sl2, al2) <- transl_exprlist rl2;
       match dst with
@@ -394,15 +482,17 @@ Fixpoint transl_expr (dst: destination) (a: Csyntax.expr) : mon (list statement
       | For_effects =>
           ret (sl1 ++ sl2 ++ Scall None a1 al2 :: nil, dummy_expr)
       end
+    end
   | Csyntax.Ebuiltin ef tyargs rl ty =>
       do (sl, al) <- transl_exprlist rl;
+      do (sl', al') <- capture_args al tyargs;
       match dst with
       | For_val | For_set _ =>
           do t <- gensym ty;
-          ret (finish dst (sl ++ Sbuiltin (Some t) ef tyargs al :: nil)
+          ret (finish dst (sl ++ sl' ++ Sbuiltin (Some t) ef tyargs al' :: nil)
                           (Etempvar t ty))
       | For_effects =>
-          ret (sl ++ Sbuiltin None ef tyargs al :: nil, dummy_expr)
+          ret (sl ++ sl' ++ Sbuiltin None ef tyargs al' :: nil, dummy_expr)
       end
   | Csyntax.Eparen r1 tycast ty =>
       error (msg "SimplExpr.transl_expr: paren")
@@ -444,17 +534,17 @@ Proof.
   destruct s; ((left; reflexivity) || (right; congruence)).
 Defined.
 
-Fixpoint transl_stmt (s: Csyntax.statement) : mon statement :=
+Fixpoint transl_stmt (s: Csyntax.statement) (ty: type) : mon statement :=
   match s with
   | Csyntax.Sskip => ret Sskip
   | Csyntax.Sdo e => transl_expr_stmt e
   | Csyntax.Ssequence s1 s2 =>
-      do ts1 <- transl_stmt s1;
-      do ts2 <- transl_stmt s2;
+      do ts1 <- transl_stmt s1 ty;
+      do ts2 <- transl_stmt s2 ty;
       ret (Ssequence ts1 ts2)
   | Csyntax.Sifthenelse e s1 s2 =>
-      do ts1 <- transl_stmt s1;
-      do ts2 <- transl_stmt s2;
+      do ts1 <- transl_stmt s1 ty;
+      do ts2 <- transl_stmt s2 ty;
       do (s', a) <- transl_expression e;
       if is_Sskip s1 && is_Sskip s2 then
         ret (Ssequence s' Sskip)
@@ -462,17 +552,17 @@ Fixpoint transl_stmt (s: Csyntax.statement) : mon statement :=
         ret (Ssequence s' (Sifthenelse a ts1 ts2))
   | Csyntax.Swhile e s1 =>
       do s' <- transl_if e Sskip Sbreak;
-      do ts1 <- transl_stmt s1;
+      do ts1 <- transl_stmt s1 ty;
       ret (Sloop (Ssequence s' ts1) Sskip)
   | Csyntax.Sdowhile e s1 =>
       do s' <- transl_if e Sskip Sbreak;
-      do ts1 <- transl_stmt s1;
+      do ts1 <- transl_stmt s1 ty;
       ret (Sloop ts1 s')
   | Csyntax.Sfor s1 e2 s3 s4 =>
-      do ts1 <- transl_stmt s1;
+      do ts1 <- transl_stmt s1 ty;
       do s' <- transl_if e2 Sskip Sbreak;
-      do ts3 <- transl_stmt s3;
-      do ts4 <- transl_stmt s4;
+      do ts3 <- transl_stmt s3 ty;
+      do ts4 <- transl_stmt s4 ty;
       if is_Sskip s1 then
         ret (Sloop (Ssequence s' ts4) ts3)
       else
@@ -484,33 +574,40 @@ Fixpoint transl_stmt (s: Csyntax.statement) : mon statement :=
   | Csyntax.Sreturn None =>
       ret (Sreturn None)
   | Csyntax.Sreturn (Some e) =>
+      if simple_cast (Csyntax.typeof e) ty
+      then
+      (* simple cast *)      
       do (s', a) <- transl_expression e;
       ret (Ssequence s' (Sreturn (Some a)))
+      else
+      (* non simple cast *)
+      do (s', a) <- transl_expression (Csyntax.Ecast e ty);
+      ret (Ssequence s' (Sreturn (Some a)))          
   | Csyntax.Sswitch e ls =>
       do (s', a) <- transl_expression e;
-      do tls <- transl_lblstmt ls;
+      do tls <- transl_lblstmt ls ty;
       ret (Ssequence s' (Sswitch a tls))
   | Csyntax.Slabel lbl s1 =>
-      do ts1 <- transl_stmt s1;
+      do ts1 <- transl_stmt s1 ty;
       ret (Slabel lbl ts1)
   | Csyntax.Sgoto lbl =>
       ret (Sgoto lbl)
   end
 
-with transl_lblstmt (ls: Csyntax.labeled_statements) : mon labeled_statements :=
+with transl_lblstmt (ls: Csyntax.labeled_statements) (ty: type) : mon labeled_statements :=
   match ls with
   | Csyntax.LSnil =>
       ret LSnil
   | Csyntax.LScons c s ls1 =>
-      do ts <- transl_stmt s;
-      do tls1 <- transl_lblstmt ls1;
+      do ts <- transl_stmt s ty;
+      do tls1 <- transl_lblstmt ls1 ty;
       ret (LScons c ts tls1)
   end.
 
 (** Translation of a function *)
 
 Definition transl_function (f: Csyntax.function) : res function :=
-  match transl_stmt f.(Csyntax.fn_body) (initial_generator tt) with
+  match transl_stmt f.(Csyntax.fn_body) f.(Csyntax.fn_return) (initial_generator tt) with
   | Err msg =>
       Error msg
   | Res tbody g i =>
diff --git a/cfrontend/SimplExprproof.v b/cfrontend/SimplExprproof.v
index 2d059ddd..ca77616a 100644
--- a/cfrontend/SimplExprproof.v
+++ b/cfrontend/SimplExprproof.v
@@ -25,2307 +25,2312 @@ Definition match_prog (p: Csyntax.program) (tp: Clight.program) :=
     match_program (fun ctx f tf => tr_fundef f tf) eq p tp
  /\ prog_types tp = prog_types p.
 
-Lemma transf_program_match:
-  forall p tp, transl_program p = OK tp -> match_prog p tp.
-Proof.
-  unfold transl_program; intros. monadInv H. split; auto.
-  unfold program_of_program; simpl. destruct x; simpl.
-  eapply match_transform_partial_program_contextual. eexact EQ. 
-  intros. apply transl_fundef_spec; auto. 
-Qed.
-
-(** ** Semantic preservation *)
-
-Section PRESERVATION.
-
-Variable prog: Csyntax.program.
-Variable tprog: Clight.program.
-Hypothesis TRANSL: match_prog prog tprog.
-
-Let ge := Csem.globalenv prog.
-Let tge := Clight.globalenv tprog.
-
-(** Invariance properties. *)
-
-Lemma comp_env_preserved:
-  Clight.genv_cenv tge = Csem.genv_cenv ge.
-Proof.
-  simpl. destruct TRANSL. generalize (prog_comp_env_eq tprog) (prog_comp_env_eq prog). 
-  congruence.
-Qed.
-
-Lemma symbols_preserved:
-  forall (s: ident), Genv.find_symbol tge s = Genv.find_symbol ge s.
-Proof (Genv.find_symbol_match (proj1 TRANSL)).
-
-Lemma senv_preserved:
-  Senv.equiv ge tge.
-Proof (Genv.senv_match (proj1 TRANSL)).
-
-Lemma function_ptr_translated:
-  forall b f,
-  Genv.find_funct_ptr ge b = Some f ->
-  exists tf,
-  Genv.find_funct_ptr tge b = Some tf /\ tr_fundef f tf.
-Proof.
-  intros.
-  edestruct (Genv.find_funct_ptr_match (proj1 TRANSL)) as (ctx & tf & A & B & C); eauto.
-Qed.
-
-Lemma functions_translated:
-  forall v f,
-  Genv.find_funct ge v = Some f ->
-  exists tf,
-  Genv.find_funct tge v = Some tf /\ tr_fundef f tf.
-Proof.
-  intros.
-  edestruct (Genv.find_funct_match (proj1 TRANSL)) as (ctx & tf & A & B & C); eauto.
-Qed.
-
-Lemma type_of_fundef_preserved:
-  forall f tf, tr_fundef f tf ->
-  type_of_fundef tf = Csyntax.type_of_fundef f.
-Proof.
-  intros. inv H.
-  inv H0; simpl. unfold type_of_function, Csyntax.type_of_function. congruence.
-  auto.
-Qed.
-
-Lemma function_return_preserved:
-  forall f tf, tr_function f tf ->
-  fn_return tf = Csyntax.fn_return f.
-Proof.
-  intros. inv H; auto.
-Qed.
-
-(** Properties of smart constructors. *)
-
-Lemma eval_Ederef':
-  forall ge e le m a t l ofs,
-  eval_expr ge e le m a (Vptr l ofs) ->
-  eval_lvalue ge e le m (Ederef' a t) l ofs.
-Proof.
-  intros. unfold Ederef'; destruct a; auto using eval_Ederef.
-  destruct (type_eq t (typeof a)); auto using eval_Ederef.
-  inv H.
-- auto. 
-- inv H0.
-Qed.
-
-Lemma typeof_Ederef':
-  forall a t, typeof (Ederef' a t) = t.
-Proof.
-  unfold Ederef'; intros; destruct a; auto. destruct (type_eq t (typeof a)); auto. 
-Qed.
-
-Lemma eval_Eaddrof':
-  forall ge e le m a t l ofs,
-  eval_lvalue ge e le m a l ofs ->
-  eval_expr ge e le m (Eaddrof' a t) (Vptr l ofs).
-Proof.
-  intros. unfold Eaddrof'; destruct a; auto using eval_Eaddrof.
-  destruct (type_eq t (typeof a)); auto using eval_Eaddrof.
-  inv H; auto.
-Qed.
-
-Lemma typeof_Eaddrof':
-  forall a t, typeof (Eaddrof' a t) = t.
-Proof.
-  unfold Eaddrof'; intros; destruct a; auto. destruct (type_eq t (typeof a)); auto. 
-Qed.
-
-(** Translation of simple expressions. *)
-
-Lemma tr_simple_nil:
-  (forall le dst r sl a tmps, tr_expr le dst r sl a tmps ->
-   dst = For_val \/ dst = For_effects -> simple r = true -> sl = nil)
-/\(forall le rl sl al tmps, tr_exprlist le rl sl al tmps ->
-   simplelist rl = true -> sl = nil).
-Proof.
-  assert (A: forall dst a, dst = For_val \/ dst = For_effects -> final dst a = nil).
-    intros. destruct H; subst dst; auto.
-  apply tr_expr_exprlist; intros; simpl in *; try discriminate; auto.
-- rewrite H0; auto. simpl; auto.
-- rewrite H0; auto. simpl; auto.
-- destruct H1; congruence.
-- destruct (andb_prop _ _ H6). inv H1.
-    rewrite H0; eauto. simpl; auto.
-    unfold chunk_for_volatile_type in H9.
-    destruct (type_is_volatile (Csyntax.typeof e1)); simpl in H8; congruence.
-- rewrite H0; auto. simpl; auto.
-- rewrite H0; auto. simpl; auto.
-- destruct (andb_prop _ _ H7). rewrite H0; auto. rewrite H2; auto. simpl; auto.
-- rewrite H0; auto. simpl; auto.
-- destruct (andb_prop _ _ H6). rewrite H0; auto.
-Qed.
-
-Lemma tr_simple_expr_nil:
-  forall le dst r sl a tmps, tr_expr le dst r sl a tmps ->
-  dst = For_val \/ dst = For_effects -> simple r = true -> sl = nil.
-Proof (proj1 tr_simple_nil).
-
-Lemma tr_simple_exprlist_nil:
-  forall le rl sl al tmps, tr_exprlist le rl sl al tmps ->
-  simplelist rl = true -> sl = nil.
-Proof (proj2 tr_simple_nil).
-
-(** Translation of [deref_loc] and [assign_loc] operations. *)
-
-Remark deref_loc_translated:
-  forall ty m b ofs t v,
-  Csem.deref_loc ge ty m b ofs t v ->
-  match chunk_for_volatile_type ty with
-  | None => t = E0 /\ Clight.deref_loc ty m b ofs v
-  | Some chunk => volatile_load tge chunk m b ofs t v
-  end.
-Proof.
-  intros. unfold chunk_for_volatile_type. inv H.
-  (* By_value, not volatile *)
-  rewrite H1. split; auto. eapply deref_loc_value; eauto.
-  (* By_value, volatile *)
-  rewrite H0; rewrite H1. eapply volatile_load_preserved with (ge1 := ge); auto. apply senv_preserved.
-  (* By reference *)
-  rewrite H0. destruct (type_is_volatile ty); split; auto; eapply deref_loc_reference; eauto.
-  (* By copy *)
-  rewrite H0. destruct (type_is_volatile ty); split; auto; eapply deref_loc_copy; eauto.
-Qed.
-
-Remark assign_loc_translated:
-  forall ty m b ofs v t m',
-  Csem.assign_loc ge ty m b ofs v t m' ->
-  match chunk_for_volatile_type ty with
-  | None => t = E0 /\ Clight.assign_loc tge ty m b ofs v m'
-  | Some chunk => volatile_store tge chunk m b ofs v t m'
-  end.
-Proof.
-  intros. unfold chunk_for_volatile_type. inv H.
-  (* By_value, not volatile *)
-  rewrite H1. split; auto. eapply assign_loc_value; eauto.
-  (* By_value, volatile *)
-  rewrite H0; rewrite H1. eapply volatile_store_preserved with (ge1 := ge); auto. apply senv_preserved.
-  (* By copy *)
-  rewrite H0. rewrite <- comp_env_preserved in *.
-  destruct (type_is_volatile ty); split; auto; eapply assign_loc_copy; eauto.
-Qed.
-
-(** Evaluation of simple expressions and of their translation *)
-
-Lemma tr_simple:
- forall e m,
- (forall r v,
-  eval_simple_rvalue ge e m r v ->
-  forall le dst sl a tmps,
-  tr_expr le dst r sl a tmps ->
-  match dst with
-  | For_val => sl = nil /\ Csyntax.typeof r = typeof a /\ eval_expr tge e le m a v
-  | For_effects => sl = nil
-  | For_set sd =>
-      exists b, sl = do_set sd b
-             /\ Csyntax.typeof r = typeof b
-             /\ eval_expr tge e le m b v
-  end)
-/\
- (forall l b ofs,
-  eval_simple_lvalue ge e m l b ofs ->
-  forall le sl a tmps,
-  tr_expr le For_val l sl a tmps ->
-  sl = nil /\ Csyntax.typeof l = typeof a /\ eval_lvalue tge e le m a b ofs).
-Proof.
-Opaque makeif.
-  intros e m.
-  apply (eval_simple_rvalue_lvalue_ind ge e m); intros until tmps; intros TR; inv TR.
-- (* value *)
-  auto.
-- auto.
-- exists a0; auto.
-- (* rvalof *)
-  inv H7; try congruence.
-  exploit H0; eauto. intros [A [B C]].
-  subst sl1; simpl.
-  assert (eval_expr tge e le m a v).
-    eapply eval_Elvalue. eauto.
-    rewrite <- B.
-    exploit deref_loc_translated; eauto. unfold chunk_for_volatile_type; rewrite H2. tauto.
-  destruct dst; auto.
-  econstructor. split. simpl; eauto. auto.
-- (* addrof *)
-  exploit H0; eauto. intros [A [B C]].
-  subst sl1; simpl.
-  assert (eval_expr tge e le m (Eaddrof' a1 ty) (Vptr b ofs)) by (apply eval_Eaddrof'; auto).
-  assert (typeof (Eaddrof' a1 ty) = ty) by (apply typeof_Eaddrof').
-  destruct dst; auto. simpl; econstructor; eauto.  
-- (* unop *)
-  exploit H0; eauto. intros [A [B C]].
-  subst sl1; simpl.
-  assert (eval_expr tge e le m (Eunop op a1 ty) v). econstructor; eauto. congruence.
-  destruct dst; auto. simpl; econstructor; eauto.
-- (* binop *)
-  exploit H0; eauto. intros [A [B C]].
-  exploit H2; eauto. intros [D [E F]].
-  subst sl1 sl2; simpl.
-  assert (eval_expr tge e le m (Ebinop op a1 a2 ty) v). econstructor; eauto. rewrite comp_env_preserved; congruence.
-  destruct dst; auto. simpl; econstructor; eauto.
-- (* cast effects *)
-  exploit H0; eauto.
-- (* cast val *)
-  exploit H0; eauto. intros [A [B C]].
-  subst sl1; simpl.
-  assert (eval_expr tge e le m (Ecast a1 ty) v). econstructor; eauto. congruence.
-  destruct dst; auto. simpl; econstructor; eauto.
-- (* sizeof *)
-  rewrite <- comp_env_preserved.
-  destruct dst.
-  split; auto. split; auto. constructor.
-  auto.
-  exists (Esizeof ty1 ty). split. auto. split. auto. constructor.
-- (* alignof *)
-  rewrite <- comp_env_preserved.
-  destruct dst.
-  split; auto. split; auto. constructor.
-  auto.
-  exists (Ealignof ty1 ty). split. auto. split. auto. constructor.
-- (* var local *)
-  split; auto. split; auto. apply eval_Evar_local; auto.
-- (* var global *)
-  split; auto. split; auto. apply eval_Evar_global; auto.
-    rewrite symbols_preserved; auto.
-- (* deref *)
-  exploit H0; eauto. intros [A [B C]]. subst sl1.
-  split; auto. split. rewrite typeof_Ederef'; auto. apply eval_Ederef'; auto. 
-- (* field struct *)
-  rewrite <- comp_env_preserved in *.
-  exploit H0; eauto. intros [A [B C]]. subst sl1.
-  split; auto. split; auto. rewrite B in H1. eapply eval_Efield_struct; eauto.
-- (* field union *)
-  rewrite <- comp_env_preserved in *.
-  exploit H0; eauto. intros [A [B C]]. subst sl1.
-  split; auto. split; auto. rewrite B in H1. eapply eval_Efield_union; eauto.
-Qed.
-
-Lemma tr_simple_rvalue:
-  forall e m r v,
-  eval_simple_rvalue ge e m r v ->
-  forall le dst sl a tmps,
-  tr_expr le dst r sl a tmps ->
-  match dst with
-  | For_val => sl = nil /\ Csyntax.typeof r = typeof a /\ eval_expr tge e le m a v
-  | For_effects => sl = nil
-  | For_set sd =>
-      exists b, sl = do_set sd b
-             /\ Csyntax.typeof r = typeof b
-             /\ eval_expr tge e le m b v
-  end.
-Proof.
-  intros e m. exact (proj1 (tr_simple e m)).
-Qed.
-
-Lemma tr_simple_lvalue:
-  forall e m l b ofs,
-  eval_simple_lvalue ge e m l b ofs ->
-  forall le sl a tmps,
-  tr_expr le For_val l sl a tmps ->
-  sl = nil /\ Csyntax.typeof l = typeof a /\ eval_lvalue tge e le m a b ofs.
-Proof.
-  intros e m. exact (proj2 (tr_simple e m)).
-Qed.
-
-Lemma tr_simple_exprlist:
-  forall le rl sl al tmps,
-  tr_exprlist le rl sl al tmps ->
-  forall e m tyl vl,
-  eval_simple_list ge e m rl tyl vl ->
-  sl = nil /\ eval_exprlist tge e le m al tyl vl.
-Proof.
-  induction 1; intros.
-  inv H. split. auto. constructor.
-  inv H4.
-  exploit tr_simple_rvalue; eauto. intros [A [B C]].
-  exploit IHtr_exprlist; eauto. intros [D E].
-  split. subst; auto. econstructor; eauto. congruence.
-Qed.
-
-(** Commutation between the translation of expressions and left contexts. *)
-
-Lemma typeof_context:
-  forall k1 k2 C, leftcontext k1 k2 C ->
-  forall e1 e2, Csyntax.typeof e1 = Csyntax.typeof e2 ->
-  Csyntax.typeof (C e1) = Csyntax.typeof (C e2).
-Proof.
-  induction 1; intros; auto.
-Qed.
-
-Scheme leftcontext_ind2 := Minimality for leftcontext Sort Prop
-  with leftcontextlist_ind2 := Minimality for leftcontextlist Sort Prop.
-Combined Scheme leftcontext_leftcontextlist_ind from leftcontext_ind2, leftcontextlist_ind2.
-
-Lemma tr_expr_leftcontext_rec:
- (
-  forall from to C, leftcontext from to C ->
-  forall le e dst sl a tmps,
-  tr_expr le dst (C e) sl a tmps ->
-  exists dst', exists sl1, exists sl2, exists a', exists tmp',
-  tr_expr le dst' e sl1 a' tmp'
-  /\ sl = sl1 ++ sl2
-  /\ incl tmp' tmps
-  /\ (forall le' e' sl3,
-        tr_expr le' dst' e' sl3 a' tmp' ->
-        (forall id, ~In id tmp' -> le'!id = le!id) ->
-        Csyntax.typeof e' = Csyntax.typeof e ->
-        tr_expr le' dst (C e') (sl3 ++ sl2) a tmps)
- ) /\ (
-  forall from C, leftcontextlist from C ->
-  forall le e sl a tmps,
-  tr_exprlist le (C e) sl a tmps ->
-  exists dst', exists sl1, exists sl2, exists a', exists tmp',
-  tr_expr le dst' e sl1 a' tmp'
-  /\ sl = sl1 ++ sl2
-  /\ incl tmp' tmps
-  /\ (forall le' e' sl3,
-        tr_expr le' dst' e' sl3 a' tmp' ->
-        (forall id, ~In id tmp' -> le'!id = le!id) ->
-        Csyntax.typeof e' = Csyntax.typeof e ->
-        tr_exprlist le' (C e') (sl3 ++ sl2) a tmps)
-).
-Proof.
-
-Ltac TR :=
-  econstructor; econstructor; econstructor; econstructor; econstructor;
-  split; [eauto | split; [idtac | split]].
-
-Ltac NOTIN :=
-  match goal with
-  | [ H1: In ?x ?l, H2: list_disjoint ?l _ |- ~In ?x _ ] =>
-        red; intro; elim (H2 x x); auto; fail
-  | [ H1: In ?x ?l, H2: list_disjoint _ ?l |- ~In ?x _ ] =>
-        red; intro; elim (H2 x x); auto; fail
-  end.
-
-Ltac UNCHANGED :=
-  match goal with
-  | [ H: (forall (id: ident), ~In id _ -> ?le' ! id = ?le ! id) |-
-         (forall (id: ident), In id _ -> ?le' ! id = ?le ! id) ] =>
-      intros; apply H; NOTIN
-  end.
-
-  (*generalize compat_dest_change; intro CDC.*)
-  apply leftcontext_leftcontextlist_ind; intros.
-
-- (* base *)
-  TR. rewrite <- app_nil_end; auto. red; auto.
-  intros. rewrite <- app_nil_end; auto.
-- (* deref *)
-  inv H1.
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. subst sl1; rewrite app_ass; eauto. auto.
-  intros. rewrite <- app_ass. econstructor; eauto.
-- (* field *)
-  inv H1.
-  exploit H0. eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. subst sl1; rewrite app_ass; eauto. auto.
-  intros. rewrite <- app_ass. econstructor; eauto.
-- (* rvalof *)
-  inv H1.
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. subst sl1; rewrite app_ass; eauto. red; eauto.
-  intros. rewrite <- app_ass; econstructor; eauto.
-  exploit typeof_context; eauto. congruence.
-- (* addrof *)
-  inv H1.
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. subst sl1; rewrite app_ass; eauto. auto.
-  intros. rewrite <- app_ass. econstructor; eauto.
-- (* unop *)
-  inv H1.
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. subst sl1; rewrite app_ass; eauto. auto.
-  intros. rewrite <- app_ass. econstructor; eauto.
-- (* binop left *)
-  inv H1.
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. subst sl1. rewrite app_ass. eauto.
-  red; auto.
-  intros. rewrite <- app_ass. econstructor; eauto.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-- (* binop right *)
-  inv H2.
-  assert (sl1 = nil) by (eapply tr_simple_expr_nil; eauto). subst sl1; simpl.
-  exploit H1; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. subst sl2. rewrite app_ass. eauto.
-  red; auto.
-  intros. rewrite <- app_ass. change (sl3 ++ sl2') with (nil ++ sl3 ++ sl2'). rewrite app_ass. econstructor; eauto.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-- (* cast *)
-  inv H1.
-+ (* for effects *)
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. eauto. auto. 
-  intros. econstructor; eauto.
-+ (* generic *)
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. subst sl1. rewrite app_ass. eauto. auto. 
-  intros. rewrite <- app_ass. econstructor; eauto.
-- (* seqand *)
-  inv H1.
-+ (* for val *)
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR.
-  rewrite Q. rewrite app_ass. eauto.
-  red; auto.
-  intros. rewrite <- app_ass. econstructor. apply S; auto.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-  auto. auto. auto. auto.
-+ (* for effects *)
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR.
-  rewrite Q. rewrite app_ass. eauto.
-  red; auto.
-  intros. rewrite <- app_ass. econstructor. apply S; auto.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-  auto. auto. auto.
-+ (* for set *)
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR.
-  rewrite Q. rewrite app_ass. eauto.
-  red; auto.
-  intros. rewrite <- app_ass. econstructor. apply S; auto.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-  auto. auto. auto. auto.
-- (* seqor *)
-  inv H1.
-+ (* for val *)
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR.
-  rewrite Q. rewrite app_ass. eauto.
-  red; auto.
-  intros. rewrite <- app_ass. econstructor. apply S; auto.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-  auto. auto. auto. auto.
-+ (* for effects *)
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR.
-  rewrite Q. rewrite app_ass. eauto.
-  red; auto.
-  intros. rewrite <- app_ass. econstructor. apply S; auto.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-  auto. auto. auto.
-+ (* for set *)
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR.
-  rewrite Q. rewrite app_ass. eauto.
-  red; auto.
-  intros. rewrite <- app_ass. econstructor. apply S; auto.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-  auto. auto. auto. auto.
-- (* condition *)
-  inv H1.
-+ (* for val *)
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR.
-  rewrite Q. rewrite app_ass. eauto.
-  red; auto.
-  intros. rewrite <- app_ass. econstructor. apply S; auto.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-  auto. auto. auto. auto. auto. auto.
-+ (* for effects *)
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR.
-  rewrite Q. rewrite app_ass. eauto.
-  red; auto.
-  intros. rewrite <- app_ass. eapply tr_condition_effects. apply S; auto.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-  auto. auto. auto. auto. auto.
-+ (* for set *)
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR.
-  rewrite Q. rewrite app_ass. eauto.
-  red; auto.
-  intros. rewrite <- app_ass. eapply tr_condition_set. apply S; auto.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-  auto. auto. auto. auto. auto. auto.
-- (* assign left *)
-  inv H1.
-+ (* for effects *)
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. subst sl1. rewrite app_ass. eauto.
-  red; auto.
-  intros. rewrite <- app_ass. econstructor. apply S; auto.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-  auto. auto. auto.
-+ (* for val *)
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. subst sl1. rewrite app_ass. eauto.
-  red; auto.
-  intros. rewrite <- app_ass. econstructor. apply S; auto.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-  auto. auto. auto. auto. auto. auto.
-  eapply typeof_context; eauto.
-  auto.
-- (* assign right *)
-  inv H2.
-+ (* for effects *)
-  assert (sl1 = nil) by (eapply tr_simple_expr_nil; eauto). subst sl1; simpl.
-  exploit H1; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. subst sl2. rewrite app_ass. eauto.
-  red; auto.
-  intros. rewrite <- app_ass. change (sl3 ++ sl2') with (nil ++ (sl3 ++ sl2')). rewrite app_ass.
-  econstructor.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-  apply S; auto. auto. auto. auto.
-+ (* for val *)
-  assert (sl1 = nil) by (eapply tr_simple_expr_nil; eauto). subst sl1; simpl.
-  exploit H1; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. subst sl2. rewrite app_ass. eauto.
-  red; auto.
-  intros. rewrite <- app_ass. change (sl3 ++ sl2') with (nil ++ (sl3 ++ sl2')). rewrite app_ass.
-  econstructor.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-  apply S; auto. auto. auto. auto. auto. auto. auto. auto.
-  eapply typeof_context; eauto.
-- (* assignop left *)
-  inv H1.
-+ (* for effects *)
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. subst sl1. rewrite app_ass. eauto.
-  red; auto.
-  intros. rewrite <- app_ass. econstructor. apply S; auto.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-  symmetry; eapply typeof_context; eauto. eauto.
-  auto. auto. auto. auto. auto. auto.
-+ (* for val *)
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. subst sl1. rewrite app_ass. eauto.
-  red; auto.
-  intros. rewrite <- app_ass. econstructor. apply S; auto.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-  eauto. auto. auto. auto. auto. auto. auto. auto. auto. auto. auto.
-  eapply typeof_context; eauto.
-- (* assignop right *)
-  inv H2.
-+ (* for effects *)
-  assert (sl1 = nil) by (eapply tr_simple_expr_nil; eauto). subst sl1; simpl.
-  exploit H1; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. subst sl2. rewrite app_ass. eauto.
-  red; auto.
-  intros. rewrite <- app_ass. change (sl0 ++ sl2') with (nil ++ sl0 ++ sl2'). rewrite app_ass. econstructor.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-  apply S; auto. auto. eauto. auto. auto. auto. auto. auto. auto.
-+ (* for val *)
-  assert (sl1 = nil) by (eapply tr_simple_expr_nil; eauto). subst sl1; simpl.
-  exploit H1; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. subst sl2. rewrite app_ass. eauto.
-  red; auto.
-  intros. rewrite <- app_ass. change (sl0 ++ sl2') with (nil ++ sl0 ++ sl2'). rewrite app_ass. econstructor.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-  apply S; auto. eauto. auto. auto. auto. auto. auto. auto. auto. auto. auto. auto. auto.
-- (* postincr *)
-  inv H1.
-+ (* for effects *)
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. rewrite Q; rewrite app_ass; eauto. red; auto.
-  intros. rewrite <- app_ass. econstructor; eauto.
-  symmetry; eapply typeof_context; eauto.
-+ (* for val *)
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. rewrite Q; rewrite app_ass; eauto. red; auto.
-  intros. rewrite <- app_ass. econstructor; eauto.
-  eapply typeof_context; eauto.
-- (* call left *)
-  inv H1.
-+ (* for effects *)
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. rewrite Q; rewrite app_ass; eauto. red; auto.
-  intros. rewrite <- app_ass. econstructor. apply S; auto.
-  eapply tr_exprlist_invariant; eauto. UNCHANGED.
-  auto. auto. auto.
-+ (* for val *)
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. rewrite Q; rewrite app_ass; eauto. red; auto.
-  intros. rewrite <- app_ass. econstructor. auto. apply S; auto.
-  eapply tr_exprlist_invariant; eauto. UNCHANGED.
-  auto. auto. auto. auto.
-- (* call right *)
-  inv H2.
-+ (* for effects *)
-  assert (sl1 = nil) by (eapply tr_simple_expr_nil; eauto). subst sl1; simpl.
-  exploit H1; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. rewrite Q; rewrite app_ass; eauto.
-  (*destruct dst'; constructor||contradiction.*)
-  red; auto.
-  intros. rewrite <- app_ass. change (sl3++sl2') with (nil ++ sl3 ++ sl2'). rewrite app_ass. econstructor.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-  apply S; auto. auto. auto. auto.
-+ (* for val *)
-  assert (sl1 = nil) by (eapply tr_simple_expr_nil; eauto). subst sl1; simpl.
-  exploit H1; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. rewrite Q; rewrite app_ass; eauto.
-  (*destruct dst'; constructor||contradiction.*)
-  red; auto.
-  intros. rewrite <- app_ass. change (sl3++sl2') with (nil ++ sl3 ++ sl2'). rewrite app_ass. econstructor.
-  auto. eapply tr_expr_invariant; eauto. UNCHANGED.
-  apply S; auto.
-  auto. auto. auto. auto.
-- (* builtin *)
-  inv H1.
-+ (* for effects *)
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. rewrite Q; rewrite app_ass; eauto.
-  red; auto.
-  intros. rewrite <- app_ass. change (sl3++sl2') with (nil ++ sl3 ++ sl2'). rewrite app_ass. econstructor.
-  apply S; auto. auto.
-+ (* for val *)
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. rewrite Q; rewrite app_ass; eauto.
-  red; auto.
-  intros. rewrite <- app_ass. change (sl3++sl2') with (nil ++ sl3 ++ sl2'). rewrite app_ass. econstructor.
-  auto. apply S; auto. auto. auto.
-- (* comma *)
-  inv H1.
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. rewrite Q; rewrite app_ass; eauto. red; auto.
-  intros. rewrite <- app_ass. econstructor. apply S; auto.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-  auto. auto. auto.
-- (* paren *)
-  inv H1.
-+ (* for val *)
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. rewrite Q. eauto. red; auto.
-  intros. econstructor; eauto.
-+ (* for effects *)
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. rewrite Q. eauto. auto.
-  intros. econstructor; eauto.
-+ (* for set *)
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. rewrite Q. eauto. auto.
-  intros. econstructor; eauto.
-- (* cons left *)
-  inv H1.
-  exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. subst sl1. rewrite app_ass. eauto.
-  red; auto.
-  intros. rewrite <- app_ass. econstructor. apply S; auto.
-  eapply tr_exprlist_invariant; eauto.  UNCHANGED.
-  auto. auto. auto.
-- (* cons right *)
-  inv H2.
-  assert (sl1 = nil) by (eapply tr_simple_expr_nil; eauto). subst sl1; simpl.
-  exploit H1; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]].
-  TR. subst sl2. eauto.
-  red; auto.
-  intros. change sl3 with (nil ++ sl3). rewrite app_ass. econstructor.
-  eapply tr_expr_invariant; eauto. UNCHANGED.
-  apply S; auto.
-  auto. auto. auto.
-Qed.
-
-Theorem tr_expr_leftcontext:
-  forall C le r dst sl a tmps,
-  leftcontext RV RV C ->
-  tr_expr le dst (C r) sl a tmps ->
-  exists dst', exists sl1, exists sl2, exists a', exists tmp',
-  tr_expr le dst' r sl1 a' tmp'
-  /\ sl = sl1 ++ sl2
-  /\ incl tmp' tmps
-  /\ (forall le' r' sl3,
-        tr_expr le' dst' r' sl3 a' tmp' ->
-        (forall id, ~In id tmp' -> le'!id = le!id) ->
-        Csyntax.typeof r' = Csyntax.typeof r ->
-        tr_expr le' dst (C r') (sl3 ++ sl2) a tmps).
-Proof.
-  intros. eapply (proj1 tr_expr_leftcontext_rec); eauto.
-Qed.
-
-Theorem tr_top_leftcontext:
-  forall e le m dst rtop sl a tmps,
-  tr_top tge e le m dst rtop sl a tmps ->
-  forall r C,
-  rtop = C r ->
-  leftcontext RV RV C ->
-  exists dst', exists sl1, exists sl2, exists a', exists tmp',
-  tr_top tge e le m dst' r sl1 a' tmp'
-  /\ sl = sl1 ++ sl2
-  /\ incl tmp' tmps
-  /\ (forall le' m' r' sl3,
-        tr_expr le' dst' r' sl3 a' tmp' ->
-        (forall id, ~In id tmp' -> le'!id = le!id) ->
-        Csyntax.typeof r' = Csyntax.typeof r ->
-        tr_top tge e le' m' dst (C r') (sl3 ++ sl2) a tmps).
-Proof.
-  induction 1; intros.
-(* val for val *)
-  inv H2; inv H1.
-  exists For_val; econstructor; econstructor; econstructor; econstructor.
-  split. apply tr_top_val_val; eauto.
-  split. instantiate (1 := nil); auto.
-  split. apply incl_refl.
-  intros. rewrite <- app_nil_end. constructor; auto.
-(* base *)
-  subst r. exploit tr_expr_leftcontext; eauto.
-  intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].
-  exists dst'; exists sl1; exists sl2; exists a'; exists tmp'.
-  split. apply tr_top_base; auto.
-  split. auto. split. auto.
-  intros. apply tr_top_base. apply S; auto.
-Qed.
-
-(** Semantics of smart constructors *)
-
-Remark sem_cast_deterministic:
-  forall v ty ty' m1 v1 m2 v2,
-  sem_cast v ty ty' m1 = Some v1 ->
-  sem_cast v ty ty' m2 = Some v2 ->
-  v1 = v2.
-Proof.
-  unfold sem_cast; intros. destruct (classify_cast ty ty'); try congruence.
-- destruct v; try congruence.
-  destruct Archi.ptr64; try discriminate.
-  destruct (Mem.weak_valid_pointer m1 b (Ptrofs.unsigned i)); inv H.
-  destruct (Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i)); inv H0.
-  auto.
-- destruct v; try congruence. 
-  destruct (negb Archi.ptr64); try discriminate.
-  destruct (Mem.weak_valid_pointer m1 b (Ptrofs.unsigned i)); inv H.
-  destruct (Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i)); inv H0.
-  auto.
-Qed.
-
-Lemma eval_simpl_expr_sound:
-  forall e le m a v, eval_expr tge e le m a v ->
-  match eval_simpl_expr a with Some v' => v' = v | None => True end.
-Proof.
-  induction 1; simpl; auto.
-  destruct (eval_simpl_expr a); auto. subst.
-  destruct (sem_cast v1 (typeof a) ty Mem.empty) as [v'|] eqn:C; auto.
-  eapply sem_cast_deterministic; eauto.
-  inv H; simpl; auto.
-Qed.
-
-Lemma static_bool_val_sound:
-  forall v t m b, bool_val v t Mem.empty = Some b -> bool_val v t m = Some b.
-Proof.
-  assert (A: forall b ofs, Mem.weak_valid_pointer Mem.empty b ofs = false).
-  { unfold Mem.weak_valid_pointer, Mem.valid_pointer, proj_sumbool; intros.
-    rewrite ! pred_dec_false by (apply Mem.perm_empty). auto. }  
-  intros until b; unfold bool_val.
-  destruct (classify_bool t); destruct v; destruct Archi.ptr64 eqn:SF; auto.
-- rewrite A; congruence.
-- simpl; rewrite A; congruence.
-Qed.
-
-Lemma step_makeif:
-  forall f a s1 s2 k e le m v1 b,
-  eval_expr tge e le m a v1 ->
-  bool_val v1 (typeof a) m = Some b ->
-  star step1 tge (State f (makeif a s1 s2) k e le m)
-             E0 (State f (if b then s1 else s2) k e le m).
-Proof.
-  intros. functional induction (makeif a s1 s2).
-- exploit eval_simpl_expr_sound; eauto. rewrite e0. intro EQ; subst v.
-  assert (bool_val v1 (typeof a) m = Some true) by (apply static_bool_val_sound; auto).
-  replace b with true by congruence. constructor.
-- exploit eval_simpl_expr_sound; eauto. rewrite e0. intro EQ; subst v.
-  assert (bool_val v1 (typeof a) m = Some false) by (apply static_bool_val_sound; auto).
-  replace b with false by congruence. constructor.
-- apply star_one. eapply step_ifthenelse; eauto.
-- apply star_one. eapply step_ifthenelse; eauto.
-Qed.
-
-Lemma step_make_set:
-  forall id a ty m b ofs t v e le f k,
-  Csem.deref_loc ge ty m b ofs t v ->
-  eval_lvalue tge e le m a b ofs ->
-  typeof a = ty ->
-  step1 tge (State f (make_set id a) k e le m)
-          t (State f Sskip k e (PTree.set id v le) m).
-Proof.
-  intros. exploit deref_loc_translated; eauto. rewrite <- H1.
-  unfold make_set. destruct (chunk_for_volatile_type (typeof a)) as [chunk|].
-(* volatile case *)
-  intros. change (PTree.set id v le) with (set_opttemp (Some id) v le). econstructor.
-  econstructor. constructor. eauto.
-  simpl. unfold sem_cast. simpl. eauto. constructor.
-  simpl. econstructor; eauto.
-(* nonvolatile case *)
-  intros [A B]. subst t. constructor. eapply eval_Elvalue; eauto.
-Qed.
-
-Lemma step_make_assign:
-  forall a1 a2 ty m b ofs t v m' v2 e le f k,
-  Csem.assign_loc ge ty m b ofs v t m' ->
-  eval_lvalue tge e le m a1 b ofs ->
-  eval_expr tge e le m a2 v2 ->
-  sem_cast v2 (typeof a2) ty m = Some v ->
-  typeof a1 = ty ->
-  step1 tge (State f (make_assign a1 a2) k e le m)
-          t (State f Sskip k e le m').
-Proof.
-  intros. exploit assign_loc_translated; eauto. rewrite <- H3.
-  unfold make_assign. destruct (chunk_for_volatile_type (typeof a1)) as [chunk|].
-(* volatile case *)
-  intros. change le with (set_opttemp None Vundef le) at 2. econstructor.
-  econstructor. constructor. eauto.
-  simpl. unfold sem_cast. simpl. eauto.
-  econstructor; eauto. rewrite H3; eauto. constructor.
-  simpl. econstructor; eauto.
-(* nonvolatile case *)
-  intros [A B]. subst t. econstructor; eauto. congruence.
-Qed.
-
-Fixpoint Kseqlist (sl: list statement) (k: cont) :=
-  match sl with
-  | nil => k
-  | s :: l => Kseq s (Kseqlist l k)
-  end.
-
-Remark Kseqlist_app:
-  forall sl1 sl2 k,
-  Kseqlist (sl1 ++ sl2) k = Kseqlist sl1 (Kseqlist sl2 k).
-Proof.
-  induction sl1; simpl; congruence.
-Qed.
-
-Lemma push_seq:
-  forall f sl k e le m,
-  star step1 tge (State f (makeseq sl) k e le m)
-              E0 (State f Sskip (Kseqlist sl k) e le m).
-Proof.
-  intros. unfold makeseq. generalize Sskip. revert sl k.
-  induction sl; simpl; intros.
-  apply star_refl.
-  eapply star_right. apply IHsl. constructor. traceEq.
-Qed.
-
-Lemma step_tr_rvalof:
-  forall ty m b ofs t v e le a sl a' tmp f k,
-  Csem.deref_loc ge ty m b ofs t v ->
-  eval_lvalue tge e le m a b ofs ->
-  tr_rvalof ty a sl a' tmp ->
-  typeof a = ty ->
-  exists le',
-    star step1 tge (State f Sskip (Kseqlist sl k) e le m)
-                 t (State f Sskip k e le' m)
-  /\ eval_expr tge e le' m a' v
-  /\ typeof a' = typeof a
-  /\ forall x, ~In x tmp -> le'!x = le!x.
-Proof.
-  intros. inv H1.
-  (* not volatile *)
-  exploit deref_loc_translated; eauto. unfold chunk_for_volatile_type; rewrite H3.
-  intros [A B]. subst t.
-  exists le; split. apply star_refl.
-  split. eapply eval_Elvalue; eauto.
-  auto.
-  (* volatile *)
-  intros. exists (PTree.set t0 v le); split.
-  simpl. eapply star_two. econstructor. eapply step_make_set; eauto. traceEq.
-  split. constructor. apply PTree.gss.
-  split. auto.
-  intros. apply PTree.gso. congruence.
-Qed.
-
-(** Matching between continuations *)
-
-Inductive match_cont : Csem.cont -> cont -> Prop :=
-  | match_Kstop:
-      match_cont Csem.Kstop Kstop
-  | match_Kseq: forall s k ts tk,
-      tr_stmt s ts ->
-      match_cont k tk ->
-      match_cont (Csem.Kseq s k) (Kseq ts tk)
-  | match_Kwhile2: forall r s k s' ts tk,
-      tr_if r Sskip Sbreak s' ->
-      tr_stmt s ts ->
-      match_cont k tk ->
-      match_cont (Csem.Kwhile2 r s k)
-                 (Kloop1 (Ssequence s' ts) Sskip tk)
-  | match_Kdowhile1: forall r s k s' ts tk,
-      tr_if r Sskip Sbreak s' ->
-      tr_stmt s ts ->
-      match_cont k tk ->
-      match_cont (Csem.Kdowhile1 r s k)
-                 (Kloop1 ts s' tk)
-  | match_Kfor3: forall r s3 s k ts3 s' ts tk,
-      tr_if r Sskip Sbreak s' ->
-      tr_stmt s3 ts3 ->
-      tr_stmt s ts ->
-      match_cont k tk ->
-      match_cont (Csem.Kfor3 r s3 s k)
-                 (Kloop1 (Ssequence s' ts) ts3 tk)
-  | match_Kfor4: forall r s3 s k ts3 s' ts tk,
-      tr_if r Sskip Sbreak s' ->
-      tr_stmt s3 ts3 ->
-      tr_stmt s ts ->
-      match_cont k tk ->
-      match_cont (Csem.Kfor4 r s3 s k)
-                 (Kloop2 (Ssequence s' ts) ts3 tk)
-  | match_Kswitch2: forall k tk,
-      match_cont k tk ->
-      match_cont (Csem.Kswitch2 k) (Kswitch tk)
-  | match_Kcall: forall f e C ty k optid tf le sl tk a dest tmps,
-      tr_function f tf ->
-      leftcontext RV RV C ->
-      (forall v m, tr_top tge e (set_opttemp optid v le) m dest (C (Csyntax.Eval v ty)) sl a tmps) ->
-      match_cont_exp dest a k tk ->
-      match_cont (Csem.Kcall f e C ty k)
-                 (Kcall optid tf e le (Kseqlist sl tk))
-(*
-  | match_Kcall_some: forall f e C ty k dst tf le sl tk a dest tmps,
-      transl_function f = Errors.OK tf ->
-      leftcontext RV RV C ->
-      (forall v m, tr_top tge e (PTree.set dst v le) m dest (C (C.Eval v ty)) sl a tmps) ->
-      match_cont_exp dest a k tk ->
-      match_cont (Csem.Kcall f e C ty k)
-                 (Kcall (Some dst) tf e le (Kseqlist sl tk))
-*)
-
-with match_cont_exp : destination -> expr -> Csem.cont -> cont -> Prop :=
-  | match_Kdo: forall k a tk,
-      match_cont k tk ->
-      match_cont_exp For_effects a (Csem.Kdo k) tk
-  | match_Kifthenelse_empty: forall a k tk,
-      match_cont k tk ->
-      match_cont_exp For_val a (Csem.Kifthenelse Csyntax.Sskip Csyntax.Sskip k) (Kseq Sskip tk)
-  | match_Kifthenelse_1: forall a s1 s2 k ts1 ts2 tk,
-      tr_stmt s1 ts1 -> tr_stmt s2 ts2 ->
-      match_cont k tk ->
-      match_cont_exp For_val a (Csem.Kifthenelse s1 s2 k) (Kseq (Sifthenelse a ts1 ts2) tk)
-  | match_Kwhile1: forall r s k s' a ts tk,
-      tr_if r Sskip Sbreak s' ->
-      tr_stmt s ts ->
-      match_cont k tk ->
-      match_cont_exp For_val a
-         (Csem.Kwhile1 r s k)
-         (Kseq (makeif a Sskip Sbreak)
-           (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk)))
-  | match_Kdowhile2: forall r s k s' a ts tk,
-      tr_if r Sskip Sbreak s' ->
-      tr_stmt s ts ->
-      match_cont k tk ->
-      match_cont_exp For_val a
-        (Csem.Kdowhile2 r s k)
-        (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk))
-  | match_Kfor2: forall r s3 s k s' a ts3 ts tk,
-      tr_if r Sskip Sbreak s' ->
-      tr_stmt s3 ts3 ->
-      tr_stmt s ts ->
-      match_cont k tk ->
-      match_cont_exp For_val a
-        (Csem.Kfor2 r s3 s k)
-        (Kseq (makeif a Sskip Sbreak)
-          (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk)))
-  | match_Kswitch1: forall ls k a tls tk,
-      tr_lblstmts ls tls ->
-      match_cont k tk ->
-      match_cont_exp For_val a (Csem.Kswitch1 ls k) (Kseq (Sswitch a tls) tk)
-  | match_Kreturn: forall k a tk,
-      match_cont k tk ->
-      match_cont_exp For_val a (Csem.Kreturn k) (Kseq (Sreturn (Some a)) tk).
-
-Lemma match_cont_call:
-  forall k tk,
-  match_cont k tk ->
-  match_cont (Csem.call_cont k) (call_cont tk).
-Proof.
-  induction 1; simpl; auto. constructor. econstructor; eauto.
-Qed.
-
-(** Matching between states *)
-
-Inductive match_states: Csem.state -> state -> Prop :=
-  | match_exprstates: forall f r k e m tf sl tk le dest a tmps,
-      tr_function f tf ->
-      tr_top tge e le m dest r sl a tmps ->
-      match_cont_exp dest a k tk ->
-      match_states (Csem.ExprState f r k e m)
-                   (State tf Sskip (Kseqlist sl tk) e le m)
-  | match_regularstates: forall f s k e m tf ts tk le,
-      tr_function f tf ->
-      tr_stmt s ts ->
-      match_cont k tk ->
-      match_states (Csem.State f s k e m)
-                   (State tf ts tk e le m)
-  | match_callstates: forall fd args k m tfd tk,
-      tr_fundef fd tfd ->
-      match_cont k tk ->
-      match_states (Csem.Callstate fd args k m)
-                   (Callstate tfd args tk m)
-  | match_returnstates: forall res k m tk,
-      match_cont k tk ->
-      match_states (Csem.Returnstate res k m)
-                   (Returnstate res tk m)
-  | match_stuckstate: forall S,
-      match_states Csem.Stuckstate S.
-
-(** Additional results on translation of statements *)
-
-Lemma tr_select_switch:
-  forall n ls tls,
-  tr_lblstmts ls tls ->
-  tr_lblstmts (Csem.select_switch n ls) (select_switch n tls).
-Proof.
-  assert (DFL: forall ls tls,
-      tr_lblstmts ls tls ->
-      tr_lblstmts (Csem.select_switch_default ls) (select_switch_default tls)).
-  { induction 1; simpl. constructor. destruct c; auto. constructor; auto. }
-  assert (CASE: forall n ls tls,
-      tr_lblstmts ls tls ->
-      match Csem.select_switch_case n ls with
-      | None =>
-          select_switch_case n tls = None
-      | Some ls' =>
-          exists tls', select_switch_case n tls = Some tls' /\ tr_lblstmts ls' tls'
-      end).
-  { induction 1; simpl; intros.
-    auto.
-    destruct c; auto. destruct (zeq z n); auto.
-    econstructor; split; eauto. constructor; auto. }
-  intros. unfold Csem.select_switch, select_switch.
-  specialize (CASE n ls tls H).
-  destruct (Csem.select_switch_case n ls) as [ls'|].
-  destruct CASE as [tls' [P Q]]. rewrite P. auto.
-  rewrite CASE. apply DFL; auto.
-Qed.
-
-Lemma tr_seq_of_labeled_statement:
-  forall ls tls,
-  tr_lblstmts ls tls ->
-  tr_stmt (Csem.seq_of_labeled_statement ls) (seq_of_labeled_statement tls).
-Proof.
-  induction 1; simpl; constructor; auto.
-Qed.
-
-(** Commutation between translation and the "find label" operation. *)
-
-Section FIND_LABEL.
-
-Variable lbl: label.
-
-Definition nolabel (s: statement) : Prop :=
-  forall k, find_label lbl s k = None.
-
-Fixpoint nolabel_list (sl: list statement) : Prop :=
-  match sl with
-  | nil => True
-  | s1 :: sl' => nolabel s1 /\ nolabel_list sl'
-  end.
-
-Lemma nolabel_list_app:
-  forall sl2 sl1, nolabel_list sl1 -> nolabel_list sl2 -> nolabel_list (sl1 ++ sl2).
-Proof.
-  induction sl1; simpl; intros. auto. tauto.
-Qed.
-
-Lemma makeseq_nolabel:
-  forall sl, nolabel_list sl -> nolabel (makeseq sl).
-Proof.
-  assert (forall sl s, nolabel s -> nolabel_list sl -> nolabel (makeseq_rec s sl)).
-  induction sl; simpl; intros. auto. destruct H0. apply IHsl; auto.
-  red. intros; simpl. rewrite H. apply H0.
-  intros. unfold makeseq. apply H; auto. red. auto.
-Qed.
-
-Lemma makeif_nolabel:
-  forall a s1 s2, nolabel s1 -> nolabel s2 -> nolabel (makeif a s1 s2).
-Proof.
-  intros. functional induction (makeif a s1 s2); auto.
-  red; simpl; intros. rewrite H; auto.
-  red; simpl; intros. rewrite H; auto.
-Qed.
-
-Lemma make_set_nolabel:
-  forall t a, nolabel (make_set t a).
-Proof.
-  unfold make_set; intros; red; intros.
-  destruct (chunk_for_volatile_type (typeof a)); auto.
-Qed.
-
-Lemma make_assign_nolabel:
-  forall l r, nolabel (make_assign l r).
-Proof.
-  unfold make_assign; intros; red; intros.
-  destruct (chunk_for_volatile_type (typeof l)); auto.
-Qed.
-
-Lemma tr_rvalof_nolabel:
-  forall ty a sl a' tmp, tr_rvalof ty a sl a' tmp -> nolabel_list sl.
-Proof.
-  destruct 1; simpl; intuition. apply make_set_nolabel.
-Qed.
-
-Lemma nolabel_do_set:
-  forall sd a, nolabel_list (do_set sd a).
-Proof.
-  induction sd; intros; simpl; split; auto; red; auto.
-Qed.
-
-Lemma nolabel_final:
-  forall dst a, nolabel_list (final dst a).
-Proof.
-  destruct dst; simpl; intros. auto. auto. apply nolabel_do_set.
-Qed.
-
-Ltac NoLabelTac :=
-  match goal with
-  | [ |- nolabel_list nil ] => exact I
-  | [ |- nolabel_list (final _ _) ] => apply nolabel_final (*; NoLabelTac*)
-  | [ |- nolabel_list (_ :: _) ] => simpl; split; NoLabelTac
-  | [ |- nolabel_list (_ ++ _) ] => apply nolabel_list_app; NoLabelTac
-  | [ H: _ -> nolabel_list ?x |- nolabel_list ?x ] => apply H; NoLabelTac
-  | [ |- nolabel (makeseq _) ] => apply makeseq_nolabel; NoLabelTac
-  | [ |- nolabel (makeif _ _ _) ] => apply makeif_nolabel; NoLabelTac
-  | [ |- nolabel (make_set _ _) ] => apply make_set_nolabel
-  | [ |- nolabel (make_assign _ _) ] => apply make_assign_nolabel
-  | [ |- nolabel _ ] => red; intros; simpl; auto
-  | [ |- _ /\ _ ] => split; NoLabelTac
-  | _ => auto
-  end.
-
-Lemma tr_find_label_expr:
-  (forall le dst r sl a tmps, tr_expr le dst r sl a tmps -> nolabel_list sl)
-/\(forall le rl sl al tmps, tr_exprlist le rl sl al tmps -> nolabel_list sl).
-Proof.
-  apply tr_expr_exprlist; intros; NoLabelTac.
-  apply nolabel_do_set.
-  eapply tr_rvalof_nolabel; eauto.
-  apply nolabel_do_set.
-  apply nolabel_do_set.
-  eapply tr_rvalof_nolabel; eauto.
-  eapply tr_rvalof_nolabel; eauto.
-  eapply tr_rvalof_nolabel; eauto.
-Qed.
-
-Lemma tr_find_label_top:
-  forall e le m dst r sl a tmps,
-  tr_top tge e le m dst r sl a tmps -> nolabel_list sl.
-Proof.
-  induction 1; intros; NoLabelTac.
-  eapply (proj1 tr_find_label_expr); eauto.
-Qed.
-
-Lemma tr_find_label_expression:
-  forall r s a, tr_expression r s a -> forall k, find_label lbl s k = None.
-Proof.
-  intros. inv H.
-  assert (nolabel (makeseq sl)). apply makeseq_nolabel.
-  eapply tr_find_label_top with (e := empty_env) (le := PTree.empty val) (m := Mem.empty).
-  eauto. apply H.
-Qed.
-
-Lemma tr_find_label_expr_stmt:
-  forall r s, tr_expr_stmt r s -> forall k, find_label lbl s k = None.
-Proof.
-  intros. inv H.
-  assert (nolabel (makeseq sl)). apply makeseq_nolabel.
-  eapply tr_find_label_top with (e := empty_env) (le := PTree.empty val) (m := Mem.empty).
-  eauto. apply H.
-Qed.
-
-Lemma tr_find_label_if:
-  forall r s,
-  tr_if r Sskip Sbreak s ->
-  forall k, find_label lbl s k = None.
-Proof.
-  intros. inv H.
-  assert (nolabel (makeseq (sl ++ makeif a Sskip Sbreak :: nil))).
-  apply makeseq_nolabel.
-  apply nolabel_list_app.
-  eapply tr_find_label_top with (e := empty_env) (le := PTree.empty val) (m := Mem.empty).
-  eauto.
-  simpl; split; auto. apply makeif_nolabel. red; simpl; auto. red; simpl; auto.
-  apply H.
-Qed.
-
-Lemma tr_find_label:
-  forall s k ts tk
-    (TR: tr_stmt s ts)
-    (MC: match_cont k tk),
-  match Csem.find_label lbl s k with
-  | None =>
-      find_label lbl ts tk = None
-  | Some (s', k') =>
-      exists ts', exists tk',
-          find_label lbl ts tk = Some (ts', tk')
-       /\ tr_stmt s' ts'
-       /\ match_cont k' tk'
-  end
-with tr_find_label_ls:
-  forall s k ts tk
-    (TR: tr_lblstmts s ts)
-    (MC: match_cont k tk),
-  match Csem.find_label_ls lbl s k with
-  | None =>
-      find_label_ls lbl ts tk = None
-  | Some (s', k') =>
-      exists ts', exists tk',
-          find_label_ls lbl ts tk = Some (ts', tk')
-       /\ tr_stmt s' ts'
-       /\ match_cont k' tk'
-  end.
-Proof.
-  induction s; intros; inversion TR; subst; clear TR; simpl.
-  auto.
-  eapply tr_find_label_expr_stmt; eauto.
-(* seq *)
-  exploit (IHs1 (Csem.Kseq s2 k)); eauto. constructor; eauto.
-  destruct (Csem.find_label lbl s1 (Csem.Kseq s2 k)) as [[s' k'] | ].
-  intros [ts' [tk' [A [B C]]]]. rewrite A. exists ts'; exists tk'; auto.
-  intro EQ. rewrite EQ. eapply IHs2; eauto.
-(* if empty *)
-  rename s' into sr.
-  rewrite (tr_find_label_expression _ _ _ H3).
-  auto.
-(* if not empty *)
-  rename s' into sr.
-  rewrite (tr_find_label_expression _ _ _ H2).
-  exploit (IHs1 k); eauto.
-  destruct (Csem.find_label lbl s1 k) as [[s' k'] | ].
-  intros [ts' [tk' [A [B C]]]]. rewrite A. exists ts'; exists tk'; intuition.
-  intro EQ. rewrite EQ. eapply IHs2; eauto.
-(* while *)
-  rename s' into sr.
-  rewrite (tr_find_label_if _ _ H1); auto.
-  exploit (IHs (Kwhile2 e s k)); eauto. econstructor; eauto.
-  destruct (Csem.find_label lbl s (Kwhile2 e s k)) as [[s' k'] | ].
-  intros [ts' [tk' [A [B C]]]]. rewrite A. exists ts'; exists tk'; intuition.
-  intro EQ. rewrite EQ. auto.
-(* dowhile *)
-  rename s' into sr.
-  rewrite (tr_find_label_if _ _ H1); auto.
-  exploit (IHs (Kdowhile1 e s k)); eauto. econstructor; eauto.
-  destruct (Csem.find_label lbl s (Kdowhile1 e s k)) as [[s' k'] | ].
-  intros [ts' [tk' [A [B C]]]]. rewrite A. exists ts'; exists tk'; intuition.
-  intro EQ. rewrite EQ. auto.
-(* for skip *)
-  rename s' into sr.
-  rewrite (tr_find_label_if _ _ H4); auto.
-  exploit (IHs3 (Csem.Kfor3 e s2 s3 k)); eauto. econstructor; eauto.
-  destruct (Csem.find_label lbl s3 (Csem.Kfor3 e s2 s3 k)) as [[s' k'] | ].
-  intros [ts' [tk' [A [B C]]]]. rewrite A. exists ts'; exists tk'; intuition.
-  intro EQ. rewrite EQ.
-  exploit (IHs2 (Csem.Kfor4 e s2 s3 k)); eauto. econstructor; eauto.
-(* for not skip *)
-  rename s' into sr.
-  rewrite (tr_find_label_if _ _ H3); auto.
-  exploit (IHs1 (Csem.Kseq (Csyntax.Sfor Csyntax.Sskip e s2 s3) k)); eauto.
-    econstructor; eauto. econstructor; eauto.
-  destruct (Csem.find_label lbl s1
-               (Csem.Kseq (Csyntax.Sfor Csyntax.Sskip e s2 s3) k)) as [[s' k'] | ].
-  intros [ts' [tk' [A [B C]]]]. rewrite A. exists ts'; exists tk'; intuition.
-  intro EQ; rewrite EQ.
-  exploit (IHs3 (Csem.Kfor3 e s2 s3 k)); eauto. econstructor; eauto.
-  destruct (Csem.find_label lbl s3 (Csem.Kfor3 e s2 s3 k)) as [[s'' k''] | ].
-  intros [ts' [tk' [A [B C]]]]. rewrite A. exists ts'; exists tk'; intuition.
-  intro EQ'. rewrite EQ'.
-  exploit (IHs2 (Csem.Kfor4 e s2 s3 k)); eauto. econstructor; eauto.
-(* break, continue, return 0 *)
-  auto. auto. auto.
-(* return 1 *)
-  rewrite (tr_find_label_expression _ _ _ H0). auto.
-(* switch *)
-  rewrite (tr_find_label_expression _ _ _ H1). apply tr_find_label_ls. auto. constructor; auto.
-(* labeled stmt *)
-  destruct (ident_eq lbl l). exists ts0; exists tk; auto. apply IHs; auto.
-(* goto *)
-  auto.
-
-  induction s; intros; inversion TR; subst; clear TR; simpl.
-(* nil *)
-  auto.
-(* case *)
-  exploit (tr_find_label s (Csem.Kseq (Csem.seq_of_labeled_statement s0) k)); eauto.
-  econstructor; eauto. apply tr_seq_of_labeled_statement; eauto.
-  destruct (Csem.find_label lbl s
-    (Csem.Kseq (Csem.seq_of_labeled_statement s0) k)) as [[s' k'] | ].
-  intros [ts' [tk' [A [B C]]]]. rewrite A. exists ts'; exists tk'; auto.
-  intro EQ. rewrite EQ. eapply IHs; eauto.
-Qed.
-
-End FIND_LABEL.
-
-(** Anti-stuttering measure *)
-
-(** There are some stuttering steps in the translation:
-- The execution of [Sdo a] where [a] is side-effect free,
-  which is three transitions in the source:
-<<
-    Sdo a, k  --->  a, Kdo k ---> rval v, Kdo k ---> Sskip, k
->>
-  but the translation, which is [Sskip], makes no transitions.
-- The reduction [Ecomma (Eval v) r2 --> r2].
-- The reduction [Eparen (Eval v) --> Eval v] in a [For_effects] context.
-
-The following measure decreases for these stuttering steps. *)
-
-Fixpoint esize (a: Csyntax.expr) : nat :=
-  match a with
-  | Csyntax.Eloc _ _ _ => 1%nat
-  | Csyntax.Evar _ _ => 1%nat
-  | Csyntax.Ederef r1 _ => S(esize r1)
-  | Csyntax.Efield l1 _ _ => S(esize l1)
-  | Csyntax.Eval _ _ => O
-  | Csyntax.Evalof l1 _ => S(esize l1)
-  | Csyntax.Eaddrof l1 _ => S(esize l1)
-  | Csyntax.Eunop _ r1 _ => S(esize r1)
-  | Csyntax.Ebinop _ r1 r2 _ => S(esize r1 + esize r2)%nat
-  | Csyntax.Ecast r1 _ => S(esize r1)
-  | Csyntax.Eseqand r1 _ _ => S(esize r1)
-  | Csyntax.Eseqor r1 _ _ => S(esize r1)
-  | Csyntax.Econdition r1 _ _ _ => S(esize r1)
-  | Csyntax.Esizeof _ _ => 1%nat
-  | Csyntax.Ealignof _ _ => 1%nat
-  | Csyntax.Eassign l1 r2 _ => S(esize l1 + esize r2)%nat
-  | Csyntax.Eassignop _ l1 r2 _ _ => S(esize l1 + esize r2)%nat
-  | Csyntax.Epostincr _ l1 _ => S(esize l1)
-  | Csyntax.Ecomma r1 r2 _ => S(esize r1 + esize r2)%nat
-  | Csyntax.Ecall r1 rl2 _ => S(esize r1 + esizelist rl2)%nat
-  | Csyntax.Ebuiltin ef _ rl _ => S(esizelist rl)%nat
-  | Csyntax.Eparen r1 _ _ => S(esize r1)
-  end
-
-with esizelist (el: Csyntax.exprlist) : nat :=
-  match el with
-  | Csyntax.Enil => O
-  | Csyntax.Econs r1 rl2 => (esize r1 + esizelist rl2)%nat
-  end.
-
-Definition measure (st: Csem.state) : nat :=
-  match st with
-  | Csem.ExprState _ r _ _ _ => (esize r + 1)%nat
-  | Csem.State _ Csyntax.Sskip _ _ _ => 0%nat
-  | Csem.State _ (Csyntax.Sdo r) _ _ _ => (esize r + 2)%nat
-  | Csem.State _ (Csyntax.Sifthenelse r _ _) _ _ _ => (esize r + 2)%nat
-  | _ => 0%nat
-  end.
-
-Lemma leftcontext_size:
-  forall from to C,
-  leftcontext from to C ->
-  forall e1 e2,
-  (esize e1 < esize e2)%nat ->
-  (esize (C e1) < esize (C e2))%nat
-with leftcontextlist_size:
-  forall from C,
-  leftcontextlist from C ->
-  forall e1 e2,
-  (esize e1 < esize e2)%nat ->
-  (esizelist (C e1) < esizelist (C e2))%nat.
-Proof.
-  induction 1; intros; simpl; auto with arith.
-  exploit leftcontextlist_size; eauto. auto with arith.
-  exploit leftcontextlist_size; eauto. auto with arith.
-  induction 1; intros; simpl; auto with arith. exploit leftcontext_size; eauto. auto with arith.
-Qed.
-
-(** Forward simulation for expressions. *)
-
-Lemma tr_val_gen:
-  forall le dst v ty a tmp,
-  typeof a = ty ->
-  (forall tge e le' m,
-      (forall id, In id tmp -> le'!id = le!id) ->
-      eval_expr tge e le' m a v) ->
-  tr_expr le dst (Csyntax.Eval v ty) (final dst a) a tmp.
-Proof.
-  intros. destruct dst; simpl; econstructor; auto.
-Qed.
-
-Lemma estep_simulation:
-  forall S1 t S2, Cstrategy.estep ge S1 t S2 ->
-  forall S1' (MS: match_states S1 S1'),
-  exists S2',
-     (plus step1 tge S1' t S2' \/
-       (star step1 tge S1' t S2' /\ measure S2 < measure S1)%nat)
-  /\ match_states S2 S2'.
-Proof.
-  induction 1; intros; inv MS.
-(* expr *)
-  assert (tr_expr le dest r sl a tmps).
-    inv H9. contradiction. auto.
-  exploit tr_simple_rvalue; eauto. destruct dest.
-  (* for val *)
-  intros [SL1 [TY1 EV1]]. subst sl.
-  econstructor; split.
-  right; split. apply star_refl. destruct r; simpl; (contradiction || lia).
-  econstructor; eauto.
-  instantiate (1 := tmps). apply tr_top_val_val; auto.
-  (* for effects *)
-  intros SL1. subst sl.
-  econstructor; split.
-  right; split. apply star_refl. destruct r; simpl; (contradiction || lia).
-  econstructor; eauto.
-  instantiate (1 := tmps). apply tr_top_base. constructor.
-  (* for set *)
-  inv H10.
-(* rval volatile *)
-  exploit tr_top_leftcontext; eauto. clear H11.
-  intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].
-  inv P. inv H2. inv H7; try congruence.
-  exploit tr_simple_lvalue; eauto. intros [SL [TY EV]]. subst sl0; simpl.
-  econstructor; split.
-  left. eapply plus_two. constructor. eapply step_make_set; eauto. traceEq.
-  econstructor; eauto.
-  change (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) with (nil ++ (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2)).
-  apply S. apply tr_val_gen. auto.
-  intros. constructor. rewrite H5; auto. apply PTree.gss.
-  intros. apply PTree.gso. red; intros; subst; elim H5; auto.
-  auto.
-(* seqand true *)
-  exploit tr_top_leftcontext; eauto. clear H9.
-  intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].
-  inv P. inv H2.
-  (* for val *)
-  exploit tr_simple_rvalue; eauto. intros [SL [TY EV]].
-  subst sl0; simpl Kseqlist.
-  econstructor; split.
-  left. eapply plus_left. constructor.
-  eapply star_trans. apply step_makeif with (b := true) (v1 := v); auto. congruence.
-  apply push_seq. reflexivity. reflexivity.
-  rewrite <- Kseqlist_app.
-  eapply match_exprstates; eauto.
-  apply S. apply tr_paren_val with (a1 := a2); auto.
-  apply tr_expr_monotone with tmp2; eauto. auto. auto.
-  (* for effects *)
-  exploit tr_simple_rvalue; eauto. intros [SL [TY EV]].
-  subst sl0; simpl Kseqlist.
-  econstructor; split.
-  left. eapply plus_left. constructor.
-  eapply star_trans. apply step_makeif with (b := true) (v1 := v); auto. congruence.
-  apply push_seq. reflexivity. reflexivity.
-  rewrite <- Kseqlist_app.
-  eapply match_exprstates; eauto.
-  apply S. apply tr_paren_effects with (a1 := a2); auto.
-  apply tr_expr_monotone with tmp2; eauto. auto. auto.
-  (* for set *)
-  exploit tr_simple_rvalue; eauto. intros [SL [TY EV]].
-  subst sl0; simpl Kseqlist.
-  econstructor; split.
-  left. eapply plus_left. constructor.
-  eapply star_trans. apply step_makeif with (b := true) (v1 := v); auto. congruence.
-  apply push_seq. reflexivity. reflexivity.
-  rewrite <- Kseqlist_app.
-  eapply match_exprstates; eauto.
-  apply S. apply tr_paren_set with (a1 := a2) (t := sd_temp sd); auto.
-  apply tr_expr_monotone with tmp2; eauto. auto. auto.
-(* seqand false *)
-  exploit tr_top_leftcontext; eauto. clear H9.
-  intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].
-  inv P. inv H2.
-  (* for val *)
-  exploit tr_simple_rvalue; eauto. intros [SL [TY EV]].
-  subst sl0; simpl Kseqlist.
-  econstructor; split.
-  left. eapply plus_left. constructor.
-  eapply star_trans. apply step_makeif with (b := false) (v1 := v); auto. congruence.
-  apply star_one. constructor. constructor. reflexivity. reflexivity.
-  eapply match_exprstates; eauto.
-  change sl2 with (nil ++ sl2). apply S. econstructor; eauto.
-  intros. constructor. rewrite H2. apply PTree.gss. auto.
-  intros. apply PTree.gso. congruence.
-  auto.
-  (* for effects *)
-  exploit tr_simple_rvalue; eauto. intros [SL [TY EV]].
-  subst sl0; simpl Kseqlist.
-  econstructor; split.
-  left. eapply plus_left. constructor.
-  apply step_makeif with (b := false) (v1 := v); auto. congruence.
-  reflexivity.
-  eapply match_exprstates; eauto.
-  change sl2 with (nil ++ sl2). apply S. econstructor; eauto.
-  auto. auto.
-  (* for set *)
-  exploit tr_simple_rvalue; eauto. intros [SL [TY EV]].
-  subst sl0; simpl Kseqlist.
-  econstructor; split.
-  left. eapply plus_left. constructor.
-  eapply star_trans. apply step_makeif with (b := false) (v1 := v); auto. congruence.
-  apply push_seq. reflexivity. reflexivity.
-  rewrite <- Kseqlist_app.
-  eapply match_exprstates; eauto.
-  apply S. econstructor; eauto. intros. constructor. auto. auto.
-(* seqor true *)
-  exploit tr_top_leftcontext; eauto. clear H9.
-  intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].
-  inv P. inv H2.
-  (* for val *)
-  exploit tr_simple_rvalue; eauto. intros [SL [TY EV]].
-  subst sl0; simpl Kseqlist.
-  econstructor; split.
-  left. eapply plus_left. constructor.
-  eapply star_trans. apply step_makeif with (b := true) (v1 := v); auto. congruence.
-  apply star_one. constructor. constructor. reflexivity. reflexivity.
-  eapply match_exprstates; eauto.
-  change sl2 with (nil ++ sl2). apply S. econstructor; eauto.
-  intros. constructor. rewrite H2. apply PTree.gss. auto.
-  intros. apply PTree.gso. congruence.
-  auto.
-  (* for effects *)
-  exploit tr_simple_rvalue; eauto. intros [SL [TY EV]].
-  subst sl0; simpl Kseqlist.
-  econstructor; split.
-  left. eapply plus_left. constructor.
-  apply step_makeif with (b := true) (v1 := v); auto. congruence.
-  reflexivity.
-  eapply match_exprstates; eauto.
-  change sl2 with (nil ++ sl2). apply S. econstructor; eauto.
-  auto. auto.
-  (* for set *)
-  exploit tr_simple_rvalue; eauto. intros [SL [TY EV]].
-  subst sl0; simpl Kseqlist.
-  econstructor; split.
-  left. eapply plus_left. constructor.
-  eapply star_trans. apply step_makeif with (b := true) (v1 := v); auto. congruence.
-  apply push_seq. reflexivity. reflexivity.
-  rewrite <- Kseqlist_app.
-  eapply match_exprstates; eauto.
-  apply S. econstructor; eauto. intros. constructor. auto. auto.
-(* seqand false *)
-  exploit tr_top_leftcontext; eauto. clear H9.
-  intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].
-  inv P. inv H2.
-  (* for val *)
-  exploit tr_simple_rvalue; eauto. intros [SL [TY EV]].
-  subst sl0; simpl Kseqlist.
-  econstructor; split.
-  left. eapply plus_left. constructor.
-  eapply star_trans. apply step_makeif with (b := false) (v1 := v); auto. congruence.
-  apply push_seq. reflexivity. reflexivity.
-  rewrite <- Kseqlist_app.
-  eapply match_exprstates; eauto.
-  apply S. apply tr_paren_val with (a1 := a2); auto.
-  apply tr_expr_monotone with tmp2; eauto. auto. auto.
-  (* for effects *)
-  exploit tr_simple_rvalue; eauto. intros [SL [TY EV]].
-  subst sl0; simpl Kseqlist.
-  econstructor; split.
-  left. eapply plus_left. constructor.
-  eapply star_trans. apply step_makeif with (b := false) (v1 := v); auto. congruence.
-  apply push_seq. reflexivity. reflexivity.
-  rewrite <- Kseqlist_app.
-  eapply match_exprstates; eauto.
-  apply S. apply tr_paren_effects with (a1 := a2); auto.
-  apply tr_expr_monotone with tmp2; eauto. auto. auto.
-  (* for set *)
-  exploit tr_simple_rvalue; eauto. intros [SL [TY EV]].
-  subst sl0; simpl Kseqlist.
-  econstructor; split.
-  left. eapply plus_left. constructor.
-  eapply star_trans. apply step_makeif with (b := false) (v1 := v); auto. congruence.
-  apply push_seq. reflexivity. reflexivity.
-  rewrite <- Kseqlist_app.
-  eapply match_exprstates; eauto.
-  apply S. apply tr_paren_set with (a1 := a2) (t := sd_temp sd); auto.
-  apply tr_expr_monotone with tmp2; eauto. auto. auto.
-(* condition *)
-  exploit tr_top_leftcontext; eauto. clear H9.
-  intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].
-  inv P. inv H2.
-  (* for value *)
-  exploit tr_simple_rvalue; eauto. intros [SL [TY EV]].
-  subst sl0; simpl Kseqlist. destruct b.
-  econstructor; split.
-  left. eapply plus_left. constructor.
-  eapply star_trans. apply step_makeif with (b := true) (v1 := v); auto. congruence.
-  apply push_seq. reflexivity. reflexivity.
-  rewrite <- Kseqlist_app.
-  eapply match_exprstates; eauto.
-  apply S. econstructor; eauto. apply tr_expr_monotone with tmp2; eauto. auto. auto.
-  econstructor; split.
-  left. eapply plus_left. constructor.
-  eapply star_trans. apply step_makeif with (b := false) (v1 := v); auto. congruence.
-  apply push_seq. reflexivity. reflexivity.
-  rewrite <- Kseqlist_app.
-  eapply match_exprstates; eauto.
-  apply S. econstructor; eauto. apply tr_expr_monotone with tmp3; eauto. auto. auto.
-  (* for effects *)
-  exploit tr_simple_rvalue; eauto. intros [SL [TY EV]].
-  subst sl0; simpl Kseqlist. destruct b.
-  econstructor; split.
-  left. eapply plus_left. constructor.
-  eapply star_trans. apply step_makeif with (b := true) (v1 := v); auto. congruence.
-  apply push_seq.
-  reflexivity. traceEq.
-  rewrite <- Kseqlist_app.
-  econstructor. eauto. apply S.
-    econstructor; eauto. apply tr_expr_monotone with tmp2; eauto.
-    econstructor; eauto.
-  auto. auto.
-  econstructor; split.
-  left. eapply plus_left. constructor.
-  eapply star_trans. apply step_makeif with (b := false) (v1 := v); auto. congruence.
-  apply push_seq.
-  reflexivity. traceEq.
-  rewrite <- Kseqlist_app.
-  econstructor. eauto. apply S.
-    econstructor; eauto. apply tr_expr_monotone with tmp3; eauto.
-    econstructor; eauto.
-  auto. auto.
-  (* for set *)
-  exploit tr_simple_rvalue; eauto. intros [SL [TY EV]].
-  subst sl0; simpl Kseqlist. destruct b.
-  econstructor; split.
-  left. eapply plus_left. constructor.
-  eapply star_trans. apply step_makeif with (b := true) (v1 := v); auto. congruence.
-  apply push_seq.
-  reflexivity. traceEq.
-  rewrite <- Kseqlist_app.
-  econstructor. eauto. apply S.
-    econstructor; eauto. apply tr_expr_monotone with tmp2; eauto.
-    econstructor; eauto.
-  auto. auto.
-  econstructor; split.
-  left. eapply plus_left. constructor.
-  eapply star_trans. apply step_makeif with (b := false) (v1 := v); auto. congruence.
-  apply push_seq.
-  reflexivity. traceEq.
-  rewrite <- Kseqlist_app.
-  econstructor. eauto. apply S.
-    econstructor; eauto. apply tr_expr_monotone with tmp3; eauto.
-    econstructor; eauto.
-  auto. auto.
-(* assign *)
-  exploit tr_top_leftcontext; eauto. clear H12.
-  intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].
-  inv P. inv H4.
-  (* for effects *)
-  exploit tr_simple_rvalue; eauto. intros [SL2 [TY2 EV2]].
-  exploit tr_simple_lvalue; eauto. intros [SL1 [TY1 EV1]].
-  subst; simpl Kseqlist.
-  econstructor; split.
-  left. eapply plus_left. constructor.
-  apply star_one. eapply step_make_assign; eauto.
-  rewrite <- TY2; eauto. traceEq.
-  econstructor. auto. change sl2 with (nil ++ sl2). apply S.
-  constructor. auto. auto. auto.
-  (* for value *)
-  exploit tr_simple_rvalue; eauto. intros [SL2 [TY2 EV2]].
-  exploit tr_simple_lvalue. eauto.
-    eapply tr_expr_invariant with (le' := PTree.set t0 v' le). eauto.
-    intros. apply PTree.gso. intuition congruence.
-  intros [SL1 [TY1 EV1]].
-  subst; simpl Kseqlist.
-  econstructor; split.
-  left. eapply plus_left. constructor.
-  eapply star_left. constructor. econstructor. eauto. rewrite <- TY2; eauto. 
-  eapply star_left. constructor.
-  apply star_one. eapply step_make_assign; eauto.
-  constructor. apply PTree.gss. simpl. eapply cast_idempotent; eauto. 
-  reflexivity. reflexivity. traceEq.
-  econstructor. auto. apply S.
-  apply tr_val_gen. auto. intros. constructor.
-  rewrite H4; auto. apply PTree.gss.
-  intros. apply PTree.gso. intuition congruence.
-  auto. auto.
-(* assignop *)
-  exploit tr_top_leftcontext; eauto. clear H15.
-  intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].
-  inv P. inv H6.
-  (* for effects *)
-  exploit tr_simple_lvalue; eauto. intros [SL1 [TY1 EV1]].
-  exploit step_tr_rvalof; eauto. intros [le' [EXEC [EV3 [TY3 INV]]]].
-  exploit tr_simple_lvalue. eauto. eapply tr_expr_invariant with (le := le) (le' := le'). eauto.
-  intros. apply INV. NOTIN. intros [? [? EV1']].
-  exploit tr_simple_rvalue. eauto. eapply tr_expr_invariant with (le := le) (le' := le'). eauto.
-  intros. apply INV. NOTIN. simpl. intros [SL2 [TY2 EV2]].
-  subst; simpl Kseqlist.
-  econstructor; split.
-  left. eapply star_plus_trans. rewrite app_ass. rewrite Kseqlist_app. eexact EXEC.
-  eapply plus_two. simpl. econstructor. eapply step_make_assign; eauto.
-    econstructor. eexact EV3. eexact EV2.
-    rewrite TY3; rewrite <- TY1; rewrite <- TY2; rewrite comp_env_preserved; auto.
-  reflexivity. traceEq.
-  econstructor. auto. change sl2 with (nil ++ sl2). apply S.
-  constructor. auto. auto. auto.
-  (* for value *)
-  exploit tr_simple_lvalue; eauto. intros [SL1 [TY1 EV1]].
-  exploit step_tr_rvalof; eauto. intros [le' [EXEC [EV3 [TY3 INV]]]].
-  exploit tr_simple_lvalue. eauto. eapply tr_expr_invariant with (le := le) (le' := le'). eauto.
-  intros. apply INV. NOTIN. intros [? [? EV1']].
-  exploit tr_simple_rvalue. eauto. eapply tr_expr_invariant with (le := le) (le' := le'). eauto.
-  intros. apply INV. NOTIN. simpl. intros [SL2 [TY2 EV2]].
-  exploit tr_simple_lvalue. eauto.
-    eapply tr_expr_invariant with (le := le) (le' := PTree.set t v4 le'). eauto.
-    intros. rewrite PTree.gso. apply INV. NOTIN. intuition congruence.
-  intros [? [? EV1'']].
-  subst; simpl Kseqlist.
-  econstructor; split.
-  left. rewrite app_ass. rewrite Kseqlist_app.
-  eapply star_plus_trans. eexact EXEC.
-  simpl. eapply plus_four. econstructor. econstructor.
-    econstructor. econstructor. eexact EV3. eexact EV2.
-    rewrite TY3; rewrite <- TY1; rewrite <- TY2; rewrite comp_env_preserved; eauto.
-    eassumption.
-  econstructor. eapply step_make_assign; eauto.
-    constructor. apply PTree.gss. simpl. eapply cast_idempotent; eauto.
-    reflexivity. traceEq.
-  econstructor. auto. apply S.
-  apply tr_val_gen. auto. intros. constructor.
-  rewrite H10; auto. apply PTree.gss.
-  intros. rewrite PTree.gso. apply INV.
-  red; intros; elim H10; auto.
-  intuition congruence.
-  auto. auto.
-(* assignop stuck *)
-  exploit tr_top_leftcontext; eauto. clear H12.
-  intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].
-  inv P. inv H4.
-  (* for effects *)
-  exploit tr_simple_lvalue; eauto. intros [SL1 [TY1 EV1]].
-  exploit tr_simple_rvalue; eauto. intros [SL2 [TY2 EV2]].
-  exploit step_tr_rvalof; eauto. intros [le' [EXEC [EV3 [TY3 INV]]]].
-  subst; simpl Kseqlist.
-  econstructor; split.
-  right; split. rewrite app_ass. rewrite Kseqlist_app. eexact EXEC.
-  simpl. lia.
-  constructor.
-  (* for value *)
-  exploit tr_simple_lvalue; eauto. intros [SL1 [TY1 EV1]].
-  exploit tr_simple_rvalue; eauto. intros [SL2 [TY2 EV2]].
-  exploit step_tr_rvalof; eauto. intros [le' [EXEC [EV3 [TY3 INV]]]].
-  subst; simpl Kseqlist.
-  econstructor; split.
-  right; split. rewrite app_ass. rewrite Kseqlist_app. eexact EXEC.
-  simpl. lia.
-  constructor.
-(* postincr *)
-  exploit tr_top_leftcontext; eauto. clear H14.
-  intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].
-  inv P. inv H5.
-  (* for effects *)
-  exploit tr_simple_lvalue; eauto. intros [SL1 [TY1 EV1]].
-  exploit step_tr_rvalof; eauto. intros [le' [EXEC [EV3 [TY3 INV]]]].
-  exploit tr_simple_lvalue. eauto. eapply tr_expr_invariant with (le := le) (le' := le'). eauto.
-  intros. apply INV. NOTIN. intros [? [? EV1']].
-  subst; simpl Kseqlist.
-  econstructor; split.
-  left. rewrite app_ass; rewrite Kseqlist_app.
-  eapply star_plus_trans. eexact EXEC.
-  eapply plus_two. simpl. constructor.
-  eapply step_make_assign; eauto.
-  unfold transl_incrdecr. destruct id; simpl in H2.
-  econstructor. eauto. constructor. rewrite TY3; rewrite <- TY1; rewrite comp_env_preserved. simpl; eauto.
-  econstructor. eauto. constructor. rewrite TY3; rewrite <- TY1; rewrite comp_env_preserved. simpl; eauto.
-  destruct id; auto.
-  reflexivity. traceEq.
-  econstructor. auto. change sl2 with (nil ++ sl2). apply S.
-  constructor. auto. auto. auto.
-  (* for value *)
-  exploit tr_simple_lvalue; eauto. intros [SL1 [TY1 EV1]].
-  exploit tr_simple_lvalue. eauto.
-    eapply tr_expr_invariant with (le' := PTree.set t v1 le). eauto.
-    intros. apply PTree.gso. intuition congruence.
-  intros [SL2 [TY2 EV2]].
-  subst; simpl Kseqlist.
-  econstructor; split.
-  left. eapply plus_four. constructor.
-  eapply step_make_set; eauto.
-  constructor.
-  eapply step_make_assign; eauto.
-  unfold transl_incrdecr. destruct id; simpl in H2.
-  econstructor. constructor. apply PTree.gss. constructor.
-  rewrite comp_env_preserved; simpl; eauto.
-  econstructor. constructor. apply PTree.gss. constructor.
-  rewrite comp_env_preserved; simpl; eauto.
-  destruct id; auto.
-  traceEq.
-  econstructor. auto. apply S.
-  apply tr_val_gen. auto. intros. econstructor; eauto.
-  rewrite H5; auto. apply PTree.gss.
-  intros. apply PTree.gso. intuition congruence.
-  auto. auto.
-(* postincr stuck *)
-  exploit tr_top_leftcontext; eauto. clear H11.
-  intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].
-  inv P. inv H3.
-  (* for effects *)
-  exploit tr_simple_lvalue; eauto. intros [SL1 [TY1 EV1]].
-  exploit step_tr_rvalof; eauto. intros [le' [EXEC [EV3 [TY3 INV]]]].
-  subst. simpl Kseqlist.
-  econstructor; split.
-  right; split. rewrite app_ass; rewrite Kseqlist_app. eexact EXEC.
-  simpl; lia.
-  constructor.
-  (* for value *)
-  exploit tr_simple_lvalue; eauto. intros [SL1 [TY1 EV1]].
-  subst. simpl Kseqlist.
-  econstructor; split.
-  left. eapply plus_two. constructor. eapply step_make_set; eauto.
-  traceEq.
-  constructor.
-(* comma *)
-  exploit tr_top_leftcontext; eauto. clear H9.
-  intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].
-  inv P. inv H1.
-  exploit tr_simple_rvalue; eauto. simpl; intro SL1.
-  subst sl0; simpl Kseqlist.
-  econstructor; split.
-  right; split. apply star_refl. simpl. apply plus_lt_compat_r.
-  apply (leftcontext_size _ _ _ H). simpl. lia.
-  econstructor; eauto. apply S.
-  eapply tr_expr_monotone; eauto.
-  auto. auto.
-(* paren *)
-  exploit tr_top_leftcontext; eauto. clear H9.
-  intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].
-  inv P. inv H2.
-  (* for value *)
-  exploit tr_simple_rvalue; eauto. intros [b [SL1 [TY1 EV1]]].
-  subst sl1; simpl Kseqlist.
-  econstructor; split.
-  left. eapply plus_left. constructor. apply star_one.
-  econstructor. econstructor; eauto. rewrite <- TY1; eauto. traceEq.
-  econstructor; eauto.
-  change sl2 with (final For_val (Etempvar t (Csyntax.typeof r)) ++ sl2). apply S.
-  constructor. auto. intros. constructor. rewrite H2; auto. apply PTree.gss.
-  intros. apply PTree.gso. intuition congruence.
-  auto.
-  (* for effects *)
-  econstructor; split.
-  right; split. apply star_refl. simpl. apply plus_lt_compat_r.
-  apply (leftcontext_size _ _ _ H). simpl. lia.
-  econstructor; eauto.
-  exploit tr_simple_rvalue; eauto. simpl. intros A. subst sl1.
-  apply S. constructor; auto. auto. auto.
-  (* for set *)
-  exploit tr_simple_rvalue; eauto. simpl. intros [b [SL1 [TY1 EV1]]]. subst sl1.
-  simpl Kseqlist.
-  econstructor; split.
-  left. eapply plus_left. constructor. apply star_one. econstructor. econstructor; eauto.
-  rewrite <- TY1; eauto. traceEq.
-  econstructor; eauto.
-  apply S. constructor; auto.
-  intros. constructor. rewrite H2. apply PTree.gss. auto.
-  intros. apply PTree.gso. congruence.
-  auto.
-
-(* call *)
-  exploit tr_top_leftcontext; eauto. clear H12.
-  intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].
-  inv P. inv H5.
-  (* for effects *)
-  exploit tr_simple_rvalue; eauto. intros [SL1 [TY1 EV1]].
-  exploit tr_simple_exprlist; eauto. intros [SL2 EV2].
-  subst. simpl Kseqlist.
-  exploit functions_translated; eauto. intros [tfd [J K]].
-  econstructor; split.
-  left. eapply plus_left. constructor.  apply star_one.
-  econstructor; eauto. rewrite <- TY1; eauto.
-  exploit type_of_fundef_preserved; eauto. congruence.
-  traceEq.
-  constructor; auto. econstructor; eauto.
-  intros. change sl2 with (nil ++ sl2). apply S.
-  constructor. auto. auto.
-  (* for value *)
-  exploit tr_simple_rvalue; eauto. intros [SL1 [TY1 EV1]].
-  exploit tr_simple_exprlist; eauto. intros [SL2 EV2].
-  subst. simpl Kseqlist.
-  exploit functions_translated; eauto. intros [tfd [J K]].
-  econstructor; split.
-  left. eapply plus_left. constructor.  apply star_one.
-  econstructor; eauto. rewrite <- TY1; eauto.
-  exploit type_of_fundef_preserved; eauto. congruence.
-  traceEq.
-  constructor; auto. econstructor; eauto.
-  intros. apply S.
-  destruct dst'; constructor.
-  auto. intros. constructor. rewrite H5; auto. apply PTree.gss.
-  auto. intros. constructor. rewrite H5; auto. apply PTree.gss.
-  intros. apply PTree.gso. intuition congruence.
-  auto.
-
-(* builtin *)
-  exploit tr_top_leftcontext; eauto. clear H9.
-  intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].
-  inv P. inv H2.
-  (* for effects *)
-  exploit tr_simple_exprlist; eauto. intros [SL EV].
-  subst. simpl Kseqlist.
-  econstructor; split.
-  left. eapply plus_left. constructor.  apply star_one.
-  econstructor; eauto.
-  eapply external_call_symbols_preserved; eauto. apply senv_preserved.
-  traceEq.
-  econstructor; eauto.
-  change sl2 with (nil ++ sl2). apply S. constructor. simpl; auto. auto.
-  (* for value *)
-  exploit tr_simple_exprlist; eauto. intros [SL EV].
-  subst. simpl Kseqlist.
-  econstructor; split.
-  left. eapply plus_left. constructor. apply star_one.
-  econstructor; eauto.
-  eapply external_call_symbols_preserved; eauto. apply senv_preserved.
-  traceEq.
-  econstructor; eauto.
-  change sl2 with (nil ++ sl2). apply S.
-  apply tr_val_gen. auto. intros. constructor. rewrite H2; auto. simpl. apply PTree.gss.
-  intros; simpl. apply PTree.gso. intuition congruence.
-  auto.
-Qed.
-
-(** Forward simulation for statements. *)
-
-Lemma tr_top_val_for_val_inv:
-  forall e le m v ty sl a tmps,
-  tr_top tge e le m For_val (Csyntax.Eval v ty) sl a tmps ->
-  sl = nil /\ typeof a = ty /\ eval_expr tge e le m a v.
-Proof.
-  intros. inv H. auto. inv H0. auto.
-Qed.
-
-Lemma alloc_variables_preserved:
-  forall e m params e' m',
-  Csem.alloc_variables ge e m params e' m' ->
-  alloc_variables tge e m params e' m'.
-Proof.
-  induction 1; econstructor; eauto. rewrite comp_env_preserved; auto.
-Qed.
-
-Lemma bind_parameters_preserved:
-  forall e m params args m',
-  Csem.bind_parameters ge e m params args m' ->
-  bind_parameters tge e m params args m'.
-Proof.
-  induction 1; econstructor; eauto. inv H0.
-- eapply assign_loc_value; eauto.
-- inv H4. eapply assign_loc_value; eauto.
-- rewrite <- comp_env_preserved in *. eapply assign_loc_copy; eauto.
-Qed.
-
-Lemma blocks_of_env_preserved:
-  forall e, blocks_of_env tge e = Csem.blocks_of_env ge e.
-Proof.
-  intros; unfold blocks_of_env, Csem.blocks_of_env.
-  unfold block_of_binding, Csem.block_of_binding.
-  rewrite comp_env_preserved. auto.
-Qed.
-
-Lemma sstep_simulation:
-  forall S1 t S2, Csem.sstep ge S1 t S2 ->
-  forall S1' (MS: match_states S1 S1'),
-  exists S2',
-     (plus step1 tge S1' t S2' \/
-       (star step1 tge S1' t S2' /\ measure S2 < measure S1)%nat)
-  /\ match_states S2 S2'.
-Proof.
-  induction 1; intros; inv MS.
-(* do 1 *)
-  inv H6. inv H0.
-  econstructor; split.
-  right; split. apply push_seq.
-  simpl. lia.
-  econstructor; eauto. constructor. auto.
-(* do 2 *)
-  inv H7. inv H6. inv H.
-  econstructor; split.
-  right; split. apply star_refl. simpl. lia.
-  econstructor; eauto. constructor.
-
-(* seq *)
-  inv H6. econstructor; split. left. apply plus_one. constructor.
-  econstructor; eauto. constructor; auto.
-(* skip seq *)
-  inv H6; inv H7. econstructor; split.
-  left. apply plus_one; constructor.
-  econstructor; eauto.
-(* continue seq *)
-  inv H6; inv H7. econstructor; split.
-  left. apply plus_one; constructor.
-  econstructor; eauto. constructor.
-(* break seq *)
-  inv H6; inv H7. econstructor; split.
-  left. apply plus_one; constructor.
-  econstructor; eauto. constructor.
-(* ifthenelse *)
-  inv H6.
-(* ifthenelse empty *)
-  inv H3. econstructor; split.
-  left. eapply plus_left. constructor. apply push_seq.
-  econstructor; eauto.
-  econstructor; eauto.
-  econstructor; eauto.
-(* ifthenelse non empty *)
-  inv H2. econstructor; split.
-  left. eapply plus_left. constructor. apply push_seq. traceEq.
-  econstructor; eauto. econstructor; eauto.
-(* ifthenelse *)
-  inv H8.
-(* ifthenelse empty *)
-  exploit tr_top_val_for_val_inv; eauto. intros [A [B C]]. subst.
-  econstructor; split; simpl.
-  right. destruct b; econstructor; eauto.
-  eapply star_left. apply step_skip_seq. econstructor. traceEq.
-  eapply star_left. apply step_skip_seq. econstructor. traceEq.
-  destruct b; econstructor; eauto. econstructor; eauto. econstructor; eauto.
-  (* ifthenelse non empty *)
-  exploit tr_top_val_for_val_inv; eauto. intros [A [B C]]. subst.
-  econstructor; split.
-  left. eapply plus_two. constructor.
-  apply step_ifthenelse with (v1 := v) (b := b); auto. traceEq.
-  destruct b; econstructor; eauto.
-(* while *)
-  inv H6. inv H1. econstructor; split.
-  left. eapply plus_left. constructor.
-  eapply star_left. constructor.
-  apply push_seq.
-  reflexivity. traceEq. rewrite Kseqlist_app.
-  econstructor; eauto. simpl.  econstructor; eauto. econstructor; eauto.
-(* while false *)
-  inv H8.
-  exploit tr_top_val_for_val_inv; eauto. intros [A [B C]]. subst.
-  econstructor; split.
-  left. simpl. eapply plus_left. constructor.
-  eapply star_trans. apply step_makeif with (v1 := v) (b := false); auto.
-  eapply star_two. constructor. apply step_break_loop1.
-  reflexivity. reflexivity. traceEq.
-  constructor; auto. constructor.
-(* while true *)
-  inv H8.
-  exploit tr_top_val_for_val_inv; eauto. intros [A [B C]]. subst.
-  econstructor; split.
-  left. simpl. eapply plus_left. constructor.
-  eapply star_right. apply step_makeif with (v1 := v) (b := true); auto.
-  constructor.
-  reflexivity. traceEq.
-  constructor; auto. constructor; auto.
-(* skip-or-continue while *)
-  assert (ts = Sskip \/ ts = Scontinue). destruct H; subst s0; inv H7; auto.
-  inv H8.
-  econstructor; split.
-  left. eapply plus_two. apply step_skip_or_continue_loop1; auto.
-  apply step_skip_loop2. traceEq.
-  constructor; auto. constructor; auto.
-(* break while *)
-  inv H6. inv H7.
-  econstructor; split.
-  left. apply plus_one. apply step_break_loop1.
-  constructor; auto. constructor.
-
-(* dowhile *)
-  inv H6.
-  econstructor; split.
-  left. apply plus_one. apply step_loop.
-  constructor; auto. constructor; auto.
-(* skip_or_continue dowhile *)
-  assert (ts = Sskip \/ ts = Scontinue). destruct H; subst s0; inv H7; auto.
-  inv H8. inv H4.
-  econstructor; split.
-  left. eapply plus_left. apply step_skip_or_continue_loop1. auto.
-  apply push_seq.
-  traceEq.
-  rewrite Kseqlist_app.
-  econstructor; eauto. simpl. econstructor; auto. econstructor; eauto.
-(* dowhile false *)
-  inv H8.
-  exploit tr_top_val_for_val_inv; eauto. intros [A [B C]]. subst.
-  econstructor; split.
-  left. simpl. eapply plus_left. constructor.
-  eapply star_right. apply step_makeif with (v1 := v) (b := false); auto.
-  constructor.
-  reflexivity. traceEq.
-  constructor; auto. constructor.
-(* dowhile true *)
-  inv H8.
-  exploit tr_top_val_for_val_inv; eauto. intros [A [B C]]. subst.
-  econstructor; split.
-  left. simpl. eapply plus_left. constructor.
-  eapply star_right. apply step_makeif with (v1 := v) (b := true); auto.
-  constructor.
-  reflexivity. traceEq.
-  constructor; auto. constructor; auto.
-(* break dowhile *)
-  inv H6. inv H7.
-  econstructor; split.
-  left. apply plus_one. apply step_break_loop1.
-  constructor; auto. constructor.
-
-(* for start *)
-  inv H7. congruence.
-  econstructor; split.
-  left; apply plus_one. constructor.
-  econstructor; eauto. constructor; auto. econstructor; eauto.
-(* for *)
-  inv H6; try congruence. inv H2.
-  econstructor; split.
-  left. eapply plus_left. apply step_loop.
-  eapply star_left. constructor. apply push_seq.
-  reflexivity. traceEq.
-  rewrite Kseqlist_app. econstructor; eauto. simpl. constructor; auto. econstructor; eauto.
-(* for false *)
-  inv H8. exploit tr_top_val_for_val_inv; eauto. intros [A [B C]]. subst.
-  econstructor; split.
-  left. simpl. eapply plus_left. constructor.
-  eapply star_trans. apply step_makeif with (v1 := v) (b := false); auto.
-  eapply star_two. constructor. apply step_break_loop1.
-  reflexivity. reflexivity. traceEq.
-  constructor; auto. constructor.
-(* for true *)
-  inv H8. exploit tr_top_val_for_val_inv; eauto. intros [A [B C]]. subst.
-  econstructor; split.
-  left. simpl. eapply plus_left. constructor.
-  eapply star_right. apply step_makeif with (v1 := v) (b := true); auto.
-  constructor.
-  reflexivity. traceEq.
-  constructor; auto. constructor; auto.
-(* skip_or_continue for3 *)
-  assert (ts = Sskip \/ ts = Scontinue). destruct H; subst x; inv H7; auto.
-  inv H8.
-  econstructor; split.
-  left. apply plus_one. apply step_skip_or_continue_loop1. auto.
-  econstructor; eauto. econstructor; auto.
-(* break for3 *)
-  inv H6. inv H7.
-  econstructor; split.
-  left. apply plus_one. apply step_break_loop1.
-  econstructor; eauto. constructor.
-(* skip for4 *)
-  inv H6. inv H7.
-  econstructor; split.
-  left. apply plus_one. constructor.
-  econstructor; eauto. constructor; auto.
-
-
-(* return none *)
-  inv H7. econstructor; split.
-  left. apply plus_one. econstructor; eauto. rewrite blocks_of_env_preserved; eauto.
-  constructor. apply match_cont_call; auto.
-(* return some 1 *)
-  inv H6. inv H0. econstructor; split.
-  left; eapply plus_left. constructor. apply push_seq. traceEq.
-  econstructor; eauto. constructor. auto.
-(* return some 2 *)
-  inv H9. exploit tr_top_val_for_val_inv; eauto. intros [A [B C]]. subst.
-  econstructor; split.
-  left. eapply plus_two. constructor. econstructor. eauto.
-  erewrite function_return_preserved; eauto. rewrite blocks_of_env_preserved; eauto.
-  eauto. traceEq.
-  constructor. apply match_cont_call; auto.
-(* skip return *)
-  inv H8.
-  assert (is_call_cont tk). inv H9; simpl in *; auto.
-  econstructor; split.
-  left. apply plus_one. apply step_skip_call; eauto. rewrite blocks_of_env_preserved; eauto.
-  constructor. auto.
-
-(* switch *)
-  inv H6. inv H1.
-  econstructor; split.
-  left; eapply plus_left. constructor. apply push_seq. traceEq.
-  econstructor; eauto. constructor; auto.
-(* expr switch *)
-  inv H8. exploit tr_top_val_for_val_inv; eauto. intros [A [B C]]. subst.
-  econstructor; split.
-  left; eapply plus_two. constructor. econstructor; eauto. traceEq.
-  econstructor; eauto.
-  apply tr_seq_of_labeled_statement. apply tr_select_switch. auto.
-  constructor; auto.
-
-(* skip-or-break switch *)
-  assert (ts = Sskip \/ ts = Sbreak). destruct H; subst x; inv H7; auto.
-  inv H8.
-  econstructor; split.
-  left; apply plus_one. apply step_skip_break_switch. auto.
-  constructor; auto. constructor.
-
-(* continue switch *)
-  inv H6. inv H7.
-  econstructor; split.
-  left; apply plus_one. apply step_continue_switch.
-  constructor; auto. constructor.
-
-(* label *)
-  inv H6. econstructor; split.
-  left; apply plus_one. constructor.
-  constructor; auto.
-
-(* goto *)
-  inv H7.
-  inversion H6; subst.
-  exploit tr_find_label. eauto. apply match_cont_call. eauto.
-  instantiate (1 := lbl). rewrite H.
-  intros [ts' [tk' [P [Q R]]]].
-  econstructor; split.
-  left. apply plus_one. econstructor; eauto.
-  econstructor; eauto.
-
-(* internal function *)
-  inv H7. inversion H3; subst.
-  econstructor; split.
-  left; apply plus_one. eapply step_internal_function. econstructor.
-  rewrite H6; rewrite H7; auto.
-  rewrite H6; rewrite H7. eapply alloc_variables_preserved; eauto.
-  rewrite H6. eapply bind_parameters_preserved; eauto.
-  eauto.
-  constructor; auto.
-
-(* external function *)
-  inv H5.
-  econstructor; split.
-  left; apply plus_one. econstructor; eauto.
-  eapply external_call_symbols_preserved; eauto. apply senv_preserved.
-  constructor; auto.
-
-(* return *)
-  inv H3.
-  econstructor; split.
-  left; apply plus_one. constructor.
-  econstructor; eauto.
-Qed.
-
-(** Semantic preservation *)
-
-Theorem simulation:
-  forall S1 t S2, Cstrategy.step ge S1 t S2 ->
-  forall S1' (MS: match_states S1 S1'),
-  exists S2',
-     (plus step1 tge S1' t S2' \/
-       (star step1 tge S1' t S2' /\ measure S2 < measure S1)%nat)
-  /\ match_states S2 S2'.
-Proof.
-  intros S1 t S2 STEP. destruct STEP.
-  apply estep_simulation; auto.
-  apply sstep_simulation; auto.
-Qed.
-
-Lemma transl_initial_states:
-  forall S,
-  Csem.initial_state prog S ->
-  exists S', Clight.initial_state tprog S' /\ match_states S S'.
-Proof.
-  intros. inv H.
-  exploit function_ptr_translated; eauto. intros [tf [FIND TR]].
-  econstructor; split.
-  econstructor.
-  eapply (Genv.init_mem_match (proj1 TRANSL)); eauto.
-  replace (prog_main tprog) with (prog_main prog).
-  rewrite symbols_preserved. eauto. 
-  destruct TRANSL. destruct H as (A & B & C). simpl in B. auto. 
-  eexact FIND.
-  rewrite <- H3. apply type_of_fundef_preserved. auto.
-  constructor. auto. constructor.
-Qed.
-
-Lemma transl_final_states:
-  forall S S' r,
-  match_states S S' -> Csem.final_state S r -> Clight.final_state S' r.
-Proof.
-  intros. inv H0. inv H. inv H4. constructor.
-Qed.
-
-Theorem transl_program_correct:
-  forward_simulation (Cstrategy.semantics prog) (Clight.semantics1 tprog).
-Proof.
-  eapply forward_simulation_star_wf with (order := ltof _ measure).
-  eapply senv_preserved.
-  eexact transl_initial_states.
-  eexact transl_final_states.
-  apply well_founded_ltof.
-  exact simulation.
-Qed.
-
-End PRESERVATION.
+(* Lemma transf_program_match: *)
+(*   forall p tp, transl_program p = OK tp -> match_prog p tp. *)
+(* Proof. *)
+(*   unfold transl_program; intros. monadInv H. split; auto. *)
+(*   unfold program_of_program; simpl. destruct x; simpl. *)
+(*   eapply match_transform_partial_program_contextual. eexact EQ.  *)
+(*   intros. apply transl_fundef_spec; auto.  *)
+(* Qed. *)
+
+(* (** ** Semantic preservation *) *)
+
+(* Section PRESERVATION. *)
+
+(* Variable prog: Csyntax.program. *)
+(* Variable tprog: Clight.program. *)
+(* Hypothesis TRANSL: match_prog prog tprog. *)
+
+(* Let ge := Csem.globalenv prog. *)
+(* Let tge := Clight.globalenv tprog. *)
+
+(* (** Invariance properties. *) *)
+
+(* Lemma comp_env_preserved: *)
+(*   Clight.genv_cenv tge = Csem.genv_cenv ge. *)
+(* Proof. *)
+(*   simpl. destruct TRANSL. generalize (prog_comp_env_eq tprog) (prog_comp_env_eq prog).  *)
+(*   congruence. *)
+(* Qed. *)
+
+(* Lemma symbols_preserved: *)
+(*   forall (s: ident), Genv.find_symbol tge s = Genv.find_symbol ge s. *)
+(* Proof (Genv.find_symbol_match (proj1 TRANSL)). *)
+
+(* Lemma senv_preserved: *)
+(*   Senv.equiv ge tge. *)
+(* Proof (Genv.senv_match (proj1 TRANSL)). *)
+
+(* Lemma function_ptr_translated: *)
+(*   forall b f, *)
+(*   Genv.find_funct_ptr ge b = Some f -> *)
+(*   exists tf, *)
+(*   Genv.find_funct_ptr tge b = Some tf /\ tr_fundef f tf. *)
+(* Proof. *)
+(*   intros. *)
+(*   edestruct (Genv.find_funct_ptr_match (proj1 TRANSL)) as (ctx & tf & A & B & C); eauto. *)
+(* Qed. *)
+
+(* Lemma functions_translated: *)
+(*   forall v f, *)
+(*   Genv.find_funct ge v = Some f -> *)
+(*   exists tf, *)
+(*   Genv.find_funct tge v = Some tf /\ tr_fundef f tf. *)
+(* Proof. *)
+(*   intros. *)
+(*   edestruct (Genv.find_funct_match (proj1 TRANSL)) as (ctx & tf & A & B & C); eauto. *)
+(* Qed. *)
+
+(* Lemma type_of_fundef_preserved: *)
+(*   forall f tf, tr_fundef f tf -> *)
+(*   type_of_fundef tf = Csyntax.type_of_fundef f. *)
+(* Proof. *)
+(*   intros. inv H. *)
+(*   inv H0; simpl. unfold type_of_function, Csyntax.type_of_function. congruence. *)
+(*   auto. *)
+(* Qed. *)
+
+(* Lemma function_return_preserved: *)
+(*   forall f tf, tr_function f tf -> *)
+(*   fn_return tf = Csyntax.fn_return f. *)
+(* Proof. *)
+(*   intros. inv H; auto. *)
+(* Qed. *)
+
+(* (** Properties of smart constructors. *) *)
+
+(* Lemma eval_Ederef': *)
+(*   forall ge e le m a t l ofs, *)
+(*   eval_expr ge e le m a (Vptr l ofs) -> *)
+(*   eval_lvalue ge e le m (Ederef' a t) (Vptr l ofs). *)
+(* Proof. *)
+(*   intros. unfold Ederef'; destruct a; auto using eval_Ederef. *)
+(*   destruct (type_eq t (typeof a)); auto using eval_Ederef. *)
+(*   inv H. *)
+(* - auto.  *)
+(* - inv H0. *)
+(* Qed. *)
+
+(* Lemma typeof_Ederef': *)
+(*   forall a t, typeof (Ederef' a t) = t. *)
+(* Proof. *)
+(*   unfold Ederef'; intros; destruct a; auto. destruct (type_eq t (typeof a)); auto.  *)
+(* Qed. *)
+
+(* Lemma eval_Eaddrof': *)
+(*   forall ge e le m a t v, *)
+(*   eval_lvalue ge e le m a v -> *)
+(*   eval_expr ge e le m (Eaddrof' a t) v. *)
+(* Proof. *)
+(*   intros. unfold Eaddrof'; destruct a; auto using eval_Eaddrof. *)
+(*   destruct (type_eq t (typeof a)); auto using eval_Eaddrof. *)
+(*   inv H; auto. *)
+(* Qed. *)
+
+(* Lemma typeof_Eaddrof': *)
+(*   forall a t, typeof (Eaddrof' a t) = t. *)
+(* Proof. *)
+(*   unfold Eaddrof'; intros; destruct a; auto. destruct (type_eq t (typeof a)); auto.  *)
+(* Qed. *)
+
+(* (** Translation of simple expressions. *) *)
+
+(* Lemma tr_simple_nil: *)
+(*   (forall le dst r sl a tmps, tr_expr le dst r sl a tmps -> *)
+(*    dst = For_val \/ dst = For_effects -> simple r = true -> sl = nil) *)
+(* /\(forall le rl sl al tmps, tr_exprlist le rl sl al tmps -> *)
+(*    simplelist rl = true -> sl = nil). *)
+(* Proof. *)
+(*   assert (A: forall dst a, dst = For_val \/ dst = For_effects -> final dst a = nil). *)
+(*     intros. destruct H; subst dst; auto. *)
+(*   apply tr_expr_exprlist; intros; simpl in *; try discriminate; auto. *)
+(* - rewrite H0; auto. simpl; auto. *)
+(* - rewrite H0; auto. simpl; auto. *)
+(* - destruct H1; congruence. *)
+(* - destruct (andb_prop _ _ H6). inv H1. *)
+(*     rewrite H0; eauto. simpl; auto. *)
+(*     unfold chunk_for_volatile_type in H9. *)
+(*     destruct (type_is_volatile (Csyntax.typeof e1)); simpl in H8; congruence. *)
+(* - rewrite H0; auto. simpl; auto. *)
+(* - rewrite H0; auto. simpl; auto. *)
+(* - destruct (andb_prop _ _ H7). rewrite H0; auto. rewrite H2; auto. simpl; auto. *)
+(* - rewrite H0; auto. simpl; auto. *)
+(* - destruct (andb_prop _ _ H6). rewrite H0; auto. *)
+(* Qed. *)
+
+(* Lemma tr_simple_expr_nil: *)
+(*   forall le dst r sl a tmps, tr_expr le dst r sl a tmps -> *)
+(*   dst = For_val \/ dst = For_effects -> simple r = true -> sl = nil. *)
+(* Proof (proj1 tr_simple_nil). *)
+
+(* Lemma tr_simple_exprlist_nil: *)
+(*   forall le rl sl al tmps, tr_exprlist le rl sl al tmps -> *)
+(*   simplelist rl = true -> sl = nil. *)
+(* Proof (proj2 tr_simple_nil). *)
+
+(* (** Translation of [deref_loc] and [assign_loc] operations. *) *)
+
+(* (* Remark deref_loc_translated: *) *)
+(* (*   forall ty m b ofs t v , *) *)
+(* (*   Csem.deref_loc ge ty m b ofs t v -> *) *)
+(* (*   match chunk_for_volatile_type ty with *) *)
+(* (*   | None => t = E0 /\ Clight.deref_loc ty m b v' *) *)
+(* (*   | Some chunk => volatile_load tge chunk m v' t v *) *)
+(* (*   end. *) *)
+(* (* Proof. *) *)
+(* (*   intros. unfold chunk_for_volatile_type. inv H. *) *)
+(* (*   (* By_value, not volatile *) *) *)
+(* (*   rewrite H1. split; auto. eapply deref_loc_value; eauto. *) *)
+(* (*   (* By_value, volatile *) *) *)
+(* (*   rewrite H0; rewrite H1. eapply volatile_load_preserved with (ge1 := ge); auto. apply senv_preserved. *) *)
+(* (*   (* By reference *) *) *)
+(* (*   rewrite H0. destruct (type_is_volatile ty); split; auto; eapply deref_loc_reference; eauto. *) *)
+(* (*   (* By copy *) *) *)
+(* (*   rewrite H0. destruct (type_is_volatile ty); split; auto; eapply deref_loc_copy; eauto. *) *)
+(* (* Qed. *) *)
+
+(* (* Remark assign_loc_translated: *) *)
+(* (*   forall ty m b ofs v t m', *) *)
+(* (*   Csem.assign_loc ge ty m b ofs v t m' -> *) *)
+(* (*   match chunk_for_volatile_type ty with *) *)
+(* (*   | None => t = E0 /\ Clight.assign_loc tge ty m b ofs v m' *) *)
+(* (*   | Some chunk => volatile_store tge chunk m b ofs v t m' *) *)
+(* (*   end. *) *)
+(* (* Proof. *) *)
+(* (*   intros. unfold chunk_for_volatile_type. inv H. *) *)
+(* (*   (* By_value, not volatile *) *) *)
+(* (*   rewrite H1. split; auto. eapply assign_loc_value; eauto. *) *)
+(* (*   (* By_value, volatile *) *) *)
+(* (*   rewrite H0; rewrite H1. eapply volatile_store_preserved with (ge1 := ge); auto. apply senv_preserved. *) *)
+(* (*   (* By copy *) *) *)
+(* (*   rewrite H0. rewrite <- comp_env_preserved in *. *) *)
+(* (*   destruct (type_is_volatile ty); split; auto; eapply assign_loc_copy; eauto. *) *)
+(* (* Qed. *) *)
+
+(* (* (** Evaluation of simple expressions and of their translation *) *) *)
+
+(* (* Lemma tr_simple: *) *)
+(* (*  forall e m, *) *)
+(* (*  (forall r v, *) *)
+(* (*   eval_simple_rvalue ge e m r v -> *) *)
+(* (*   forall le dst sl a tmps, *) *)
+(* (*   tr_expr le dst r sl a tmps -> *) *)
+(* (*   match dst with *) *)
+(* (*   | For_val => sl = nil /\ Csyntax.typeof r = typeof a /\ eval_expr tge e le m a v *) *)
+(* (*   | For_effects => sl = nil *) *)
+(* (*   | For_set sd => *) *)
+(* (*       exists b, sl = do_set sd b *) *)
+(* (*              /\ Csyntax.typeof r = typeof b *) *)
+(* (*              /\ eval_expr tge e le m b v *) *)
+(* (*   end) *) *)
+(* (* /\ *) *)
+(* (*  (forall l b ofs, *) *)
+(* (*   eval_simple_lvalue ge e m l b ofs -> *) *)
+(* (*   forall le sl a tmps, *) *)
+(* (*   tr_expr le For_val l sl a tmps -> *) *)
+(* (*   sl = nil /\ Csyntax.typeof l = typeof a /\ eval_lvalue tge e le m a b ofs). *) *)
+(* (* Proof. *) *)
+(* (* Opaque makeif. *) *)
+(* (*   intros e m. *) *)
+(* (*   apply (eval_simple_rvalue_lvalue_ind ge e m); intros until tmps; intros TR; inv TR. *) *)
+(* (* - (* value *) *) *)
+(* (*   auto. *) *)
+(* (* - auto. *) *)
+(* (* - exists a0; auto. *) *)
+(* (* - (* rvalof *) *) *)
+(* (*   inv H7; try congruence. *) *)
+(* (*   exploit H0; eauto. intros [A [B C]]. *) *)
+(* (*   subst sl1; simpl. *) *)
+(* (*   assert (eval_expr tge e le m a v). *) *)
+(* (*     eapply eval_Elvalue. eauto. *) *)
+(* (*     rewrite <- B. *) *)
+(* (*     exploit deref_loc_translated; eauto. unfold chunk_for_volatile_type; rewrite H2. tauto. *) *)
+(* (*   destruct dst; auto. *) *)
+(* (*   econstructor. split. simpl; eauto. auto. *) *)
+(* (* - (* addrof *) *) *)
+(* (*   exploit H0; eauto. intros [A [B C]]. *) *)
+(* (*   subst sl1; simpl. *) *)
+(* (*   assert (eval_expr tge e le m (Eaddrof' a1 ty) (Vptr b ofs)) by (apply eval_Eaddrof'; auto). *) *)
+(* (*   assert (typeof (Eaddrof' a1 ty) = ty) by (apply typeof_Eaddrof'). *) *)
+(* (*   destruct dst; auto. simpl; econstructor; eauto.   *) *)
+(* (* - (* unop *) *) *)
+(* (*   exploit H0; eauto. intros [A [B C]]. *) *)
+(* (*   subst sl1; simpl. *) *)
+(* (*   assert (eval_expr tge e le m (Eunop op a1 ty) v). econstructor; eauto. congruence. *) *)
+(* (*   destruct dst; auto. simpl; econstructor; eauto. *) *)
+(* (* - (* binop *) *) *)
+(* (*   exploit H0; eauto. intros [A [B C]]. *) *)
+(* (*   exploit H2; eauto. intros [D [E F]]. *) *)
+(* (*   subst sl1 sl2; simpl. *) *)
+(* (*   assert (eval_expr tge e le m (Ebinop op a1 a2 ty) v). econstructor; eauto. rewrite comp_env_preserved; congruence. *) *)
+(* (*   destruct dst; auto. simpl; econstructor; eauto. *) *)
+(* (* - (* cast effects *) *) *)
+(* (*   exploit H0; eauto. *) *)
+(* (* - (* cast val *) *) *)
+(* (*   exploit H0; eauto. intros [A [B C]]. *) *)
+(* (*   subst sl1; simpl. *) *)
+(* (*   assert (eval_expr tge e le m (Ecast a1 ty) v). econstructor; eauto. congruence. *) *)
+(* (*   destruct dst; auto. simpl; econstructor; eauto. *) *)
+(* (* - (* sizeof *) *) *)
+(* (*   rewrite <- comp_env_preserved. *) *)
+(* (*   destruct dst. *) *)
+(* (*   split; auto. split; auto. constructor. *) *)
+(* (*   auto. *) *)
+(* (*   exists (Esizeof ty1 ty). split. auto. split. auto. constructor. *) *)
+(* (* - (* alignof *) *) *)
+(* (*   rewrite <- comp_env_preserved. *) *)
+(* (*   destruct dst. *) *)
+(* (*   split; auto. split; auto. constructor. *) *)
+(* (*   auto. *) *)
+(* (*   exists (Ealignof ty1 ty). split. auto. split. auto. constructor. *) *)
+(* (* - (* var local *) *) *)
+(* (*   split; auto. split; auto. apply eval_Evar_local; auto. *) *)
+(* (* - (* var global *) *) *)
+(* (*   split; auto. split; auto. apply eval_Evar_global; auto. *) *)
+(* (*     rewrite symbols_preserved; auto. *) *)
+(* (* - (* deref *) *) *)
+(* (*   exploit H0; eauto. intros [A [B C]]. subst sl1. *) *)
+(* (*   split; auto. split. rewrite typeof_Ederef'; auto. apply eval_Ederef'; auto.  *) *)
+(* (* - (* field struct *) *) *)
+(* (*   rewrite <- comp_env_preserved in *. *) *)
+(* (*   exploit H0; eauto. intros [A [B C]]. subst sl1. *) *)
+(* (*   split; auto. split; auto. rewrite B in H1. eapply eval_Efield_struct; eauto. *) *)
+(* (* - (* field union *) *) *)
+(* (*   rewrite <- comp_env_preserved in *. *) *)
+(* (*   exploit H0; eauto. intros [A [B C]]. subst sl1. *) *)
+(* (*   split; auto. split; auto. rewrite B in H1. eapply eval_Efield_union; eauto. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma tr_simple_rvalue: *) *)
+(* (*   forall e m r v, *) *)
+(* (*   eval_simple_rvalue ge e m r v -> *) *)
+(* (*   forall le dst sl a tmps, *) *)
+(* (*   tr_expr le dst r sl a tmps -> *) *)
+(* (*   match dst with *) *)
+(* (*   | For_val => sl = nil /\ Csyntax.typeof r = typeof a /\ eval_expr tge e le m a v *) *)
+(* (*   | For_effects => sl = nil *) *)
+(* (*   | For_set sd => *) *)
+(* (*       exists b, sl = do_set sd b *) *)
+(* (*              /\ Csyntax.typeof r = typeof b *) *)
+(* (*              /\ eval_expr tge e le m b v *) *)
+(* (*   end. *) *)
+(* (* Proof. *) *)
+(* (*   intros e m. exact (proj1 (tr_simple e m)). *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma tr_simple_lvalue: *) *)
+(* (*   forall e m l b ofs, *) *)
+(* (*   eval_simple_lvalue ge e m l b ofs -> *) *)
+(* (*   forall le sl a tmps, *) *)
+(* (*   tr_expr le For_val l sl a tmps -> *) *)
+(* (*   sl = nil /\ Csyntax.typeof l = typeof a /\ eval_lvalue tge e le m a b ofs. *) *)
+(* (* Proof. *) *)
+(* (*   intros e m. exact (proj2 (tr_simple e m)). *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma tr_simple_exprlist: *) *)
+(* (*   forall le rl sl al tmps, *) *)
+(* (*   tr_exprlist le rl sl al tmps -> *) *)
+(* (*   forall e m tyl vl, *) *)
+(* (*   eval_simple_list ge e m rl tyl vl -> *) *)
+(* (*   sl = nil /\ eval_exprlist tge e le m al tyl vl. *) *)
+(* (* Proof. *) *)
+(* (*   induction 1; intros. *) *)
+(* (*   inv H. split. auto. constructor. *) *)
+(* (*   inv H4. *) *)
+(* (*   exploit tr_simple_rvalue; eauto. intros [A [B C]]. *) *)
+(* (*   exploit IHtr_exprlist; eauto. intros [D E]. *) *)
+(* (*   split. subst; auto. econstructor; eauto. congruence. *) *)
+(* (* Qed. *) *)
+
+(* (* (** Commutation between the translation of expressions and left contexts. *) *) *)
+
+(* (* Lemma typeof_context: *) *)
+(* (*   forall k1 k2 C, leftcontext k1 k2 C -> *) *)
+(* (*   forall e1 e2, Csyntax.typeof e1 = Csyntax.typeof e2 -> *) *)
+(* (*   Csyntax.typeof (C e1) = Csyntax.typeof (C e2). *) *)
+(* (* Proof. *) *)
+(* (*   induction 1; intros; auto. *) *)
+(* (* Qed. *) *)
+
+(* (* Scheme leftcontext_ind2 := Minimality for leftcontext Sort Prop *) *)
+(* (*   with leftcontextlist_ind2 := Minimality for leftcontextlist Sort Prop. *) *)
+(* (* Combined Scheme leftcontext_leftcontextlist_ind from leftcontext_ind2, leftcontextlist_ind2. *) *)
+
+(* (* Lemma tr_expr_leftcontext_rec: *) *)
+(* (*  ( *) *)
+(* (*   forall from to C, leftcontext from to C -> *) *)
+(* (*   forall le e dst sl a tmps, *) *)
+(* (*   tr_expr le dst (C e) sl a tmps -> *) *)
+(* (*   exists dst', exists sl1, exists sl2, exists a', exists tmp', *) *)
+(* (*   tr_expr le dst' e sl1 a' tmp' *) *)
+(* (*   /\ sl = sl1 ++ sl2 *) *)
+(* (*   /\ incl tmp' tmps *) *)
+(* (*   /\ (forall le' e' sl3, *) *)
+(* (*         tr_expr le' dst' e' sl3 a' tmp' -> *) *)
+(* (*         (forall id, ~In id tmp' -> le'!id = le!id) -> *) *)
+(* (*         Csyntax.typeof e' = Csyntax.typeof e -> *) *)
+(* (*         tr_expr le' dst (C e') (sl3 ++ sl2) a tmps) *) *)
+(* (*  ) /\ ( *) *)
+(* (*   forall from C, leftcontextlist from C -> *) *)
+(* (*   forall le e sl a tmps, *) *)
+(* (*   tr_exprlist le (C e) sl a tmps -> *) *)
+(* (*   exists dst', exists sl1, exists sl2, exists a', exists tmp', *) *)
+(* (*   tr_expr le dst' e sl1 a' tmp' *) *)
+(* (*   /\ sl = sl1 ++ sl2 *) *)
+(* (*   /\ incl tmp' tmps *) *)
+(* (*   /\ (forall le' e' sl3, *) *)
+(* (*         tr_expr le' dst' e' sl3 a' tmp' -> *) *)
+(* (*         (forall id, ~In id tmp' -> le'!id = le!id) -> *) *)
+(* (*         Csyntax.typeof e' = Csyntax.typeof e -> *) *)
+(* (*         tr_exprlist le' (C e') (sl3 ++ sl2) a tmps) *) *)
+(* (* ). *) *)
+(* (* Proof. *) *)
+
+(* (* Ltac TR := *) *)
+(* (*   econstructor; econstructor; econstructor; econstructor; econstructor; *) *)
+(* (*   split; [eauto | split; [idtac | split]]. *) *)
+
+(* (* Ltac NOTIN := *) *)
+(* (*   match goal with *) *)
+(* (*   | [ H1: In ?x ?l, H2: list_disjoint ?l _ |- ~In ?x _ ] => *) *)
+(* (*         red; intro; elim (H2 x x); auto; fail *) *)
+(* (*   | [ H1: In ?x ?l, H2: list_disjoint _ ?l |- ~In ?x _ ] => *) *)
+(* (*         red; intro; elim (H2 x x); auto; fail *) *)
+(* (*   end. *) *)
+
+(* (* Ltac UNCHANGED := *) *)
+(* (*   match goal with *) *)
+(* (*   | [ H: (forall (id: ident), ~In id _ -> ?le' ! id = ?le ! id) |- *) *)
+(* (*          (forall (id: ident), In id _ -> ?le' ! id = ?le ! id) ] => *) *)
+(* (*       intros; apply H; NOTIN *) *)
+(* (*   end. *) *)
+
+(* (*   (*generalize compat_dest_change; intro CDC.*) *) *)
+(* (*   apply leftcontext_leftcontextlist_ind; intros. *) *)
+
+(* (* - (* base *) *) *)
+(* (*   TR. rewrite <- app_nil_end; auto. red; auto. *) *)
+(* (*   intros. rewrite <- app_nil_end; auto. *) *)
+(* (* - (* deref *) *) *)
+(* (*   inv H1. *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. subst sl1; rewrite app_ass; eauto. auto. *) *)
+(* (*   intros. rewrite <- app_ass. econstructor; eauto. *) *)
+(* (* - (* field *) *) *)
+(* (*   inv H1. *) *)
+(* (*   exploit H0. eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. subst sl1; rewrite app_ass; eauto. auto. *) *)
+(* (*   intros. rewrite <- app_ass. econstructor; eauto. *) *)
+(* (* - (* rvalof *) *) *)
+(* (*   inv H1. *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. subst sl1; rewrite app_ass; eauto. red; eauto. *) *)
+(* (*   intros. rewrite <- app_ass; econstructor; eauto. *) *)
+(* (*   exploit typeof_context; eauto. congruence. *) *)
+(* (* - (* addrof *) *) *)
+(* (*   inv H1. *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. subst sl1; rewrite app_ass; eauto. auto. *) *)
+(* (*   intros. rewrite <- app_ass. econstructor; eauto. *) *)
+(* (* - (* unop *) *) *)
+(* (*   inv H1. *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. subst sl1; rewrite app_ass; eauto. auto. *) *)
+(* (*   intros. rewrite <- app_ass. econstructor; eauto. *) *)
+(* (* - (* binop left *) *) *)
+(* (*   inv H1. *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. subst sl1. rewrite app_ass. eauto. *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. econstructor; eauto. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (* - (* binop right *) *) *)
+(* (*   inv H2. *) *)
+(* (*   assert (sl1 = nil) by (eapply tr_simple_expr_nil; eauto). subst sl1; simpl. *) *)
+(* (*   exploit H1; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. subst sl2. rewrite app_ass. eauto. *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. change (sl3 ++ sl2') with (nil ++ sl3 ++ sl2'). rewrite app_ass. econstructor; eauto. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (* - (* cast *) *) *)
+(* (*   inv H1. *) *)
+(* (* + (* for effects *) *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. eauto. auto.  *) *)
+(* (*   intros. econstructor; eauto. *) *)
+(* (* + (* generic *) *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. subst sl1. rewrite app_ass. eauto. auto.  *) *)
+(* (*   intros. rewrite <- app_ass. econstructor; eauto. *) *)
+(* (* - (* seqand *) *) *)
+(* (*   inv H1. *) *)
+(* (* + (* for val *) *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. *) *)
+(* (*   rewrite Q. rewrite app_ass. eauto. *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. econstructor. apply S; auto. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (*   auto. auto. auto. auto. *) *)
+(* (* + (* for effects *) *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. *) *)
+(* (*   rewrite Q. rewrite app_ass. eauto. *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. econstructor. apply S; auto. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (*   auto. auto. auto. *) *)
+(* (* + (* for set *) *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. *) *)
+(* (*   rewrite Q. rewrite app_ass. eauto. *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. econstructor. apply S; auto. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (*   auto. auto. auto. auto. *) *)
+(* (* - (* seqor *) *) *)
+(* (*   inv H1. *) *)
+(* (* + (* for val *) *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. *) *)
+(* (*   rewrite Q. rewrite app_ass. eauto. *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. econstructor. apply S; auto. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (*   auto. auto. auto. auto. *) *)
+(* (* + (* for effects *) *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. *) *)
+(* (*   rewrite Q. rewrite app_ass. eauto. *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. econstructor. apply S; auto. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (*   auto. auto. auto. *) *)
+(* (* + (* for set *) *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. *) *)
+(* (*   rewrite Q. rewrite app_ass. eauto. *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. econstructor. apply S; auto. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (*   auto. auto. auto. auto. *) *)
+(* (* - (* condition *) *) *)
+(* (*   inv H1. *) *)
+(* (* + (* for val *) *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. *) *)
+(* (*   rewrite Q. rewrite app_ass. eauto. *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. econstructor. apply S; auto. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (*   auto. auto. auto. auto. auto. auto. *) *)
+(* (* + (* for effects *) *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. *) *)
+(* (*   rewrite Q. rewrite app_ass. eauto. *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. eapply tr_condition_effects. apply S; auto. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (*   auto. auto. auto. auto. auto. *) *)
+(* (* + (* for set *) *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. *) *)
+(* (*   rewrite Q. rewrite app_ass. eauto. *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. eapply tr_condition_set. apply S; auto. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (*   auto. auto. auto. auto. auto. auto. *) *)
+(* (* - (* assign left *) *) *)
+(* (*   inv H1. *) *)
+(* (* + (* for effects *) *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. subst sl1. rewrite app_ass. eauto. *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. econstructor. apply S; auto. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (*   auto. auto. auto. *) *)
+(* (* + (* for val *) *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. subst sl1. rewrite app_ass. eauto. *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. econstructor. apply S; auto. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (*   auto. auto. auto. auto. auto. auto. *) *)
+(* (*   eapply typeof_context; eauto. *) *)
+(* (*   auto. *) *)
+(* (* - (* assign right *) *) *)
+(* (*   inv H2. *) *)
+(* (* + (* for effects *) *) *)
+(* (*   assert (sl1 = nil) by (eapply tr_simple_expr_nil; eauto). subst sl1; simpl. *) *)
+(* (*   exploit H1; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. subst sl2. rewrite app_ass. eauto. *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. change (sl3 ++ sl2') with (nil ++ (sl3 ++ sl2')). rewrite app_ass. *) *)
+(* (*   econstructor. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (*   apply S; auto. auto. auto. auto. *) *)
+(* (* + (* for val *) *) *)
+(* (*   assert (sl1 = nil) by (eapply tr_simple_expr_nil; eauto). subst sl1; simpl. *) *)
+(* (*   exploit H1; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. subst sl2. rewrite app_ass. eauto. *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. change (sl3 ++ sl2') with (nil ++ (sl3 ++ sl2')). rewrite app_ass. *) *)
+(* (*   econstructor. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (*   apply S; auto. auto. auto. auto. auto. auto. auto. auto. *) *)
+(* (*   eapply typeof_context; eauto. *) *)
+(* (* - (* assignop left *) *) *)
+(* (*   inv H1. *) *)
+(* (* + (* for effects *) *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. subst sl1. rewrite app_ass. eauto. *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. econstructor. apply S; auto. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (*   symmetry; eapply typeof_context; eauto. eauto. *) *)
+(* (*   auto. auto. auto. auto. auto. auto. *) *)
+(* (* + (* for val *) *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. subst sl1. rewrite app_ass. eauto. *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. econstructor. apply S; auto. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (*   eauto. auto. auto. auto. auto. auto. auto. auto. auto. auto. auto. *) *)
+(* (*   eapply typeof_context; eauto. *) *)
+(* (* - (* assignop right *) *) *)
+(* (*   inv H2. *) *)
+(* (* + (* for effects *) *) *)
+(* (*   assert (sl1 = nil) by (eapply tr_simple_expr_nil; eauto). subst sl1; simpl. *) *)
+(* (*   exploit H1; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. subst sl2. rewrite app_ass. eauto. *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. change (sl0 ++ sl2') with (nil ++ sl0 ++ sl2'). rewrite app_ass. econstructor. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (*   apply S; auto. auto. eauto. auto. auto. auto. auto. auto. auto. *) *)
+(* (* + (* for val *) *) *)
+(* (*   assert (sl1 = nil) by (eapply tr_simple_expr_nil; eauto). subst sl1; simpl. *) *)
+(* (*   exploit H1; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. subst sl2. rewrite app_ass. eauto. *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. change (sl0 ++ sl2') with (nil ++ sl0 ++ sl2'). rewrite app_ass. econstructor. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (*   apply S; auto. eauto. auto. auto. auto. auto. auto. auto. auto. auto. auto. auto. auto. *) *)
+(* (* - (* postincr *) *) *)
+(* (*   inv H1. *) *)
+(* (* + (* for effects *) *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. rewrite Q; rewrite app_ass; eauto. red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. econstructor; eauto. *) *)
+(* (*   symmetry; eapply typeof_context; eauto. *) *)
+(* (* + (* for val *) *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. rewrite Q; rewrite app_ass; eauto. red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. econstructor; eauto. *) *)
+(* (*   eapply typeof_context; eauto. *) *)
+(* (* - (* call left *) *) *)
+(* (*   inv H1. *) *)
+(* (* + (* for effects *) *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. rewrite Q; rewrite app_ass; eauto. red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. econstructor. apply S; auto. *) *)
+(* (*   eapply tr_exprlist_invariant; eauto. UNCHANGED. *) *)
+(* (*   auto. auto. auto. *) *)
+(* (* + (* for val *) *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. rewrite Q; rewrite app_ass; eauto. red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. econstructor. auto. apply S; auto. *) *)
+(* (*   eapply tr_exprlist_invariant; eauto. UNCHANGED. *) *)
+(* (*   auto. auto. auto. auto. *) *)
+(* (* - (* call right *) *) *)
+(* (*   inv H2. *) *)
+(* (* + (* for effects *) *) *)
+(* (*   assert (sl1 = nil) by (eapply tr_simple_expr_nil; eauto). subst sl1; simpl. *) *)
+(* (*   exploit H1; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. rewrite Q; rewrite app_ass; eauto. *) *)
+(* (*   (*destruct dst'; constructor||contradiction.*) *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. change (sl3++sl2') with (nil ++ sl3 ++ sl2'). rewrite app_ass. econstructor. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (*   apply S; auto. auto. auto. auto. *) *)
+(* (* + (* for val *) *) *)
+(* (*   assert (sl1 = nil) by (eapply tr_simple_expr_nil; eauto). subst sl1; simpl. *) *)
+(* (*   exploit H1; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. rewrite Q; rewrite app_ass; eauto. *) *)
+(* (*   (*destruct dst'; constructor||contradiction.*) *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. change (sl3++sl2') with (nil ++ sl3 ++ sl2'). rewrite app_ass. econstructor. *) *)
+(* (*   auto. eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (*   apply S; auto. *) *)
+(* (*   auto. auto. auto. auto. *) *)
+(* (* - (* builtin *) *) *)
+(* (*   inv H1. *) *)
+(* (* + (* for effects *) *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. rewrite Q; rewrite app_ass; eauto. *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. change (sl3++sl2') with (nil ++ sl3 ++ sl2'). rewrite app_ass. econstructor. *) *)
+(* (*   apply S; auto. auto. *) *)
+(* (* + (* for val *) *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. rewrite Q; rewrite app_ass; eauto. *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. change (sl3++sl2') with (nil ++ sl3 ++ sl2'). rewrite app_ass. econstructor. *) *)
+(* (*   auto. apply S; auto. auto. auto. *) *)
+(* (* - (* comma *) *) *)
+(* (*   inv H1. *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. rewrite Q; rewrite app_ass; eauto. red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. econstructor. apply S; auto. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (*   auto. auto. auto. *) *)
+(* (* - (* paren *) *) *)
+(* (*   inv H1. *) *)
+(* (* + (* for val *) *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. rewrite Q. eauto. red; auto. *) *)
+(* (*   intros. econstructor; eauto. *) *)
+(* (* + (* for effects *) *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. rewrite Q. eauto. auto. *) *)
+(* (*   intros. econstructor; eauto. *) *)
+(* (* + (* for set *) *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. rewrite Q. eauto. auto. *) *)
+(* (*   intros. econstructor; eauto. *) *)
+(* (* - (* cons left *) *) *)
+(* (*   inv H1. *) *)
+(* (*   exploit H0; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. subst sl1. rewrite app_ass. eauto. *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. rewrite <- app_ass. econstructor. apply S; auto. *) *)
+(* (*   eapply tr_exprlist_invariant; eauto.  UNCHANGED. *) *)
+(* (*   auto. auto. auto. *) *)
+(* (* - (* cons right *) *) *)
+(* (*   inv H2. *) *)
+(* (*   assert (sl1 = nil) by (eapply tr_simple_expr_nil; eauto). subst sl1; simpl. *) *)
+(* (*   exploit H1; eauto. intros [dst' [sl1' [sl2' [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   TR. subst sl2. eauto. *) *)
+(* (*   red; auto. *) *)
+(* (*   intros. change sl3 with (nil ++ sl3). rewrite app_ass. econstructor. *) *)
+(* (*   eapply tr_expr_invariant; eauto. UNCHANGED. *) *)
+(* (*   apply S; auto. *) *)
+(* (*   auto. auto. auto. *) *)
+(* (* Qed. *) *)
+
+(* (* Theorem tr_expr_leftcontext: *) *)
+(* (*   forall C le r dst sl a tmps, *) *)
+(* (*   leftcontext RV RV C -> *) *)
+(* (*   tr_expr le dst (C r) sl a tmps -> *) *)
+(* (*   exists dst', exists sl1, exists sl2, exists a', exists tmp', *) *)
+(* (*   tr_expr le dst' r sl1 a' tmp' *) *)
+(* (*   /\ sl = sl1 ++ sl2 *) *)
+(* (*   /\ incl tmp' tmps *) *)
+(* (*   /\ (forall le' r' sl3, *) *)
+(* (*         tr_expr le' dst' r' sl3 a' tmp' -> *) *)
+(* (*         (forall id, ~In id tmp' -> le'!id = le!id) -> *) *)
+(* (*         Csyntax.typeof r' = Csyntax.typeof r -> *) *)
+(* (*         tr_expr le' dst (C r') (sl3 ++ sl2) a tmps). *) *)
+(* (* Proof. *) *)
+(* (*   intros. eapply (proj1 tr_expr_leftcontext_rec); eauto. *) *)
+(* (* Qed. *) *)
+
+(* (* Theorem tr_top_leftcontext: *) *)
+(* (*   forall e le m dst rtop sl a tmps, *) *)
+(* (*   tr_top tge e le m dst rtop sl a tmps -> *) *)
+(* (*   forall r C, *) *)
+(* (*   rtop = C r -> *) *)
+(* (*   leftcontext RV RV C -> *) *)
+(* (*   exists dst', exists sl1, exists sl2, exists a', exists tmp', *) *)
+(* (*   tr_top tge e le m dst' r sl1 a' tmp' *) *)
+(* (*   /\ sl = sl1 ++ sl2 *) *)
+(* (*   /\ incl tmp' tmps *) *)
+(* (*   /\ (forall le' m' r' sl3, *) *)
+(* (*         tr_expr le' dst' r' sl3 a' tmp' -> *) *)
+(* (*         (forall id, ~In id tmp' -> le'!id = le!id) -> *) *)
+(* (*         Csyntax.typeof r' = Csyntax.typeof r -> *) *)
+(* (*         tr_top tge e le' m' dst (C r') (sl3 ++ sl2) a tmps). *) *)
+(* (* Proof. *) *)
+(* (*   induction 1; intros. *) *)
+(* (* (* val for val *) *) *)
+(* (*   inv H2; inv H1. *) *)
+(* (*   exists For_val; econstructor; econstructor; econstructor; econstructor. *) *)
+(* (*   split. apply tr_top_val_val; eauto. *) *)
+(* (*   split. instantiate (1 := nil); auto. *) *)
+(* (*   split. apply incl_refl. *) *)
+(* (*   intros. rewrite <- app_nil_end. constructor; auto. *) *)
+(* (* (* base *) *) *)
+(* (*   subst r. exploit tr_expr_leftcontext; eauto. *) *)
+(* (*   intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   exists dst'; exists sl1; exists sl2; exists a'; exists tmp'. *) *)
+(* (*   split. apply tr_top_base; auto. *) *)
+(* (*   split. auto. split. auto. *) *)
+(* (*   intros. apply tr_top_base. apply S; auto. *) *)
+(* (* Qed. *) *)
+
+(* (* (** Semantics of smart constructors *) *) *)
+
+(* (* Remark sem_cast_deterministic: *) *)
+(* (*   forall v ty ty' m1 v1 m2 v2, *) *)
+(* (*   sem_cast v ty ty' m1 = Some v1 -> *) *)
+(* (*   sem_cast v ty ty' m2 = Some v2 -> *) *)
+(* (*   v1 = v2. *) *)
+(* (* Proof. *) *)
+(* (*   unfold sem_cast; intros. destruct (classify_cast ty ty'); try congruence. *) *)
+(* (* - destruct v; try congruence. *) *)
+(* (*   destruct Archi.ptr64; try discriminate. *) *)
+(* (*   destruct (Mem.weak_valid_pointer m1 b (Ptrofs.unsigned i)); inv H. *) *)
+(* (*   destruct (Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i)); inv H0. *) *)
+(* (*   auto. *) *)
+(* (* - destruct v; try congruence.  *) *)
+(* (*   destruct (negb Archi.ptr64); try discriminate. *) *)
+(* (*   destruct (Mem.weak_valid_pointer m1 b (Ptrofs.unsigned i)); inv H. *) *)
+(* (*   destruct (Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i)); inv H0. *) *)
+(* (*   auto. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma eval_simpl_expr_sound: *) *)
+(* (*   forall e le m a v, eval_expr tge e le m a v -> *) *)
+(* (*   match eval_simpl_expr a with Some v' => v' = v | None => True end. *) *)
+(* (* Proof. *) *)
+(* (*   (* induction 1; simpl; auto. *) *) *)
+(* (*   (* destruct (eval_simpl_expr a); auto. subst. *) *) *)
+(* (*   (* destruct (sem_cast v1 (typeof a) ty Mem.empty) as [v'|] eqn:C; auto. *) *) *)
+(* (*   (* eapply sem_cast_deterministic; eauto. *) *) *)
+(* (*   (* inv H; simpl; auto. *) *) *)
+
+(* (* Qed. *) *)
+
+(* (* Lemma static_bool_val_sound: *) *)
+(* (*   forall v t m b, bool_val v t Mem.empty = Some b -> bool_val v t m = Some b. *) *)
+(* (* Proof. *) *)
+(* (*   assert (A: forall b ofs, Mem.weak_valid_pointer Mem.empty b ofs = false). *) *)
+(* (*   { unfold Mem.weak_valid_pointer, Mem.valid_pointer, proj_sumbool; intros. *) *)
+(* (*     rewrite ! pred_dec_false by (apply Mem.perm_empty). auto. }   *) *)
+(* (*   intros until b; unfold bool_val. *) *)
+(* (*   destruct (classify_bool t); destruct v; destruct Archi.ptr64 eqn:SF; auto. *) *)
+(* (* - rewrite A; congruence. *) *)
+(* (* - simpl; rewrite A; congruence. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma step_makeif: *) *)
+(* (*   forall f a s1 s2 k e le m v1 b, *) *)
+(* (*   eval_expr tge e le m a v1 -> *) *)
+(* (*   bool_val v1 (typeof a) m = Some b -> *) *)
+(* (*   star step1 tge (State f (makeif a s1 s2) k e le m) *) *)
+(* (*              E0 (State f (if b then s1 else s2) k e le m). *) *)
+(* (* Proof. *) *)
+(* (*   intros. functional induction (makeif a s1 s2). *) *)
+(* (* - exploit eval_simpl_expr_sound; eauto. rewrite e0. intro EQ; subst v. *) *)
+(* (*   assert (bool_val v1 (typeof a) m = Some true) by (apply static_bool_val_sound; auto). *) *)
+(* (*   replace b with true by congruence. constructor. *) *)
+(* (* - exploit eval_simpl_expr_sound; eauto. rewrite e0. intro EQ; subst v. *) *)
+(* (*   assert (bool_val v1 (typeof a) m = Some false) by (apply static_bool_val_sound; auto). *) *)
+(* (*   replace b with false by congruence. constructor. *) *)
+(* (* - apply star_one. eapply step_ifthenelse; eauto. *) *)
+(* (* - apply star_one. eapply step_ifthenelse; eauto. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma step_make_set: *) *)
+(* (*   forall id a ty m b ofs t v e le f k, *) *)
+(* (*   Csem.deref_loc ge ty m b ofs t v -> *) *)
+(* (*   eval_lvalue tge e le m a b ofs -> *) *)
+(* (*   typeof a = ty -> *) *)
+(* (*   step1 tge (State f (make_set id a) k e le m) *) *)
+(* (*           t (State f Sskip k e (PTree.set id v le) m). *) *)
+(* (* Proof. *) *)
+(* (* (*   intros. exploit deref_loc_translated; eauto. rewrite <- H1. *) *) *)
+(* (* (*   unfold make_set. destruct (chunk_for_volatile_type (typeof a)) as [chunk|]. *) *) *)
+(* (* (* (* volatile case *) *) *) *)
+(* (* (*   intros. change (PTree.set id v le) with (set_opttemp (Some id) v le). econstructor. *) *) *)
+(* (* (*   econstructor. constructor. eauto. *) *) *)
+(* (* (*   simpl. unfold sem_cast. simpl. eauto. constructor. *) *) *)
+(* (* (*   simpl. econstructor; eauto. *) *) *)
+(* (* (* (* nonvolatile case *) *) *) *)
+(* (* (*   intros [A B]. subst t. constructor. eapply eval_Elvalue; eauto. *) *) *)
+
+(* (* Qed. *) *)
+
+(* (* Lemma step_make_assign: *) *)
+(* (*   forall a1 a2 ty m b ofs t v m' v2 e le f k, *) *)
+(* (*   Csem.assign_loc ge ty m b ofs v t m' -> *) *)
+(* (*   eval_lvalue tge e le m a1 b ofs -> *) *)
+(* (*   eval_expr tge e le m a2 v2 -> *) *)
+(* (*   sem_cast v2 (typeof a2) ty m = Some v -> *) *)
+(* (*   typeof a1 = ty -> *) *)
+(* (*   step1 tge (State f (make_assign a1 a2) k e le m) *) *)
+(* (*           t (State f Sskip k e le m'). *) *)
+(* (* Proof. *) *)
+(* (* (*   intros. exploit assign_loc_translated; eauto. rewrite <- H3. *) *) *)
+(* (* (*   unfold make_assign. destruct (chunk_for_volatile_type (typeof a1)) as [chunk|]. *) *) *)
+(* (* (* (* volatile case *) *) *) *)
+(* (* (*   intros. change le with (set_opttemp None Vundef le) at 2. econstructor. *) *) *)
+(* (* (*   econstructor. constructor. eauto. *) *) *)
+(* (* (*   simpl. unfold sem_cast. simpl. eauto. *) *) *)
+(* (* (*   econstructor; eauto. rewrite H3; eauto. constructor. *) *) *)
+(* (* (*   simpl. econstructor; eauto. *) *) *)
+(* (* (* (* nonvolatile case *) *) *) *)
+(* (* (*   intros [A B]. subst t. econstructor; eauto. congruence. *) *) *)
+
+(* (* Qed. *) *)
+
+(* (* Fixpoint Kseqlist (sl: list statement) (k: cont) := *) *)
+(* (*   match sl with *) *)
+(* (*   | nil => k *) *)
+(* (*   | s :: l => Kseq s (Kseqlist l k) *) *)
+(* (*   end. *) *)
+
+(* (* Remark Kseqlist_app: *) *)
+(* (*   forall sl1 sl2 k, *) *)
+(* (*   Kseqlist (sl1 ++ sl2) k = Kseqlist sl1 (Kseqlist sl2 k). *) *)
+(* (* Proof. *) *)
+(* (*   induction sl1; simpl; congruence. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma push_seq: *) *)
+(* (*   forall f sl k e le m, *) *)
+(* (*   star step1 tge (State f (makeseq sl) k e le m) *) *)
+(* (*               E0 (State f Sskip (Kseqlist sl k) e le m). *) *)
+(* (* Proof. *) *)
+(* (*   intros. unfold makeseq. generalize Sskip. revert sl k. *) *)
+(* (*   induction sl; simpl; intros. *) *)
+(* (*   apply star_refl. *) *)
+(* (*   eapply star_right. apply IHsl. constructor. traceEq. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma step_tr_rvalof: *) *)
+(* (*   forall ty m b ofs t v e le a sl a' tmp f k, *) *)
+(* (*   Csem.deref_loc ge ty m b ofs t v -> *) *)
+(* (*   eval_lvalue tge e le m a b ofs -> *) *)
+(* (*   tr_rvalof ty a sl a' tmp -> *) *)
+(* (*   typeof a = ty -> *) *)
+(* (*   exists le', *) *)
+(* (*     star step1 tge (State f Sskip (Kseqlist sl k) e le m) *) *)
+(* (*                  t (State f Sskip k e le' m) *) *)
+(* (*   /\ eval_expr tge e le' m a' v *) *)
+(* (*   /\ typeof a' = typeof a *) *)
+(* (*   /\ forall x, ~In x tmp -> le'!x = le!x. *) *)
+(* (* Proof. *) *)
+(* (*   intros. inv H1. *) *)
+(* (*   (* not volatile *) *) *)
+(* (*   exploit deref_loc_translated; eauto. unfold chunk_for_volatile_type; rewrite H3. *) *)
+(* (*   intros [A B]. subst t. *) *)
+(* (*   exists le; split. apply star_refl. *) *)
+(* (*   split. eapply eval_Elvalue; eauto. *) *)
+(* (*   auto. *) *)
+(* (*   (* volatile *) *) *)
+(* (*   intros. exists (PTree.set t0 v le); split. *) *)
+(* (*   simpl. eapply star_two. econstructor. eapply step_make_set; eauto. traceEq. *) *)
+(* (*   split. constructor. apply PTree.gss. *) *)
+(* (*   split. auto. *) *)
+(* (*   intros. apply PTree.gso. congruence. *) *)
+(* (* Qed. *) *)
+
+(* (* (** Matching between continuations *) *) *)
+
+(* (* Inductive match_cont : Csem.cont -> cont -> Prop := *) *)
+(* (*   | match_Kstop: *) *)
+(* (*       match_cont Csem.Kstop Kstop *) *)
+(* (*   | match_Kseq: forall s k ts tk ty, *) *)
+(* (*       tr_stmt s ty ts -> *) *)
+(* (*       match_cont k tk -> *) *)
+(* (*       match_cont (Csem.Kseq s k) (Kseq ts tk) *) *)
+(* (*   | match_Kwhile2: forall r s k s' ts tk ty, *) *)
+(* (*       tr_if r Sskip Sbreak s' -> *) *)
+(* (*       tr_stmt s ty ts -> *) *)
+(* (*       match_cont k tk -> *) *)
+(* (*       match_cont (Csem.Kwhile2 r s k) *) *)
+(* (*                  (Kloop1 (Ssequence s' ts) Sskip tk) *) *)
+(* (*   | match_Kdowhile1: forall r s k s' ts tk ty, *) *)
+(* (*       tr_if r Sskip Sbreak s' -> *) *)
+(* (*       tr_stmt s ty ts -> *) *)
+(* (*       match_cont k tk -> *) *)
+(* (*       match_cont (Csem.Kdowhile1 r s k) *) *)
+(* (*                  (Kloop1 ts s' tk) *) *)
+(* (*   | match_Kfor3: forall r s3 s k ts3 s' ts tk ty, *) *)
+(* (*       tr_if r Sskip Sbreak s' -> *) *)
+(* (*       tr_stmt s3 ty ts3 -> *) *)
+(* (*       tr_stmt s ty ts -> *) *)
+(* (*       match_cont k tk -> *) *)
+(* (*       match_cont (Csem.Kfor3 r s3 s k) *) *)
+(* (*                  (Kloop1 (Ssequence s' ts) ts3 tk) *) *)
+(* (*   | match_Kfor4: forall r s3 s k ts3 s' ts tk ty, *) *)
+(* (*       tr_if r Sskip Sbreak s' -> *) *)
+(* (*       tr_stmt s3 ty ts3 -> *) *)
+(* (*       tr_stmt s ty ts -> *) *)
+(* (*       match_cont k tk -> *) *)
+(* (*       match_cont (Csem.Kfor4 r s3 s k) *) *)
+(* (*                  (Kloop2 (Ssequence s' ts) ts3 tk) *) *)
+(* (*   | match_Kswitch2: forall k tk, *) *)
+(* (*       match_cont k tk -> *) *)
+(* (*       match_cont (Csem.Kswitch2 k) (Kswitch tk) *) *)
+(* (*   | match_Kcall: forall f e C ty k optid tf le sl tk a dest tmps, *) *)
+(* (*       tr_function f tf -> *) *)
+(* (*       leftcontext RV RV C -> *) *)
+(* (*       (forall v m, tr_top tge e (set_opttemp optid v le) m dest (C (Csyntax.Eval v ty)) sl a tmps) -> *) *)
+(* (*       match_cont_exp dest a k tk -> *) *)
+(* (*       match_cont (Csem.Kcall f e C ty k) *) *)
+(* (*                  (Kcall optid tf e le (Kseqlist sl tk)) *) *)
+(* (* (* *) *)
+(* (*   | match_Kcall_some: forall f e C ty k dst tf le sl tk a dest tmps, *) *)
+(* (*       transl_function f = Errors.OK tf -> *) *)
+(* (*       leftcontext RV RV C -> *) *)
+(* (*       (forall v m, tr_top tge e (PTree.set dst v le) m dest (C (C.Eval v ty)) sl a tmps) -> *) *)
+(* (*       match_cont_exp dest a k tk -> *) *)
+(* (*       match_cont (Csem.Kcall f e C ty k) *) *)
+(* (*                  (Kcall (Some dst) tf e le (Kseqlist sl tk)) *) *)
+(* (* *) *) *)
+
+(* (* with match_cont_exp : destination -> expr -> Csem.cont -> cont -> Prop := *) *)
+(* (*   | match_Kdo: forall k a tk, *) *)
+(* (*       match_cont k tk -> *) *)
+(* (*       match_cont_exp For_effects a (Csem.Kdo k) tk *) *)
+(* (*   | match_Kifthenelse_empty: forall a k tk, *) *)
+(* (*       match_cont k tk -> *) *)
+(* (*       match_cont_exp For_val a (Csem.Kifthenelse Csyntax.Sskip Csyntax.Sskip k) (Kseq Sskip tk) *) *)
+(* (*   | match_Kifthenelse_1: forall a s1 s2 k ts1 ts2 tk ty, *) *)
+(* (*       tr_stmt s1 ty ts1 -> tr_stmt s2 ty ts2 -> *) *)
+(* (*       match_cont k tk -> *) *)
+(* (*       match_cont_exp For_val a (Csem.Kifthenelse s1 s2 k) (Kseq (Sifthenelse a ts1 ts2) tk) *) *)
+(* (*   | match_Kwhile1: forall r s k s' a ts tk ty, *) *)
+(* (*       tr_if r Sskip Sbreak s' -> *) *)
+(* (*       tr_stmt s ty ts -> *) *)
+(* (*       match_cont k tk -> *) *)
+(* (*       match_cont_exp For_val a *) *)
+(* (*          (Csem.Kwhile1 r s k) *) *)
+(* (*          (Kseq (makeif a Sskip Sbreak) *) *)
+(* (*            (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk))) *) *)
+(* (*   | match_Kdowhile2: forall r s k s' a ts tk ty, *) *)
+(* (*       tr_if r Sskip Sbreak s' -> *) *)
+(* (*       tr_stmt s ty ts -> *) *)
+(* (*       match_cont k tk -> *) *)
+(* (*       match_cont_exp For_val a *) *)
+(* (*         (Csem.Kdowhile2 r s k) *) *)
+(* (*         (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk)) *) *)
+(* (*   | match_Kfor2: forall r s3 s k s' a ts3 ts tk ty, *) *)
+(* (*       tr_if r Sskip Sbreak s' -> *) *)
+(* (*       tr_stmt s3 ty ts3 -> *) *)
+(* (*       tr_stmt s ty ts -> *) *)
+(* (*       match_cont k tk -> *) *)
+(* (*       match_cont_exp For_val a *) *)
+(* (*         (Csem.Kfor2 r s3 s k) *) *)
+(* (*         (Kseq (makeif a Sskip Sbreak) *) *)
+(* (*           (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk))) *) *)
+(* (*   | match_Kswitch1: forall ls k a tls tk ty, *) *)
+(* (*       tr_lblstmts ls ty tls -> *) *)
+(* (*       match_cont k tk -> *) *)
+(* (*       match_cont_exp For_val a (Csem.Kswitch1 ls k) (Kseq (Sswitch a tls) tk) *) *)
+(* (*   | match_Kreturn: forall k a tk, *) *)
+(* (*       match_cont k tk -> *) *)
+(* (*       match_cont_exp For_val a (Csem.Kreturn k) (Kseq (Sreturn (Some a)) tk). *) *)
+
+(* (* Lemma match_cont_call: *) *)
+(* (*   forall k tk, *) *)
+(* (*   match_cont k tk -> *) *)
+(* (*   match_cont (Csem.call_cont k) (call_cont tk). *) *)
+(* (* Proof. *) *)
+(* (*   induction 1; simpl; auto. constructor. econstructor; eauto. *) *)
+(* (* Qed. *) *)
+
+(* (* (** Matching between states *) *) *)
+
+(* (* Inductive match_states: Csem.state -> state -> Prop := *) *)
+(* (*   | match_exprstates: forall f r k e m tf sl tk le dest a tmps, *) *)
+(* (*       tr_function f tf -> *) *)
+(* (*       tr_top tge e le m dest r sl a tmps -> *) *)
+(* (*       match_cont_exp dest a k tk -> *) *)
+(* (*       match_states (Csem.ExprState f r k e m) *) *)
+(* (*                    (State tf Sskip (Kseqlist sl tk) e le m) *) *)
+(* (*   | match_regularstates: forall f s k e m tf ts tk le ty, *) *)
+(* (*       tr_function f tf -> *) *)
+(* (*       tr_stmt s ty ts -> *) *)
+(* (*       match_cont k tk -> *) *)
+(* (*       match_states (Csem.State f s k e m) *) *)
+(* (*                    (State tf ts tk e le m) *) *)
+(* (*   | match_callstates: forall fd args k m tfd tk, *) *)
+(* (*       tr_fundef fd tfd -> *) *)
+(* (*       match_cont k tk -> *) *)
+(* (*       match_states (Csem.Callstate fd args k m) *) *)
+(* (*                    (Callstate tfd args tk m) *) *)
+(* (*   | match_returnstates: forall res k m tk, *) *)
+(* (*       match_cont k tk -> *) *)
+(* (*       match_states (Csem.Returnstate res k m) *) *)
+(* (*                    (Returnstate res tk m) *) *)
+(* (*   | match_stuckstate: forall S, *) *)
+(* (*       match_states Csem.Stuckstate S. *) *)
+
+(* (* (** Additional results on translation of statements *) *) *)
+
+(* (* Lemma tr_select_switch: *) *)
+(* (*   forall n ls tls ty, *) *)
+(* (*   tr_lblstmts ls ty tls -> *) *)
+(* (*   tr_lblstmts (Csem.select_switch n ls) ty (select_switch n tls). *) *)
+(* (* Proof. *) *)
+(* (*   assert (DFL: forall ls tls ty, *) *)
+(* (*       tr_lblstmts ls ty tls -> *) *)
+(* (*       tr_lblstmts (Csem.select_switch_default ls) ty (select_switch_default tls)). *) *)
+(* (*   { induction 1; simpl. constructor. destruct c; auto. constructor; auto. } *) *)
+(* (*   assert (CASE: forall n ls tls ty, *) *)
+(* (*       tr_lblstmts ls ty tls -> *) *)
+(* (*       match Csem.select_switch_case n ls with *) *)
+(* (*       | None => *) *)
+(* (*           select_switch_case n tls = None *) *)
+(* (*       | Some ls' => *) *)
+(* (*           exists tls', select_switch_case n tls = Some tls' /\ tr_lblstmts ls' ty tls' *) *)
+(* (*       end). *) *)
+(* (*   { induction 1; simpl; intros. *) *)
+(* (*     auto. *) *)
+(* (*     destruct c; auto. destruct (zeq z n); auto. *) *)
+(* (*     econstructor; split; eauto. constructor; auto. } *) *)
+(* (*   intros. unfold Csem.select_switch, select_switch. *) *)
+(* (*   specialize (CASE n ls tls ty H). *) *)
+(* (*   destruct (Csem.select_switch_case n ls) as [ls'|]. *) *)
+(* (*   destruct CASE as [tls' [P Q]]. rewrite P. auto. *) *)
+(* (*   rewrite CASE. apply DFL; auto. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma tr_seq_of_labeled_statement: *) *)
+(* (*   forall ls tls ty, *) *)
+(* (*   tr_lblstmts ls ty tls -> *) *)
+(* (*   tr_stmt (Csem.seq_of_labeled_statement ls) ty (seq_of_labeled_statement tls). *) *)
+(* (* Proof. *) *)
+(* (*   induction 1; simpl; constructor; auto. *) *)
+(* (* Qed. *) *)
+
+(* (* (** Commutation between translation and the "find label" operation. *) *) *)
+
+(* (* Section FIND_LABEL. *) *)
+
+(* (* Variable lbl: label. *) *)
+
+(* (* Definition nolabel (s: statement) : Prop := *) *)
+(* (*   forall k, find_label lbl s k = None. *) *)
+
+(* (* Fixpoint nolabel_list (sl: list statement) : Prop := *) *)
+(* (*   match sl with *) *)
+(* (*   | nil => True *) *)
+(* (*   | s1 :: sl' => nolabel s1 /\ nolabel_list sl' *) *)
+(* (*   end. *) *)
+
+(* (* Lemma nolabel_list_app: *) *)
+(* (*   forall sl2 sl1, nolabel_list sl1 -> nolabel_list sl2 -> nolabel_list (sl1 ++ sl2). *) *)
+(* (* Proof. *) *)
+(* (*   induction sl1; simpl; intros. auto. tauto. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma makeseq_nolabel: *) *)
+(* (*   forall sl, nolabel_list sl -> nolabel (makeseq sl). *) *)
+(* (* Proof. *) *)
+(* (*   assert (forall sl s, nolabel s -> nolabel_list sl -> nolabel (makeseq_rec s sl)). *) *)
+(* (*   induction sl; simpl; intros. auto. destruct H0. apply IHsl; auto. *) *)
+(* (*   red. intros; simpl. rewrite H. apply H0. *) *)
+(* (*   intros. unfold makeseq. apply H; auto. red. auto. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma makeif_nolabel: *) *)
+(* (*   forall a s1 s2, nolabel s1 -> nolabel s2 -> nolabel (makeif a s1 s2). *) *)
+(* (* Proof. *) *)
+(* (*   intros. functional induction (makeif a s1 s2); auto. *) *)
+(* (*   red; simpl; intros. rewrite H; auto. *) *)
+(* (*   red; simpl; intros. rewrite H; auto. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma make_set_nolabel: *) *)
+(* (*   forall t a, nolabel (make_set t a). *) *)
+(* (* Proof. *) *)
+(* (*   unfold make_set; intros; red; intros. *) *)
+(* (*   destruct (chunk_for_volatile_type (typeof a)); auto. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma make_assign_nolabel: *) *)
+(* (*   forall l r, nolabel (make_assign l r). *) *)
+(* (* Proof. *) *)
+(* (*   unfold make_assign; intros; red; intros. *) *)
+(* (*   destruct (chunk_for_volatile_type (typeof l)); auto. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma tr_rvalof_nolabel: *) *)
+(* (*   forall ty a sl a' tmp, tr_rvalof ty a sl a' tmp -> nolabel_list sl. *) *)
+(* (* Proof. *) *)
+(* (*   destruct 1; simpl; intuition. apply make_set_nolabel. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma nolabel_do_set: *) *)
+(* (*   forall sd a, nolabel_list (do_set sd a). *) *)
+(* (* Proof. *) *)
+(* (*   induction sd; intros; simpl; split; auto; red; auto. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma nolabel_final: *) *)
+(* (*   forall dst a, nolabel_list (final dst a). *) *)
+(* (* Proof. *) *)
+(* (*   destruct dst; simpl; intros. auto. auto. apply nolabel_do_set. *) *)
+(* (* Qed. *) *)
+
+(* (* Ltac NoLabelTac := *) *)
+(* (*   match goal with *) *)
+(* (*   | [ |- nolabel_list nil ] => exact I *) *)
+(* (*   | [ |- nolabel_list (final _ _) ] => apply nolabel_final (*; NoLabelTac*) *) *)
+(* (*   | [ |- nolabel_list (_ :: _) ] => simpl; split; NoLabelTac *) *)
+(* (*   | [ |- nolabel_list (_ ++ _) ] => apply nolabel_list_app; NoLabelTac *) *)
+(* (*   | [ H: _ -> nolabel_list ?x |- nolabel_list ?x ] => apply H; NoLabelTac *) *)
+(* (*   | [ |- nolabel (makeseq _) ] => apply makeseq_nolabel; NoLabelTac *) *)
+(* (*   | [ |- nolabel (makeif _ _ _) ] => apply makeif_nolabel; NoLabelTac *) *)
+(* (*   | [ |- nolabel (make_set _ _) ] => apply make_set_nolabel *) *)
+(* (*   | [ |- nolabel (make_assign _ _) ] => apply make_assign_nolabel *) *)
+(* (*   | [ |- nolabel _ ] => red; intros; simpl; auto *) *)
+(* (*   | [ |- _ /\ _ ] => split; NoLabelTac *) *)
+(* (*   | _ => auto *) *)
+(* (*   end. *) *)
+
+(* (* Lemma tr_find_label_expr: *) *)
+(* (*   (forall le dst r sl a tmps, tr_expr le dst r sl a tmps -> nolabel_list sl) *) *)
+(* (* /\(forall le rl sl al tmps, tr_exprlist le rl sl al tmps -> nolabel_list sl). *) *)
+(* (* Proof. *) *)
+(* (*   apply tr_expr_exprlist; intros; NoLabelTac. *) *)
+(* (*   apply nolabel_do_set. *) *)
+(* (*   eapply tr_rvalof_nolabel; eauto. *) *)
+(* (*   apply nolabel_do_set. *) *)
+(* (*   apply nolabel_do_set. *) *)
+(* (*   eapply tr_rvalof_nolabel; eauto. *) *)
+(* (*   eapply tr_rvalof_nolabel; eauto. *) *)
+(* (*   eapply tr_rvalof_nolabel; eauto. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma tr_find_label_top: *) *)
+(* (*   forall e le m dst r sl a tmps, *) *)
+(* (*   tr_top tge e le m dst r sl a tmps -> nolabel_list sl. *) *)
+(* (* Proof. *) *)
+(* (*   induction 1; intros; NoLabelTac. *) *)
+(* (*   eapply (proj1 tr_find_label_expr); eauto. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma tr_find_label_expression: *) *)
+(* (*   forall r s a, tr_expression r s a -> forall k, find_label lbl s k = None. *) *)
+(* (* Proof. *) *)
+(* (*   intros. inv H. *) *)
+(* (*   assert (nolabel (makeseq sl)). apply makeseq_nolabel. *) *)
+(* (*   eapply tr_find_label_top with (e := empty_env) (le := PTree.empty val) (m := Mem.empty). *) *)
+(* (*   eauto. apply H. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma tr_find_label_expr_stmt: *) *)
+(* (*   forall r s, tr_expr_stmt r s -> forall k, find_label lbl s k = None. *) *)
+(* (* Proof. *) *)
+(* (*   intros. inv H. *) *)
+(* (*   assert (nolabel (makeseq sl)). apply makeseq_nolabel. *) *)
+(* (*   eapply tr_find_label_top with (e := empty_env) (le := PTree.empty val) (m := Mem.empty). *) *)
+(* (*   eauto. apply H. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma tr_find_label_if: *) *)
+(* (*   forall r s, *) *)
+(* (*   tr_if r Sskip Sbreak s -> *) *)
+(* (*   forall k, find_label lbl s k = None. *) *)
+(* (* Proof. *) *)
+(* (*   intros. inv H. *) *)
+(* (*   assert (nolabel (makeseq (sl ++ makeif a Sskip Sbreak :: nil))). *) *)
+(* (*   apply makeseq_nolabel. *) *)
+(* (*   apply nolabel_list_app. *) *)
+(* (*   eapply tr_find_label_top with (e := empty_env) (le := PTree.empty val) (m := Mem.empty). *) *)
+(* (*   eauto. *) *)
+(* (*   simpl; split; auto. apply makeif_nolabel. red; simpl; auto. red; simpl; auto. *) *)
+(* (*   apply H. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma tr_find_label: *) *)
+(* (*   forall s k ts tk ty *) *)
+(* (*     (TR: tr_stmt s ty ts) *) *)
+(* (*     (MC: match_cont k tk), *) *)
+(* (*   match Csem.find_label lbl s k with *) *)
+(* (*   | None => *) *)
+(* (*       find_label lbl ts tk = None *) *)
+(* (*   | Some (s', k') => *) *)
+(* (*       exists ts', exists tk', *) *)
+(* (*           find_label lbl ts tk = Some (ts', tk') *) *)
+(* (*        /\ tr_stmt s' ty ts' *) *)
+(* (*        /\ match_cont k' tk' *) *)
+(* (*   end *) *)
+(* (* with tr_find_label_ls: *) *)
+(* (*   forall s k ts tk ty *) *)
+(* (*     (TR: tr_lblstmts s ty ts) *) *)
+(* (*     (MC: match_cont k tk), *) *)
+(* (*   match Csem.find_label_ls lbl s k with *) *)
+(* (*   | None => *) *)
+(* (*       find_label_ls lbl ts tk = None *) *)
+(* (*   | Some (s', k') => *) *)
+(* (*       exists ts', exists tk', *) *)
+(* (*           find_label_ls lbl ts tk = Some (ts', tk') *) *)
+(* (*        /\ tr_stmt s' ty ts' *) *)
+(* (*        /\ match_cont k' tk' *) *)
+(* (*   end. *) *)
+(* (* Proof. *) *)
+(* (* (*   induction s; intros; inversion TR; subst; clear TR; simpl. *) *) *)
+(* (* (*   auto. *) *) *)
+(* (* (*   eapply tr_find_label_expr_stmt; eauto. *) *) *)
+(* (* (* (* seq *) *) *) *)
+(* (* (*   exploit (IHs1 (Csem.Kseq s2 k)); eauto. constructor; eauto. *) *) *)
+(* (* (*   destruct (Csem.find_label lbl s1 (Csem.Kseq s2 k)) as [[s' k'] | ]. *) *) *)
+(* (* (*   intros [ts' [tk' [A [B C]]]]. rewrite A. exists ts'; exists tk'; auto. *) *) *)
+(* (* (*   intro EQ. rewrite EQ. eapply IHs2; eauto. *) *) *)
+(* (* (* (* if empty *) *) *) *)
+(* (* (*   rename s' into sr. *) *) *)
+(* (* (*   rewrite (tr_find_label_expression _ _ _ H3). *) *) *)
+(* (* (*   auto. *) *) *)
+(* (* (* (* if not empty *) *) *) *)
+(* (* (*   rename s' into sr. *) *) *)
+(* (* (*   rewrite (tr_find_label_expression _ _ _ H2). *) *) *)
+(* (* (*   exploit (IHs1 k); eauto. *) *) *)
+(* (* (*   destruct (Csem.find_label lbl s1 k) as [[s' k'] | ]. *) *) *)
+(* (* (*   intros [ts' [tk' [A [B C]]]]. rewrite A. exists ts'; exists tk'; intuition. *) *) *)
+(* (* (*   intro EQ. rewrite EQ. eapply IHs2; eauto. *) *) *)
+(* (* (* (* while *) *) *) *)
+(* (* (*   rename s' into sr. *) *) *)
+(* (* (*   rewrite (tr_find_label_if _ _ H1); auto. *) *) *)
+(* (* (*   exploit (IHs (Kwhile2 e s k)); eauto. econstructor; eauto. *) *) *)
+(* (* (*   destruct (Csem.find_label lbl s (Kwhile2 e s k)) as [[s' k'] | ]. *) *) *)
+(* (* (*   intros [ts' [tk' [A [B C]]]]. rewrite A. exists ts'; exists tk'; intuition. *) *) *)
+(* (* (*   intro EQ. rewrite EQ. auto. *) *) *)
+(* (* (* (* dowhile *) *) *) *)
+(* (* (*   rename s' into sr. *) *) *)
+(* (* (*   rewrite (tr_find_label_if _ _ H1); auto. *) *) *)
+(* (* (*   exploit (IHs (Kdowhile1 e s k)); eauto. econstructor; eauto. *) *) *)
+(* (* (*   destruct (Csem.find_label lbl s (Kdowhile1 e s k)) as [[s' k'] | ]. *) *) *)
+(* (* (*   intros [ts' [tk' [A [B C]]]]. rewrite A. exists ts'; exists tk'; intuition. *) *) *)
+(* (* (*   intro EQ. rewrite EQ. auto. *) *) *)
+(* (* (* (* for skip *) *) *) *)
+(* (* (*   rename s' into sr. *) *) *)
+(* (* (*   rewrite (tr_find_label_if _ _ H4); auto. *) *) *)
+(* (* (*   exploit (IHs3 (Csem.Kfor3 e s2 s3 k)); eauto. econstructor; eauto. *) *) *)
+(* (* (*   destruct (Csem.find_label lbl s3 (Csem.Kfor3 e s2 s3 k)) as [[s' k'] | ]. *) *) *)
+(* (* (*   intros [ts' [tk' [A [B C]]]]. rewrite A. exists ts'; exists tk'; intuition. *) *) *)
+(* (* (*   intro EQ. rewrite EQ. *) *) *)
+(* (* (*   exploit (IHs2 (Csem.Kfor4 e s2 s3 k)); eauto. econstructor; eauto. *) *) *)
+(* (* (* (* for not skip *) *) *) *)
+(* (* (*   rename s' into sr. *) *) *)
+(* (* (*   rewrite (tr_find_label_if _ _ H3); auto. *) *) *)
+(* (* (*   exploit (IHs1 (Csem.Kseq (Csyntax.Sfor Csyntax.Sskip e s2 s3) k)); eauto. *) *) *)
+(* (* (*     econstructor; eauto. econstructor; eauto. *) *) *)
+(* (* (*   destruct (Csem.find_label lbl s1 *) *) *)
+(* (* (*                (Csem.Kseq (Csyntax.Sfor Csyntax.Sskip e s2 s3) k)) as [[s' k'] | ]. *) *) *)
+(* (* (*   intros [ts' [tk' [A [B C]]]]. rewrite A. exists ts'; exists tk'; intuition. *) *) *)
+(* (* (*   intro EQ; rewrite EQ. *) *) *)
+(* (* (*   exploit (IHs3 (Csem.Kfor3 e s2 s3 k)); eauto. econstructor; eauto. *) *) *)
+(* (* (*   destruct (Csem.find_label lbl s3 (Csem.Kfor3 e s2 s3 k)) as [[s'' k''] | ]. *) *) *)
+(* (* (*   intros [ts' [tk' [A [B C]]]]. rewrite A. exists ts'; exists tk'; intuition. *) *) *)
+(* (* (*   intro EQ'. rewrite EQ'. *) *) *)
+(* (* (*   exploit (IHs2 (Csem.Kfor4 e s2 s3 k)); eauto. econstructor; eauto. *) *) *)
+(* (* (* (* break, continue, return 0 *) *) *) *)
+(* (* (*   auto. auto. auto. *) *) *)
+(* (* (* (* return 1 *) *) *) *)
+(* (* (*   rewrite (tr_find_label_expression _ _ _ H0). auto. *) *) *)
+(* (* (* (* switch *) *) *) *)
+(* (* (*   rewrite (tr_find_label_expression _ _ _ H1). apply tr_find_label_ls. auto. constructor; auto. *) *) *)
+(* (* (* (* labeled stmt *) *) *) *)
+(* (* (*   destruct (ident_eq lbl l). exists ts0; exists tk; auto. apply IHs; auto. *) *) *)
+(* (* (* (* goto *) *) *) *)
+(* (* (*   auto. *) *) *)
+
+(* (* (*   induction s; intros; inversion TR; subst; clear TR; simpl. *) *) *)
+(* (* (* (* nil *) *) *) *)
+(* (* (*   auto. *) *) *)
+(* (* (* (* case *) *) *) *)
+(* (* (*   exploit (tr_find_label s (Csem.Kseq (Csem.seq_of_labeled_statement s0) k)); eauto. *) *) *)
+(* (* (*   econstructor; eauto. apply tr_seq_of_labeled_statement; eauto. *) *) *)
+(* (* (*   destruct (Csem.find_label lbl s *) *) *)
+(* (* (*     (Csem.Kseq (Csem.seq_of_labeled_statement s0) k)) as [[s' k'] | ]. *) *) *)
+(* (* (*   intros [ts' [tk' [A [B C]]]]. rewrite A. exists ts'; exists tk'; auto. *) *) *)
+(* (* (*   intro EQ. rewrite EQ. eapply IHs; eauto. *) *) *)
+(* (* (* Qed. *) *) *)
+  
+(* (* End FIND_LABEL. *) *)
+
+(* (* (** Anti-stuttering measure *) *) *)
+
+(* (* (** There are some stuttering steps in the translation: *) *)
+(* (* - The execution of [Sdo a] where [a] is side-effect free, *) *)
+(* (*   which is three transitions in the source: *) *)
+(* (* << *) *)
+(* (*     Sdo a, k  --->  a, Kdo k ---> rval v, Kdo k ---> Sskip, k *) *)
+(* (* >> *) *)
+(* (*   but the translation, which is [Sskip], makes no transitions. *) *)
+(* (* - The reduction [Ecomma (Eval v) r2 --> r2]. *) *)
+(* (* - The reduction [Eparen (Eval v) --> Eval v] in a [For_effects] context. *) *)
+
+(* (* The following measure decreases for these stuttering steps. *) *) *)
+
+(* (* Fixpoint esize (a: Csyntax.expr) : nat := *) *)
+(* (*   match a with *) *)
+(* (*   | Csyntax.Eloc _ _ _ => 1%nat *) *)
+(* (*   | Csyntax.Evar _ _ => 1%nat *) *)
+(* (*   | Csyntax.Ederef r1 _ => S(esize r1) *) *)
+(* (*   | Csyntax.Efield l1 _ _ => S(esize l1) *) *)
+(* (*   | Csyntax.Eval _ _ => O *) *)
+(* (*   | Csyntax.Evalof l1 _ => S(esize l1) *) *)
+(* (*   | Csyntax.Eaddrof l1 _ => S(esize l1) *) *)
+(* (*   | Csyntax.Eunop _ r1 _ => S(esize r1) *) *)
+(* (*   | Csyntax.Ebinop _ r1 r2 _ => S(esize r1 + esize r2)%nat *) *)
+(* (*   | Csyntax.Ecast r1 _ => S(esize r1) *) *)
+(* (*   | Csyntax.Eseqand r1 _ _ => S(esize r1) *) *)
+(* (*   | Csyntax.Eseqor r1 _ _ => S(esize r1) *) *)
+(* (*   | Csyntax.Econdition r1 _ _ _ => S(esize r1) *) *)
+(* (*   | Csyntax.Esizeof _ _ => 1%nat *) *)
+(* (*   | Csyntax.Ealignof _ _ => 1%nat *) *)
+(* (*   | Csyntax.Eassign l1 r2 _ => S(esize l1 + esize r2)%nat *) *)
+(* (*   | Csyntax.Eassignop _ l1 r2 _ _ => S(esize l1 + esize r2)%nat *) *)
+(* (*   | Csyntax.Epostincr _ l1 _ => S(esize l1) *) *)
+(* (*   | Csyntax.Ecomma r1 r2 _ => S(esize r1 + esize r2)%nat *) *)
+(* (*   | Csyntax.Ecall r1 rl2 _ => S(esize r1 + esizelist rl2)%nat *) *)
+(* (*   | Csyntax.Ebuiltin ef _ rl _ => S(esizelist rl)%nat *) *)
+(* (*   | Csyntax.Eparen r1 _ _ => S(esize r1) *) *)
+(* (*   end *) *)
+
+(* (* with esizelist (el: Csyntax.exprlist) : nat := *) *)
+(* (*   match el with *) *)
+(* (*   | Csyntax.Enil => O *) *)
+(* (*   | Csyntax.Econs r1 rl2 => (esize r1 + esizelist rl2)%nat *) *)
+(* (*   end. *) *)
+
+(* (* Definition measure (st: Csem.state) : nat := *) *)
+(* (*   match st with *) *)
+(* (*   | Csem.ExprState _ r _ _ _ => (esize r + 1)%nat *) *)
+(* (*   | Csem.State _ Csyntax.Sskip _ _ _ => 0%nat *) *)
+(* (*   | Csem.State _ (Csyntax.Sdo r) _ _ _ => (esize r + 2)%nat *) *)
+(* (*   | Csem.State _ (Csyntax.Sifthenelse r _ _) _ _ _ => (esize r + 2)%nat *) *)
+(* (*   | _ => 0%nat *) *)
+(* (*   end. *) *)
+
+(* (* Lemma leftcontext_size: *) *)
+(* (*   forall from to C, *) *)
+(* (*   leftcontext from to C -> *) *)
+(* (*   forall e1 e2, *) *)
+(* (*   (esize e1 < esize e2)%nat -> *) *)
+(* (*   (esize (C e1) < esize (C e2))%nat *) *)
+(* (* with leftcontextlist_size: *) *)
+(* (*   forall from C, *) *)
+(* (*   leftcontextlist from C -> *) *)
+(* (*   forall e1 e2, *) *)
+(* (*   (esize e1 < esize e2)%nat -> *) *)
+(* (*   (esizelist (C e1) < esizelist (C e2))%nat. *) *)
+(* (* Proof. *) *)
+(* (*   induction 1; intros; simpl; auto with arith. *) *)
+(* (*   exploit leftcontextlist_size; eauto. auto with arith. *) *)
+(* (*   exploit leftcontextlist_size; eauto. auto with arith. *) *)
+(* (*   induction 1; intros; simpl; auto with arith. exploit leftcontext_size; eauto. auto with arith. *) *)
+(* (* Qed. *) *)
+
+(* (* (** Forward simulation for expressions. *) *) *)
+
+(* (* Lemma tr_val_gen: *) *)
+(* (*   forall le dst v ty a tmp, *) *)
+(* (*   typeof a = ty -> *) *)
+(* (*   (forall tge e le' m, *) *)
+(* (*       (forall id, In id tmp -> le'!id = le!id) -> *) *)
+(* (*       eval_expr tge e le' m a v) -> *) *)
+(* (*   tr_expr le dst (Csyntax.Eval v ty) (final dst a) a tmp. *) *)
+(* (* Proof. *) *)
+(* (*   intros. destruct dst; simpl; econstructor; auto. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma estep_simulation: *) *)
+(* (*   forall S1 t S2, Cstrategy.estep ge S1 t S2 -> *) *)
+(* (*   forall S1' (MS: match_states S1 S1'), *) *)
+(* (*   exists S2', *) *)
+(* (*      (plus step1 tge S1' t S2' \/ *) *)
+(* (*        (star step1 tge S1' t S2' /\ measure S2 < measure S1)%nat) *) *)
+(* (*   /\ match_states S2 S2'. *) *)
+(* (* Proof. *) *)
+(* (*   induction 1; intros; inv MS. *) *)
+(* (* (* expr *) *) *)
+(* (*   assert (tr_expr le dest r sl a tmps). *) *)
+(* (*     inv H9. contradiction. auto. *) *)
+(* (*   exploit tr_simple_rvalue; eauto. destruct dest. *) *)
+(* (*   (* for val *) *) *)
+(* (*   intros [SL1 [TY1 EV1]]. subst sl. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   right; split. apply star_refl. destruct r; simpl; (contradiction || lia). *) *)
+(* (*   econstructor; eauto. *) *)
+(* (*   instantiate (1 := tmps). apply tr_top_val_val; auto. *) *)
+(* (*   (* for effects *) *) *)
+(* (*   intros SL1. subst sl. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   right; split. apply star_refl. destruct r; simpl; (contradiction || lia). *) *)
+(* (*   econstructor; eauto. *) *)
+(* (*   instantiate (1 := tmps). apply tr_top_base. constructor. *) *)
+(* (*   (* for set *) *) *)
+(* (*   inv H10. *) *)
+(* (* (* rval volatile *) *) *)
+(* (*   exploit tr_top_leftcontext; eauto. clear H11. *) *)
+(* (*   intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   inv P. inv H2. inv H7; try congruence. *) *)
+(* (*   exploit tr_simple_lvalue; eauto. intros [SL [TY EV]]. subst sl0; simpl. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_two. constructor. eapply step_make_set; eauto. traceEq. *) *)
+(* (*   econstructor; eauto. *) *)
+(* (*   change (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) with (nil ++ (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2)). *) *)
+(* (*   apply S. apply tr_val_gen. auto. *) *)
+(* (*   intros. constructor. rewrite H5; auto. apply PTree.gss. *) *)
+(* (*   intros. apply PTree.gso. red; intros; subst; elim H5; auto. *) *)
+(* (*   auto. *) *)
+(* (* (* seqand true *) *) *)
+(* (*   exploit tr_top_leftcontext; eauto. clear H9. *) *)
+(* (*   intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   inv P. inv H2. *) *)
+(* (*   (* for val *) *) *)
+(* (*   exploit tr_simple_rvalue; eauto. intros [SL [TY EV]]. *) *)
+(* (*   subst sl0; simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. *) *)
+(* (*   eapply star_trans. apply step_makeif with (b := true) (v1 := v); auto. congruence. *) *)
+(* (*   apply push_seq. reflexivity. reflexivity. *) *)
+(* (*   rewrite <- Kseqlist_app. *) *)
+(* (*   eapply match_exprstates; eauto. *) *)
+(* (*   apply S. apply tr_paren_val with (a1 := a2); auto. *) *)
+(* (*   apply tr_expr_monotone with tmp2; eauto. auto. auto. *) *)
+(* (*   (* for effects *) *) *)
+(* (*   exploit tr_simple_rvalue; eauto. intros [SL [TY EV]]. *) *)
+(* (*   subst sl0; simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. *) *)
+(* (*   eapply star_trans. apply step_makeif with (b := true) (v1 := v); auto. congruence. *) *)
+(* (*   apply push_seq. reflexivity. reflexivity. *) *)
+(* (*   rewrite <- Kseqlist_app. *) *)
+(* (*   eapply match_exprstates; eauto. *) *)
+(* (*   apply S. apply tr_paren_effects with (a1 := a2); auto. *) *)
+(* (*   apply tr_expr_monotone with tmp2; eauto. auto. auto. *) *)
+(* (*   (* for set *) *) *)
+(* (*   exploit tr_simple_rvalue; eauto. intros [SL [TY EV]]. *) *)
+(* (*   subst sl0; simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. *) *)
+(* (*   eapply star_trans. apply step_makeif with (b := true) (v1 := v); auto. congruence. *) *)
+(* (*   apply push_seq. reflexivity. reflexivity. *) *)
+(* (*   rewrite <- Kseqlist_app. *) *)
+(* (*   eapply match_exprstates; eauto. *) *)
+(* (*   apply S. apply tr_paren_set with (a1 := a2) (t := sd_temp sd); auto. *) *)
+(* (*   apply tr_expr_monotone with tmp2; eauto. auto. auto. *) *)
+(* (* (* seqand false *) *) *)
+(* (*   exploit tr_top_leftcontext; eauto. clear H9. *) *)
+(* (*   intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   inv P. inv H2. *) *)
+(* (*   (* for val *) *) *)
+(* (*   exploit tr_simple_rvalue; eauto. intros [SL [TY EV]]. *) *)
+(* (*   subst sl0; simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. *) *)
+(* (*   eapply star_trans. apply step_makeif with (b := false) (v1 := v); auto. congruence. *) *)
+(* (*   apply star_one. constructor. constructor. reflexivity. reflexivity. *) *)
+(* (*   eapply match_exprstates; eauto. *) *)
+(* (*   change sl2 with (nil ++ sl2). apply S. econstructor; eauto. *) *)
+(* (*   intros. constructor. rewrite H2. apply PTree.gss. auto. *) *)
+(* (*   intros. apply PTree.gso. congruence. *) *)
+(* (*   auto. *) *)
+(* (*   (* for effects *) *) *)
+(* (*   exploit tr_simple_rvalue; eauto. intros [SL [TY EV]]. *) *)
+(* (*   subst sl0; simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. *) *)
+(* (*   apply step_makeif with (b := false) (v1 := v); auto. congruence. *) *)
+(* (*   reflexivity. *) *)
+(* (*   eapply match_exprstates; eauto. *) *)
+(* (*   change sl2 with (nil ++ sl2). apply S. econstructor; eauto. *) *)
+(* (*   auto. auto. *) *)
+(* (*   (* for set *) *) *)
+(* (*   exploit tr_simple_rvalue; eauto. intros [SL [TY EV]]. *) *)
+(* (*   subst sl0; simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. *) *)
+(* (*   eapply star_trans. apply step_makeif with (b := false) (v1 := v); auto. congruence. *) *)
+(* (*   apply push_seq. reflexivity. reflexivity. *) *)
+(* (*   rewrite <- Kseqlist_app. *) *)
+(* (*   eapply match_exprstates; eauto. *) *)
+(* (*   apply S. econstructor; eauto. intros. constructor. auto. auto. *) *)
+(* (* (* seqor true *) *) *)
+(* (*   exploit tr_top_leftcontext; eauto. clear H9. *) *)
+(* (*   intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   inv P. inv H2. *) *)
+(* (*   (* for val *) *) *)
+(* (*   exploit tr_simple_rvalue; eauto. intros [SL [TY EV]]. *) *)
+(* (*   subst sl0; simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. *) *)
+(* (*   eapply star_trans. apply step_makeif with (b := true) (v1 := v); auto. congruence. *) *)
+(* (*   apply star_one. constructor. constructor. reflexivity. reflexivity. *) *)
+(* (*   eapply match_exprstates; eauto. *) *)
+(* (*   change sl2 with (nil ++ sl2). apply S. econstructor; eauto. *) *)
+(* (*   intros. constructor. rewrite H2. apply PTree.gss. auto. *) *)
+(* (*   intros. apply PTree.gso. congruence. *) *)
+(* (*   auto. *) *)
+(* (*   (* for effects *) *) *)
+(* (*   exploit tr_simple_rvalue; eauto. intros [SL [TY EV]]. *) *)
+(* (*   subst sl0; simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. *) *)
+(* (*   apply step_makeif with (b := true) (v1 := v); auto. congruence. *) *)
+(* (*   reflexivity. *) *)
+(* (*   eapply match_exprstates; eauto. *) *)
+(* (*   change sl2 with (nil ++ sl2). apply S. econstructor; eauto. *) *)
+(* (*   auto. auto. *) *)
+(* (*   (* for set *) *) *)
+(* (*   exploit tr_simple_rvalue; eauto. intros [SL [TY EV]]. *) *)
+(* (*   subst sl0; simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. *) *)
+(* (*   eapply star_trans. apply step_makeif with (b := true) (v1 := v); auto. congruence. *) *)
+(* (*   apply push_seq. reflexivity. reflexivity. *) *)
+(* (*   rewrite <- Kseqlist_app. *) *)
+(* (*   eapply match_exprstates; eauto. *) *)
+(* (*   apply S. econstructor; eauto. intros. constructor. auto. auto. *) *)
+(* (* (* seqand false *) *) *)
+(* (*   exploit tr_top_leftcontext; eauto. clear H9. *) *)
+(* (*   intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   inv P. inv H2. *) *)
+(* (*   (* for val *) *) *)
+(* (*   exploit tr_simple_rvalue; eauto. intros [SL [TY EV]]. *) *)
+(* (*   subst sl0; simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. *) *)
+(* (*   eapply star_trans. apply step_makeif with (b := false) (v1 := v); auto. congruence. *) *)
+(* (*   apply push_seq. reflexivity. reflexivity. *) *)
+(* (*   rewrite <- Kseqlist_app. *) *)
+(* (*   eapply match_exprstates; eauto. *) *)
+(* (*   apply S. apply tr_paren_val with (a1 := a2); auto. *) *)
+(* (*   apply tr_expr_monotone with tmp2; eauto. auto. auto. *) *)
+(* (*   (* for effects *) *) *)
+(* (*   exploit tr_simple_rvalue; eauto. intros [SL [TY EV]]. *) *)
+(* (*   subst sl0; simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. *) *)
+(* (*   eapply star_trans. apply step_makeif with (b := false) (v1 := v); auto. congruence. *) *)
+(* (*   apply push_seq. reflexivity. reflexivity. *) *)
+(* (*   rewrite <- Kseqlist_app. *) *)
+(* (*   eapply match_exprstates; eauto. *) *)
+(* (*   apply S. apply tr_paren_effects with (a1 := a2); auto. *) *)
+(* (*   apply tr_expr_monotone with tmp2; eauto. auto. auto. *) *)
+(* (*   (* for set *) *) *)
+(* (*   exploit tr_simple_rvalue; eauto. intros [SL [TY EV]]. *) *)
+(* (*   subst sl0; simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. *) *)
+(* (*   eapply star_trans. apply step_makeif with (b := false) (v1 := v); auto. congruence. *) *)
+(* (*   apply push_seq. reflexivity. reflexivity. *) *)
+(* (*   rewrite <- Kseqlist_app. *) *)
+(* (*   eapply match_exprstates; eauto. *) *)
+(* (*   apply S. apply tr_paren_set with (a1 := a2) (t := sd_temp sd); auto. *) *)
+(* (*   apply tr_expr_monotone with tmp2; eauto. auto. auto. *) *)
+(* (* (* condition *) *) *)
+(* (*   exploit tr_top_leftcontext; eauto. clear H9. *) *)
+(* (*   intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   inv P. inv H2. *) *)
+(* (*   (* for value *) *) *)
+(* (*   exploit tr_simple_rvalue; eauto. intros [SL [TY EV]]. *) *)
+(* (*   subst sl0; simpl Kseqlist. destruct b. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. *) *)
+(* (*   eapply star_trans. apply step_makeif with (b := true) (v1 := v); auto. congruence. *) *)
+(* (*   apply push_seq. reflexivity. reflexivity. *) *)
+(* (*   rewrite <- Kseqlist_app. *) *)
+(* (*   eapply match_exprstates; eauto. *) *)
+(* (*   apply S. econstructor; eauto. apply tr_expr_monotone with tmp2; eauto. auto. auto. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. *) *)
+(* (*   eapply star_trans. apply step_makeif with (b := false) (v1 := v); auto. congruence. *) *)
+(* (*   apply push_seq. reflexivity. reflexivity. *) *)
+(* (*   rewrite <- Kseqlist_app. *) *)
+(* (*   eapply match_exprstates; eauto. *) *)
+(* (*   apply S. econstructor; eauto. apply tr_expr_monotone with tmp3; eauto. auto. auto. *) *)
+(* (*   (* for effects *) *) *)
+(* (*   exploit tr_simple_rvalue; eauto. intros [SL [TY EV]]. *) *)
+(* (*   subst sl0; simpl Kseqlist. destruct b. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. *) *)
+(* (*   eapply star_trans. apply step_makeif with (b := true) (v1 := v); auto. congruence. *) *)
+(* (*   apply push_seq. *) *)
+(* (*   reflexivity. traceEq. *) *)
+(* (*   rewrite <- Kseqlist_app. *) *)
+(* (*   econstructor. eauto. apply S. *) *)
+(* (*     econstructor; eauto. apply tr_expr_monotone with tmp2; eauto. *) *)
+(* (*     econstructor; eauto. *) *)
+(* (*   auto. auto. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. *) *)
+(* (*   eapply star_trans. apply step_makeif with (b := false) (v1 := v); auto. congruence. *) *)
+(* (*   apply push_seq. *) *)
+(* (*   reflexivity. traceEq. *) *)
+(* (*   rewrite <- Kseqlist_app. *) *)
+(* (*   econstructor. eauto. apply S. *) *)
+(* (*     econstructor; eauto. apply tr_expr_monotone with tmp3; eauto. *) *)
+(* (*     econstructor; eauto. *) *)
+(* (*   auto. auto. *) *)
+(* (*   (* for set *) *) *)
+(* (*   exploit tr_simple_rvalue; eauto. intros [SL [TY EV]]. *) *)
+(* (*   subst sl0; simpl Kseqlist. destruct b. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. *) *)
+(* (*   eapply star_trans. apply step_makeif with (b := true) (v1 := v); auto. congruence. *) *)
+(* (*   apply push_seq. *) *)
+(* (*   reflexivity. traceEq. *) *)
+(* (*   rewrite <- Kseqlist_app. *) *)
+(* (*   econstructor. eauto. apply S. *) *)
+(* (*     econstructor; eauto. apply tr_expr_monotone with tmp2; eauto. *) *)
+(* (*     econstructor; eauto. *) *)
+(* (*   auto. auto. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. *) *)
+(* (*   eapply star_trans. apply step_makeif with (b := false) (v1 := v); auto. congruence. *) *)
+(* (*   apply push_seq. *) *)
+(* (*   reflexivity. traceEq. *) *)
+(* (*   rewrite <- Kseqlist_app. *) *)
+(* (*   econstructor. eauto. apply S. *) *)
+(* (*     econstructor; eauto. apply tr_expr_monotone with tmp3; eauto. *) *)
+(* (*     econstructor; eauto. *) *)
+(* (*   auto. auto. *) *)
+(* (* (* assign *) *) *)
+(* (*   exploit tr_top_leftcontext; eauto. clear H12. *) *)
+(* (*   intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   inv P. inv H4. *) *)
+(* (*   (* for effects *) *) *)
+(* (*   exploit tr_simple_rvalue; eauto. intros [SL2 [TY2 EV2]]. *) *)
+(* (*   exploit tr_simple_lvalue; eauto. intros [SL1 [TY1 EV1]]. *) *)
+(* (*   subst; simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. *) *)
+(* (*   apply star_one. eapply step_make_assign; eauto. *) *)
+(* (*   rewrite <- TY2; eauto. traceEq. *) *)
+(* (*   econstructor. auto. change sl2 with (nil ++ sl2). apply S. *) *)
+(* (*   constructor. auto. auto. auto. *) *)
+(* (*   (* for value *) *) *)
+(* (*   exploit tr_simple_rvalue; eauto. intros [SL2 [TY2 EV2]]. *) *)
+(* (*   exploit tr_simple_lvalue. eauto. *) *)
+(* (*     eapply tr_expr_invariant with (le' := PTree.set t0 v' le). eauto. *) *)
+(* (*     intros. apply PTree.gso. intuition congruence. *) *)
+(* (*   intros [SL1 [TY1 EV1]]. *) *)
+(* (*   subst; simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. *) *)
+(* (*   eapply star_left. constructor. econstructor. eauto. rewrite <- TY2; eauto.  *) *)
+(* (*   eapply star_left. constructor. *) *)
+(* (*   apply star_one. eapply step_make_assign; eauto. *) *)
+(* (*   constructor. apply PTree.gss. simpl. eapply cast_idempotent; eauto.  *) *)
+(* (*   reflexivity. reflexivity. traceEq. *) *)
+(* (*   econstructor. auto. apply S. *) *)
+(* (*   apply tr_val_gen. auto. intros. constructor. *) *)
+(* (*   rewrite H4; auto. apply PTree.gss. *) *)
+(* (*   intros. apply PTree.gso. intuition congruence. *) *)
+(* (*   auto. auto. *) *)
+(* (* (* assignop *) *) *)
+(* (*   exploit tr_top_leftcontext; eauto. clear H15. *) *)
+(* (*   intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   inv P. inv H6. *) *)
+(* (*   (* for effects *) *) *)
+(* (*   exploit tr_simple_lvalue; eauto. intros [SL1 [TY1 EV1]]. *) *)
+(* (*   exploit step_tr_rvalof; eauto. intros [le' [EXEC [EV3 [TY3 INV]]]]. *) *)
+(* (*   exploit tr_simple_lvalue. eauto. eapply tr_expr_invariant with (le := le) (le' := le'). eauto. *) *)
+(* (*   intros. apply INV. NOTIN. intros [? [? EV1']]. *) *)
+(* (*   exploit tr_simple_rvalue. eauto. eapply tr_expr_invariant with (le := le) (le' := le'). eauto. *) *)
+(* (*   intros. apply INV. NOTIN. simpl. intros [SL2 [TY2 EV2]]. *) *)
+(* (*   subst; simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply star_plus_trans. rewrite app_ass. rewrite Kseqlist_app. eexact EXEC. *) *)
+(* (*   eapply plus_two. simpl. econstructor. eapply step_make_assign; eauto. *) *)
+(* (*     econstructor. eexact EV3. eexact EV2. *) *)
+(* (*     rewrite TY3; rewrite <- TY1; rewrite <- TY2; rewrite comp_env_preserved; auto. *) *)
+(* (*   reflexivity. traceEq. *) *)
+(* (*   econstructor. auto. change sl2 with (nil ++ sl2). apply S. *) *)
+(* (*   constructor. auto. auto. auto. *) *)
+(* (*   (* for value *) *) *)
+(* (*   exploit tr_simple_lvalue; eauto. intros [SL1 [TY1 EV1]]. *) *)
+(* (*   exploit step_tr_rvalof; eauto. intros [le' [EXEC [EV3 [TY3 INV]]]]. *) *)
+(* (*   exploit tr_simple_lvalue. eauto. eapply tr_expr_invariant with (le := le) (le' := le'). eauto. *) *)
+(* (*   intros. apply INV. NOTIN. intros [? [? EV1']]. *) *)
+(* (*   exploit tr_simple_rvalue. eauto. eapply tr_expr_invariant with (le := le) (le' := le'). eauto. *) *)
+(* (*   intros. apply INV. NOTIN. simpl. intros [SL2 [TY2 EV2]]. *) *)
+(* (*   exploit tr_simple_lvalue. eauto. *) *)
+(* (*     eapply tr_expr_invariant with (le := le) (le' := PTree.set t v4 le'). eauto. *) *)
+(* (*     intros. rewrite PTree.gso. apply INV. NOTIN. intuition congruence. *) *)
+(* (*   intros [? [? EV1'']]. *) *)
+(* (*   subst; simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. rewrite app_ass. rewrite Kseqlist_app. *) *)
+(* (*   eapply star_plus_trans. eexact EXEC. *) *)
+(* (*   simpl. eapply plus_four. econstructor. econstructor. *) *)
+(* (*     econstructor. econstructor. eexact EV3. eexact EV2. *) *)
+(* (*     rewrite TY3; rewrite <- TY1; rewrite <- TY2; rewrite comp_env_preserved; eauto. *) *)
+(* (*     eassumption. *) *)
+(* (*   econstructor. eapply step_make_assign; eauto. *) *)
+(* (*     constructor. apply PTree.gss. simpl. eapply cast_idempotent; eauto. *) *)
+(* (*     reflexivity. traceEq. *) *)
+(* (*   econstructor. auto. apply S. *) *)
+(* (*   apply tr_val_gen. auto. intros. constructor. *) *)
+(* (*   rewrite H10; auto. apply PTree.gss. *) *)
+(* (*   intros. rewrite PTree.gso. apply INV. *) *)
+(* (*   red; intros; elim H10; auto. *) *)
+(* (*   intuition congruence. *) *)
+(* (*   auto. auto. *) *)
+(* (* (* assignop stuck *) *) *)
+(* (*   exploit tr_top_leftcontext; eauto. clear H12. *) *)
+(* (*   intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   inv P. inv H4. *) *)
+(* (*   (* for effects *) *) *)
+(* (*   exploit tr_simple_lvalue; eauto. intros [SL1 [TY1 EV1]]. *) *)
+(* (*   exploit tr_simple_rvalue; eauto. intros [SL2 [TY2 EV2]]. *) *)
+(* (*   exploit step_tr_rvalof; eauto. intros [le' [EXEC [EV3 [TY3 INV]]]]. *) *)
+(* (*   subst; simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   right; split. rewrite app_ass. rewrite Kseqlist_app. eexact EXEC. *) *)
+(* (*   simpl. lia. *) *)
+(* (*   constructor. *) *)
+(* (*   (* for value *) *) *)
+(* (*   exploit tr_simple_lvalue; eauto. intros [SL1 [TY1 EV1]]. *) *)
+(* (*   exploit tr_simple_rvalue; eauto. intros [SL2 [TY2 EV2]]. *) *)
+(* (*   exploit step_tr_rvalof; eauto. intros [le' [EXEC [EV3 [TY3 INV]]]]. *) *)
+(* (*   subst; simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   right; split. rewrite app_ass. rewrite Kseqlist_app. eexact EXEC. *) *)
+(* (*   simpl. lia. *) *)
+(* (*   constructor. *) *)
+(* (* (* postincr *) *) *)
+(* (*   exploit tr_top_leftcontext; eauto. clear H14. *) *)
+(* (*   intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   inv P. inv H5. *) *)
+(* (*   (* for effects *) *) *)
+(* (*   exploit tr_simple_lvalue; eauto. intros [SL1 [TY1 EV1]]. *) *)
+(* (*   exploit step_tr_rvalof; eauto. intros [le' [EXEC [EV3 [TY3 INV]]]]. *) *)
+(* (*   exploit tr_simple_lvalue. eauto. eapply tr_expr_invariant with (le := le) (le' := le'). eauto. *) *)
+(* (*   intros. apply INV. NOTIN. intros [? [? EV1']]. *) *)
+(* (*   subst; simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. rewrite app_ass; rewrite Kseqlist_app. *) *)
+(* (*   eapply star_plus_trans. eexact EXEC. *) *)
+(* (*   eapply plus_two. simpl. constructor. *) *)
+(* (*   eapply step_make_assign; eauto. *) *)
+(* (*   unfold transl_incrdecr. destruct id; simpl in H2. *) *)
+(* (*   econstructor. eauto. constructor. rewrite TY3; rewrite <- TY1; rewrite comp_env_preserved. simpl; eauto. *) *)
+(* (*   econstructor. eauto. constructor. rewrite TY3; rewrite <- TY1; rewrite comp_env_preserved. simpl; eauto. *) *)
+(* (*   destruct id; auto. *) *)
+(* (*   reflexivity. traceEq. *) *)
+(* (*   econstructor. auto. change sl2 with (nil ++ sl2). apply S. *) *)
+(* (*   constructor. auto. auto. auto. *) *)
+(* (*   (* for value *) *) *)
+(* (*   exploit tr_simple_lvalue; eauto. intros [SL1 [TY1 EV1]]. *) *)
+(* (*   exploit tr_simple_lvalue. eauto. *) *)
+(* (*     eapply tr_expr_invariant with (le' := PTree.set t v1 le). eauto. *) *)
+(* (*     intros. apply PTree.gso. intuition congruence. *) *)
+(* (*   intros [SL2 [TY2 EV2]]. *) *)
+(* (*   subst; simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_four. constructor. *) *)
+(* (*   eapply step_make_set; eauto. *) *)
+(* (*   constructor. *) *)
+(* (*   eapply step_make_assign; eauto. *) *)
+(* (*   unfold transl_incrdecr. destruct id; simpl in H2. *) *)
+(* (*   econstructor. constructor. apply PTree.gss. constructor. *) *)
+(* (*   rewrite comp_env_preserved; simpl; eauto. *) *)
+(* (*   econstructor. constructor. apply PTree.gss. constructor. *) *)
+(* (*   rewrite comp_env_preserved; simpl; eauto. *) *)
+(* (*   destruct id; auto. *) *)
+(* (*   traceEq. *) *)
+(* (*   econstructor. auto. apply S. *) *)
+(* (*   apply tr_val_gen. auto. intros. econstructor; eauto. *) *)
+(* (*   rewrite H5; auto. apply PTree.gss. *) *)
+(* (*   intros. apply PTree.gso. intuition congruence. *) *)
+(* (*   auto. auto. *) *)
+(* (* (* postincr stuck *) *) *)
+(* (*   exploit tr_top_leftcontext; eauto. clear H11. *) *)
+(* (*   intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   inv P. inv H3. *) *)
+(* (*   (* for effects *) *) *)
+(* (*   exploit tr_simple_lvalue; eauto. intros [SL1 [TY1 EV1]]. *) *)
+(* (*   exploit step_tr_rvalof; eauto. intros [le' [EXEC [EV3 [TY3 INV]]]]. *) *)
+(* (*   subst. simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   right; split. rewrite app_ass; rewrite Kseqlist_app. eexact EXEC. *) *)
+(* (*   simpl; lia. *) *)
+(* (*   constructor. *) *)
+(* (*   (* for value *) *) *)
+(* (*   exploit tr_simple_lvalue; eauto. intros [SL1 [TY1 EV1]]. *) *)
+(* (*   subst. simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_two. constructor. eapply step_make_set; eauto. *) *)
+(* (*   traceEq. *) *)
+(* (*   constructor. *) *)
+(* (* (* comma *) *) *)
+(* (*   exploit tr_top_leftcontext; eauto. clear H9. *) *)
+(* (*   intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   inv P. inv H1. *) *)
+(* (*   exploit tr_simple_rvalue; eauto. simpl; intro SL1. *) *)
+(* (*   subst sl0; simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   right; split. apply star_refl. simpl. apply plus_lt_compat_r. *) *)
+(* (*   apply (leftcontext_size _ _ _ H). simpl. lia. *) *)
+(* (*   econstructor; eauto. apply S. *) *)
+(* (*   eapply tr_expr_monotone; eauto. *) *)
+(* (*   auto. auto. *) *)
+(* (* (* paren *) *) *)
+(* (*   exploit tr_top_leftcontext; eauto. clear H9. *) *)
+(* (*   intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   inv P. inv H2. *) *)
+(* (*   (* for value *) *) *)
+(* (*   exploit tr_simple_rvalue; eauto. intros [b [SL1 [TY1 EV1]]]. *) *)
+(* (*   subst sl1; simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. apply star_one. *) *)
+(* (*   econstructor. econstructor; eauto. rewrite <- TY1; eauto. traceEq. *) *)
+(* (*   econstructor; eauto. *) *)
+(* (*   change sl2 with (final For_val (Etempvar t (Csyntax.typeof r)) ++ sl2). apply S. *) *)
+(* (*   constructor. auto. intros. constructor. rewrite H2; auto. apply PTree.gss. *) *)
+(* (*   intros. apply PTree.gso. intuition congruence. *) *)
+(* (*   auto. *) *)
+(* (*   (* for effects *) *) *)
+(* (*   econstructor; split. *) *)
+(* (*   right; split. apply star_refl. simpl. apply plus_lt_compat_r. *) *)
+(* (*   apply (leftcontext_size _ _ _ H). simpl. lia. *) *)
+(* (*   econstructor; eauto. *) *)
+(* (*   exploit tr_simple_rvalue; eauto. simpl. intros A. subst sl1. *) *)
+(* (*   apply S. constructor; auto. auto. auto. *) *)
+(* (*   (* for set *) *) *)
+(* (*   exploit tr_simple_rvalue; eauto. simpl. intros [b [SL1 [TY1 EV1]]]. subst sl1. *) *)
+(* (*   simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. apply star_one. econstructor. econstructor; eauto. *) *)
+(* (*   rewrite <- TY1; eauto. traceEq. *) *)
+(* (*   econstructor; eauto. *) *)
+(* (*   apply S. constructor; auto. *) *)
+(* (*   intros. constructor. rewrite H2. apply PTree.gss. auto. *) *)
+(* (*   intros. apply PTree.gso. congruence. *) *)
+(* (*   auto. *) *)
+
+(* (* (* call *) *) *)
+(* (*   exploit tr_top_leftcontext; eauto. clear H12. *) *)
+(* (*   intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   inv P. inv H5. *) *)
+(* (*   (* for effects *) *) *)
+(* (*   exploit tr_simple_rvalue; eauto. intros [SL1 [TY1 EV1]]. *) *)
+(* (*   exploit tr_simple_exprlist; eauto. intros [SL2 EV2]. *) *)
+(* (*   subst. simpl Kseqlist. *) *)
+(* (*   exploit functions_translated; eauto. intros [tfd [J K]]. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor.  apply star_one. *) *)
+(* (*   econstructor; eauto. rewrite <- TY1; eauto. *) *)
+(* (*   exploit type_of_fundef_preserved; eauto. congruence. *) *)
+(* (*   traceEq. *) *)
+(* (*   constructor; auto. econstructor; eauto. *) *)
+(* (*   intros. change sl2 with (nil ++ sl2). apply S. *) *)
+(* (*   constructor. auto. auto. *) *)
+(* (*   (* for value *) *) *)
+(* (*   exploit tr_simple_rvalue; eauto. intros [SL1 [TY1 EV1]]. *) *)
+(* (*   exploit tr_simple_exprlist; eauto. intros [SL2 EV2]. *) *)
+(* (*   subst. simpl Kseqlist. *) *)
+(* (*   exploit functions_translated; eauto. intros [tfd [J K]]. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor.  apply star_one. *) *)
+(* (*   econstructor; eauto. rewrite <- TY1; eauto. *) *)
+(* (*   exploit type_of_fundef_preserved; eauto. congruence. *) *)
+(* (*   traceEq. *) *)
+(* (*   constructor; auto. econstructor; eauto. *) *)
+(* (*   intros. apply S. *) *)
+(* (*   destruct dst'; constructor. *) *)
+(* (*   auto. intros. constructor. rewrite H5; auto. apply PTree.gss. *) *)
+(* (*   auto. intros. constructor. rewrite H5; auto. apply PTree.gss. *) *)
+(* (*   intros. apply PTree.gso. intuition congruence. *) *)
+(* (*   auto. *) *)
+
+(* (* (* builtin *) *) *)
+(* (*   exploit tr_top_leftcontext; eauto. clear H9. *) *)
+(* (*   intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]]. *) *)
+(* (*   inv P. inv H2. *) *)
+(* (*   (* for effects *) *) *)
+(* (*   exploit tr_simple_exprlist; eauto. intros [SL EV]. *) *)
+(* (*   subst. simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor.  apply star_one. *) *)
+(* (*   econstructor; eauto. *) *)
+(* (*   eapply external_call_symbols_preserved; eauto. apply senv_preserved. *) *)
+(* (*   traceEq. *) *)
+(* (*   econstructor; eauto. *) *)
+(* (*   change sl2 with (nil ++ sl2). apply S. constructor. simpl; auto. auto. *) *)
+(* (*   (* for value *) *) *)
+(* (*   exploit tr_simple_exprlist; eauto. intros [SL EV]. *) *)
+(* (*   subst. simpl Kseqlist. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. apply star_one. *) *)
+(* (*   econstructor; eauto. *) *)
+(* (*   eapply external_call_symbols_preserved; eauto. apply senv_preserved. *) *)
+(* (*   traceEq. *) *)
+(* (*   econstructor; eauto. *) *)
+(* (*   change sl2 with (nil ++ sl2). apply S. *) *)
+(* (*   apply tr_val_gen. auto. intros. constructor. rewrite H2; auto. simpl. apply PTree.gss. *) *)
+(* (*   intros; simpl. apply PTree.gso. intuition congruence. *) *)
+(* (*   auto. *) *)
+(* (* Qed. *) *)
+
+(* (** Forward simulation for statements. *) *)
+
+(* (* Lemma tr_top_val_for_val_inv: *) *)
+(* (*   forall e le m v ty sl a tmps, *) *)
+(* (*   tr_top tge e le m For_val (Csyntax.Eval v ty) sl a tmps -> *) *)
+(* (*   sl = nil /\ typeof a = ty /\ eval_expr tge e le m a v. *) *)
+(* (* Proof. *) *)
+(* (*   intros. inv H. auto. inv H0. auto. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma alloc_variables_preserved: *) *)
+(* (*   forall e m params e' m', *) *)
+(* (*   Csem.alloc_variables ge e m params e' m' -> *) *)
+(* (*   alloc_variables tge e m params e' m'. *) *)
+(* (* Proof. *) *)
+(* (*   induction 1; econstructor; eauto. rewrite comp_env_preserved; auto. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma bind_parameters_preserved: *) *)
+(* (*   forall e m params args m', *) *)
+(* (*   Csem.bind_parameters ge e m params args m' -> *) *)
+(* (*   bind_parameters tge e m params args m'. *) *)
+(* (* Proof. *) *)
+(* (*   induction 1; econstructor; eauto. inv H0. *) *)
+(* (* - eapply assign_loc_value; eauto. *) *)
+(* (* - inv H4. eapply assign_loc_value; eauto. *) *)
+(* (* - rewrite <- comp_env_preserved in *. eapply assign_loc_copy; eauto. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma blocks_of_env_preserved: *) *)
+(* (*   forall e, blocks_of_env tge e = Csem.blocks_of_env ge e. *) *)
+(* (* Proof. *) *)
+(* (*   intros; unfold blocks_of_env, Csem.blocks_of_env. *) *)
+(* (*   unfold block_of_binding, Csem.block_of_binding. *) *)
+(* (*   rewrite comp_env_preserved. auto. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma sstep_simulation: *) *)
+(* (*   forall S1 t S2, Csem.sstep ge S1 t S2 -> *) *)
+(* (*   forall S1' (MS: match_states S1 S1'), *) *)
+(* (*   exists S2', *) *)
+(* (*      (plus step1 tge S1' t S2' \/ *) *)
+(* (*        (star step1 tge S1' t S2' /\ measure S2 < measure S1)%nat) *) *)
+(* (*   /\ match_states S2 S2'. *) *)
+(* (* Proof. *) *)
+(* (*   induction 1; intros; inv MS. *) *)
+(* (* (* do 1 *) *) *)
+(* (*   inv H6. inv H0. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   right; split. apply push_seq. *) *)
+(* (*   simpl. lia. *) *)
+(* (*   econstructor; eauto. constructor. auto. *) *)
+(* (* (* do 2 *) *) *)
+(* (*   inv H7. inv H6. inv H. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   right; split. apply star_refl. simpl. lia. *) *)
+(* (*   econstructor; eauto. constructor. *) *)
+
+(* (* (* seq *) *) *)
+(* (*   inv H6. econstructor; split. left. apply plus_one. constructor. *) *)
+(* (*   econstructor; eauto. constructor; auto. *) *)
+(* (* (* skip seq *) *) *)
+(* (*   inv H6; inv H7. econstructor; split. *) *)
+(* (*   left. apply plus_one; constructor. *) *)
+(* (*   econstructor; eauto. *) *)
+(* (* (* continue seq *) *) *)
+(* (*   inv H6; inv H7. econstructor; split. *) *)
+(* (*   left. apply plus_one; constructor. *) *)
+(* (*   econstructor; eauto. constructor. *) *)
+(* (* (* break seq *) *) *)
+(* (*   inv H6; inv H7. econstructor; split. *) *)
+(* (*   left. apply plus_one; constructor. *) *)
+(* (*   econstructor; eauto. constructor. *) *)
+(* (* (* ifthenelse *) *) *)
+(* (*   inv H6. *) *)
+(* (* (* ifthenelse empty *) *) *)
+(* (*   inv H3. econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. apply push_seq. *) *)
+(* (*   econstructor; eauto. *) *)
+(* (*   econstructor; eauto. *) *)
+(* (*   econstructor; eauto. *) *)
+(* (* (* ifthenelse non empty *) *) *)
+(* (*   inv H2. econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. apply push_seq. traceEq. *) *)
+(* (*   econstructor; eauto. econstructor; eauto. *) *)
+(* (* (* ifthenelse *) *) *)
+(* (*   inv H8. *) *)
+(* (* (* ifthenelse empty *) *) *)
+(* (*   exploit tr_top_val_for_val_inv; eauto. intros [A [B C]]. subst. *) *)
+(* (*   econstructor; split; simpl. *) *)
+(* (*   right. destruct b; econstructor; eauto. *) *)
+(* (*   eapply star_left. apply step_skip_seq. econstructor. traceEq. *) *)
+(* (*   eapply star_left. apply step_skip_seq. econstructor. traceEq. *) *)
+(* (*   destruct b; econstructor; eauto. econstructor; eauto. econstructor; eauto. *) *)
+(* (*   (* ifthenelse non empty *) *) *)
+(* (*   exploit tr_top_val_for_val_inv; eauto. intros [A [B C]]. subst. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_two. constructor. *) *)
+(* (*   apply step_ifthenelse with (v1 := v) (b := b); auto. traceEq. *) *)
+(* (*   destruct b; econstructor; eauto. *) *)
+(* (* (* while *) *) *)
+(* (*   inv H6. inv H1. econstructor; split. *) *)
+(* (*   left. eapply plus_left. constructor. *) *)
+(* (*   eapply star_left. constructor. *) *)
+(* (*   apply push_seq. *) *)
+(* (*   reflexivity. traceEq. rewrite Kseqlist_app. *) *)
+(* (*   econstructor; eauto. simpl.  econstructor; eauto. econstructor; eauto. *) *)
+(* (* (* while false *) *) *)
+(* (*   inv H8. *) *)
+(* (*   exploit tr_top_val_for_val_inv; eauto. intros [A [B C]]. subst. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. simpl. eapply plus_left. constructor. *) *)
+(* (*   eapply star_trans. apply step_makeif with (v1 := v) (b := false); auto. *) *)
+(* (*   eapply star_two. constructor. apply step_break_loop1. *) *)
+(* (*   reflexivity. reflexivity. traceEq. *) *)
+(* (*   constructor; auto. constructor. *) *)
+(* (* (* while true *) *) *)
+(* (*   inv H8. *) *)
+(* (*   exploit tr_top_val_for_val_inv; eauto. intros [A [B C]]. subst. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. simpl. eapply plus_left. constructor. *) *)
+(* (*   eapply star_right. apply step_makeif with (v1 := v) (b := true); auto. *) *)
+(* (*   constructor. *) *)
+(* (*   reflexivity. traceEq. *) *)
+(* (*   constructor; auto. constructor; auto. *) *)
+(* (* (* skip-or-continue while *) *) *)
+(* (*   assert (ts = Sskip \/ ts = Scontinue). destruct H; subst s0; inv H7; auto. *) *)
+(* (*   inv H8. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_two. apply step_skip_or_continue_loop1; auto. *) *)
+(* (*   apply step_skip_loop2. traceEq. *) *)
+(* (*   constructor; auto. constructor; auto. *) *)
+(* (* (* break while *) *) *)
+(* (*   inv H6. inv H7. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. apply plus_one. apply step_break_loop1. *) *)
+(* (*   constructor; auto. constructor. *) *)
+
+(* (* (* dowhile *) *) *)
+(* (*   inv H6. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. apply plus_one. apply step_loop. *) *)
+(* (*   constructor; auto. constructor; auto. *) *)
+(* (* (* skip_or_continue dowhile *) *) *)
+(* (*   assert (ts = Sskip \/ ts = Scontinue). destruct H; subst s0; inv H7; auto. *) *)
+(* (*   inv H8. inv H4. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. apply step_skip_or_continue_loop1. auto. *) *)
+(* (*   apply push_seq. *) *)
+(* (*   traceEq. *) *)
+(* (*   rewrite Kseqlist_app. *) *)
+(* (*   econstructor; eauto. simpl. econstructor; auto. econstructor; eauto. *) *)
+(* (* (* dowhile false *) *) *)
+(* (*   inv H8. *) *)
+(* (*   exploit tr_top_val_for_val_inv; eauto. intros [A [B C]]. subst. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. simpl. eapply plus_left. constructor. *) *)
+(* (*   eapply star_right. apply step_makeif with (v1 := v) (b := false); auto. *) *)
+(* (*   constructor. *) *)
+(* (*   reflexivity. traceEq. *) *)
+(* (*   constructor; auto. constructor. *) *)
+(* (* (* dowhile true *) *) *)
+(* (*   inv H8. *) *)
+(* (*   exploit tr_top_val_for_val_inv; eauto. intros [A [B C]]. subst. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. simpl. eapply plus_left. constructor. *) *)
+(* (*   eapply star_right. apply step_makeif with (v1 := v) (b := true); auto. *) *)
+(* (*   constructor. *) *)
+(* (*   reflexivity. traceEq. *) *)
+(* (*   constructor; auto. constructor; auto. *) *)
+(* (* (* break dowhile *) *) *)
+(* (*   inv H6. inv H7. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. apply plus_one. apply step_break_loop1. *) *)
+(* (*   constructor; auto. constructor. *) *)
+
+(* (* (* for start *) *) *)
+(* (*   inv H7. congruence. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left; apply plus_one. constructor. *) *)
+(* (*   econstructor; eauto. constructor; auto. econstructor; eauto. *) *)
+(* (* (* for *) *) *)
+(* (*   inv H6; try congruence. inv H2. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_left. apply step_loop. *) *)
+(* (*   eapply star_left. constructor. apply push_seq. *) *)
+(* (*   reflexivity. traceEq. *) *)
+(* (*   rewrite Kseqlist_app. econstructor; eauto. simpl. constructor; auto. econstructor; eauto. *) *)
+(* (* (* for false *) *) *)
+(* (*   inv H8. exploit tr_top_val_for_val_inv; eauto. intros [A [B C]]. subst. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. simpl. eapply plus_left. constructor. *) *)
+(* (*   eapply star_trans. apply step_makeif with (v1 := v) (b := false); auto. *) *)
+(* (*   eapply star_two. constructor. apply step_break_loop1. *) *)
+(* (*   reflexivity. reflexivity. traceEq. *) *)
+(* (*   constructor; auto. constructor. *) *)
+(* (* (* for true *) *) *)
+(* (*   inv H8. exploit tr_top_val_for_val_inv; eauto. intros [A [B C]]. subst. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. simpl. eapply plus_left. constructor. *) *)
+(* (*   eapply star_right. apply step_makeif with (v1 := v) (b := true); auto. *) *)
+(* (*   constructor. *) *)
+(* (*   reflexivity. traceEq. *) *)
+(* (*   constructor; auto. constructor; auto. *) *)
+(* (* (* skip_or_continue for3 *) *) *)
+(* (*   assert (ts = Sskip \/ ts = Scontinue). destruct H; subst x; inv H7; auto. *) *)
+(* (*   inv H8. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. apply plus_one. apply step_skip_or_continue_loop1. auto. *) *)
+(* (*   econstructor; eauto. econstructor; auto. *) *)
+(* (* (* break for3 *) *) *)
+(* (*   inv H6. inv H7. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. apply plus_one. apply step_break_loop1. *) *)
+(* (*   econstructor; eauto. constructor. *) *)
+(* (* (* skip for4 *) *) *)
+(* (*   inv H6. inv H7. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. apply plus_one. constructor. *) *)
+(* (*   econstructor; eauto. constructor; auto. *) *)
+
+
+(* (* (* return none *) *) *)
+(* (*   inv H7. econstructor; split. *) *)
+(* (*   left. apply plus_one. econstructor; eauto. rewrite blocks_of_env_preserved; eauto. *) *)
+(* (*   constructor. apply match_cont_call; auto. *) *)
+(* (* (* return some 1 *) *) *)
+(* (*   inv H6. inv H0. econstructor; split. *) *)
+(* (*   left; eapply plus_left. constructor. apply push_seq. traceEq. *) *)
+(* (*   econstructor; eauto. constructor. auto. *) *)
+(* (* (* return some 2 *) *) *)
+(* (*   inv H9. exploit tr_top_val_for_val_inv; eauto. intros [A [B C]]. subst. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. eapply plus_two. constructor. econstructor. eauto. *) *)
+(* (*   erewrite function_return_preserved; eauto. rewrite blocks_of_env_preserved; eauto. *) *)
+(* (*   eauto. traceEq. *) *)
+(* (*   constructor. apply match_cont_call; auto. *) *)
+(* (* (* skip return *) *) *)
+(* (*   inv H8. *) *)
+(* (*   assert (is_call_cont tk). inv H9; simpl in *; auto. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. apply plus_one. apply step_skip_call; eauto. rewrite blocks_of_env_preserved; eauto. *) *)
+(* (*   constructor. auto. *) *)
+
+(* (* (* switch *) *) *)
+(* (*   inv H6. inv H1. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left; eapply plus_left. constructor. apply push_seq. traceEq. *) *)
+(* (*   econstructor; eauto. constructor; auto. *) *)
+(* (* (* expr switch *) *) *)
+(* (*   inv H8. exploit tr_top_val_for_val_inv; eauto. intros [A [B C]]. subst. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left; eapply plus_two. constructor. econstructor; eauto. traceEq. *) *)
+(* (*   econstructor; eauto. *) *)
+(* (*   apply tr_seq_of_labeled_statement. apply tr_select_switch. auto. *) *)
+(* (*   constructor; auto. *) *)
+
+(* (* (* skip-or-break switch *) *) *)
+(* (*   assert (ts = Sskip \/ ts = Sbreak). destruct H; subst x; inv H7; auto. *) *)
+(* (*   inv H8. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left; apply plus_one. apply step_skip_break_switch. auto. *) *)
+(* (*   constructor; auto. constructor. *) *)
+
+(* (* (* continue switch *) *) *)
+(* (*   inv H6. inv H7. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left; apply plus_one. apply step_continue_switch. *) *)
+(* (*   constructor; auto. constructor. *) *)
+
+(* (* (* label *) *) *)
+(* (*   inv H6. econstructor; split. *) *)
+(* (*   left; apply plus_one. constructor. *) *)
+(* (*   constructor; auto. *) *)
+
+(* (* (* goto *) *) *)
+(* (*   inv H7. *) *)
+(* (*   inversion H6; subst. *) *)
+(* (*   exploit tr_find_label. eauto. apply match_cont_call. eauto. *) *)
+(* (*   instantiate (1 := lbl). rewrite H. *) *)
+(* (*   intros [ts' [tk' [P [Q R]]]]. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left. apply plus_one. econstructor; eauto. *) *)
+(* (*   econstructor; eauto. *) *)
+
+(* (* (* internal function *) *) *)
+(* (*   inv H7. inversion H3; subst. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left; apply plus_one. eapply step_internal_function. econstructor. *) *)
+(* (*   rewrite H6; rewrite H7; auto. *) *)
+(* (*   rewrite H6; rewrite H7. eapply alloc_variables_preserved; eauto. *) *)
+(* (*   rewrite H6. eapply bind_parameters_preserved; eauto. *) *)
+(* (*   eauto. *) *)
+(* (*   constructor; auto. *) *)
+
+(* (* (* external function *) *) *)
+(* (*   inv H5. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left; apply plus_one. econstructor; eauto. *) *)
+(* (*   eapply external_call_symbols_preserved; eauto. apply senv_preserved. *) *)
+(* (*   constructor; auto. *) *)
+
+(* (* (* return *) *) *)
+(* (*   inv H3. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   left; apply plus_one. constructor. *) *)
+(* (*   econstructor; eauto. *) *)
+
+(* (* Qed. *) *)
+
+(* (** Semantic preservation *) *)
+
+(* (* Theorem simulation: *) *)
+(* (*   forall S1 t S2, Cstrategy.step ge S1 t S2 -> *) *)
+(* (*   forall S1' (MS: match_states S1 S1'), *) *)
+(* (*   exists S2', *) *)
+(* (*      (plus step1 tge S1' t S2' \/ *) *)
+(* (*        (star step1 tge S1' t S2' /\ measure S2 < measure S1)%nat) *) *)
+(* (*   /\ match_states S2 S2'. *) *)
+(* (* Proof. *) *)
+(* (*   intros S1 t S2 STEP. destruct STEP. *) *)
+(* (*   apply estep_simulation; auto. *) *)
+(* (*   apply sstep_simulation; auto. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma transl_initial_states: *) *)
+(* (*   forall S, *) *)
+(* (*   Csem.initial_state prog S -> *) *)
+(* (*   exists S', Clight.initial_state tprog S' /\ match_states S S'. *) *)
+(* (* Proof. *) *)
+(* (*   intros. inv H. *) *)
+(* (*   exploit function_ptr_translated; eauto. intros [tf [FIND TR]]. *) *)
+(* (*   econstructor; split. *) *)
+(* (*   econstructor. *) *)
+(* (*   eapply (Genv.init_mem_match (proj1 TRANSL)); eauto. *) *)
+(* (*   replace (prog_main tprog) with (prog_main prog). *) *)
+(* (*   rewrite symbols_preserved. eauto.  *) *)
+(* (*   destruct TRANSL. destruct H as (A & B & C). simpl in B. auto.  *) *)
+(* (*   eexact FIND. *) *)
+(* (*   rewrite <- H3. apply type_of_fundef_preserved. auto. *) *)
+(* (*   constructor. auto. constructor. *) *)
+(* (* Qed. *) *)
+
+(* (* Lemma transl_final_states: *) *)
+(* (*   forall S S' r, *) *)
+(* (*   match_states S S' -> Csem.final_state S r -> Clight.final_state S' r. *) *)
+(* (* Proof. *) *)
+(* (*   intros. inv H0. inv H. inv H4. constructor. *) *)
+(* (* Qed. *) *)
+
+(* Theorem transl_program_correct: *)
+(*   forward_simulation (Cstrategy.semantics prog) (Clight.semantics1 tprog). *)
+(* Proof. *)
+(*   (* eapply forward_simulation_star_wf with (order := ltof _ measure). *) *)
+(*   (* eapply senv_preserved. *) *)
+(*   (* eexact transl_initial_states. *) *)
+(*   (* eexact transl_final_states. *) *)
+(*   (* apply well_founded_ltof. *) *)
+(*   (* exact simulation. *) *)
+
+(* Qed. *)
+
+(* End PRESERVATION. *)
 
 (** ** Commutation with linking *)
 
diff --git a/cfrontend/SimplExprspec.v b/cfrontend/SimplExprspec.v
index 98425311..86457183 100644
--- a/cfrontend/SimplExprspec.v
+++ b/cfrontend/SimplExprspec.v
@@ -24,14 +24,14 @@ Local Open Scope gensym_monad_scope.
 
 (** ** Translation of expressions *)
 
-(** This specification covers:
-- all cases of [transl_lvalue] and [transl_rvalue];
-- two additional cases for [Csyntax.Eparen], so that reductions of [Csyntax.Econdition]
-  expressions are properly tracked;
-- three additional cases allowing [Csyntax.Eval v] C expressions to match
-  any Clight expression [a] that evaluates to [v] in any environment
-  matching the given temporary environment [le].
-*)
+(** This specification covers: *)
+(* - all cases of [transl_lvalue] and [transl_rvalue]; *)
+(* - two additional cases for [Csyntax.Eparen], so that reductions of [Csyntax.Econdition] *)
+(*   expressions are properly tracked; *)
+(* - three additional cases allowing [Csyntax.Eval v] C expressions to match *)
+(*   any Clight expression [a] that evaluates to [v] in any environment *)
+(*   matching the given temporary environment [le]. *)
+(* *)
 
 Definition final (dst: destination) (a: expr) : list statement :=
   match dst with
@@ -366,12 +366,12 @@ Qed.
 
 (** ** Top-level translation *)
 
-(** The "top-level" translation is equivalent to [tr_expr] above
-  for source terms.  It brings additional flexibility in the matching
-  between Csyntax values and Cminor expressions: in the case of
-  [tr_expr], the Cminor expression must not depend on memory,
-  while in the case of [tr_top] it can depend on the current memory
-  state. *)
+(** The "top-level" translation is equivalent to [tr_expr] above *)
+(*   for source terms.  It brings additional flexibility in the matching *)
+(*   between Csyntax values and Cminor expressions: in the case of *)
+(*   [tr_expr], the Cminor expression must not depend on memory, *)
+(*   while in the case of [tr_top] it can depend on the current memory *)
+(*   state. *)
 
 Section TR_TOP.
 
@@ -407,72 +407,76 @@ Inductive tr_if: Csyntax.expr -> statement -> statement -> statement -> Prop :=
       (forall ge e le m, tr_top ge e le m For_val r sl a tmps) ->
       tr_if r s1 s2 (makeseq (sl ++ makeif a s1 s2 :: nil)).
 
-Inductive tr_stmt: Csyntax.statement -> statement -> Prop :=
-  | tr_skip:
-      tr_stmt Csyntax.Sskip Sskip
-  | tr_do: forall r s,
+Inductive tr_stmt: Csyntax.statement -> type -> statement -> Prop :=
+  | tr_skip: forall ty,
+      tr_stmt Csyntax.Sskip ty Sskip
+  | tr_do: forall r s ty,
       tr_expr_stmt r s ->
-      tr_stmt (Csyntax.Sdo r) s
-  | tr_seq: forall s1 s2 ts1 ts2,
-      tr_stmt s1 ts1 -> tr_stmt s2 ts2 ->
-      tr_stmt (Csyntax.Ssequence s1 s2) (Ssequence ts1 ts2)
-  | tr_ifthenelse_empty: forall r s' a,
+      tr_stmt (Csyntax.Sdo r) ty s
+  | tr_seq: forall s1 s2 ts1 ts2 ty,
+      tr_stmt s1 ty ts1 -> tr_stmt s2 ty ts2 ->
+      tr_stmt (Csyntax.Ssequence s1 s2) ty (Ssequence ts1 ts2)
+  | tr_ifthenelse_empty: forall r s' a ty,
       tr_expression r s' a ->
-      tr_stmt (Csyntax.Sifthenelse r Csyntax.Sskip Csyntax.Sskip) (Ssequence s' Sskip)
-  | tr_ifthenelse: forall r s1 s2 s' a ts1 ts2,
+      tr_stmt (Csyntax.Sifthenelse r Csyntax.Sskip Csyntax.Sskip) ty (Ssequence s' Sskip)
+  | tr_ifthenelse: forall r s1 s2 s' a ts1 ts2 ty,
       tr_expression r s' a ->
-      tr_stmt s1 ts1 -> tr_stmt s2 ts2 ->
-      tr_stmt (Csyntax.Sifthenelse r s1 s2) (Ssequence s' (Sifthenelse a ts1 ts2))
-  | tr_while: forall r s1 s' ts1,
+      tr_stmt s1 ty ts1 -> tr_stmt s2 ty ts2 ->
+      tr_stmt (Csyntax.Sifthenelse r s1 s2) ty (Ssequence s' (Sifthenelse a ts1 ts2))
+  | tr_while: forall r s1 s' ts1 ty,
       tr_if r Sskip Sbreak s' ->
-      tr_stmt s1 ts1 ->
+      tr_stmt s1 ty ts1 ->
       tr_stmt (Csyntax.Swhile r s1)
+              ty
               (Sloop (Ssequence s' ts1) Sskip)
-  | tr_dowhile: forall r s1 s' ts1,
+  | tr_dowhile: forall r s1 s' ts1 ty,
       tr_if r Sskip Sbreak s' ->
-      tr_stmt s1 ts1 ->
+      tr_stmt s1 ty ts1 ->
       tr_stmt (Csyntax.Sdowhile r s1)
+              ty
               (Sloop ts1 s')
-  | tr_for_1: forall r s3 s4 s' ts3 ts4,
+  | tr_for_1: forall r s3 s4 s' ts3 ts4 ty,
       tr_if r Sskip Sbreak s' ->
-      tr_stmt s3 ts3 ->
-      tr_stmt s4 ts4 ->
+      tr_stmt s3 ty ts3 ->
+      tr_stmt s4 ty ts4 ->
       tr_stmt (Csyntax.Sfor Csyntax.Sskip r s3 s4)
+              ty
               (Sloop (Ssequence s' ts4) ts3)
-  | tr_for_2: forall s1 r s3 s4 s' ts1 ts3 ts4,
+  | tr_for_2: forall s1 r s3 s4 s' ts1 ts3 ts4 ty,
       tr_if r Sskip Sbreak s' ->
       s1 <> Csyntax.Sskip ->
-      tr_stmt s1 ts1 ->
-      tr_stmt s3 ts3 ->
-      tr_stmt s4 ts4 ->
+      tr_stmt s1 ty ts1 ->
+      tr_stmt s3 ty ts3 ->
+      tr_stmt s4 ty ts4 ->
       tr_stmt (Csyntax.Sfor s1 r s3 s4)
+              ty
               (Ssequence ts1 (Sloop (Ssequence s' ts4) ts3))
-  | tr_break:
-      tr_stmt Csyntax.Sbreak Sbreak
-  | tr_continue:
-      tr_stmt Csyntax.Scontinue Scontinue
-  | tr_return_none:
-      tr_stmt (Csyntax.Sreturn None) (Sreturn None)
-  | tr_return_some: forall r s' a,
+  | tr_break: forall ty,
+      tr_stmt Csyntax.Sbreak ty Sbreak
+  | tr_continue: forall ty,
+      tr_stmt Csyntax.Scontinue ty Scontinue
+  | tr_return_none: forall ty,
+      tr_stmt (Csyntax.Sreturn None) ty (Sreturn None)
+  | tr_return_some: forall r s' a ty,
       tr_expression r s' a ->
-      tr_stmt (Csyntax.Sreturn (Some r)) (Ssequence s' (Sreturn (Some a)))
-  | tr_switch: forall r ls s' a tls,
+      tr_stmt (Csyntax.Sreturn (Some r)) ty (Ssequence s' (Sreturn (Some a)))
+  | tr_switch: forall r ls s' a tls ty,
       tr_expression r s' a ->
-      tr_lblstmts ls tls ->
-      tr_stmt (Csyntax.Sswitch r ls) (Ssequence s' (Sswitch a tls))
-  | tr_label: forall lbl s ts,
-      tr_stmt s ts ->
-      tr_stmt (Csyntax.Slabel lbl s) (Slabel lbl ts)
-  | tr_goto: forall lbl,
-      tr_stmt (Csyntax.Sgoto lbl) (Sgoto lbl)
-
-with tr_lblstmts: Csyntax.labeled_statements -> labeled_statements -> Prop :=
-  | tr_ls_nil:
-      tr_lblstmts Csyntax.LSnil LSnil
-  | tr_ls_cons: forall c s ls ts tls,
-      tr_stmt s ts ->
-      tr_lblstmts ls tls ->
-      tr_lblstmts (Csyntax.LScons c s ls) (LScons c ts tls).
+      tr_lblstmts ls ty tls ->
+      tr_stmt (Csyntax.Sswitch r ls) ty (Ssequence s' (Sswitch a tls))
+  | tr_label: forall lbl s ts ty,
+      tr_stmt s ty ts ->
+      tr_stmt (Csyntax.Slabel lbl s) ty (Slabel lbl ts)
+  | tr_goto: forall lbl ty,
+      tr_stmt (Csyntax.Sgoto lbl) ty (Sgoto lbl)
+
+with tr_lblstmts: Csyntax.labeled_statements -> type -> labeled_statements -> Prop :=
+  | tr_ls_nil: forall ty,
+      tr_lblstmts Csyntax.LSnil ty LSnil
+  | tr_ls_cons: forall c s ls ts tls ty,
+      tr_stmt s ty ts ->
+      tr_lblstmts ls ty tls ->
+      tr_lblstmts (Csyntax.LScons c s ls) ty (LScons c ts tls).
 
 (** * Correctness proof with respect to the specification. *)
 
@@ -718,13 +722,13 @@ Ltac UseFinish :=
       repeat rewrite app_ass
   end.
 
-(*
-Fixpoint add_set_dest (sd: set_destination) (tmps: list ident) :=
-  match sd with
-  | SDbase ty tmp => tmp :: tmps
-  | SDcons ty tmp sd' => tmp :: add_set_dest sd' tmps
-  end.
-*)
+(* *)
+(* Fixpoint add_set_dest (sd: set_destination) (tmps: list ident) := *)
+(*   match sd with *)
+(*   | SDbase ty tmp => tmp :: tmps *)
+(*   | SDcons ty tmp sd' => tmp :: add_set_dest sd' tmps *)
+(*   end. *)
+(* *)
 
 Definition add_dest (dst: destination) (tmps: list ident) :=
   match dst with
@@ -761,338 +765,340 @@ Scheme expr_ind2 := Induction for Csyntax.expr Sort Prop
   with exprlist_ind2 := Induction for Csyntax.exprlist Sort Prop.
 Combined Scheme expr_exprlist_ind from expr_ind2, exprlist_ind2.
 
-Lemma transl_meets_spec:
-   (forall r dst g sl a g' I,
-    transl_expr dst r g = Res (sl, a) g' I ->
-    dest_below dst g ->
-    exists tmps, (forall le, tr_expr le dst r sl a (add_dest dst tmps)) /\ contained tmps g g')
-  /\
-   (forall rl g sl al g' I,
-    transl_exprlist rl g = Res (sl, al) g' I ->
-    exists tmps, (forall le, tr_exprlist le rl sl al tmps) /\ contained tmps g g').
-Proof.
-  apply expr_exprlist_ind; simpl add_dest; intros.
-- (* val *)
-  simpl in H. destruct v; monadInv H; exists (@nil ident); split; auto with gensym.
-Opaque makeif.
-+ intros. destruct dst; simpl in *; inv H2.
-    constructor. auto. intros; constructor.
-    constructor.
-    constructor. auto. intros; constructor.
-+ intros. destruct dst; simpl in *; inv H2.
-    constructor. auto. intros; constructor.
-    constructor.
-    constructor. auto. intros; constructor.
-+ intros. destruct dst; simpl in *; inv H2.
-    constructor. auto. intros; constructor.
-    constructor.
-    constructor. auto. intros; constructor.
-+ intros. destruct dst; simpl in *; inv H2.
-    constructor. auto. intros; constructor.
-    constructor.
-    constructor. auto. intros; constructor.
-- (* var *)
-  monadInv H; econstructor; split; auto with gensym. UseFinish. constructor.
-- (* field *)
-  monadInv H0. exploit H; eauto. auto. intros [tmp [A B]]. UseFinish.
-  econstructor; split; eauto. intros; apply tr_expr_add_dest. constructor; auto.
-- (* valof *)
-  monadInv H0. exploit H; eauto. intros [tmp1 [A B]].
-  exploit transl_valof_meets_spec; eauto. intros [tmp2 [Csyntax D]]. UseFinish.
-  exists (tmp1 ++ tmp2); split.
-  intros; apply tr_expr_add_dest. econstructor; eauto with gensym.
-  eauto with gensym.
-- (* deref *)
-  monadInv H0. exploit H; eauto. intros [tmp [A B]]. UseFinish.
-  econstructor; split; eauto. intros; apply tr_expr_add_dest. constructor; auto.
-- (* addrof *)
-  monadInv H0. exploit H; eauto. intros [tmp [A B]]. UseFinish.
-  econstructor; split; eauto. intros; apply tr_expr_add_dest. econstructor; eauto.
-- (* unop *)
-  monadInv H0. exploit H; eauto. intros [tmp [A B]]. UseFinish.
-  econstructor; split; eauto. intros; apply tr_expr_add_dest. constructor; auto.
-- (* binop *)
-  monadInv H1. exploit H; eauto. intros [tmp1 [A B]].
-  exploit H0; eauto. intros [tmp2 [Csyntax D]]. UseFinish.
-  exists (tmp1 ++ tmp2); split.
-  intros; apply tr_expr_add_dest. econstructor; eauto with gensym.
-  eauto with gensym.
-- (* cast *)
-  destruct dst.
-+ (* for value *)
-  monadInv H0. exploit H; eauto. intros [tmp [A B]].
-  econstructor; split; eauto. intros; apply tr_expr_add_dest.
-  rewrite (app_nil_end sl).
-  apply tr_cast_val with (dst := For_val); auto.
-+ (* for effects *)
-  exploit H; eauto. intros [tmp [A B]].
-  econstructor; split; eauto. intros; eapply tr_cast_effects; eauto.
-+ (* for set *)
-  monadInv H0. exploit H; eauto. intros [tmp [A B]].
-  econstructor; split; eauto. intros; apply tr_expr_add_dest.
-  apply tr_cast_val with (dst := For_set sd); auto.
-- (* seqand *)
-  monadInv H1. exploit H; eauto. intros [tmp1 [A B]].
-  destruct dst; monadInv EQ0.
-+ (* for value *)
-  exploit H0; eauto with gensym. intros [tmp2 [C D]].
-  simpl add_dest in *.
-  exists (x0 :: tmp1 ++ tmp2); split.
-  intros; eapply tr_seqand_val; eauto with gensym.
-  apply list_disjoint_cons_r; eauto with gensym.
-  apply contained_cons. eauto with gensym.
-  apply contained_app; eauto with gensym.
-+ (* for effects *)
-  exploit H0; eauto with gensym. intros [tmp2 [Csyntax D]].
-  simpl add_dest in *.
-  exists (tmp1 ++ tmp2); split.
-  intros; eapply tr_seqand_effects; eauto with gensym.
-  apply contained_app; eauto with gensym.
-+ (* for set *)
-  exploit H0; eauto with gensym. intros [tmp2 [C D]].
-  simpl add_dest in *.
-  exists (tmp1 ++ tmp2); split.
-  intros; eapply tr_seqand_set; eauto with gensym.
-  apply list_disjoint_cons_r; eauto with gensym.
-  apply contained_app; eauto with gensym.
-- (* seqor *)
-  monadInv H1. exploit H; eauto. intros [tmp1 [A B]].
-  destruct dst; monadInv EQ0.
-+ (* for value *)
-  exploit H0; eauto with gensym. intros [tmp2 [Csyntax D]].
-  simpl add_dest in *.
-  exists (x0 :: tmp1 ++ tmp2); split.
-  intros; eapply tr_seqor_val; eauto with gensym.
-  apply list_disjoint_cons_r; eauto with gensym.
-  apply contained_cons. eauto with gensym.
-  apply contained_app; eauto with gensym.
-+ (* for effects *)
-  exploit H0; eauto with gensym. intros [tmp2 [C D]].
-  simpl add_dest in *.
-  exists (tmp1 ++ tmp2); split.
-  intros; eapply tr_seqor_effects; eauto with gensym.
-  apply contained_app; eauto with gensym.
-+ (* for set *)
-  exploit H0; eauto with gensym. intros [tmp2 [C D]].
-  simpl add_dest in *.
-  exists (tmp1 ++ tmp2); split.
-  intros; eapply tr_seqor_set; eauto with gensym.
-  apply list_disjoint_cons_r; eauto with gensym.
-  apply contained_app; eauto with gensym.
-- (* condition *)
-  monadInv H2. exploit H; eauto. intros [tmp1 [A B]].
-  destruct dst; monadInv EQ0.
-+ (* for value *)
-  exploit H0; eauto with gensym. intros [tmp2 [C D]].
-  exploit H1; eauto with gensym. intros [tmp3 [E F]].
-  simpl add_dest in *.
-  exists (x0 :: tmp1 ++ tmp2 ++ tmp3); split.
-  simpl; intros; eapply tr_condition_val; eauto with gensym.
-  apply list_disjoint_cons_r; eauto with gensym.
-  apply list_disjoint_cons_r; eauto with gensym.
-  apply contained_cons. eauto with gensym.
-  apply contained_app. eauto with gensym.
-  apply contained_app; eauto with gensym.
-+ (* for effects *)
-  exploit H0; eauto. intros [tmp2 [Csyntax D]].
-  exploit H1; eauto. intros [tmp3 [E F]].
-  simpl add_dest in *.
-  exists (tmp1 ++ tmp2 ++ tmp3); split.
-  intros; eapply tr_condition_effects; eauto with gensym.
-  apply contained_app; eauto with gensym.
-+ (* for test *)
-  exploit H0; eauto with gensym. intros [tmp2 [C D]].
-  exploit H1; eauto 10 with gensym. intros [tmp3 [E F]].
-  simpl add_dest in *.
-  exists (x0 :: tmp1 ++ tmp2 ++ tmp3); split.
-  intros; eapply tr_condition_set; eauto with gensym.
-  apply list_disjoint_cons_r; eauto with gensym.
-  apply list_disjoint_cons_r; eauto with gensym.
-  apply contained_cons; eauto with gensym.
-  apply contained_app; eauto with gensym.
-  apply contained_app; eauto with gensym.
-- (* sizeof *)
-  monadInv H. UseFinish.
-  exists (@nil ident); split; auto with gensym. constructor.
-- (* alignof *)
-  monadInv H. UseFinish.
-  exists (@nil ident); split; auto with gensym. constructor.
-- (* assign *)
-  monadInv H1. exploit H; eauto. intros [tmp1 [A B]].
-  exploit H0; eauto. intros [tmp2 [Csyntax D]].
-  destruct dst; monadInv EQ2; simpl add_dest in *.
-+ (* for value *)
-  exists (x1 :: tmp1 ++ tmp2); split.
-  intros. eapply tr_assign_val with (dst := For_val); eauto with gensym.
-  apply contained_cons. eauto with gensym.
-  apply contained_app; eauto with gensym.
-+ (* for effects *)
-  exists (tmp1 ++ tmp2); split.
-  econstructor; eauto with gensym.
-  apply contained_app; eauto with gensym.
-+ (* for set *)
-  exists (x1 :: tmp1 ++ tmp2); split.
-  repeat rewrite app_ass. simpl.
-  intros. eapply tr_assign_val with (dst := For_set sd); eauto with gensym.
-  apply contained_cons. eauto with gensym.
-  apply contained_app; eauto with gensym.
-- (* assignop *)
-  monadInv H1. exploit H; eauto. intros [tmp1 [A B]].
-  exploit H0; eauto. intros [tmp2 [Csyntax D]].
-  exploit transl_valof_meets_spec; eauto. intros [tmp3 [E F]].
-  destruct dst; monadInv EQ3; simpl add_dest in *.
-+ (* for value *)
-  exists (x2 :: tmp1 ++ tmp2 ++ tmp3); split.
-  intros. eapply tr_assignop_val with (dst := For_val); eauto with gensym.
-  apply contained_cons. eauto with gensym.
-  apply contained_app; eauto with gensym.
-+ (* for effects *)
-  exists (tmp1 ++ tmp2 ++ tmp3); split.
-  econstructor; eauto with gensym.
-  apply contained_app; eauto with gensym.
-+ (* for set *)
-  exists (x2 :: tmp1 ++ tmp2 ++ tmp3); split.
-  repeat rewrite app_ass. simpl.
-  intros. eapply tr_assignop_val with (dst := For_set sd); eauto with gensym.
-  apply contained_cons. eauto with gensym.
-  apply contained_app; eauto with gensym.
-- (* postincr *)
-  monadInv H0. exploit H; eauto. intros [tmp1 [A B]].
-  destruct dst; monadInv EQ0; simpl add_dest in *.
-+ (* for value *)
-  exists (x0 :: tmp1); split.
-  econstructor; eauto with gensym.
-  apply contained_cons; eauto with gensym.
-+ (* for effects *)
-  exploit transl_valof_meets_spec; eauto. intros [tmp2 [Csyntax D]].
-  exists (tmp1 ++ tmp2); split.
-  econstructor; eauto with gensym.
-  eauto with gensym.
-+ (* for set *)
-  repeat rewrite app_ass; simpl.
-  exists (x0 :: tmp1); split.
-  econstructor; eauto with gensym.
-  apply contained_cons; eauto with gensym.
-- (* comma *)
-  monadInv H1. exploit H; eauto. intros [tmp1 [A B]].
-  exploit H0; eauto with gensym. intros [tmp2 [Csyntax D]].
-  exists (tmp1 ++ tmp2); split.
-  econstructor; eauto with gensym.
-  destruct dst; simpl; eauto with gensym.
-  apply list_disjoint_cons_r; eauto with gensym.
-  simpl. eapply incl_tran. 2: apply add_dest_incl. auto with gensym.
-  destruct dst; simpl; auto with gensym.
-  apply contained_app; eauto with gensym.
-- (* call *)
-  monadInv H1. exploit H; eauto. intros [tmp1 [A B]].
-  exploit H0; eauto. intros [tmp2 [Csyntax D]].
-  destruct dst; monadInv EQ2; simpl add_dest in *.
-+ (* for value *)
-  exists (x1 :: tmp1 ++ tmp2); split.
-  econstructor; eauto with gensym. congruence.
-  apply contained_cons. eauto with gensym.
-  apply contained_app; eauto with gensym.
-+ (* for effects *)
-  exists (tmp1 ++ tmp2); split.
-  econstructor; eauto with gensym.
-  apply contained_app; eauto with gensym.
-+ (* for set *)
-  exists (x1 :: tmp1 ++ tmp2); split.
-  repeat rewrite app_ass. econstructor; eauto with gensym. congruence.
-  apply contained_cons. eauto with gensym.
-  apply contained_app; eauto with gensym.
-- (* builtin *)
-  monadInv H0. exploit H; eauto. intros [tmp1 [A B]].
-  destruct dst; monadInv EQ0; simpl add_dest in *.
-+ (* for value *)
-  exists (x0 :: tmp1); split.
-  econstructor; eauto with gensym. congruence.
-  apply contained_cons; eauto with gensym.
-+ (* for effects *)
-  exists tmp1; split.
-  econstructor; eauto with gensym.
-  auto.
-+ (* for set *)
-  exists (x0 :: tmp1); split.
-  repeat rewrite app_ass. econstructor; eauto with gensym. congruence.
-  apply contained_cons; eauto with gensym.
-- (* loc *)
-  monadInv H.
-- (* paren *)
-  monadInv H0.
-- (* nil *)
-  monadInv H; exists (@nil ident); split; auto with gensym. constructor.
-- (* cons *)
-  monadInv H1. exploit H; eauto. intros [tmp1 [A B]].
-  exploit H0; eauto. intros [tmp2 [Csyntax D]].
-  exists (tmp1 ++ tmp2); split.
-  econstructor; eauto with gensym.
-  eauto with gensym.
-Qed.
-
-Lemma transl_expr_meets_spec:
-   forall r dst g sl a g' I,
-   transl_expr dst r g = Res (sl, a) g' I ->
-   dest_below dst g ->
-   exists tmps, forall ge e le m, tr_top ge e le m dst r sl a tmps.
-Proof.
-  intros. exploit (proj1 transl_meets_spec); eauto. intros [tmps [A B]].
-  exists (add_dest dst tmps); intros. apply tr_top_base. auto.
-Qed.
-
-Lemma transl_expression_meets_spec:
-  forall r g s a g' I,
-  transl_expression r g = Res (s, a) g' I ->
-  tr_expression r s a.
-Proof.
-  intros. monadInv H. exploit transl_expr_meets_spec; eauto.
-  intros [tmps A]. econstructor; eauto.
-Qed.
-
-Lemma transl_expr_stmt_meets_spec:
-  forall r g s g' I,
-  transl_expr_stmt r g = Res s g' I ->
-  tr_expr_stmt r s.
-Proof.
-  intros. monadInv H. exploit transl_expr_meets_spec; eauto.
-  intros [tmps A]. econstructor; eauto.
-Qed.
-
-Lemma transl_if_meets_spec:
-  forall r s1 s2 g s g' I,
-  transl_if r s1 s2 g = Res s g' I ->
-  tr_if r s1 s2 s.
-Proof.
-  intros. monadInv H. exploit transl_expr_meets_spec; eauto.
-  intros [tmps A]. econstructor; eauto.
-Qed.
+(* Lemma transl_meets_spec: *)
+(*    (forall r dst g sl a g' I, *)
+(*     transl_expr dst r g = Res (sl, a) g' I -> *)
+(*     dest_below dst g -> *)
+(*     exists tmps, (forall le, tr_expr le dst r sl a (add_dest dst tmps)) /\ contained tmps g g') *)
+(*   /\ *)
+(*    (forall rl g sl al g' I, *)
+(*     transl_exprlist rl g = Res (sl, al) g' I -> *)
+(*     exists tmps, (forall le, tr_exprlist le rl sl al tmps) /\ contained tmps g g'). *)
+(* Proof. *)
+(*   apply expr_exprlist_ind; simpl add_dest; intros. *)
+(* - (* val *) *)
+(*   simpl in H. destruct v; monadInv H; exists (@nil ident); split; auto with gensym. *)
+(* Opaque makeif. *)
+(* + intros. destruct dst; simpl in *; inv H2. *)
+(*     constructor. auto. intros; constructor. *)
+(*     constructor. *)
+(*     constructor. auto. intros; constructor. *)
+(* + intros. destruct dst; simpl in *; inv H2. *)
+(*     constructor. auto. intros; constructor. *)
+(*     constructor. *)
+(*     constructor. auto. intros; constructor. *)
+(* + intros. destruct dst; simpl in *; inv H2. *)
+(*     constructor. auto. intros; constructor. *)
+(*     constructor. *)
+(*     constructor. auto. intros; constructor. *)
+(* + intros. destruct dst; simpl in *; inv H2. *)
+(*     constructor. auto. intros; constructor. *)
+(*     constructor. *)
+(*     constructor. auto. intros; constructor. *)
+(* - (* var *) *)
+(*   monadInv H; econstructor; split; auto with gensym. UseFinish. constructor. *)
+(* - (* field *) *)
+(*   monadInv H0. exploit H; eauto. auto. intros [tmp [A B]]. UseFinish. *)
+(*   econstructor; split; eauto. intros; apply tr_expr_add_dest. constructor; auto. *)
+(* - (* valof *) *)
+(*   monadInv H0. exploit H; eauto. intros [tmp1 [A B]]. *)
+(*   exploit transl_valof_meets_spec; eauto. intros [tmp2 [Csyntax D]]. UseFinish. *)
+(*   exists (tmp1 ++ tmp2); split. *)
+(*   intros; apply tr_expr_add_dest. econstructor; eauto with gensym. *)
+(*   eauto with gensym. *)
+(* - (* deref *) *)
+(*   monadInv H0. exploit H; eauto. intros [tmp [A B]]. UseFinish. *)
+(*   econstructor; split; eauto. intros; apply tr_expr_add_dest. constructor; auto. *)
+(* - (* addrof *) *)
+(*   monadInv H0. exploit H; eauto. intros [tmp [A B]]. UseFinish. *)
+(*   econstructor; split; eauto. intros; apply tr_expr_add_dest. econstructor; eauto. *)
+(* - (* unop *) *)
+(*   monadInv H0. exploit H; eauto. intros [tmp [A B]]. UseFinish. *)
+(*   econstructor; split; eauto. intros; apply tr_expr_add_dest. constructor; auto. *)
+(* - (* binop *) *)
+(*   monadInv H1. exploit H; eauto. intros [tmp1 [A B]]. *)
+(*   exploit H0; eauto. intros [tmp2 [Csyntax D]]. UseFinish. *)
+(*   exists (tmp1 ++ tmp2); split. *)
+(*   intros; apply tr_expr_add_dest. econstructor; eauto with gensym. *)
+(*   eauto with gensym. *)
+(* - (* cast *) *)
+(* (*   destruct dst. *) *)
+(* (* + (* for value *) *) *)
+(* (*   monadInv H0. exploit H; eauto. intros [tmp [A B]]. *) *)
+(* (*   econstructor; split; eauto. intros; apply tr_expr_add_dest. *) *)
+(* (*   rewrite (app_nil_end sl). *) *)
+(* (*   apply tr_cast_val with (dst := For_val); auto. *) *)
+(* (* + (* for effects *) *) *)
+(* (*   exploit H; eauto. intros [tmp [A B]]. *) *)
+(* (*   econstructor; split; eauto. intros; eapply tr_cast_effects; eauto. *) *)
+(* (* + (* for set *) *) *)
+(* (*   monadInv H0. exploit H; eauto. intros [tmp [A B]]. *) *)
+(* (*   econstructor; split; eauto. intros; apply tr_expr_add_dest. *) *)
+(* (*   apply tr_cast_val with (dst := For_set sd); auto. *) *)
+(* - (* seqand *) *)
+(*   monadInv H1. exploit H; eauto. intros [tmp1 [A B]]. *)
+(*   destruct dst; monadInv EQ0. *)
+(* + (* for value *) *)
+(*   exploit H0; eauto with gensym. intros [tmp2 [C D]]. *)
+(*   simpl add_dest in *. *)
+(*   exists (x0 :: tmp1 ++ tmp2); split. *)
+(*   intros; eapply tr_seqand_val; eauto with gensym. *)
+(*   apply list_disjoint_cons_r; eauto with gensym. *)
+(*   apply contained_cons. eauto with gensym. *)
+(*   apply contained_app; eauto with gensym. *)
+(* + (* for effects *) *)
+(*   exploit H0; eauto with gensym. intros [tmp2 [Csyntax D]]. *)
+(*   simpl add_dest in *. *)
+(*   exists (tmp1 ++ tmp2); split. *)
+(*   intros; eapply tr_seqand_effects; eauto with gensym. *)
+(*   apply contained_app; eauto with gensym. *)
+(* + (* for set *) *)
+(*   exploit H0; eauto with gensym. intros [tmp2 [C D]]. *)
+(*   simpl add_dest in *. *)
+(*   exists (tmp1 ++ tmp2); split. *)
+(*   intros; eapply tr_seqand_set; eauto with gensym. *)
+(*   apply list_disjoint_cons_r; eauto with gensym. *)
+(*   apply contained_app; eauto with gensym. *)
+(* - (* seqor *) *)
+(*   monadInv H1. exploit H; eauto. intros [tmp1 [A B]]. *)
+(*   destruct dst; monadInv EQ0. *)
+(* + (* for value *) *)
+(*   exploit H0; eauto with gensym. intros [tmp2 [Csyntax D]]. *)
+(*   simpl add_dest in *. *)
+(*   exists (x0 :: tmp1 ++ tmp2); split. *)
+(*   intros; eapply tr_seqor_val; eauto with gensym. *)
+(*   apply list_disjoint_cons_r; eauto with gensym. *)
+(*   apply contained_cons. eauto with gensym. *)
+(*   apply contained_app; eauto with gensym. *)
+(* + (* for effects *) *)
+(*   exploit H0; eauto with gensym. intros [tmp2 [C D]]. *)
+(*   simpl add_dest in *. *)
+(*   exists (tmp1 ++ tmp2); split. *)
+(*   intros; eapply tr_seqor_effects; eauto with gensym. *)
+(*   apply contained_app; eauto with gensym. *)
+(* + (* for set *) *)
+(*   exploit H0; eauto with gensym. intros [tmp2 [C D]]. *)
+(*   simpl add_dest in *. *)
+(*   exists (tmp1 ++ tmp2); split. *)
+(*   intros; eapply tr_seqor_set; eauto with gensym. *)
+(*   apply list_disjoint_cons_r; eauto with gensym. *)
+(*   apply contained_app; eauto with gensym. *)
+(* - (* condition *) *)
+(*   monadInv H2. exploit H; eauto. intros [tmp1 [A B]]. *)
+(*   destruct dst; monadInv EQ0. *)
+(* + (* for value *) *)
+(*   exploit H0; eauto with gensym. intros [tmp2 [C D]]. *)
+(*   exploit H1; eauto with gensym. intros [tmp3 [E F]]. *)
+(*   simpl add_dest in *. *)
+(*   exists (x0 :: tmp1 ++ tmp2 ++ tmp3); split. *)
+(*   simpl; intros; eapply tr_condition_val; eauto with gensym. *)
+(*   apply list_disjoint_cons_r; eauto with gensym. *)
+(*   apply list_disjoint_cons_r; eauto with gensym. *)
+(*   apply contained_cons. eauto with gensym. *)
+(*   apply contained_app. eauto with gensym. *)
+(*   apply contained_app; eauto with gensym. *)
+(* + (* for effects *) *)
+(*   exploit H0; eauto. intros [tmp2 [Csyntax D]]. *)
+(*   exploit H1; eauto. intros [tmp3 [E F]]. *)
+(*   simpl add_dest in *. *)
+(*   exists (tmp1 ++ tmp2 ++ tmp3); split. *)
+(*   intros; eapply tr_condition_effects; eauto with gensym. *)
+(*   apply contained_app; eauto with gensym. *)
+(* + (* for test *) *)
+(*   exploit H0; eauto with gensym. intros [tmp2 [C D]]. *)
+(*   exploit H1; eauto 10 with gensym. intros [tmp3 [E F]]. *)
+(*   simpl add_dest in *. *)
+(*   exists (x0 :: tmp1 ++ tmp2 ++ tmp3); split. *)
+(*   intros; eapply tr_condition_set; eauto with gensym. *)
+(*   apply list_disjoint_cons_r; eauto with gensym. *)
+(*   apply list_disjoint_cons_r; eauto with gensym. *)
+(*   apply contained_cons; eauto with gensym. *)
+(*   apply contained_app; eauto with gensym. *)
+(*   apply contained_app; eauto with gensym. *)
+(* - (* sizeof *) *)
+(*   monadInv H. UseFinish. *)
+(*   exists (@nil ident); split; auto with gensym. constructor. *)
+(* - (* alignof *) *)
+(*   monadInv H. UseFinish. *)
+(*   exists (@nil ident); split; auto with gensym. constructor. *)
+(* - (* assign *) *)
+(* (*   monadInv H1. exploit H; eauto. intros [tmp1 [A B]]. *) *)
+(* (*   exploit H0; eauto. intros [tmp2 [Csyntax D]]. *) *)
+(* (*   destruct dst; monadInv EQ2; simpl add_dest in *. *) *)
+(* (* + (* for value *) *) *)
+(* (*   exists (x1 :: tmp1 ++ tmp2); split. *) *)
+(* (*   intros. eapply tr_assign_val with (dst := For_val); eauto with gensym. *) *)
+(* (*   apply contained_cons. eauto with gensym. *) *)
+(* (*   apply contained_app; eauto with gensym. *) *)
+(* (* + (* for effects *) *) *)
+(* (*   exists (tmp1 ++ tmp2); split. *) *)
+(* (*   econstructor; eauto with gensym. *) *)
+(* (*   apply contained_app; eauto with gensym. *) *)
+(* (* + (* for set *) *) *)
+(* (*   exists (x1 :: tmp1 ++ tmp2); split. *) *)
+(* (*   repeat rewrite app_ass. simpl. *) *)
+(* (*   intros. eapply tr_assign_val with (dst := For_set sd); eauto with gensym. *) *)
+(* (*   apply contained_cons. eauto with gensym. *) *)
+(* (*   apply contained_app; eauto with gensym. *) *)
+(* - (* assignop *) *)
+(* (*   monadInv H1. exploit H; eauto. intros [tmp1 [A B]]. *) *)
+(* (*   exploit H0; eauto. intros [tmp2 [Csyntax D]]. *) *)
+(* (*   exploit transl_valof_meets_spec; eauto. intros [tmp3 [E F]]. *) *)
+(* (*   destruct dst; monadInv EQ3; simpl add_dest in *. *) *)
+(* (* + (* for value *) *) *)
+(* (*   exists (x2 :: tmp1 ++ tmp2 ++ tmp3); split. *) *)
+(* (*   intros. eapply tr_assignop_val with (dst := For_val); eauto with gensym. *) *)
+(* (*   apply contained_cons. eauto with gensym. *) *)
+(* (*   apply contained_app; eauto with gensym. *) *)
+(* (* + (* for effects *) *) *)
+(* (*   exists (tmp1 ++ tmp2 ++ tmp3); split. *) *)
+(* (*   econstructor; eauto with gensym. *) *)
+(* (*   apply contained_app; eauto with gensym. *) *)
+(* (* + (* for set *) *) *)
+(* (*   exists (x2 :: tmp1 ++ tmp2 ++ tmp3); split. *) *)
+(* (*   repeat rewrite app_ass. simpl. *) *)
+(* (*   intros. eapply tr_assignop_val with (dst := For_set sd); eauto with gensym. *) *)
+(* (*   apply contained_cons. eauto with gensym. *) *)
+(* (*   apply contained_app; eauto with gensym. *) *)
+(* - (* postincr *) *)
+(*   monadInv H0. exploit H; eauto. intros [tmp1 [A B]]. *)
+(*   destruct dst; monadInv EQ0; simpl add_dest in *. *)
+(* + (* for value *) *)
+(*   exists (x0 :: tmp1); split. *)
+(*   econstructor; eauto with gensym. *)
+(*   apply contained_cons; eauto with gensym. *)
+(* + (* for effects *) *)
+(*   exploit transl_valof_meets_spec; eauto. intros [tmp2 [Csyntax D]]. *)
+(*   exists (tmp1 ++ tmp2); split. *)
+(*   econstructor; eauto with gensym. *)
+(*   eauto with gensym. *)
+(* + (* for set *) *)
+(*   repeat rewrite app_ass; simpl. *)
+(*   exists (x0 :: tmp1); split. *)
+(*   econstructor; eauto with gensym. *)
+(*   apply contained_cons; eauto with gensym. *)
+(* - (* comma *) *)
+(*   monadInv H1. exploit H; eauto. intros [tmp1 [A B]]. *)
+(*   exploit H0; eauto with gensym. intros [tmp2 [Csyntax D]]. *)
+(*   exists (tmp1 ++ tmp2); split. *)
+(*   econstructor; eauto with gensym. *)
+(*   destruct dst; simpl; eauto with gensym. *)
+(*   apply list_disjoint_cons_r; eauto with gensym. *)
+(*   simpl. eapply incl_tran. 2: apply add_dest_incl. auto with gensym. *)
+(*   destruct dst; simpl; auto with gensym. *)
+(*   apply contained_app; eauto with gensym. *)
+(* - (* call *) *)
+(* (*   monadInv H1. exploit H; eauto. intros [tmp1 [A B]]. *) *)
+(* (*   exploit H0; eauto. intros [tmp2 [Csyntax D]]. *) *)
+(* (*   destruct dst; monadInv EQ2; simpl add_dest in *. *) *)
+(* (* + (* for value *) *) *)
+(* (*   exists (x1 :: tmp1 ++ tmp2); split. *) *)
+(* (*   econstructor; eauto with gensym. congruence. *) *)
+(* (*   apply contained_cons. eauto with gensym. *) *)
+(* (*   apply contained_app; eauto with gensym. *) *)
+(* (* + (* for effects *) *) *)
+(* (*   exists (tmp1 ++ tmp2); split. *) *)
+(* (*   econstructor; eauto with gensym. *) *)
+(* (*   apply contained_app; eauto with gensym. *) *)
+(* (* + (* for set *) *) *)
+(* (*   exists (x1 :: tmp1 ++ tmp2); split. *) *)
+(* (*   repeat rewrite app_ass. econstructor; eauto with gensym. congruence. *) *)
+(* (*   apply contained_cons. eauto with gensym. *) *)
+(* (*   apply contained_app; eauto with gensym. *) *)
+(* - (* builtin *) *)
+(* (*   monadInv H0. exploit H; eauto. intros [tmp1 [A B]]. *) *)
+(* (*   destruct dst; monadInv EQ0; simpl add_dest in *. *) *)
+(* (* + (* for value *) *) *)
+(* (*   exists (x0 :: tmp1); split. *) *)
+(* (*   econstructor; eauto with gensym. congruence. *) *)
+(* (*   apply contained_cons; eauto with gensym. *) *)
+(* (* + (* for effects *) *) *)
+(* (*   exists tmp1; split. *) *)
+(* (*   econstructor; eauto with gensym. *) *)
+(* (*   auto. *) *)
+(* (* + (* for set *) *) *)
+(* (*   exists (x0 :: tmp1); split. *) *)
+(* (*   repeat rewrite app_ass. econstructor; eauto with gensym. congruence. *) *)
+(* (*   apply contained_cons; eauto with gensym. *) *)
+(* - (* loc *) *)
+(*   monadInv H. *)
+(* - (* paren *) *)
+(*   monadInv H0. *)
+(* - (* nil *) *)
+(*   monadInv H; exists (@nil ident); split; auto with gensym. constructor. *)
+(* - (* cons *) *)
+(*   monadInv H1. exploit H; eauto. intros [tmp1 [A B]]. *)
+(*   exploit H0; eauto. intros [tmp2 [Csyntax D]]. *)
+(*   exists (tmp1 ++ tmp2); split. *)
+(*   econstructor; eauto with gensym. *)
+(*   eauto with gensym. *)
+(* Qed. *)
+
+(* Lemma transl_expr_meets_spec: *)
+(*    forall r dst g sl a g' I, *)
+(*    transl_expr dst r g = Res (sl, a) g' I -> *)
+(*    dest_below dst g -> *)
+(*    exists tmps, forall ge e le m, tr_top ge e le m dst r sl a tmps. *)
+(* Proof. *)
+(*   intros. exploit (proj1 transl_meets_spec); eauto. intros [tmps [A B]]. *)
+(*   exists (add_dest dst tmps); intros. apply tr_top_base. auto. *)
+(* Qed. *)
+
+(* Lemma transl_expression_meets_spec: *)
+(*   forall r g s a g' I, *)
+(*   transl_expression r g = Res (s, a) g' I -> *)
+(*   tr_expression r s a. *)
+(* Proof. *)
+(*   intros. monadInv H. exploit transl_expr_meets_spec; eauto. *)
+(*   intros [tmps A]. econstructor; eauto. *)
+(* Qed. *)
+
+(* Lemma transl_expr_stmt_meets_spec: *)
+(*   forall r g s g' I, *)
+(*   transl_expr_stmt r g = Res s g' I -> *)
+(*   tr_expr_stmt r s. *)
+(* Proof. *)
+(*   intros. monadInv H. exploit transl_expr_meets_spec; eauto. *)
+(*   intros [tmps A]. econstructor; eauto. *)
+(* Qed. *)
+
+(* Lemma transl_if_meets_spec: *)
+(*   forall r s1 s2 g s g' I, *)
+(*   transl_if r s1 s2 g = Res s g' I -> *)
+(*   tr_if r s1 s2 s. *)
+(* Proof. *)
+(*   intros. monadInv H. exploit transl_expr_meets_spec; eauto. *)
+(*   intros [tmps A]. econstructor; eauto. *)
+(* Qed. *)
+
+(* Lemma transl_stmt_meets_spec: *)
+(*   forall s g ts g' I ty, transl_stmt s ty g = Res ts g' I -> tr_stmt s ty ts *)
+(* with transl_lblstmt_meets_spec: *)
+(*   forall s g ts g' I ty, transl_lblstmt s ty g = Res ts g' I -> tr_lblstmts s ty ts. *)
+(* Proof. *)
+(* (*   generalize transl_expression_meets_spec transl_expr_stmt_meets_spec transl_if_meets_spec; intros T1 T2 T3. *) *)
+(* (* Opaque transl_expression transl_expr_stmt. *) *)
+(* (*   clear transl_stmt_meets_spec. *) *)
+(* (*   induction s; simpl; intros until I; intros TR; *) *)
+(* (*   try (monadInv TR); try (constructor; eauto). *) *)
+(* (*   destruct (is_Sskip s1); destruct (is_Sskip s2) eqn:?; monadInv EQ3; try (constructor; eauto). *) *)
+(* (*   eapply tr_ifthenelse_empty; eauto. *) *)
+(* (*   destruct (is_Sskip s1); monadInv EQ4. *) *)
+(* (*   apply tr_for_1; eauto. *) *)
+(* (*   apply tr_for_2; eauto. *) *)
+(* (*   destruct o; monadInv TR; constructor; eauto. *) *)
+(* (*   clear transl_lblstmt_meets_spec. *) *)
+(* (*   induction s; simpl; intros until I; intros TR; *) *)
+(* (*   monadInv TR; constructor; eauto. *) *)
+
+(*   (* Qed. *) *)
 
-Lemma transl_stmt_meets_spec:
-  forall s g ts g' I, transl_stmt s g = Res ts g' I -> tr_stmt s ts
-with transl_lblstmt_meets_spec:
-  forall s g ts g' I, transl_lblstmt s g = Res ts g' I -> tr_lblstmts s ts.
-Proof.
-  generalize transl_expression_meets_spec transl_expr_stmt_meets_spec transl_if_meets_spec; intros T1 T2 T3.
-Opaque transl_expression transl_expr_stmt.
-  clear transl_stmt_meets_spec.
-  induction s; simpl; intros until I; intros TR;
-  try (monadInv TR); try (constructor; eauto).
-  destruct (is_Sskip s1); destruct (is_Sskip s2) eqn:?; monadInv EQ3; try (constructor; eauto).
-  eapply tr_ifthenelse_empty; eauto.
-  destruct (is_Sskip s1); monadInv EQ4.
-  apply tr_for_1; eauto.
-  apply tr_for_2; eauto.
-  destruct o; monadInv TR; constructor; eauto.
-  clear transl_lblstmt_meets_spec.
-  induction s; simpl; intros until I; intros TR;
-  monadInv TR; constructor; eauto.
-Qed.
 
 (** Relational presentation for the transformation of functions, fundefs, and variables. *)
 
 Inductive tr_function: Csyntax.function -> Clight.function -> Prop :=
   | tr_function_intro: forall f tf,
-      tr_stmt f.(Csyntax.fn_body) tf.(fn_body) ->
+      tr_stmt f.(Csyntax.fn_body) f.(Csyntax.fn_return) tf.(fn_body) ->
       fn_return tf = Csyntax.fn_return f ->
       fn_callconv tf = Csyntax.fn_callconv f ->
       fn_params tf = Csyntax.fn_params f ->
@@ -1106,25 +1112,25 @@ Inductive tr_fundef: Csyntax.fundef -> Clight.fundef -> Prop :=
   | tr_external: forall ef targs tres cconv,
       tr_fundef (External ef targs tres cconv) (External ef targs tres cconv).
 
-Lemma transl_function_spec:
-  forall f tf,
-  transl_function f = OK tf ->
-  tr_function f tf.
-Proof.
-  unfold transl_function; intros.
-  destruct (transl_stmt (Csyntax.fn_body f) (initial_generator tt)) eqn:T; inv H.
-  constructor; auto. simpl. eapply transl_stmt_meets_spec; eauto.
-Qed.
-
-Lemma transl_fundef_spec:
-  forall fd tfd,
-  transl_fundef fd = OK tfd ->
-  tr_fundef fd tfd.
-Proof.
-  unfold transl_fundef; intros.
-  destruct fd; Errors.monadInv H.
-+ constructor. eapply transl_function_spec; eauto.
-+ constructor.
-Qed.
+(* Lemma transl_function_spec: *)
+(*   forall f tf, *)
+(*   transl_function f = OK tf -> *)
+(*   tr_function f tf. *)
+(* Proof. *)
+(*   unfold transl_function; intros. *)
+(*   destruct (transl_stmt (Csyntax.fn_body f) (Csyntax.fn_return f) (initial_generator tt)) eqn:T; inv H. *)
+(*   constructor; auto. simpl. eapply transl_stmt_meets_spec; eauto. *)
+(* Qed. *)
+
+(* Lemma transl_fundef_spec: *)
+(*   forall fd tfd, *)
+(*   transl_fundef fd = OK tfd -> *)
+(*   tr_fundef fd tfd. *)
+(* Proof. *)
+(*   unfold transl_fundef; intros. *)
+(*   destruct fd; Errors.monadInv H. *)
+(* + constructor. eapply transl_function_spec; eauto. *)
+(* + constructor. *)
+(* Qed. *)
 
 End SPEC.
diff --git a/cfrontend/SimplLocals.v b/cfrontend/SimplLocals.v
index 0a164e29..118cab29 100644
--- a/cfrontend/SimplLocals.v
+++ b/cfrontend/SimplLocals.v
@@ -41,6 +41,7 @@ Definition is_liftable_var (cenv: compilenv) (a: expr) : option ident :=
 
 Definition make_cast (a: expr) (tto: type) : expr :=
   match classify_cast (typeof a) tto with
+  | cast_case_pointer2int => a
   | cast_case_pointer => a
   | cast_case_i2i I32 _ => a
   | cast_case_f2f => a
diff --git a/cfrontend/SimplLocalsproof.v b/cfrontend/SimplLocalsproof.v
index 988988a1..6ff38468 100644
--- a/cfrontend/SimplLocalsproof.v
+++ b/cfrontend/SimplLocalsproof.v
@@ -15,8 +15,12 @@
 Require Import FSets.
 Require Import Coqlib Errors Ordered Maps Integers Floats.
 Require Import AST Linking.
+Require Import Simulation ClightD.
 Require Import Values Memory Globalenvs Events Smallstep.
 Require Import Ctypes Cop Clight SimplLocals.
+Require Import Classical.
+From Paco Require Import paco.
+
 
 Module VSF := FSetFacts.Facts(VSet).
 Module VSP := FSetProperties.Properties(VSet).
@@ -40,6 +44,9 @@ Hypothesis TRANSF: match_prog prog tprog.
 Let ge := globalenv prog.
 Let tge := globalenv tprog.
 
+Let sem := Clight.semantics1 prog.
+Let tsem := Clight.semantics2 tprog.
+
 Lemma comp_env_preserved:
   genv_cenv tge = genv_cenv ge.
 Proof.
@@ -54,6 +61,15 @@ Lemma senv_preserved:
   Senv.equiv ge tge.
 Proof (Genv.senv_match (proj1 TRANSF)).
 
+Lemma same_public: prog_public prog = prog_public tprog.
+Proof. inv TRANSF. inv H. des; eauto. Qed.
+
+Lemma same_public': AST.prog_public prog = AST.prog_public tprog.
+Proof. inv TRANSF. inv H. des; eauto. Qed.
+
+Lemma same_public'' (p: program): prog_public p = AST.prog_public p.
+Proof. ss. Qed.
+
 Lemma functions_translated:
   forall (v: val) (f: fundef),
   Genv.find_funct ge v = Some f ->
@@ -83,6 +99,7 @@ Inductive match_var (f: meminj) (cenv: compilenv) (e: env) (m: mem) (te: env) (t
       (LIFTED: VSet.mem id cenv = true)
       (MAPPED: f b = None)
       (MODE: access_mode ty = By_value chunk)
+      (PURE: Mem.change_check chunk (Mem.getN (size_chunk_nat chunk) 0 (Mem.mem_contents m) !! b) = false)
       (LOAD: Mem.load chunk m b 0 = Some v)
       (TLENV: tle!(id) = Some tv)
       (VINJ: Val.inject f v tv),
@@ -134,7 +151,8 @@ Lemma match_envs_invariant:
   forall f cenv e le m lo hi te tle tlo thi f' m',
   match_envs f cenv e le m lo hi te tle tlo thi ->
   (forall b chunk v,
-    f b = None -> Ple lo b /\ Plt b hi -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) ->
+    f b = None -> Ple lo b /\ Plt b hi -> 
+    Mem.loadbytes m b 0 (size_chunk chunk) = Some v -> Mem.loadbytes m' b 0 (size_chunk chunk) = Some v) ->
   inject_incr f f' ->
   (forall b, Ple lo b /\ Plt b hi -> f' b = f b) ->
   (forall b b' delta, f' b = Some(b', delta) -> Ple tlo b' /\ Plt b' thi -> f' b = f b) ->
@@ -144,8 +162,21 @@ Proof.
   destruct ME; constructor; eauto.
 (* vars *)
   intros. generalize (me_vars0 id); intros MV; inv MV.
-  eapply match_var_lifted; eauto.
-  rewrite <- MAPPED; eauto.
+  Local Transparent Mem.load Mem.loadbytes. 
+  assert (LD': forall (ENC: Mem.change_check chunk (Mem.getN (size_chunk_nat chunk) 0 (Mem.mem_contents m) !! b) = false),
+               f b = None -> Ple lo b /\ Plt b hi -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).
+  { ii. exploit Mem.load_loadbytes; eauto. i. des. exploit LD; eauto. i.
+    unfold Mem.loadbytes in H2, H5. des_ifs_safe. rewrite <- H2 in *.
+    clear LOAD VINJ. exploit Mem.load_valid_access; eauto. i. inv H3. unfold Mem.load. des_ifs.
+    - unfold size_chunk_nat in ENC. rewrite H2 in *.
+      erewrite <- Mem.change_check_fail_normalize_mvs_same; eauto.
+    - exfalso. eapply n. econs; eauto. }
+  eapply match_var_lifted; try by eauto.
+  rewrite <- MAPPED; eauto. eauto.
+  { exploit Mem.load_valid_access; eauto. i. inv H.
+    exploit (LD b chunk (Mem.getN (size_chunk_nat chunk) 0 (Mem.mem_contents m) !! b)); eauto.
+    unfold Mem.loadbytes. des_ifs. i. unfold Mem.loadbytes in H. des_ifs_safe.
+    unfold size_chunk_nat. rewrite H. ss. }
   eapply match_var_not_lifted; eauto.
   eapply match_var_not_local; eauto.
 (* temps *)
@@ -168,7 +199,7 @@ Lemma match_envs_extcall:
   match_envs f' cenv e le m' lo hi te tle tlo thi.
 Proof.
   intros. eapply match_envs_invariant; eauto.
-  intros. eapply Mem.load_unchanged_on; eauto.
+  intros. eapply Mem.loadbytes_unchanged_on; eauto.
   red in H2. intros. destruct (f b) as [[b' delta]|] eqn:?.
   eapply H1; eauto.
   destruct (f' b) as [[b' delta]|] eqn:?; auto.
@@ -253,6 +284,7 @@ Proof.
   unfold sem_cast, make_cast in *.
   destruct (classify_cast (typeof a) tto); auto.
   destruct v1; destruct Archi.ptr64; inv H0; auto.
+  destruct v1; destruct Archi.ptr64; inv H0; auto.
   destruct sz2; auto. destruct v1; inv H0; auto.
   destruct v1; inv H0; auto.
   destruct v1; inv H0; auto.
@@ -290,10 +322,10 @@ Lemma step_Sdebug_temp:
   forall f id ty k e le m v,
   le!id = Some v ->
   val_casted v ty ->
-  step2 tge (State f (Sdebug_temp id ty) k e le m)
+  DStep tsem (State f (Sdebug_temp id ty) k e le m)
          E0 (State f Sskip k e le m).
 Proof.
-  intros. unfold Sdebug_temp. eapply step_builtin with (optid := None).
+  intros. unfold Sdebug_temp. DStep_tac2. eapply step_builtin with (optid := None).
   econstructor. constructor. eauto. simpl. eapply cast_typeconv; eauto. constructor.
   simpl. constructor.
 Qed.
@@ -301,10 +333,10 @@ Qed.
 Lemma step_Sdebug_var:
   forall f id ty k e le m b,
   e!id = Some(b, ty) ->
-  step2 tge (State f (Sdebug_var id ty) k e le m)
+  DStep tsem (State f (Sdebug_var id ty) k e le m)
          E0 (State f Sskip k e le m).
 Proof.
-  intros. unfold Sdebug_var. eapply step_builtin with (optid := None).
+  intros. unfold Sdebug_var. DStep_tac2. eapply step_builtin with (optid := None).
   econstructor. constructor. constructor. eauto.
   simpl. reflexivity. constructor.
   simpl. constructor.
@@ -314,7 +346,7 @@ Lemma step_Sset_debug:
   forall f id ty a k e le m v v',
   eval_expr tge e le m a v ->
   sem_cast v (typeof a) ty m = Some v' ->
-  plus step2 tge (State f (Sset_debug id ty a) k e le m)
+  DPlus tsem (State f (Sset_debug id ty a) k e le m)
               E0 (State f Sskip k e (PTree.set id v' le) m).
 Proof.
   intros; unfold Sset_debug.
@@ -322,19 +354,19 @@ Proof.
                            E0 (State f Sskip k e (PTree.set id v' le) m)).
   { intros. apply step_set. eapply make_cast_correct; eauto. }
   destruct (Compopts.debug tt).
-- eapply plus_left. constructor.
-  eapply star_left. apply H1.
-  eapply star_left. constructor.
-  apply star_one. apply step_Sdebug_temp with (v := v').
+- eapply plus_left. DStep_tac2. constructor.
+  eapply star_left. DStep_tac2. apply H1.
+  eapply star_left. DStep_tac2. constructor.
+  apply star_one. DStep_tac2. apply step_Sdebug_temp with (v := v').
   apply PTree.gss. eapply cast_val_is_casted; eauto.
   reflexivity. reflexivity. reflexivity.
-- apply plus_one. apply H1.
+- apply plus_one. DStep_tac2. apply H1.
 Qed.
 
 Lemma step_add_debug_vars:
   forall f s e le m vars k,
   (forall id ty, In (id, ty) vars -> exists b, e!id = Some (b, ty)) ->
-  star step2 tge (State f (add_debug_vars vars s) k e le m)
+  DStar tsem (State f (add_debug_vars vars s) k e le m)
               E0 (State f s k e le m).
 Proof.
   unfold add_debug_vars. destruct (Compopts.debug tt).
@@ -342,9 +374,9 @@ Proof.
   + apply star_refl.
   + destruct a as [id ty].
     exploit H; eauto. intros (b & TE).
-    simpl. eapply star_left. constructor.
-    eapply star_left. eapply step_Sdebug_var; eauto.
-    eapply star_left. constructor.
+    simpl. eapply star_left. DStep_tac2. constructor.
+    eapply star_left. DStep_tac2. eapply step_Sdebug_var; eauto.
+    eapply star_left. DStep_tac2. constructor.
     apply IHvars; eauto.
     reflexivity. reflexivity. reflexivity.
 - intros. apply star_refl.
@@ -368,16 +400,16 @@ Lemma step_add_debug_params:
   list_norepet (var_names params) ->
   list_forall2 val_casted vl (map snd params) ->
   bind_parameter_temps params vl le1 = Some le ->
-  star step2 tge (State f (add_debug_params params s) k e le m)
+  DStar tsem (State f (add_debug_params params s) k e le m)
               E0 (State f s k e le m).
 Proof.
   unfold add_debug_params. destruct (Compopts.debug tt).
 - induction params as [ | [id ty] params ]; simpl; intros until le1; intros NR CAST BIND; inv CAST; inv NR.
   + apply star_refl.
   + assert (le!id = Some a1). { erewrite bind_parameter_temps_inv by eauto. apply PTree.gss. }
-    eapply star_left. constructor.
-    eapply star_left. eapply step_Sdebug_temp; eauto.
-    eapply star_left. constructor.
+    eapply star_left. DStep_tac2. constructor.
+    eapply star_left. DStep_tac2. eapply step_Sdebug_temp; eauto.
+    eapply star_left. DStep_tac2. constructor.
     eapply IHparams; eauto.
     reflexivity. reflexivity. reflexivity.
 - intros; apply star_refl.
@@ -385,13 +417,22 @@ Qed.
 
 (** Preservation by assignment to lifted variable. *)
 
+Lemma store_encoded_bytes chunk m b ofs v m'
+    (STORE: Mem.store chunk m b ofs v = Some m'):
+  <<ENC: Mem.change_check chunk (Mem.getN (size_chunk_nat chunk) ofs (Mem.mem_contents m') !! b) = false>>.
+Proof.
+  exploit Mem.store_valid_access_3; eauto. i. exploit Mem.store_valid_access_1; eauto. i.
+  eapply Mem.store_pure_memval_check; eauto. unfold Mem.loadbytes. des_ifs.
+  exfalso. eapply n. inv H0. eapply Mem.range_perm_implies; eauto. eapply perm_W_R.
+Qed.
+
 Lemma match_envs_assign_lifted:
   forall f cenv e le m lo hi te tle tlo thi b ty v m' id tv,
   match_envs f cenv e le m lo hi te tle tlo thi ->
   e!id = Some(b, ty) ->
   val_casted v ty ->
   Val.inject f v tv ->
-  assign_loc ge ty m b Ptrofs.zero v m' ->
+  assign_loc ge ty m (Vptr b Ptrofs.zero) v m' ->
   VSet.mem id cenv = true ->
   match_envs f cenv e le m' lo hi te (PTree.set id tv tle) tlo thi.
 Proof.
@@ -402,10 +443,14 @@ Proof.
 (* vars *)
   destruct (peq id0 id). subst id0.
   eapply match_var_lifted with (v := v); eauto.
+  eapply store_encoded_bytes; eauto.
   exploit Mem.load_store_same; eauto. erewrite val_casted_load_result; eauto.
   apply PTree.gss.
   generalize (me_vars0 id0); intros MV; inv MV.
   eapply match_var_lifted; eauto.
+  exploit (Mem.loadbytes_store_other _ _ _ _ _ _ H0 b0 0 (size_chunk chunk1)); eauto.
+  i. exploit Mem.load_valid_access; eauto. i. exploit Mem.store_valid_access_1; eauto. i.
+  inv H5. inv H6. unfold Mem.loadbytes in H3. des_ifs. unfold size_chunk_nat in *.  rewrite H3. ss.
   rewrite <- LOAD0. eapply Mem.load_store_other; eauto.
   rewrite PTree.gso; auto.
   eapply match_var_not_lifted; eauto.
@@ -750,6 +795,21 @@ Proof.
   apply IHalloc_variables. eapply Mem.load_alloc_other; eauto.
 Qed.
 
+Lemma alloc_variables_loadbytes:
+  forall e m vars e' m',
+  alloc_variables ge e m vars e' m' ->
+  forall chunk b ofs v,
+  Mem.loadbytes m b ofs (size_chunk chunk) = Some v ->
+  Mem.loadbytes m' b ofs (size_chunk chunk) = Some v.
+Proof.
+  induction 1; intros.
+  auto.
+  apply IHalloc_variables. rewrite <- H1. eapply Mem.loadbytes_alloc_unchanged; eauto.
+  unfold Mem.loadbytes in H1. des_ifs. specialize (r ofs). exploit r; eauto.
+  { destruct chunk; ss; lia. }
+  i. eauto with mem.
+Qed.
+
 Lemma sizeof_by_value:
   forall ty chunk,
   access_mode ty = By_value chunk -> size_chunk chunk <= sizeof ge ty.
@@ -767,6 +827,14 @@ Definition env_initial_value (e: env) (m: mem) :=
   forall id b ty chunk,
   e!id = Some(b, ty) -> access_mode ty = By_value chunk -> Mem.load chunk m b 0 = Some Vundef.
 
+Definition env_initial_value' (e: env) (m: mem) :=
+  forall id b ty chunk,
+  e!id = Some(b, ty) -> access_mode ty = By_value chunk -> Mem.loadbytes m b 0 (size_chunk chunk) = Some (repeat Undef (size_chunk_nat chunk)).
+
+Definition env_initial_value'' (e: env) (m: mem) :=
+  forall id b ty chunk,
+  e!id = Some(b, ty) -> access_mode ty = By_value chunk -> bytes_all_undef (Mem.getN (size_chunk_nat chunk) 0 (Mem.mem_contents m) !! b) = true.
+
 Lemma alloc_variables_initial_value:
   forall e m vars e' m',
   alloc_variables ge e m vars e' m' ->
@@ -783,6 +851,49 @@ Proof.
   eapply Mem.load_alloc_other; eauto.
 Qed.
 
+Lemma bytes_alloc_unchanged m lo hi m' b b' sz ofs
+    (VLD: Mem.valid_block m b')
+    (ALLOC: Mem.alloc m lo hi = (m', b)):
+  <<BYTES: Mem.getN sz ofs (Mem.mem_contents m) !! b' = Mem.getN sz ofs (Mem.mem_contents m') !! b'>>.
+Proof.
+  destruct (eq_block b' b); i.
+- subst. exfalso. eapply Mem.fresh_block_alloc; eauto.
+- Local Transparent Mem.alloc. injection ALLOC; i. rewrite <- H0. ss.
+  erewrite PMap.gso; eauto. rewrite H. ss.
+Qed.
+
+Lemma loadbytes_alloc_other m1 lo hi m2 b
+  (ALLOC: Mem.alloc m1 lo hi = (m2, b))
+  b' ofs n bytes (LEN: n > 0)
+  (LB: Mem.loadbytes m1 b' ofs n = Some bytes) :
+  <<LB: Mem.loadbytes m2 b' ofs n = Some bytes>>.
+Proof.
+  rewrite <- LB. eapply Mem.loadbytes_alloc_unchanged; eauto with mem.
+  unfold Mem.loadbytes in *. des_ifs.
+  specialize (r ofs). exploit r; eauto. lia. i. eauto with mem.
+Qed.
+
+Lemma alloc_bytes_all_undef ty m m1 b chunk
+  (ALLOC: Mem.alloc m 0 (sizeof ge ty) = (m1, b))
+  (SZ: access_mode ty = By_value chunk):
+  <<UNDEF: bytes_all_undef (Mem.getN (size_chunk_nat chunk) 0 (Mem.mem_contents m1) !! b) = true>>.
+Proof. injection ALLOC; i; subst. ss. erewrite PMap.gss; eauto. destruct chunk; ss. Qed.
+
+Lemma alloc_variables_initial_undef:
+  forall e m vars e' m' (WF: forall id b ty, e ! id = Some (b, ty) -> Mem.valid_block m b),
+  alloc_variables ge e m vars e' m' ->
+  env_initial_value'' e m ->
+  env_initial_value'' e' m'.
+Proof.
+  induction 2; auto. i. eapply IHalloc_variables.
+  { ii. destruct (peq id id0); subst.
+    rewrite PTree.gss in H2; eauto. clarify. eapply Mem.valid_new_block; eauto.
+    rewrite PTree.gso in H2; eauto. eapply WF in H2. eapply Mem.valid_block_alloc; eauto. }
+  red; i. rewrite PTree.gsspec in H2. destruct (peq id0 id). inv H2.
+- eapply alloc_bytes_all_undef; eauto.
+- erewrite <- bytes_alloc_unchanged; eauto.
+Qed.
+
 Lemma create_undef_temps_charact:
   forall id ty vars, In (id, ty) vars -> (create_undef_temps vars)!id = Some Vundef.
 Proof.
@@ -936,6 +1047,12 @@ Proof.
   destruct R as [U V]. exploit H2; eauto. intros [chunk X].
   eapply match_var_lifted with (v := Vundef) (tv := Vundef); eauto.
   rewrite U; apply PTree.gempty.
+  { assert (bytes_all_undef (Mem.getN (size_chunk_nat chunk) 0 (Mem.mem_contents m') !! b) = true).
+    { eapply alloc_variables_initial_undef; eauto.
+      - unfold empty_env; i. rewrite PTree.gempty in H4; congruence.
+      - r. unfold empty_env; i. rewrite PTree.gempty in H4; congruence. }
+    eapply Mem.bytes_all_undef_not_change; eauto.
+    { destruct chunk; ss. } }
   eapply alloc_variables_initial_value; eauto.
   red. unfold empty_env; intros. rewrite PTree.gempty in H4; congruence.
   apply create_undef_temps_charact with ty.
@@ -1003,49 +1120,37 @@ Proof.
   destruct Y as (tb & U & V). exists tb; auto.
 Qed.
 
-Lemma assign_loc_inject:
-  forall f ty m loc ofs v m' tm loc' ofs' v',
-  assign_loc ge ty m loc ofs v m' ->
-  Val.inject f (Vptr loc ofs) (Vptr loc' ofs') ->
+Lemma assign_loc_inject':
+  forall f ty m vp v m' tm vp' v',
+  assign_loc ge ty m vp v m' ->
+  Val.inject f vp vp' ->
   Val.inject f v v' ->
   Mem.inject f m tm ->
   exists tm',
-     assign_loc tge ty tm loc' ofs' v' tm'
+     assign_loc tge ty tm vp' v' tm'
   /\ Mem.inject f m' tm'
   /\ (forall b chunk v,
-      f b = None -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).
+      f b = None -> Mem.loadbytes m b 0 (size_chunk chunk) = Some v -> Mem.loadbytes m' b 0 (size_chunk chunk) = Some v).
 Proof.
   intros. inv H.
 - (* by value *)
   exploit Mem.storev_mapped_inject; eauto. intros [tm' [A B]].
   exists tm'; split. eapply assign_loc_value; eauto.
   split. auto.
-  intros. rewrite <- H5. eapply Mem.load_store_other; eauto.
+  unfold Mem.storev in H4. des_ifs.
+  { intros. rewrite <- H5. eapply Mem.loadbytes_store_other; eauto.
+    exploit Mem.denormalize_inject; try eapply Heq0; eauto. i. des.
+    inv H0. left. unfold Mem.storev in A. des_ifs. inv VINJ. ii. clarify. }
+  intros. rewrite <- H5. eapply Mem.loadbytes_store_other; eauto.
   left. inv H0. congruence.
 - (* by copy *)
-  inv H0. inv H1.
-  rename b' into bsrc. rename ofs'0 into osrc.
-  rename loc into bdst. rename ofs into odst.
-  rename loc' into bdst'. rename b2 into bsrc'.
+  exploit Mem.to_ptr_inject; try eapply TOPTR1; eauto. i. des_safe.
+  exploit Mem.to_ptr_inject; try eapply TOPTR2; eauto. i. des_safe.
+  inv VINJ. inv VINJ0.
+  rename b' into bsrc. rename ofs' into osrc. rename b into bdst.
+  rename ofs into odst. rename b2 into bdst'. rename b0 into bsrc'.
   rewrite <- comp_env_preserved in *.
-  destruct (zeq (sizeof tge ty) 0).
-+ (* special case size = 0 *)
-  assert (bytes = nil).
-  { exploit (Mem.loadbytes_empty m bsrc (Ptrofs.unsigned osrc) (sizeof tge ty)).
-    lia. congruence. }
-  subst.
-  destruct (Mem.range_perm_storebytes tm bdst' (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta))) nil)
-  as [tm' SB].
-  simpl. red; intros; extlia.
-  exists tm'.
-  split. eapply assign_loc_copy; eauto.
-  intros; extlia.
-  intros; extlia.
-  rewrite e; right; lia.
-  apply Mem.loadbytes_empty. lia.
-  split. eapply Mem.storebytes_empty_inject; eauto.
-  intros. rewrite <- H0. eapply Mem.load_storebytes_other; eauto.
-  left. congruence.
+  destruct (zeq (sizeof tge ty) 0); [lia|].
 + (* general case size > 0 *)
   exploit Mem.loadbytes_length; eauto. intros LEN.
   assert (SZPOS: sizeof tge ty > 0).
@@ -1065,7 +1170,7 @@ Proof.
   exploit Mem.loadbytes_inject; eauto. intros [bytes2 [A B]].
   exploit Mem.storebytes_mapped_inject; eauto. intros [tm' [C D]].
   exists tm'.
-  split. eapply assign_loc_copy; try rewrite EQ1; try rewrite EQ2; eauto.
+  split. eapply assign_loc_copy; try eapply TOPTRTGT; try eapply TOPTRTGT0; try rewrite EQ1; try rewrite EQ2; eauto.
   intros; eapply Mem.aligned_area_inject with (m := m); eauto.
   apply alignof_blockcopy_1248.
   apply sizeof_alignof_blockcopy_compat.
@@ -1076,17 +1181,48 @@ Proof.
   apply Mem.range_perm_max with Cur; auto.
   apply Mem.range_perm_max with Cur; auto.
   split. auto.
-  intros. rewrite <- H0. eapply Mem.load_storebytes_other; eauto.
+  intros. rewrite <- H9. eapply Mem.loadbytes_storebytes_other; eauto.
+  destruct chunk; ss.
   left. congruence.
+- (* special case size = 0 *)
+  rewrite <- comp_env_preserved in *.
+  exists tm. esplits; eauto. econs 3; eauto.
+Qed.
+
+Lemma assign_loc_same_conc ty m vp v m'
+    (ASSIGN: assign_loc ge ty m vp v m'):
+  <<CONC: m.(Mem.mem_concrete) = m'.(Mem.mem_concrete)>>.
+Proof.
+  induction ASSIGN; ss; [eapply Mem.storev_concrete|eapply Mem.storebytes_concrete]; eauto.
+Qed.
+
+Lemma assign_loc_inject:
+  forall f ty m vp v m' tm vp' v',
+  assign_loc ge ty m vp v m' ->
+  Val.inject f vp vp' ->
+  Val.inject f v v' ->
+  Mem.inject f m tm ->
+  exists tm',
+     assign_loc tge ty tm vp' v' tm'
+  /\ Mem.inject f m' tm'
+  /\ (forall b chunk v,
+      f b = None -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v).
+Proof.
+  ii. exploit assign_loc_inject'; eauto. i. des.
+  esplits; eauto. ii. exploit Mem.load_loadbytes; eauto. i. des.
+  exploit H5; eauto. i. exploit Mem.loadbytes_load; eauto. eapply Z.divide_0_r. i.
+  subst. rewrite H11. symmetry. erewrite (Mem.normalize_mvs_same_concrete m m'); eauto.
+  eapply assign_loc_same_conc; eauto.
 Qed.
 
 Lemma assign_loc_nextblock:
-  forall ge ty m b ofs v m',
-  assign_loc ge ty m b ofs v m' -> Mem.nextblock m' = Mem.nextblock m.
+  forall ge ty m vp v m',
+  assign_loc ge ty m vp v m' -> Mem.nextblock m' = Mem.nextblock m.
 Proof.
   induction 1.
-  simpl in H0. eapply Mem.nextblock_store; eauto.
+  unfold Mem.storev in H0; simpl in H0; des_ifs; eapply Mem.nextblock_store; eauto.
   eapply Mem.nextblock_storebytes; eauto.
+  eauto.
 Qed.
 
 Theorem store_params_correct:
@@ -1101,7 +1237,7 @@ Theorem store_params_correct:
   (forall id, ~In id (var_names params) -> tle2!id = tle1!id) ->
   (forall id, In id (var_names params) -> le!id = None) ->
   exists tle, exists tm',
-  star step2 tge (State f (store_params cenv params s) k te tle tm)
+  DStar tsem (State f (store_params cenv params s) k te tle tm)
               E0 (State f s k te tle tm')
   /\ bind_parameter_temps params targs tle2 = Some tle
   /\ Mem.inject j m' tm'
@@ -1132,15 +1268,15 @@ Local Opaque Conventions1.parameter_needs_normalization.
   destruct (Conventions1.parameter_needs_normalization (rettype_of_type ty)); [|assumption].
   assert (A: tle!id = Some v').
   { erewrite bind_parameter_temps_inv by eauto. apply PTree.gss. }
-  eapply star_left. constructor.
-  eapply star_left. econstructor. eapply make_cast_correct.
+  eapply star_left. DStep_tac2. constructor.
+  eapply star_left. DStep_tac2. econstructor. eapply make_cast_correct.
     constructor; eauto. apply cast_val_casted; auto. eapply val_casted_inject; eauto.
   rewrite PTree.gsident by auto.
-  eapply star_left. constructor. eassumption.
+  eapply star_left. DStep_tac2. constructor. eassumption.
   traceEq. traceEq. traceEq.
 + (* still in memory *)
   inv MV; try congruence. rewrite ENV in H; inv H.
-  exploit assign_loc_inject; eauto.
+  exploit assign_loc_inject'; eauto.
   intros [tm1 [A [B C]]].
   exploit IHbind_parameters. eauto. eauto. eauto.
   instantiate (1 := PTree.set id v' tle1).
@@ -1156,19 +1292,20 @@ Local Opaque Conventions1.parameter_needs_normalization.
   intros [tle [tm' [U [V [X [Y Z]]]]]].
   exists tle; exists tm'; split.
   eapply star_trans.
-  eapply star_left. econstructor.
-  eapply star_left. econstructor.
+  eapply star_left. DStep_tac2. econstructor.
+  eapply star_left. DStep_tac2. econstructor.
     eapply eval_Evar_local. eauto.
     eapply eval_Etempvar. erewrite bind_parameter_temps_inv; eauto.
     apply PTree.gss.
     simpl. instantiate (1 := v'). apply cast_val_casted.
     eapply val_casted_inject with (v := v1); eauto.
     simpl. eexact A.
-  apply star_one. constructor.
+  apply star_one. DStep_tac2. constructor.
   reflexivity. reflexivity.
   eexact U.
   traceEq.
-  rewrite (assign_loc_nextblock _ _ _ _ _ _ _ A) in Z. auto.
+  esplits; eauto. eapply assign_loc_nextblock in A. rewrite A in Z. eauto.
+  (* rewrite (assign_loc_nextblock _ _ _ _ _ _ _ A) in Z. auto. *)
 Qed.
 
 Lemma bind_parameters_nextblock:
@@ -1193,7 +1330,27 @@ Proof.
   assert (b <> b0) by eauto.
   inv H1.
   simpl in H5. eapply Mem.load_store_other; eauto.
+  simpl in TOPTR1. clarify.
   eapply Mem.load_storebytes_other; eauto.
+  eauto.
+Qed.
+
+Lemma bind_parameters_loadbytes:
+  forall ge e chunk b ofs,
+  (forall id b' ty, e!id = Some(b', ty) -> b <> b') ->
+  forall m params args m',
+  bind_parameters ge e m params args m' ->
+  Mem.loadbytes m' b ofs (size_chunk chunk) = Mem.loadbytes m b ofs (size_chunk chunk).
+Proof.
+  induction 2.
+  auto.
+  rewrite IHbind_parameters.
+  assert (b <> b0) by eauto.
+  inv H1.
+  simpl in H5. eapply Mem.loadbytes_store_other; eauto.
+  simpl in TOPTR1. clarify.
+  eapply Mem.loadbytes_storebytes_other; eauto. destruct chunk; ss.
+  eauto.
 Qed.
 
 (** Freeing of local variables *)
@@ -1400,19 +1557,19 @@ Proof.
 Qed.
 
 Lemma deref_loc_inject:
-  forall ty loc ofs v loc' ofs',
-  deref_loc ty m loc ofs v ->
-  Val.inject f (Vptr loc ofs) (Vptr loc' ofs') ->
-  exists tv, deref_loc ty tm loc' ofs' tv /\ Val.inject f v tv.
+  forall ty vp v vp',
+  deref_loc ty m vp v ->
+  Val.inject f vp vp' ->
+  exists tv, deref_loc ty tm vp' tv /\ Val.inject f v tv.
 Proof.
   intros. inv H.
   (* by value *)
   exploit Mem.loadv_inject; eauto. intros [tv [A B]].
   exists tv; split; auto. eapply deref_loc_value; eauto.
   (* by reference *)
-  exists (Vptr loc' ofs'); split; auto. eapply deref_loc_reference; eauto.
+  exists vp'; split; auto. eapply deref_loc_reference; eauto.
   (* by copy *)
-  exists (Vptr loc' ofs'); split; auto. eapply deref_loc_copy; eauto.
+  exists vp'; split; auto. eapply deref_loc_copy; eauto.
 Qed.
 
 Lemma eval_simpl_expr:
@@ -1422,11 +1579,11 @@ Lemma eval_simpl_expr:
   exists tv, eval_expr tge te tle tm (simpl_expr cenv a) tv /\ Val.inject f v tv
 
 with eval_simpl_lvalue:
-  forall a b ofs,
-  eval_lvalue ge e le m a b ofs ->
+  forall a v,
+  eval_lvalue ge e le m a v ->
   compat_cenv (addr_taken_expr a) cenv ->
   match a with Evar id ty => VSet.mem id cenv = false | _ => True end ->
-  exists b', exists ofs', eval_lvalue tge te tle tm (simpl_expr cenv a) b' ofs' /\ Val.inject f (Vptr b ofs) (Vptr b' ofs').
+  exists v', eval_lvalue tge te tle tm (simpl_expr cenv a) v' /\ Val.inject f v v'.
 
 Proof.
   destruct 1; simpl; intros.
@@ -1443,8 +1600,8 @@ Proof.
   destruct a; auto with compat.
   destruct a; auto. destruct (VSet.mem i cenv) eqn:?; auto.
   elim (H0 i). apply VSet.singleton_2. auto. apply VSet.mem_2. auto.
-  intros [b' [ofs' [A B]]].
-  exists (Vptr b' ofs'); split; auto. constructor; auto.
+  intros [v' [A B]].
+  exists v'; split; auto. constructor; auto.
 (* unop *)
   exploit eval_simpl_expr; eauto. intros [tv1 [A B]].
   exploit sem_unary_operation_inject; eauto. intros [tv [C D]].
@@ -1472,15 +1629,15 @@ Proof.
   subst a. simpl. rewrite OPT.
   exploit me_vars; eauto. instantiate (1 := id). intros MV.
   inv H; inv MV; try congruence.
-  rewrite ENV in H6; inv H6.
+  rewrite ENV in H5; inv H5.
   inv H0; try congruence.
   assert (chunk0 = chunk). simpl in H. congruence. subst chunk0.
-  assert (v0 = v). unfold Mem.loadv in H2. rewrite Ptrofs.unsigned_zero in H2. congruence. subst v0.
+  assert (v0 = v). unfold Mem.loadv in H2. ss. rewrite Ptrofs.unsigned_zero in H2. congruence. subst v0.
   exists tv; split; auto. constructor; auto.
   simpl in H; congruence.
   simpl in H; congruence.
   (* any other l-value *)
-  exploit eval_simpl_lvalue; eauto. intros [loc' [ofs' [A B]]].
+  exploit eval_simpl_lvalue; eauto. intros [v' [A B]].
   exploit deref_loc_inject; eauto. intros [tv [C D]].
   exists tv; split; auto. econstructor. eexact A. rewrite typeof_simpl_expr; auto.
 
@@ -1490,32 +1647,36 @@ Proof.
   rewrite H1.
   exploit me_vars; eauto. instantiate (1 := id). intros MV. inv MV; try congruence.
   rewrite ENV in H; inv H.
-  exists b'; exists Ptrofs.zero; split.
+  exists (Vptr b' Ptrofs.zero); split.
   apply eval_Evar_local; auto.
   econstructor; eauto.
 (* global var *)
   rewrite H2.
   exploit me_vars; eauto. instantiate (1 := id). intros MV. inv MV; try congruence.
-  exists l; exists Ptrofs.zero; split.
+  exists (Vptr l Ptrofs.zero); split.
   apply eval_Evar_global. auto. rewrite <- H0. apply symbols_preserved.
   destruct GLOB as [bound GLOB1]. inv GLOB1.
   econstructor; eauto.
 (* deref *)
   exploit eval_simpl_expr; eauto. intros [tv [A B]].
-  inversion B. subst.
-  econstructor; econstructor; split; eauto. econstructor; eauto.
+  inversion B; subst; simpl in *; des_ifs.
+  econs; split; eauto. econs; eauto.
+  econstructor; split; eauto. econstructor; eauto.
 (* field struct *)
   rewrite <- comp_env_preserved in *.
   exploit eval_simpl_expr; eauto. intros [tv [A B]].
-  inversion B. subst.
-  econstructor; econstructor; split.
+  inversion B; subst; simpl in *; unfold Vptrofs in *; des_ifs.
+  { econstructor; split. eapply eval_Efield_struct; eauto.
+    rewrite typeof_simpl_expr; eauto. econstructor; eauto. }
+  econstructor; split.
   eapply eval_Efield_struct; eauto. rewrite typeof_simpl_expr; eauto.
   econstructor; eauto. repeat rewrite Ptrofs.add_assoc. decEq. apply Ptrofs.add_commut.
 (* field union *)
   rewrite <- comp_env_preserved in *.
   exploit eval_simpl_expr; eauto. intros [tv [A B]].
-  inversion B. subst.
-  econstructor; econstructor; split.
+  inversion B; subst; simpl in *; des_ifs.
+  { econstructor; split. eapply eval_Efield_union; eauto. rewrite typeof_simpl_expr; eauto. auto. }
+  econstructor; split.
   eapply eval_Efield_union; eauto. rewrite typeof_simpl_expr; eauto. auto.
 Qed.
 
@@ -1582,7 +1743,7 @@ Lemma match_cont_invariant:
   forall f' m' f cenv k tk m bound tbound,
   match_cont f cenv k tk m bound tbound ->
   (forall b chunk v,
-    f b = None -> Plt b bound -> Mem.load chunk m b 0 = Some v -> Mem.load chunk m' b 0 = Some v) ->
+     f b = None -> Plt b bound -> Mem.loadbytes m b 0 (size_chunk chunk) = Some v -> Mem.loadbytes m' b 0 (size_chunk chunk) = Some v) ->
   inject_incr f f' ->
   (forall b, Plt b bound -> f' b = f b) ->
   (forall b b' delta, f' b = Some(b', delta) -> Plt b' tbound -> f' b = f b) ->
@@ -1609,16 +1770,18 @@ Qed.
 Lemma match_cont_assign_loc:
   forall f cenv k tk m bound tbound ty loc ofs v m',
   match_cont f cenv k tk m bound tbound ->
-  assign_loc ge ty m loc ofs v m' ->
+  assign_loc ge ty m (Vptr loc ofs) v m' ->
   Ple bound loc ->
   match_cont f cenv k tk m' bound tbound.
 Proof.
   intros. eapply match_cont_invariant; eauto.
   intros. rewrite <- H4. inv H0.
   (* scalar *)
-  simpl in H6. eapply Mem.load_store_other; eauto. left. unfold block; extlia.
+  simpl in H6. eapply Mem.loadbytes_store_other; eauto. left. unfold block; extlia.
   (* block copy *)
-  eapply Mem.load_storebytes_other; eauto. left. unfold block; extlia.
+  ss. clarify.
+  eapply Mem.loadbytes_storebytes_other; eauto. destruct chunk; ss. left. unfold block; extlia.
+  eauto.
 Qed.
 
 (** Invariance by external calls *)
@@ -1633,7 +1796,7 @@ Lemma match_cont_extcall:
   match_cont f' cenv k tk m' bound tbound.
 Proof.
   intros. eapply match_cont_invariant; eauto.
-  intros. eapply Mem.load_unchanged_on; eauto.
+  intros. eapply Mem.loadbytes_unchanged_on; eauto.
   red in H2. intros. destruct (f b) as [[b' delta] | ] eqn:?. auto.
   destruct (f' b) as [[b' delta] | ] eqn:?; auto.
   exploit H2; eauto. unfold Mem.valid_block. intros [A B]. extlia.
@@ -1707,6 +1870,19 @@ Proof.
   eapply Mem.load_free. eauto. left. assert (Plt b' b) by eauto. unfold block; extlia.
 Qed.
 
+Remark free_list_loadbytes:
+  forall chunk b' l m m',
+  Mem.free_list m l = Some m' ->
+  (forall b lo hi, In (b, lo, hi) l -> Plt b' b) ->
+  Mem.loadbytes m' b' 0 (size_chunk chunk) = Mem.loadbytes m b' 0 (size_chunk chunk).
+Proof.
+  induction l; simpl; intros.
+  inv H; auto.
+  destruct a. destruct p. destruct (Mem.free m b z0 z) as [m1|] eqn:?; try discriminate.
+  transitivity (Mem.loadbytes m1 b' 0 (size_chunk chunk)). eauto.
+  eapply Mem.loadbytes_free. eauto. left. assert (Plt b' b) by eauto. unfold block; extlia.
+Qed.
+
 Lemma match_cont_free_env:
   forall f cenv e le m lo hi te tle tm tlo thi k tk m' tm',
   match_envs f cenv e le m lo hi te tle tlo thi ->
@@ -1719,7 +1895,7 @@ Lemma match_cont_free_env:
 Proof.
   intros. apply match_cont_incr_bounds with lo tlo.
   eapply match_cont_invariant; eauto.
-  intros. rewrite <- H7. eapply free_list_load; eauto.
+  intros. rewrite <- H7. eapply free_list_loadbytes; eauto.
   unfold blocks_of_env; intros. exploit list_in_map_inv; eauto.
   intros [[id [b1 ty]] [P Q]]. simpl in P. inv P.
   exploit me_range; eauto. eapply PTree.elements_complete; eauto. extlia.
@@ -2014,9 +2190,10 @@ End FIND_LABEL.
 
 
 Lemma step_simulation:
-  forall S1 t S2, step1 ge S1 t S2 ->
-  forall S1' (MS: match_states S1 S1'), exists S2', plus step2 tge S1' t S2' /\ match_states S2 S2'.
+  forall S1 t S2, IStep sem S1 t S2 ->
+  forall S1' (MS: match_states S1 S1'), exists S2', DPlus tsem S1' t S2' /\ match_states S2 S2'.
 Proof.
+  destruct 1. generalize dependent S2. rename H into INT.
   induction 1; simpl; intros; inv MS; simpl in *; try (monadInv TRS).
 
 (* assign *)
@@ -2040,12 +2217,12 @@ Proof.
   inv MV; congruence.
   (* not liftable *)
   intros P.
-  exploit eval_simpl_lvalue; eauto with compat. intros [tb [tofs [E F]]].
+  exploit eval_simpl_lvalue; eauto with compat. intros [tvp [E F]].
   exploit eval_simpl_expr; eauto with compat. intros [tv2 [A B]].
   exploit sem_cast_inject; eauto. intros [tv [C D]].
-  exploit assign_loc_inject; eauto. intros [tm' [X [Y Z]]].
+  exploit assign_loc_inject'; eauto. intros [tm' [X [Y Z]]].
   econstructor; split.
-  apply plus_one. econstructor. eexact E. eexact A. repeat rewrite typeof_simpl_expr. eexact C.
+  apply plus_one. DStep_tac2. econstructor. eexact E. eexact A. repeat rewrite typeof_simpl_expr. eexact C.
   rewrite typeof_simpl_expr; auto. eexact X.
   econstructor; eauto with compat.
   eapply match_envs_invariant; eauto.
@@ -2056,7 +2233,7 @@ Proof.
 (* set temporary *)
   exploit eval_simpl_expr; eauto with compat. intros [tv [A B]].
   econstructor; split.
-  apply plus_one. econstructor. eauto.
+  apply plus_one. DStep_tac2. econstructor. eauto.
   econstructor; eauto with compat.
   eapply match_envs_set_temp; eauto.
 
@@ -2065,7 +2242,7 @@ Proof.
   exploit eval_simpl_exprlist; eauto with compat. intros [CASTED [tvargs [C D]]].
   exploit match_cont_find_funct; eauto. intros [tfd [P Q]].
   econstructor; split.
-  apply plus_one. eapply step_call with (fd := tfd).
+  apply plus_one. DStep_tac2. eapply step_call with (fd := tfd).
   rewrite typeof_simpl_expr. eauto.
   eauto. eauto. eauto.
   erewrite type_of_fundef_preserved; eauto.
@@ -2073,11 +2250,12 @@ Proof.
   intros. econstructor; eauto.
 
 (* builtin *)
+  unfold is_internal in INT. ss. exploit external_call_spec; eauto. intros DETERM.
   exploit eval_simpl_exprlist; eauto with compat. intros [CASTED [tvargs [C D]]].
   exploit external_call_mem_inject; eauto. apply match_globalenvs_preserves_globals; eauto with compat.
   intros [j' [tvres [tm' [P [Q [R [S [T [U V]]]]]]]]].
   econstructor; split.
-  apply plus_one. econstructor; eauto. eapply external_call_symbols_preserved; eauto. apply senv_preserved.
+  apply plus_one. DStep_tac2. econstructor; eauto. eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   econstructor; eauto with compat.
   eapply match_envs_set_opttemp; eauto.
   eapply match_envs_extcall; eauto.
@@ -2087,48 +2265,48 @@ Proof.
   eapply Ple_trans; eauto. eapply external_call_nextblock; eauto.
 
 (* sequence *)
-  econstructor; split. apply plus_one. econstructor.
+  econstructor; split. apply plus_one. DStep_tac2. econstructor.
   econstructor; eauto with compat. econstructor; eauto with compat.
 
 (* skip sequence *)
-  inv MCONT. econstructor; split. apply plus_one. econstructor. econstructor; eauto.
+  inv MCONT. econstructor; split. apply plus_one. DStep_tac2. econstructor. econstructor; eauto.
 
 (* continue sequence *)
-  inv MCONT. econstructor; split. apply plus_one. econstructor. econstructor; eauto.
+  inv MCONT. econstructor; split. apply plus_one. DStep_tac2. econstructor. econstructor; eauto.
 
 (* break sequence *)
-  inv MCONT. econstructor; split. apply plus_one. econstructor. econstructor; eauto.
+  inv MCONT. econstructor; split. apply plus_one. DStep_tac2. econstructor. econstructor; eauto.
 
 (* ifthenelse *)
   exploit eval_simpl_expr; eauto with compat. intros [tv [A B]].
   econstructor; split.
-  apply plus_one. apply step_ifthenelse with (v1 := tv) (b := b). auto.
+  apply plus_one. DStep_tac2. apply step_ifthenelse with (v1 := tv) (b := b). auto.
   rewrite typeof_simpl_expr. eapply bool_val_inject; eauto.
   destruct b; econstructor; eauto with compat.
 
 (* loop *)
-  econstructor; split. apply plus_one. econstructor. econstructor; eauto with compat. econstructor; eauto with compat.
+  econstructor; split. apply plus_one. DStep_tac2. econstructor. econstructor; eauto with compat. econstructor; eauto with compat.
 
 (* skip-or-continue loop *)
   inv MCONT. econstructor; split.
-  apply plus_one. econstructor. destruct H; subst x; simpl in *; intuition congruence.
+  apply plus_one. DStep_tac2. des; subst; ss; clarify. econstructor. destruct H; subst x; simpl in *; intuition congruence.
   econstructor; eauto with compat. econstructor; eauto with compat.
 
 (* break loop1 *)
-  inv MCONT. econstructor; split. apply plus_one. eapply step_break_loop1.
+  inv MCONT. econstructor; split. apply plus_one. DStep_tac2. eapply step_break_loop1.
   econstructor; eauto.
 
 (* skip loop2 *)
-  inv MCONT. econstructor; split. apply plus_one. eapply step_skip_loop2.
+  inv MCONT. econstructor; split. apply plus_one. DStep_tac2. eapply step_skip_loop2.
   econstructor; eauto with compat. simpl; rewrite H2; rewrite H4; auto.
 
 (* break loop2 *)
-  inv MCONT. econstructor; split. apply plus_one. eapply step_break_loop2.
+  inv MCONT. econstructor; split. apply plus_one. DStep_tac2. eapply step_break_loop2.
   econstructor; eauto.
 
 (* return none *)
   exploit match_envs_free_blocks; eauto. intros [tm' [P Q]].
-  econstructor; split. apply plus_one. econstructor; eauto.
+  econstructor; split. apply plus_one. DStep_tac2. econstructor; eauto.
   econstructor; eauto.
   intros. eapply match_cont_call_cont. eapply match_cont_free_env; eauto.
 
@@ -2136,14 +2314,14 @@ Proof.
   exploit eval_simpl_expr; eauto with compat. intros [tv [A B]].
   exploit sem_cast_inject; eauto. intros [tv' [C D]].
   exploit match_envs_free_blocks; eauto. intros [tm' [P Q]].
-  econstructor; split. apply plus_one. econstructor; eauto.
+  econstructor; split. apply plus_one. DStep_tac2. econstructor; eauto.
   rewrite typeof_simpl_expr. monadInv TRF; simpl. eauto.
   econstructor; eauto.
   intros. eapply match_cont_call_cont. eapply match_cont_free_env; eauto.
 
 (* skip call *)
   exploit match_envs_free_blocks; eauto. intros [tm' [P Q]].
-  econstructor; split. apply plus_one. econstructor; eauto.
+  econstructor; split. apply plus_one. DStep_tac2. econstructor; eauto.
   eapply match_cont_is_call_cont; eauto.
   monadInv TRF; auto.
   econstructor; eauto.
@@ -2151,7 +2329,7 @@ Proof.
 
 (* switch *)
   exploit eval_simpl_expr; eauto with compat. intros [tv [A B]].
-  econstructor; split. apply plus_one. econstructor; eauto.
+  econstructor; split. apply plus_one. DStep_tac2. econstructor; eauto.
   rewrite typeof_simpl_expr. instantiate (1 := n).
   unfold sem_switch_arg in *;
   destruct (classify_switch (typeof a)); try discriminate;
@@ -2164,16 +2342,16 @@ Proof.
 
 (* skip-break switch *)
   inv MCONT. econstructor; split.
-  apply plus_one. eapply step_skip_break_switch. destruct H; subst x; simpl in *; intuition congruence.
+  apply plus_one. DStep_tac2. des; subst; ss; clarify. eapply step_skip_break_switch. destruct H; subst x; simpl in *; intuition congruence.
   econstructor; eauto with compat.
 
 (* continue switch *)
   inv MCONT. econstructor; split.
-  apply plus_one. eapply step_continue_switch.
+  apply plus_one. DStep_tac2. eapply step_continue_switch.
   econstructor; eauto with compat.
 
 (* label *)
-  econstructor; split. apply plus_one. econstructor. econstructor; eauto.
+  econstructor; split. apply plus_one. DStep_tac2. econstructor. econstructor; eauto.
 
 (* goto *)
   generalize TRF; intros TRF'. monadInv TRF'.
@@ -2182,7 +2360,7 @@ Proof.
     apply compat_cenv_for.
   rewrite H. intros [ts' [tk' [A [B [C D]]]]].
   econstructor; split.
-  apply plus_one. econstructor; eauto. simpl.
+  apply plus_one. DStep_tac2. econstructor; eauto. simpl.
   rewrite find_label_add_debug_params. rewrite find_label_store_params. rewrite find_label_add_debug_vars. eexact A.
   econstructor; eauto.
 
@@ -2213,7 +2391,7 @@ Proof.
   generalize (vars_and_temps_properties (cenv_for f) (fn_params f) (fn_vars f) (fn_temps f)).
   intros [X [Y Z]]. auto. auto.
   econstructor; split.
-  eapply plus_left. econstructor.
+  eapply plus_left. DStep_tac2. econstructor.
   econstructor. exact Y. exact X. exact Z. simpl. eexact A. simpl. eexact Q.
   simpl. eapply star_trans. eapply step_add_debug_params. auto. eapply forall2_val_casted_inject; eauto. eexact Q.
   eapply star_trans. eexact P. eapply step_add_debug_vars.
@@ -2222,23 +2400,25 @@ Proof.
   reflexivity. reflexivity. traceEq.
   econstructor; eauto.
   eapply match_cont_invariant; eauto.
-  intros. transitivity (Mem.load chunk m0 b 0).
-  eapply bind_parameters_load; eauto. intros.
+  intros. transitivity (Mem.loadbytes m0 b 0 (size_chunk chunk)).
+  eapply bind_parameters_loadbytes; eauto. intros.
   exploit alloc_variables_range. eexact H1. eauto.
   unfold empty_env. rewrite PTree.gempty. intros [?|?]. congruence.
   red; intros; subst b'. extlia.
-  eapply alloc_variables_load; eauto.
+  eapply alloc_variables_loadbytes; eauto.
   apply compat_cenv_for.
   rewrite (bind_parameters_nextblock _ _ _ _ _ _ H2). extlia.
   rewrite T; extlia.
 
 (* external function *)
   monadInv TRFD. inv FUNTY.
-  exploit external_call_mem_inject; eauto. apply match_globalenvs_preserves_globals.
+  unfold is_internal in INT. ss.
+  exploit external_call_mem_inject; eauto. eapply external_call_spec; eauto.
+  apply match_globalenvs_preserves_globals.
   eapply match_cont_globalenv. eexact (MCONT VSet.empty).
   intros [j' [tvres [tm' [P [Q [R [S [T [U V]]]]]]]]].
   econstructor; split.
-  apply plus_one. econstructor; eauto. eapply external_call_symbols_preserved; eauto. apply senv_preserved.
+  apply plus_one. DStep_tac2. econstructor; eauto. eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   econstructor; eauto.
   intros. apply match_cont_incr_bounds with (Mem.nextblock m) (Mem.nextblock tm).
   eapply match_cont_extcall; eauto. extlia. extlia.
@@ -2248,7 +2428,7 @@ Proof.
 (* return *)
   specialize (MCONT (cenv_for f)). inv MCONT.
   econstructor; split.
-  apply plus_one. econstructor.
+  apply plus_one. DStep_tac2. econstructor.
   econstructor; eauto with compat.
   eapply match_envs_set_opttemp; eauto.
 Qed.
@@ -2281,6 +2461,99 @@ Proof.
   constructor.
 Qed.
 
+Lemma match_states_bsim
+      s1 (EXT: is_external ge s1)
+      s2 t s2'
+      (STEPTGT: Step tsem s2 t s2')
+      (MATCH: match_states s1 s2)
+      (SAFESRC: safe sem s1) :
+    (exists s1', Step sem s1 t s1' /\ match_states s1' s2')
+    \/ (~ trace_intact t /\ exists s1'' t', Star sem s1 t' s1'' /\ exists tl, t' = (trace_cut_pterm t) ** tl).
+Proof.
+  assert (SEQUIV: Senv.equiv tge ge) by (symmetry; apply senv_preserved).
+  unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+  { inv SAFESRC. inv MATCH. inv RINJ. inv STEPTGT. specialize (MCONT VSet.empty). inv MCONT. }
+  unfold is_external in *. des_ifs.
+  (* builtin *)
+  - i. inv MATCH; try (monadInv TRS); clarify.
+    inv STEPTGT; ss; clarify; try (by (des; clarify)).
+    inv SAFESRC; ss; clarify; try (by (des; clarify)).
+
+    exploit eval_simpl_exprlist; eauto with compat. intros [CASTED [tvargs [C D]]].
+    exploit ClightD.eval_exprlist_determ. eapply H10. eapply C. i. subst.
+
+    exploit external_call_mem_inject_backward.
+    2:{ eapply (match_globalenvs_preserves_globals j). eapply match_cont_globalenv. eauto. }
+    2:{ eapply external_call_symbols_preserved; eauto. }
+    all: eauto. i. des.
+    + left. esplits; eauto. eapply step_builtin; eauto.
+      econstructor; eauto with compat.
+      eapply match_envs_set_opttemp; eauto.
+      eapply match_envs_extcall; eauto.
+      eapply match_cont_extcall; eauto.
+      inv MENV; extlia. inv MENV; extlia.
+      eapply Ple_trans; eauto. eapply external_call_nextblock; eauto.
+      eapply Ple_trans; eauto. eapply external_call_nextblock; eauto.
+    + exploit H; eauto. clarify.
+    + right. esplits; eauto. eapply star_one. eapply step_builtin; eauto.
+  (* external call *)
+  - i. inv MATCH; try (monadInv TRS); clarify.
+    inv STEPTGT; ss; clarify; try (by (des; clarify)).
+    inv SAFESRC; ss; clarify; try (by (des; clarify)).
+
+    exploit external_call_mem_inject_backward.
+    2: { eapply (match_globalenvs_preserves_globals j). eapply match_cont_globalenv. eauto. }
+    2: { eapply external_call_symbols_preserved; eauto. }
+    all: eauto. i. des.
+    + left. esplits; eauto. eapply step_external_function; eauto.
+      econstructor; eauto.
+      intros. apply match_cont_incr_bounds with (Mem.nextblock m) (Mem.nextblock tm).
+      eapply match_cont_extcall; eauto. extlia. extlia.
+      eapply external_call_nextblock; eauto.
+      eapply external_call_nextblock; eauto.
+    + exploit H; eauto. clarify.
+    + right. esplits; eauto. eapply star_one. eapply step_external_function; eauto.
+      Unshelve. eapply VSet.empty.
+Qed.
+
+Lemma match_states_xsim st_src0 st_tgt0 gmtgt
+    (MATCH: match_states st_src0 st_tgt0) :
+  xsim (semantics1 prog) (semantics2 tprog) gmtgt lt 0%nat st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold. destruct (classic (is_external ge st_src0)); cycle 1.
+  (* not external *)
+  - left. econs. econs.
+    + i. exploit step_simulation; eauto. i. des.
+      * esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl|].
+        left. split; eauto. eapply ClightD.semantics1_receptive_at; auto.
+    + ii. eapply final_state_determ; eauto. inv FINALSRC. inv MATCH. inv RINJ.
+      specialize (MCONT VSet.empty). ss. inv MCONT. econs.
+  (* external *)
+  - right. econs. i. econs.
+    + i. exploit match_states_bsim; eauto. i. des.
+      * left. esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl|].
+        left. eapply plus_one. eauto.
+      * right. esplits; eauto. subst. eapply tr_rel_refl. eapply ev_rel_refl.
+    + i. unfold is_external in *. des_ifs; inv FINALTGT; inv MATCH.
+    (* progress *)
+    + i. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify; [inv SAFESRC; ss|].
+      right. inv SAFESRC; ss; clarify; try (by (des; clarify)); inv MATCH; try (monadInv TRS).
+      * exploit eval_simpl_exprlist; eauto with compat. i. des.
+        exploit external_call_mem_inject_backward_progress; eauto.
+        eapply match_globalenvs_preserves_globals.
+        eapply match_cont_globalenv. eauto. i. des.
+        esplits. eapply step_builtin; eauto.
+        eapply external_call_symbols_preserved; eauto. eapply senv_preserved.
+      * monadInv TRFD. inv FUNTY.
+        exploit external_call_mem_inject_backward_progress; eauto.
+        eapply match_globalenvs_preserves_globals.
+        eapply match_cont_globalenv. eauto. i. des.
+        exploit external_call_symbols_preserved. apply senv_preserved. eauto. i.
+        esplits. eapply step_external_function; eauto.
+      Unshelve. eapply VSet.empty.
+Qed.
+
 Lemma final_states_simulation:
   forall S R r,
   match_states S R -> final_state S r -> final_state R r.
@@ -2290,14 +2563,73 @@ Proof.
   inv RINJ. constructor.
 Qed.
 
+Lemma non_static_equiv j l hi (MGE: match_globalenvs j hi):
+  Forall2 (fun b b' => (j b = Some (b', 0)) /\ b = b') (Genv.non_static_glob (Genv.globalenv prog) l) (Genv.non_static_glob (Genv.globalenv tprog) l).
+Proof.
+  induction l; ss.
+  destruct (Genv.find_symbol (Genv.globalenv prog) a) eqn:FS1; cycle 1.
+  - destruct (Genv.find_symbol (Genv.globalenv tprog) a) eqn:FS2; cycle 1.
+    { unfold Genv.public_symbol. des_ifs. }
+    destruct senv_preserved. des. unfold Senv.find_symbol in *. ss. erewrite H in FS2.
+    Local Transparent ge tge. unfold ge, fundef in *. ss. clarify.
+  - destruct (Genv.public_symbol (Genv.globalenv prog) a) eqn:PS1; cycle 1.
+    { des_ifs. destruct senv_preserved. des. ss. erewrite H0 in Heq. unfold ge, fundef in *. clarify. }
+    destruct senv_preserved. des. ss. erewrite <- H0 in PS1.
+    unfold tge, fundef in *. erewrite PS1. erewrite H, FS1. econs; eauto. inv MGE. esplits; eauto.
+Qed.
+
+
+Lemma transf_initial_capture f tfd tk m1 m2 S2'
+    (INITSRC: initial_state prog (Callstate f [] Kstop m1))
+    (INITTGT: initial_state tprog (Callstate tfd [] tk m2))
+    (MATCH: match_states (Callstate f [] Kstop m1) (Callstate tfd [] tk m2))
+    (CAPTGT: glob_capture tprog (Callstate tfd [] tk m2) S2'):
+  exists S1', glob_capture prog (Callstate f [] Kstop m1) S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (concrete_snapshot ge S1') (concrete_snapshot tge S2').
+Proof.
+  specialize senv_preserved. intros SENVEQ. inv CAPTGT. ss. rename m' into m2'.
+  rewrite Genv.globalenv_public in CAPTURE. erewrite <- same_public' in CAPTURE; eauto.
+  inv MATCH. specialize (MCONT VSet.empty). inv MCONT.
+  exploit non_static_equiv. eapply H. instantiate (1:=AST.prog_public prog). intros EQUIV.
+  inv ANORM. inv AINJ.
+  assert (exists m1', Genv.capture_init_mem m1 (Genv.non_static_glob (Genv.globalenv prog) (AST.prog_public prog)) m1' /\
+                     Mem.inject j m1' m2').
+  { clear - SENVEQ MINJ EQUIV CAPTURE. ginduction EQUIV; ss; ii.
+    - exists m1. inv CAPTURE. inv CAP. esplits; eauto. econs. econs.
+    - inv CAPTURE. inv CAP. des; subst.
+      exploit Mem.capture_inject_backward; try eapply INJ; eauto.
+      { instantiate (2:=addr). instantiate (1:= m0). rewrite Z.sub_0_r. eauto. }
+      i. des. exploit IHEQUIV; try eapply MEM. eauto. econs; eauto. i. des.
+      inv H0. esplits; eauto. econs; eauto. econs; eauto. }
+  des. esplits; eauto.
+  - econs; try eapply H2; eauto. ss. erewrite same_public''. rewrite Genv.globalenv_public. eauto.
+  - econs; eauto; cycle 1; [econs|]. i. econs; eauto.
+    { inv H2. exploit Mem.capture_list_nextblock; eauto. i. erewrite <- H2. eauto. }
+    { inv CAPTURE. exploit Mem.capture_list_nextblock; eauto. i. erewrite <- H4. eauto. }
+  - ii. unfold concrete_snapshot in *. inv SENVEQ. des. erewrite H6, H5. des_ifs; ss.
+    assert (j b = Some (b, 0)).
+    { inv H. exploit SYMBOLS; eauto. }
+    inv H3. exploit mi_src_concrete_public; eauto. i. erewrite H3. f_equal. lia.
+Qed.
+
+
 Theorem transf_program_correct:
-  forward_simulation (semantics1 prog) (semantics2 tprog).
-Proof.
-  eapply forward_simulation_plus.
-  apply senv_preserved.
-  eexact initial_states_simulation.
-  eexact final_states_simulation.
-  eexact step_simulation.
+  mixed_simulation (semantics1 prog) (semantics2 tprog).
+Proof.
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (S a). lia.
+  - econs. i. exploit initial_states_simulation; eauto. i. des.
+    exists R. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. inversion INITSRC; subst. inversion H0; subst.
+      inv AINJ. inv ANORM. exploit transf_initial_capture
+      ; [eapply INITSRC|eapply H|eapply H0|eauto|]. i. des.
+      exists 0%nat. esplits; eauto. apply match_states_xsim; auto.
+  - i. apply senv_preserved.
 Qed.
 
 End PRESERVATION.
diff --git a/common/AST.v b/common/AST.v
index 2259d74c..0108ccd0 100644
--- a/common/AST.v
+++ b/common/AST.v
@@ -505,10 +505,11 @@ Inductive external_function : Type :=
          used with caution, as it can invalidate the semantic
          preservation theorem.  Generated only if [-finline-asm] is
          given. *)
-  | EF_debug (kind: positive) (text: ident) (targs: list typ).
+  | EF_debug (kind: positive) (text: ident) (targs: list typ)
      (** Transport debugging information from the front-end to the generated
          assembly.  Takes zero, one or several arguments like [EF_annot].
          Unlike [EF_annot], produces no observable event. *)
+  | EF_capture.
 
 (** The type signature of an external function. *)
 
@@ -526,6 +527,7 @@ Definition ef_sig (ef: external_function): signature :=
   | EF_annot_val kind text targ => mksignature (targ :: nil) targ cc_default
   | EF_inline_asm text sg clob => sg
   | EF_debug kind text targs => mksignature targs Tvoid cc_default
+  | EF_capture => mksignature (Tptr :: nil) (if Archi.ptr64 then Tlong else Tint) cc_default
   end.
 
 (** Whether an external function should be inlined by the compiler. *)
@@ -544,6 +546,11 @@ Definition ef_inline (ef: external_function) : bool :=
   | EF_annot_val kind Text rg => true
   | EF_inline_asm text sg clob => true
   | EF_debug kind text targs => true
+  | EF_capture => false (* true ? *)
+    (*  *)
+    (* : I "guess" it should be inlinable, but I'm not confident... please investigate the semantics of ef_inline *)
+    (*  : When the language transport Cminor to CminorSel, external calls with ef_inline true are treated as builtin functions. *)
+    (* Assuming Capture is inlineable, we can see that some of the builtin functions are non-deterministic. *)                               
   end.
 
 (** Whether an external function must reload its arguments. *)
diff --git a/common/Behaviors.v b/common/Behaviors.v
index 023b33e2..09a1ac20 100644
--- a/common/Behaviors.v
+++ b/common/Behaviors.v
@@ -22,27 +22,166 @@ Require Import Coqlib.
 Require Import Events.
 Require Import Globalenvs.
 Require Import Integers.
-Require Import Smallstep.
+Require Import Simulation.
+Require Import sflib.
+From Paco Require Import paco.
+Require Import Coq.Relations.Relation_Operators.
 
 Set Implicit Arguments.
 
+Section FOREVERCOIND.
+
+Variable L1: semantics.
+ 
+Definition _forever_reactive2 (forever_reactive2: state L1 -> traceinf -> Prop)
+  (s1: state L1) (T1: traceinf) : Prop :=
+  exists s2 t T2 (INTACT: trace_intact t),
+    Star L1 s1 t s2 /\ t <> E0 /\ forever_reactive2 s2 T2 /\ T1 = t *** T2.
+
+
+(*     _forever_reactive2 forever_reactive2 s1 (t *** T) *)
+(* . *)
+
+Lemma forever_reactive_mon: monotone2 _forever_reactive2.
+Proof. ii. inv IN. des. econs. esplits; eauto. Qed.
+
+Hint Resolve forever_reactive_mon: paco.
+
+Definition forever_reactive2 := paco2 _forever_reactive2 bot2.
+Arguments forever_reactive2: clear implicits.
+
+Lemma forever_reactive2_forever_reactive:
+  forever_reactive2 <2= Forever_reactive L1.
+Proof.
+  cofix CIH. i. punfold PR. inv PR. des. pclearbot.
+  eapply CIH in H1. subst. econs; eauto.
+Qed.
+
+Lemma forever_reactive_forever_reactive2:
+  Forever_reactive L1 <2= forever_reactive2.
+Proof.
+  pcofix CIH. i. destruct PR. inv PR.
+  pstep. econs. esplits; cycle 1.
+  { eapply star_trans; eauto. }
+  { destruct t, t0; ss. }
+  { right. eapply CIH; eauto. }
+  { traceEq. }
+  eapply trace_intact_app; eauto.
+Qed.
+
+Variant star_clo (r: state L1 -> traceinf -> Prop)
+        (s1: state L1) (T: traceinf): Prop :=
+| silent_star_clo_intro
+    s1' t T'
+    (STAR: Star L1 s1 t s1')
+    (REL: r s1' T')
+    (TRACE: T = t *** T')
+    (INTACT: trace_intact t).
+
+Lemma star_clo_compatible:
+  compatible2 _forever_reactive2 star_clo.
+Proof.
+  econs. { ii. inv IN. econs; eauto. }
+  i. inv PR. inv REL. des. subst. rewrite <- Eappinf_assoc. econs. esplits.
+  { eapply trace_intact_app. eapply INTACT. eapply INTACT0. }
+  { eapply star_trans; eauto. }
+  { ii. eapply Eapp_E0_inv in H2. des; ss. }
+  2:{ traceEq. }
+  econs; [eapply star_refl | | |]; eauto; ss.
+Qed.
+
+Definition _forever_silent2 (forever_silent2: state L1 ->  Prop) (s1: state L1) : Prop :=
+  exists s2, Step L1 s1 E0 s2 /\ forever_silent2 s2.
+
+Lemma forever_silent_mon: monotone1 _forever_silent2.
+Proof. ii. inv IN. des. econs. esplits; eauto. Qed.
+
+Hint Resolve forever_silent_mon: paco.
+
+Definition forever_silent2 := paco1 _forever_silent2 bot1.
+Arguments forever_silent2: clear implicits.
+
+Lemma forever_silent2_forever_silent:
+  forever_silent2 <1= Forever_silent L1.
+Proof.
+  cofix CIH. i. punfold PR. inv PR. des. pclearbot.
+  eapply CIH in H0. subst. econs; eauto.
+Qed.
+
+Lemma forever_silent_forever_silent2:
+  Forever_silent L1 <1= forever_silent2.
+Proof.
+  pcofix CIH. i. destruct PR.
+  pstep. econs. esplits; cycle 1.
+  { right. eapply CIH; eauto. }
+  eauto.
+Qed.
+
+Variable index: Type.
+Variable order: index -> index -> Prop.
+
+Inductive _forever_silent_N2 (forever_silent_N2: index -> state L1 ->  Prop) : index -> L1.(state) -> Prop :=
+| _forever_silent_N2_star
+    s1 s2 i1 i2
+    (STAR: Star L1 s1 E0 s2)
+    (ORD: order i2 i1)
+    (SIL: forever_silent_N2 i2 s2):
+  _forever_silent_N2 forever_silent_N2 i1 s1
+| _forever_silent_N2_plus
+    s1 s2 i1 i2
+    (STAR: Plus L1 s1 E0 s2)
+    (SIL: forever_silent_N2 i2 s2):
+  _forever_silent_N2 forever_silent_N2 i1 s1.
+
+Definition forever_silent_N2 := paco2 _forever_silent_N2 bot2.
+Arguments forever_silent2: clear implicits.
+
+Lemma forever_silent_N_mon: monotone2 _forever_silent_N2.
+Proof. ii. inv IN; [econs; eauto| econs 2; eauto]. Qed.
+
+Hint Resolve forever_silent_N_mon: paco.
+
+Lemma forever_silent_N2_forever_silent_N:
+  forever_silent_N2 <2= forever_silent_N (step L1) order (globalenv L1).
+Proof.
+  cofix CIH. i. punfold PR. inv PR; pclearbot.
+  - eapply CIH in SIL. econs; eauto.
+  - eapply CIH in SIL. econs 2; eauto.
+Qed.
+
+Lemma forever_silent_N_forever_silent_N2:
+  forever_silent_N (step L1) order (globalenv L1) <2= forever_silent_N2.
+Proof.
+  pcofix CIH. i. destruct PR.
+  - pstep. econs; cycle 1; eauto.
+  - pstep. econs 2; cycle 1; eauto.
+Qed.
+
+End FOREVERCOIND.
+
+Hint Resolve forever_reactive_mon: paco.
+Hint Resolve forever_silent_mon: paco.
+Hint Resolve forever_silent_N_mon: paco.
+Hint Resolve cpn2_wcompat: paco.
+
 (** * Behaviors for program executions *)
 
-(** The four possible outcomes for the execution of a program:
-- Termination, with a finite trace of observable events
-  and an integer value that stands for the process exit code
-  (the return value of the main function).
-- Divergence with a finite trace of observable events.
-  (At some point, the program runs forever without doing any I/O.)
-- Reactive divergence with an infinite trace of observable events.
-  (The program performs infinitely many I/O operations separated
-   by finite amounts of internal computations.)
-- Going wrong, with a finite trace of observable events
-  performed before the program gets stuck.
-*)
+(** The four possible outcomes for the execution of a program: *)
+(* - Termination, with a finite trace of observable events *)
+(*   and an integer value that stands for the process exit code *)
+(*   (the return value of the main function). *)
+(* - Divergence with a finite trace of observable events. *)
+(*   (At some point, the program runs forever without doing any I/O.) *)
+(* - Reactive divergence with an infinite trace of observable events. *)
+(*   (The program performs infinitely many I/O operations separated *)
+(*    by finite amounts of internal computations.) *)
+(* - Going wrong, with a finite trace of observable events *)
+(*   performed before the program gets stuck. *)
+(* *)
 
 Inductive program_behavior: Type :=
   | Terminates: trace -> int -> program_behavior
+  | Partial_terminates: trace -> program_behavior
   | Diverges: trace -> program_behavior
   | Reacts: traceinf -> program_behavior
   | Goes_wrong: trace -> program_behavior.
@@ -52,14 +191,25 @@ Inductive program_behavior: Type :=
 Definition not_wrong (beh: program_behavior) : Prop :=
   match beh with
   | Terminates _ _ => True
+  | Partial_terminates _ => True
   | Diverges _ => True
   | Reacts _ => True
   | Goes_wrong _ => False
   end.
 
+Definition intact (beh: program_behavior) : Prop :=
+  match beh with
+  | Terminates _ _ => True
+  | Partial_terminates _ => False
+  | Diverges _ => True
+  | Reacts _ => True
+  | Goes_wrong _ => True
+  end.
+
 Definition behavior_app (t: trace) (beh: program_behavior): program_behavior :=
   match beh with
   | Terminates t1 r => Terminates (t ** t1) r
+  | Partial_terminates t1 => Partial_terminates (t ** t1)
   | Diverges t1 => Diverges (t ** t1)
   | Reacts T => Reacts (t *** T)
   | Goes_wrong t1 => Goes_wrong (t ** t1)
@@ -81,41 +231,344 @@ Qed.
 Definition behavior_prefix (t: trace) (beh: program_behavior) : Prop :=
   exists beh', beh = behavior_app t beh'.
 
-Definition behavior_improves (beh1 beh2: program_behavior) : Prop :=
-  beh1 = beh2 \/ exists t, beh1 = Goes_wrong t /\ behavior_prefix t beh2.
 
-Lemma behavior_improves_refl:
-  forall beh, behavior_improves beh beh.
+Variant _trinf_rel (evr: event -> event -> Prop) (trinf_rel: traceinf -> traceinf -> Prop) : traceinf -> traceinf -> Prop :=
+| trinf_rel_intro
+    es et trs trt
+    (EVR: evr es et)
+    (TIR: trinf_rel trs trt):
+  _trinf_rel evr trinf_rel (Econsinf es trs) (Econsinf et trt).
+
+Definition trinf_rel evr : _ -> _ -> Prop := paco2 (_trinf_rel evr) bot2.
+
+Lemma trinf_rel_mon ev_rel:
+  monotone2 (_trinf_rel ev_rel).
+Proof. ii. inv IN; econs; eauto. Qed.
+
+Hint Unfold trinf_rel.
+Hint Resolve trinf_rel_mon: paco.
+
+Lemma trinf_rel_refl pm t:
+  trinf_rel (ev_rel pm) t t.
+Proof.
+  revert t. pcofix CIH. i. pfold.
+  destruct t. econs; [eapply ev_rel_refl|]. right. eauto.
+Qed.
+
+Lemma trinf_rel_app
+    ev_rel tr1 tr1' tr2 tr2'
+    (TR1: tr_rel ev_rel tr1 tr1')
+    (TR2: trinf_rel ev_rel tr2 tr2') :
+  trinf_rel ev_rel (tr1 *** tr2) (tr1' *** tr2').
+Proof.
+  ginduction TR1; ss; i. pfold. econs; eauto. left. eapply IHTR1; eauto.
+Qed.
+
+Lemma trinf_rel_div_l
+    ev_rel t t1 t2
+    (TRREL: trinf_rel ev_rel (t1 *** t2) t):
+  exists t1' t2', t = t1' *** t2' /\
+             tr_rel ev_rel t1 t1' /\
+             trinf_rel ev_rel t2 t2'.
+Proof.
+  ginduction t1; ss.
+  - i. exists E0. exists t. esplits; traceEq. econs.
+  - i. punfold TRREL. inv TRREL. pclearbot. exploit IHt1; eauto. i. des.
+    subst. exists (et :: t1'). exists t2'. ss. esplits; eauto. econs; eauto.
+Qed.
+
+Lemma trinf_rel_div_r
+    ev_rel t t1' t2'
+    (TRREL: trinf_rel ev_rel t (t1' *** t2')):
+  exists t1 t2, t = t1 *** t2 /\
+           tr_rel ev_rel t1 t1' /\
+           trinf_rel ev_rel t2 t2'.
+Proof.
+  ginduction t1'; ss.
+  - i. exists E0. exists t. esplits; traceEq. econs.
+  - i. punfold TRREL. inv TRREL. pclearbot. exploit IHt1'; eauto. i. des.
+    subst. exists (es :: t1). exists t2. ss. esplits; eauto. econs; eauto.
+Qed.
+
+Definition pimap := (positive -> option Z).
+Definition pimap' := option pimap.
+
+(* eq *)
+Definition behav_rel (pm: pimap) (beh1 beh2: program_behavior) : Prop :=
+  match beh1, beh2 with
+  | Terminates t1 i1, Terminates t2 i2 => tr_rel (ev_rel pm) t1 t2 /\ i1 = i2
+  | Partial_terminates t1, Partial_terminates t2 => tr_rel (ev_rel pm) t1 t2
+  | Diverges t1, Diverges t2 => tr_rel (ev_rel pm) t1 t2
+  | Reacts t1, Reacts t2 => trinf_rel (ev_rel pm) t1 t2
+  | Goes_wrong t1, Goes_wrong t2 => tr_rel (ev_rel pm) t1 t2
+  | _, _ => False
+  end.
+
+Lemma behav_rel_refl pm beh: behav_rel pm beh beh.
+Proof.
+  destruct beh; ss; eauto.
+  - split; eauto. eapply tr_rel_refl. eapply ev_rel_refl.
+  - eapply tr_rel_refl. eapply ev_rel_refl.
+  - eapply tr_rel_refl. eapply ev_rel_refl.
+  - eapply trinf_rel_refl.
+  - eapply tr_rel_refl. eapply ev_rel_refl.
+Qed.
+
+Definition program_observation : Type := pimap' * program_behavior.
+(* name: (block -> option z) * program_behavior = program_observation *)
+
+Definition behavior_improves (pm: pimap) (beh1 beh2: program_behavior) :=
+  (behav_rel pm beh1 beh2
+   \/ (exists t t', beh1 = Goes_wrong t /\ tr_rel (ev_rel pm) t t' /\ behavior_prefix t' beh2)
+   \/ (exists t' t, beh2 = Partial_terminates t' /\ tr_rel (ev_rel pm) t t' /\ behavior_prefix t beh1)).
+
+Definition gm_improves' (pm1 pm2: pimap') : Prop :=
+  match pm1, pm2 with
+  | Some pim1, Some pim2 => gm_improves pim1 pim2
+  | _, None => True
+  | None, Some _ => False
+  end.
+  
+Definition observation_improves (obs1 obs2: program_observation) : Prop :=
+  let pm1 := fst obs1 in let pm2 := fst obs2 in
+  let beh1 := snd obs1 in let beh2 := snd obs2 in
+  (match pm2 with
+   | Some pim2 => behavior_improves pim2 beh1 beh2
+   | None => True
+   end) /\ (gm_improves' pm1 pm2).
+
+Lemma observation_improves_refl:
+  forall obs, observation_improves obs obs.
+Proof.
+  i. destruct obs; ss; r; ss. destruct p; ss. split; [|ii; eauto].
+  left. eapply behav_rel_refl.
+Qed.
+
+Lemma prefix_tr_rel pim beh1 beh2 t
+    (BREL: behav_rel pim beh1 beh2)
+    (PREF : behavior_prefix t beh1):
+  exists t', tr_rel (ev_rel pim) t t' /\ behavior_prefix t' beh2.
+Proof.
+  r in PREF. des. subst. unfold behav_rel in BREL.
+  des_ifs; unfold behavior_app in Heq; des_ifs.
+  - des. exploit tr_rel_div_l; eauto. i. des. subst.
+    exists t1'. esplits; eauto. rr. exists (Terminates t2' i0). ss.
+  - exploit tr_rel_div_l; eauto. i. des. subst.
+    exists t1'. esplits; eauto. rr. exists (Partial_terminates t2'). ss.
+  - exploit tr_rel_div_l; eauto. i. des. subst.
+    exists t1'. esplits; eauto. rr. exists (Diverges t2'). ss.
+  - exploit trinf_rel_div_l; eauto. i. des. subst.
+    exists t1'. esplits; eauto. rr. exists (Reacts t2'). ss.
+  - exploit tr_rel_div_l; eauto. i. des. subst.
+    exists t1'. esplits; eauto. rr. exists (Goes_wrong t2'). ss.
+Qed.
+
+Lemma prefix_tr_rel_r pim beh1 beh2 t'
+    (BREL: behav_rel pim beh1 beh2)
+    (PREF : behavior_prefix t' beh2):
+  exists t, tr_rel (ev_rel pim) t t' /\ behavior_prefix t beh1.
+Proof.
+  r in PREF. des. subst. unfold behav_rel in BREL.
+  des_ifs; unfold behavior_app in Heq; des_ifs.
+  - des. exploit tr_rel_div_r; eauto. i. des. subst.
+    exists t1'. esplits; eauto. rr. exists (Terminates t2' i0). ss.
+  - exploit tr_rel_div_r; eauto. i. des. subst.
+    exists t1'. esplits; eauto. rr. exists (Partial_terminates t2'). ss.
+  - exploit tr_rel_div_r; eauto. i. des. subst.
+    exists t1'. esplits; eauto. rr. exists (Diverges t2'). ss.
+  - exploit trinf_rel_div_r; eauto. i. des. subst.
+    exists t0. esplits; eauto. rr. exists (Reacts t2). ss.
+  - exploit tr_rel_div_r; eauto. i. des. subst.
+    exists t1'. esplits; eauto. rr. exists (Goes_wrong t2'). ss.
+Qed.
+
+Lemma evval_rel_trans
+    pm1 pm2 ev1 ev2 ev3
+    (IMP: gm_improves pm1 pm2)
+    (EV1: evval_rel pm1 ev1 ev2)
+    (EV2: evval_rel pm2 ev2 ev3):
+  evval_rel pm2 ev1 ev3.
+Proof.
+  unfold evval_rel in *. destruct ev1; ss; subst; destruct ev3; ss; try by des_ifs.
+  - des_ifs. des. split; eauto. unfold to_int_ev in *. des_ifs.
+  - des_ifs. des. split; eauto. unfold to_int_ev in *. des_ifs.
+    + unfold eventval_bind in EV2. clarify. exploit IMP; eauto. i; clarify.
+    + exploit IMP; eauto. i; clarify.
+Qed.
+
+Lemma evval_rel_list_trans
+    pm1 pm2 ev1 ev2 ev3
+    (IMP: gm_improves pm1 pm2)
+    (EV1: Forall2 (evval_rel pm1) ev1 ev2)
+    (EV2: Forall2 (evval_rel pm2) ev2 ev3):
+  Forall2 (evval_rel pm2) ev1 ev3.
+Proof.
+  ginduction EV1; ii; [inv EV2; econs|].
+  i. inv EV2. econs; eauto. eapply evval_rel_trans; eauto.
+Qed.
+
+Lemma ev_rel_trans
+    pm1 pm2 ev1 ev2 ev3
+    (IMP: gm_improves pm1 pm2)
+    (EV1: ev_rel pm1 ev1 ev2)
+    (EV2: ev_rel pm2 ev2 ev3):
+  ev_rel pm2 ev1 ev3.
+Proof.
+  destruct ev1; ss; subst; [inv EV2; eauto| | | | ].
+  - des_ifs. ss. des; subst; eauto. splits; eauto.
+    + eapply evval_rel_list_trans; eauto.
+    + eapply evval_rel_trans; eauto.
+  - des_ifs. ss. des; subst; eauto. splits; eauto.
+    eapply evval_rel_trans; eauto.
+  - des_ifs. ss. des; subst; eauto. splits; eauto.
+    eapply evval_rel_trans; eauto.
+  - des_ifs. ss. des; subst; eauto. splits; eauto.
+    eapply evval_rel_list_trans; eauto.
+Qed.
+
+Lemma tr_rel_trans
+    pm1 pm2 ev1 ev2 ev3
+    (IMP: gm_improves pm1 pm2)
+    (TR1: tr_rel (ev_rel pm1) ev1 ev2)
+    (TR2: tr_rel (ev_rel pm2) ev2 ev3):
+  tr_rel (ev_rel pm2) ev1 ev3.
+Proof.
+  ginduction TR1; ss. ii. inv TR2. econs; eauto.
+  { eapply ev_rel_trans; eauto. }
+  exploit IHTR1; eauto.
+Qed.
+
+Lemma tr_rel_trans'
+    pm ev1 ev2 ev3
+    (TR1: tr_rel (ev_rel pm) ev1 ev2)
+    (TR2: tr_rel (ev_rel pm) ev2 ev3):
+  tr_rel (ev_rel pm) ev1 ev3.
+Proof.
+  ginduction TR1; ss. ii. inv TR2. econs; eauto.
+  eapply ev_rel_trans; eauto. { rr; eauto. }
+  exploit IHTR1; eauto.
+Qed.
+
+Lemma trinf_rel_trans
+    pm1 pm2 ev1 ev2 ev3
+    (IMP: gm_improves pm1 pm2)
+    (TR1: trinf_rel (ev_rel pm1) ev1 ev2)
+    (TR2: trinf_rel (ev_rel pm2) ev2 ev3):
+  trinf_rel (ev_rel pm2) ev1 ev3.
 Proof.
-  intros; red; auto.
+  revert_until IMP. revert ev1 ev2 ev3. pcofix CIH. ii.
+  pfold. punfold TR1. inv TR1. punfold TR2. inv TR2. pclearbot. econs.
+  { eapply ev_rel_trans; eauto. }
+  right. eapply CIH; eauto.
 Qed.
 
-Lemma behavior_improves_trans:
-  forall beh1 beh2 beh3,
-  behavior_improves beh1 beh2 -> behavior_improves beh2 beh3 ->
-  behavior_improves beh1 beh3.
+Lemma observation_improves_trans:
+  forall obs1 obs2 obs3,
+  observation_improves obs1 obs2 -> observation_improves obs2 obs3 ->
+  observation_improves obs1 obs3.
 Proof.
-  intros. red. destruct H; destruct H0; subst; auto.
-  destruct H as [t1 [EQ1 [beh2' EQ1']]].
-  destruct H0 as [t2 [EQ2 [beh3' EQ2']]].
-  subst. destruct beh2'; simpl in EQ2; try discriminate. inv EQ2.
-  right. exists t1; split; auto. exists (behavior_app t beh3'). apply behavior_app_assoc.
+  i. destruct obs1 as [pm1 beh1]. destruct obs2 as [pm2 beh2]. destruct obs3 as [pm3 beh3].
+  split; ss; cycle 1.
+  { inv H; inv H0. ss. clear - H2 H3. unfold gm_improves' in *. des_ifs.
+    unfold gm_improves in *. i. eapply H3; eauto. }
+  inv H; inv H0. ss. unfold behavior_improves in *. destruct pm3; ss. des_ifs.
+  destruct pm1; ss. rename p into pm3. rename p0 into pm2. rename p1 into pm1. des.
+  - left. unfold behav_rel in *. des_ifs.
+    + split; des; subst; eauto. eapply tr_rel_trans; eauto.
+    + eapply tr_rel_trans; eauto.
+    + eapply tr_rel_trans; eauto.
+    + eapply trinf_rel_trans; eauto.
+    + eapply tr_rel_trans; eauto.
+  - right. left. exists t.
+    assert (exists t'', tr_rel (ev_rel pm3) t' t'' /\ behavior_prefix t'' beh3).
+    { eapply prefix_tr_rel; eauto. }
+    des. esplits; eauto. eapply tr_rel_trans; eauto.
+  - right. right.
+    subst. ss. des_ifs. exists t0. exists t. esplits; eauto. eapply tr_rel_trans; eauto.
+  - right. left.
+    subst. unfold behav_rel in H1. des_ifs. exists t0. exists t'. esplits; eauto. eapply tr_rel_trans; eauto.
+  - right. left. rewrite H1 in *. rewrite H in *. r in H6. des.
+    unfold behavior_app in H6. destruct beh'; ss. inv H6.
+    unfold behavior_prefix in H4.
+    exists t0. des. exploit tr_rel_div_l. eapply H0. i. des.
+    exists t1'. esplits; eauto.
+    { eapply tr_rel_trans; eauto. }
+    subst. erewrite behavior_app_assoc. rr. esplits; eauto.
+  - clarify.
+  - right. right. exists t'.
+    assert (exists t0, tr_rel (ev_rel pm3) t0 t' /\ behavior_prefix t0 beh1).
+    { exploit prefix_tr_rel_r; eauto. i. des. exists t0. esplit; eauto.
+      eapply tr_rel_trans; eauto. }
+    des. esplits; eauto.
+  - right. unfold behavior_prefix in *. subst. des. clarify.
+    assert (PREF: trace_prefix t'0 t \/ trace_prefix t t'0).
+    { assert ((exists t1 t2, t'0 ** t1 = t ** t2) \/ exists t1 t2, t'0 *** t1 = t *** t2).
+      { unfold behavior_app in *. des_ifs; eauto. }
+      des.
+      - clear -H. ginduction t'0; ss.
+        + i. left. unfold trace_prefix. exists t. traceEq.
+        + i. destruct t; ss.
+          { right. r. esplits; eauto; traceEq. }
+          inv H. exploit IHt'0; eauto. i. des.
+          { left. r. r in H. des. subst. exists t3. esplits; eauto; traceEq. }
+          right. r. r in H. des. subst. exists t3. esplits; eauto; traceEq.
+      - clear -H. ginduction t'0; ss.
+        + i. left. unfold trace_prefix. exists t. traceEq.
+        + i. destruct t; ss.
+          { right. r. esplits; eauto; traceEq. }
+          inv H. exploit IHt'0; eauto. i. des.
+          { left. r. r in H. des. subst. exists t3. esplits; eauto; traceEq. }
+          right. r. r in H. des. subst. exists t3. esplits; eauto; traceEq. }
+    des.
+    + unfold trace_prefix in PREF. des. subst.
+      exploit tr_rel_div_l; eauto. i. des; subst.
+      left. exists t0. exists t1'. esplits; eauto.
+      * eapply tr_rel_trans; eauto.
+      * instantiate (1:= Partial_terminates t2'). ss.
+    + unfold trace_prefix in PREF. des. subst.
+      exploit tr_rel_div_r; eauto. i. des; subst.
+      right. exists t'. exists t1'. esplits; eauto.
+      * eapply tr_rel_trans; eauto.
+      * instantiate (1:= Goes_wrong t2'). ss.
+  - right. right.
+    rewrite H1, H in *. r in H4. des.
+    unfold behavior_app in H4. destruct beh'; ss. inv H4.
+    r in H6. des.
+    exists t'. exploit tr_rel_div_r. eapply H5. i. des.
+    exists t1'. esplits; eauto.
+    { eapply tr_rel_mon in H1; cycle 1. eapply ev_rel_mon; eauto.
+      eapply tr_rel_trans'; eauto. }
+    subst. erewrite behavior_app_assoc. rr. esplits; eauto.
 Qed.
 
-Lemma behavior_improves_bot:
-  forall beh, behavior_improves (Goes_wrong E0) beh.
+Lemma observation_improves_bot pm1 pm2 beh (IMP: gm_improves' pm1 pm2):
+  observation_improves (pm1, (Goes_wrong E0)) (pm2, beh).
 Proof.
-  intros. right. exists E0; split; auto. exists beh. rewrite behavior_app_E0; auto.
+  r. ss. split; eauto. des_ifs. right. left. esplits; eauto; [instantiate (1:=E0); econs|].
+  r. exists beh. erewrite behavior_app_E0; auto.
 Qed.
 
-Lemma behavior_improves_app:
-  forall t beh1 beh2,
-  behavior_improves beh1 beh2 ->
-  behavior_improves (behavior_app t beh1) (behavior_app t beh2).
+Lemma observation_improves_app
+    pm1 pm2 beh1 beh2 t1 t2
+    (OIMP: observation_improves (Some pm1, beh1) (Some pm2, beh2))
+    (TRREL: tr_rel (ev_rel pm2) t1 t2) :
+  observation_improves (Some pm1, behavior_app t1 beh1) (Some pm2, behavior_app t2 beh2).
 Proof.
-  intros. red; destruct H. left; congruence.
-  destruct H as [t' [A [beh' B]]]. subst.
-  right; exists (t ** t'); split; auto. exists beh'. rewrite behavior_app_assoc; auto.
+  red. ss. destruct OIMP as [OIMP IMP]. split; eauto; ss. unfold behavior_improves in *. des.
+  - left. unfold behav_rel in OIMP. des_ifs; ss.
+    + des; split; auto. eapply tr_rel_app; eauto.
+    + eapply tr_rel_app; eauto.
+    + eapply tr_rel_app; eauto.
+    + eapply trinf_rel_app; eauto.
+    + eapply tr_rel_app; eauto.
+  - right. left. subst; ss.
+    exists (t1 ** t). exists (t2 ** t'). esplits; eauto.
+    { eapply tr_rel_app; eauto. }
+    r in OIMP1. des. subst. r. exists beh'. erewrite behavior_app_assoc; eauto.
+  - right. right. subst; ss.
+    exists (t2 ** t'). exists (t1 ** t). esplits; eauto.
+    { eapply tr_rel_app; eauto. }
+    r in OIMP1. des. subst. r. exists beh'. erewrite behavior_app_assoc; eauto.
 Qed.
 
 (** Associating behaviors to programs. *)
@@ -125,154 +578,203 @@ Section PROGRAM_BEHAVIORS.
 Variable L: semantics.
 
 Inductive state_behaves (s: state L): program_behavior -> Prop :=
-  | state_terminates: forall t s' r,
+  | state_terminates: forall t s' r (INTACT: trace_intact t),
       Star L s t s' ->
       final_state L s' r ->
       state_behaves s (Terminates t r)
-  | state_diverges: forall t s',
+  | state_partial_terminates
+      t s'
+      (STAR: Star L s t s')
+      (PTERM: ~trace_intact t) :
+      state_behaves s (Partial_terminates (trace_cut_pterm t))
+  | state_diverges: forall t s' (INTACT: trace_intact t),
       Star L s t s' -> Forever_silent L s' ->
       state_behaves s (Diverges t)
   | state_reacts: forall T,
       Forever_reactive L s T ->
       state_behaves s (Reacts T)
-  | state_goes_wrong: forall t s',
+  | state_goes_wrong: forall t s' (INTACT: trace_intact t),
       Star L s t s' ->
       Nostep L s' ->
       (forall r, ~final_state L s' r) ->
       state_behaves s (Goes_wrong t).
 
-Inductive program_behaves: program_behavior -> Prop :=
-  | program_runs: forall s beh,
-      initial_state L s -> state_behaves s beh ->
-      program_behaves beh
+Inductive program_observes: (option (positive -> option Z)) * program_behavior -> Prop :=
+  | program_runs: forall s s' mp beh,
+      initial_state L s -> initial_capture L s s' -> initial_pimap L s' = mp -> state_behaves s' beh ->
+      program_observes (Some mp, beh)
   | program_goes_initially_wrong:
       (forall s, ~initial_state L s) ->
-      program_behaves (Goes_wrong E0).
+      program_observes (Some (fun _ => None), (Goes_wrong E0))
+  | program_goes_initially_capture_wrong: forall s,
+       initial_state L s -> (forall s', ~ initial_capture L s s') -> 
+      program_observes (None, (Partial_terminates E0)).
 
 Lemma state_behaves_app:
-  forall s1 t s2 beh,
+  forall s1 t s2 beh (INTACT: trace_intact t),
   Star L s1 t s2 -> state_behaves s2 beh -> state_behaves s1 (behavior_app t beh).
 Proof.
-  intros. inv H0; simpl; econstructor; eauto; try (eapply star_trans; eauto).
-  eapply star_forever_reactive; eauto.
+  intros.
+  inv H0; simpl; try (by econstructor; eauto; try (eapply star_trans; eauto); try eapply trace_intact_app; eauto).
+  - replace (t ** trace_cut_pterm t0) with (trace_cut_pterm (t ** t0)); cycle 1.
+    { apply trace_cut_pterm_intact_app; auto. }
+    econs; eauto. eapply star_trans; eauto.
+    { intros INTACT1. apply PTERM.
+      apply trace_intact_app_rev in INTACT1. des. auto. }
+  - econs; eauto. eapply star_forever_reactive; eauto.
 Qed.
 
 (** * Existence of behaviors *)
 
-(** We now show that any program admits at least one behavior.
-  The proof requires classical logic: the axiom of excluded middle
-  and an axiom of description. *)
+(*   The proof requires classical logic: the axiom of excluded middle *)
+(*   and an axiom of description. *)
 
-(** The most difficult part of the proof is to show the existence
-  of an infinite trace in the case of reactive divergence. *)
+(** The most difficult part of the proof is to show the existence *)
+(*   of an infinite trace in the case of reactive divergence. *)
 
 Section TRACEINF_REACTS.
 
 Variable s0: state L.
 
 Hypothesis reacts:
-  forall s1 t1, Star L s0 t1 s1 ->
-  exists s2, exists t2, Star L s1 t2 s2 /\ t2 <> E0.
+  forall s1 t1 (INTACT: trace_intact t1), Star L s0 t1 s1 ->
+  exists s2, exists t2, <<INTACT: trace_intact t2>> /\ Star L s1 t2 s2 /\ t2 <> E0.
 
 Lemma reacts':
-  forall s1 t1, Star L s0 t1 s1 ->
-  { s2 : state L & { t2 : trace | Star L s1 t2 s2 /\ t2 <> E0 } }.
+  forall s1 t1 (INTACT: trace_intact t1), Star L s0 t1 s1 ->
+  { s2 : state L & { t2 : trace | <<INTACT: trace_intact t2>> /\ Star L s1 t2 s2 /\ t2 <> E0 } }.
 Proof.
   intros.
-  destruct (constructive_indefinite_description _ (reacts H)) as [s2 A].
+  destruct (constructive_indefinite_description _ (reacts INTACT H)) as [s2 A].
   destruct (constructive_indefinite_description _ A) as [t2 [B C]].
   exists s2; exists t2; auto.
 Qed.
 
-CoFixpoint build_traceinf' (s1: state L) (t1: trace) (ST: Star L s0 t1 s1) : traceinf' :=
-  match reacts' ST with
-  | existT s2 (exist t2 (conj A B)) =>
+CoFixpoint build_traceinf' (s1: state L) (t1: trace) (INTACT0: trace_intact t1) (ST: Star L s0 t1 s1) : traceinf' :=
+  match reacts' INTACT0 ST with
+  | existT s2 (exist t2 (conj INTACT1 (conj A B))) =>
       Econsinf' t2
-                (build_traceinf' (star_trans ST A (eq_refl _)))
+                (build_traceinf' (trace_intact_app _ _ INTACT0 INTACT1) (star_trans ST A (eq_refl _)))
                 B
   end.
 
 Lemma reacts_forever_reactive_rec:
-  forall s1 t1 (ST: Star L s0 t1 s1),
-  Forever_reactive L s1 (traceinf_of_traceinf' (build_traceinf' ST)).
+  forall s1 t1 (INTACT0: trace_intact t1) (ST: Star L s0 t1 s1),
+  Forever_reactive L s1 (traceinf_of_traceinf' (build_traceinf' INTACT0 ST)).
 Proof.
   cofix COINDHYP; intros.
-  rewrite (unroll_traceinf' (build_traceinf' ST)). simpl.
-  destruct (reacts' ST) as [s2 [t2 [A B]]].
+  rewrite (unroll_traceinf' (build_traceinf' INTACT0 ST)). simpl.
+  destruct (reacts' INTACT0 ST) as [s2 [t2 [INTACT1 [A B]]]].
   rewrite traceinf_traceinf'_app.
-  econstructor. eexact A. auto. apply COINDHYP.
+  econstructor. eauto. eexact A. auto. apply COINDHYP.
 Qed.
 
 Lemma reacts_forever_reactive:
   exists T, Forever_reactive L s0 T.
 Proof.
-  exists (traceinf_of_traceinf' (build_traceinf' (star_refl (step L) (globalenv L) s0))).
+  eexists (traceinf_of_traceinf' (build_traceinf' _ (star_refl (step L) (globalenv L) s0))).
   apply reacts_forever_reactive_rec.
+Unshelve.
+  ii. eauto. (* TODO: (trace_intact E0) make this lemma? *)
 Qed.
 
 End TRACEINF_REACTS.
 
 Lemma diverges_forever_silent:
   forall s0,
-  (forall s1 t1, Star L s0 t1 s1 -> exists s2, Step L s1 E0 s2) ->
+  (forall s1 t1 (INTACT: trace_intact t1), Star L s0 t1 s1 -> exists s2, Step L s1 E0 s2) ->
   Forever_silent L s0.
 Proof.
   cofix COINDHYP; intros.
-  destruct (H s0 E0) as [s1 ST]. constructor.
+  destruct (H s0 E0) as [s1 ST]. { ii. eauto. } constructor.
   econstructor. eexact ST. apply COINDHYP.
-  intros. eapply H. eapply star_left; eauto.
+  intros. eapply H. { eauto. } eapply star_left; eauto.
 Qed.
 
 Lemma state_behaves_exists:
   forall s, exists beh, state_behaves s beh.
 Proof.
   intros s0.
-  destruct (classic (forall s1 t1, Star L s0 t1 s1 -> exists s2, exists t2, Step L s1 t2 s2)).
+  destruct (classic (forall s1 t1 (INTACT: trace_intact t1), Star L s0 t1 s1 -> exists s2, exists t2, <<INTACT: trace_intact t2>> /\ Step L s1 t2 s2)).
+  {
 (* 1 Divergence (silent or reactive) *)
-  destruct (classic (exists s1, exists t1, Star L s0 t1 s1 /\
-                       (forall s2 t2, Star L s1 t2 s2 ->
+  destruct (classic (exists s1, exists t1, (<<BEHAV: trace_intact t1>>) /\ Star L s0 t1 s1 /\
+                       (forall s2 t2 (INTACT: trace_intact t2), Star L s1 t2 s2 ->
                         exists s3, Step L s2 E0 s3))).
+  {
 (* 1.1 Silent divergence *)
-  destruct H0 as [s1 [t1 [A B]]].
+  destruct H0 as [s1 [t1 [BEHAV [A B]]]].
   exists (Diverges t1); econstructor; eauto.
   apply diverges_forever_silent; auto.
+  }
+  {
 (* 1.2 Reactive divergence *)
   destruct (@reacts_forever_reactive s0) as [T FR].
   intros.
   generalize (not_ex_all_not _ _ H0 s1). intro A; clear H0.
   generalize (not_ex_all_not _ _ A t1). intro B; clear A.
+  apply not_and_or in B. des; ss; eauto.
   destruct (not_and_or _ _ B). contradiction.
   destruct (not_all_ex_not _ _ H0) as [s2 C]; clear H0.
   destruct (not_all_ex_not _ _ C) as [t2 D]; clear C.
+  destruct (imply_to_and _ _ D) as [INTACT0 TMP]; clear D. rename TMP into D.
   destruct (imply_to_and _ _ D) as [E F]; clear D.
-  destruct (H s2 (t1 ** t2)) as [s3 [t3 G]]. eapply star_trans; eauto.
+  destruct (H s2 (t1 ** t2)) as [s3 [t3 G]]. apply trace_intact_app; eauto. eapply star_trans; eauto.
+  des.
   exists s3; exists (t2 ** t3); split.
+  apply trace_intact_app; eauto. split.
   eapply star_right; eauto.
   red; intros. destruct (app_eq_nil t2 t3 H0). subst. elim F. exists s3; auto.
   exists (Reacts T); econstructor; eauto.
+  }
+  }
+  {
 (* 2 Termination (normal or by going wrong) *)
   destruct (not_all_ex_not _ _ H) as [s1 A]; clear H.
   destruct (not_all_ex_not _ _ A) as [t1 B]; clear A.
+  destruct (imply_to_and _ _ B) as [INTACT TMP]; clear B. rename TMP into B.
   destruct (imply_to_and _ _ B) as [C D]; clear B.
   destruct (classic (exists r, final_state L s1 r)) as [[r FINAL] | NOTFINAL].
+  {
 (* 2.1 Normal termination *)
   exists (Terminates t1 r); econstructor; eauto.
-(* 2.2 Going wrong *)
+  }
+  destruct (classic (exists s2 t2, Step L s1 t2 s2)).
+  {
+(* 2.2 Partial Termination *)
+    des.
+    destruct (classic (trace_intact t2)).
+    { exfalso. eauto. }
+    exists (Partial_terminates (t1 ** (trace_cut_pterm t2))).
+    replace (t1 ** trace_cut_pterm t2) with (trace_cut_pterm (t1 ** t2)); cycle 1.
+    { apply trace_cut_pterm_intact_app; auto. }
+    econs; eauto.
+    { eapply star_trans; eauto. apply star_one. eauto. }
+    intros INTACT1. apply H0.
+    apply trace_intact_app_rev in INTACT1. des. auto.
+  }
+  {
+(* 2.3 Going wrong *)
   exists (Goes_wrong t1); econstructor; eauto. red. intros.
   generalize (not_ex_all_not _ _ D s'); intros.
-  generalize (not_ex_all_not _ _ H t); intros.
-  auto.
+  generalize (not_ex_all_not _ _ H0 t); intros.
+  apply not_and_or in H1. des; eauto.
+  }
+  }
 Qed.
 
-Theorem program_behaves_exists:
-  exists beh, program_behaves beh.
+Theorem program_observes_exists:
+  exists obs, program_observes obs.
 Proof.
   destruct (classic (exists s, initial_state L s)) as [[s0 INIT] | NOTINIT].
 (* 1. Initial state is defined. *)
-  destruct (state_behaves_exists s0) as [beh SB].
-  exists beh; econstructor; eauto.
+- destruct (classic (exists s', initial_capture L s0 s')) as [[s0' INITC] | NOTINITC].
++ destruct (state_behaves_exists s0') as [beh SB].
+  eexists. econs; eauto.
+  (* exists (Some (initial_pimap L s0', beh)); econstructor; eauto. *)
++ exists (None, Partial_terminates E0). econs 3; eauto.
 (* 2. Initial state is undefined *)
-  exists (Goes_wrong E0). apply program_goes_initially_wrong.
+- exists (Some (fun _ => None), Goes_wrong E0). apply program_goes_initially_wrong.
   intros. eapply not_ex_all_not; eauto.
 Qed.
 
@@ -280,106 +782,83 @@ End PROGRAM_BEHAVIORS.
 
 (** * Forward simulations and program behaviors *)
 
-Section FORWARD_SIMULATIONS.
-
-Context L1 L2 index order match_states (S: fsim_properties L1 L2 index order match_states).
-
-Lemma forward_simulation_state_behaves:
-  forall i s1 s2 beh1,
-  match_states i s1 s2 -> state_behaves L1 s1 beh1 ->
-  exists beh2, state_behaves L2 s2 beh2 /\ behavior_improves beh1 beh2.
-Proof.
-  intros. inv H0.
-- (* termination *)
-  exploit simulation_star; eauto. intros [i' [s2' [A B]]].
-  exists (Terminates t r); split.
-  econstructor; eauto. eapply fsim_match_final_states; eauto.
-  apply behavior_improves_refl.
-- (* silent divergence *)
-  exploit simulation_star; eauto. intros [i' [s2' [A B]]].
-  exists (Diverges t); split.
-  econstructor; eauto. eapply simulation_forever_silent; eauto.
-  apply behavior_improves_refl.
-- (* reactive divergence *)
-  exists (Reacts T); split.
-  econstructor. eapply simulation_forever_reactive; eauto.
-  apply behavior_improves_refl.
-- (* going wrong *)
-  exploit simulation_star; eauto. intros [i' [s2' [A B]]].
-  destruct (state_behaves_exists L2 s2') as [beh' SB].
-  exists (behavior_app t beh'); split.
-  eapply state_behaves_app; eauto.
-  replace (Goes_wrong t) with (behavior_app t (Goes_wrong E0)).
-  apply behavior_improves_app. apply behavior_improves_bot.
-  simpl. decEq. traceEq.
-Qed.
-
-End FORWARD_SIMULATIONS.
-
-Theorem forward_simulation_behavior_improves:
-  forall L1 L2, forward_simulation L1 L2 ->
-  forall beh1, program_behaves L1 beh1 ->
-  exists beh2, program_behaves L2 beh2 /\ behavior_improves beh1 beh2.
-Proof.
-  intros L1 L2 FS. destruct FS as [init order match_states S]. intros. inv H.
-- (* initial state defined *)
-  exploit (fsim_match_initial_states S); eauto. intros [i [s' [INIT MATCH]]].
-  exploit forward_simulation_state_behaves; eauto. intros [beh2 [A B]].
-  exists beh2; split; auto. econstructor; eauto.
-- (* initial state undefined *)
-  destruct (classic (exists s', initial_state L2 s')).
-  destruct H as [s' INIT].
-  destruct (state_behaves_exists L2 s') as [beh' SB].
-  exists beh'; split. econstructor; eauto. apply behavior_improves_bot.
-  exists (Goes_wrong E0); split.
-  apply program_goes_initially_wrong.
-  intros; red; intros. elim H; exists s; auto.
-  apply behavior_improves_refl.
-Qed.
-
-Corollary forward_simulation_same_safe_behavior:
-  forall L1 L2, forward_simulation L1 L2 ->
-  forall beh,
-  program_behaves L1 beh -> not_wrong beh ->
-  program_behaves L2 beh.
-Proof.
-  intros. exploit forward_simulation_behavior_improves; eauto.
-  intros [beh' [A B]]. destruct B.
-  congruence.
-  destruct H2 as [t [C D]]. subst. contradiction.
-Qed.
 
 (** * Backward simulations and program behaviors *)
 
 Section BACKWARD_SIMULATIONS.
 
-Context L1 L2 index order match_states (S: bsim_properties L1 L2 index order match_states).
+Context L1 L2 index order (S: NOSTUTTER.bsim_properties L1 L2 index order).
+
+(* rlx = false is right? *)
+Variable pim : positive -> option Z.
+
+Let match_states : index -> L1.(state) -> L2.(state) -> Prop := NOSTUTTER.bsim L1 L2 pim order.
+
+Lemma match_states_final s1 s2 i retv
+    (FINAL: final_state L2 s2 retv)
+    (MATCH: match_states i s1 s2)
+    (SAFE: safe L1 s1) :
+  exists s1', (<<STEPS: Star L1 s1 E0 s1'>>) /\ (<<FINAL: final_state L1 s1' retv>>).
+Proof.
+  punfold MATCH. inv MATCH. hexploit STEP; auto.
+  i. inv H; clarify. hexploit FINAL0; eauto.
+Qed.
+
+Lemma match_states_simulation
+    s1 s2 s2' i t'
+    (STEP: Step L2 s2 t' s2')
+    (MATCH: match_states i s1 s2)
+    (SAFE: safe L1 s1):
+  (exists s1' t i',
+   ((tr_rel (ev_rel pim) t t') /\
+    (Plus L1 s1 t s1' \/ (Star L1 s1 t s1' /\ order i' i)) /\
+    (match_states i' s1' s2')))
+\/ (exists s1' t,
+   (~trace_intact t') /\
+   (Star L1 s1 t s1') /\
+   (exists tl, tr_rel (ev_rel pim) t (trace_cut_pterm t' ** tl))).
+Proof.
+  punfold MATCH. inv MATCH. hexploit STEP0; auto.
+  i. inv H; clarify. hexploit STEP1; eauto. i. destruct H; des_safe.
+  - inv H0; pclearbot; left; esplits; eauto.
+  - right. esplits; eauto.
+Qed.
+
+Lemma match_states_progress s1 s2 i
+      (SAFE: safe L1 s1)
+      (MATCH: match_states i s1 s2) :
+  (exists retv, <<FINAL: final_state L2 s2 retv>>)
+\/ (exists t s2', <<STEP: Step L2 s2 t s2'>>).
+Proof.
+  punfold MATCH. inv MATCH. hexploit STEP; auto. i. inv H; clarify.
+Qed.
 
 Definition safe_along_behavior (s: state L1) (b: program_behavior) : Prop :=
-  forall t1 s' b2, Star L1 s t1 s' -> b = behavior_app t1 b2 ->
+  forall t1 s' b2 (INTACT: trace_intact t1), Star L1 s t1 s' -> b = behavior_app t1 b2 ->
      (exists r, final_state L1 s' r)
   \/ (exists t2, exists s'', Step L1 s' t2 s'').
 
 Remark safe_along_safe:
   forall s b, safe_along_behavior s b -> safe L1 s.
 Proof.
-  intros; red; intros. eapply H; eauto. symmetry; apply behavior_app_E0.
+  intros; red; intros. eapply H; eauto. { ss. } symmetry; apply behavior_app_E0.
 Qed.
 
 Remark star_safe_along:
-  forall s b t1 s' b2,
+  forall s b t1 s' b2 (INTACT: trace_intact t1),
   safe_along_behavior s b ->
   Star L1 s t1 s' -> b = behavior_app t1 b2 ->
   safe_along_behavior s' b2.
 Proof.
-  intros; red; intros. eapply H. eapply star_trans; eauto.
+  intros; red; intros. eapply H. all: cycle 1. eapply star_trans; eauto.
   subst. rewrite behavior_app_assoc. eauto.
+  eapply trace_intact_app; eauto.
 Qed.
 
 Remark not_safe_along_behavior:
   forall s b,
   ~ safe_along_behavior s b ->
-  exists t, exists s',
+  exists t, exists s', <<INTACT: trace_intact t>> /\
      behavior_prefix t b
   /\ Star L1 s t s'
   /\ Nostep L1 s'
@@ -389,10 +868,12 @@ Proof.
   destruct (not_all_ex_not _ _ H) as [t1 A]; clear H.
   destruct (not_all_ex_not _ _ A) as [s' B]; clear A.
   destruct (not_all_ex_not _ _ B) as [b2 C]; clear B.
+  destruct (imply_to_and _ _ C) as [INTACT TMP]; clear C. rename TMP into C.
   destruct (imply_to_and _ _ C) as [D E]; clear C.
   destruct (imply_to_and _ _ E) as [F G]; clear E.
   destruct (not_or_and _ _ G) as [P Q]; clear G.
   exists t1; exists s'.
+  split; eauto.
   split. exists b2; auto.
   split. auto.
   split. red; intros; red; intros. elim Q. exists t; exists s'0; auto.
@@ -400,19 +881,170 @@ Proof.
 Qed.
 
 Lemma backward_simulation_star:
-  forall s2 t s2', Star L2 s2 t s2' ->
-  forall i s1 b, match_states i s1 s2 -> safe_along_behavior s1 (behavior_app t b) ->
-  exists i', exists s1', Star L1 s1 t s1' /\ match_states i' s1' s2'.
+  forall s2 t' s2' (INTACT: trace_intact t'), Star L2 s2 t' s2' ->
+  forall i s1 b, match_states i s1 s2 -> (forall t, tr_rel (ev_rel pim) t t' -> safe_along_behavior s1 (behavior_app t b)) ->
+  (exists s1' t i',
+   ((tr_rel (ev_rel pim) t t') /\
+    (Star L1 s1 t s1') /\
+    (match_states i' s1' s2'))).
+Proof.
+  induction 2; i.
+  { exists s1, E0, i. esplits; eauto.
+    - econs.
+    - eapply star_refl. }
+  subst. exploit trace_intact_app_rev; eauto. i. des.
+  exploit match_states_simulation; eauto.
+  { specialize (H3 (t1 ** t2)). hexploit H3; eauto.
+    eapply tr_rel_refl. eapply ev_rel_refl. i. eapply safe_along_safe; eauto. }
+  i. subst. destruct H1; cycle 1.
+  { des. exfalso. eapply H1. i. des; eauto. }
+  des.
+  - exploit IHstar; eauto.
+    { i. specialize (H3 (t ** t0)). hexploit H3.
+      { eapply tr_rel_app; eauto. }
+      i. instantiate (1:=b). erewrite behavior_app_assoc in H7.
+      eapply star_safe_along; try eapply H7; cycle 1.
+      { eapply plus_star. eauto. }
+      { eauto. }
+      { erewrite <- tr_rel_intact.
+        3:{ eapply H1. }
+        { eauto. }
+        { ii. split; ii; subst; ss. unfold ev_rel, event_rel in ER. des_ifs. } } }
+    i. des.
+    esplits; cycle 2.
+    { eauto. }
+    { eapply tr_rel_app; eauto. }
+    { eapply plus_star. eapply plus_star_trans; eauto. }
+  - exploit IHstar; eauto.
+    { i. specialize (H3 (t ** t0)). hexploit H3.
+      { eapply tr_rel_app; eauto. }
+      i. instantiate (1:=b). erewrite behavior_app_assoc in H8.
+      eapply star_safe_along; try eapply H8; cycle 1.
+      { eauto. }
+      { eauto. }
+      { erewrite <- tr_rel_intact.
+        3:{ eapply H1. }
+        { eauto. }
+        { ii. split; ii; subst; ss. unfold ev_rel, event_rel in ER. des_ifs. } } }
+    i. des.
+    esplits; cycle 2.
+    { eauto. }
+    { eapply tr_rel_app; eauto. }
+    { eapply star_trans; eauto. }
+Qed.
+
+Lemma backward_simulation_plus:
+  forall s2 t' s2' (INTACT: trace_intact t'), Plus L2 s2 t' s2' ->
+  forall i s1 b, match_states i s1 s2 -> (forall t, tr_rel (ev_rel pim) t t' -> safe_along_behavior s1 (behavior_app t b)) ->
+  (exists s1' t i',
+   ((tr_rel (ev_rel pim) t t') /\
+    (Star L1 s1 t s1') /\
+    (match_states i' s1' s2'))).
+Proof.
+  i.
+  assert (SAFE: safe L1 s1).
+  { specialize (H1 t'). eapply safe_along_safe.
+    eapply H1. eapply tr_rel_refl. eapply ev_rel_refl. }
+  inv H.
+  hexploit match_states_simulation; eauto.
+  eapply trace_intact_app_rev in INTACT. i. destruct H; cycle 1.
+  { des; clarify. }
+  des.
+  - exploit plus_star; eauto. i.
+    assert (trace_intact t).
+    { erewrite <- tr_rel_intact; cycle 1; eauto. i.
+      destruct ev1, ev2; ss. }
+    hexploit backward_simulation_star; try apply H3; eauto.
+    { i. eapply star_safe_along; cycle 1; eauto.
+      instantiate (1:=b). specialize (H1 (t ** t0)).
+      erewrite behavior_app_assoc in H1. eapply  H1. eapply tr_rel_app; eauto. }
+    i. des. esplits; [| | eauto].
+    + eapply tr_rel_app; eauto.
+    + eapply star_trans; eauto.
+  - assert (trace_intact t).
+    { erewrite <- tr_rel_intact; cycle 1; eauto. i.
+      destruct ev1, ev2; ss. }
+    hexploit backward_simulation_star; try apply H3; eauto.
+    { i. eapply star_safe_along; cycle 1; eauto.
+      instantiate (1:=b). specialize (H1 (t ** t0)).
+      erewrite behavior_app_assoc in H1. eapply  H1. eapply tr_rel_app; eauto. }
+    i. des. esplits; [| | eauto].
+    + eapply tr_rel_app; eauto.
+    + eapply star_trans; eauto.
+Qed.
+
+Lemma backward_simulation_star_pterm:
+  forall s2 t' s2' (PTERM: ~trace_intact t'), Star L2 s2 t' s2' ->
+  forall i s1 b , match_states i s1 s2 ->
+  (forall t, tr_rel (ev_rel pim) t t' -> safe_along_behavior s1 (behavior_app (trace_cut_pterm t) b)) ->
+  (exists s1' t, <<STAR: Star L1 s1 t s1'>> /\ <<SUB: exists tl, tr_rel (ev_rel pim) t (trace_cut_pterm t' ** tl)>>).
 Proof.
-  induction 1; intros.
-  exists i; exists s1; split; auto. apply star_refl.
-  exploit (bsim_simulation S); eauto. eapply safe_along_safe; eauto.
-  intros [i' [s1' [A B]]].
-  assert (Star L1 s0 t1 s1'). intuition. apply plus_star; auto.
-  exploit IHstar; eauto. eapply star_safe_along; eauto.
-  subst t; apply behavior_app_assoc.
-  intros [i'' [s2'' [C D]]].
-  exists i''; exists s2''; split; auto. eapply star_trans; eauto.
+  induction 2; intros.
+  { contradict PTERM. ss. }
+  subst. hexploit match_states_simulation; eauto.
+  { specialize (H3 (t1 ** t2)). eapply safe_along_safe; eauto. eapply H3.
+    eapply tr_rel_refl. eapply ev_rel_refl. }
+  i. destruct H1.
+  2:{ des.
+      subst. esplits; eauto. (* rewrite E0_left. *)
+      rewrite trace_cut_pterm_pterm_app; eauto. }
+  des.
+  - destruct (classic (trace_intact t)).
+    2: { destruct (trace_cut_pterm_split t) as [t3 SPLIT]. esplits; eauto.
+      { eapply plus_star. eauto. }
+      rewrite SPLIT.
+      assert (~ trace_intact t1).
+      { ii. eapply H6. erewrite <- tr_rel_intact; try eapply H1; eauto.
+        i. destruct ev1, ev2; ss. }
+      erewrite trace_cut_pterm_pterm_app; eauto. instantiate (1:=t3).
+      eapply tr_rel_app; eauto.
+      - eapply tr_rel_cut_pterm; eauto.
+        { i. destruct ev1, ev2; ss. }
+      - eapply tr_rel_refl. eapply ev_rel_refl. }
+    assert (trace_intact t1).
+    { clear - H1 H6. ii. eapply H6. clear H6. ginduction H1; ss. ii. des.
+      - subst. destruct x; ss; eauto.
+      - eapply IHForall2 in H0. eauto. }
+    hexploit IHstar; eauto.
+    { ii. eapply PTERM. eapply trace_intact_app; auto. }
+    { i.
+      specialize (H3 (t ** t0)). hexploit H3; eauto.
+      { eapply tr_rel_app; eauto. }
+      rewrite trace_cut_pterm_intact_app; auto. i.
+      eapply star_safe_along.
+      3:{ eapply plus_star. eauto. }
+      { eauto. }
+      { eauto. }
+      rewrite <- behavior_app_assoc. eauto. }
+    i. des. esplits.
+    { eapply plus_star. eapply plus_star_trans. eapply H4. eapply STAR. eauto. }
+    rewrite trace_cut_pterm_intact_app; auto.
+    erewrite Eapp_assoc. eapply tr_rel_app; eauto.
+  - destruct (classic (trace_intact t)).
+    2: { destruct (trace_cut_pterm_split t) as [t3 SPLIT]. esplits; eauto.
+      rewrite SPLIT.
+      assert (~ trace_intact t1).
+      { ii. eapply H7. erewrite <- tr_rel_intact; try eapply H1; eauto.
+        i. destruct ev1, ev2; ss. }
+      erewrite trace_cut_pterm_pterm_app; eauto. instantiate (1:=t3).
+      eapply tr_rel_app; eauto.
+      - eapply tr_rel_cut_pterm; eauto.
+        { i. destruct ev1, ev2; ss. }
+      - eapply tr_rel_refl. eapply ev_rel_refl. }
+    assert (trace_intact t1).
+    { clear - H1 H7. erewrite tr_rel_intact; eauto. i. destruct ev1, ev2; ss. }
+    hexploit IHstar; eauto.
+    { ii. eapply PTERM. eapply trace_intact_app; auto. }
+    { i.
+      specialize (H3 (t ** t0)). hexploit H3; eauto.
+      { eapply tr_rel_app; eauto. }
+      rewrite trace_cut_pterm_intact_app; auto. i.
+      eapply star_safe_along; cycle 2; eauto.
+      rewrite <- behavior_app_assoc. eauto. }
+    i. des. esplits.
+    { eapply star_trans; eauto. }
+    rewrite trace_cut_pterm_intact_app; auto.
+    erewrite Eapp_assoc. eapply tr_rel_app; eauto.
 Qed.
 
 Lemma backward_simulation_forever_silent:
@@ -423,399 +1055,312 @@ Proof.
   assert (forall i s1 s2,
          Forever_silent L2 s2 -> match_states i s1 s2 -> safe L1 s1 ->
          forever_silent_N (step L1) order (globalenv L1) i s1).
-    cofix COINDHYP; intros.
-    inv H.  destruct (bsim_simulation S _ _ _ H2 _ H0 H1) as [i' [s2' [A B]]].
-    destruct A as [C | [C D]].
-    eapply forever_silent_N_plus; eauto. eapply COINDHYP; eauto.
-      eapply star_safe; eauto. apply plus_star; auto.
-    eapply forever_silent_N_star; eauto. eapply COINDHYP; eauto.
-      eapply star_safe; eauto.
-  intros. eapply forever_silent_N_forever; eauto. eapply bsim_order_wf; eauto.
+  { i. (* eapply forever_silent_forever_silent2 in H. *) eapply forever_silent_N2_forever_silent_N.
+    revert_until match_states. pcofix CIH. i.
+    inv H0. punfold H1. inv H1. specialize (STEP H2). inv STEP; clarify.
+    exploit STEP0; eauto. i. inv H0; cycle 1.
+    { des_safe. exfalso. eapply PTERM. ii. clarify. }
+    destruct H1 as [st_src1 [tr [i1 [TRREL [OSTAR MATCH]]]]].
+    pclearbot. inv TRREL. inv OSTAR.
+    - r in H0. pfold. econs 2; eauto. right. eapply CIH; cycle 1; eauto.
+      eapply star_safe; eauto. eapply plus_star; eauto.
+    - des_safe. pfold. econs; eauto. right. eapply CIH; cycle 1; eauto.
+      eapply star_safe; eauto. }
+  intros. eapply forever_silent_N_forever; eauto. eapply NOSTUTTER.bsim_order_wf; eauto.
 Qed.
 
-Lemma backward_simulation_forever_reactive:
-  forall i s1 s2 T,
-  Forever_reactive L2 s2 T -> match_states i s1 s2 -> safe_along_behavior s1 (Reacts T) ->
-  Forever_reactive L1 s1 T.
+CoFixpoint trinf_fix {X} (f:X -> (event * X)) (x: X) : traceinf :=
+  let '(e,x') := f x in Econsinf e (trinf_fix f x').
+
+Lemma trinf_unfold
+    (tr: traceinf):
+  tr = match tr with Econsinf e tr' => Econsinf e tr' end.
 Proof.
-  cofix COINDHYP; intros. inv H.
-  destruct (backward_simulation_star H2 (Reacts T0) H0) as [i' [s1' [A B]]]; eauto.
-  econstructor; eauto. eapply COINDHYP; eauto. eapply star_safe_along; eauto.
+  destruct tr; ss.
 Qed.
 
-Lemma backward_simulation_state_behaves:
-  forall i s1 s2 beh2,
-  match_states i s1 s2 -> state_behaves L2 s2 beh2 ->
-  exists beh1, state_behaves L1 s1 beh1 /\ behavior_improves beh1 beh2.
+Lemma trinf_fix_unfold
+    X (f:X -> (event * X)) (x: X):
+  trinf_fix f x = let '(e,x') := f x in Econsinf e (trinf_fix f x').
 Proof.
-  intros. destruct (classic (safe_along_behavior s1 beh2)).
-- (* 1. Safe along *)
-  exists beh2; split; [idtac|apply behavior_improves_refl].
-  inv H0.
-+ (* termination *)
-  assert (Terminates t r = behavior_app t (Terminates E0 r)).
-    simpl. rewrite E0_right; auto.
-  rewrite H0 in H1.
-  exploit backward_simulation_star; eauto.
-  intros [i' [s1' [A B]]].
-  exploit (bsim_match_final_states S); eauto.
-    eapply safe_along_safe. eapply star_safe_along; eauto.
-  intros [s1'' [C D]].
-  econstructor. eapply star_trans; eauto. traceEq. auto.
-+ (* silent divergence *)
-  assert (Diverges t = behavior_app t (Diverges E0)).
-    simpl. rewrite E0_right; auto.
-  rewrite H0 in H1.
-  exploit backward_simulation_star; eauto.
-  intros [i' [s1' [A B]]].
-  econstructor. eauto. eapply backward_simulation_forever_silent; eauto.
-  eapply safe_along_safe. eapply star_safe_along; eauto.
-+ (* reactive divergence *)
-  econstructor. eapply backward_simulation_forever_reactive; eauto.
-+ (* goes wrong *)
-  assert (Goes_wrong t = behavior_app t (Goes_wrong E0)).
-    simpl. rewrite E0_right; auto.
-  rewrite H0 in H1.
-  exploit backward_simulation_star; eauto.
-  intros [i' [s1' [A B]]].
-  exploit (bsim_progress S); eauto. eapply safe_along_safe. eapply star_safe_along; eauto.
-  intros [[r FIN] | [t' [s2' STEP2]]].
-  elim (H4 _ FIN).
-  elim (H3 _ _ STEP2).
-
-- (* 2. Not safe along *)
-  exploit not_safe_along_behavior; eauto.
-  intros [t [s1' [PREF [STEPS [NOSTEP NOFIN]]]]].
-  exists (Goes_wrong t); split.
-  econstructor; eauto.
-  right. exists t; auto.
+  rewrite trinf_unfold at 1. simpl. des_ifs.
 Qed.
 
-End BACKWARD_SIMULATIONS.
+Definition _trinf_fix_gen {X} f : trace * X -> event * (trace * X) :=
+  fun '(tr,x) =>
+    match tr with
+    | [] => f x
+    | e::tr' => (e,(tr',x))
+    end.
 
-Theorem backward_simulation_behavior_improves:
-  forall L1 L2, backward_simulation L1 L2 ->
-  forall beh2, program_behaves L2 beh2 ->
-  exists beh1, program_behaves L1 beh1 /\ behavior_improves beh1 beh2.
-Proof.
-  intros L1 L2 S beh2 H. destruct S as [index order match_states S]. inv H.
-- (* L2's initial state is defined. *)
-  destruct (classic (exists s1, initial_state L1 s1)) as [[s1 INIT] | NOINIT].
-+ (* L1's initial state is defined too. *)
-  exploit (bsim_match_initial_states S); eauto. intros [i [s1' [INIT1' MATCH]]].
-  exploit backward_simulation_state_behaves; eauto. intros [beh1 [A B]].
-  exists beh1; split; auto. econstructor; eauto.
-+ (* L1 has no initial state *)
-  exists (Goes_wrong E0); split.
-  apply program_goes_initially_wrong.
-  intros; red; intros. elim NOINIT; exists s0; auto.
-  apply behavior_improves_bot.
-- (* L2 has no initial state *)
-  exists (Goes_wrong E0); split.
-  apply program_goes_initially_wrong.
-  intros; red; intros.
-  exploit (bsim_initial_states_exist S); eauto. intros [s2 INIT2].
-  elim (H0 s2); auto.
-  apply behavior_improves_refl.
-Qed.
+Definition trinf_fix_gen {X} (f: X -> (event * (trace * X))) (x: X) : traceinf :=
+  trinf_fix (_trinf_fix_gen f) ([],x).
 
-Corollary backward_simulation_same_safe_behavior:
-  forall L1 L2, backward_simulation L1 L2 ->
-  (forall beh, program_behaves L1 beh -> not_wrong beh) ->
-  (forall beh, program_behaves L2 beh -> program_behaves L1 beh).
+Lemma trinf_fix_gen_unfold X f x:
+  @trinf_fix_gen X f x
+  = let '(e, (tr, x')) := f x in (e::tr) *** trinf_fix_gen f x'.
 Proof.
-  intros. exploit backward_simulation_behavior_improves; eauto.
-  intros [beh' [A B]]. destruct B.
-  congruence.
-  destruct H2 as [t [C D]]. subst. elim (H0 (Goes_wrong t)). auto.
+  unfold trinf_fix_gen.
+  rewrite trinf_fix_unfold at 1. unfold _trinf_fix_gen at 1.
+  destruct (f x) as [e [tr x']]. clear x.
+  ss. f_equal.
+  induction tr; eauto.
+  ss. rewrite trinf_fix_unfold at 1. ss.
+  f_equal. eauto.
 Qed.
 
-(** * Program behaviors for the "atomic" construction *)
+Variant _trinf_clos {X} (R: X -> trace -> X -> Prop) (trinf_clos: X -> traceinf -> Prop) : X -> traceinf -> Prop :=
+| trinf_clos_intro
+    tr inf x x'
+    (REL: R x tr x')
+    (INF: trinf_clos x' inf):
+  _trinf_clos R trinf_clos x (tr *** inf).
 
-Section ATOMIC.
+Definition trinf_clos {X} R x inf := paco2 (@_trinf_clos X R) bot2 x inf.
 
-Variable L: semantics.
-Hypothesis Lwb: well_behaved_traces L.
-
-Remark atomic_finish: forall s t, output_trace t -> Star (atomic L) (t, s) t (E0, s).
-Proof.
-  induction t; intros.
-  apply star_refl.
-  simpl in H; destruct H. eapply star_left; eauto.
-  simpl. apply atomic_step_continue; auto. simpl; auto. auto.
-Qed.
+Lemma trinf_clos_mon X R:
+  monotone2 (@_trinf_clos X R).
+Proof. ii. inv IN; econs; eauto. Qed.
 
-Lemma step_atomic_plus:
-  forall s1 t s2, Step L s1 t s2 -> Plus (atomic L) (E0,s1) t (E0,s2).
-Proof.
-  intros.  destruct t.
-  apply plus_one. simpl; apply atomic_step_silent; auto.
-  exploit Lwb; eauto. simpl; intros.
-  eapply plus_left. eapply atomic_step_start; eauto. eapply atomic_finish; eauto. auto.
-Qed.
+Hint Unfold trinf_clos.
+Hint Resolve trinf_clos_mon: paco.
 
-Lemma star_atomic_star:
-  forall s1 t s2, Star L s1 t s2 -> Star (atomic L) (E0,s1) t (E0,s2).
-Proof.
-  induction 1. apply star_refl. eapply star_trans with (s2 := (E0,s2)).
-  apply plus_star. eapply step_atomic_plus; eauto. eauto. auto.
-Qed.
+Definition non_E0 {X} (R: X -> trace -> X -> Prop) :=
+  fun x tr x' => tr <> E0 /\ R x tr x'.
 
-Lemma atomic_forward_simulation: forward_simulation L (atomic L).
+Definition _trinf_clos_coind X (R: X -> trace -> X -> Prop) (STEP: forall x, exists tr x', non_E0 R x tr x') (x: X) : event * (trace * X).
 Proof.
-  set (ms := fun (s: state L) (ts: state (atomic L)) => ts = (E0,s)).
-  apply forward_simulation_plus with ms; intros.
-  auto.
-  exists (E0,s1); split. simpl; auto. red; auto.
-  red in H. subst s2. simpl; auto.
-  red in H0. subst s2. exists (E0,s1'); split.
-  apply step_atomic_plus; auto. red; auto.
-Qed.
-
-Lemma atomic_star_star_gen:
-  forall ts1 t ts2, Star (atomic L) ts1 t ts2 ->
-  exists t', Star L (snd ts1) t' (snd ts2) /\ fst ts1 ** t' = t ** fst ts2.
+  specialize (STEP x). rename STEP into e.
+  repeat (eapply constructive_indefinite_description in e; destruct e). destruct n.
+  destruct x0.
+  { exfalso. apply H. eauto. }
+  exact (e, (x0, x1)).
+Defined.
+
+Lemma trinf_clos_coind {X} (R: X -> trace -> X -> Prop)
+    (STEP: forall x, exists tr x', non_E0 R x tr x') x:
+  exists inf: traceinf, trinf_clos (non_E0 R) x inf.
 Proof.
-  induction 1.
-  exists E0; split. apply star_refl. traceEq.
-  destruct IHstar as [t' [A B]].
-  simpl in H; inv H; simpl in *.
-  exists t'; split. eapply star_left; eauto. auto.
-  exists (ev :: t0 ** t'); split. eapply star_left; eauto. rewrite B; auto.
-  exists t'; split. auto. rewrite B; auto.
+  exists (trinf_fix_gen (_trinf_clos_coind STEP) x).
+  revert x. pcofix CIH. i.
+  rewrite trinf_fix_gen_unfold.
+  unfold _trinf_clos_coind at 1.
+  repeat (destruct (constructive_indefinite_description _ _); des).
+  destruct n, x0.
+  { exfalso. apply n. eauto. }
+  pstep. econs; cycle 1; rr; eauto with paco.
 Qed.
 
-Lemma atomic_star_star:
-  forall s1 t s2, Star (atomic L) (E0,s1) t (E0,s2) -> Star L s1 t s2.
+Definition bsfr_state : Type :=
+  { '(i,s1,s2,T2) |
+    match_states i s1 s2 /\
+    Forever_reactive L2 s2 T2 /\
+    forall T1, trinf_rel (ev_rel pim) T1 T2 -> safe_along_behavior s1 (Reacts T1) }.
+
+Definition bsfr: bsfr_state -> trace -> bsfr_state -> Prop :=
+  fun '(exist (i,s1,s2,T2) _) tr1 '(exist (i',s1',s2',T2') _) =>
+    exists tr2,
+    T2 = tr2 *** T2' /\
+    tr_rel (ev_rel pim) tr1 tr2 /\
+    trace_intact tr1 /\ Star L1 s1 tr1 s1'.
+         
+Lemma backward_simulation_forever_reactive_step
+    (x: bsfr_state):
+  exists tr1 x', non_E0 bsfr x tr1 x'.
 Proof.
-  intros. exploit atomic_star_star_gen; eauto. intros [t' [A B]].
-  simpl in *. replace t with t'. auto. subst; traceEq.
+  cut (exists tr1 i' s1' s2' T2', tr1 <> E0 /\
+       exists PF, bsfr x tr1 (exist _ (i',s1',s2',T2') PF)).
+  { i. des. unfold non_E0. esplits; eauto. }
+  destruct x as [[[[i s1] s2] T2] [MATCH [REACT SAFE]]]. simpl.
+  inv REACT. hexploit backward_simulation_star; eauto.
+  { i. specialize (SAFE (t0 *** T)). hexploit SAFE; i.
+    { eapply trinf_rel_app; eauto. eapply trinf_rel_refl. }
+    instantiate (1:=Reacts T). ss. }
+  i. des.
+  assert (t0 <> E0).
+  { destruct t0; ss. inv H2. clarify. }
+  esplits; eauto.
+  { i. specialize (SAFE (t0 *** T1)).
+    hexploit SAFE; i.
+    { eapply trinf_rel_app; eauto. }
+    eapply star_safe_along; try eapply H3; eauto.
+    { erewrite <- tr_rel_intact; eauto. ii. destruct ev1, ev2; ss. } }
+  erewrite <- tr_rel_intact; eauto. ii. destruct ev1, ev2; ss.
 Qed.
 
-Lemma atomic_forever_silent_forever_silent:
-  forall s, Forever_silent (atomic L) s -> Forever_silent L (snd s).
+Lemma backward_simulation_forever_reactive
+    i s1 s2 T2
+    (MATCH: match_states i s1 s2)
+    (REACT: Forever_reactive L2 s2 T2)
+    (SAFE: forall T1, trinf_rel (ev_rel pim) T1 T2 -> safe_along_behavior s1 (Reacts T1)) :
+  exists T1, trinf_rel (ev_rel pim) T1 T2 /\ Forever_reactive L1 s1 T1.
 Proof.
-  cofix COINDHYP; intros. inv H. inv H0.
-  apply forever_silent_intro with (snd (E0, s')). auto. apply COINDHYP; auto.
+  assert (INF:= trinf_clos_coind backward_simulation_forever_reactive_step
+                (exist _ (i,s1,s2,T2) (conj MATCH (conj REACT SAFE)))).
+  des. exists inf. split.
+  { revert_until match_states. pcofix CIH. i.
+    punfold INF. inv INF. destruct REL as [NE REL].
+    destruct x' as [[[[i' s1'] s2'] T2'] [MATCH' [REACT' SAFE']]].
+    ss. pclearbot. des. subst.
+    clear i s1 s2 MATCH SAFE REACT REL1 REL2.
+    move tr before CIH. revert_until tr. induction tr; i.
+    { exfalso. apply NE. eauto. }
+    inv REL0. pstep. s. econs; eauto.
+    destruct tr; inv H3; eauto.
+    left. eapply IHtr; ii; ss; eauto.
+    econs; eauto. }
+  { eapply forever_reactive2_forever_reactive.
+    revert_until match_states. pcofix CIH. i.
+    punfold INF. inv INF. destruct REL as [NE REL].
+    destruct x' as [[[[i' s1'] s2'] T2'] [MATCH' [REACT' SAFE']]].
+    ss. pclearbot. des. subst.
+    pstep. econs. esplits; eauto. }
 Qed.
 
-Remark star_atomic_output_trace:
-  forall s t t' s',
-  Star (atomic L) (E0, s) t (t', s') -> output_trace t'.
+Lemma backward_simulation_state_behaves:
+  forall i s1 s2 beh2,
+  match_states i s1 s2 -> state_behaves L2 s2 beh2 ->
+  exists pim1 beh1, state_behaves L1 s1 beh1 /\ observation_improves (Some pim1, beh1) (Some pim, beh2).
 Proof.
-  assert (forall ts1 t ts2, Star (atomic L) ts1 t ts2 ->
-          output_trace (fst ts1) -> output_trace (fst ts2)).
-  induction 1; intros. auto. inv H; simpl in *.
-  apply IHstar. auto.
-  apply IHstar. exploit Lwb; eauto.
-  destruct H2. apply IHstar. auto.
-  intros. change t' with (fst (t',s')). eapply H; eauto. simpl; auto.
+  intros. destruct (classic (forall beh1, behav_rel pim beh1 beh2 -> (safe_along_behavior s1 (behavior_app E0 beh1)))).
+(* 1. Safe along *)  
+- pose (beh2_ := beh2).
+  inv H0.
+  (* termination *)
+  + exploit backward_simulation_star; eauto.
+    { instantiate (1:= Terminates E0 r). i. specialize (H1 (behavior_app t0 (Terminates E0 r))).
+      hexploit H1.
+      { r. ss. esplits; eauto. traceEq. }
+      i. ss. }
+    i. des. hexploit match_states_final; eauto.
+    { eapply safe_along_safe. eapply star_safe_along; try eapply H4; eauto.
+      - erewrite <- tr_rel_intact; eauto. i. destruct ev1, ev2; ss.
+      - instantiate (1:= Terminates E0 r).
+        specialize (H1 (Terminates t0 r)). hexploit H1; eauto.
+        { r. ss. }
+        i; ss. traceEq. }
+    i. des. subst. exists pim. exists (Terminates t0 r). splits.
+    2:{ rr. ss. esplits; eauto. econs; eauto. ss. rr. eauto. }
+    econs; try eapply FINAL.
+    2:{ eapply star_trans; eauto. traceEq. }
+    erewrite <- tr_rel_intact; eauto. i. destruct ev1, ev2; ss.
+  (* partial termination *)
+  + exploit backward_simulation_star_pterm; eauto.
+    { instantiate (1:= Partial_terminates E0).
+      i. specialize (H1 (Partial_terminates (trace_cut_pterm t0))).
+      hexploit H1; eauto.
+      { r. eapply tr_rel_cut_pterm; eauto. i. destruct ev1, ev2; ss. }
+      ss. traceEq. }
+    i. des. generalize (state_behaves_exists L1 s1'); intro T. des.
+    destruct (classic (trace_intact tl)).
+    * exists pim. exists (behavior_app t0 beh). esplits; eauto.
+      { eapply state_behaves_app; eauto.
+        erewrite <- tr_rel_intact; cycle 2; eauto.
+        2:{ i. destruct ev1, ev2; ss. }
+        eapply trace_intact_app; eauto. eapply trace_cut_pterm_intact. }
+      r. ss. split; ii; ss. right. right.
+      exploit tr_rel_div_r; eauto. i. des. subst.
+      exists (trace_cut_pterm t). exists t1'. esplits; eauto. erewrite behavior_app_assoc; eauto.
+      r. esplits; eauto.
+    * exists pim. exists (Partial_terminates (trace_cut_pterm t0)). esplits.
+      { econs; eauto. ii. eapply H0. erewrite <- tr_rel_intact in H2; cycle 2.
+        { eauto. }
+        2:{ ii. destruct ev1, ev2; ss. }
+        eapply trace_intact_app_rev in H2. des; eauto. }
+      r. ss. esplits; ii; ss. r. right. right.
+      exploit tr_rel_div_r; eauto. i. des. subst.
+      exists (trace_cut_pterm t). exists t1'. esplits; eauto.
+      erewrite trace_cut_pterm_intact_app.
+      2:{ erewrite <- tr_rel_intact; eauto.
+          - eapply trace_cut_pterm_intact.
+          - ii. destruct ev1, ev2; ss. }
+      r. exists (Partial_terminates (trace_cut_pterm t2')). ss.
+  (* diverges *)
+  + exploit backward_simulation_star; eauto.
+    { instantiate (1:= Diverges E0). i. specialize (H1 (behavior_app t0 (Diverges E0))).
+      hexploit H1.
+      { r. ss. esplits; eauto. traceEq. }
+      i. ss. }
+    i. des. exploit backward_simulation_forever_silent; eauto.
+    { specialize (H1 (Diverges t0)). hexploit H1; eauto.
+      i. ss. eapply safe_along_safe. eapply star_safe_along; try eapply H4; eauto.
+      - erewrite <- tr_rel_intact; eauto. ii. destruct ev1, ev2; ss.
+      - instantiate (1:= Diverges E0). ss. traceEq. }
+    i. exists pim. exists (Diverges t0). esplits; eauto.
+    2:{ r. ss. split; ii; eauto. econs. ss. }
+    econs; eauto. erewrite <- tr_rel_intact; eauto. ii. destruct ev1, ev2; ss.
+  (* reacts *)
+  + exploit backward_simulation_forever_reactive; eauto.
+    { i. specialize (H1 (Reacts T1)). ss. eapply H1; eauto. }
+    i. des. exists pim. exists (Reacts T1). esplits; eauto.
+    2:{ econs; eauto; ss. r. ss. left. eauto. }
+    econs; eauto.
+  (* goes wrong *)
+  + exploit backward_simulation_star; eauto.
+    { instantiate (1:= Goes_wrong E0). i. specialize (H1 (behavior_app t0 (Goes_wrong E0))).
+      hexploit H1.
+      { r. ss. esplits; eauto. traceEq. }
+      i. ss. }
+    i. des. exploit match_states_progress; eauto.
+    { specialize (H1 (Goes_wrong t0)).
+      hexploit H1; eauto. i. ss.
+      hexploit star_safe_along; try eapply H5; eauto; cycle 1.
+      { instantiate (1:= Goes_wrong E0). ss. traceEq. }
+      { i. eapply safe_along_safe; eauto. }
+      erewrite <- tr_rel_intact; eauto. ii. destruct ev1, ev2; ss. }
+    i. des.
+    * eapply H4 in FINAL. clarify.
+    * exfalso. eapply H3. eauto.
+(* 2. Not safe along *)      
+- eapply not_all_ex_not in H1. des. eapply imply_to_and in H1. des.
+  rewrite behavior_app_E0 in *.
+  exploit not_safe_along_behavior; eauto.
+  intros [t [s1' [INTACT [PREF [STEPS [NOSTEP NOFIN]]]]]].
+  exists pim. exists (Goes_wrong t); split.
+  econstructor; eauto.
+  r. split; [|ss].
+  + right. left. ss.
+    assert (exists t', tr_rel (ev_rel pim) t t' /\ behavior_prefix t' beh2).
+    { eapply prefix_tr_rel; eauto. }
+    des. exists t; exists t'; auto.
 Qed.
 
-Lemma atomic_forever_reactive_forever_reactive:
-  forall s T, Forever_reactive (atomic L) (E0,s) T -> Forever_reactive L s T.
-Proof.
-  assert (forall t s T, Forever_reactive (atomic L) (t,s) T ->
-          exists T', Forever_reactive (atomic L) (E0,s) T' /\ T = t *** T').
-  induction t; intros. exists T; auto.
-  inv H. inv H0. congruence. simpl in H; inv H.
-  destruct (IHt s (t2***T0)) as [T' [A B]]. eapply star_forever_reactive; eauto.
-  exists T'; split; auto. simpl. congruence.
-
-  cofix COINDHYP; intros. inv H0. destruct s2 as [t2 s2].
-  destruct (H _ _ _ H3) as [T' [A B]].
-  assert (Star (atomic L) (E0, s) (t**t2) (E0, s2)).
-    eapply star_trans. eauto. apply atomic_finish. eapply star_atomic_output_trace; eauto. auto.
-  replace (t *** T0) with ((t ** t2) *** T'). apply forever_reactive_intro with s2.
-  apply atomic_star_star; auto. destruct t; simpl in *; unfold E0 in *; congruence.
-  apply COINDHYP. auto.
-  subst T0; traceEq.
-Qed.
+End BACKWARD_SIMULATIONS.
 
-Theorem atomic_behaviors:
-  forall beh, program_behaves L beh <-> program_behaves (atomic L) beh.
+Theorem backward_simulation_observation_improves:
+  forall L1 L2, NOSTUTTER.backward_simulation L1 L2 ->
+  forall obs2, program_observes L2 obs2 ->
+  exists obs1, program_observes L1 obs1 /\ observation_improves obs1 obs2.
 Proof.
-  intros; split; intros.
-- (* L -> atomic L *)
-  exploit forward_simulation_behavior_improves. eapply atomic_forward_simulation. eauto.
-  intros [beh2 [A B]]. red in B. destruct B as [EQ | [t [C D]]].
-  congruence.
-  subst beh. inv H. inv H1.
-  apply program_runs with (E0,s). simpl; auto.
-  apply state_goes_wrong with (E0,s'). apply star_atomic_star; auto.
-  red; intros; red; intros. inv H. eelim H3; eauto. eelim H3; eauto.
-  intros; red; intros. simpl in H. destruct H. eelim H4; eauto.
+  intros L1 L2 S obs2 H. destruct S as [index order S]. inv H.
+- (* L2's initial state is defined. *)
+  destruct (classic (exists s1, initial_state L1 s1)) as [[s1 INIT] | NOINIT].
++ (* L1's initial state is defined too. *)
+  exploit (NOSTUTTER.bsim_match_initial_states S); eauto. i. des.
+  exploit backward_simulation_state_behaves; eauto.
+  i. des. esplits.
+  { econs; eauto. }
+  r. ss. inv H2. split; eauto.
++ (* L1 has no initial state *)
+  exists (Some (fun _ => None), Goes_wrong E0); split.
   apply program_goes_initially_wrong.
-  intros; red; intros. simpl in H; destruct H. eelim H1; eauto.
-- (* atomic L -> L *)
-  inv H.
-+ (* initial state defined *)
-  destruct s as [t s]. simpl in H0. destruct H0; subst t.
-  apply program_runs with s; auto.
-  inv H1.
-* (* termination *)
-  destruct s' as [t' s']. simpl in H2; destruct H2; subst t'.
-  econstructor. eapply atomic_star_star; eauto. auto.
-* (* silent divergence *)
-  destruct s' as [t' s'].
-  assert (t' = E0). inv H2. inv H1; auto. subst t'.
-  econstructor. eapply atomic_star_star; eauto.
-  change s' with (snd (E0,s')). apply atomic_forever_silent_forever_silent. auto.
-* (* reactive divergence *)
-  econstructor. apply atomic_forever_reactive_forever_reactive. auto.
-* (* going wrong *)
-  destruct s' as [t' s'].
-  assert (t' = E0).
-    destruct t'; auto. eelim H2. simpl. apply atomic_step_continue.
-    eapply star_atomic_output_trace; eauto.
-  subst t'. econstructor. apply atomic_star_star; eauto.
-  red; intros; red; intros. destruct t0.
-  elim (H2 E0 (E0,s'0)). constructor; auto.
-  elim (H2 (e::nil) (t0,s'0)). constructor; auto.
-  intros; red; intros. elim (H3 r). simpl; auto.
-+ (* initial state undefined *)
+  intros; red; intros. elim NOINIT; exists s0; auto.
+  eapply observation_improves_bot. r. i; clarify.
+- (* L2 has no initial state *)
+  exists (Some (fun _ => None), Goes_wrong E0); split.
   apply program_goes_initially_wrong.
-  intros; red; intros. elim (H0 (E0,s)); simpl; auto.
-Qed.
-
-End ATOMIC.
-
-(** * Additional results about infinite reduction sequences *)
-
-(** We now show that any infinite sequence of reductions is either of
-  the "reactive" kind or of the "silent" kind (after a finite number
-  of non-silent transitions).  The proof necessitates the axiom of
-  excluded middle.  This result is used below to relate
-  the coinductive big-step semantics for divergence with the
-  small-step notions of divergence. *)
-
-Unset Implicit Arguments.
-
-Section INF_SEQ_DECOMP.
-
-Variable genv: Type.
-Variable state: Type.
-Variable step: genv -> state -> trace -> state -> Prop.
-
-Variable ge: genv.
-
-Inductive tstate: Type :=
-  ST: forall (s: state) (T: traceinf), forever step ge s T -> tstate.
-
-Definition state_of_tstate (S: tstate): state :=
-  match S with ST s T F => s end.
-Definition traceinf_of_tstate (S: tstate) : traceinf :=
-  match S with ST s T F => T end.
-
-Inductive tstep: trace -> tstate -> tstate -> Prop :=
-  | tstep_intro: forall s1 t T s2 S F,
-      tstep t (ST s1 (t *** T) (@forever_intro genv state step ge s1 t s2 T S F))
-              (ST s2 T F).
-
-Inductive tsteps: tstate -> tstate -> Prop :=
-  | tsteps_refl: forall S, tsteps S S
-  | tsteps_left: forall t S1 S2 S3, tstep t S1 S2 -> tsteps S2 S3 -> tsteps S1 S3.
-
-Remark tsteps_trans:
-  forall S1 S2, tsteps S1 S2 -> forall S3, tsteps S2 S3 -> tsteps S1 S3.
-Proof.
-  induction 1; intros. auto. econstructor; eauto.
-Qed.
-
-Let treactive (S: tstate) : Prop :=
-  forall S1,
-  tsteps S S1 ->
-  exists S2, exists S3, exists t, tsteps S1 S2 /\ tstep t S2 S3 /\ t <> E0.
-
-Let tsilent (S: tstate) : Prop :=
-  forall S1 t S2, tsteps S S1 -> tstep t S1 S2 -> t = E0.
-
-Lemma treactive_or_tsilent:
-  forall S, treactive S \/ (exists S', tsteps S S' /\ tsilent S').
-Proof.
-  intros. destruct (classic (exists S', tsteps S S' /\ tsilent S')).
-  auto.
-  left. red; intros.
-  generalize (not_ex_all_not _ _ H S1). intros.
-  destruct (not_and_or _ _ H1). contradiction.
-  unfold tsilent in H2.
-  generalize (not_all_ex_not _ _ H2). intros [S2 A].
-  generalize (not_all_ex_not _ _ A). intros [t B].
-  generalize (not_all_ex_not _ _ B). intros [S3 C].
-  generalize (imply_to_and _ _ C). intros [D F].
-  generalize (imply_to_and _ _ F). intros [G J].
-  exists S2; exists S3; exists t. auto.
-Qed.
-
-Lemma tsteps_star:
-  forall S1 S2, tsteps S1 S2 ->
-  exists t, star step ge (state_of_tstate S1) t (state_of_tstate S2)
-         /\ traceinf_of_tstate S1 = t *** traceinf_of_tstate S2.
-Proof.
-  induction 1.
-  exists E0; split. apply star_refl. auto.
-  inv H. destruct IHtsteps as [t' [A B]].
-  exists (t ** t'); split.
-  simpl; eapply star_left; eauto.
-  simpl in *. subst T. traceEq.
-Qed.
-
-Lemma tsilent_forever_silent:
-  forall S,
-  tsilent S -> forever_silent step ge (state_of_tstate S).
-Proof.
-  cofix COINDHYP; intro S. case S. intros until f. simpl. case f. intros.
-  assert (tstep t (ST s1 (t *** T0) (forever_intro s1 t s0 f0))
-                  (ST s2 T0 f0)).
-    constructor.
-  assert (t = E0).
-    red in H. eapply H; eauto. apply tsteps_refl.
-  apply forever_silent_intro with (state_of_tstate (ST s2 T0 f0)).
-  rewrite <- H1. assumption.
-  apply COINDHYP.
-  red; intros. eapply H. eapply tsteps_left; eauto. eauto.
-Qed.
-
-Lemma treactive_forever_reactive:
-  forall S,
-  treactive S -> forever_reactive step ge (state_of_tstate S) (traceinf_of_tstate S).
-Proof.
-  cofix COINDHYP; intros.
-  destruct (H S) as [S1 [S2 [t [A [B C]]]]]. apply tsteps_refl.
-  destruct (tsteps_star _ _ A) as [t' [P Q]].
-  inv B. simpl in *. rewrite Q. rewrite <- Eappinf_assoc.
-  apply forever_reactive_intro with s2.
-  eapply star_right; eauto.
-  red; intros. destruct (Eapp_E0_inv _ _ H0). contradiction.
-  change (forever_reactive step ge (state_of_tstate (ST s2 T F)) (traceinf_of_tstate (ST s2 T F))).
-  apply COINDHYP.
-  red; intros. apply H.
-  eapply tsteps_trans. eauto.
-  eapply tsteps_left. constructor. eauto.
-Qed.
-
-Theorem forever_silent_or_reactive:
-  forall s T,
-  forever step ge s T ->
-  forever_reactive step ge s T \/
-  exists t, exists s', exists T',
-  star step ge s t s' /\ forever_silent step ge s' /\ T = t *** T'.
-Proof.
-  intros.
-  destruct (treactive_or_tsilent (ST s T H)).
-  left.
-  change (forever_reactive step ge (state_of_tstate (ST s T H)) (traceinf_of_tstate (ST s T H))).
-  apply treactive_forever_reactive. auto.
-  destruct H0 as [S' [A B]].
-  exploit tsteps_star; eauto. intros [t [C D]]. simpl in *.
-  right. exists t; exists (state_of_tstate S'); exists (traceinf_of_tstate S').
-  split. auto.
-  split. apply tsilent_forever_silent. auto.
-  auto.
+  intros; red; intros.
+  exploit (NOSTUTTER.bsim_initial_states_exist S); eauto. intros [s2 INIT2].
+  elim (H0 s2); auto.
+  eapply observation_improves_refl.
+- (* L2 has no captured initial state *)
+  specialize (program_observes_exists L1). i. des.
+  (* exists (None, Partial_terminates E0); split. *)
+  (* eapply program_goes_initially_capture_wrong; eauto. *)
+  exists obs. esplits; eauto.
+  r. ss. split; auto. r. des_ifs.
 Qed.
 
-End INF_SEQ_DECOMP.
-
 Set Implicit Arguments.
 
 (** * Big-step semantics and program behaviors *)
@@ -826,25 +1371,25 @@ Variable B: bigstep_semantics.
 Variable L: semantics.
 Hypothesis sound: bigstep_sound B L.
 
-Lemma behavior_bigstep_terminates:
-  forall t r,
-  bigstep_terminates B t r -> program_behaves L (Terminates t r).
-Proof.
-  intros. exploit (bigstep_terminates_sound sound); eauto.
-  intros [s1 [s2 [P [Q R]]]].
-  econstructor; eauto. econstructor; eauto.
-Qed.
-
-Lemma behavior_bigstep_diverges:
-  forall T,
-  bigstep_diverges B T ->
-  program_behaves L (Reacts T)
-  \/ exists t, program_behaves L (Diverges t) /\ traceinf_prefix t T.
-Proof.
-  intros. exploit (bigstep_diverges_sound sound); eauto. intros [s1 [P Q]].
-  exploit forever_silent_or_reactive; eauto. intros [X | [t [s' [T' [X [Y Z]]]]]].
-  left. econstructor; eauto. constructor; auto.
-  right. exists t; split. econstructor; eauto. econstructor; eauto. exists T'; auto.
-Qed.
+(* Lemma behavior_bigstep_terminates: *)
+(*   forall t r, *)
+(*   bigstep_terminates B t r -> program_behaves L (Terminates t r). *)
+(* Proof. *)
+(*   (* intros. exploit (bigstep_terminates_sound sound); eauto. *) *)
+(*   (* intros [s1 [s2 [P [Q [R INTACT]]]]]. *) *)
+(*   (* econstructor; eauto. econstructor; eauto. *) *)
+(* Qed. *)
+
+(* Lemma behavior_bigstep_diverges: *)
+(*   forall T, *)
+(*   bigstep_diverges B T -> *)
+(*   program_behaves L (Reacts T) *)
+(*   \/ exists t, program_behaves L (Diverges t) /\ traceinf_prefix t T. *)
+(* Proof. *)
+(*   intros. exploit (bigstep_diverges_sound sound); eauto. intros [s1 [P Q]]. *)
+(*   (* exploit forever_silent_or_reactive; eauto. intros [X | [t [s' [T' [X [Y [Z INTACT]]]]]]]. *) *)
+(*   (* left. econstructor; eauto. constructor; auto. *) *)
+(*   (* right. exists t; split. econstructor; eauto. econstructor; eauto. exists T'; auto. *) *)
+(* Qed. *)
 
 End BIGSTEP_BEHAVIORS.
diff --git a/common/Builtins0.v b/common/Builtins0.v
index 384dde1e..6c972e41 100644
--- a/common/Builtins0.v
+++ b/common/Builtins0.v
@@ -18,6 +18,7 @@
 
 Require Import String Coqlib.
 Require Import AST Integers Floats Values Memdata.
+Require Import Memory IntPtrRel.
 
 (** This module provides definitions and mechanisms to associate semantics
   with names of built-in functions.
@@ -37,6 +38,13 @@ Definition val_opt_inject (j: meminj) (ov ov': option val) : Prop :=
   | _, None => False
   end.
 
+Definition val_opt_binded (m: Mem.mem) (ov ov': option val) : Prop :=
+  match ov, ov' with
+  | None, _ => True
+  | Some v, Some v' => val_intptr m v v'
+  | _, None => False
+  end.
+
 (** The semantics of a built-in function is a partial function
   from list of values to values.  
   It must agree with the return type stated in the signature,
@@ -48,7 +56,9 @@ Record builtin_sem (tret: rettype) : Type := mkbuiltin {
   bs_well_typed: forall vl, 
     val_opt_has_rettype (bs_sem vl) tret;
   bs_inject: forall j vl vl',
-    Val.inject_list j vl vl' -> val_opt_inject j (bs_sem vl) (bs_sem vl')
+    Val.inject_list j vl vl' -> val_opt_inject j (bs_sem vl) (bs_sem vl');
+  bs_binded: forall m vl vl',
+    val_intptrist m vl vl' -> val_opt_binded m (bs_sem vl) (bs_sem vl')
 }.
 
 (** Builtin functions can be created from functions over values, such as those
@@ -63,69 +73,96 @@ Local Unset Program Cases.
 Program Definition mkbuiltin_v1t 
      (tret: rettype) (f: val -> val)
      (WT: forall v1, Val.has_rettype (f v1) tret)
-     (INJ: forall j v1 v1', Val.inject j v1 v1' -> Val.inject j (f v1) (f v1')) :=
-  mkbuiltin tret (fun vl => match vl with v1 :: nil => Some (f v1) | _ => None end) _ _.
+     (INJ: forall j v1 v1', Val.inject j v1 v1' -> Val.inject j (f v1) (f v1'))
+     (BIND: forall m v1 v1', val_intptr m v1 v1' -> val_intptr m (f v1) (f v1')) :=
+  mkbuiltin tret (fun vl => match vl with v1 :: nil => Some (f v1) | _ => None end) _ _ _.
 Next Obligation.
   red; destruct vl; auto. destruct vl; auto.
 Qed.
 Next Obligation.
   red; inv H; auto. inv H1; auto. 
 Qed.
+Next Obligation.
+  red; inv H; auto. inv H1; auto.
+Qed.
 
 Program Definition mkbuiltin_v2t 
      (tret: rettype) (f: val -> val -> val)
      (WT: forall v1 v2, Val.has_rettype (f v1 v2) tret)
      (INJ: forall j v1 v1' v2 v2',
            Val.inject j v1 v1' -> Val.inject j v2 v2' ->
-           Val.inject j (f v1 v2) (f v1' v2')) :=
-  mkbuiltin tret (fun vl => match vl with v1 :: v2 :: nil => Some (f v1 v2) | _ => None end) _ _.
+           Val.inject j (f v1 v2) (f v1' v2'))
+     (BIND: forall m v1 v1' v2 v2',
+           val_intptr m v1 v1' -> val_intptr m v2 v2' ->
+           val_intptr m (f v1 v2) (f v1' v2')) :=
+  mkbuiltin tret (fun vl => match vl with v1 :: v2 :: nil => Some (f v1 v2) | _ => None end) _ _ _.
 Next Obligation.
   red; destruct vl; auto. destruct vl; auto. destruct vl; auto.
 Qed.
 Next Obligation.
   red; inv H; auto. inv H1; auto. inv H2; auto.
 Qed.
+Next Obligation.
+  red; inv H; auto. inv H1; auto. inv H2; auto.
+Qed.
 
 Program Definition mkbuiltin_v3t 
      (tret: rettype) (f: val -> val -> val -> val)
      (WT: forall v1 v2 v3, Val.has_rettype (f v1 v2 v3) tret)
      (INJ: forall j v1 v1' v2 v2' v3 v3',
            Val.inject j v1 v1' -> Val.inject j v2 v2' -> Val.inject j v3 v3' ->
-           Val.inject j (f v1 v2 v3) (f v1' v2' v3')) :=
-  mkbuiltin tret (fun vl => match vl with v1 :: v2 :: v3 :: nil => Some (f v1 v2 v3) | _ => None end) _ _.
+           Val.inject j (f v1 v2 v3) (f v1' v2' v3'))
+     (BIND: forall m v1 v1' v2 v2' v3 v3',
+           val_intptr m v1 v1' -> val_intptr m v2 v2' -> val_intptr m v3 v3' ->
+           val_intptr m (f v1 v2 v3) (f v1' v2' v3')) :=
+  mkbuiltin tret (fun vl => match vl with v1 :: v2 :: v3 :: nil => Some (f v1 v2 v3) | _ => None end) _ _ _.
 Next Obligation.
   red; destruct vl; auto. destruct vl; auto. destruct vl; auto. destruct vl; auto.
 Qed.
 Next Obligation.
   red; inv H; auto. inv H1; auto. inv H2; auto. inv H3; auto.
 Qed.
+Next Obligation.
+  red; inv H; auto. inv H1; auto. inv H2; auto. inv H3; auto.
+Qed.
 
 Program Definition mkbuiltin_v1p
      (tret: rettype) (f: val -> option val)
      (WT: forall v1, val_opt_has_rettype (f v1) tret)
      (INJ: forall j v1 v1',
-        Val.inject j v1 v1' -> val_opt_inject j (f v1) (f v1')) :=
-  mkbuiltin tret (fun vl => match vl with v1 :: nil => f v1 | _ => None end) _ _.
+        Val.inject j v1 v1' -> val_opt_inject j (f v1) (f v1'))
+     (BIND: forall m v1 v1',
+        val_intptr m v1 v1' -> val_opt_binded m (f v1) (f v1')) :=
+  mkbuiltin tret (fun vl => match vl with v1 :: nil => f v1 | _ => None end) _ _ _.
 Next Obligation.
   red; destruct vl; auto. destruct vl; auto. apply WT.
 Qed.
 Next Obligation.
   red; inv H; auto. inv H1; auto. apply INJ; auto. 
 Qed.
+Next Obligation.
+  red; inv H; auto. inv H1; auto. apply BIND; auto. 
+Qed.
 
 Program Definition mkbuiltin_v2p
      (tret: rettype) (f: val -> val -> option val)
      (WT: forall v1 v2, val_opt_has_rettype (f v1 v2) tret)
      (INJ: forall j v1 v1' v2 v2',
         Val.inject j v1 v1' -> Val.inject j v2 v2' ->
-        val_opt_inject j (f v1 v2) (f v1' v2')) :=
-  mkbuiltin tret (fun vl => match vl with v1 :: v2 :: nil => f v1 v2 | _ => None end)  _ _.
+        val_opt_inject j (f v1 v2) (f v1' v2'))
+     (BIND: forall m v1 v1' v2 v2',
+        val_intptr m v1 v1' -> val_intptr m v2 v2' ->
+        val_opt_binded m (f v1 v2) (f v1' v2')) :=
+  mkbuiltin tret (fun vl => match vl with v1 :: v2 :: nil => f v1 v2 | _ => None end)  _ _ _.
 Next Obligation.
   red; destruct vl; auto. destruct vl; auto. destruct vl; auto. apply WT.
 Qed.
 Next Obligation.
   red; inv H; auto. inv H1; auto. inv H2; auto. apply INJ; auto. 
 Qed.
+Next Obligation.
+  red; inv H; auto. inv H1; auto. inv H2; auto. apply BIND; auto. 
+Qed.
 
 (** For numerical functions, involving only integers and floating-point numbers
   but no pointer values, we can automate the proofs of well-typedness and
@@ -172,6 +209,11 @@ Proof.
   destruct t; intros; constructor.
 Qed.
 
+Lemma inj_num_binded: forall m t x, val_intptr m (inj_num t x) (inj_num t x).
+Proof.
+  destruct t; intros; constructor.
+Qed.
+
 Lemma inj_num_opt_wt: forall t x, val_opt_has_rettype (option_map (inj_num t) x) t.
 Proof.
   intros. destruct x; simpl. apply inj_num_wt. auto. 
@@ -183,6 +225,12 @@ Proof.
   destruct x; simpl. apply inj_num_inject. auto.
 Qed.
 
+Lemma inj_num_opt_binded: forall m t x,
+  val_opt_binded m (option_map (inj_num t) x) (option_map (inj_num t) x).
+Proof.
+  destruct x; simpl. apply inj_num_binded. auto.
+Qed.
+
 Lemma proj_num_wt:
   forall tres t k1 v,
   (forall x, Val.has_type (k1 x) tres) ->
@@ -200,6 +248,15 @@ Proof.
   intros. destruct t; simpl; inv H0; auto.
 Qed.
 
+Lemma proj_num_binded:
+  forall m t k1 v k1' v',
+  (forall x, val_intptr m (k1 x) (k1' x)) ->
+  val_intptr m v v' -> 
+  val_intptr m (proj_num t Vundef v k1) (proj_num t Vundef v' k1').
+Proof.
+  intros. destruct t; simpl; inv H0; auto; try by econs.
+Qed.
+
 Lemma proj_num_opt_wt:
   forall (tres: typ) t k0 k1 v,
   k0 = None \/ k0 = Some Vundef ->
@@ -221,6 +278,16 @@ Proof.
   intros. destruct t; simpl; inv H1; auto.
 Qed.
 
+Lemma proj_num_opt_binded:
+  forall m k0 t k1 v k1' v',
+  (forall ov, val_opt_binded m k0 ov) ->
+  (forall x, val_opt_binded m (k1 x) (k1' x)) ->
+  val_intptr m v v' -> 
+  val_opt_binded m (proj_num t k0 v k1) (proj_num t k0 v' k1').
+Proof.
+  intros. destruct t; simpl; inv H1; auto.
+Qed.
+
 (** Wrapping numerical functions as built-ins.  The constructor functions
   have names
 - [mkbuiltin_nNt] for a [t]otal function of [N] numbers, or
@@ -232,13 +299,16 @@ Program Definition mkbuiltin_n1t
     (f: valty targ1 -> valty tres) :=
   mkbuiltin_v1t tres
     (fun v1 => proj_num targ1 Vundef v1 (fun x => inj_num tres (f x)))
-    _ _.
+    _ _ _.
 Next Obligation.
   auto using proj_num_wt, inj_num_wt.
 Qed.
 Next Obligation.
   auto using proj_num_inject, inj_num_inject.
 Qed.
+Next Obligation.
+  auto using proj_num_binded, inj_num_binded.
+Qed.
 
 Program Definition mkbuiltin_n2t 
     (targ1 targ2: typ) (tres: typ)
@@ -247,13 +317,16 @@ Program Definition mkbuiltin_n2t
     (fun v1 v2 =>
        proj_num targ1 Vundef v1 (fun x1 =>
        proj_num targ2 Vundef v2 (fun x2 => inj_num tres (f x1 x2))))
-    _ _.
+    _ _ _.
 Next Obligation.
   auto using proj_num_wt, inj_num_wt.
 Qed.
 Next Obligation.
   auto using proj_num_inject, inj_num_inject.
 Qed.
+Next Obligation.
+  auto using proj_num_binded, inj_num_binded.
+Qed.
 
 Program Definition mkbuiltin_n3t 
     (targ1 targ2 targ3: typ) (tres: typ)
@@ -263,26 +336,32 @@ Program Definition mkbuiltin_n3t
        proj_num targ1 Vundef v1 (fun x1 =>
        proj_num targ2 Vundef v2 (fun x2 =>
        proj_num targ3 Vundef v3 (fun x3 => inj_num tres (f x1 x2 x3)))))
-    _ _.
+    _ _ _.
 Next Obligation.
   auto using proj_num_wt, inj_num_wt.
 Qed.
 Next Obligation.
   auto using proj_num_inject, inj_num_inject.
 Qed.
+Next Obligation.
+  auto using proj_num_binded, inj_num_binded.
+Qed.
 
 Program Definition mkbuiltin_n1p
     (targ1: typ) (tres: typ)
     (f: valty targ1 -> option (valty tres)) :=
   mkbuiltin_v1p tres
     (fun v1 => proj_num targ1 None v1 (fun x => option_map (inj_num tres) (f x)))
-    _ _.
+    _ _ _.
 Next Obligation.
   auto using proj_num_opt_wt, inj_num_opt_wt.
 Qed.
 Next Obligation.
   apply proj_num_opt_inject; auto. intros; red; auto. intros; apply inj_num_opt_inject.
 Qed.
+Next Obligation.
+  apply proj_num_opt_binded; auto. intros; red; auto. intros; apply inj_num_opt_binded.
+Qed.
 
 Program Definition mkbuiltin_n2p
     (targ1 targ2: typ) (tres: typ)
@@ -291,7 +370,7 @@ Program Definition mkbuiltin_n2p
     (fun v1 v2 =>
       proj_num targ1 None v1 (fun x1 =>
       proj_num targ2 None v2 (fun x2 => option_map (inj_num tres) (f x1 x2))))
-    _ _.
+    _ _ _.
 Next Obligation.
   auto using proj_num_opt_wt, inj_num_opt_wt.
 Qed.
@@ -300,6 +379,11 @@ Next Obligation.
   apply proj_num_opt_inject; auto. intros; red; auto. intros.
   apply inj_num_opt_inject.
 Qed.
+Next Obligation.
+  apply proj_num_opt_binded; auto. intros; red; auto. intros.
+  apply proj_num_opt_binded; auto. intros; red; auto. intros.
+  apply inj_num_opt_binded.
+Qed.
 
 (** Looking up builtins by name and signature *)
 
@@ -436,14 +520,14 @@ Program Definition standard_builtin_sem (b: standard_builtin) : builtin_sem (sig
        (fun vargs => match vargs with
           | Vint n :: v1 :: v2 :: nil => Some (Val.normalize (if Int.eq n Int.zero then v2 else v1) t)
           | _ => None
-        end) _ _
+        end) _ _ _
   | BI_fabs => mkbuiltin_n1t Tfloat Tfloat Float.abs
   | BI_fabsf => mkbuiltin_n1t Tsingle Tsingle Float32.abs
   | BI_fsqrt => mkbuiltin_n1t Tfloat Tfloat Float.sqrt
   | BI_negl => mkbuiltin_n1t Tlong Tlong Int64.neg
-  | BI_addl => mkbuiltin_v2t Tlong Val.addl _ _ 
-  | BI_subl => mkbuiltin_v2t Tlong Val.subl _ _
-  | BI_mull => mkbuiltin_v2t Tlong Val.mull' _ _
+  | BI_addl => mkbuiltin_v2t Tlong Val.addl _ _ _
+  | BI_subl => mkbuiltin_v2t Tlong Val.subl _ _ _
+  | BI_mull => mkbuiltin_v2t Tlong Val.mull' _ _ _
   | BI_i16_bswap =>
     mkbuiltin_n1t Tint Tint
                   (fun n => Int.repr (decode_int (List.rev (encode_int 2%nat (Int.unsigned n)))))
@@ -453,16 +537,16 @@ Program Definition standard_builtin_sem (b: standard_builtin) : builtin_sem (sig
   | BI_i64_bswap =>
     mkbuiltin_n1t Tlong Tlong
                   (fun n => Int64.repr (decode_int (List.rev (encode_int 8%nat (Int64.unsigned n)))))
-  | BI_unreachable => mkbuiltin Tvoid (fun vargs => None) _ _
+  | BI_unreachable => mkbuiltin Tvoid (fun vargs => None) _ _ _
   | BI_i64_umulh => mkbuiltin_n2t Tlong Tlong Tlong Int64.mulhu
   | BI_i64_smulh => mkbuiltin_n2t Tlong Tlong Tlong Int64.mulhs
-  | BI_i64_sdiv => mkbuiltin_v2p Tlong Val.divls _ _
-  | BI_i64_udiv => mkbuiltin_v2p Tlong Val.divlu _ _
-  | BI_i64_smod => mkbuiltin_v2p Tlong Val.modls _ _
-  | BI_i64_umod => mkbuiltin_v2p Tlong Val.modlu _ _
-  | BI_i64_shl => mkbuiltin_v2t Tlong Val.shll _ _
-  | BI_i64_shr => mkbuiltin_v2t Tlong Val.shrlu _ _
-  | BI_i64_sar => mkbuiltin_v2t Tlong Val.shrl _ _
+  | BI_i64_sdiv => mkbuiltin_v2p Tlong Val.divls _ _ _
+  | BI_i64_udiv => mkbuiltin_v2p Tlong Val.divlu _ _ _
+  | BI_i64_smod => mkbuiltin_v2p Tlong Val.modls _ _ _
+  | BI_i64_umod => mkbuiltin_v2p Tlong Val.modlu _ _ _
+  | BI_i64_shl => mkbuiltin_v2t Tlong Val.shll _ _ _
+  | BI_i64_shr => mkbuiltin_v2t Tlong Val.shrlu _ _ _
+  | BI_i64_sar => mkbuiltin_v2t Tlong Val.shrl _ _ _
   | BI_i64_dtos => mkbuiltin_n1p Tfloat Tlong Float.to_long
   | BI_i64_dtou => mkbuiltin_n1p Tfloat Tlong Float.to_longu
   | BI_i64_stod => mkbuiltin_n1t Tlong Tfloat Float.of_long
@@ -479,12 +563,19 @@ Next Obligation.
   red. inv H; auto. inv H0; auto. inv H1; auto. inv H0; auto. inv H2; auto.
   apply Val.normalize_inject. destruct (Int.eq i Int.zero); auto.
 Qed.
+Next Obligation.
+  red. inv H; auto. inv H0; auto. inv H1; auto. inv H0; auto. inv H2; auto.
+  apply normalize_binded. destruct (Int.eq i Int.zero); auto.
+Qed.
 Next Obligation.
   unfold Val.addl, Val.has_type; destruct v1; auto; destruct v2; auto; destruct Archi.ptr64; auto.
 Qed.
 Next Obligation.
   apply Val.addl_inject; auto.
-Qed.   
+Qed.
+Next Obligation.
+  apply addl_bind; auto.
+Qed.
 Next Obligation.
   unfold Val.subl, Val.has_type, negb; destruct v1; auto; destruct v2; auto;
   destruct Archi.ptr64; auto; destruct (eq_block b0 b1); auto.
@@ -492,52 +583,79 @@ Qed.
 Next Obligation.
   apply Val.subl_inject; auto.
 Qed.
+Next Obligation.
+  eapply subl_bind; eauto.
+Qed.
 Next Obligation.
   unfold Val.mull', Val.has_type; destruct v1; simpl; auto; destruct v2; auto.
 Qed.
 Next Obligation.
   inv H; simpl; auto. inv H0; auto.
 Qed.
+Next Obligation.
+  inv H; simpl; auto; try by econs. inv H0; auto; try by econs.
+Qed.
 Next Obligation.
   red. destruct v1; simpl; auto. destruct v2; auto. destruct orb; exact I.
 Qed.
 Next Obligation.
   red. inv H; simpl; auto. inv H0; auto. destruct orb; auto.
 Qed.
+Next Obligation.
+  red. inv H; simpl; auto. inv H0; auto. destruct orb; auto. econs.
+Qed.
 Next Obligation.
   red. destruct v1; simpl; auto. destruct v2; auto. destruct Int64.eq; exact I.
 Qed.
 Next Obligation.
   red. inv H; simpl; auto. inv H0; auto. destruct Int64.eq; auto.
 Qed.
+Next Obligation.
+  red. inv H; simpl; auto. inv H0; auto. destruct Int64.eq; auto. econs.
+Qed.
 Next Obligation.
   red. destruct v1; simpl; auto. destruct v2; auto. destruct orb; exact I.
 Qed.
 Next Obligation.
   red. inv H; simpl; auto. inv H0; auto. destruct orb; auto.
 Qed.
+Next Obligation.
+  red. inv H; simpl; auto. inv H0; auto. destruct orb; auto; econs.
+Qed.
 Next Obligation.
   red. destruct v1; simpl; auto. destruct v2; auto. destruct Int64.eq; exact I.
 Qed.
 Next Obligation.
   red. inv H; simpl; auto. inv H0; auto. destruct Int64.eq; auto.
 Qed.
+Next Obligation.
+  red. inv H; simpl; auto. inv H0; auto. destruct Int64.eq; auto; econs.
+Qed.
 Next Obligation.
   red. destruct v1; simpl; auto. destruct v2; auto. destruct Int.ltu; auto.
 Qed.
 Next Obligation.
   inv H; simpl; auto. inv H0; auto. destruct Int.ltu; auto.
 Qed.
+Next Obligation.
+  inv H; simpl; auto; try by econs. inv H0; auto; try by econs. destruct Int.ltu; auto; econs.
+Qed.
 Next Obligation.
   red. destruct v1; simpl; auto. destruct v2; auto. destruct Int.ltu; auto.
 Qed.
 Next Obligation.
   inv H; simpl; auto. inv H0; auto. destruct Int.ltu; auto.
 Qed.
+Next Obligation.
+  inv H; simpl; auto; try by econs. inv H0; auto; try by econs. destruct Int.ltu; auto; econs.
+Qed.
 Next Obligation.
   red. destruct v1; simpl; auto. destruct v2; auto. destruct Int.ltu; auto.
 Qed.
 Next Obligation.
   inv H; simpl; auto. inv H0; auto. destruct Int.ltu; auto.
 Qed.
+Next Obligation.
+  inv H; simpl; auto; try by econs. inv H0; auto; try by econs. destruct Int.ltu; auto; econs.
+Qed.
 
diff --git a/common/Determinism.v b/common/Determinism.v
index c8c90782..7cb3068f 100644
--- a/common/Determinism.v
+++ b/common/Determinism.v
@@ -173,330 +173,330 @@ Ltac possibleTraceInv :=
   | _ => idtac
   end.
 
-Definition possible_behavior (w: world) (b: program_behavior) : Prop :=
-  match b with
-  | Terminates t r => exists w', possible_trace w t w'
-  | Diverges t => exists w', possible_trace w t w'
-  | Reacts T => possible_traceinf w T
-  | Goes_wrong t => exists w', possible_trace w t w'
-  end.
-
-CoInductive possible_traceinf': world -> traceinf -> Prop :=
-  | possible_traceinf'_app: forall w1 t w2 T,
-      possible_trace w1 t w2 -> t <> E0 ->
-      possible_traceinf' w2 T ->
-      possible_traceinf' w1 (t *** T).
-
-Lemma possible_traceinf'_traceinf:
-  forall w T, possible_traceinf' w T -> possible_traceinf w T.
-Proof.
-  cofix COINDHYP; intros. inv H. inv H0. congruence.
-  simpl. econstructor. eauto. apply COINDHYP.
-  inv H3. simpl. auto. econstructor; eauto. econstructor; eauto. unfold E0; congruence.
-Qed.
-
-(** * Definition and properties of deterministic semantics *)
-
-Record sem_deterministic (L: semantics) := mk_deterministic {
-  det_step: forall s0 t1 s1 t2 s2,
-    Step L s0 t1 s1 -> Step L s0 t2 s2 -> s1 = s2 /\ t1 = t2;
-  det_initial_state: forall s1 s2,
-    initial_state L s1 -> initial_state L s2 -> s1 = s2;
-  det_final_state: forall s r1 r2,
-    final_state L s r1 -> final_state L s r2 -> r1 = r2;
-  det_final_nostep: forall s r,
-    final_state L s r -> Nostep L s
-}.
-
-Section DETERM_SEM.
-
-Variable L: semantics.
-Hypothesis DET: sem_deterministic L.
-
-Ltac use_step_deterministic :=
-  match goal with
-  | [ S1: Step L _ ?t1 _, S2: Step L _ ?t2 _ |- _ ] =>
-    destruct (det_step L DET _ _ _ _ _ S1 S2) as [EQ1 EQ2]; subst
-  end.
-
-(** Determinism for finite transition sequences. *)
-
-Lemma star_step_diamond:
-  forall s0 t1 s1, Star L s0 t1 s1 ->
-  forall t2 s2, Star L s0 t2 s2 ->
-  exists t,
-     (Star L s1 t s2 /\ t2 = t1 ** t)
-  \/ (Star L s2 t s1 /\ t1 = t2 ** t).
-Proof.
-  induction 1; intros.
-  exists t2; auto.
-  inv H2. exists (t1 ** t2); right.
-    split. econstructor; eauto. auto.
-  use_step_deterministic.
-  exploit IHstar. eexact H4. intros [t A]. exists t.
-  destruct A. left; intuition. traceEq. right; intuition. traceEq.
-Qed.
-
-Ltac use_star_step_diamond :=
-  match goal with
-  | [ S1: Star L _ ?t1 _, S2: Star L _ ?t2 _ |- _ ] =>
-    let t := fresh "t" in let P := fresh "P" in let EQ := fresh "EQ" in
-    destruct (star_step_diamond _ _ _ S1 _ _ S2)
-    as [t [ [P EQ] | [P EQ] ]]; subst
- end.
-
-Ltac use_nostep :=
-  match goal with
-  | [ S: Step L ?s _ _, NO: Nostep L ?s |- _ ] => elim (NO _ _ S)
-  end.
-
-Lemma star_step_triangle:
-  forall s0 t1 s1 t2 s2,
-  Star L s0 t1 s1 ->
-  Star L s0 t2 s2 ->
-  Nostep L s2 ->
-  exists t,
-  Star L s1 t s2 /\ t2 = t1 ** t.
-Proof.
-  intros. use_star_step_diamond.
-  exists t; auto.
-  inv P. exists E0. split. constructor. traceEq.
-  use_nostep.
-Qed.
-
-Ltac use_star_step_triangle :=
-  match goal with
-  | [ S1: Star L _ ?t1 _, S2: Star L _ ?t2 ?s2, NO: Nostep L ?s2 |- _ ] =>
-    let t := fresh "t" in let P := fresh "P" in let EQ := fresh "EQ" in
-    destruct (star_step_triangle _ _ _ _ _ S1 S2 NO)
-    as [t [P EQ]]; subst
-  end.
-
-Lemma steps_deterministic:
-  forall s0 t1 s1 t2 s2,
-  Star L s0 t1 s1 -> Star L s0 t2 s2 ->
-  Nostep L s1 -> Nostep L s2 ->
-  t1 = t2 /\ s1 = s2.
-Proof.
-  intros. use_star_step_triangle. inv P.
-  split; auto; traceEq. use_nostep.
-Qed.
-
-Lemma terminates_not_goes_wrong:
-  forall s t1 s1 r t2 s2,
-  Star L s t1 s1 -> final_state L s1 r ->
-  Star L s t2 s2 -> Nostep L s2 ->
-  (forall r, ~final_state L s2 r) -> False.
-Proof.
-  intros.
-  assert (t1 = t2 /\ s1 = s2).
-    eapply steps_deterministic; eauto. eapply det_final_nostep; eauto.
-  destruct H4; subst. elim (H3 _ H0).
-Qed.
-
-(** Determinism for infinite transition sequences. *)
-
-Lemma star_final_not_forever_silent:
-  forall s t s', Star L s t s' ->
-  Nostep L s' ->
-  Forever_silent L s -> False.
-Proof.
-  induction 1; intros.
-  inv H0. use_nostep.
-  inv H3. use_step_deterministic. eauto.
-Qed.
-
-Lemma star2_final_not_forever_silent:
-  forall s t1 s1 t2 s2,
-  Star L s t1 s1 -> Nostep L s1 ->
-  Star L s t2 s2 -> Forever_silent L s2 ->
-  False.
-Proof.
-  intros. use_star_step_triangle.
-  eapply star_final_not_forever_silent. eexact P. eauto. auto.
-Qed.
-
-Lemma star_final_not_forever_reactive:
-  forall s t s', Star L s t s' ->
-  forall T, Nostep L s' -> Forever_reactive L s T -> False.
-Proof.
-  induction 1; intros.
-  inv H0. inv H1. congruence. use_nostep.
-  inv H3. inv H4. congruence.
-  use_step_deterministic.
-  eapply IHstar with (T := t4 *** T0). eauto.
-  eapply star_forever_reactive; eauto.
-Qed.
-
-Lemma star_forever_silent_inv:
-  forall s t s', Star L s t s' ->
-  Forever_silent L s ->
-  t = E0 /\ Forever_silent L s'.
-Proof.
-  induction 1; intros.
-  auto.
-  subst. inv H2. use_step_deterministic. eauto.
-Qed.
-
-Lemma forever_silent_reactive_exclusive:
-  forall s T,
-  Forever_silent L s -> Forever_reactive L s T -> False.
-Proof.
-  intros. inv H0. exploit star_forever_silent_inv; eauto.
-  intros [A B]. contradiction.
-Qed.
-
-Lemma forever_reactive_inv2:
-  forall s t1 s1, Star L s t1 s1 ->
-  forall t2 s2 T1 T2,
-  Star L s t2 s2 ->
-  t1 <> E0 -> t2 <> E0 ->
-  Forever_reactive L s1 T1 ->
-  Forever_reactive L s2 T2 ->
-  exists s', exists t, exists T1', exists T2',
-  t <> E0 /\
-  Forever_reactive L s' T1' /\
-  Forever_reactive L s' T2' /\
-  t1 *** T1 = t *** T1' /\
-  t2 *** T2 = t *** T2'.
-Proof.
-  induction 1; intros.
-  congruence.
-  inv H2. congruence. use_step_deterministic.
-  destruct t3.
-  (* inductive case *)
-  simpl in *. eapply IHstar; eauto.
-  (* base case *)
-  exists s5; exists (e :: t3);
-  exists (t2 *** T1); exists (t4 *** T2).
-  split. unfold E0; congruence.
-  split. eapply star_forever_reactive; eauto.
-  split. eapply star_forever_reactive; eauto.
-  split; traceEq.
-Qed.
-
-Lemma forever_reactive_determ':
-  forall s T1 T2,
-  Forever_reactive L s T1 ->
-  Forever_reactive L s T2 ->
-  traceinf_sim' T1 T2.
-Proof.
-  cofix COINDHYP; intros.
-  inv H. inv H0.
-  destruct (forever_reactive_inv2 _ _ _ H t s2 T0 T)
-  as [s' [t' [T1' [T2' [A [B [C [D E]]]]]]]]; auto.
-  rewrite D; rewrite E. constructor. auto.
-  eapply COINDHYP; eauto.
-Qed.
-
-Lemma forever_reactive_determ:
-  forall s T1 T2,
-  Forever_reactive L s T1 ->
-  Forever_reactive L s T2 ->
-  traceinf_sim T1 T2.
-Proof.
-  intros. apply traceinf_sim'_sim. eapply forever_reactive_determ'; eauto.
-Qed.
-
-Lemma star_forever_reactive_inv:
-  forall s t s', Star L s t s' ->
-  forall T, Forever_reactive L s T ->
-  exists T', Forever_reactive L s' T' /\ T = t *** T'.
-Proof.
-  induction 1; intros.
-  exists T; auto.
-  inv H2. inv H3. congruence.
-  use_step_deterministic.
-  exploit IHstar. eapply star_forever_reactive. 2: eauto. eauto.
-  intros [T' [A B]]. exists T'; intuition. traceEq. congruence.
-Qed.
-
-Lemma forever_silent_reactive_exclusive2:
-  forall s t s' T,
-  Star L s t s' -> Forever_silent L s' ->
-  Forever_reactive L s T ->
-  False.
-Proof.
-  intros. exploit star_forever_reactive_inv; eauto.
-  intros [T' [A B]]. subst T.
-  eapply forever_silent_reactive_exclusive; eauto.
-Qed.
-
-(** Determinism for program executions *)
-
-Definition same_behaviors (beh1 beh2: program_behavior) : Prop :=
-  match beh1, beh2 with
-  | Terminates t1 r1, Terminates t2 r2 => t1 = t2 /\ r1 = r2
-  | Diverges t1, Diverges t2 => t1 = t2
-  | Reacts t1, Reacts t2 => traceinf_sim t1 t2
-  | Goes_wrong t1, Goes_wrong t2 => t1 = t2
-  | _, _ => False
-  end.
-
-Lemma state_behaves_deterministic:
-  forall s beh1 beh2,
-  state_behaves L s beh1 -> state_behaves L s beh2 -> same_behaviors beh1 beh2.
-Proof.
-  generalize (det_final_nostep L DET); intro dfns.
-  intros until beh2; intros BEH1 BEH2.
-  inv BEH1; inv BEH2; red.
-(* terminates, terminates *)
-  assert (t = t0 /\ s' = s'0). eapply steps_deterministic; eauto.
-  destruct H3. split; auto. subst. eapply det_final_state; eauto.
-(* terminates, diverges *)
-  eapply star2_final_not_forever_silent with (s1 := s') (s2 := s'0); eauto.
-(* terminates, reacts *)
-  eapply star_final_not_forever_reactive; eauto.
-(* terminates, goes_wrong *)
-  eapply terminates_not_goes_wrong with (s1 := s') (s2 := s'0); eauto.
-(* diverges, terminates *)
-  eapply star2_final_not_forever_silent with (s2 := s') (s1 := s'0); eauto.
-(* diverges, diverges *)
-  use_star_step_diamond.
-  exploit star_forever_silent_inv. eexact P. eauto.
-  intros [A B]. subst; traceEq.
-  exploit star_forever_silent_inv. eexact P. eauto.
-  intros [A B]. subst; traceEq.
-(* diverges, reacts *)
-  eapply forever_silent_reactive_exclusive2; eauto.
-(* diverges, goes wrong *)
-  eapply star2_final_not_forever_silent with (s1 := s'0) (s2 := s'); eauto.
-(* reacts, terminates *)
-  eapply star_final_not_forever_reactive; eauto.
-(* reacts, diverges *)
-  eapply forever_silent_reactive_exclusive2; eauto.
-(* reacts, reacts *)
-  eapply forever_reactive_determ; eauto.
-(* reacts, goes wrong *)
-  eapply star_final_not_forever_reactive; eauto.
-(* goes wrong, terminate *)
-  eapply terminates_not_goes_wrong with (s1 := s'0) (s2 := s'); eauto.
-(* goes wrong, diverges *)
-  eapply star2_final_not_forever_silent with (s1 := s') (s2 := s'0); eauto.
-(* goes wrong, reacts *)
-  eapply star_final_not_forever_reactive; eauto.
-(* goes wrong, goes wrong *)
-  assert (t = t0 /\ s' = s'0). eapply steps_deterministic; eauto.
-  tauto.
-Qed.
-
-Theorem program_behaves_deterministic:
-  forall beh1 beh2,
-  program_behaves L beh1 -> program_behaves L beh2 ->
-  same_behaviors beh1 beh2.
-Proof.
-  intros until beh2; intros BEH1 BEH2. inv BEH1; inv BEH2.
-(* both initial states defined *)
-  assert (s = s0) by (eapply det_initial_state; eauto). subst s0.
-  eapply state_behaves_deterministic; eauto.
-(* one initial state defined, the other undefined *)
-  elim (H1 _ H).
-  elim (H _ H0).
-(* both initial states undefined *)
-  red; auto.
-Qed.
-
-End DETERM_SEM.
+(* Definition possible_behavior (w: world) (b: program_behavior) : Prop := *)
+(*   match b with *)
+(*   | Terminates t r => exists w', possible_trace w t w' *)
+(*   | Diverges t => exists w', possible_trace w t w' *)
+(*   | Reacts T => possible_traceinf w T *)
+(*   | Goes_wrong t => exists w', possible_trace w t w' *)
+(*   end. *)
+
+(* CoInductive possible_traceinf': world -> traceinf -> Prop := *)
+(*   | possible_traceinf'_app: forall w1 t w2 T, *)
+(*       possible_trace w1 t w2 -> t <> E0 -> *)
+(*       possible_traceinf' w2 T -> *)
+(*       possible_traceinf' w1 (t *** T). *)
+
+(* Lemma possible_traceinf'_traceinf: *)
+(*   forall w T, possible_traceinf' w T -> possible_traceinf w T. *)
+(* Proof. *)
+(*   cofix COINDHYP; intros. inv H. inv H0. congruence. *)
+(*   simpl. econstructor. eauto. apply COINDHYP. *)
+(*   inv H3. simpl. auto. econstructor; eauto. econstructor; eauto. unfold E0; congruence. *)
+(* Qed. *)
+
+(* (** * Definition and properties of deterministic semantics *) *)
+
+(* Record sem_deterministic (L: semantics) := mk_deterministic { *)
+(*   det_step: forall s0 t1 s1 t2 s2, *)
+(*     Step L s0 t1 s1 -> Step L s0 t2 s2 -> s1 = s2 /\ t1 = t2; *)
+(*   det_initial_state: forall s1 s2, *)
+(*     initial_state L s1 -> initial_state L s2 -> s1 = s2; *)
+(*   det_final_state: forall s r1 r2, *)
+(*     final_state L s r1 -> final_state L s r2 -> r1 = r2; *)
+(*   det_final_nostep: forall s r, *)
+(*     final_state L s r -> Nostep L s *)
+(* }. *)
+
+(* Section DETERM_SEM. *)
+
+(* Variable L: semantics. *)
+(* Hypothesis DET: sem_deterministic L. *)
+
+(* Ltac use_step_deterministic := *)
+(*   match goal with *)
+(*   | [ S1: Step L _ ?t1 _, S2: Step L _ ?t2 _ |- _ ] => *)
+(*     destruct (det_step L DET _ _ _ _ _ S1 S2) as [EQ1 EQ2]; subst *)
+(*   end. *)
+
+(* (** Determinism for finite transition sequences. *) *)
+
+(* Lemma star_step_diamond: *)
+(*   forall s0 t1 s1, Star L s0 t1 s1 -> *)
+(*   forall t2 s2, Star L s0 t2 s2 -> *)
+(*   exists t, *)
+(*      (Star L s1 t s2 /\ t2 = t1 ** t) *)
+(*   \/ (Star L s2 t s1 /\ t1 = t2 ** t). *)
+(* Proof. *)
+(*   induction 1; intros. *)
+(*   exists t2; auto. *)
+(*   inv H2. exists (t1 ** t2); right. *)
+(*     split. econstructor; eauto. auto. *)
+(*   use_step_deterministic. *)
+(*   exploit IHstar. eexact H4. intros [t A]. exists t. *)
+(*   destruct A. left; intuition. traceEq. right; intuition. traceEq. *)
+(* Qed. *)
+
+(* Ltac use_star_step_diamond := *)
+(*   match goal with *)
+(*   | [ S1: Star L _ ?t1 _, S2: Star L _ ?t2 _ |- _ ] => *)
+(*     let t := fresh "t" in let P := fresh "P" in let EQ := fresh "EQ" in *)
+(*     destruct (star_step_diamond _ _ _ S1 _ _ S2) *)
+(*     as [t [ [P EQ] | [P EQ] ]]; subst *)
+(*  end. *)
+
+(* Ltac use_nostep := *)
+(*   match goal with *)
+(*   | [ S: Step L ?s _ _, NO: Nostep L ?s |- _ ] => elim (NO _ _ S) *)
+(*   end. *)
+
+(* Lemma star_step_triangle: *)
+(*   forall s0 t1 s1 t2 s2, *)
+(*   Star L s0 t1 s1 -> *)
+(*   Star L s0 t2 s2 -> *)
+(*   Nostep L s2 -> *)
+(*   exists t, *)
+(*   Star L s1 t s2 /\ t2 = t1 ** t. *)
+(* Proof. *)
+(*   intros. use_star_step_diamond. *)
+(*   exists t; auto. *)
+(*   inv P. exists E0. split. constructor. traceEq. *)
+(*   use_nostep. *)
+(* Qed. *)
+
+(* Ltac use_star_step_triangle := *)
+(*   match goal with *)
+(*   | [ S1: Star L _ ?t1 _, S2: Star L _ ?t2 ?s2, NO: Nostep L ?s2 |- _ ] => *)
+(*     let t := fresh "t" in let P := fresh "P" in let EQ := fresh "EQ" in *)
+(*     destruct (star_step_triangle _ _ _ _ _ S1 S2 NO) *)
+(*     as [t [P EQ]]; subst *)
+(*   end. *)
+
+(* Lemma steps_deterministic: *)
+(*   forall s0 t1 s1 t2 s2, *)
+(*   Star L s0 t1 s1 -> Star L s0 t2 s2 -> *)
+(*   Nostep L s1 -> Nostep L s2 -> *)
+(*   t1 = t2 /\ s1 = s2. *)
+(* Proof. *)
+(*   intros. use_star_step_triangle. inv P. *)
+(*   split; auto; traceEq. use_nostep. *)
+(* Qed. *)
+
+(* Lemma terminates_not_goes_wrong: *)
+(*   forall s t1 s1 r t2 s2, *)
+(*   Star L s t1 s1 -> final_state L s1 r -> *)
+(*   Star L s t2 s2 -> Nostep L s2 -> *)
+(*   (forall r, ~final_state L s2 r) -> False. *)
+(* Proof. *)
+(*   intros. *)
+(*   assert (t1 = t2 /\ s1 = s2). *)
+(*     eapply steps_deterministic; eauto. eapply det_final_nostep; eauto. *)
+(*   destruct H4; subst. elim (H3 _ H0). *)
+(* Qed. *)
+
+(* (** Determinism for infinite transition sequences. *) *)
+
+(* Lemma star_final_not_forever_silent: *)
+(*   forall s t s', Star L s t s' -> *)
+(*   Nostep L s' -> *)
+(*   Forever_silent L s -> False. *)
+(* Proof. *)
+(*   induction 1; intros. *)
+(*   inv H0. use_nostep. *)
+(*   inv H3. use_step_deterministic. eauto. *)
+(* Qed. *)
+
+(* Lemma star2_final_not_forever_silent: *)
+(*   forall s t1 s1 t2 s2, *)
+(*   Star L s t1 s1 -> Nostep L s1 -> *)
+(*   Star L s t2 s2 -> Forever_silent L s2 -> *)
+(*   False. *)
+(* Proof. *)
+(*   intros. use_star_step_triangle. *)
+(*   eapply star_final_not_forever_silent. eexact P. eauto. auto. *)
+(* Qed. *)
+
+(* Lemma star_final_not_forever_reactive: *)
+(*   forall s t s', Star L s t s' -> *)
+(*   forall T, Nostep L s' -> Forever_reactive L s T -> False. *)
+(* Proof. *)
+(*   induction 1; intros. *)
+(*   inv H0. inv H1. congruence. use_nostep. *)
+(*   inv H3. inv H4. congruence. *)
+(*   use_step_deterministic. *)
+(*   eapply IHstar with (T := t4 *** T0). eauto. *)
+(*   eapply star_forever_reactive; eauto. *)
+(* Qed. *)
+
+(* Lemma star_forever_silent_inv: *)
+(*   forall s t s', Star L s t s' -> *)
+(*   Forever_silent L s -> *)
+(*   t = E0 /\ Forever_silent L s'. *)
+(* Proof. *)
+(*   induction 1; intros. *)
+(*   auto. *)
+(*   subst. inv H2. use_step_deterministic. eauto. *)
+(* Qed. *)
+
+(* Lemma forever_silent_reactive_exclusive: *)
+(*   forall s T, *)
+(*   Forever_silent L s -> Forever_reactive L s T -> False. *)
+(* Proof. *)
+(*   intros. inv H0. exploit star_forever_silent_inv; eauto. *)
+(*   intros [A B]. contradiction. *)
+(* Qed. *)
+
+(* Lemma forever_reactive_inv2: *)
+(*   forall s t1 s1, Star L s t1 s1 -> *)
+(*   forall t2 s2 T1 T2, *)
+(*   Star L s t2 s2 -> *)
+(*   t1 <> E0 -> t2 <> E0 -> *)
+(*   Forever_reactive L s1 T1 -> *)
+(*   Forever_reactive L s2 T2 -> *)
+(*   exists s', exists t, exists T1', exists T2', *)
+(*   t <> E0 /\ *)
+(*   Forever_reactive L s' T1' /\ *)
+(*   Forever_reactive L s' T2' /\ *)
+(*   t1 *** T1 = t *** T1' /\ *)
+(*   t2 *** T2 = t *** T2'. *)
+(* Proof. *)
+(*   induction 1; intros. *)
+(*   congruence. *)
+(*   inv H2. congruence. use_step_deterministic. *)
+(*   destruct t3. *)
+(*   (* inductive case *) *)
+(*   simpl in *. eapply IHstar; eauto. *)
+(*   (* base case *) *)
+(*   exists s5; exists (e :: t3); *)
+(*   exists (t2 *** T1); exists (t4 *** T2). *)
+(*   split. unfold E0; congruence. *)
+(*   split. eapply star_forever_reactive; eauto. *)
+(*   split. eapply star_forever_reactive; eauto. *)
+(*   split; traceEq. *)
+(* Qed. *)
+
+(* Lemma forever_reactive_determ': *)
+(*   forall s T1 T2, *)
+(*   Forever_reactive L s T1 -> *)
+(*   Forever_reactive L s T2 -> *)
+(*   traceinf_sim' T1 T2. *)
+(* Proof. *)
+(*   cofix COINDHYP; intros. *)
+(*   inv H. inv H0. *)
+(*   destruct (forever_reactive_inv2 _ _ _ H t s2 T0 T) *)
+(*   as [s' [t' [T1' [T2' [A [B [C [D E]]]]]]]]; auto. *)
+(*   rewrite D; rewrite E. constructor. auto. *)
+(*   eapply COINDHYP; eauto. *)
+(* Qed. *)
+
+(* Lemma forever_reactive_determ: *)
+(*   forall s T1 T2, *)
+(*   Forever_reactive L s T1 -> *)
+(*   Forever_reactive L s T2 -> *)
+(*   traceinf_sim T1 T2. *)
+(* Proof. *)
+(*   intros. apply traceinf_sim'_sim. eapply forever_reactive_determ'; eauto. *)
+(* Qed. *)
+
+(* Lemma star_forever_reactive_inv: *)
+(*   forall s t s', Star L s t s' -> *)
+(*   forall T, Forever_reactive L s T -> *)
+(*   exists T', Forever_reactive L s' T' /\ T = t *** T'. *)
+(* Proof. *)
+(*   induction 1; intros. *)
+(*   exists T; auto. *)
+(*   inv H2. inv H3. congruence. *)
+(*   use_step_deterministic. *)
+(*   exploit IHstar. eapply star_forever_reactive. 2: eauto. eauto. *)
+(*   intros [T' [A B]]. exists T'; intuition. traceEq. congruence. *)
+(* Qed. *)
+
+(* Lemma forever_silent_reactive_exclusive2: *)
+(*   forall s t s' T, *)
+(*   Star L s t s' -> Forever_silent L s' -> *)
+(*   Forever_reactive L s T -> *)
+(*   False. *)
+(* Proof. *)
+(*   intros. exploit star_forever_reactive_inv; eauto. *)
+(*   intros [T' [A B]]. subst T. *)
+(*   eapply forever_silent_reactive_exclusive; eauto. *)
+(* Qed. *)
+
+(* (** Determinism for program executions *) *)
+
+(* Definition same_behaviors (beh1 beh2: program_behavior) : Prop := *)
+(*   match beh1, beh2 with *)
+(*   | Terminates t1 r1, Terminates t2 r2 => t1 = t2 /\ r1 = r2 *)
+(*   | Diverges t1, Diverges t2 => t1 = t2 *)
+(*   | Reacts t1, Reacts t2 => traceinf_sim t1 t2 *)
+(*   | Goes_wrong t1, Goes_wrong t2 => t1 = t2 *)
+(*   | _, _ => False *)
+(*   end. *)
+
+(* Lemma state_behaves_deterministic: *)
+(*   forall s beh1 beh2, *)
+(*   state_behaves L s beh1 -> state_behaves L s beh2 -> same_behaviors beh1 beh2. *)
+(* Proof. *)
+(*   generalize (det_final_nostep L DET); intro dfns. *)
+(*   intros until beh2; intros BEH1 BEH2. *)
+(*   inv BEH1; inv BEH2; red. *)
+(* (* terminates, terminates *) *)
+(*   assert (t = t0 /\ s' = s'0). eapply steps_deterministic; eauto. *)
+(*   destruct H3. split; auto. subst. eapply det_final_state; eauto. *)
+(* (* terminates, diverges *) *)
+(*   eapply star2_final_not_forever_silent with (s1 := s') (s2 := s'0); eauto. *)
+(* (* terminates, reacts *) *)
+(*   eapply star_final_not_forever_reactive; eauto. *)
+(* (* terminates, goes_wrong *) *)
+(*   eapply terminates_not_goes_wrong with (s1 := s') (s2 := s'0); eauto. *)
+(* (* diverges, terminates *) *)
+(*   eapply star2_final_not_forever_silent with (s2 := s') (s1 := s'0); eauto. *)
+(* (* diverges, diverges *) *)
+(*   use_star_step_diamond. *)
+(*   exploit star_forever_silent_inv. eexact P. eauto. *)
+(*   intros [A B]. subst; traceEq. *)
+(*   exploit star_forever_silent_inv. eexact P. eauto. *)
+(*   intros [A B]. subst; traceEq. *)
+(* (* diverges, reacts *) *)
+(*   eapply forever_silent_reactive_exclusive2; eauto. *)
+(* (* diverges, goes wrong *) *)
+(*   eapply star2_final_not_forever_silent with (s1 := s'0) (s2 := s'); eauto. *)
+(* (* reacts, terminates *) *)
+(*   eapply star_final_not_forever_reactive; eauto. *)
+(* (* reacts, diverges *) *)
+(*   eapply forever_silent_reactive_exclusive2; eauto. *)
+(* (* reacts, reacts *) *)
+(*   eapply forever_reactive_determ; eauto. *)
+(* (* reacts, goes wrong *) *)
+(*   eapply star_final_not_forever_reactive; eauto. *)
+(* (* goes wrong, terminate *) *)
+(*   eapply terminates_not_goes_wrong with (s1 := s'0) (s2 := s'); eauto. *)
+(* (* goes wrong, diverges *) *)
+(*   eapply star2_final_not_forever_silent with (s1 := s') (s2 := s'0); eauto. *)
+(* (* goes wrong, reacts *) *)
+(*   eapply star_final_not_forever_reactive; eauto. *)
+(* (* goes wrong, goes wrong *) *)
+(*   assert (t = t0 /\ s' = s'0). eapply steps_deterministic; eauto. *)
+(*   tauto. *)
+(* Qed. *)
+
+(* Theorem program_behaves_deterministic: *)
+(*   forall beh1 beh2, *)
+(*   program_behaves L beh1 -> program_behaves L beh2 -> *)
+(*   same_behaviors beh1 beh2. *)
+(* Proof. *)
+(*   intros until beh2; intros BEH1 BEH2. inv BEH1; inv BEH2. *)
+(* (* both initial states defined *) *)
+(*   assert (s = s0) by (eapply det_initial_state; eauto). subst s0. *)
+(*   eapply state_behaves_deterministic; eauto. *)
+(* (* one initial state defined, the other undefined *) *)
+(*   elim (H1 _ H). *)
+(*   elim (H _ H0). *)
+(* (* both initial states undefined *) *)
+(*   red; auto. *)
+(* Qed. *)
+
+(* End DETERM_SEM. *)
 
 (** * Integrating an external world in a semantics. *)
 
@@ -518,33 +518,36 @@ Definition world_sem : semantics := @Semantics_gen
   (genvtype L)
   (fun ge s t s' => step L ge s#1 t s'#1 /\ possible_trace s#2 t s'#2)
   (fun s => initial_state L s#1 /\ s#2 = initial_world)
+  (fun s s' => False)
+  (fun s p => None)
   (fun s r => final_state L s#1 r)
+  (fun ge s => is_external L ge s#1)
   (globalenv L)
   (symbolenv L).
 
 (** If the original semantics is determinate, the world-aware semantics is deterministic. *)
 
-Hypothesis D: determinate L.
-
-Theorem world_sem_deterministic: sem_deterministic world_sem.
-Proof.
-  constructor; simpl; intros.
-(* steps *)
-  destruct H; destruct H0.
-  exploit (sd_determ D). eexact H. eexact H0. intros [A B].
-  exploit match_possible_traces; eauto. intros [EQ1 EQ2]. subst t2.
-  split; auto.
-  rewrite (surjective_pairing s1). rewrite (surjective_pairing s2). intuition congruence.
-(* initial states *)
-  destruct H; destruct H0.
-  rewrite (surjective_pairing s1). rewrite (surjective_pairing s2). decEq.
-  eapply (sd_initial_determ D); eauto.
-  congruence.
-(* final states *)
-  eapply (sd_final_determ D); eauto.
-(* final no step *)
-  red; simpl; intros. red; intros [A B]. exploit (sd_final_nostep D); eauto.
-Qed.
+(* Hypothesis D: determinate L. *)
+
+(* Theorem world_sem_deterministic: sem_deterministic world_sem. *)
+(* Proof. *)
+(*   constructor; simpl; intros. *)
+(* (* steps *) *)
+(*   destruct H; destruct H0. *)
+(*   exploit (sd_determ D). eexact H. eexact H0. intros [A B]. *)
+(*   exploit match_possible_traces; eauto. intros [EQ1 EQ2]. subst t2. *)
+(*   split; auto. *)
+(*   rewrite (surjective_pairing s1). rewrite (surjective_pairing s2). intuition congruence. *)
+(* (* initial states *) *)
+(*   destruct H; destruct H0. *)
+(*   rewrite (surjective_pairing s1). rewrite (surjective_pairing s2). decEq. *)
+(*   eapply (sd_initial_determ D); eauto. *)
+(*   congruence. *)
+(* (* final states *) *)
+(*   eapply (sd_final_determ D); eauto. *)
+(* (* final no step *) *)
+(*   red; simpl; intros. red; intros [A B]. exploit (sd_final_nostep D); eauto. *)
+(* Qed. *)
 
 End WORLD_SEM.
 
diff --git a/common/Events.v b/common/Events.v
index c4a6e7f9..53e08085 100644
--- a/common/Events.v
+++ b/common/Events.v
@@ -26,6 +26,9 @@ Require Import Values.
 Require Import Memory.
 Require Import Globalenvs.
 Require Import Builtins.
+Require Import IntPtrRel.
+Require Import sflib.
+Require Import Classical.
 
 (** * Events and traces *)
 
@@ -64,6 +67,7 @@ Inductive eventval: Type :=
   | EVptr_global: ident -> ptrofs -> eventval.
 
 Inductive event: Type :=
+  | Event_pterm: event
   | Event_syscall: string -> list eventval -> eventval -> event
   | Event_vload: memory_chunk -> ident -> ptrofs -> eventval -> event
   | Event_vstore: memory_chunk -> ident -> ptrofs -> eventval -> event
@@ -257,6 +261,65 @@ Proof.
   intros. destruct H as [T3 EQ]. exists T3. subst T2. traceEq.
 Qed.
 
+Definition trace_intact (tr: trace): Prop := ~In Event_pterm tr.
+
+Lemma trace_intact_E0 : trace_intact E0.
+Proof. ii. ss. Qed.
+
+Lemma trace_intact_app t0 t1
+    (INTACT0: trace_intact t0)
+    (INTACT1: trace_intact t1) :
+  <<INTACT: trace_intact (t0 ** t1)>>.
+Proof. ii. unfold trace_intact in *. rewrite in_app_iff in *. tauto. Qed.
+
+Lemma trace_intact_app_rev t0 t1
+    (INTACT: trace_intact (t0 ** t1)) :
+  <<INTACT0: trace_intact t0>> /\ <<INTACT1: trace_intact t1>>.
+Proof.
+  ginduction t0; ss; i; split; auto; [ii; inv H | |].
+  - ii. apply INTACT. apply in_app_iff. ss. des; auto.
+  - ii. apply INTACT. apply in_app_iff. auto.
+Qed.
+
+Fixpoint trace_cut_pterm (tr: trace): trace :=
+  match tr with
+  | nil => nil
+  | Event_pterm :: _ => nil
+  | hd :: tl => hd :: (trace_cut_pterm tl)
+  end.
+
+Lemma trace_cut_pterm_intact t : trace_intact (trace_cut_pterm t).
+Proof. ginduction t; ss. des_ifs; ii; ss; des; clarify. Qed.    
+
+Lemma trace_cut_pterm_intact_app t0 t1
+    (INTACT: trace_intact t0) :
+  trace_cut_pterm (t0 ** t1) = t0 ** trace_cut_pterm t1.
+Proof.
+  ginduction t0; ss. i. Transparent Eapp. ss. rewrite IHt0.
+  - unfold trace_intact in INTACT. ss.
+    apply Classical_Prop.not_or_and in INTACT. des. destruct a; ss.
+  - ii. apply INTACT. ss. auto.
+Qed.    
+
+Lemma trace_cut_pterm_pterm_app t0 t1
+    (PTERM: ~ trace_intact t0) :
+  trace_cut_pterm (t0 ** t1) = trace_cut_pterm t0.
+Proof.
+  ginduction t0; ss. i.
+  - exfalso. apply PTERM. ii. ss.
+  - i. unfold trace_intact in PTERM. apply Classical_Prop.NNPP in PTERM.
+    ss. des; subst; auto. rewrite IHt0; auto.
+Qed.
+
+Lemma trace_cut_pterm_split t : exists t1, t = trace_cut_pterm t ** t1.
+Proof.
+  ginduction t; ss; eauto. des.
+  exists (match a with | Event_pterm => a :: t | _ => t1 end).
+  des_ifs; ss; f_equal; auto.
+Qed.
+
+Opaque Eapp.
+
 (** * Relating values and event values *)
 
 Set Implicit Arguments.
@@ -492,6 +555,139 @@ Qed.
 
 End EVENTVAL_INJECT.
 
+(* gm is concrete memory map(mem_concrete) of some memory *)
+
+Definition to_int_ev (id: ident) (ofs: ptrofs) (gm: ident -> option Z) : option val :=
+  match gm id with
+  | Some addr => Some (if Archi.ptr64 then Vlong (Int64.repr (addr + Ptrofs.unsigned ofs)) else Vint (Int.repr (addr + Ptrofs.unsigned ofs)))
+  | _ => None
+  end.
+
+Section EVENTVAL_BIND.
+
+(* Variable ge: Senv.t. *)
+Variable gm: ident -> option Z.
+
+Definition eventval_bind (e1 e2: eventval) : Prop :=
+  match e1, e2 with
+  | EVptr_global id ofs, EVint i =>
+      <<SF: Archi.ptr64 = false>> /\
+      <<TOINT: to_int_ev id ofs gm = Some (Vint i)>>
+  | EVptr_global id ofs, EVlong i =>
+      <<SF: Archi.ptr64 = true>> /\
+      <<TOINT: to_int_ev id ofs gm = Some (Vlong i)>>
+  | _, _ => e1 = e2
+  end.
+
+Lemma eventval_bind_refl ev:
+  eventval_bind ev ev.
+Proof. destruct ev; ss. Qed.
+
+End EVENTVAL_BIND.
+
+(* m: current memory, gm: snap shot of concrete part of init state  *)
+Definition ge_binded (ge:Senv.t) (m: mem) (gm: ident -> option Z) :=
+    forall id, Senv.public_symbol ge id = true ->
+    forall b, Senv.find_symbol ge id = Some b ->
+         Maps.PTree.get b (Mem.mem_concrete m) = gm id
+         /\
+         exists addr, gm id = Some addr.
+
+Section EVENT_REL.
+
+Definition event_rel (evval_rel: eventval -> eventval -> Prop) (e1 e2: event) : Prop :=
+  match e1, e2 with
+  | Event_syscall st1 args1 res1, Event_syscall st2 args2 res2 =>
+      <<ST: st1 = st2>> /\
+      <<ARGS: Forall2 evval_rel args1 args2>> /\
+      <<RES: evval_rel res1 res2>>
+  | Event_vload chunk1 id1 ofs1 res1, Event_vload chunk2 id2 ofs2 res2 =>
+      <<CHUNK: chunk1 = chunk2>> /\
+      <<ID: id1 = id2>> /\
+      <<OFS: ofs1 = ofs2>> /\
+      <<RES: evval_rel res1 res2>>
+  | Event_vstore chunk1 id1 ofs1 arg1, Event_vstore chunk2 id2 ofs2 arg2 =>
+      <<CHUNK: chunk1 = chunk2>> /\
+      <<ID: id1 = id2>> /\
+      <<OFS: ofs1 = ofs2>> /\
+      <<ARG: evval_rel arg1 arg2>>
+  | Event_annot id1 args1, Event_annot id2 args2 =>
+      <<ID: id1 = id2>> /\
+      <<ARGS: Forall2 evval_rel args1 args2>>
+  | _, _ => e1 = e2
+  end.
+
+Definition tr_rel (ev_rel: event -> event -> Prop) (tr1 tr2: trace) : Prop :=
+  Forall2 ev_rel tr1 tr2.
+
+Definition evval_rel (gvmap: ident -> option Z) : eventval -> eventval -> Prop := eventval_bind gvmap.
+Definition ev_rel (gvmap: ident -> option Z) : event -> event -> Prop := event_rel (evval_rel gvmap).
+
+Lemma eventval_list_eq (ev1 ev2: list eventval)
+  (EQ: Forall2 eq ev1 ev2) : ev1 = ev2.
+Proof. ginduction EQ; ss. subst; eauto. Qed.
+
+Lemma tr_rel_eq tr1 tr2
+  (EQ: tr_rel eq tr1 tr2): tr1 = tr2.
+Proof. ginduction EQ; ss. subst. eauto. Qed.
+
+End EVENT_REL.
+
+Lemma evval_rel_refl pm ev: evval_rel pm ev ev.
+Proof. destruct ev; ss. Qed.
+
+Lemma evval_list_rel_refl pm ev: Forall2 (evval_rel pm) ev ev.
+Proof. ginduction ev; ss. econs; eauto. eapply evval_rel_refl. Qed.
+
+Lemma ev_rel_refl pm ev: ev_rel pm ev ev.
+Proof.
+  destruct ev; ss; esplits; eauto.
+  - eapply evval_list_rel_refl.
+  - eapply evval_rel_refl.
+  - eapply evval_rel_refl.
+  - eapply evval_rel_refl.
+  - eapply evval_list_rel_refl.
+Qed.
+
+Lemma tr_rel_refl ev_rel
+    (REFL: forall ev, ev_rel ev ev: Prop) tr:
+  tr_rel ev_rel tr tr.
+Proof. induction tr; ss; ii; econs; eauto. Qed.
+
+Lemma tr_rel_app
+    ev_rel tr1 tr1' tr2 tr2'
+    (TR1: tr_rel ev_rel tr1 tr1')
+    (TR2: tr_rel ev_rel tr2 tr2') :
+  tr_rel ev_rel (tr1 ** tr2) (tr1' ** tr2').
+Proof. eapply Forall2_app; eauto. Qed.
+
+Lemma eventval_match_binded
+    (ge: Senv.t) ev1 ty m v1 v2 gm
+    (GB: ge_binded ge m gm)
+    (EM: eventval_match ge ev1 ty v1)
+    (BIND: val_intptr m v1 v2):
+  exists ev2, eventval_match ge ev2 ty v2 /\ evval_rel gm ev1 ev2.
+Proof.
+  inv EM; inv BIND; try by (esplits; eauto; econs); des_ifs. ss.
+  ss. des_ifs_safe. unfold Mem.ptr2int in Heq. des_ifs.
+  exploit GB; eauto. i. des. esplits; [econs|].
+  ss. esplits; eauto. unfold to_int_ev. rewrite H2. des_ifs.
+  rewrite H1 in Heq0. clarify.
+Qed.
+
+Lemma eventval_list_match_binded
+    (ge: Senv.t) evl1 tyl m vl1 vl2 gm
+    (GB: ge_binded ge m gm)
+    (EM: eventval_list_match ge evl1 tyl vl1)
+    (BIND: val_intptrist m vl1 vl2):
+  exists evl2, eventval_list_match ge evl2 tyl vl2 /\ Forall2 (evval_rel gm) evl1 evl2.
+Proof.
+  ginduction EM; ii; [inv BIND; esplits; eauto; econs|].
+  inv BIND. hexploit IHEM; eauto. i. des. hexploit eventval_match_binded; eauto. i. des.
+  esplits; eauto. econs; eauto.
+Qed.
+
+
 (** * Matching traces. *)
 
 Section MATCH_TRACES.
@@ -541,6 +737,7 @@ End MATCH_TRACES_INV.
 
 Definition output_event (ev: event) : Prop :=
   match ev with
+  | Event_pterm => True
   | Event_syscall _ _ _ => False
   | Event_vload _ _ _ _ => False
   | Event_vstore _ _ _ _ => True
@@ -557,7 +754,7 @@ Fixpoint output_trace (t: trace) : Prop :=
 
 Inductive volatile_load (ge: Senv.t):
                    memory_chunk -> mem -> block -> ptrofs -> trace -> val -> Prop :=
-  | volatile_load_vol: forall chunk m b ofs id ev v,
+  | volatile_load_vol: forall chunk m b ofs id ev v (VLPERM: Mem.perm m b (Ptrofs.unsigned ofs) Cur Nonempty),
       Senv.block_is_volatile ge b = true ->
       Senv.find_symbol ge id = Some b ->
       eventval_match ge ev (type_of_chunk chunk) v ->
@@ -571,7 +768,7 @@ Inductive volatile_load (ge: Senv.t):
 
 Inductive volatile_store (ge: Senv.t):
                   memory_chunk -> mem -> block -> ptrofs -> val -> trace -> mem -> Prop :=
-  | volatile_store_vol: forall chunk m b ofs id ev v,
+  | volatile_store_vol: forall chunk m b ofs id ev v (VLPERM: Mem.perm m b (Ptrofs.unsigned ofs) Cur Nonempty),
       Senv.block_is_volatile ge b = true ->
       Senv.find_symbol ge id = Some b ->
       eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v) ->
@@ -617,9 +814,16 @@ Definition inject_separated (f f': meminj) (m1 m2: mem): Prop :=
   f b1 = None -> f' b1 = Some(b2, delta) ->
   ~Mem.valid_block m1 b1 /\ ~Mem.valid_block m2 b2.
 
-Record extcall_properties (sem: extcall_sem) (sg: signature) : Prop :=
-  mk_extcall_properties {
+Definition nonempty_perm (m: mem) (b: block) (ofs: Z) :=
+  Mem.perm m b ofs Max Nonempty
+  /\ (forall k p, Mem.perm m b ofs k p -> p = Nonempty).
+
+Definition self_inj (f:meminj) : Prop :=
+  forall b b' delta, f b = Some (b', delta) -> b = b' /\ delta = 0.
 
+Record extcall_properties_common (sem: extcall_sem) (sg: signature) : Prop :=
+  mk_extcall_properties_common {
+  
 (** The return value of an external call must agree with its signature. *)
   ec_well_typed:
     forall ge vargs m1 t vres m2,
@@ -657,6 +861,128 @@ Record extcall_properties (sem: extcall_sem) (sg: signature) : Prop :=
     (forall i, ofs <= i < ofs + n -> ~Mem.perm m1 b i Max Writable) ->
     Mem.loadbytes m1 b ofs n = Some bytes;
 
+  ec_binds:
+    forall ge vargs m1 t vres m2,
+    sem ge vargs m1 t vres m2 ->
+    (forall b caddr, Maps.PTree.get b m1.(Mem.mem_concrete) = Some caddr -> Maps.PTree.get b m2.(Mem.mem_concrete) = Some caddr);
+
+  ec_nonempty:
+    forall ge vargs m1 t vres m2,
+    sem ge vargs m1 t vres m2 -> (forall b ofs, nonempty_perm m1 b ofs -> nonempty_perm m2 b ofs);    
+}.
+
+(* backward version of extcall properties *)
+Record extcall_properties_backward (sem: extcall_sem) (sg: signature) : Prop :=
+  mk_extcall_properties_backward {
+
+  ec_properties_backward_common:
+    extcall_properties_common sem sg;
+
+(** External calls must commute with memory extensions, in the
+  following sense. *)
+  ec_mem_extends_backward
+      ge vargs m1 t vres' m2' m1' vargs'
+      (CALLTGT: sem ge vargs' m1' t vres' m2')
+      (MEM: Mem.extends m1 m1')
+      (ARGS: Val.lessdef_list vargs vargs') :
+    (exists vres m2,
+      <<CALLSRC: sem ge vargs m1 t vres m2>>
+    /\ <<RETV: Val.lessdef vres vres'>>
+    /\ <<MEM: Mem.extends m2 m2'>>
+    /\ <<PRIV: Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'>>)
+    \/ <<UBSRC: (forall t' vres m2, ~ sem ge vargs m1 t' vres m2)>>
+    \/ (<<PTERM: ~trace_intact t >> /\
+       exists t' vres1 m21, <<CALLSRC: sem ge vargs m1 t' vres1 m21>> /\
+                       <<SUB: exists tl, t' = (trace_cut_pterm t) ** tl>>);
+
+  ec_mem_extends_backward_progress
+      ge vargs m1 t vres m2 m1' vargs'
+      (CALLSRC: sem ge vargs m1 t vres m2)
+      (MEM: Mem.extends m1 m1')
+      (ARGS: Val.lessdef_list vargs vargs') :
+    (exists t' vres' m2', <<CALLTGT: sem ge vargs' m1' t' vres' m2'>>);
+
+(** External calls must commute with memory injections,
+  in the following sense. *)
+  ec_mem_inject_backward
+      ge1 ge2 vargs m1 t vres' m2' f m1' vargs'
+      (SYMB: symbols_inject f ge1 ge2)
+      (CALLTGT: sem ge2 vargs' m1' t vres' m2')
+      (MEM: Mem.inject f m1 m1')
+      (ARGS: Val.inject_list f vargs vargs') :
+    (exists f' vres m2,
+      <<CALLSRC: sem ge1 vargs m1 t vres m2>>
+    /\ <<RETV: Val.inject f' vres vres'>>
+    /\ <<MEM: Mem.inject f' m2 m2'>>
+    /\ <<MEMPRIVSRC: Mem.unchanged_on (loc_unmapped f) m1 m2>>
+    /\ <<MEMPRIVTGT: Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'>>
+    /\ <<INJINCR: inject_incr f f'>>
+    /\ <<INJSEP: inject_separated f f' m1 m1'>>)
+    \/ <<UBSRC: (forall t' vres m2, ~ sem ge1 vargs m1 t' vres m2)>>
+    \/ (<<PTERM: ~trace_intact t >> /\
+       exists t' vres1 m21, <<CALLSRC: sem ge1 vargs m1 t' vres1 m21>> /\
+                       <<SUB: exists tl, t' = (trace_cut_pterm t) ** tl>>);
+
+  ec_mem_inject_backward_progress
+      ge1 ge2 vargs m1 t vres m2 f m1' vargs'
+      (SYMB: symbols_inject f ge1 ge2)
+      (CALLSRC: sem ge1 vargs m1 t vres m2)
+      (MEM: Mem.inject f m1 m1')
+      (ARGS: Val.inject_list f vargs vargs') :
+    (exists t'' vres' m2', <<CALLTGT: sem ge2 vargs' m1' t'' vres' m2'>>);
+
+  ec_sound
+      ge vargs m1 m2 t vres f
+      (SELF: self_inj f)
+      (SYMB: symbols_inject f ge ge)
+      (CALLSRC: sem ge vargs m1 t vres m2)
+      (MEM: Mem.inject f m1 m1)
+      (ARGS: Val.inject_list f vargs vargs) :
+    (exists f',
+      <<RETV: Val.inject f' vres vres>>
+    /\ <<MEM: Mem.inject f' m2 m2>>
+    /\ <<MEMPRIVSRC: Mem.unchanged_on (loc_unmapped f) m1 m2>>
+    /\ <<MEMPRIVTGT: Mem.unchanged_on (loc_out_of_reach f m1) m1 m2>>
+    /\ <<INJINCR: inject_incr f f'>>
+    /\ <<INJSEP: inject_separated f f' m1 m1>>);
+
+   ec_concrete_extends_backward :
+      forall ge vargs m1 t' vres' m2' m1' vargs' gm (TINIT: ge_binded ge m1' gm),
+      sem ge vargs' m1' t' vres' m2' -> concrete_extends m1 m1' ->
+      val_intptrist m1' vargs vargs' ->
+    (exists t vres m2,
+      <<TRREL: tr_rel (ev_rel gm) t t'>>
+    /\ <<CALLSRC: sem ge vargs m1 t vres m2>>
+    /\ <<RETV: val_intptr m2' vres vres'>>
+    /\ <<MEM: concrete_extends m2 m2'>>
+    /\ <<PRIV: Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'>>)
+    \/ <<UBSRC: (forall t vres m2, ~ sem ge vargs m1 t vres m2)>>
+    \/ (<<PTERM: ~ trace_intact t' >> /\
+       exists t vres1 m21, <<CALLSRC: sem ge vargs m1 t vres1 m21>> /\
+                      <<SUB: exists tl, tr_rel (ev_rel gm) t (Eapp (trace_cut_pterm t') tl)>>);
+
+  ec_concrete_extends_backward_progress
+      ge vargs m1 t vres m2 m1' vargs' gm
+      (TINIT: ge_binded ge m1' gm)
+      (CALLSRC: sem ge vargs m1 t vres m2)
+      (MEM: concrete_extends m1 m1')
+      (ARGS: val_intptrist m1' vargs vargs') :
+    (exists t'' vres' m2', <<CALLTGT: sem ge vargs' m1' t'' vres' m2'>>);
+
+}.
+
+(* forward version of extcall properties *)
+Record extcall_properties (sem: extcall_sem) (sg: signature) : Prop :=
+  mk_extcall_properties {
+
+  ec_properties_common:
+    extcall_properties_common sem sg;
+
+(** External calls produce at most one event. *)
+  ec_trace_length:
+    forall ge vargs m t vres m',
+    sem ge vargs m t vres m' -> (length t <= 1)%nat;
+      
 (** External calls must commute with memory extensions, in the
   following sense. *)
   ec_mem_extends:
@@ -687,10 +1013,17 @@ Record extcall_properties (sem: extcall_sem) (sg: signature) : Prop :=
     /\ inject_incr f f'
     /\ inject_separated f f' m1 m1';
 
-(** External calls produce at most one event. *)
-  ec_trace_length:
-    forall ge vargs m t vres m',
-    sem ge vargs m t vres m' -> (length t <= 1)%nat;
+  ec_mem_concrete_extends:
+    forall ge vargs m1 t vres m2 m1' vargs' gm (TINIT: ge_binded ge m1' gm),
+    sem ge vargs m1 t vres m2 ->
+    concrete_extends m1 m1' ->
+    val_intptrist m1' vargs vargs' ->
+    exists t', exists vres', exists m2',
+      tr_rel (ev_rel gm) t t' 
+    /\ sem ge vargs' m1' t' vres' m2'
+    /\ val_intptr m2' vres vres'
+    /\ concrete_extends m2 m2'
+    /\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2';
 
 (** External calls must be receptive to changes of traces by another, matching trace. *)
   ec_receptive:
@@ -702,16 +1035,22 @@ Record extcall_properties (sem: extcall_sem) (sg: signature) : Prop :=
   ec_determ:
     forall ge vargs m t1 vres1 m1 t2 vres2 m2,
     sem ge vargs m t1 vres1 m1 -> sem ge vargs m t2 vres2 m2 ->
-    match_traces ge t1 t2 /\ (t1 = t2 -> vres1 = vres2 /\ m1 = m2)
+    t1 = t2 /\ vres1 = vres2 /\ m1 = m2;
+
+  ec_binds_rev:
+    forall ge vargs m1 t vres m2,
+    sem ge vargs m1 t vres m2 ->
+    (forall b caddr, Maps.PTree.get b m2.(Mem.mem_concrete) = Some caddr -> Maps.PTree.get b m1.(Mem.mem_concrete) = Some caddr);
+
 }.
 
 (** ** Semantics of volatile loads *)
 
 Inductive volatile_load_sem (chunk: memory_chunk) (ge: Senv.t):
               list val -> mem -> trace -> val -> mem -> Prop :=
-  | volatile_load_sem_intro: forall b ofs m t v,
+  | volatile_load_sem_intro: forall b ofs m t v addr (TOPTR: Mem.to_ptr addr m = Some (Vptr b ofs)),
       volatile_load ge chunk m b ofs t v ->
-      volatile_load_sem chunk ge (Vptr b ofs :: nil) m t v m.
+      volatile_load_sem chunk ge (addr :: nil) m t v m.
 
 Lemma volatile_load_preserved:
   forall ge1 ge2 chunk m b ofs t v,
@@ -734,9 +1073,24 @@ Lemma volatile_load_extends:
 Proof.
   intros. inv H.
   econstructor; split; eauto. econstructor; eauto.
+  eapply Mem.perm_extends; eauto.
   exploit Mem.load_extends; eauto. intros [v' [A B]]. exists v'; split; auto. constructor; auto.
 Qed.
 
+Lemma volatile_load_concrete_extends:
+  forall ge chunk m b ofs t v m',
+  volatile_load ge chunk m b ofs t v ->
+  concrete_extends m m' ->
+  exists v', volatile_load ge chunk m' b ofs t v' /\ val_intptr m' v v'.
+Proof.
+  intros. inv H.
+  econstructor; split; eauto. econstructor; eauto.
+  eapply concrete_extends_perm_implies; eauto.
+  eapply val_intptr_refl.
+  exploit load_concrete_extends; eauto. i. des.
+  esplits; eauto. econs; eauto.
+Qed.
+
 Lemma volatile_load_inject:
   forall ge1 ge2 f chunk m b ofs t v b' ofs' m',
   symbols_inject f ge1 ge2 ->
@@ -752,10 +1106,13 @@ Proof.
   exploit eventval_match_inject_2; eauto. intros (v2 & X & Y).
   rewrite Ptrofs.add_zero. exists (Val.load_result chunk v2); split.
   constructor; auto.
+  exploit Mem.perm_inject; eauto. ii.
+  assert (Ptrofs.unsigned ofs + 0 = Ptrofs.unsigned ofs) by lia.
+  rewrite H3 in H2. eauto.
   erewrite D; eauto.
   apply Val.load_result_inject. auto.
 - (* normal load *)
-  exploit Mem.loadv_inject; eauto. simpl; eauto. simpl; intros (v2 & X & Y).
+  exploit Mem.loadv_inject; eauto. unfold Mem.loadv. ss. simpl; eauto. simpl; intros (v2 & X & Y).
   exists v2; split; auto.
   constructor; auto.
   inv VI. erewrite D; eauto.
@@ -772,57 +1129,247 @@ Proof.
   exists v1; constructor; auto.
 Qed.
 
+Lemma volatile_load_perm ge chunk m b ofs t v
+    (VL: volatile_load ge chunk m b ofs t v):
+  <<PERM: Mem.perm m b (Ptrofs.unsigned ofs) Cur Nonempty>>.
+Proof.
+  inv VL; ss. exploit Mem.load_valid_access; eauto. i. inv H1.
+  r in H2. specialize (H2 (Ptrofs.unsigned ofs)).
+  exploit H2; eauto; [destruct chunk; ss; lia|]. i.
+  eapply Mem.perm_implies; eauto. eapply perm_any_N.
+Qed.
+
+Lemma volatile_load_extends_backward
+    ge chunk m b ofs t v' m'
+    (VLOADTGT: volatile_load ge chunk m' b ofs t v')
+    (MEXT: Mem.extends m m') :
+  (exists v, <<VLOADSRC: volatile_load ge chunk m b ofs t v>> /\ <<VLD: Val.lessdef v v'>>)
+  \/ (<<VLOADFAIL: forall t v, ~ volatile_load ge chunk m b ofs t v>>).
+Proof.
+  ii. inv VLOADTGT.
+  - destruct (classic (Mem.perm m b (Ptrofs.unsigned ofs) Cur Nonempty)).
+    + left. esplits;[econs; eauto| eauto].
+    + right. ii. eapply H2. eapply volatile_load_perm; eauto.
+  - exploit Mem.load_extends_backward; eauto. ii. des.
+    { left. esplits; eauto. econs 2; eauto. }
+    { right. ii. inv H1; clarify. }
+Qed.
+
+Lemma volatile_load_concrete_extends_backward
+    ge chunk m b ofs t' v' m'
+    (VLOADTGT: volatile_load ge chunk m' b ofs t' v')
+    (MEXT: concrete_extends m m') :
+  (exists v, <<VLOADSRC: volatile_load ge chunk m b ofs t' v>> /\ <<VLD: val_intptr m' v v'>>)
+  \/ (<<VLOADFAIL: forall t v, ~ volatile_load ge chunk m b ofs t v>>).
+Proof.
+  ii. inv VLOADTGT.
+  - destruct (classic (Mem.perm m b (Ptrofs.unsigned ofs) Cur Nonempty)).
+    2:{ right. ii. eapply H2. eapply volatile_load_perm; eauto. }
+    left. esplits; eauto; [econs; eauto| eapply val_intptr_refl].
+  - destruct (Mem.load chunk m b (Ptrofs.unsigned ofs)) eqn:LD1.
+    2:{ right. ii. inv H1; clarify. }
+    exploit load_concrete_extends; eauto. ii. des.
+    clarify. left. esplits; eauto. econs 2; eauto.
+Qed.
+
+Lemma volatile_load_extends_fail ge chunk m b ofs m'
+    (FAILTGT: forall t v', ~volatile_load ge chunk m' b ofs t v')
+    (MEXT: Mem.extends m m') :
+  (<<FAILSRC: forall t v, ~ volatile_load ge chunk m b ofs t v>>).
+Proof.
+  ii. exploit volatile_load_extends; eauto. ii. des. eapply FAILTGT in H0. clarify.
+Qed.
+
+Lemma volatile_load_inject_backward
+    ge1 ge2 f chunk m b ofs t v' b' ofs' m'
+    (SI: symbols_inject f ge1 ge2)
+    (VLOADTGT: volatile_load ge2 chunk m' b' ofs' t v')
+    (VI: Val.inject f (Vptr b ofs) (Vptr b' ofs'))
+    (MI: Mem.inject f m m') :
+  (exists v, <<VLOADSRC: volatile_load ge1 chunk m b ofs t v>> /\ <<VI': Val.inject f v v'>>)
+  \/ (<<VLOADFAIL: forall t v, ~ volatile_load ge1 chunk m b ofs t v>>).
+Proof.
+  generalize SI; intros (A & B & C & D). inv VLOADTGT.
+(* volatile load *)
+- inv VI.
+  assert (Senv.block_is_volatile ge1 b = true).
+  { erewrite <- D; eauto. }
+  destruct (Senv.find_symbol ge1 id) eqn: SYMB.
+  2: { right. ii. inv H3; clarify.
+       exploit B; eauto. i. des. subst.
+       exploit Senv.find_symbol_injective; [eapply H8|eapply H0|].
+       i. des. subst. clarify. }
+  destruct (peq b0 b) eqn: BLK.
+  2: { right. ii. inv H3; clarify.
+       exploit B; eauto. i. des. subst.
+       exploit Senv.find_symbol_injective; [eapply H8|eapply H0|].
+       i. des. subst. clarify. }
+  subst. clear BLK.
+  (* make eventval_match ge2 ev (type_of_chunk chunk) v1 /\ Val.inject f v1 v *)
+  assert (exists v1, eventval_match ge1 ev (type_of_chunk chunk) v1 /\ Val.inject f v1 v).
+  { inv H1; try by (esplits; econs; econs).
+    - assert (Senv.public_symbol ge1 id0 = true).
+      { rewrite <- A; eauto. }
+      exploit Senv.public_symbol_exists; eauto. i. des.
+      exploit C; eauto. i. des; subst. clarify.
+      exists (Vptr b1 ofs0). split; econs; eauto. rewrite Ptrofs.add_zero; eauto. }
+  des. exploit B; eauto. i. des; subst.
+  rewrite Ptrofs.add_zero.
+  destruct (classic (Mem.perm m b (Ptrofs.unsigned ofs) Cur Nonempty)); cycle 1.
+  { right. ii. eapply H6. eapply volatile_load_perm; eauto. }
+  left. esplits. econs; eauto.
+  apply Val.load_result_inject. auto.
+(* normal load *)
+- exploit Mem.loadv_inject_backward; eauto.
+  { unfold Mem.loadv. ss. eapply H0. }
+  simpl; intros [[v2 [X Y]] | FAIL].
+  2: { right. ii. inv H1; clarify.
+       - inv VI. erewrite D in H; eauto. clarify.
+       - rr in FAIL. unfold Mem.loadv in FAIL. ss. clarify. }
+  left. esplits; eauto. econs 2; eauto.
+  inv VI. erewrite <- D; eauto.
+Qed.
+
+Lemma volatile_load_inject_fail
+    ge1 ge2 f chunk m b ofs b' ofs' m'
+    (SI: symbols_inject f ge1 ge2)
+    (FAILTGT: forall t v', ~ volatile_load ge2 chunk m' b' ofs' t v')
+    (VI: Val.inject f (Vptr b ofs) (Vptr b' ofs'))
+    (MI: Mem.inject f m m') :
+  (<<FAILSRC: forall t v, ~ volatile_load ge1 chunk m b ofs t v>>).
+Proof.
+  ii. exploit volatile_load_inject; eauto. i. des. eapply FAILTGT in H0; eauto.
+Qed.
+
 Lemma volatile_load_ok:
   forall chunk,
-  extcall_properties (volatile_load_sem chunk)
+  extcall_properties_backward (volatile_load_sem chunk)
                      (mksignature (Tptr :: nil) (rettype_of_chunk chunk) cc_default).
 Proof.
   intros; constructor; intros.
+  econs; i.
 (* well typed *)
 - inv H. inv H0. apply Val.load_result_rettype.
   eapply Mem.load_rettype; eauto.
 (* symbols *)
-- inv H0. constructor. eapply volatile_load_preserved; eauto.
+- inv H0. econstructor. eauto. eapply volatile_load_preserved; eauto.
 (* valid blocks *)
 - inv H; auto.
 (* max perms *)
 - inv H; auto.
 (* readonly *)
 - inv H; auto.
+(* (* trace length *) *)
+(* - inv H. inv H0; simpl; lia. *)
+- inv H; ss.
+(* nonempty *)
+- inv H; ss.
 (* mem extends *)
-- inv H. inv H1. inv H6. inv H4.
-  exploit volatile_load_extends; eauto. intros [v' [A B]].
-  exists v'; exists m1'; intuition. constructor; auto.
+- destruct (classic (exists t' vres m1', volatile_load_sem chunk ge vargs m1 t' vres m1')); cycle 1.
+  { right. left. ii. eapply H; eauto. }
+  des. inv H. inv ARGS. inv H4. exploit Mem.to_ptr_extends; try eapply TOPTR; eauto. ii. des.
+  inv CALLTGT; clarify. exploit volatile_load_extends_backward; eauto. i. des.
+  2:{ exfalso. eapply VLOADFAIL; eauto. }
+  left. esplits; eauto; [econs; eauto|apply Mem.unchanged_on_refl].
+(* mem extends progress *)
+- inv ARGS. inv CALLSRC. inv H0; inv CALLSRC.
+  exploit Mem.to_ptr_extends; try eapply TOPTR; eauto. ii. des.
+  exploit volatile_load_extends; eauto. i. des.
+  esplits. econs; eauto.
 (* mem injects *)
-- inv H0. inv H2. inv H7. inversion H5; subst.
-  exploit volatile_load_inject; eauto. intros [v' [A B]].
-  exists f; exists v'; exists m1'; intuition. constructor; auto.
-  red; intros. congruence.
-(* trace length *)
-- inv H; inv H0; simpl; lia.
-(* receptive *)
-- inv H. exploit volatile_load_receptive; eauto. intros [v2 A].
-  exists v2; exists m1; constructor; auto.
-(* determ *)
-- inv H; inv H0. inv H1; inv H7; try congruence.
-  assert (id = id0) by (eapply Senv.find_symbol_injective; eauto). subst id0.
-  split. constructor.
-  eapply eventval_match_valid; eauto.
-  eapply eventval_match_valid; eauto.
-  eapply eventval_match_same_type; eauto.
-  intros EQ; inv EQ.
-  assert (v = v0) by (eapply eventval_match_determ_1; eauto). subst v0.
-  auto.
-  split. constructor. intuition congruence.
+- destruct (classic (exists t' vres m1', volatile_load_sem chunk ge1 vargs m1 t' vres m1')); cycle 1.
+  { right. left. ii. eapply H. eauto. }
+  des. inv H. inv ARGS. inv H4. exploit Mem.to_ptr_inject; try eapply TOPTR; eauto. ii. des.
+  inv CALLTGT; clarify. exploit volatile_load_inject_backward; eauto. i. des.
+  2:{ exfalso. eapply VLOADFAIL; eauto. }
+  left. esplits; eauto.
+  + econs; eauto.
+  + apply Mem.unchanged_on_refl.
+  + apply Mem.unchanged_on_refl.
+  + ii; clarify.
+(* mem inject progress *)
+- inv ARGS. inv CALLSRC. inv H0; inv CALLSRC.
+  exploit Mem.to_ptr_inject; try eapply TOPTR; eauto. ii. des.
+  inversion VINJ; subst.
+  exploit volatile_load_inject; eauto. i. des.
+  esplits. econs; eauto.
+(* self-sim *)
+- inv CALLSRC. inv ARGS. inv H5.
+  exploit Mem.to_ptr_inject; eauto. i. des. inversion VINJ; subst.
+  exploit volatile_load_inject; eauto.
+  i. des. clarify. exploit SELF; eauto. i. des; subst.
+  rewrite H5 in *.
+  assert (vres = v').
+  { inv H; inv H0; ss; clarify.
+    exploit eventval_match_determ_1. eapply H8. eapply H17. i. subst; eauto. }
+  subst. esplits; eauto.
+  + apply Mem.unchanged_on_refl.
+  + apply Mem.unchanged_on_refl.
+  + ii; clarify.
+(* CE *)
+- destruct (classic (exists t vres m1', volatile_load_sem chunk ge vargs m1 t vres m1')); cycle 1.
+  { right. left. ii. eapply H2; eauto. }
+  des. inv H2. inv H. inv H1. inv H8.
+  assert (b = b0 /\ ofs = ofs0).
+  { unfold Mem.to_ptr in *. des_ifs; try by inv H6.
+    - inv H6. exploit denormalize_concrete_extends; eauto. i. des; clarify.
+    - inv H6. ss. des_ifs.
+      assert (PERM: Mem.perm m2' b (Ptrofs.unsigned ofs) Max Nonempty).
+      { eapply concrete_extends_perm_implies; eauto. eapply Mem.perm_cur.
+        inv H3; eauto. eapply Mem.load_valid_access in H1.
+        eapply Mem.valid_access_perm; eauto. eapply Mem.valid_access_implies; eauto.
+        eapply perm_any_N. }
+      exploit Mem.ptr2int_to_denormalize_max; eauto.
+      { eapply Ptrofs.unsigned_range_2. }
+      i. erewrite Int64.unsigned_repr in Heq1; cycle 1.
+      { eapply Mem.denormalize_info in H. des. esplits. lia.
+        unfold Ptrofs.max_unsigned, Int64.max_unsigned in *. erewrite <- Ptrofs.modulus_eq64; eauto. lia. }
+      des; clarify. erewrite Ptrofs.repr_unsigned. eauto. }
+  des; subst.
+  exploit volatile_load_concrete_extends_backward; try eapply H0. eauto. i. des; cycle 1.
+  { right. left. ii. eapply VLOADFAIL. eauto. }
+  left. esplits; eauto.
+  { instantiate (1:= t'). eapply tr_rel_refl. eapply ev_rel_refl. }
+  { econs. eauto. eauto. }
+  apply Mem.unchanged_on_refl.
+(* CE progress *)
+- inv CALLSRC. inv ARGS. inv H4. dup H2. inv H2; ss.
+  + des_ifs. exploit denormalize_concrete_extends; eauto. i.
+    exploit volatile_load_concrete_extends; eauto. i. des.
+    esplits. econs; eauto. ss. des_ifs.
+  + clarify. exploit volatile_load_concrete_extends; eauto. i. des.
+    esplits. econs; eauto. ss.
+  + des_ifs. exploit volatile_load_concrete_extends; eauto. intros (v' & VL & BIND).
+    exploit Mem.ptr2int_to_denormalize_max.
+    { eauto. }
+    { eapply Ptrofs.unsigned_range_2. }
+    { eapply concrete_extends_perm_implies; eauto. eapply Mem.perm_cur.
+      inv H; eauto. eapply Mem.load_valid_access in H3.
+      eapply Mem.valid_access_perm; eauto. eapply Mem.valid_access_implies; eauto.
+      eapply perm_any_N. }
+    i. des. esplits. econs.
+    { ss. erewrite Int64.unsigned_repr.
+      { des_ifs_safe. eapply Int64.same_if_eq in Heq1. exfalso.
+        eapply Mem.denormalize_info in Heq0. des.
+        clear - CRANGE CRANGE0 Heq1.
+        (* make lemma *)
+        assert (Int64.eq (Int64.repr z) Int64.zero = false).
+        { unfold Int64.eq. rewrite Int64.unsigned_repr.
+          2:{ unfold Ptrofs.max_unsigned, Int64.max_unsigned in *. erewrite <- Ptrofs.modulus_eq64; eauto. lia. }
+          rewrite Int64.unsigned_zero. des_ifs. }
+        rewrite Heq1 in H. ss. }
+      eapply Mem.denormalize_info in H2. des.
+      unfold Ptrofs.max_unsigned, Int64.max_unsigned in *. erewrite <- Ptrofs.modulus_eq64; eauto. lia. } 
+    erewrite Ptrofs.repr_unsigned. eauto.
 Qed.
 
 (** ** Semantics of volatile stores *)
 
 Inductive volatile_store_sem (chunk: memory_chunk) (ge: Senv.t):
               list val -> mem -> trace -> val -> mem -> Prop :=
-  | volatile_store_sem_intro: forall b ofs m1 v t m2,
+  | volatile_store_sem_intro: forall b ofs m1 v t m2 addr (TOPTR: Mem.to_ptr addr m1 = Some (Vptr b ofs)),
       volatile_store ge chunk m1 b ofs v t m2 ->
-      volatile_store_sem chunk ge (Vptr b ofs :: v :: nil) m1 t Vundef m2.
+      volatile_store_sem chunk ge (addr :: v :: nil) m1 t Vundef m2.
 
 Lemma volatile_store_preserved:
   forall ge1 ge2 chunk m1 b ofs v t m2,
@@ -875,6 +1422,7 @@ Lemma volatile_store_extends:
 Proof.
   intros. inv H.
 - econstructor; split. econstructor; eauto.
+  { eapply Mem.perm_extends; eauto. }
   eapply eventval_match_lessdef; eauto. apply Val.load_result_lessdef; auto.
   auto with mem.
 - exploit Mem.store_within_extends; eauto. intros [m2' [A B]].
@@ -888,6 +1436,32 @@ Proof.
   tauto.
 Qed.
 
+(* Lemma volatile_store_concrete_extends: *)
+(*   forall ge chunk m1 b ofs v t m2 m1' v', *)
+(*   volatile_store ge chunk m1 b ofs v t m2 -> *)
+(*   concrete_extends m1 m1' -> *)
+(*   val_intptr m1' v v' -> *)
+(*   exists m2', *)
+(*      volatile_store ge chunk m1' b ofs v' t m2' *)
+(*   /\ concrete_extends m2 m2' *)
+(*   /\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'. *)
+(* Proof. *)
+(*   intros. inv H. *)
+(* - econstructor; split. econstructor; eauto. *)
+(*   { eapply concrete_extends_perm; eauto. } *)
+(*   eapply eventval_match_lessdef; eauto. apply Val.load_result_lessdef; auto. *)
+(*   auto with mem. *)
+(* - exploit Mem.store_within_extends; eauto. intros [m2' [A B]]. *)
+(*   exists m2'; intuition. *)
+(* + econstructor; eauto. *)
+(* + eapply Mem.store_unchanged_on; eauto. *)
+(*   unfold loc_out_of_bounds; intros. *)
+(*   assert (Mem.perm m1 b i Max Nonempty). *)
+(*   { apply Mem.perm_cur_max. apply Mem.perm_implies with Writable; auto with mem. *)
+(*     exploit Mem.store_valid_access_3. eexact H3. intros [P Q]. eauto. } *)
+(*   tauto. *)
+(* Qed. *)
+
 Lemma volatile_store_inject:
   forall ge1 ge2 f chunk m1 b ofs v t m2 m1' b' ofs' v',
   symbols_inject f ge1 ge2 ->
@@ -907,7 +1481,11 @@ Proof.
 - (* volatile store *)
   inv AI. exploit Q; eauto. intros [A B]. subst delta.
   rewrite Ptrofs.add_zero. exists m1'; split.
-  constructor; auto. erewrite S; eauto.
+  constructor; auto.
+  { exploit Mem.perm_inject; eauto.
+    replace (Ptrofs.unsigned ofs + 0) with (Ptrofs.unsigned ofs) by lia.
+    eauto. }
+  erewrite S; eauto.
   eapply eventval_match_inject; eauto. apply Val.load_result_inject. auto.
   intuition auto with mem.
 - (* normal store *)
@@ -936,41 +1514,83 @@ Proof.
   intros. inv H; inv H0; auto.
 Qed.
 
+Lemma volatile_store_perm
+  ge chunk m b ofs t v m'
+  (VS: volatile_store ge chunk m b ofs v t m'):
+  <<PERM: Mem.perm m b (Ptrofs.unsigned ofs) Cur Nonempty>>.
+Proof.
+  inv VS; ss. exploit Mem.store_valid_access_3; eauto. i. inv H1.
+  r in H2. specialize (H2 (Ptrofs.unsigned ofs)).
+  exploit H2; eauto; [destruct chunk; ss; lia|]. i.
+  eapply Mem.perm_implies; eauto. eapply perm_any_N.
+Qed.
+
 Lemma volatile_store_ok:
   forall chunk,
   extcall_properties (volatile_store_sem chunk)
                      (mksignature (Tptr :: type_of_chunk chunk :: nil) Tvoid cc_default).
 Proof.
   intros; constructor; intros.
+  constructor; intros.
 (* well typed *)
 - unfold proj_sig_res; simpl. inv H; constructor.
 (* symbols preserved *)
-- inv H0. constructor. eapply volatile_store_preserved; eauto.
+- inv H0. econstructor; eauto. eapply volatile_store_preserved; eauto.
 (* valid block *)
 - inv H. inv H1. auto. eauto with mem.
 (* perms *)
 - inv H. inv H2. auto. eauto with mem.
 (* readonly *)
 - inv H. eapply unchanged_on_readonly; eauto. eapply volatile_store_readonly; eauto.
+(* bind *)
+- inv H; ss. inv H1; ss. erewrite <- Mem.concrete_store; eauto.
+(* nonempty *)
+- inv H; ss. inv H1; ss. unfold nonempty_perm in *. des. split.
+  { eapply Mem.perm_store_1; eauto. }
+  i. eapply H1; eauto. eapply Mem.perm_store_2; eauto.
+(* trace length *)
+- inv H; inv H0; simpl; lia.  
 (* mem extends*)
-- inv H. inv H1. inv H6. inv H7. inv H4.
+- inv H. inv H1. inv H6. inv H7.
+  exploit Mem.to_ptr_extends; try eapply TOPTR; eauto. i. des.
   exploit volatile_store_extends; eauto. intros [m2' [A [B C]]].
-  exists Vundef; exists m2'; intuition. constructor; auto.
+  exists Vundef; exists m2'; intuition. econstructor; eauto.
 (* mem inject *)
-- inv H0. inv H2. inv H7. inv H8. inversion H5; subst.
+- inv H0. inv H2. inv H7. inv H8.
+  exploit Mem.to_ptr_inject; try eapply H5; eauto. i. des. inv VINJ.
   exploit volatile_store_inject; eauto. intros [m2' [A [B [C D]]]].
-  exists f; exists Vundef; exists m2'; intuition. constructor; auto. red; intros; congruence.
-(* trace length *)
-- inv H; inv H0; simpl; lia.
+  exists f; exists Vundef; exists m2'; intuition. econstructor; eauto. red; intros; congruence.
+- inv H. inv H1. inv H6. inv H7.
+  assert (PERM: Mem.perm m1 b (Ptrofs.unsigned ofs) Cur Nonempty).
+  { inv H2; eauto. exploit Mem.store_valid_access_3; eauto. i.
+    eapply Mem.valid_access_perm with (k := Cur) in H2. eapply Mem.perm_implies; eauto. eapply perm_any_N. }
+  exploit to_ptr_concrete_exnteds; try eapply H4; eauto. intros TOPTR2.
+  inv H2.
+  2:{ exploit store_concrete_extends; eauto. i. des.
+      exists E0. esplits; (try by econs); eauto.
+      - econs; eauto. econs 2; eauto.
+      - eapply Mem.store_unchanged_on; eauto.
+        unfold loc_out_of_bounds; intros.
+        assert (Mem.perm m1 b i Max Nonempty).
+        { apply Mem.perm_cur_max. apply Mem.perm_implies with Writable; auto with mem.
+          exploit Mem.store_valid_access_3. eexact H1. intros [P Q]. eauto. }
+        tauto. }
+  exploit (load_result_binded chunk); eauto. i.
+  exploit eventval_match_binded; eauto. i. des.
+  exists ([Event_vstore chunk id ofs ev2]). esplits; eauto; econs; ss; eauto.
+  + econs; eauto. eapply concrete_extends_perm_implies; eauto.
+  + eapply Ple_refl.
 (* receptive *)
 - assert (t1 = t2). inv H. eapply volatile_store_receptive; eauto.
   subst t2; exists vres1; exists m1; auto.
 (* determ *)
-- inv H; inv H0. inv H1; inv H8; try congruence.
+- inv H; inv H0. clarify. inv H1; inv H7; try congruence.
   assert (id = id0) by (eapply Senv.find_symbol_injective; eauto). subst id0.
   assert (ev = ev0) by (eapply eventval_match_determ_2; eauto). subst ev0.
   split. constructor. auto.
-  split. constructor. intuition congruence.
+  esplits; eauto. clarify.
+(* concrete rev *)
+- inv H. inv H1; eauto. erewrite Mem.concrete_store; eauto.
 Qed.
 
 (** ** Semantics of dynamic memory allocation (malloc) *)
@@ -1000,6 +1620,7 @@ Proof.
     intros. eapply Mem.valid_not_valid_diff; eauto with mem.
   }
   constructor; intros.
+  constructor; intros.
 (* well typed *)
 - inv H. simpl. unfold Tptr; destruct Archi.ptr64; auto.
 (* symbols preserved *)
@@ -1012,6 +1633,18 @@ Proof.
   apply Mem.valid_not_valid_diff with m1; eauto with mem.
 (* readonly *)
 - inv H. eapply unchanged_on_readonly; eauto. 
+(* (* trace length *) *)
+(* - inv H; simpl; lia. *)
+(* bind *)
+- inv H; ss. erewrite <- Mem.concrete_store; try eapply H2. erewrite <- Mem.concrete_alloc; eauto.
+(* nonempty *)
+- inv H; ss. unfold nonempty_perm in *. des.
+  exploit Mem.perm_alloc_1; eauto. i. exploit Mem.perm_store_1; eauto. i.
+  split; eauto. i. eapply H3. eapply Mem.perm_alloc_4; eauto.
+  { eapply Mem.perm_store_2; eauto. }
+  ii. subst. eapply Mem.fresh_block_alloc; eauto. eapply Mem.perm_valid_block; eauto.
+(* trace length *)
+- inv H; inv H0; simpl; lia.  
 (* mem extends *)
 - inv H. inv H1. inv H7.
   assert (SZ: v2 = Vptrofs sz).
@@ -1042,8 +1675,15 @@ Proof.
   red; intros. destruct (eq_block b1 b).
   subst b1. rewrite C in H2. inv H2. eauto with mem.
   rewrite D in H2 by auto. congruence.
-(* trace length *)
-- inv H; simpl; lia.
+- inv H. inv H1. inv H7. inv H5. des_ifs.
+  unfold Vptrofs in Heq. des_ifs.
+  exploit alloc_concrete_extends; eauto. i. des.
+  exploit store_concrete_extends; eauto.
+  { econs. }
+  i. des. esplits; eauto.
+  { econs. }
+  { econs; eauto. }
+  eapply val_intptr_refl.
 (* receptive *)
 - assert (t1 = t2). inv H; inv H0; auto. subst t2.
   exists vres1; exists m1; auto.
@@ -1056,17 +1696,19 @@ Proof.
   }
   subst.
   split. constructor. intuition congruence.
+(* concrete rev *)
+- inv H. erewrite Mem.concrete_alloc; cycle 1; eauto. erewrite Mem.concrete_store; eauto.
 Qed.
 
 (** ** Semantics of dynamic memory deallocation (free) *)
 
 Inductive extcall_free_sem (ge: Senv.t):
               list val -> mem -> trace -> val -> mem -> Prop :=
-  | extcall_free_sem_ptr: forall b lo sz m m',
+  | extcall_free_sem_ptr: forall b lo sz m m' addr (TOPTR: Mem.to_ptr addr m = Some (Vptr b lo)),
       Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz) ->
       Ptrofs.unsigned sz > 0 ->
       Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr) (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m' ->
-      extcall_free_sem ge (Vptr b lo :: nil) m E0 Vundef m'
+      extcall_free_sem ge (addr :: nil) m E0 Vundef m'
   | extcall_free_sem_null: forall m,
       extcall_free_sem ge (Vnullptr :: nil) m E0 Vundef m.
 
@@ -1075,10 +1717,13 @@ Lemma extcall_free_ok:
                      (mksignature (Tptr :: nil) Tvoid cc_default).
 Proof.
   constructor; intros.
+  constructor; intros.
 (* well typed *)
 - inv H; simpl; auto.
 (* symbols preserved *)
-- inv H0; econstructor; eauto.
+- inv H0.
+  { econs; eauto. }
+  { econs 2; eauto. }
 (* valid block *)
 - inv H; eauto with mem.
 (* perms *)
@@ -1090,9 +1735,25 @@ Proof.
   apply Mem.perm_cur_max. apply Mem.perm_implies with Freeable; auto with mem.
   eapply Mem.free_range_perm; eauto.
 + apply Mem.unchanged_on_refl.
+- inv H; ss. erewrite <- Mem.concrete_free; try eapply H3. eauto.
+(* nonempty *)
+- inv H; ss.
+  unfold nonempty_perm in *. des.
+  hexploit Mem.free_range_perm; eauto. intros FPERM. r in FPERM.
+  destruct (classic (Ptrofs.unsigned lo - size_chunk Mptr <= ofs < Ptrofs.unsigned lo + Ptrofs.unsigned sz)).
+  { exploit FPERM; eauto. i.
+    destruct (peq b0 b); subst.
+    { eapply H4 in H5. clarify. }
+    exploit Mem.perm_free_1; eauto. i. split; eauto. i.
+    eapply Mem.perm_free_3 in H7; eauto. }
+  eapply not_and_or in H. split.
+  { exploit Mem.perm_free_1; eauto. right. des; lia. }
+  i. eapply Mem.perm_free_3 in H5; eauto.
+(* trace length *)
+- inv H; simpl; lia.  
 (* mem extends *)
 - inv H.
-+ inv H1. inv H8. inv H6.
++ inv H1. inv H8.
   exploit Mem.load_extends; eauto. intros [v' [A B]].
   assert (v' = Vptrofs sz).
   { unfold Vptrofs in *; destruct Archi.ptr64; inv B; auto. }
@@ -1100,6 +1761,7 @@ Proof.
   exploit Mem.free_parallel_extends; eauto. intros [m2' [C D]].
   exists Vundef; exists m2'; intuition auto.
   econstructor; eauto.
+  { eapply Mem.to_ptr_extends; try eapply TOPTR; eauto. }
   eapply Mem.free_unchanged_on; eauto.
   unfold loc_out_of_bounds; intros.
   assert (Mem.perm m1 b i Max Nonempty).
@@ -1113,7 +1775,8 @@ Proof.
   unfold Vnullptr in *; destruct Archi.ptr64; inv H3; auto.
 (* mem inject *)
 - inv H0.
-+ inv H2. inv H7. inv H9.
++ inv H2. inv H9. rename v' into addr'.
+  exploit Mem.to_ptr_inject; eauto. i. des. inv VINJ.
   exploit Mem.load_inject; eauto. intros [v' [A B]].
   assert (v' = Vptrofs sz).
   { unfold Vptrofs in *; destruct Archi.ptr64; inv B; auto. }
@@ -1127,7 +1790,8 @@ Proof.
   intro EQ.
   exploit Mem.free_parallel_inject; eauto. intros (m2' & C & D).
   exists f, Vundef, m2'; split.
-  apply extcall_free_sem_ptr with (sz := sz) (m' := m2').
+  eapply extcall_free_sem_ptr with (sz := sz) (m' := m2').
+    eauto. eauto.
     rewrite EQ. rewrite <- A. f_equal. lia.
     auto. auto.
     rewrite ! EQ. rewrite <- C. f_equal; lia.
@@ -1144,15 +1808,32 @@ Proof.
   exists f, Vundef, m1'; intuition auto using Mem.unchanged_on_refl.
   constructor.
   red; intros; congruence.
-  unfold Vnullptr in *; destruct Archi.ptr64; inv H4; auto.
-(* trace length *)
-- inv H; simpl; lia.
+  inv H4; auto.
+- inv H; cycle 1.
+  { inv H1. inv H5. inv H3. des_ifs. esplits; eauto; try by econs.
+    - rewrite <- Heq. econs 2; eauto.
+    - eapply Mem.unchanged_on_refl. }
+  inv H1. inv H8. exploit to_ptr_concrete_exnteds; eauto.
+  { eapply Mem.free_range_perm in H4. specialize (H4 (Ptrofs.unsigned lo)). exploit H4.
+    { unfold Mptr. des_ifs. ss. lia. }
+    i. eapply Mem.perm_cur. eapply Mem.perm_implies; eauto. eapply perm_any_N. }
+  i. exploit load_concrete_extends; eauto. i. des.
+  exploit free_concrete_extends; eauto. i. des.
+  esplits; eauto; try by econs.
+  + econs; eauto. inv BIND. des_ifs.
+  + eapply Mem.free_unchanged_on; eauto.
+    unfold loc_out_of_bounds; intros.
+    assert (Mem.perm m1 b i Max Nonempty).
+    { apply Mem.perm_cur_max. apply Mem.perm_implies with Freeable; auto with mem.
+      eapply Mem.free_range_perm. eexact H4. eauto. }
+    tauto.
 (* receptive *)
 - assert (t1 = t2) by (inv H; inv H0; auto). subst t2.
   exists vres1; exists m1; auto.
 (* determ *)
 - inv H; inv H0; try (unfold Vnullptr in *; destruct Archi.ptr64; discriminate).
-+ assert (EQ1: Vptrofs sz0 = Vptrofs sz) by congruence.
++ rewrite TOPTR0 in TOPTR. inv TOPTR.
+  assert (EQ1: Vptrofs sz0 = Vptrofs sz) by congruence.
   assert (EQ2: sz0 = sz).
   { unfold Vptrofs in EQ1; destruct Archi.ptr64 eqn:SF.
     rewrite <- (Ptrofs.of_int64_to_int64 SF sz0), <- (Ptrofs.of_int64_to_int64 SF sz). congruence.
@@ -1161,13 +1842,18 @@ Proof.
   subst sz0.
   split. constructor. intuition congruence.
 + split. constructor. intuition auto.
+(* concrete rev *)
+- inv H; eauto. erewrite Mem.concrete_free; cycle 1; eauto.
+  Unshelve. econs.
 Qed.
 
 (** ** Semantics of [memcpy] operations. *)
 
 Inductive extcall_memcpy_sem (sz al: Z) (ge: Senv.t):
                         list val -> mem -> trace -> val -> mem -> Prop :=
-  | extcall_memcpy_sem_intro: forall bdst odst bsrc osrc m bytes m',
+  | extcall_memcpy_sem_intro: forall bdst odst bsrc osrc m bytes m' addr addr' (SZ: sz > 0)
+                                (TOPTR1: Mem.to_ptr addr m = Some (Vptr bdst odst))
+                                (TOPTR2: Mem.to_ptr addr' m = Some (Vptr bsrc osrc)),
       al = 1 \/ al = 2 \/ al = 4 \/ al = 8 -> sz >= 0 -> (al | sz) ->
       (sz > 0 -> (al | Ptrofs.unsigned osrc)) ->
       (sz > 0 -> (al | Ptrofs.unsigned odst)) ->
@@ -1176,7 +1862,10 @@ Inductive extcall_memcpy_sem (sz al: Z) (ge: Senv.t):
                    \/ Ptrofs.unsigned odst + sz <= Ptrofs.unsigned osrc ->
       Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes ->
       Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m' ->
-      extcall_memcpy_sem sz al ge (Vptr bdst odst :: Vptr bsrc osrc :: nil) m E0 Vundef m'.
+      extcall_memcpy_sem sz al ge (addr :: addr' :: nil) m E0 Vundef m'
+  | extcall_memcpy_sem_zero: forall m addr addr' (SZ: sz = 0),
+      extcall_memcpy_sem sz al ge (addr :: addr' :: nil) m E0 Vundef m  
+.
 
 Lemma extcall_memcpy_ok:
   forall sz al,
@@ -1184,26 +1873,42 @@ Lemma extcall_memcpy_ok:
                      (mksignature (Tptr :: Tptr :: nil) Tvoid cc_default).
 Proof.
   intros. constructor.
+  intros. constructor.
 - (* return type *)
-  intros. inv H. exact I.
+  intros. inv H; exact I.
 - (* change of globalenv *)
   intros. inv H0. econstructor; eauto.
+  econs 2; eauto.
 - (* valid blocks *)
-  intros. inv H. eauto with mem.
+  intros. inv H; eauto with mem.
 - (* perms *)
   intros. inv H. eapply Mem.perm_storebytes_2; eauto.
+  eauto.
 - (* readonly *)
   intros. inv H. eapply unchanged_on_readonly; eauto. 
   eapply Mem.storebytes_unchanged_on; eauto.
   intros; red; intros. elim H11.
   apply Mem.perm_cur_max. eapply Mem.storebytes_range_perm; eauto.
+  eauto.
+- i. inv H. erewrite <- Mem.concrete_storebytes; eauto. ss.
+(* nonempty *)
+- ii. inv H; ss. unfold nonempty_perm in *. des_safe.
+  exploit Mem.perm_storebytes_1; eauto. i. split; auto. i.
+  eapply Mem.perm_storebytes_2 in H10; eauto.
+- (* trace length *)
+  intros; inv H; simpl; lia.  
 - (* extensions *)
   intros. inv H.
-  inv H1. inv H13. inv H14. inv H10. inv H11.
+  inv H1. inv H13. inv H14. (* inv H14. inv H10. inv H11. *)
   exploit Mem.loadbytes_length; eauto. intros LEN.
   exploit Mem.loadbytes_extends; eauto. intros [bytes2 [A B]].
   exploit Mem.storebytes_within_extends; eauto. intros [m2' [C D]].
   exists Vundef; exists m2'.
+  exploit Mem.to_ptr_extends; try eapply TOPTR1; eauto. i. des_safe.
+  exploit Mem.to_ptr_extends; try eapply TOPTR2; eauto. i. des_safe.
+  assert (v2 = addr /\ v0 = addr').
+  { destruct addr; destruct addr'; ss; inv H11; inv H10; eauto. }
+  des_safe; subst.
   split. econstructor; eauto.
   split. constructor.
   split. auto.
@@ -1213,30 +1918,12 @@ Proof.
   eapply Mem.storebytes_range_perm; eauto.
   erewrite list_forall2_length; eauto.
   tauto.
+  { inv H1. inv H5. inv H6. esplits; eauto; [econs 2; eauto| eapply Mem.unchanged_on_refl]. }
 - (* injections *)
-  intros. inv H0. inv H2. inv H14. inv H15. inv H11. inv H12.
-  destruct (zeq sz 0).
-+ (* special case sz = 0 *)
-  assert (bytes = nil).
-  { exploit (Mem.loadbytes_empty m1 bsrc (Ptrofs.unsigned osrc) sz). lia. congruence. }
-  subst.
-  destruct (Mem.range_perm_storebytes m1' b0 (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil)
-  as [m2' SB].
-  simpl. red; intros; extlia.
-  exists f, Vundef, m2'.
-  split. econstructor; eauto.
-  intros; extlia.
-  intros; extlia.
-  right; lia.
-  apply Mem.loadbytes_empty. lia.
-  split. auto.
-  split. eapply Mem.storebytes_empty_inject; eauto.
-  split. eapply Mem.storebytes_unchanged_on; eauto. unfold loc_unmapped; intros.
-  congruence.
-  split. eapply Mem.storebytes_unchanged_on; eauto.
-  simpl; intros; extlia.
-  split. apply inject_incr_refl.
-  red; intros; congruence.
+  intros. inv H0. inv H2. inv H14. inv H15. (* inv H11. inv H12. *)
+  exploit Mem.to_ptr_inject; try eapply TOPTR1; eauto. intros (v1' & TOPTR1' & INJ1). des_safe.
+  exploit Mem.to_ptr_inject; try eapply TOPTR2; eauto. intros (v0' & TOPTR2' & INJ0). des_safe.
+  inv INJ0. inv INJ1. 
 + (* general case sz > 0 *)
   exploit Mem.loadbytes_length; eauto. intros LEN.
   assert (RPSRC: Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur Nonempty).
@@ -1254,12 +1941,12 @@ Proof.
   exploit Mem.loadbytes_inject; eauto. intros [bytes2 [A B]].
   exploit Mem.storebytes_mapped_inject; eauto. intros [m2' [C D]].
   exists f; exists Vundef; exists m2'.
-  split. econstructor; try rewrite EQ1; try rewrite EQ2; eauto.
+  split. econstructor; try eapply TOPTR1'; try eapply TOPTR0'; try rewrite EQ1; try rewrite EQ2; eauto.
   intros; eapply Mem.aligned_area_inject with (m := m1); eauto.
   intros; eapply Mem.aligned_area_inject with (m := m1); eauto.
   eapply Mem.disjoint_or_equal_inject with (m := m1); eauto.
   apply Mem.range_perm_max with Cur; auto.
-  apply Mem.range_perm_max with Cur; auto. lia.
+  apply Mem.range_perm_max with Cur; auto. (* lia. *)
   split. constructor.
   split. auto.
   split. eapply Mem.storebytes_unchanged_on; eauto. unfold loc_unmapped; intros.
@@ -1272,14 +1959,50 @@ Proof.
   lia.
   split. apply inject_incr_refl.
   red; intros; congruence.
-- (* trace length *)
-  intros; inv H. simpl; lia.
++ (* special case sz = 0 *)
+  inv H2. inv H6. inv H7.
+  esplits; eauto.
+  econs 2; eauto.
+  eapply Mem.unchanged_on_refl.
+  eapply Mem.unchanged_on_refl.
+  red; intros; congruence.
+- i. inv H; cycle 1.
+  { esplits; eauto; try by econs.
+    - inv H1. inv H5. inv H6. econs 2. eauto.
+    - eapply Mem.unchanged_on_refl. }
+  inv H1. inv H13. inv H14.
+  exploit Mem.loadbytes_length; eauto. intros LEN.
+  assert (RPSRC: Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur Nonempty).
+  { eapply Mem.range_perm_implies. eapply Mem.loadbytes_range_perm; eauto. auto with mem. }
+  assert (RPDST: Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur Nonempty).
+  { replace sz with (Z.of_nat (length bytes)).
+    eapply Mem.range_perm_implies. eapply Mem.storebytes_range_perm; eauto. auto with mem.
+    rewrite LEN. apply Z2Nat.id. lia. }
+  assert (PSRC: Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty).
+  { apply RPSRC. lia. }
+  assert (PDST: Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty).
+  { apply RPDST. lia. }
+  exploit to_ptr_concrete_exnteds; try eapply TOPTR1; eauto. i.
+  exploit to_ptr_concrete_exnteds; try eapply TOPTR2; eauto. i.
+  exploit loadbytes_concrete_extends; eauto. i. des_safe.
+  exploit storebytes_within_concrete_extends; eauto. i. des_safe.
+  exists E0, Vundef, m2'. esplits; eauto; try by econs.
+  + econs; eauto.
+  + eapply Mem.storebytes_unchanged_on; eauto. unfold loc_out_of_bounds; intros.
+    assert (Mem.perm m1 bdst i Max Nonempty).
+    apply Mem.perm_cur_max. apply Mem.perm_implies with Writable; auto with mem.
+    eapply Mem.storebytes_range_perm; eauto.
+    erewrite list_forall2_length; eauto.
+    tauto.
 - (* receptive *)
   intros.
   assert (t1 = t2). inv H; inv H0; auto. subst t2.
   exists vres1; exists m1; auto.
 - (* determ *)
   intros; inv H; inv H0. split. constructor. intros; split; congruence.
+  lia. lia. esplits; eauto.
+(* concrete rev *)
+- i. inv H; eauto. erewrite Mem.concrete_storebytes; cycle 1; eauto.
 Qed.
 
 (** ** Semantics of annotations. *)
@@ -1296,6 +2019,7 @@ Lemma extcall_annot_ok:
                      (mksignature targs Tvoid cc_default).
 Proof.
   intros; constructor; intros.
+  constructor; intros.
 (* well typed *)
 - inv H. simpl. auto.
 (* symbols *)
@@ -1307,6 +2031,10 @@ Proof.
 - inv H; auto.
 (* readonly *)
 - inv H; auto.
+- inv H; ss.
+- inv H; ss.
+(* trace length *)
+- inv H; simpl; lia.
 (* mem extends *)
 - inv H.
   exists Vundef; exists m1'; intuition.
@@ -1318,8 +2046,10 @@ Proof.
   econstructor; eauto.
   eapply eventval_list_match_inject; eauto.
   red; intros; congruence.
-(* trace length *)
-- inv H; simpl; lia.
+- inv H. exploit eventval_list_match_binded; eauto. i. des.
+  exists (Event_annot text evl2 :: E0), Vundef, m1'. esplits; eauto; try by econs.
+  + econs; eauto; econs; eauto.
+  + eapply Mem.unchanged_on_refl.
 (* receptive *)
 - assert (t1 = t2). inv H; inv H0; auto.
   exists vres1; exists m1; congruence.
@@ -1327,6 +2057,8 @@ Proof.
 - inv H; inv H0.
   assert (args = args0). eapply eventval_list_match_determ_2; eauto. subst args0.
   split. constructor. auto.
+(* concrete rev *)
+- inv H; eauto.
 Qed.
 
 Inductive extcall_annot_val_sem (text: string) (targ: typ) (ge: Senv.t):
@@ -1341,6 +2073,7 @@ Lemma extcall_annot_val_ok:
                      (mksignature (targ :: nil) targ cc_default).
 Proof.
   intros; constructor; intros.
+  constructor; intros.
 (* well typed *)
 - inv H. eapply eventval_match_type; eauto.
 (* symbols *)
@@ -1352,6 +2085,10 @@ Proof.
 - inv H; auto.
 (* readonly *)
 - inv H; auto.
+- inv H. ss.
+- inv H. ss.
+(* trace length *)
+- inv H; simpl; lia.
 (* mem extends *)
 - inv H. inv H1. inv H6.
   exists v2; exists m1'; intuition.
@@ -1363,8 +2100,11 @@ Proof.
   econstructor; eauto.
   eapply eventval_match_inject; eauto.
   red; intros; congruence.
-(* trace length *)
-- inv H; simpl; lia.
+- inv H. inv H1. inv H6. exploit eventval_match_binded; eauto. i. des.
+  exists (Event_annot text [ev2] :: E0). esplits; eauto.
+  { econs; econs; eauto. }
+  + econs. eauto.
+  + eapply Mem.unchanged_on_refl.
 (* receptive *)
 - assert (t1 = t2). inv H; inv H0; auto. subst t2.
   exists vres1; exists m1; auto.
@@ -1372,6 +2112,8 @@ Proof.
 - inv H; inv H0.
   assert (arg = arg0). eapply eventval_match_determ_2; eauto. subst arg0.
   split. constructor. auto.
+(* concrete rev *)
+- inv H; eauto.
 Qed.
 
 Inductive extcall_debug_sem (ge: Senv.t):
@@ -1385,6 +2127,7 @@ Lemma extcall_debug_ok:
                      (mksignature targs Tvoid cc_default).
 Proof.
   intros; constructor; intros.
+  constructor; intros.
 (* well typed *)
 - inv H. simpl. auto.
 (* symbols *)
@@ -1395,6 +2138,10 @@ Proof.
 - inv H; auto.
 (* readonly *)
 - inv H; auto.
+- inv H; ss.
+- inv H; ss.
+(* trace length *)
+- inv H; simpl; lia.
 (* mem extends *)
 - inv H.
   exists Vundef; exists m1'; intuition.
@@ -1404,13 +2151,15 @@ Proof.
   exists f; exists Vundef; exists m1'; intuition.
   econstructor; eauto.
   red; intros; congruence.
-(* trace length *)
-- inv H; simpl; lia.
+- inv H. esplits; eauto. econs. econs. econs.
+  eapply Mem.unchanged_on_refl.
 (* receptive *)
 - inv H; inv H0. exists Vundef, m1; constructor.
 (* determ *)
 - inv H; inv H0.
   split. constructor. auto.
+(* concrete rev *)
+- inv H; eauto.
 Qed.
 
 (** ** Semantics of known built-in functions. *)
@@ -1429,6 +2178,7 @@ Lemma known_builtin_ok: forall bf,
   extcall_properties (known_builtin_sem bf) (builtin_function_sig bf).
 Proof.
   intros. set (bsem := builtin_function_sem bf). constructor; intros.
+  constructor; intros.
 (* well typed *)
 - inv H.
   specialize (bs_well_typed  _ bsem vargs).
@@ -1442,6 +2192,10 @@ Proof.
 - inv H; auto.
 (* readonly *)
 - inv H; auto.
+- inv H; ss.
+- inv H; ss.
+(* trace length *)
+- inv H; simpl; lia.
 (* mem extends *)
 - inv H. fold bsem in H2. apply val_inject_list_lessdef in H1.
   specialize (bs_inject _ bsem _ _ _ H1).
@@ -1458,13 +2212,347 @@ Proof.
   exists f, vres', m1'; intuition auto using Mem.extends_refl, Mem.unchanged_on_refl.
   constructor; auto.
   red; intros; congruence.
-(* trace length *)
-- inv H; simpl; lia.
+- inv H. fold bsem in H2.
+  specialize (bs_binded _ bsem _ _ _ H1).
+  unfold val_opt_binded. rewrite H2. i. des_ifs.
+  esplits; eauto.
+  { econs. }
+  { econs; eauto. }
+  eapply Mem.unchanged_on_refl.
 (* receptive *)
 - inv H; inv H0. exists vres1, m1; constructor; auto. 
 (* determ *)
 - inv H; inv H0.
-  split. constructor. intuition congruence. 
+  split. constructor. intuition congruence.
+(* concrete rev *)
+- inv H; eauto.
+Qed.
+
+Inductive extcall_capture_sem (ge: Senv.t):
+  list val -> mem -> trace -> val -> mem -> Prop :=
+| extcall_capture_sem_intro
+    b m m' addr ofs v
+    (CAPTURE: Mem.capture m b addr m')
+    (RET: v = if Archi.ptr64
+              then Vlong (Int64.repr (addr + (Ptrofs.unsigned ofs)))
+              else Vint (Int.repr (addr + (Ptrofs.unsigned ofs)))) :
+    extcall_capture_sem ge (Vptr b ofs :: nil) m E0 v m'
+| extcall_capture_sem_fail
+    b m ofs
+    (OOM: Mem.capture_oom m b) :
+    extcall_capture_sem ge (Vptr b ofs :: nil) m [Event_pterm] Vundef m
+| extcall_capture_int
+    (PTRSZ: Archi.ptr64 = false)
+    m n :
+    extcall_capture_sem ge (Vint n :: nil) m E0 (Vint n) m
+| extcall_capture_long
+    (PTRSZ: Archi.ptr64 = true)
+    m n :
+    extcall_capture_sem ge (Vlong n :: nil) m E0 (Vlong n) m.
+
+Lemma capture_extends_backward
+    m1 b addr m1' m2'
+    (CAPTGT: Mem.capture m1' b addr m2')
+    (MEXT: Mem.extends m1 m1') :
+  (exists m2, <<CAPSRC: Mem.capture m1 b addr m2>>
+    /\ <<MEXT: Mem.extends m2 m2'>>
+    /\ <<PRIV: Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'>>).
+Proof.
+  exploit Mem.capture_extends_backward; eauto. i. des. esplits; eauto.
+  inversion CAPTGT. econs; eauto.
+  - rewrite NEXTBLOCK. eapply Ple_refl.
+  - i. unfold Mem.perm. rewrite ACCESS. auto.
+  - i. rewrite CONTENTS. auto.
+  - i. destruct (peq b0 b).
+    { subst. exploit PREVADDR; eauto. i. des. rewrite <- H2. clarify. }
+    { exploit Mem.concrete_other. eapply CAPTGT. eauto. i. rewrite <- H1. auto. }
+Qed.
+
+Lemma capture_extends_backward_progress
+    m1 m2 b addr m1'
+    (CAPSRC: Mem.capture m1 b addr m2)
+    (MEXT: Mem.extends m1 m1') :
+  (exists m2' addr, <<CAPTGT: Mem.capture m1' b addr m2'>>) \/ <<OOM: Mem.capture_oom m1' b>>.
+Proof. exploit Mem.capture_extends_backward_progress; eauto. Qed.
+
+Lemma capture_injects_backward
+    m1' b' m2' f m1 b ofs ofs' delta addr
+    (FB: f b = Some (b', delta))
+    (CAPTGT: Mem.capture m1' b' (addr - delta) m2')
+    (MINJ: Mem.inject f m1 m1')
+    (VINJ: Val.inject f (Vptr b ofs) (Vptr b' ofs')) :
+  (exists f' m2,
+    <<CAPSRC: Mem.capture m1 b addr m2>>
+    /\ <<MINJ: Mem.inject f' m2 m2'>>
+    /\ <<MEMPRIVSRC: Mem.unchanged_on (loc_unmapped f) m1 m2>>
+    /\ <<MEMPRIVTGT: Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'>>
+    /\ <<INJINCR: inject_incr f f'>>
+    /\ <<INJSEP: inject_separated f f' m1 m1'>>).
+Proof.
+  exploit Mem.capture_inject_backward; try eapply FB; eauto. i. des.
+  esplits; eauto.
+  - inversion CAPSRC. econs.
+    + rewrite NEXTBLOCK. eapply Ple_refl.
+    + i. inv H. unfold Mem.perm. rewrite ACCESS. auto.
+    + i. rewrite CONTENTS. auto.
+    + i. destruct (peq b0 b).
+      * subst. exploit PREVADDR; eauto. i. des. rewrite <- H2. clarify.
+      * exploit Mem.concrete_other. eapply CAPSRC. eauto. i. rewrite <- H1. auto.
+  - inversion CAPTGT. econs.
+    + rewrite NEXTBLOCK. eapply Ple_refl.
+    + i. unfold Mem.perm. rewrite ACCESS. auto.
+    + i. rewrite CONTENTS. auto.
+    + i. destruct (peq b0 b').
+      * subst. exploit PREVADDR; eauto. i. des. rewrite <- H2. clarify.
+      * exploit Mem.concrete_other. eapply CAPTGT. eauto. i. rewrite <- H1. auto.
+  - split; clarify.
+Qed.
+
+Lemma capture_injects_backward_progress
+    m1 b addr m1' f m2 b' ofs ofs' delta
+    (FB: f b = Some (b', delta))
+    (CAPSRC: Mem.capture m1 b addr m2)
+    (MINJ: Mem.inject f m1 m1')
+    (VINJ: Val.inject f (Vptr b ofs) (Vptr b' ofs')) :
+  (exists m2' addr', <<CAPTGT: Mem.capture m1' b' addr' m2'>>) \/ <<OOM: Mem.capture_oom m1' b'>>.
+Proof. exploit Mem.capture_injects_backward_progress; eauto. Qed.
+
+Lemma capture_concrete_extends_backward
+    m1 b addr m1' m2'
+    (CAPTGT: Mem.capture m1' b addr m2')
+    (CONC: concrete_extends m1 m1') :
+  (exists m2,
+    <<CAPSRC: Mem.capture m1 b addr m2>>
+    /\ <<CONC: concrete_extends m2 m2'>>
+    /\ <<PRIV: Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'>>).
+Proof.
+  exploit capture_concrete_extends; eauto. i. des. esplits; eauto.
+  inversion CAPTGT. econs; eauto.
+  - rewrite NEXTBLOCK. eapply Ple_refl.
+  - i. unfold Mem.perm. rewrite ACCESS. auto.
+  - i. rewrite CONTENTS. auto.
+  - i. destruct (peq b0 b).
+    { subst. exploit PREVADDR; eauto. i. des. rewrite <- H2. clarify. }
+    { exploit Mem.concrete_other. eapply CAPTGT. eauto. i. rewrite <- H1. auto. }
+Qed.
+
+Lemma extcall_capture_ok:
+  extcall_properties_backward extcall_capture_sem
+                              (mksignature (Tptr :: nil) (if Archi.ptr64 then Tlong else Tint) cc_default).
+Proof.
+  econs; i. econs; i.
+(* well typed *)
+- inv H; unfold proj_sig_res; ss.
+(* symbols *)
+- inv H0. econs; eauto. econs 2; eauto. econs; eauto. econs; eauto.
+(* valid blocks *)
+- inv H; eauto. inv CAPTURE. unfold Mem.valid_block in *. rewrite <- NEXTBLOCK. eauto.
+(* max perms *)
+- inv H; try inv CAPTURE; unfold Mem.perm in *; try rewrite ACCESS; auto.
+(* readonly *)
+- inv H; eauto.
+  inversion CAPTURE.
+  erewrite <- Mem.loadbytes_capture_unchanged; eauto.
+(* (* trace length *) *)
+(* - inv H; simpl; lia. *)
+- inv H; ss. inv CAPTURE.
+  destruct (peq b b0); subst.
+  { exploit PREVADDR; eauto. i. des. rewrite <- H1. eauto. }
+  destruct (Maps.PTree.get b0 (Mem.mem_concrete m1)) eqn:CAP.
+  + exploit PREVADDR; eauto. i. des; clarify. rewrite <- H1; eauto.
+  + exploit CAPTURED; eauto. i. rewrite H. rewrite Maps.PTree.gso; eauto.
+- inv H; ss. unfold nonempty_perm in *. des.
+  rewrite Genv.capture_same_perm in H0; eauto. split; eauto. i.
+  rewrite <- Genv.capture_same_perm in H; eauto.
+(* mem extends *)
+- inversion CALLTGT; subst; cycle 1.
+  { inv ARGS. inv H2; inv H3; cycle 1.
+    - right. left. ii. inv H.
+    - destruct (classic (Mem.valid_block m1 b)); cycle 1.
+      { right. left. ii. inv H0. inv CAPTURE; clarify.
+        inv OOM0; clarify. }
+      destruct OOM.
+      destruct (classic (exists addr' m'', Mem.capture m1 b addr' m'')).
+      + des. right. right. esplits; ss.
+        * unfold trace_intact. ss. ii. eapply H3. eauto.
+        * traceEq. econs; eauto.
+      + right. right. esplits; eauto.
+        * unfold trace_intact. ss. ii. eapply H3. eauto.
+        * traceEq. econs 2; eauto. split; eauto. }
+  { inv ARGS. inv H3. inv H2.
+    - left. exists (Vint n). exists m1. esplits; eauto.
+      { econs; eauto. }
+      { eapply Mem.unchanged_on_refl. }
+    - right. left. ii. inv H. }
+  { inv ARGS. inv H3. inv H2.
+    - left. exists (Vlong n). exists m1. esplits; eauto.
+      { econs; eauto. }
+      { eapply Mem.unchanged_on_refl. }
+    - right. left. ii. inv H. }
+  inv ARGS; inv H2; inv H3; cycle 1.
+  { right. left. ii. inv H. }
+  exploit capture_extends_backward; eauto. i. des.
+  left. exists (if Archi.ptr64 then Vlong (Int64.repr (addr + Ptrofs.unsigned ofs))
+           else Vint (Int.repr (addr + Ptrofs.unsigned ofs))).
+  esplits; eauto. econs; eauto.
+(* mem extends progress *)
+- inversion CALLSRC; subst; inv ARGS; inv H1; inv H3; cycle 1.
+  { exists [Event_pterm], Vundef. eexists.
+    red. econs 2; eauto.
+    inv OOM. split.
+    erewrite <- Mem.valid_block_extends; eauto.
+    ii. exploit capture_extends_backward; eauto. i. des.
+    eapply H0. eauto. }
+  { esplits; eauto. econs; eauto. }
+  { esplits; eauto. econs; eauto. }
+  exploit capture_extends_backward_progress; eauto. i. des.
+  + esplits. econs; eauto.
+  + exists [Event_pterm], Vundef. eexists.
+    red. econs 2; eauto.
+(* mem injects *)
+- inversion CALLTGT; subst; cycle 1.
+  { inv ARGS. inv H2; inv H3; cycle 1.
+    - right. left. ii. inv H.
+    - destruct (classic (Mem.valid_block m1 b1)); cycle 1.
+      { right. left. ii. inv H0. inv CAPTURE; clarify.
+        inv OOM0; clarify. }
+      destruct OOM.
+      destruct (classic (exists addr' m'', Mem.capture m1 b1 addr' m'')).
+      + des. right. right. esplits; ss.
+        * unfold trace_intact. ss. ii. eapply H3. eauto.
+        * traceEq. econs; eauto.
+      + right. right. esplits; eauto.
+        * unfold trace_intact. ss. ii. eapply H3. eauto.
+        * traceEq. econs 2; eauto. split; eauto. }
+  { inv ARGS. inv H3. inv H2.
+    - left. exists f. exists (Vint n). exists m1. esplits; eauto.
+      econs; eauto. eapply Mem.unchanged_on_refl. eapply Mem.unchanged_on_refl.
+      rr. ii. clarify.
+    - right. left. ii. inv H. }
+  { inv ARGS. inv H3. inv H2.
+    - left. exists f. exists (Vlong n). exists m1. esplits; eauto.
+      econs; eauto. eapply Mem.unchanged_on_refl. eapply Mem.unchanged_on_refl.
+      rr. ii. clarify.
+    - right. left. ii. inv H. }
+  inv ARGS. inv H3. inv H2; cycle 1.
+  { right. left. ii. inv H. }
+  des_ifs.
+  exploit capture_injects_backward; eauto.
+  instantiate (2:= (addr + delta)).
+  assert ((addr + delta - delta) = addr). lia.
+  rewrite H. eauto. i. des.
+  left. exists f', (if Archi.ptr64
+               then Vlong (Int64.repr (addr + delta + Ptrofs.unsigned ofs1))
+               else Vint (Int.repr (addr + delta + Ptrofs.unsigned ofs1))).
+  esplits; eauto. des_ifs. econs; eauto.
+  des_ifs.
+  assert ((Int64.repr (addr + delta + Ptrofs.unsigned ofs1)) = (Int64.repr (addr + Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta))))).
+  { apply Int64.eqm_samerepr. rewrite Zplus_assoc_reverse. eapply Int64.eqm_add. eapply Int64.eqm_refl.
+    rewrite Ptrofs.eqm64; eauto. rewrite Ptrofs.add_unsigned. eapply Ptrofs.eqm_unsigned_repr_r.
+    assert (delta + Ptrofs.unsigned ofs1 = Ptrofs.unsigned ofs1 + delta) by lia. rewrite H.
+    eapply Ptrofs.eqm_add. eapply Ptrofs.eqm_refl. eapply Ptrofs.eqm_unsigned_repr. }
+  rewrite H. econs.
+(* mem injects progress *)
+- inversion CALLSRC; subst; inv ARGS; inv H1; inv H3; cycle 1.
+  { exists [Event_pterm], Vundef. eexists.
+    red. econs 2; eauto.
+    inv OOM. split.
+    { eapply Mem.valid_block_inject_2; eauto. }
+    ii.
+    assert ((addr + delta - delta) = addr). lia.
+    exploit capture_injects_backward; eauto. erewrite H3. eauto. i. des.
+    eapply H0; eauto. }
+  { esplits. econs; eauto. }
+  { esplits. econs; eauto. }
+  inv SYMB. des.
+  exploit capture_injects_backward_progress; eauto. i. des.
+  + esplits. econs; eauto.
+  + exists [Event_pterm], Vundef. eexists.
+    red. econs 2; eauto.
+(* self-inj *)
+- inv CALLSRC; cycle 1.
+  { inv OOM. esplits; eauto.
+    - eapply Mem.unchanged_on_refl.
+    - eapply Mem.unchanged_on_refl.
+    - ii; clarify. }
+  { exists f. esplits; eauto. eapply Mem.unchanged_on_refl.
+    eapply Mem.unchanged_on_refl. ii. clarify. }
+  { exists f. esplits; eauto. eapply Mem.unchanged_on_refl.
+    eapply Mem.unchanged_on_refl. ii. clarify. }
+  inv ARGS. inv H2. exploit SELF; eauto. i. des; subst.
+  inv MEM. inversion CAPTURE.
+  exists f. esplits; eauto.
+  + des_ifs.
+  + econs.
+    * inv mi_inj. econs.
+      { unfold Mem.perm, Mem.perm_order' in *. rewrite <- ACCESS. eauto. }
+      { unfold Mem.range_perm, Mem.perm, Mem.perm_order' in *. rewrite <- ACCESS. eauto. }
+      { i. exploit SELF; eauto. i. des; subst.
+        rewrite Z.add_0_r.
+        exploit mi_memval; eauto.
+        unfold Mem.perm, Mem.perm_order' in *. rewrite ACCESS. eauto. i.
+        rewrite Z.add_0_r in H2. rewrite <- CONTENTS. eauto. }
+    * unfold Mem.valid_block in *. rewrite <- NEXTBLOCK in *. eauto.
+    * unfold Mem.valid_block in *. rewrite <- NEXTBLOCK in *. eauto.
+    * unfold Mem.meminj_no_overlap in *.
+      unfold Mem.perm, Mem.perm_order' in *. rewrite <- ACCESS. eauto.
+    * unfold Mem.perm, Mem.perm_order' in *. rewrite <- ACCESS. eauto.
+    * unfold Mem.perm, Mem.perm_order' in *. rewrite <- ACCESS. eauto.
+    * i. exploit SELF; eauto. i. des; subst. rewrite Z.sub_0_r. eauto.
+    * i.
+      destruct (peq b b0).
+      { subst. clarify. }
+      destruct (Maps.PTree.get b (Mem.mem_concrete m1)).
+      { exploit PREVADDR; eauto. i. des; subst.
+        rewrite <- H1. eauto. }
+      rewrite CAPTURED; eauto. rewrite Maps.PTree.gso; eauto.
+  + eapply Mem.capture_unchanged_on; eauto.
+  + eapply Mem.capture_unchanged_on; eauto.
+  + ii. clarify.
+- destruct (classic (exists t vres m2, extcall_capture_sem ge vargs m1 t vres m2)); cycle 1.
+  { right. left. ii. eapply H2; eauto. }
+  des. rename H2 into SAFE.
+  inv H; ss.
+  + exploit capture_concrete_extends_backward; eauto. i. des.
+    inv H1. inv H5. inv H4; cycle 1.
+    { inv SAFE. }
+    left. exists E0. esplits; eauto; try by econs.
+    econs; eauto.
+  + right. right. split.
+    { ii. eapply H. ss. auto. }
+    esplits; eauto. traceEq. eapply tr_rel_refl. eapply ev_rel_refl.
+  + inv H1. inv H5. inv H4; ss.
+    3:{ inv SAFE. }
+    * left. exists E0. esplits; eauto; try by econs.
+      eapply Mem.unchanged_on_refl.
+    * des_ifs_safe. left.
+      unfold Mem.ptr2int in Heq. des_ifs.
+      assert (Mem.capture m2' b z0 m2').
+      { econs; eauto.
+        - eapply NNPP. ii. eapply Mem.nextblocks_logical in H. clarify.
+        - i. clarify.
+        - i. clarify. }
+      exploit capture_concrete_extends; eauto. i. des.
+      exists E0. esplits; eauto; try by econs.
+      { econs; eauto. }
+      eapply Mem.unchanged_on_refl.
+(* CE progress *)
+- inv CALLSRC; ss.
+  + inv ARGS. inv H1; inv H3; ss.
+    * exploit capture_concrete_extends_backward_progress; eauto. i. des.
+      { esplits. econs; eauto. }
+      esplits. econs 2. eauto.
+    * esplits; eauto. econs. eauto.
+  + inv ARGS. inv H1; inv H3; ss.
+    { exists [Event_pterm], Vundef. eexists.
+      red. econs 2; eauto.
+      inv OOM. split.
+      { unfold Mem.valid_block in *. erewrite <- same_nextblock; eauto. }
+      ii. exploit capture_concrete_extends; eauto. i. des.
+      eapply H0. eauto. }
+    esplits. econs; eauto.
+  + inv ARGS. inv H1. inv H3. esplits; eauto. econs. eauto.
+Unshelve. all: eauto.
 Qed.
 
 (** ** Semantics of external functions. *)
@@ -1479,14 +2567,14 @@ Qed.
 Parameter external_functions_sem: String.string -> signature -> extcall_sem.
 
 Axiom external_functions_properties:
-  forall id sg, extcall_properties (external_functions_sem id sg) sg.
+  forall id sg, extcall_properties_backward (external_functions_sem id sg) sg.
 
 (** We treat inline assembly similarly. *)
 
 Parameter inline_assembly_sem: String.string -> signature -> extcall_sem.
 
 Axiom inline_assembly_properties:
-  forall id sg, extcall_properties (inline_assembly_sem id sg) sg.
+  forall id sg, extcall_properties_backward (inline_assembly_sem id sg) sg.
 
 (** ** Combined semantics of external calls *)
 
@@ -1496,15 +2584,15 @@ Definition builtin_or_external_sem name sg :=
   | None => external_functions_sem name sg
   end.
 
-Lemma builtin_or_external_sem_ok: forall name sg,
-  extcall_properties (builtin_or_external_sem name sg) sg.
-Proof.
-  unfold builtin_or_external_sem; intros. 
-  destruct (lookup_builtin_function name sg) as [bf|] eqn:L.
-- exploit lookup_builtin_function_sig; eauto. intros EQ; subst sg.
-  apply known_builtin_ok.
-- apply external_functions_properties.
-Qed.
+(* Lemma builtin_or_external_sem_ok: forall name sg, *)
+(*   extcall_properties (builtin_or_external_sem name sg) sg. *)
+(* Proof. *)
+(*   unfold builtin_or_external_sem; intros.  *)
+(*   destruct (lookup_builtin_function name sg) as [bf|] eqn:L. *)
+(* - exploit lookup_builtin_function_sig; eauto. intros EQ; subst sg. *)
+(*   apply known_builtin_ok. *)
+(* - apply external_functions_properties. *)
+(* Qed. *)
 
 (** Combining the semantics given above for the various kinds of external calls,
   we define the predicate [external_call] that relates:
@@ -1531,37 +2619,145 @@ Definition external_call (ef: external_function): extcall_sem :=
   | EF_annot_val kind txt targ => extcall_annot_val_sem txt targ
   | EF_inline_asm txt sg clb => inline_assembly_sem txt sg
   | EF_debug kind txt targs => extcall_debug_sem
+  | EF_capture => extcall_capture_sem
+  end.
+
+Definition is_external_ef (ef: external_function): Prop :=
+  match ef with
+  | EF_external name sg  => True
+  | EF_builtin name sg =>
+    match lookup_builtin_function name sg with
+    | Some bf => False
+    | None => True
+    end                    
+  | EF_runtime name sg =>
+    match lookup_builtin_function name sg with
+    | Some bf => False
+    | None => True
+    end
+  | EF_vload chunk => True
+  | EF_inline_asm txt sg clb => True
+  | EF_capture => True
+  | _ => False
+  end.
+
+Definition is_external_efb (ef: external_function): bool :=
+  match ef with
+  | EF_external name sg  => true
+  | EF_builtin name sg =>
+    match lookup_builtin_function name sg with
+    | Some bf => false
+    | None => true
+    end                    
+  | EF_runtime name sg =>
+    match lookup_builtin_function name sg with
+    | Some bf => false
+    | None => true
+    end
+  | EF_vload chunk => true
+  | EF_inline_asm txt sg clb => true
+  | EF_capture => true
+  | _ => false
   end.
 
+Lemma is_external_ef_reflect ef :
+  reflect (is_external_ef ef) (is_external_efb ef).
+Proof.
+  destruct ef; ss; des_ifs; econs; eauto.
+Qed.
+
+Section BACKWARD_EXTCALL.
+
+Variable ef: external_function.
+Hypothesis IS_EXT: is_external_ef ef.
+
+Theorem external_call_spec_backward:
+   extcall_properties_backward (external_call ef) (ef_sig ef).
+Proof.
+ intros. unfold external_call, ef_sig. destruct ef; des_ifs.
+ - apply external_functions_properties.
+ - unfold builtin_or_external_sem. ss. des_ifs.
+   apply external_functions_properties.
+ - unfold builtin_or_external_sem. ss. des_ifs.
+   apply external_functions_properties.
+ - apply volatile_load_ok.
+ - apply inline_assembly_properties.
+ - apply extcall_capture_ok.
+Qed.
+
+Definition external_call_mem_extends_backward := ec_mem_extends_backward (external_call_spec_backward).
+Definition external_call_mem_extends_backward_progress := ec_mem_extends_backward_progress (external_call_spec_backward).
+Definition external_call_mem_inject_gen_backward := ec_mem_inject_backward (external_call_spec_backward).
+Definition external_call_mem_inject_gen_backward_progress := ec_mem_inject_backward_progress (external_call_spec_backward).
+
+End BACKWARD_EXTCALL.
+
+Section FORWARD_EXTCALL.
+
+Variable ef: external_function.
+Hypothesis NOT_EXT: ~ is_external_ef ef.
+
 Theorem external_call_spec:
-  forall ef,
   extcall_properties (external_call ef) (ef_sig ef).
 Proof.
-  intros. unfold external_call, ef_sig; destruct ef.
-  apply external_functions_properties.
-  apply builtin_or_external_sem_ok.
-  apply builtin_or_external_sem_ok.
-  apply volatile_load_ok.
+  intros. unfold external_call, ef_sig; destruct ef; ss.
+  unfold builtin_or_external_sem. des_ifs.
+  exploit lookup_builtin_function_sig; eauto. intros EQ; subst sg.
+  eapply known_builtin_ok.
+  unfold builtin_or_external_sem. des_ifs.
+  exploit lookup_builtin_function_sig; eauto. intros EQ; subst sg.
+  eapply known_builtin_ok.
+  (* apply volatile_load_ok. *)
   apply volatile_store_ok.
   apply extcall_malloc_ok.
   apply extcall_free_ok.
   apply extcall_memcpy_ok.
   apply extcall_annot_ok.
   apply extcall_annot_val_ok.
-  apply inline_assembly_properties.
   apply extcall_debug_ok.
 Qed.
 
-Definition external_call_well_typed_gen ef := ec_well_typed (external_call_spec ef).
-Definition external_call_symbols_preserved ef := ec_symbols_preserved (external_call_spec ef).
-Definition external_call_valid_block ef := ec_valid_block (external_call_spec ef).
-Definition external_call_max_perm ef := ec_max_perm (external_call_spec ef).
-Definition external_call_readonly ef := ec_readonly (external_call_spec ef).
-Definition external_call_mem_extends ef := ec_mem_extends (external_call_spec ef).
-Definition external_call_mem_inject_gen ef := ec_mem_inject (external_call_spec ef).
-Definition external_call_trace_length ef := ec_trace_length (external_call_spec ef).
-Definition external_call_receptive ef := ec_receptive (external_call_spec ef).
-Definition external_call_determ ef := ec_determ (external_call_spec ef).
+Definition external_call_mem_extends := ec_mem_extends (external_call_spec).
+Definition external_call_mem_inject_gen := ec_mem_inject (external_call_spec).
+Definition external_call_receptive := ec_receptive (external_call_spec).
+Definition external_call_determ := ec_determ (external_call_spec).
+
+End FORWARD_EXTCALL.
+
+Theorem external_call_common_spec:
+   forall ef,
+   extcall_properties_common (external_call ef) (ef_sig ef).
+Proof.
+ intros. unfold external_call, ef_sig; destruct ef.
+ apply external_functions_properties.
+ unfold builtin_or_external_sem. des_ifs.
+ exploit lookup_builtin_function_sig; eauto. intros EQ; subst sg.
+ eapply known_builtin_ok. 
+ apply external_functions_properties.
+ unfold builtin_or_external_sem. des_ifs.
+ exploit lookup_builtin_function_sig; eauto. intros EQ; subst sg.
+ eapply known_builtin_ok.
+ apply external_functions_properties.
+ apply volatile_load_ok.
+ apply volatile_store_ok.
+ apply extcall_malloc_ok.
+ apply extcall_free_ok.
+ apply extcall_memcpy_ok.
+ apply extcall_annot_ok.
+ apply extcall_annot_val_ok.
+ apply inline_assembly_properties.
+ apply extcall_debug_ok.
+ apply extcall_capture_ok.
+Qed.
+
+Definition external_call_well_typed_gen ef := ec_well_typed (external_call_common_spec ef).
+Definition external_call_symbols_preserved ef := ec_symbols_preserved (external_call_common_spec ef).
+Definition external_call_valid_block ef := ec_valid_block (external_call_common_spec ef).
+Definition external_call_max_perm ef := ec_max_perm (external_call_common_spec ef).
+Definition external_call_readonly ef := ec_readonly (external_call_common_spec ef).
+(* Definition external_call_trace_length ef := ec_trace_length (external_call_common_spec ef). *)
+
+Definition determ_properties (ef: external_function) := extcall_properties (external_call ef) (ef_sig ef).
 
 (** Corollary of [external_call_well_typed_gen]. *)
 
@@ -1593,8 +2789,81 @@ Definition meminj_preserves_globals (F V: Type) (ge: Genv.t F V) (f: block -> op
   /\ (forall b gv, Genv.find_var_info ge b = Some gv -> f b = Some(b, 0))
   /\ (forall b1 b2 delta gv, Genv.find_var_info ge b2 = Some gv -> f b1 = Some(b2, delta) -> b2 = b1).
 
+Lemma meminj_preserves_globals_to_symbols_inject
+    F V (ge: Genv.t F V) f
+    (GENV : meminj_preserves_globals ge f) :
+  symbols_inject f ge ge.
+Proof.
+  destruct GENV as (A & B & C).
+  repeat split; intros.
+  + simpl in H0. exploit A; eauto. intros EQ; rewrite EQ in H; inv H. auto.
+  + simpl in H0. exploit A; eauto. intros EQ; rewrite EQ in H; inv H. auto.
+  + simpl in H0. exists b1; split; eauto.
+  + simpl; unfold Genv.block_is_volatile.
+    destruct (Genv.find_var_info ge b1) as [gv1|] eqn:V1.
+    * exploit B; eauto. intros EQ; rewrite EQ in H; inv H. rewrite V1; auto.
+    * destruct (Genv.find_var_info ge b2) as [gv2|] eqn:V2; auto.
+      exploit C; eauto. intros EQ; subst b2. congruence.
+Qed.
+
+Lemma external_call_mem_inject_backward:
+  forall ef F V (ge: Genv.t F V) vargs' m1' t vres' m2' f m1 vargs,
+  is_external_ef ef ->
+  meminj_preserves_globals ge f ->
+  external_call ef ge vargs' m1' t vres' m2' ->
+  Mem.inject f m1 m1' ->
+  Val.inject_list f vargs vargs' ->
+  (exists f', exists vres, exists m2,
+     external_call ef ge vargs m1 t vres m2
+    /\ Val.inject f' vres vres'
+    /\ Mem.inject f' m2 m2'
+    /\ Mem.unchanged_on (loc_unmapped f) m1 m2
+    /\ Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'
+    /\ inject_incr f f'
+    /\ inject_separated f f' m1 m1')
+  \/ (forall t' vres m2, ~ external_call ef ge vargs m1 t' vres m2)
+  \/ ((~ trace_intact t) /\
+     exists t' vres1 m21, external_call ef ge vargs m1 t' vres1 m21 /\
+                     (exists tl, t' = (trace_cut_pterm t) ** tl)).
+Proof.
+  intros until vargs. intros EXT GENV TGTCALL MEM ARGS.
+  destruct GENV as (A & B & C). exploit external_call_mem_inject_gen_backward; eauto.
+  repeat split; intros.
+  + simpl in H0. exploit A; eauto. intros EQ; rewrite EQ in H; inv H. auto.
+  + simpl in H0. exploit A; eauto. intros EQ; rewrite EQ in H; inv H. auto.
+  + simpl in H0. exists b1; split; eauto.
+  + simpl; unfold Genv.block_is_volatile.
+    destruct (Genv.find_var_info ge b1) as [gv1|] eqn:V1.
+    * exploit B; eauto. intros EQ; rewrite EQ in H; inv H. rewrite V1; auto.
+    * destruct (Genv.find_var_info ge b2) as [gv2|] eqn:V2; auto.
+      exploit C; eauto. intros EQ; subst b2. congruence.
+Qed.
+
+Lemma external_call_mem_inject_backward_progress:
+    forall ef F V (ge: Genv.t F V) vargs' m1' t vres m2 f m1 vargs,
+    is_external_ef ef ->
+    meminj_preserves_globals ge f ->
+    external_call ef ge vargs m1 t vres m2 ->
+    Mem.inject f m1 m1' ->
+    Val.inject_list f vargs vargs' ->
+    exists t' vres' m2',
+      external_call ef ge vargs' m1' t' vres' m2'.
+Proof.
+  intros until vargs. intros EXT GENV SRCCALL MEM ARGS.
+  destruct GENV as (A & B & C). eapply external_call_mem_inject_gen_backward_progress with (ge1:= ge); eauto. 
+  repeat split; intros.
+  + simpl in H0. exploit A; eauto. intros EQ; rewrite EQ in H; inv H. auto.
+  + simpl in H0. exploit A; eauto. intros EQ; rewrite EQ in H; inv H. auto.
+  + simpl in H0. exists b1; split; eauto.
+  + simpl; unfold Genv.block_is_volatile.
+    destruct (Genv.find_var_info ge b1) as [gv1|] eqn:V1.
+    * exploit B; eauto. intros EQ; rewrite EQ in H; inv H. rewrite V1; auto.
+    * destruct (Genv.find_var_info ge b2) as [gv2|] eqn:V2; auto.
+      exploit C; eauto. intros EQ; subst b2. congruence.
+Qed.
+
 Lemma external_call_mem_inject:
-  forall ef F V (ge: Genv.t F V) vargs m1 t vres m2 f m1' vargs',
+  forall ef F V (ge: Genv.t F V) vargs m1 t vres m2 f m1' vargs' (DETERM: determ_properties ef),
   meminj_preserves_globals ge f ->
   external_call ef ge vargs m1 t vres m2 ->
   Mem.inject f m1 m1' ->
@@ -1608,7 +2877,7 @@ Lemma external_call_mem_inject:
     /\ inject_incr f f'
     /\ inject_separated f f' m1 m1'.
 Proof.
-  intros. destruct H as (A & B & C). eapply external_call_mem_inject_gen with (ge1 := ge); eauto.
+  intros. destruct H as (A & B & C). eapply ec_mem_inject with (ge1 := ge); eauto.
   repeat split; intros.
   + simpl in H3. exploit A; eauto. intros EQ; rewrite EQ in H; inv H. auto.
   + simpl in H3. exploit A; eauto. intros EQ; rewrite EQ in H; inv H. auto.
@@ -1623,23 +2892,30 @@ Qed.
 (** Corollaries of [external_call_determ]. *)
 
 Lemma external_call_match_traces:
-  forall ef ge vargs m t1 vres1 m1 t2 vres2 m2,
+  forall ef ge vargs m t1 vres1 m1 t2 vres2 m2 (INT: ~ is_external_ef ef),
   external_call ef ge vargs m t1 vres1 m1 ->
   external_call ef ge vargs m t2 vres2 m2 ->
-  match_traces ge t1 t2.
+  t1 = t2.
 Proof.
-  intros. exploit external_call_determ. eexact H. eexact H0. tauto.
+  intros. exploit external_call_determ. eauto. eexact H. eexact H0. tauto.
 Qed.
 
 Lemma external_call_deterministic:
-  forall ef ge vargs m t vres1 m1 vres2 m2,
+  forall ef ge vargs m t vres1 m1 vres2 m2 (INT: ~ is_external_ef ef),
   external_call ef ge vargs m t vres1 m1 ->
   external_call ef ge vargs m t vres2 m2 ->
   vres1 = vres2 /\ m1 = m2.
 Proof.
-  intros. exploit external_call_determ. eexact H. eexact H0. intuition.
+  intros. exploit external_call_determ. eauto. eexact H. eexact H0. intuition.
 Qed.
 
+Lemma external_call_trace_length
+    ef ge vargs m t vres m1
+    (INT: ~ is_external_ef ef)
+    (EC: external_call ef ge vargs m t vres m1):
+  (length t <= 1)%nat.
+Proof. i. eapply external_call_spec in INT. inv INT. eauto. Qed.
+
 (** * Evaluation of builtin arguments *)
 
 Section EVAL_BUILTIN_ARG.
@@ -1779,3 +3055,84 @@ Qed.
 
 End EVAL_BUILTIN_ARG_LESSDEF.
 
+Section ExtcallPropImply.
+
+(** Extcall properties : relaxed *)
+
+Lemma forwrard_axiom_implies_backward_axiom
+    sem sg
+    (FORWARD: extcall_properties sem sg) :
+  extcall_properties_backward sem sg.
+Proof.
+  econstructor; inv FORWARD; eauto; i.
+  - destruct (classic (exists t' vres m2, sem ge vargs m1 t' vres m2)); cycle 1.
+    { right. left. red. ii. eapply H; eauto. }
+    destruct H as [t' [vres [m2 H]]].
+    left. exploit ec_mem_extends0; eauto. i. des.
+    exploit ec_determ0. eapply H0. eapply CALLTGT. intros (TRC & TRC').
+    des; subst. esplits; eauto.
+  - exploit ec_mem_extends0; eauto. i. des; eauto.
+  - destruct (classic (exists t' vres m2, sem ge1 vargs m1 t' vres m2)); cycle 1.
+    { right. left. ii. eapply H; eauto. }
+    destruct H as [t' [vres [m2 H]]]. left. exploit ec_mem_inject0; eauto.
+    i. des. exploit ec_determ0. eapply H0. eapply CALLTGT. intros (TRC & TRC').
+    des; subst. esplits; eauto.
+  - intros. exploit ec_mem_inject0; eauto. i. des; eauto.
+  - intros. exploit ec_mem_inject0; eauto. i. des.
+    exploit ec_determ0. eapply CALLSRC. eauto. intros. des; subst.
+    esplits; eauto.
+  - destruct (classic (exists t' vres m2, sem ge vargs m1 t' vres m2)); cycle 1.
+    { right. left. ii. eapply H2; eauto. }
+    destruct H2 as [t [vres [m2 H2]]].
+    left. exploit ec_mem_concrete_extends0; eauto. i. des.
+    exploit ec_determ0. eapply H4. eapply H. i; des; subst. esplits; eauto.
+  - i. exploit ec_mem_concrete_extends0; eauto. i. des; eauto.
+Qed.
+
+End ExtcallPropImply.
+
+Lemma ge_binded_store ge m gm chunk b ofs v m'
+    (BIND: ge_binded ge m gm)
+    (STORE: Mem.store chunk m b ofs v = Some m'):
+  ge_binded ge m' gm.
+Proof.
+  unfold ge_binded in *. i. exploit BIND; eauto. i. des.
+  split; eauto. rewrite <- H1. erewrite <-Mem.concrete_store; eauto.
+Qed.
+
+Lemma ge_binded_alloc ge m gm lo hi m' v
+    (BIND: ge_binded ge m gm)
+    (ALLOC: Mem.alloc m lo hi = (m', v)):
+  ge_binded ge m' gm.
+Proof.
+  unfold ge_binded in *. i. exploit BIND; eauto. i. des.
+  split; eauto. rewrite <- H1. erewrite <-Mem.concrete_alloc; eauto.
+Qed.
+
+Lemma ge_binded_free ge m gm v lo hi m'
+    (BIND: ge_binded ge m gm)
+    (FREE: Mem.free m v lo hi = Some m'):
+  ge_binded ge m' gm.
+Proof.
+  unfold ge_binded in *. i. exploit BIND; eauto. i. des.
+  split; eauto. rewrite <- H1. erewrite <-Mem.concrete_free; eauto.
+Qed.
+
+Lemma ge_binded_external_call ge m gm ef vargs t vres m'
+    (BIND: ge_binded ge m gm)
+    (EXT: external_call ef ge vargs m t vres m'):
+  ge_binded ge m' gm.
+Proof.
+  unfold ge_binded in *. i. exploit BIND; eauto. i. des.
+  split; eauto. rewrite H2 in *. eapply ec_binds; eauto. eapply external_call_common_spec.
+Qed.
+
+Lemma ge_binded_senv_equiv ge tge m gm
+    (SEQ: Senv.equiv ge tge):
+  ge_binded ge m gm <-> ge_binded tge m gm.
+Proof.
+  inv SEQ. inv H0. split; ii.
+  - eapply H0; eauto. rewrite <- H; eauto.
+  - eapply H0; eauto. rewrite H; eauto.
+Qed.
+
diff --git a/common/ExtCallAxiomRlx.v b/common/ExtCallAxiomRlx.v
new file mode 100644
index 00000000..94d32a48
--- /dev/null
+++ b/common/ExtCallAxiomRlx.v
@@ -0,0 +1,237 @@
+Require Import String.
+Require Import Coqlib.
+Require Intv.
+Require Import AST.
+Require Import Integers.
+Require Import Floats.
+Require Import Values.
+Require Import Memory.
+Require Import Globalenvs.
+Require Import Builtins.
+Require Import IntPtrRel.
+Require Import sflib.
+Require Import Classical.
+Require Import Events.
+
+Section RLX.
+
+Record extcall_properties_common_old (sem: extcall_sem) (sg: signature) : Prop :=
+  mk_extcall_properties_common_old {
+  
+(** The return value of an external call must agree with its signature. *)
+  ec_well_typed_old:
+    forall ge vargs m1 t vres m2,
+    sem ge vargs m1 t vres m2 ->
+    Val.has_rettype vres sg.(sig_res);
+
+(** The semantics is invariant under change of global environment that preserves symbols. *)
+  ec_symbols_preserved_old:
+    forall ge1 ge2 vargs m1 t vres m2,
+    Senv.equiv ge1 ge2 ->
+    sem ge1 vargs m1 t vres m2 ->
+    sem ge2 vargs m1 t vres m2;
+
+(** External calls cannot invalidate memory blocks.  (Remember that
+  freeing a block does not invalidate its block identifier.) *)
+  ec_valid_block_old:
+    forall ge vargs m1 t vres m2 b,
+    sem ge vargs m1 t vres m2 ->
+    Mem.valid_block m1 b -> Mem.valid_block m2 b;
+
+(** External calls cannot increase the max permissions of a valid block.
+    They can decrease the max permissions, e.g. by freeing. *)
+  ec_max_perm_old:
+    forall ge vargs m1 t vres m2 b ofs p,
+    sem ge vargs m1 t vres m2 ->
+    Mem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p;
+
+(** External call cannot modify memory unless they have [Max, Writable]
+   permissions. *)
+  ec_readonly_old:
+    forall ge vargs m1 t vres m2 b ofs n bytes,
+    sem ge vargs m1 t vres m2 ->
+    Mem.valid_block m1 b ->
+    Mem.loadbytes m2 b ofs n = Some bytes ->
+    (forall i, ofs <= i < ofs + n -> ~Mem.perm m1 b i Max Writable) ->
+    Mem.loadbytes m1 b ofs n = Some bytes;
+}.
+
+(* old forward version of extcall properties *)
+Record extcall_properties_old (sem: extcall_sem) (sg: signature) : Prop :=
+  mk_extcall_properties_old {
+
+  ec_properties_old_common:
+    extcall_properties_common_old sem sg;
+
+(** External calls produce at most one event. *)
+  ec_trace_length_old:
+    forall ge vargs m t vres m',
+    sem ge vargs m t vres m' -> (length t <= 1)%nat;
+      
+(** External calls must commute with memory extensions, in the
+  following sense. *)
+  ec_mem_extends_old:
+    forall ge vargs m1 t vres m2 m1' vargs',
+    sem ge vargs m1 t vres m2 ->
+    Mem.extends m1 m1' ->
+    Val.lessdef_list vargs vargs' ->
+    exists vres', exists m2',
+       sem ge vargs' m1' t vres' m2'
+    /\ Val.lessdef vres vres'
+    /\ Mem.extends m2 m2'
+    /\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2';
+
+(** External calls must commute with memory injections,
+  in the following sense. *)
+  ec_mem_inject_old:
+    forall ge1 ge2 vargs m1 t vres m2 f m1' vargs',
+    symbols_inject f ge1 ge2 ->
+    sem ge1 vargs m1 t vres m2 ->
+    Mem.inject f m1 m1' ->
+    Val.inject_list f vargs vargs' ->
+    exists f', exists vres', exists m2',
+       sem ge2 vargs' m1' t vres' m2'
+    /\ Val.inject f' vres vres'
+    /\ Mem.inject f' m2 m2'
+    /\ Mem.unchanged_on (loc_unmapped f) m1 m2
+    /\ Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'
+    /\ inject_incr f f'
+    /\ inject_separated f f' m1 m1';
+
+(** External calls must be receptive to changes of traces by another, matching trace. *)
+  ec_receptive_old:
+    forall ge vargs m t1 vres1 m1 t2,
+    sem ge vargs m t1 vres1 m1 -> match_traces ge t1 t2 ->
+    exists vres2, exists m2, sem ge vargs m t2 vres2 m2;
+
+(** External calls must be deterministic up to matching between traces. *)
+  ec_determ_old:
+    forall ge vargs m t1 vres1 m1 t2 vres2 m2,
+    sem ge vargs m t1 vres1 m1 -> sem ge vargs m t2 vres2 m2 ->
+    match_traces ge t1 t2 /\ (t1 = t2 -> vres1 = vres2 /\ m1 = m2);
+}.
+
+(* backward version of extcall properties: *)
+(* Its subset of our axiom. *the first two changes* of external call axiom in 4.1.2 *)
+Record extcall_properties_backward_sim (sem: extcall_sem) (sg: signature) : Prop :=
+  mk_extcall_properties_backward_sim {
+
+  ec_properties_backward_common_sim:
+    extcall_properties_common_old sem sg;
+
+(** External calls must commute with memory extensions, in the
+  following sense. *)
+  ec_mem_extends_backward_sim
+    ge vargs m1 t vres' m2' m1' vargs'
+    (CALLTGT: sem ge vargs' m1' t vres' m2')
+    (MEM: Mem.extends m1 m1')
+    (ARGS: Val.lessdef_list vargs vargs') :
+    (exists vres m2,
+      <<CALLSRC: sem ge vargs m1 t vres m2>>
+    /\ <<RETV: Val.lessdef vres vres'>>
+    /\ <<MEM: Mem.extends m2 m2'>>
+    /\ <<PRIV: Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'>>)
+    \/ <<UBSRC: (forall t' vres m2, ~ sem ge vargs m1 t' vres m2)>>
+    \/ (<<PTERM: ~trace_intact t >> /\
+       exists t' vres1 m21, <<CALLSRC: sem ge vargs m1 t' vres1 m21>> /\
+                       <<SUB: exists tl, t' = (trace_cut_pterm t) ** tl>>);
+
+  ec_mem_extends_backward_progress_sim
+    ge vargs m1 t vres m2 m1' vargs'
+    (CALLSRC: sem ge vargs m1 t vres m2)
+    (MEM: Mem.extends m1 m1')
+    (ARGS: Val.lessdef_list vargs vargs') :
+    (exists t' vres' m2',
+      <<CALLTGT: sem ge vargs' m1' t' vres' m2'>>);
+
+(** External calls must commute with memory injections,
+  in the following sense. *)
+  ec_mem_inject_backward_sim
+    ge1 ge2 vargs m1 t vres' m2' f m1' vargs'
+    (SYMB: symbols_inject f ge1 ge2)
+    (CALLTGT: sem ge2 vargs' m1' t vres' m2')
+    (MEM: Mem.inject f m1 m1')
+    (ARGS: Val.inject_list f vargs vargs') :
+    (exists f' vres m2,
+      <<CALLSRC: sem ge1 vargs m1 t vres m2>>
+    /\ <<RETV: Val.inject f' vres vres'>>
+    /\ <<MEM: Mem.inject f' m2 m2'>>
+    /\ <<MEMPRIVSRC: Mem.unchanged_on (loc_unmapped f) m1 m2>>
+    /\ <<MEMPRIVTGT: Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'>>
+    /\ <<INJINCR: inject_incr f f'>>
+    /\ <<INJSEP: inject_separated f f' m1 m1'>>)
+    \/ <<UBSRC: (forall t' vres m2, ~ sem ge1 vargs m1 t' vres m2)>>
+    \/ (<<PTERM: ~trace_intact t >> /\
+       exists t' vres1 m21, <<CALLSRC: sem ge1 vargs m1 t' vres1 m21>> /\
+                       <<SUB: exists tl, t' = (trace_cut_pterm t) ** tl>>);
+
+  ec_mem_inject_backward_progress_sim
+    ge1 ge2 vargs m1 t vres m2 f m1' vargs'
+    (SYMB: symbols_inject f ge1 ge2)
+    (CALLSRC: sem ge1 vargs m1 t vres m2)
+    (MEM: Mem.inject f m1 m1')
+    (ARGS: Val.inject_list f vargs vargs') :
+    (exists t'' vres' m2',
+      <<CALLTGT: sem ge2 vargs' m1' t'' vres' m2'>>);
+
+  ec_sound_sim
+    ge vargs m1 m2 t vres f
+    (SELF: self_inj f)
+    (SYMB: symbols_inject f ge ge)
+    (CALLSRC: sem ge vargs m1 t vres m2)
+    (MEM: Mem.inject f m1 m1)
+    (ARGS: Val.inject_list f vargs vargs) :
+    (exists f',
+      <<RETV: Val.inject f' vres vres>>
+    /\ <<MEM: Mem.inject f' m2 m2>>
+    /\ <<MEMPRIVSRC: Mem.unchanged_on (loc_unmapped f) m1 m2>>
+    /\ <<MEMPRIVTGT: Mem.unchanged_on (loc_out_of_reach f m1) m1 m2>>
+    /\ <<INJINCR: inject_incr f f'>>
+    /\ <<INJSEP: inject_separated f f' m1 m1>>);
+}.
+
+Lemma forwrard_axiom_implies_backward_axiom_sim
+      sem sg
+      (FORWARD: extcall_properties_old sem sg) :
+  extcall_properties_backward_sim sem sg.
+Proof.
+  econstructor; inv FORWARD; eauto.
+  - intros.
+    destruct (classic (exists t' vres m2, sem ge vargs m1 t' vres m2)); cycle 1.
+    { right. left. red. ii. eapply H; eauto. }
+    destruct H as [t' [vres [m2 H]]].
+    left. exploit ec_mem_extends_old0; eauto. intros (vres'0 & m2'0 & SEM & VAL & MEXT & NOCHANGE).
+    exploit ec_determ_old0. eapply SEM. eapply CALLTGT. intros (TRC & TRC').
+    exploit ec_receptive_old0. eapply H. eauto. intros (vres2 & m3 & SEM').
+    exploit ec_mem_extends_old0. eapply SEM'. eauto. eauto.
+    intros (vres'1 & m2'1 & SEM'' & VAL' & MEXT' & NOCHANGE').
+    exploit ec_determ_old0. eapply CALLTGT. eauto. intros (TRC1 & TRC1').
+    exploit TRC1'; eauto. intros [A B]. subst.
+    do 2 eexists. repeat (split; eauto).
+  - intros. exploit ec_mem_extends_old0; eauto. intros (vres' & m2' & A & B & C & D).
+    do 3 eexists. eauto.
+  - intros.
+    destruct (classic (exists t' vres m2, sem ge1 vargs m1 t' vres m2)); cycle 1.
+    { right. left. ii. eapply H; eauto. }
+    destruct H as [t' [vres [m2 H]]].
+    left. exploit ec_mem_inject_old0; eauto.
+    intros (f' & vres'0 & m2'0 & SEM & VAL & MEXT & NOCHANGE).
+    exploit ec_determ_old0. eapply SEM. eapply CALLTGT. intros (TRC & TRC').
+    exploit ec_receptive_old0. eapply H. eapply match_traces_preserved.
+    instantiate (1:=ge2). unfold symbols_inject in *. inv SYMB. eauto. eauto.
+    intros (vres2 & m3 & SEM').
+    exploit ec_mem_inject_old0; eauto.
+    intros (f'0 & vres'1 & m2'1 & SEM1 & VAL1 & MEXT1 & NOCHANGE1).
+    exploit ec_determ_old0. eapply CALLTGT. eauto. intros (TRC1 & TRC1').
+    exploit TRC1'; eauto. intros [A B]. subst.
+    do 3 eexists. repeat (split; eauto).
+  - intros. exploit ec_mem_inject_old0; eauto.
+    intros (f' & vres' & m2' & A & B). eauto.
+  - intros. exploit ec_mem_inject_old0; eauto.
+    intros (f' & vres' & m2' & A & B & C & D & E & F & G).
+    exploit ec_determ_old0. eapply CALLSRC. eauto. intros. inv H.
+    exploit H1; eauto. intros [A' B']. subst.
+    eexists. repeat (split; eauto).
+Qed.
+
+End RLX.
diff --git a/common/Globalenvs.v b/common/Globalenvs.v
index 4c9e7889..16f5fd53 100644
--- a/common/Globalenvs.v
+++ b/common/Globalenvs.v
@@ -38,6 +38,8 @@ Require Import Recdef.
 Require Import Zwf.
 Require Import Axioms Coqlib Errors Maps AST Linking.
 Require Import Integers Floats Values Memory.
+Require Import sflib.
+Require Import RelationClasses.
 
 Notation "s #1" := (fst s) (at level 9, format "s '#1'") : pair_scope.
 Notation "s #2" := (snd s) (at level 9, format "s '#2'") : pair_scope.
@@ -132,6 +134,12 @@ Definition equiv (se1 se2: t) : Prop :=
   /\ (forall id, public_symbol se2 id = public_symbol se1 id)
   /\ (forall b, block_is_volatile se2 b = block_is_volatile se1 b).
 
+Global Program Instance equiv_sym: Symmetric equiv.
+Next Obligation. inv H. des. econs; eauto. Qed.
+
+Global Program Instance equiv_refl: Reflexive equiv.
+Next Obligation. econs; eauto. Qed.
+
 End Senv.
 
 Module Genv.
@@ -686,6 +694,44 @@ Fixpoint alloc_globals (m: mem) (gl: list (ident * globdef F V))
       end
   end.
 
+(* ids = ge.genv_public *)
+(* non static glob. capture this blocks after initialization *)
+Fixpoint non_static_glob (ids: list ident) : list block :=
+  match ids with
+  | [] => []
+  | id :: ids => if public_symbol ge id
+               then (match find_symbol ge id with
+                     | Some b => b::(non_static_glob ids)
+                     | _ => non_static_glob ids
+                     end)
+               else non_static_glob ids
+  end.
+
+(* every blocks of find_symbols are valid block in initial memory *)
+Inductive capture_init_mem (m: mem) (blks: list block) : mem -> Prop :=
+  | capture_init_mem_intro
+      addrs m'
+      (CAP: Mem.capture_list m blks addrs m'):
+    capture_init_mem m blks m'.
+
+
+(* Senv.public_symbol ge id = true -> *)
+(* Senv.find_symbol ge id = Some b -> *)
+
+(* Definition init_mem (p: program F V) := *)
+(*   alloc_globals (globalenv p) Mem.empty p.(prog_defs). *)
+
+(* Record t: Type := mkgenv { *)
+(*   genv_public: list ident;              (**r which symbol names are public *) *)
+(*   genv_symb: PTree.t block;             (**r mapping symbol -> block *) *)
+(*   genv_defs: PTree.t (globdef F V);     (**r mapping block -> definition *) *)
+(*   genv_next: block;                     (**r next symbol pointer *) *)
+(*   genv_symb_range: forall id b, PTree.get id genv_symb = Some b -> Plt b genv_next; *)
+(*   genv_defs_range: forall b g, PTree.get b genv_defs = Some g -> Plt b genv_next; *)
+(*   genv_vars_inj: forall id1 id2 b, *)
+(*     PTree.get id1 genv_symb = Some b -> PTree.get id2 genv_symb = Some b -> id1 = id2 *)
+(* }. *)
+          
 Lemma alloc_globals_app : forall gl1 gl2 m m1,
   alloc_globals m gl1 = Some m1 ->
   alloc_globals m1 gl2 = alloc_globals m (gl1 ++ gl2).
@@ -834,7 +880,7 @@ Proof.
   induction gl.
   simpl; intros. inv H. tauto.
   simpl; intros. destruct (alloc_global m a) as [m1|] eqn:?; try discriminate.
-  erewrite alloc_global_perm; eauto. eapply IHgl; eauto.
+  exploit alloc_global_perm; eauto. intros. erewrite H1. eapply IHgl; eauto.
   unfold Mem.valid_block in *. erewrite alloc_global_nextblock; eauto.
   apply Plt_trans_succ; auto.
 Qed.
@@ -855,6 +901,15 @@ Proof.
 - discriminate.
 Qed.
 
+Lemma store_zeros_same_conc
+  m b p n m'
+  (STORE: store_zeros m b p n = Some m'):
+  <<CONC: m.(Mem.mem_concrete) = m'.(Mem.mem_concrete)>>.
+Proof.
+  functional induction (store_zeros m b p n); intros; try by (inv STORE; ss).
+  eapply Mem.concrete_store in e0. rewrite e0. eauto.
+Qed.
+
 Remark store_init_data_unchanged:
   forall (P: block -> Z -> Prop) b i m p m',
   store_init_data m b p i = Some m' ->
@@ -997,21 +1052,23 @@ Definition read_as_zero (m: mem) (b: block) (ofs len: Z) : Prop :=
   (align_chunk chunk | p) ->
   Mem.load chunk m b p =
   Some (match chunk with
-        | Mint8unsigned | Mint8signed | Mint16unsigned | Mint16signed | Mint32 => Vint Int.zero
-        | Mint64 => Vlong Int64.zero
+        | Mint8unsigned | Mint8signed | Mint16unsigned | Mint16signed | Mint32 | Many32 => Vint Int.zero
+        | Mint64 | Many64 => Vlong Int64.zero
         | Mfloat32 => Vsingle Float32.zero
         | Mfloat64 => Vfloat Float.zero
-        | Many32 | Many64 => Vundef
+        (* | Many32 => if negb Archi.ptr64 then Vint Int.zero else Vundef *)
+        (* | Many64 => if Archi.ptr64 then Vlong Int64.zero else Vundef *)
         end).
 
 Remark read_as_zero_unchanged:
-  forall (P: block -> Z -> Prop) m b ofs len m',
+  forall (P: block -> Z -> Prop) m b ofs len m'
+  (CONC: m.(Mem.mem_concrete) = m'.(Mem.mem_concrete)),
   read_as_zero m b ofs len ->
   Mem.unchanged_on P m m' ->
   (forall i, ofs <= i < ofs + len -> P b i) ->
   read_as_zero m' b ofs len.
 Proof.
-  intros; red; intros. eapply Mem.load_unchanged_on; eauto.
+  intros; red; intros. eapply Mem.load_unchanged_on_concrete; eauto.
   intros; apply H1. lia.
 Qed.
 
@@ -1021,10 +1078,10 @@ Lemma store_zeros_read_as_zero:
   read_as_zero m' b p n.
 Proof.
   intros; red; intros.
-  transitivity (Some(decode_val chunk (List.repeat (Byte Byte.zero) (size_chunk_nat chunk)))).
+  transitivity (Some(decode_val chunk (Mem.normalize_mvs chunk m' (List.repeat (Byte Byte.zero) (size_chunk_nat chunk))))).
   apply Mem.loadbytes_load; auto. rewrite size_chunk_conv.
   eapply store_zeros_loadbytes; eauto. rewrite <- size_chunk_conv; auto.
-  f_equal. destruct chunk; unfold decode_val; unfold decode_int; unfold rev_if_be; destruct Archi.big_endian; reflexivity.
+  f_equal. destruct chunk; unfold decode_val; unfold decode_int; unfold rev_if_be; destruct Archi.big_endian; try reflexivity.
 Qed.
 
 Fixpoint load_store_init_data (m: mem) (b: block) (p: Z) (il: list init_data) {struct il} : Prop :=
@@ -1056,6 +1113,26 @@ Fixpoint load_store_init_data (m: mem) (b: block) (p: Z) (il: list init_data) {s
       /\ load_store_init_data m b (p + Z.max n 0) il'
   end.
 
+Lemma store_init_data_same_conc
+  m b p id m'
+  (STORE: store_init_data m b p id = Some m'):
+  <<CONC: m.(Mem.mem_concrete) = m'.(Mem.mem_concrete)>>.
+Proof.
+  destruct id; ss; try by (eapply Mem.concrete_store; eauto).
+  inv STORE; eauto. des_ifs. eapply Mem.concrete_store; eauto.
+Qed.
+
+Lemma store_init_data_list_same_conc
+  m b p il m'
+  (STORE: store_init_data_list m b p il = Some m'):
+  <<CONC: m.(Mem.mem_concrete) = m'.(Mem.mem_concrete)>>.
+Proof.
+  ginduction il; ss; ii.
+  { inv STORE. ss. }
+  des_ifs. exploit IHil; eauto. i. eapply store_init_data_same_conc in Heq.
+  rewrite Heq. auto.
+Qed.
+
 Lemma store_init_data_list_charact:
   forall b il m p m',
   store_init_data_list m b p il = Some m' ->
@@ -1068,7 +1145,8 @@ Proof.
     Mem.load chunk m' b p = Some(Val.load_result chunk v)).
   {
     intros.
-    eapply Mem.load_unchanged_on with (P := fun b' ofs' => ofs' < p + size_chunk chunk).
+    eapply Mem.load_unchanged_on_concrete with (P := fun b' ofs' => ofs' < p + size_chunk chunk).
+    eapply store_init_data_list_same_conc; eauto.
     eapply store_init_data_list_unchanged; eauto. intros; lia.
     intros; tauto.
     eapply Mem.load_store_same; eauto.
@@ -1079,6 +1157,7 @@ Proof.
   exploit IHil; eauto.
   set (P := fun (b': block) ofs' => p + init_data_size a <= ofs').
   apply read_as_zero_unchanged with (m := m) (P := P).
+  { eapply store_init_data_same_conc; eauto. }
   red; intros; apply H0; auto. generalize (init_data_size_pos a); lia. lia.
   eapply store_init_data_unchanged with (P := P); eauto.
   intros; unfold P. lia.
@@ -1094,6 +1173,7 @@ Proof.
 + split; auto.
   set (P := fun (b': block) ofs' => ofs' < p + init_data_size (Init_space z)).
   inv Heqo. apply read_as_zero_unchanged with (m := m1) (P := P).
+  { eapply store_init_data_list_same_conc; eauto. }
   red; intros. apply H0; auto. simpl. generalize (init_data_list_size_pos il); extlia.
   eapply store_init_data_list_unchanged; eauto.
   intros; unfold P. lia.
@@ -1153,6 +1233,19 @@ Proof.
   apply IHgl; auto.
 Qed.
 
+Lemma alloc_global_same_conc
+  m m' gl
+  (ALLOC: alloc_global m gl = Some m'):
+  <<CONC: m.(Mem.mem_concrete) = m'.(Mem.mem_concrete)>>.
+Proof.
+  unfold alloc_global in ALLOC. des_ifs.
+- eapply Mem.concrete_drop in ALLOC. rewrite <- ALLOC.
+  eapply Mem.concrete_alloc; eauto.
+- eapply Mem.concrete_drop in ALLOC. eapply store_init_data_list_same_conc in Heq1.
+  eapply store_zeros_same_conc in Heq0. eapply Mem.concrete_alloc in Heq.
+  rewrite Heq, Heq0, Heq1, ALLOC. eauto.
+Qed.
+    
 Remark load_store_init_data_invariant:
   forall m m' b,
   (forall chunk ofs, Mem.load chunk m' b ofs = Mem.load chunk m b ofs) ->
@@ -1240,7 +1333,7 @@ Proof.
   red; intros. eapply Mem.perm_unchanged_on; eauto. exact I.
   intros. eapply B. eapply Mem.perm_unchanged_on_2; eauto. exact I.
   intros. apply load_store_init_data_invariant with m; auto.
-  intros. eapply Mem.load_unchanged_on_1; eauto. intros; exact I.
+  intros. eapply Mem.load_unchanged_on_2; eauto. eapply alloc_global_same_conc; eauto. intros; exact I.
   intros. eapply Mem.loadbytes_unchanged_on; eauto. intros; exact I.
 - simpl. congruence.
 Qed.
@@ -1264,6 +1357,105 @@ End INITMEM.
 Definition init_mem (p: program F V) :=
   alloc_globals (globalenv p) Mem.empty p.(prog_defs).
 
+Theorem concrete_store_init_data
+  ge m1 b p id m2
+  (STORE: store_init_data ge m1 b p id = Some m2)
+  :
+  m1.(Mem.mem_concrete)= m2.(Mem.mem_concrete).
+Proof.
+  unfold store_init_data in STORE.
+  destruct id;
+    try apply Mem.concrete_store in STORE; try assumption.
+  inversion STORE. reflexivity.
+  destruct (find_symbol ge i); inversion STORE.
+  apply Mem.concrete_store in STORE. assumption.
+Qed.
+
+Theorem concrete_store_init_data_list ge m1 b p idl m2
+        (STORE: store_init_data_list ge m1 b p idl = Some m2):
+  m1.(Mem.mem_concrete)= m2.(Mem.mem_concrete).
+Proof.
+  unfold store_init_data_list in STORE.
+  remember (length idl) as n.
+  revert m1 m2 p idl STORE Heqn.
+  induction n as [|n0 IH].
+  - intros. symmetry in Heqn. apply length_zero_iff_nil in Heqn.
+    rewrite Heqn in *. inversion STORE. reflexivity.
+  - intros. destruct idl as [|e idl0] eqn:HIDL; inversion Heqn.
+    specialize IH with (idl:=idl0).
+    destruct (store_init_data ge m1 b p e) as [m3|] eqn:HM3.
+    + apply concrete_store_init_data in HM3.
+      rewrite HM3.
+      assert (m3.(Mem.mem_concrete) = m2.(Mem.mem_concrete)).
+      { eapply IH; eauto. }
+      auto.
+    + inversion STORE.
+Qed.
+
+Theorem concrete_store_zeros m1 b p n m2
+        (STORE: store_zeros m1 b p n = Some m2):
+  m1.(Mem.mem_concrete)= m2.(Mem.mem_concrete).
+Proof.
+  simpl in STORE.
+  functional induction (store_zeros m1 b p n).
+  + inversion STORE. reflexivity.
+  + apply Mem.concrete_store in e0. rewrite e0.
+    apply IHo. assumption.
+  + inversion STORE.
+Qed.
+
+Theorem alloc_global_concrete ge m1 idg m2
+        (ALLOC: alloc_global ge m1 idg = (Some m2)):
+  m2.(Mem.mem_concrete) = m1.(Mem.mem_concrete).
+Proof.
+  unfold alloc_global in ALLOC.
+  destruct idg as [f g].
+  destruct g eqn:HG;
+  destruct (Mem.alloc m1 0 1) as [m3 b] eqn:HALLOC;
+  apply Mem.concrete_alloc with (lo:=0) (hi:=1) (m2:=m3) (b:=b) in HALLOC; rewrite HALLOC.
+  - apply Mem.concrete_drop with (b:=b) (lo:=0) (hi:=1) (p:=Nonempty) in ALLOC. symmetry. assumption.
+  - destruct (Mem.alloc m1 0 (init_data_list_size (gvar_init v))) as [m4 b1] eqn:HALLOC1;
+   destruct (store_zeros m4 b1 0 (init_data_list_size (gvar_init v))) as [m5|] eqn:HSTORE;
+   try destruct (store_init_data_list ge m5 b1 0 (gvar_init v)) as [m6|] eqn:HSTOREINIT; try inversion ALLOC.
+    apply Mem.concrete_alloc in HALLOC1;
+      apply Mem.concrete_drop in ALLOC;
+      apply concrete_store_zeros in HSTORE;
+      apply concrete_store_init_data_list in HSTOREINIT.
+    rewrite HALLOC1 in *. rewrite HALLOC in *. rewrite ALLOC in *.
+    rewrite HSTOREINIT in *. rewrite HSTORE in *. reflexivity.
+Qed.
+
+Theorem alloc_globals_concrete ge m1 gl m2
+        (ALLOC: alloc_globals ge m1 gl = Some m2):
+  m1.(Mem.mem_concrete) = m2.(Mem.mem_concrete).
+Proof.
+  remember (length gl) as n.
+  revert m2 m1 gl ALLOC Heqn.
+  induction n as [|n0 IH].
+  - intros. symmetry in Heqn. apply length_zero_iff_nil in Heqn.
+    rewrite Heqn in ALLOC. simpl in ALLOC. inversion ALLOC. reflexivity.
+  - intros m2 m1 gl ALLOC HLENGTH.
+    destruct gl as [|e gl0] eqn:HGL; inversion HLENGTH.
+    specialize IH with (gl:=gl0).
+    unfold alloc_globals in ALLOC.
+    destruct (alloc_global ge m1 e) as [m3|] eqn:HM3.
+    + apply alloc_global_concrete in HM3. rewrite <- HM3.
+      assert (m3.(Mem.mem_concrete) = m2.(Mem.mem_concrete)).
+      { eapply IH; eauto. }
+      auto.
+    + inversion ALLOC.
+Qed.
+
+Theorem init_mem_logical p m b
+  (INIT: init_mem p = Some m)
+  :
+  PTree.get b m.(Mem.mem_concrete) = None.
+Proof.
+  unfold init_mem in INIT.
+  apply alloc_globals_concrete in INIT.
+  rewrite <- INIT. rewrite PTree.gempty; eauto.
+Qed.
+
 Lemma init_mem_genv_next: forall p m,
   init_mem p = Some m ->
   genv_next (globalenv p) = Mem.nextblock m.
@@ -1461,6 +1653,69 @@ Proof.
   apply Ple_refl.
 Qed.
 
+(* move to Memory.v *)
+Lemma capture_same_perm
+    m m' b addr
+    (CAP: Mem.capture m b addr m') :
+  forall b1 ofs k p, Mem.perm m b1 ofs k p <-> Mem.perm m' b1 ofs k p.
+Proof.
+  i. inv CAP. unfold Mem.perm. rewrite ACCESS. eauto.
+Qed.
+
+Lemma capture_same_range_perm
+    m m' b addr
+    (CAP: Mem.capture m b addr m') :
+  forall b1 lo hi k p, Mem.range_perm m b1 lo hi k p <-> Mem.range_perm m' b1 lo hi k p.
+Proof.
+  i. unfold Mem.range_perm. split; i.
+  - rewrite <- capture_same_perm; eauto.
+  - rewrite capture_same_perm; eauto.
+Qed.
+
+Theorem flat_inj_capture_inject
+    m b addr m'
+    (IM: Mem.inject (Mem.flat_inj (Mem.nextblock m)) m m)
+    (CAP: Mem.capture m b addr m') :
+  Mem.inject (Mem.flat_inj (Mem.nextblock m')) m' m'.
+Proof.
+  inv IM. eapply  Mem.neutral_inject. r. clear -CAP mi_inj.
+  erewrite Mem.nextblock_capture; eauto.
+  inv mi_inj. econs; i.
+  - rewrite <- capture_same_perm in *; eauto.
+  - rewrite <- capture_same_range_perm in H0; eauto.
+  - dup CAP. inv CAP. rewrite <- CONTENTS. rewrite <- capture_same_perm in H0; eauto.
+Qed.
+
+Theorem initmem_capture_inject
+    p m b addr m'
+    (INIT: init_mem p = Some m)
+    (CAP: Mem.capture m b addr m') :
+  Mem.inject (Mem.flat_inj (Mem.nextblock m')) m' m'.
+Proof.
+  exploit initmem_inject; eauto. intros IM. eapply flat_inj_capture_inject; eauto.
+Qed.
+
+Theorem flat_inj_capture_list_inject
+    m bs addrs m'
+    (IM: Mem.inject (Mem.flat_inj (Mem.nextblock m)) m m)
+    (CAP: Mem.capture_list m bs addrs m') :
+  Mem.inject (Mem.flat_inj (Mem.nextblock m')) m' m'.
+Proof.
+  ginduction bs; ss; i.
+  { inv CAP. eauto. }
+  inv CAP. exploit flat_inj_capture_inject; eauto.
+Qed.
+
+Theorem initmem_capture_list_inject
+    p m bs addrs m'
+    (INIT: init_mem p = Some m)
+    (CAP: Mem.capture_list m bs addrs m') :
+  Mem.inject (Mem.flat_inj (Mem.nextblock m')) m' m'.
+Proof.
+  exploit initmem_inject; eauto. intros IM. eapply flat_inj_capture_list_inject; eauto.
+Qed.
+
+
 (** ** Sufficient and necessary conditions for the initial memory to exist. *)
 
 (** Alignment properties *)
diff --git a/common/IntPtrRel.v b/common/IntPtrRel.v
new file mode 100644
index 00000000..e790d859
--- /dev/null
+++ b/common/IntPtrRel.v
@@ -0,0 +1,4013 @@
+Require Import Coqlib.
+Require Import AST.
+Require Import Integers.
+Require Import Floats.
+Require Import Maps.
+Require Import Values Memory.
+Require Import sflib Classical.
+
+Local Notation "a # b" := (PMap.get b a) (at level 1).
+
+Section BINDEDVAL.
+
+(* m is a target memory *)    
+
+(* merge long and int case *)
+Inductive val_intptr (m: mem) : val -> val -> Prop :=
+| val_intptr_int : forall i, val_intptr m (Vint i) (Vint i)
+| val_intptr_long : forall i, val_intptr m (Vlong i) (Vlong i)
+| val_intptr_float : forall f, val_intptr m (Vfloat f) (Vfloat f)
+| val_intptr_single : forall f, val_intptr m (Vsingle f) (Vsingle f)
+| val_intptr_ptr_ptr : forall b ofs, val_intptr m (Vptr b ofs) (Vptr b ofs)
+| val_intptr_ptr_int : forall i b ofs, Archi.ptr64 = false ->
+                              Mem.to_int (Vptr b ofs) m = Some (Vint i) ->
+                              val_intptr m (Vptr b ofs) (Vint i)
+| val_intptr_ptr_long : forall i b ofs, Archi.ptr64 = true ->
+                               Mem.to_int (Vptr b ofs) m = Some (Vlong i) ->
+                               val_intptr m (Vptr b ofs) (Vlong i)
+| val_intptr_undef : forall v, val_intptr m Vundef v.
+
+Inductive val_intptrist (m: mem) : list val -> list val -> Prop :=
+| val_intptr_nil : val_intptrist m [] []
+| val_intptr_cons : forall v1 v2 vl1 vl2, val_intptr m v1 v2 ->
+                                 val_intptrist m vl1 vl2 ->
+                                 val_intptrist m (v1::vl1) (v2::vl2).
+
+Lemma val_intptr_refl m v :
+  val_intptr m v v.
+Proof. destruct v; ss; econs. Qed.
+
+End BINDEDVAL.
+
+Section BINDMVAL.
+
+(** * Compatibility with concrete extends *)
+
+(** Relating two memory values according to a concrete extends. *)
+
+(* TODO: merge 2nd 3rd case *)
+Inductive memval_intptr (m: mem) : memval -> memval -> Prop :=
+| memval_intptr_byte:
+  forall n, memval_intptr m (Byte n) (Byte n)
+| memval_intptr_byte_frag64:
+  forall b ofs i bl bt n,
+    Archi.ptr64 = true ->
+    Mem.to_int (Vptr b ofs) m = Some (Vlong i) ->
+    encode_val Mptr (Vlong i) = bl ->
+    nth_error (rev_if_be_mv bl) n = Some (Byte bt) ->
+    memval_intptr m (Fragment (Vptr b ofs) Q64 n) (Byte bt)
+| memval_intptr_byte_frag32:
+  forall b ofs i bl bt n,
+    Archi.ptr64 = false ->
+    Mem.to_int (Vptr b ofs) m = Some (Vint i) ->
+    encode_val Mptr (Vint i) = bl ->
+    nth_error (rev_if_be_mv bl) n = Some (Byte bt) ->
+    memval_intptr m (Fragment (Vptr b ofs) Q32 n) (Byte bt)
+| memval_intptr_frag:
+  forall v1 v2 q n,
+    val_intptr m v1 v2 ->
+    memval_intptr m (Fragment v1 q n) (Fragment v2 q n)
+| memval_intptr_undef_frag:
+  forall q n mv, memval_intptr m (Fragment Vundef q n) mv
+| memval_intptr_undef:
+  forall mv, memval_intptr m Undef mv.
+
+Lemma memval_intptr_refl m mv :
+  memval_intptr m mv mv.
+Proof. destruct mv; ss; econs. destruct v; econs. Qed.
+  
+End BINDMVAL.
+
+Section CHANGE_EXT.
+
+Record concrete_extends (m_before m_after: mem) : Prop := mk_concrete_extends {
+  same_nextblock:
+    (Mem.nextblock m_before) = (Mem.nextblock m_after);
+  extended_access:
+      forall b ofs k p, Mem.perm m_before b ofs k p ->
+                   Mem.perm m_after b ofs k p;                                                         
+  extended_contents:
+    forall b ofs,
+    Mem.perm m_before b ofs Cur Readable ->
+    memval_intptr m_after (ZMap.get ofs (Mem.mem_contents m_before) # b) (ZMap.get ofs (Mem.mem_contents m_after) # b);
+  extended_concrete:
+    forall b caddr,
+    m_before.(Mem.mem_concrete) ! b = Some caddr -> m_after.(Mem.mem_concrete) ! b = Some caddr;
+}.
+
+Lemma concrete_ext_refl:
+  forall m, concrete_extends m m.
+Proof. i; econs; eauto. ii. eapply memval_intptr_refl. Qed.
+
+Lemma concrete_concrete_implies m m' b caddr
+  (CE: concrete_extends m m')
+  (CONC: m.(Mem.mem_concrete) ! b = Some caddr):
+  <<CONC: m'.(Mem.mem_concrete) ! b = Some caddr>>.
+Proof. inv CE. eauto. Qed.
+
+Lemma valid_concrete_extends m m'
+  (CE: concrete_extends m m') b ofs:
+  Mem.valid_pointer m b ofs = true -> Mem.valid_pointer m' b ofs = true.
+Proof.
+  inv CE. unfold Mem.valid_pointer.
+  destruct (Mem.perm_dec m b ofs Cur Nonempty); destruct (Mem.perm_dec m' b ofs Cur Nonempty); ss.
+  exfalso. eapply n; eauto.
+Qed.
+
+Lemma weak_valid_concrete_extends m m'
+  (CE: concrete_extends m m') b ofs :
+  Mem.weak_valid_pointer m b ofs = true -> Mem.weak_valid_pointer m' b ofs = true.
+Proof.
+  unfold Mem.weak_valid_pointer. i. eapply orb_prop in H. des.
+  - eapply valid_concrete_extends in H; eauto. rewrite H. ss.
+  - eapply valid_concrete_extends in H; eauto. rewrite H. eapply orb_true_r.
+Qed.
+
+Lemma _valid_concrete_extends m m'
+  (CE: concrete_extends m m') b ofs k :
+  Mem._valid_pointer m.(Mem.mem_access) b ofs k -> Mem._valid_pointer m'.(Mem.mem_access) b ofs k.
+Proof. unfold Mem._valid_pointer. i. eapply extended_access; eauto. Qed.
+
+Lemma _weak_valid_concrete_extends m m'
+  (CE: concrete_extends m m') b ofs k:
+  Mem._weak_valid_pointer m.(Mem.mem_access) b ofs k -> Mem._weak_valid_pointer m'.(Mem.mem_access) b ofs k.
+Proof. unfold Mem._weak_valid_pointer. i. des; eapply _valid_concrete_extends in H; eauto. Qed.
+
+Lemma denormalize_concrete_extends
+  m z m' b ofs
+  (CE: concrete_extends m m')
+  (DENO: Mem.denormalize z m = Some (b, ofs)):
+  <<DENOTGT: Mem.denormalize z m' = Some (b, ofs)>>.
+Proof.
+  inv CE. unfold Mem.denormalize in DENO.
+  eapply PTree.gselectf in DENO. des. unfold Mem.denormalize_aux in *.
+  rewrite DENO in *. des_ifs_safe.
+  eapply andb_prop in Heq. des.
+  rewrite <- Mem.addr_in_block_iff in Heq0.
+  
+  inv Heq0. des. clarify.
+  exploit extended_access0.
+  { unfold Mem.perm. erewrite PERM. ss. eapply perm_any_N. }
+  eapply extended_concrete0 in CONCRETE.
+  unfold Mem.is_valid in Heq. rewrite same_nextblock0 in *.
+
+  assert (INBLKTGT: Mem.addr_in_block (Mem.mem_concrete m') (Mem.mem_access m') z b).
+  { exploit extended_access0.
+    { unfold Mem.perm. erewrite PERM. ss. eapply perm_any_N. }
+    i. unfold Mem.perm, Mem.perm_order' in H. des_ifs.
+    econs; eauto. }
+
+  destruct (Mem.denormalize z m') eqn:TGT.
+  { unfold Mem.denormalize in TGT. eapply PTree.gselectf in TGT.
+    des. unfold Mem.denormalize_aux in TGT0. des_ifs.
+    eapply andb_prop in Heq1. des.
+    rewrite <- Mem.addr_in_block_iff in Heq2.
+    exploit Mem.no_concrete_overlap. eapply INBLKTGT. eauto. ii. subst. clarify. }
+  eapply PTree.gselectnf in TGT. exfalso. eapply TGT. esplits; eauto. 
+  ii. unfold Mem.denormalize_aux in H. des_ifs. rewrite andb_false_iff in Heq1. des.
+  { unfold Mem.is_valid in Heq1. clarify. }
+  rewrite Mem.addr_in_block_iff in INBLKTGT. clarify.
+Qed.
+
+Lemma concrete_extends_perm_implies m m'
+    (CE: concrete_extends m m') b o k p :
+  Mem.perm m b o k p -> Mem.perm m' b o k p.
+Proof. eapply extended_access; eauto. Qed.
+
+Lemma concrete_extends_range_perm_implies m m'
+    (CE: concrete_extends m m') b o l k p :
+  Mem.range_perm m b o l k p -> Mem.range_perm m' b o l k p.
+Proof. unfold Mem.range_perm; i. eapply concrete_extends_perm_implies; eauto. Qed.
+
+(* Lemma denormalize_concrete_extends_same_addr m m' *)
+(*     (CE: concrete_extends m m') *)
+(*     i1 i2 b o *)
+(*     (DENO1: Mem.denormalize i1 m = Some (b, o)) *)
+(*     (DENO2: Mem.denormalize i2 m' = Some (b, o)): *)
+(*   <<SAMEADD: i1 = i2>>. *)
+(* Proof. *)
+(*   eapply PTree.gselectf in DENO1, DENO2. *)
+(*   des. unfold Mem.denormalize_aux in *. des_ifs. *)
+(*   assert (a0 = a). *)
+(*   { eapply extended_concrete in Heq1; eauto. clarify. } *)
+(*   clarify. eapply Mem.Z_sub_reg_r; eauto. *)
+(* Qed. *)
+
+End CHANGE_EXT.
+
+Lemma ptr2int_conc_ext (m m': mem) b ofs addr
+   (CONCEXT: concrete_extends m m')
+   (P2I: Mem.ptr2int b ofs m = Some addr) :  
+  Mem.ptr2int b ofs m' = Some addr.
+Proof.
+  unfold Mem.ptr2int in *. des_ifs_safe.
+  eapply extended_concrete in Heq; eauto.
+  rewrite Heq. auto.
+Qed.
+
+Lemma to_ptr_concrete_exnteds_tgt
+    m m' v1 v1' b ofs k
+    (CONCEXT: concrete_extends m m')
+    (BIND: val_intptr m' v1 v1')
+    (PERM: Mem.perm m' b (Ptrofs.unsigned ofs) k Nonempty) 
+    (I2P: Mem.to_ptr v1 m = Some (Vptr b ofs)) :
+  Mem.to_ptr v1' m' = Some (Vptr b ofs).
+Proof.
+  ss. dup BIND. inv BIND; ss; des_ifs_safe.
+  - des_ifs.
+    { eapply denormalize_concrete_extends in Heq1; eauto. des; clarify. }
+    { eapply denormalize_concrete_extends in Heq1; eauto. des; clarify. }
+  - exploit Mem.ptr2int_to_denormalize_max; eauto.
+    { eapply Ptrofs.unsigned_range_2. }
+    { eapply Mem.perm_max; eauto. }
+    i. des. exploit Mem.denormalize_info; eauto. i. des.
+    unfold Ptrofs.max_unsigned in *. erewrite Ptrofs.modulus_eq64 in *; eauto.
+    destruct (Int64.eq (Int64.repr z) Int64.zero) eqn:NULL.
+    { exfalso. unfold Int64.eq in NULL. erewrite Int64.unsigned_zero in NULL. des_ifs.
+      erewrite Int64.unsigned_repr in e; subst; [lia|].
+      unfold Int64.max_unsigned. lia. }
+    erewrite Int64.unsigned_repr.
+    2:{ unfold Int64.max_unsigned. lia. }
+    rewrite H0. rewrite Ptrofs.repr_unsigned. eauto.
+Qed.
+
+Lemma to_ptr_concrete_exnteds
+    m m' v1 v1' b ofs k
+    (CONCEXT: concrete_extends m m')
+    (BIND: val_intptr m' v1 v1')
+    (PERM: Mem.perm m b (Ptrofs.unsigned ofs) k Nonempty) 
+    (I2P: Mem.to_ptr v1 m = Some (Vptr b ofs)) :
+  Mem.to_ptr v1' m' = Some (Vptr b ofs).
+Proof.
+  eapply concrete_extends_perm_implies in PERM; eauto.
+  eapply to_ptr_concrete_exnteds_tgt; eauto.
+Qed.
+
+(** to_ptr, to_int function & lemmas for wrapper operation *)
+
+Definition option_to_val (ov: option val) : val :=
+  match ov with
+  | Some v => v
+  | None => Vundef
+  end.
+
+Definition to_ptr_val (m: mem) (v: val) : val :=
+  option_to_val (Mem.to_ptr v m).
+
+Definition to_int_val (m: mem) (v: val) : val :=
+  option_to_val (Mem.to_int v m).
+
+Lemma to_ptr_val_ptr_or_undef m v v'
+    (TOPTR: to_ptr_val m v = v') :
+  v' = Vundef \/ exists b ofs, v' = Vptr b ofs \/ v' = Vnullptr.
+Proof.
+  unfold to_ptr_val, Mem.to_ptr in TOPTR. destruct v; ss; des_ifs; eauto.
+  right. unfold option_to_val. esplits; eauto.
+  Unshelve. eapply 1%positive. eapply Ptrofs.zero.
+Qed.
+
+Lemma to_int_val_int_or_undef m v v'
+    (TOINT: to_int_val m v = v') :
+  v' = Vundef \/ exists n, v' = Vlong n \/ exists n, v' = Vint n.
+Proof.
+  unfold to_int_val, Mem.to_int in TOINT. destruct v; ss; des_ifs; eauto.
+  ss. eauto.
+  Unshelve. eapply Int64.zero.
+Qed.
+
+Lemma nullptr_to_ptr_nullptr m:
+  <<FAIL: to_ptr_val m Vnullptr = Vnullptr>>.
+Proof.
+  unfold to_ptr_val, Mem.to_ptr, Vnullptr. simpl. des_ifs.
+Qed.
+
+Lemma nullptr_to_ptr_nullptr32 (SF: Archi.ptr64 = false) m:
+  <<FAIL: to_ptr_val m (Vint Int.zero) = Vint Int.zero>>.
+Proof.
+  specialize (nullptr_to_ptr_nullptr m). i. unfold Vnullptr in *.
+  rewrite SF in *. eauto.
+Qed.
+
+Lemma ptr_to_int_never_nullptr b ofs m
+    (WVLD: Mem.weak_valid_pointer m b (Ptrofs.unsigned ofs) = true) :
+  <<NOTNULL: to_int_val m (Vptr b ofs) <> Vnullptr>>.
+Proof.
+  unfold to_int_val, Mem.to_int, Mem.ptr2int_v. simpl. des_ifs.
+  eapply Mem.ptr2int_weak_valid' in Heq; eauto; [| eapply Ptrofs.unsigned_range_2].
+  i. des. ii. simpl in *. unfold Vnullptr in H. destruct Archi.ptr64 eqn:SF.
+  - assert (Int64.eq (Int64.repr z) Int64.zero).
+    { inv H; des_ifs. }
+    inv INRANGE. simpl in *. unfold Int64.eq in H0. rewrite Int64.unsigned_repr in H0.
+    2:{ simpl in *. rewrite Ptrofs.modulus_eq64 in SND; eauto. unfold Int64.max_unsigned. lia. }
+    rewrite Int64.unsigned_zero in H0. des_ifs; lia.
+  - assert (Int.eq (Int.repr z) Int.zero).
+    { inv H; des_ifs. }
+    inv INRANGE. simpl in *. unfold Int.eq in H0. rewrite Int.unsigned_repr in H0.
+    2:{ simpl in *. rewrite Ptrofs.modulus_eq32 in SND; eauto. unfold Int.max_unsigned. lia. }
+    rewrite Int.unsigned_zero in H0. des_ifs; lia.
+Qed.
+
+Section GENINJ.
+
+Variable m1 m2: mem.
+Variable f: meminj.
+
+Hypothesis mi_inj_perm: forall b1 b2 delta ofs k p,
+    f b1 = Some (b2, delta) ->
+    Mem.perm m1 b1 ofs k p -> Mem.perm m2 b2 (ofs + delta) k p.
+
+Hypothesis src_concrete_private: forall b, f b = None -> (Mem.mem_concrete m1) ! b = None.
+
+Hypothesis mappedblocks: forall b b' delta, Mem.valid_block m1 b -> f b = Some (b', delta) -> Mem.valid_block m2 b'.
+
+Hypothesis src_concrete_public: forall b1 b2 addr delta,
+    f b1 = Some (b2, delta) ->
+    (Mem.mem_concrete m1) ! b1 = Some addr ->
+    (Mem.mem_concrete m2) ! b2 = Some (addr - delta).
+
+Hypothesis representable: forall b b' delta ofs,
+    f b = Some (b', delta) ->
+    Mem.perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \/
+    Mem.perm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->
+    delta >= 0 /\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.
+
+Lemma to_ptr_val_inject' v v'
+    (VINJ: Val.inject f v v') :
+  <<INJ: Val.inject f (to_ptr_val m1 v) (to_ptr_val m2 v')>>.
+Proof.
+  unfold to_ptr_val. destruct (Mem.to_ptr v m1) eqn:SRC; ss.
+  exploit Mem.to_ptr_inject'; eauto. i. des. rewrite TOPTRTGT. ss.
+Qed.
+
+Lemma to_int_val_inject' v v'
+    (VINJ: Val.inject f v v') :
+  <<INJ: Val.inject f (to_int_val m1 v) (to_int_val m2 v')>>.
+Proof.
+  unfold to_int_val. destruct (Mem.to_int v m1) eqn:SRC; ss.
+  exploit Mem.to_int_inject'; eauto. i. des. rewrite TOINTTGT. ss.
+Qed.
+
+End GENINJ.
+
+Lemma to_ptr_val_lessdef m m' v v'
+    (MEXT: Mem.extends m m')
+    (VINJ: Val.lessdef v v') :
+  <<LESS': Val.lessdef (option_to_val (Mem.to_ptr v m)) (option_to_val (Mem.to_ptr v' m'))>>.
+Proof.
+  destruct (Mem.to_ptr v m) eqn:SRC; ss.
+  exploit Mem.to_ptr_extends; eauto. i. des. rewrite H. ss.
+Qed.
+        
+Lemma to_ptr_val_list_lessdef m m' vl vl'
+    (MEXT: Mem.extends m m')
+    (VLESS: Val.lessdef_list vl vl') :
+  <<LESS: Val.lessdef_list (map (to_ptr_val m) vl) (map (to_ptr_val m') vl')>>.
+Proof.
+  induction VLESS; ss. econs; eauto. eapply to_ptr_val_lessdef; eauto.
+Qed.
+
+Lemma to_int_val_lessdef m m' v v'
+    (MEXT: Mem.extends m m')
+    (VINJ: Val.lessdef v v') :
+  <<LESS': Val.lessdef (option_to_val (Mem.to_int v m)) (option_to_val (Mem.to_int v' m'))>>.
+Proof.
+  destruct (Mem.to_int v m) eqn:SRC; ss.
+  exploit Mem.to_int_extends; eauto. i. des. rewrite H. ss.
+Qed.
+
+Lemma to_int_val_list_lessdef m m' vl vl'
+    (MEXT: Mem.extends m m')
+    (VLESS: Val.lessdef_list vl vl') :
+  <<LESS: Val.lessdef_list (map (to_int_val m) vl) (map (to_int_val m') vl')>>.
+Proof.
+  induction VLESS; ss. econs; eauto. eapply to_int_val_lessdef; eauto.
+Qed.
+
+Lemma to_ptr_val_inject f m m' v v'
+    (MINJ: Mem.inject f m m')
+    (VINJ: Val.inject f v v') :
+  <<INJ: Val.inject f (to_ptr_val m v) (to_ptr_val m' v')>>.
+Proof. inv MINJ. eapply to_ptr_val_inject'; eauto. inv mi_inj; eauto. Qed.
+
+Lemma to_ptr_val_list_inject f m m' vl vl'
+    (MINJ: Mem.inject f m m')
+    (VINJ: Val.inject_list f vl vl') :
+  <<INJ: Val.inject_list f (map (to_ptr_val m) vl) (map (to_ptr_val m') vl')>>.
+Proof. induction VINJ; ss. econs; eauto. eapply to_ptr_val_inject; eauto. Qed.
+
+Lemma to_int_val_inject f m m' v v'
+    (MINJ: Mem.inject f m m')
+    (VINJ: Val.inject f v v') :
+  <<INJ: Val.inject f (to_int_val m v) (to_int_val m' v')>>.
+Proof. inv MINJ. eapply to_int_val_inject'; eauto. Qed.
+
+Lemma to_int_val_list_inject f m m' vl vl'
+    (MINJ: Mem.inject f m m')
+    (VINJ: Val.inject_list f vl vl') :
+  <<INJ: Val.inject_list f (map (to_int_val m) vl) (map (to_int_val m') vl')>>.
+Proof. induction VINJ; ss. econs; eauto. eapply to_int_val_inject; eauto. Qed.
+
+(** Auxiliary Lemmas for comparison *)
+
+(* Lemma same_block_concrete_cmp64 *)
+(*   caddr caddr' m b ofs ofs' c *)
+(*   (BIT: Archi.ptr64 = true) *)
+(*   (PTR1: Mem.denormalize (Int64.unsigned caddr) m = Some (b, ofs)) *)
+(*   (PTR2: Mem.denormalize (Int64.unsigned caddr') m = Some (b, ofs')) *)
+(*   : *)
+(*   <<CMP: Ptrofs.cmpu c (Ptrofs.repr ofs) (Ptrofs.repr ofs') = Int64.cmpu c caddr caddr' >>. *)
+(* Proof. *)
+(*   exploit Mem.denormalize_in_range; try eapply PTR1. *)
+(*   exploit Mem.denormalize_in_range; try eapply PTR2. intros ORANGE1 ORANGE2. *)
+(*   exploit Mem.denormalize_paddr_in_range; try eapply PTR1. *)
+(*   exploit Mem.denormalize_paddr_in_range; try eapply PTR2. intros PRANGE1 PRANGE2. *)
+(*   eapply PTree.gselectf in PTR1, PTR2. des. unfold Mem.denormalize_aux in *. des_ifs. *)
+(*   eapply andb_prop in Heq0, Heq2. des. r. *)
+(*   unfold Mem.addr_is_in_block in *. des_ifs. *)
+(*   destruct c. *)
+(*   - unfold Ptrofs.cmpu, Ptrofs.eq. *)
+(*     rewrite Ptrofs.unsigned_repr; [|unfold Ptrofs.max_unsigned in *; lia]. *)
+(*     rewrite Ptrofs.unsigned_repr; [|unfold Ptrofs.max_unsigned in *; lia]. *)
+(*     unfold Int64.cmpu, Int64.eq. des_ifs; lia. *)
+(*   - unfold Ptrofs.cmpu, Ptrofs.eq. *)
+(*     rewrite Ptrofs.unsigned_repr; [|unfold Ptrofs.max_unsigned in *; lia]. *)
+(*     rewrite Ptrofs.unsigned_repr; [|unfold Ptrofs.max_unsigned in *; lia]. *)
+(*     unfold Int64.cmpu, Int64.eq. des_ifs; lia. *)
+(*   - simpl. unfold Ptrofs.ltu, Int64.ltu. *)
+(*     rewrite Ptrofs.unsigned_repr; [|unfold Ptrofs.max_unsigned in *; lia]. *)
+(*     rewrite Ptrofs.unsigned_repr; [|unfold Ptrofs.max_unsigned in *; lia]. *)
+(*     des_ifs; lia. *)
+(*   - simpl. unfold Ptrofs.ltu, Int64.ltu. *)
+(*     rewrite Ptrofs.unsigned_repr; [|unfold Ptrofs.max_unsigned in *; lia]. *)
+(*     rewrite Ptrofs.unsigned_repr; [|unfold Ptrofs.max_unsigned in *; lia]. *)
+(*     des_ifs; lia. *)
+(*   - simpl. unfold Ptrofs.ltu, Int64.ltu. *)
+(*     rewrite Ptrofs.unsigned_repr; [|unfold Ptrofs.max_unsigned in *; lia]. *)
+(*     rewrite Ptrofs.unsigned_repr; [|unfold Ptrofs.max_unsigned in *; lia]. *)
+(*     des_ifs; lia. *)
+(*   - simpl. unfold Ptrofs.ltu, Int64.ltu. *)
+(*     rewrite Ptrofs.unsigned_repr; [|unfold Ptrofs.max_unsigned in *; lia]. *)
+(*     rewrite Ptrofs.unsigned_repr; [|unfold Ptrofs.max_unsigned in *; lia]. *)
+(*     des_ifs; lia. *)
+(* Qed. *)
+
+Lemma lt_eq_cmpu ofs1 ofs2 i1 i2 c
+    (EQ: Ptrofs.eq ofs1 ofs2 = Int.eq i1 i2)
+    (LT: Ptrofs.ltu ofs1 ofs2 = Int.ltu i1 i2) :
+  <<CMPU: Ptrofs.cmpu c ofs1 ofs2 = Int.cmpu c i1 i2>>.
+Proof.
+  destruct c; simpl in *.
+  - rewrite EQ. reflexivity.
+  - rewrite EQ. reflexivity.
+  - rewrite LT. reflexivity.
+  - rewrite Ptrofs.not_ltu, Int.not_ltu. rewrite EQ, LT. reflexivity.
+  - rewrite Ptrofs.ltu_not, Int.ltu_not. rewrite EQ, LT. reflexivity.
+  - rewrite LT. reflexivity.
+Qed.
+
+Lemma lt_eq_cmplu ofs1 ofs2 i1 i2 c
+    (EQ: Ptrofs.eq ofs1 ofs2 = Int64.eq i1 i2)
+    (LT: Ptrofs.ltu ofs1 ofs2 = Int64.ltu i1 i2) :
+  <<CMPU: Ptrofs.cmpu c ofs1 ofs2 = Int64.cmpu c i1 i2>>.
+Proof.
+  destruct c; simpl in *.
+  - rewrite EQ. reflexivity.
+  - rewrite EQ. reflexivity.
+  - rewrite LT. reflexivity.
+  - rewrite Ptrofs.not_ltu, Int64.not_ltu. rewrite EQ, LT. reflexivity.
+  - rewrite Ptrofs.ltu_not, Int64.ltu_not. rewrite EQ, LT. reflexivity.
+  - rewrite LT. reflexivity.
+Qed.
+
+(** Auxiliary Lemmas for ptr comparison and pointer sub *)
+
+(** No Angelic Behavior in CompCert *)
+
+Lemma psub_wrapper_no_angelic m v1 v2 vp vi
+    (SUB1: Val.psub (to_ptr_val m v1) (to_ptr_val m v2) = vp)
+    (SUB2: Val.psub (to_int_val m v1) (to_int_val m v2) = vi) :
+  <<NOANGELIC: vp = Vundef \/ vi = Vundef \/ vi = vp>>.
+Proof.
+  destruct (Archi.ptr64) eqn:BIT.
+  { unfold Val.psub in *. rewrite BIT in *. clear BIT.
+    destruct v1; destruct v2; simpl in *; subst; eauto.
+    all: (des_ifs; eauto). }
+  destruct v1; simpl in *; subst; try rewrite BIT; [auto| | auto | auto | auto | ].
+  - destruct v2; simpl in *; subst; try rewrite BIT; [auto| | auto | auto | auto | ].
+    (* int int *)
+    + unfold to_ptr_val. simpl. rewrite BIT. simpl.
+      destruct (Int.eq i Int.zero) eqn: NULL.
+      { destruct (Int.eq i0 Int.zero) eqn: NULL'.
+        - simpl. eapply Int.same_if_eq in NULL, NULL'. subst. eauto.
+        - destruct (Mem.denormalize (Int.unsigned i0) m) eqn:DENO2; simpl; eauto. }
+      destruct (Int.eq i0 Int.zero) eqn: NULL'.
+      { destruct (Mem.denormalize (Int.unsigned i) m) eqn:DENO; simpl; eauto.
+        destruct p. simpl. eauto. }
+      destruct (Mem.denormalize (Int.unsigned i) m) eqn:DENO1; simpl;[|auto]. destruct p. simpl.
+      destruct (Mem.denormalize (Int.unsigned i0) m) eqn:DENO2; simpl; [|auto]. destruct p. simpl.
+      rewrite BIT. destruct (eq_block b b0); [|auto]. symmetry in e; subst.
+      exploit Mem.denormalize_info; try eapply DENO1. i. des.
+      exploit Mem.denormalize_info; try eapply DENO2. i. des. subst.
+      rewrite CONC in CONC0. inv CONC0. do 2 right. unfold Ptrofs.sub.
+      rewrite Ptrofs.unsigned_repr; [|lia]. rewrite Ptrofs.unsigned_repr; [|lia].
+      replace (Int.unsigned i - caddr0 - (Int.unsigned i0 - caddr0)) with (Int.unsigned i - Int.unsigned i0) by lia.
+      unfold Int.sub, Ptrofs.to_int. f_equal. eapply Int.same_if_eq. unfold Int.eq.
+      do 2 rewrite Int.unsigned_repr_eq. rewrite Ptrofs.unsigned_repr_eq. rewrite Ptrofs.modulus_eq32; eauto.
+      rewrite Z.mod_mod; [des_ifs|]. specialize Int.modulus_pos. lia.
+    (* int ptr *)
+    + unfold to_ptr_val, to_int_val. simpl. rewrite BIT. simpl.
+      destruct (Int.eq i Int.zero) eqn: NULL; simpl; eauto.
+      destruct (Mem.denormalize (Int.unsigned i) m) eqn:DENO1; simpl; [|auto]. destruct p. simpl.
+      rewrite BIT. destruct (eq_block b0 b); [|auto]. subst.
+      destruct (Mem.ptr2int b (Ptrofs.unsigned i0) m) eqn:I2P; simpl; [|auto].
+      right. right. eapply Mem.denormalize_info in DENO1. des.
+      unfold Mem.ptr2int in I2P. rewrite CONC in I2P. subst. inv I2P.
+      f_equal. unfold Int.sub, Ptrofs.sub, Ptrofs.to_int.
+      do 2 rewrite Ptrofs.unsigned_repr_eq. eapply Int.same_if_eq. unfold Int.eq.
+      do 3 rewrite Int.unsigned_repr_eq. rewrite Zminus_mod_idemp_l. rewrite Zminus_mod_idemp_r.
+      rewrite Ptrofs.modulus_eq32; eauto.
+      replace (Int.unsigned i - (caddr + Ptrofs.unsigned i0)) with (Int.unsigned i - caddr - Ptrofs.unsigned i0) by lia.
+      rewrite Z.mod_mod; [des_ifs|]. specialize Int.modulus_pos. lia.
+  - destruct v2; simpl in *; subst; try rewrite BIT; [auto| | auto | auto | auto | ].
+    (* ptr int *)
+    + unfold to_ptr_val, to_int_val. simpl. rewrite BIT. simpl.
+      destruct (Int.eq i0 Int.zero) eqn: NULL; simpl; eauto.
+      destruct (Mem.denormalize (Int.unsigned i0) m) eqn:DENO2; simpl; [|auto]. destruct p. simpl.
+      destruct (eq_block b b0); [|auto]. symmetry in e. subst.
+      destruct (Mem.ptr2int b (Ptrofs.unsigned i) m) eqn:I2P; simpl; [|auto]. rewrite BIT.
+      right. right. eapply Mem.denormalize_info in DENO2. des.
+      unfold Mem.ptr2int in I2P. rewrite CONC in I2P. subst. inv I2P.
+      f_equal. unfold Int.sub, Ptrofs.sub, Ptrofs.to_int.
+      do 2 rewrite Ptrofs.unsigned_repr_eq. eapply Int.same_if_eq. unfold Int.eq.
+      do 3 rewrite Int.unsigned_repr_eq. rewrite Zminus_mod_idemp_l. rewrite Zminus_mod_idemp_r.
+      rewrite Ptrofs.modulus_eq32; eauto.
+      replace (Ptrofs.unsigned i - (Int.unsigned i0 - caddr)) with (caddr + Ptrofs.unsigned i - Int.unsigned i0) by lia.
+      rewrite Z.mod_mod; [des_ifs|]. specialize Int.modulus_pos. lia.
+    + unfold to_ptr_val in *. simpl. rewrite BIT. simpl. auto.
+    + destruct (eq_block b b0); [|auto]. unfold to_int_val. simpl. subst b0.
+      destruct (Mem.ptr2int b (Ptrofs.unsigned i) m) eqn:P2I; simpl; [|auto].
+      destruct (Mem.ptr2int b (Ptrofs.unsigned i0) m) eqn:P2I'; simpl; [|auto]. rewrite BIT.
+      unfold Mem.ptr2int in *. destruct ((Mem.mem_concrete m)!b); [|clarify].
+      inv P2I; inv P2I'. right. right. simpl. rewrite BIT.
+      unfold Int.sub, Ptrofs.to_int, Ptrofs.sub. f_equal. eapply Int.same_if_eq. unfold Int.eq.
+      repeat rewrite Int.unsigned_repr_eq. rewrite Ptrofs.unsigned_repr_eq. rewrite Ptrofs.modulus_eq32; eauto.
+      rewrite Zminus_mod_idemp_l. rewrite Zminus_mod_idemp_r.
+      replace (z1 + Ptrofs.unsigned i - (z1 + Ptrofs.unsigned i0)) with (Ptrofs.unsigned i - Ptrofs.unsigned i0) by lia.
+      rewrite Z.mod_mod; [des_ifs|]. specialize Int.modulus_pos. lia.
+Qed.
+
+Lemma psubl_wrapper_no_angelic m v1 v2 vp vi
+    (SUB1: Val.psubl (to_ptr_val m v1) (to_ptr_val m v2) = vp)
+    (SUB2: Val.psubl (to_int_val m v1) (to_int_val m v2) = vi) :
+  <<NOANGELIC: vp = Vundef \/ vi = Vundef \/ vi = vp>>.
+Proof.
+  destruct (Archi.ptr64) eqn:BIT; cycle 1.
+  { unfold Val.psubl in *. rewrite BIT in *. clear BIT.
+    destruct v1; destruct v2; simpl in *; subst; eauto.
+    all: (des_ifs; eauto). }
+  destruct v1; simpl in *; subst; try rewrite BIT; [auto | auto | | auto | auto | ].
+  - destruct v2; simpl in *; subst; try rewrite BIT; [auto | auto | | auto | auto | ].
+    (* int int *)
+    + unfold to_ptr_val. simpl. rewrite BIT. simpl.
+      destruct (Int64.eq i Int64.zero) eqn: NULL.
+      { destruct (Int64.eq i0 Int64.zero) eqn: NULL'.
+        - simpl. (* rewrite BIT. *) eapply Int64.same_if_eq in NULL, NULL'. subst. eauto.
+        - destruct (Mem.denormalize (Int64.unsigned i0) m) eqn:DENO2; simpl; eauto.
+          destruct p. simpl. eauto. }
+      destruct (Int64.eq i0 Int64.zero) eqn: NULL'.
+      { destruct (Mem.denormalize (Int64.unsigned i) m) eqn:DENO; simpl; eauto.
+        destruct p. simpl. eauto. }
+      destruct (Mem.denormalize (Int64.unsigned i) m) eqn:DENO1; simpl;[|auto]. destruct p. simpl.
+      destruct (Mem.denormalize (Int64.unsigned i0) m) eqn:DENO2; simpl; [|auto]. destruct p. simpl.
+      rewrite BIT. destruct (eq_block b b0); [|auto]. symmetry in e; subst.
+      exploit Mem.denormalize_info; try eapply DENO1. i. des.
+      exploit Mem.denormalize_info; try eapply DENO2. i. des. subst. simpl.
+      rewrite CONC in CONC0. inv CONC0. do 2 right. unfold Ptrofs.sub.
+      rewrite Ptrofs.unsigned_repr; [|lia]. rewrite Ptrofs.unsigned_repr; [|lia].
+      replace (Int64.unsigned i - caddr0 - (Int64.unsigned i0 - caddr0)) with (Int64.unsigned i - Int64.unsigned i0) by lia.
+      unfold Int64.sub, Ptrofs.to_int64. f_equal. eapply Int64.same_if_eq. unfold Int64.eq.
+      do 2 rewrite Int64.unsigned_repr_eq. rewrite Ptrofs.unsigned_repr_eq. rewrite Ptrofs.modulus_eq64; eauto.
+      rewrite Z.mod_mod; [des_ifs|]. specialize Int64.modulus_pos. lia.
+    (* int ptr *)
+    + unfold to_ptr_val, to_int_val. simpl. rewrite BIT. simpl.
+      destruct (Int64.eq i Int64.zero) eqn: NULL; simpl; eauto.
+      destruct (Mem.denormalize (Int64.unsigned i) m) eqn:DENO1; simpl; [|auto]. destruct p. simpl.
+      rewrite BIT. destruct (eq_block b0 b); [|auto]. subst.
+      destruct (Mem.ptr2int b (Ptrofs.unsigned i0) m) eqn:I2P; simpl; [|auto].
+      right. right. eapply Mem.denormalize_info in DENO1. des.
+      unfold Mem.ptr2int in I2P. rewrite CONC in I2P. subst. inv I2P.
+      f_equal. unfold Int64.sub, Ptrofs.sub, Ptrofs.to_int64.
+      do 2 rewrite Ptrofs.unsigned_repr_eq. eapply Int64.same_if_eq. unfold Int64.eq.
+      do 3 rewrite Int64.unsigned_repr_eq. rewrite Zminus_mod_idemp_l. rewrite Zminus_mod_idemp_r.
+      rewrite Ptrofs.modulus_eq64; eauto.
+      replace (Int64.unsigned i - (caddr + Ptrofs.unsigned i0)) with (Int64.unsigned i - caddr - Ptrofs.unsigned i0) by lia.
+      rewrite Z.mod_mod; [des_ifs|]. specialize Int64.modulus_pos. lia.
+  - destruct v2; simpl in *; subst; try rewrite BIT; [auto | auto | | auto | auto | ].
+    (* ptr int *)
+    + unfold to_ptr_val, to_int_val. simpl. rewrite BIT. simpl.
+      destruct (Int64.eq i0 Int64.zero) eqn: NULL; simpl; eauto.
+      destruct (Mem.denormalize (Int64.unsigned i0) m) eqn:DENO2; simpl; [|auto]. destruct p. simpl.
+      destruct (eq_block b b0); [|auto]. symmetry in e. subst.
+      destruct (Mem.ptr2int b (Ptrofs.unsigned i) m) eqn:I2P; simpl; [|auto]. rewrite BIT.
+      right. right. eapply Mem.denormalize_info in DENO2. des.
+      unfold Mem.ptr2int in I2P. rewrite CONC in I2P. subst. inv I2P.
+      f_equal. unfold Int64.sub, Ptrofs.sub, Ptrofs.to_int64.
+      do 2 rewrite Ptrofs.unsigned_repr_eq. eapply Int64.same_if_eq. unfold Int64.eq.
+      do 3 rewrite Int64.unsigned_repr_eq. rewrite Zminus_mod_idemp_l. rewrite Zminus_mod_idemp_r.
+      rewrite Ptrofs.modulus_eq64; eauto.
+      replace (Ptrofs.unsigned i - (Int64.unsigned i0 - caddr)) with (caddr + Ptrofs.unsigned i - Int64.unsigned i0) by lia.
+      rewrite Z.mod_mod; [des_ifs|]. specialize Int64.modulus_pos. lia.
+    + destruct (eq_block b b0); [|auto]. unfold to_int_val. simpl. subst b0.
+      destruct (Mem.ptr2int b (Ptrofs.unsigned i) m) eqn:P2I; simpl; [|auto].
+      destruct (Mem.ptr2int b (Ptrofs.unsigned i0) m) eqn:P2I'; simpl; [|auto]. rewrite BIT.
+      unfold Mem.ptr2int in *. destruct ((Mem.mem_concrete m)!b); [|clarify].
+      inv P2I; inv P2I'. right. right. simpl. rewrite BIT.
+      unfold Int64.sub, Ptrofs.to_int64, Ptrofs.sub. f_equal. eapply Int64.same_if_eq. unfold Int64.eq.
+      repeat rewrite Int64.unsigned_repr_eq. rewrite Ptrofs.unsigned_repr_eq. rewrite Ptrofs.modulus_eq64; eauto.
+      rewrite Zminus_mod_idemp_l. rewrite Zminus_mod_idemp_r.
+      replace (z1 + Ptrofs.unsigned i - (z1 + Ptrofs.unsigned i0)) with (Ptrofs.unsigned i - Ptrofs.unsigned i0) by lia.
+      rewrite Z.mod_mod; [des_ifs|]. specialize Int64.modulus_pos. lia.
+Qed.
+
+Lemma cmpu_no_angelic m c v1 v2 bp bi
+    (CMP1: Val.cmpu_bool (Mem.valid_pointer m) c (to_ptr_val m v1) (to_ptr_val m v2) = Some bp)
+    (CMP2: Val.cmpu_bool (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2) = Some bi) :
+  <<NOANGELIC: bp = bi>>.
+Proof.
+  destruct (Archi.ptr64) eqn:BIT.
+  { unfold Val.cmpu_bool, to_ptr_val, to_int_val in *.
+      unfold Mem.to_ptr, Mem.to_int in *. rewrite BIT in *. simpl in *.
+      destruct v1; destruct v2; simpl in *; subst; inversion CMP1; inversion CMP2.
+      clear H0 H1. rewrite BIT in *. clear BIT. des_ifs. }
+  destruct v1; simpl in *; subst; try rewrite BIT; [clarify| | clarify | clarify | clarify | ].
+  - destruct v2; simpl in *; subst; try rewrite BIT; [clarify| | clarify | clarify | clarify | ].
+    (* int int *)
+    + unfold to_ptr_val in *. simpl in *. rewrite BIT in *. simpl in *.
+      destruct (Int.eq i Int.zero) eqn: NULL.
+      { destruct (Int.eq i0 Int.zero) eqn: NULL'.
+        - simpl in *. eapply Int.same_if_eq in NULL, NULL'. subst. clarify.
+        - destruct (Mem.denormalize (Int.unsigned i0) m) eqn:DENO2; simpl in *; eauto.
+          2:{ inv CMP1. }
+          destruct p; simpl in *. (* rewrite BIT in *.  *) (* rewrite Int.eq_true in CMP1. *) simpl in *.
+          destruct (Mem.valid_pointer m b (Ptrofs.unsigned (Ptrofs.repr z))
+                    || Mem.valid_pointer m b (Ptrofs.unsigned (Ptrofs.repr z) - 1)) eqn:WVLD.
+          2:{ inv CMP1. }
+          eapply Int.same_if_eq in NULL. subst.
+          rewrite Int.eq_sym in NULL'. inv CMP2. destruct c; simpl in *; inv CMP1; eauto.
+          (* rewrite NULL'. ss. *) }
+      destruct (Int.eq i0 Int.zero) eqn: NULL'.
+      { destruct (Mem.denormalize (Int.unsigned i) m) eqn:DENO; simpl in *; eauto.
+        2:{ inv CMP1. }
+        destruct p. simpl in *. (* rewrite Int.eq_true in CMP1. simpl in *. *)
+        destruct (Mem.valid_pointer m b (Ptrofs.unsigned (Ptrofs.repr z))
+                  || Mem.valid_pointer m b (Ptrofs.unsigned (Ptrofs.repr z) - 1)) eqn:WVLD.
+        2:{ des_ifs; clarify. }
+        rewrite BIT in *. eapply Int.same_if_eq in NULL'. subst.
+        inv CMP2. destruct c; simpl in *; inv CMP1; eauto. (* rewrite NULL. ss. *) }
+      destruct (Mem.denormalize (Int.unsigned i) m) eqn:DENO1; simpl in *; [|clarify]. destruct p. simpl in *.
+      destruct (Mem.denormalize (Int.unsigned i0) m) eqn:DENO2; simpl in *; [|clarify]. destruct p. simpl in *.
+      destruct (eq_block b b0); rewrite BIT in *.
+      (* diff block *)
+      2:{ assert (Int.eq i i0 = false).
+          { assert (BLK1: Mem.addr_in_block (Mem.mem_concrete m) (Mem.mem_access m) (Int.unsigned i) b).
+            { eapply Mem.denormalize_info in DENO1. des. subst. eapply Mem.conditions_of_addr_in_block; eauto. }
+            assert (BLK2: Mem.addr_in_block (Mem.mem_concrete m) (Mem.mem_access m) (Int.unsigned i0) b0).
+            { eapply Mem.denormalize_info in DENO2. des. subst. eapply Mem.conditions_of_addr_in_block; eauto. }
+            unfold Int.eq. clear BIT. des_ifs. rewrite e in *. exfalso. eapply n.
+            eapply Mem.no_concrete_overlap; eauto. }
+          clear BIT. des_ifs. destruct c; ss; rewrite H; clarify. }
+      (* same block *)
+      subst b0. eapply Ptrofs.modulus_eq32 in BIT; eauto.
+      fold (Mem.weak_valid_pointer m b (Ptrofs.unsigned (Ptrofs.repr z))) in CMP1.
+      fold (Mem.weak_valid_pointer m b (Ptrofs.unsigned (Ptrofs.repr z0))) in CMP1.
+      exploit Mem.denormalize_info; try eapply DENO1; eauto. i. des.
+      exploit Mem.denormalize_info; try eapply DENO2; eauto. i. des. subst.
+      rewrite CONC in CONC0. inv CONC0. do 2 (rewrite Ptrofs.unsigned_repr in CMP1; [|lia]).
+      destruct (Mem.weak_valid_pointer m b (Int.unsigned i - caddr0)
+                && Mem.weak_valid_pointer m b (Int.unsigned i0 - caddr0)) eqn:WVLD; [|clarify].
+      inv CMP1; inv CMP2.
+      assert (EQ: Ptrofs.eq (Ptrofs.repr (Int.unsigned i - caddr0)) (Ptrofs.repr (Int.unsigned i0 - caddr0))
+                  = Int.eq i i0).
+      { unfold Ptrofs.eq, Int.eq. do 2 (rewrite Ptrofs.unsigned_repr; [|lia]). des_ifs; lia. }
+      assert (LT: Ptrofs.ltu (Ptrofs.repr (Int.unsigned i - caddr0)) (Ptrofs.repr (Int.unsigned i0 - caddr0))
+                  = Int.ltu i i0).
+      { unfold Ptrofs.ltu, Int.ltu. do 2 (rewrite Ptrofs.unsigned_repr; [|lia]). des_ifs; lia. }
+      eapply lt_eq_cmpu; eauto.
+    (* int ptr *)
+    + unfold to_ptr_val, to_int_val in *. simpl in *. rewrite BIT in *. simpl in *.
+      destruct (Int.eq i Int.zero) eqn: NULL.
+      { simpl in *. (* rewrite BIT in *. eapply Int.same_if_eq in NULL. subst. rewrite Int.eq_true in CMP1. *)
+        destruct (Mem.ptr2int b (Ptrofs.unsigned i0)) eqn:P2I; simpl in *.
+        2:{ inv CMP2. }
+        destruct (Mem.valid_pointer m b (Ptrofs.unsigned i0)
+                  || Mem.valid_pointer m b (Ptrofs.unsigned i0 - 1)) eqn:WVLD.
+        2:{ inv CMP1. }
+        eapply Ptrofs.modulus_eq32 in BIT.
+        exploit Mem.ptr2int_weak_valid'; eauto; [eapply Ptrofs.unsigned_range_2|]. i. des.
+        assert (Int.eq Int.zero (Int.repr z) = false).
+        { inv INRANGE. simpl in *. unfold Int.zero. unfold Int.eq.
+          rewrite BIT in *. rewrite Int.unsigned_repr.
+          2:{ split. lia. unfold Int.max_unsigned. specialize Int.modulus_gt_one. lia. }
+          rewrite Int.unsigned_repr; [| unfold Int.max_unsigned;lia]. des_ifs; subst; lia. }
+        inv CMP2. destruct c; simpl in *; inv CMP1; rewrite H; eauto. }
+      destruct (Mem.denormalize (Int.unsigned i) m) eqn:DENO1; simpl in *; [|clarify]. destruct p. simpl in *.
+      destruct (eq_block b0 b); rewrite BIT in *.
+      2:{ eapply Ptrofs.modulus_eq32 in BIT.
+          unfold Mem.ptr2int in CMP2.
+          destruct (Mem.valid_pointer m b0 (Ptrofs.unsigned (Ptrofs.repr z))
+                    && Mem.valid_pointer m b (Ptrofs.unsigned i0)) eqn:VLD; [|clarify].
+          destruct ((Mem.mem_concrete m) ! b) eqn:CONCB; simpl in *; [|clarify].
+          simpl in *. inv CMP2.
+          assert (Int.eq i (Int.repr (z0 + Ptrofs.unsigned i0)) = false).
+          { eapply andb_prop in VLD. des. exploit Mem.denormalize_info; eauto. i. des. subst.
+            assert (BLK1: Mem.addr_in_block (Mem.mem_concrete m) (Mem.mem_access m) (Int.unsigned i) b0).
+            { eapply Mem.conditions_of_addr_in_block; eauto. }
+            assert (BLK2: Mem.addr_in_block (Mem.mem_concrete m) (Mem.mem_access m) (z0 + Ptrofs.unsigned i0) b).
+            { eapply Mem.conditions_of_addr_in_block; eauto.
+              - replace (z0 + Ptrofs.unsigned i0 - z0) with (Ptrofs.unsigned i0) by lia.
+                eapply Mem.perm_cur_max. rewrite <- Mem.valid_pointer_nonempty_perm. eauto.
+              - replace (z0 + Ptrofs.unsigned i0 - z0) with (Ptrofs.unsigned i0) by lia.
+                eapply Ptrofs.unsigned_range_2. }
+            exploit Mem._valid_pointer_range; eauto. i. inv H. unfold fst, snd in *.
+            rewrite BIT in SND. clear BIT. unfold Int.eq. des_ifs. rewrite e in *. exfalso. eapply n.
+            eapply Mem.no_concrete_overlap; eauto. rewrite Int.unsigned_repr; eauto.
+            unfold Int.max_unsigned. lia. }
+          clear BIT. des_ifs. destruct c; ss; rewrite H; clarify. }
+      (* same block *)
+      subst b0. eapply Ptrofs.modulus_eq32 in BIT; eauto.
+      fold (Mem.weak_valid_pointer m b (Ptrofs.unsigned (Ptrofs.repr z))) in CMP1.
+      fold (Mem.weak_valid_pointer m b (Ptrofs.unsigned i0)) in CMP1.
+      destruct (Mem.ptr2int b (Ptrofs.unsigned i0) m) eqn:P2I; simpl in *; inv CMP2.
+      destruct (Mem.weak_valid_pointer m b (Ptrofs.unsigned (Ptrofs.repr z))
+                && Mem.weak_valid_pointer m b (Ptrofs.unsigned i0)) eqn: WVLD; inv CMP1.
+      eapply andb_prop in WVLD. des. exploit Mem.ptr2int_weak_valid'; eauto;[eapply Ptrofs.unsigned_range_2|].
+      exploit Mem.denormalize_info; eauto. i. des; subst. inv INRANGE. simpl in *.
+      assert (EQ: Ptrofs.eq (Ptrofs.repr (Int.unsigned i - caddr0)) i0 = Int.eq i (Int.repr (caddr + Ptrofs.unsigned i0))).
+      { unfold Ptrofs.eq, Int.eq. rewrite Ptrofs.unsigned_repr; [|lia]. rewrite Int.unsigned_repr.
+        2:{ unfold Int.max_unsigned. rewrite <- BIT. lia. }
+        des_ifs; lia. }
+      assert (LT: Ptrofs.ltu (Ptrofs.repr (Int.unsigned i - caddr0)) i0 = Int.ltu i (Int.repr (caddr + Ptrofs.unsigned i0))).
+      { unfold Ptrofs.ltu, Int.ltu. rewrite Ptrofs.unsigned_repr; [|lia]. rewrite Int.unsigned_repr.
+        2:{ unfold Int.max_unsigned. rewrite <- BIT. lia. }
+        des_ifs; lia. }
+      eapply lt_eq_cmpu; eauto.
+  - destruct v2; simpl in *; subst; try rewrite BIT; [clarify| | clarify | clarify | clarify | ].
+    + unfold to_ptr_val, to_int_val in *. simpl in *. rewrite BIT in *. simpl in *.
+      destruct (Int.eq i0 Int.zero) eqn: NULL.
+      { simpl in *. eapply Int.same_if_eq in NULL. subst. (* rewrite Int.eq_true in CMP1. *)
+        destruct (Mem.ptr2int b (Ptrofs.unsigned i)) eqn:P2I; simpl in *.
+        2:{ inv CMP2. }
+        destruct (Mem.valid_pointer m b (Ptrofs.unsigned i)
+                  || Mem.valid_pointer m b (Ptrofs.unsigned i - 1)) eqn:WVLD.
+        2:{ inv CMP1. }
+        eapply Ptrofs.modulus_eq32 in BIT.
+        exploit Mem.ptr2int_weak_valid'; eauto; [eapply Ptrofs.unsigned_range_2|]. i. des.
+        assert (Int.eq Int.zero (Int.repr z) = false).
+        { inv INRANGE. simpl in *. unfold Int.zero. unfold Int.eq.
+          rewrite BIT in *. rewrite Int.unsigned_repr.
+          2:{ split. lia. unfold Int.max_unsigned. specialize Int.modulus_gt_one. lia. }
+          rewrite Int.unsigned_repr; [| unfold Int.max_unsigned;lia]. des_ifs; subst; lia. }
+        rewrite Int.eq_sym in H. inv CMP2. destruct c; simpl in *; inv CMP1; rewrite H; eauto. }
+      destruct (Mem.denormalize (Int.unsigned i0) m) eqn:DENO2; simpl in *; [|clarify]. destruct p. simpl in *.
+      destruct (eq_block b b0); try rewrite BIT in *.
+      2:{ eapply Ptrofs.modulus_eq32 in BIT.
+          unfold Mem.ptr2int in CMP2.
+          destruct (Mem.valid_pointer m b (Ptrofs.unsigned i)
+                    && Mem.valid_pointer m b0 (Ptrofs.unsigned (Ptrofs.repr z))) eqn:VLD; [|clarify].
+          destruct ((Mem.mem_concrete m) ! b) eqn:CONCB; simpl in *; [|clarify].
+          simpl in *. inv CMP2.
+          assert (Int.eq (Int.repr (z0 + Ptrofs.unsigned i)) i0 = false).
+          { eapply andb_prop in VLD. des. exploit Mem.denormalize_info; eauto. i. des. subst.
+            assert (BLK1: Mem.addr_in_block (Mem.mem_concrete m) (Mem.mem_access m) (Int.unsigned i0) b0).
+            { eapply Mem.conditions_of_addr_in_block; eauto. }
+            assert (BLK2: Mem.addr_in_block (Mem.mem_concrete m) (Mem.mem_access m) (z0 + Ptrofs.unsigned i) b).
+            { eapply Mem.conditions_of_addr_in_block; eauto.
+              - replace (z0 + Ptrofs.unsigned i - z0) with (Ptrofs.unsigned i) by lia.
+                eapply Mem.perm_cur_max. rewrite <- Mem.valid_pointer_nonempty_perm. eauto.
+              - replace (z0 + Ptrofs.unsigned i - z0) with (Ptrofs.unsigned i) by lia.
+                eapply Ptrofs.unsigned_range_2. }
+            exploit Mem._valid_pointer_range; eauto. i. inv H. unfold fst, snd in *.
+            rewrite BIT in SND. clear BIT. unfold Int.eq. des_ifs. rewrite <- e in *. exfalso. eapply n.
+            eapply Mem.no_concrete_overlap; eauto. rewrite Int.unsigned_repr in BLK1; eauto.
+            unfold Int.max_unsigned. lia. }
+          clear BIT. des_ifs. destruct c; ss; rewrite H; clarify. }
+      (* same block *)
+      subst b0. eapply Ptrofs.modulus_eq32 in BIT; eauto.
+      fold (Mem.weak_valid_pointer m b (Ptrofs.unsigned (Ptrofs.repr z))) in CMP1.
+      fold (Mem.weak_valid_pointer m b (Ptrofs.unsigned i)) in CMP1.
+      destruct (Mem.ptr2int b (Ptrofs.unsigned i) m) eqn:P2I; simpl in *; inv CMP2.
+      destruct (Mem.weak_valid_pointer m b (Ptrofs.unsigned i)
+                && Mem.weak_valid_pointer m b (Ptrofs.unsigned (Ptrofs.repr z))) eqn: WVLD; inv CMP1.
+      eapply andb_prop in WVLD. des. exploit Mem.ptr2int_weak_valid'; eauto;[eapply Ptrofs.unsigned_range_2|].
+      exploit Mem.denormalize_info; eauto. i. des; subst. inv INRANGE. simpl in *.
+      assert (EQ: Ptrofs.eq i (Ptrofs.repr (Int.unsigned i0 - caddr0)) = Int.eq (Int.repr (caddr + Ptrofs.unsigned i)) i0).
+      { unfold Ptrofs.eq, Int.eq. rewrite Ptrofs.unsigned_repr; [|lia]. rewrite Int.unsigned_repr.
+        2:{ unfold Int.max_unsigned. rewrite <- BIT. lia. }
+        des_ifs; lia. }
+      assert (LT: Ptrofs.ltu i (Ptrofs.repr (Int.unsigned i0 - caddr0)) = Int.ltu (Int.repr (caddr + Ptrofs.unsigned i)) i0).
+      { unfold Ptrofs.ltu, Int.ltu. rewrite Ptrofs.unsigned_repr; [|lia]. rewrite Int.unsigned_repr.
+        2:{ unfold Int.max_unsigned. rewrite <- BIT. lia. }
+        des_ifs; lia. }
+      eapply lt_eq_cmpu; eauto.
+    + unfold to_int_val, Mem.to_int in *. simpl in *. rewrite BIT in *.
+      destruct (eq_block b b0).
+      2:{ destruct (Mem.valid_pointer m b (Ptrofs.unsigned i)
+                    && Mem.valid_pointer m b0 (Ptrofs.unsigned i0)) eqn:VLD; inv CMP1.
+          destruct (Mem.ptr2int b (Ptrofs.unsigned i) m) eqn:P2I; simpl in *;[|clarify].
+          destruct (Mem.ptr2int b0 (Ptrofs.unsigned i0) m) eqn:P2I'; simpl in *;[|clarify].
+          inv CMP2. eapply andb_prop in VLD. des.
+          exploit Mem.ptr2int_to_denormalize; try eapply P2I; eauto.
+          { eapply Ptrofs.unsigned_range_2. }
+          exploit Mem.ptr2int_to_denormalize; try eapply P2I'; eauto.
+          { eapply Ptrofs.unsigned_range_2. }
+          i. des. exploit Mem.denormalize_info; try eapply H; eauto. exploit Mem.denormalize_info; try eapply H0; eauto.
+          i. des. subst.
+          assert (Int.eq (Int.repr z) (Int.repr z0) = false).
+          { assert (BLK1: Mem.addr_in_block (Mem.mem_concrete m) (Mem.mem_access m) z0 b0).
+            { eapply Mem.conditions_of_addr_in_block; eauto.
+              - rewrite <- OFS. eauto.
+              - rewrite <- OFS. eapply Ptrofs.unsigned_range_2. }
+            assert (BLK2: Mem.addr_in_block (Mem.mem_concrete m) (Mem.mem_access m) z b).
+            { eapply Mem.conditions_of_addr_in_block; eauto.
+              - rewrite <- OFS0. eauto.
+              - rewrite <- OFS0. eapply Ptrofs.unsigned_range_2. }
+            exploit Mem._valid_pointer_range; eauto. i. inv H2. unfold fst, snd in *.
+            eapply Ptrofs.modulus_eq32 in BIT. rewrite BIT in *.
+            unfold Int.eq. rewrite Int.unsigned_repr.
+            2:{ unfold Int.max_unsigned. lia. }
+            rewrite Int.unsigned_repr.
+            2:{ unfold Int.max_unsigned, Ptrofs.max_unsigned in *. rewrite <- BIT. lia. }
+            destruct (zeq z z0); eauto. exfalso. subst. eapply n. eapply Mem.no_concrete_overlap; eauto. }
+          clear BIT. des_ifs. destruct c; ss; rewrite H2; clarify. }
+      { subst b0. eapply Ptrofs.modulus_eq32 in BIT; eauto.
+        fold (Mem.weak_valid_pointer m b (Ptrofs.unsigned i0)) in CMP1.
+        fold (Mem.weak_valid_pointer m b (Ptrofs.unsigned i)) in CMP1.
+        destruct (Mem.ptr2int b (Ptrofs.unsigned i) m) eqn:P2I; simpl in *; inv CMP2.
+        destruct (Mem.ptr2int b (Ptrofs.unsigned i0) m) eqn:P2I'; simpl in *; inv H0.
+        destruct (Mem.weak_valid_pointer m b (Ptrofs.unsigned i)
+                  && Mem.weak_valid_pointer m b (Ptrofs.unsigned i0)) eqn:WVLD; inv CMP1.
+        eapply andb_prop in WVLD. des.
+        exploit Mem.ptr2int_weak_valid'; try eapply P2I; eauto;[eapply Ptrofs.unsigned_range_2|].
+        exploit Mem.ptr2int_weak_valid'; try eapply P2I'; eauto;[eapply Ptrofs.unsigned_range_2|].
+        i. des. subst. inv INRANGE; inv INRANGE0. simpl in *. rewrite CONC in CONC0. inv CONC0.
+        assert (EQ: Ptrofs.eq i i0 = Int.eq (Int.repr (caddr0 + Ptrofs.unsigned i)) (Int.repr (caddr0 + Ptrofs.unsigned i0))).
+        { unfold Ptrofs.eq, Int.eq. rewrite BIT in *. do 2 (rewrite Int.unsigned_repr; [|unfold Int.max_unsigned; lia]).
+          des_ifs; lia. }
+        assert (LT: Ptrofs.ltu i i0 = Int.ltu (Int.repr (caddr0 + Ptrofs.unsigned i)) (Int.repr (caddr0 + Ptrofs.unsigned i0))).
+        { unfold Ptrofs.ltu, Int.ltu. rewrite BIT in *. do 2 (rewrite Int.unsigned_repr; [|unfold Int.max_unsigned; lia]).
+          des_ifs; lia. }
+        eapply lt_eq_cmpu; eauto. }
+Qed.
+
+Lemma cmpu_no_angelic' m c v1 v2 vp vi
+    (CMP1: Val.cmpu (Mem.valid_pointer m) c (to_ptr_val m v1) (to_ptr_val m v2) = vp)
+    (CMP2: Val.cmpu (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2) = vi) :
+  <<NOANGELIC: vp = Vundef \/ vi = Vundef \/ vp = vi>>.
+Proof.
+  unfold Val.cmpu in *. unfold Val.of_optbool in *. des_ifs; eauto; exploit cmpu_no_angelic; eauto; clarify.
+Qed.
+
+Lemma cmplu_no_angelic m c v1 v2 bp bi
+    (CMP1: Val.cmplu_bool (Mem.valid_pointer m) c (to_ptr_val m v1) (to_ptr_val m v2) = Some bp)
+    (CMP2: Val.cmplu_bool (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2) = Some bi) :
+  <<NOANGELIC: bp = bi>>.
+Proof.
+  destruct (Archi.ptr64) eqn:BIT.
+  2:{ unfold Val.cmplu_bool, to_ptr_val, to_int_val in *.
+      unfold Mem.to_ptr, Mem.to_int in *. rewrite BIT in *. simpl in *.
+      destruct v1; destruct v2; simpl in *; subst; inversion CMP1; inversion CMP2.
+      clear H0 H1. rewrite BIT in *. clear BIT. des_ifs. }
+  destruct v1; simpl in *; subst; try rewrite BIT; [clarify|clarify| |clarify|clarify|].
+  - destruct v2; simpl in *; subst; try rewrite BIT; [clarify|clarify| |clarify|clarify|].
+    (* int int *)
+    + unfold to_ptr_val in *. simpl in *. rewrite BIT in *. simpl in *.
+      destruct (Int64.eq i Int64.zero) eqn: NULL.
+      { destruct (Int64.eq i0 Int64.zero) eqn: NULL'.
+        - simpl in *. eapply Int64.same_if_eq in NULL, NULL'. subst.
+          unfold Val.cmplu_bool in CMP1. unfold Vnullptr in *. des_ifs.
+        - destruct (Mem.denormalize (Int64.unsigned i0) m) eqn:DENO2; simpl in *; eauto.
+          2:{ inv CMP1. }
+          destruct p; unfold Val.cmplu_bool, Vnullptr in *; simpl in *. rewrite BIT in *. ss.
+          rewrite Int64.eq_true in CMP1.
+          (* simpl in *. *)
+          destruct (Mem.valid_pointer m b (Ptrofs.unsigned (Ptrofs.repr z))
+                    || Mem.valid_pointer m b (Ptrofs.unsigned (Ptrofs.repr z) - 1)) eqn:WVLD.
+          2:{ inv CMP1. }
+          eapply Int64.same_if_eq in NULL. subst.
+          rewrite Int64.eq_sym in NULL'. inv CMP2. destruct c; simpl in *; inv CMP1; eauto.
+          rewrite NULL'. ss. }
+      destruct (Int64.eq i0 Int64.zero) eqn: NULL'.
+      { destruct (Mem.denormalize (Int64.unsigned i) m) eqn:DENO; simpl in *; eauto.
+        2:{ inv CMP1. }
+        destruct p. unfold Val.cmplu_bool, Vnullptr in CMP1. simpl in *. rewrite BIT in *.
+        rewrite Int64.eq_true in CMP1. simpl in *.
+        destruct (Mem.valid_pointer m b (Ptrofs.unsigned (Ptrofs.repr z))
+                  || Mem.valid_pointer m b (Ptrofs.unsigned (Ptrofs.repr z) - 1)) eqn:WVLD.
+        2:{ des_ifs; clarify. }
+        eapply Int64.same_if_eq in NULL'. subst.
+        inv CMP2. destruct c; simpl in *; inv CMP1; eauto. rewrite NULL. ss. }
+      destruct (Mem.denormalize (Int64.unsigned i) m) eqn:DENO1; simpl in *; [|clarify]. destruct p. simpl in *.
+      destruct (Mem.denormalize (Int64.unsigned i0) m) eqn:DENO2; simpl in *; [|clarify]. destruct p. simpl in *.
+      destruct (eq_block b b0); rewrite BIT in *.
+      (* diff block *)
+      2:{ assert (Int64.eq i i0 = false).
+          { assert (BLK1: Mem.addr_in_block (Mem.mem_concrete m) (Mem.mem_access m) (Int64.unsigned i) b).
+            { eapply Mem.denormalize_info in DENO1. des. subst. eapply Mem.conditions_of_addr_in_block; eauto. }
+            assert (BLK2: Mem.addr_in_block (Mem.mem_concrete m) (Mem.mem_access m) (Int64.unsigned i0) b0).
+            { eapply Mem.denormalize_info in DENO2. des. subst. eapply Mem.conditions_of_addr_in_block; eauto. }
+            unfold Int64.eq. clear BIT. des_ifs. rewrite e in *. exfalso. eapply n.
+            eapply Mem.no_concrete_overlap; eauto. }
+          clear BIT. des_ifs. destruct c; ss; rewrite H; clarify. }
+      (* same block *)
+      subst b0. eapply Ptrofs.modulus_eq64 in BIT; eauto.
+      fold (Mem.weak_valid_pointer m b (Ptrofs.unsigned (Ptrofs.repr z))) in CMP1.
+      fold (Mem.weak_valid_pointer m b (Ptrofs.unsigned (Ptrofs.repr z0))) in CMP1.
+      exploit Mem.denormalize_info; try eapply DENO1; eauto. i. des.
+      exploit Mem.denormalize_info; try eapply DENO2; eauto. i. des. subst.
+      rewrite CONC in CONC0. inv CONC0. do 2 (rewrite Ptrofs.unsigned_repr in CMP1; [|lia]).
+      destruct (Mem.weak_valid_pointer m b (Int64.unsigned i - caddr0)
+                && Mem.weak_valid_pointer m b (Int64.unsigned i0 - caddr0)) eqn:WVLD; [|clarify].
+      inv CMP1; inv CMP2.
+      assert (EQ: Ptrofs.eq (Ptrofs.repr (Int64.unsigned i - caddr0)) (Ptrofs.repr (Int64.unsigned i0 - caddr0))
+                  = Int64.eq i i0).
+      { unfold Ptrofs.eq, Int64.eq. do 2 (rewrite Ptrofs.unsigned_repr; [|lia]). des_ifs; lia. }
+      assert (LT: Ptrofs.ltu (Ptrofs.repr (Int64.unsigned i - caddr0)) (Ptrofs.repr (Int64.unsigned i0 - caddr0))
+                  = Int64.ltu i i0).
+      { unfold Ptrofs.ltu, Int64.ltu. do 2 (rewrite Ptrofs.unsigned_repr; [|lia]). des_ifs; lia. }
+      eapply lt_eq_cmplu; eauto.
+    (* int ptr *)
+    + unfold to_ptr_val, to_int_val in *. simpl in *. rewrite BIT in *. simpl in *.
+      destruct (Int64.eq i Int64.zero) eqn: NULL.
+      { unfold Val.cmplu_bool, Vnullptr in *. simpl in *. rewrite BIT in *. eapply Int64.same_if_eq in NULL.
+        subst. rewrite Int64.eq_true in CMP1.
+        destruct (Mem.ptr2int b (Ptrofs.unsigned i0)) eqn:P2I; simpl in *.
+        2:{ inv CMP2. }
+        destruct (Mem.valid_pointer m b (Ptrofs.unsigned i0)
+                  || Mem.valid_pointer m b (Ptrofs.unsigned i0 - 1)) eqn:WVLD.
+        2:{ inv CMP1. }
+        eapply Ptrofs.modulus_eq64 in BIT.
+        exploit Mem.ptr2int_weak_valid'; eauto; [eapply Ptrofs.unsigned_range_2|]. i. des.
+        assert (Int64.eq Int64.zero (Int64.repr z) = false).
+        { inv INRANGE. simpl in *. unfold Int64.zero. unfold Int64.eq.
+          rewrite BIT in *. rewrite Int64.unsigned_repr.
+          2:{ split. lia. unfold Int64.max_unsigned. specialize Int64.modulus_gt_one. lia. }
+          rewrite Int64.unsigned_repr; [| unfold Int64.max_unsigned;lia]. des_ifs; subst; lia. }
+        inv CMP2. destruct c; simpl in *; inv CMP1; rewrite H; eauto. }
+      destruct (Mem.denormalize (Int64.unsigned i) m) eqn:DENO1; simpl in *; [|clarify]. destruct p. simpl in *.
+      destruct (eq_block b0 b); rewrite BIT in *.
+      2:{ eapply Ptrofs.modulus_eq64 in BIT.
+          unfold Mem.ptr2int in CMP2.
+          destruct (Mem.valid_pointer m b0 (Ptrofs.unsigned (Ptrofs.repr z))
+                    && Mem.valid_pointer m b (Ptrofs.unsigned i0)) eqn:VLD; [|clarify].
+          destruct ((Mem.mem_concrete m) ! b) eqn:CONCB; simpl in *; [|clarify].
+          simpl in *. inv CMP2.
+          assert (Int64.eq i (Int64.repr (z0 + Ptrofs.unsigned i0)) = false).
+          { eapply andb_prop in VLD. des. exploit Mem.denormalize_info; eauto. i. des. subst.
+            assert (BLK1: Mem.addr_in_block (Mem.mem_concrete m) (Mem.mem_access m) (Int64.unsigned i) b0).
+            { eapply Mem.conditions_of_addr_in_block; eauto. }
+            assert (BLK2: Mem.addr_in_block (Mem.mem_concrete m) (Mem.mem_access m) (z0 + Ptrofs.unsigned i0) b).
+            { eapply Mem.conditions_of_addr_in_block; eauto.
+              - replace (z0 + Ptrofs.unsigned i0 - z0) with (Ptrofs.unsigned i0) by lia.
+                eapply Mem.perm_cur_max. rewrite <- Mem.valid_pointer_nonempty_perm. eauto.
+              - replace (z0 + Ptrofs.unsigned i0 - z0) with (Ptrofs.unsigned i0) by lia.
+                eapply Ptrofs.unsigned_range_2. }
+            exploit Mem._valid_pointer_range; eauto. i. inv H. unfold fst, snd in *.
+            rewrite BIT in SND. clear BIT. unfold Int64.eq. des_ifs. rewrite e in *. exfalso. eapply n.
+            eapply Mem.no_concrete_overlap; eauto. rewrite Int64.unsigned_repr; eauto.
+            unfold Int64.max_unsigned. lia. }
+          clear BIT. des_ifs. destruct c; ss; rewrite H; clarify. }
+      (* same block *)
+      subst b0. eapply Ptrofs.modulus_eq64 in BIT; eauto.
+      fold (Mem.weak_valid_pointer m b (Ptrofs.unsigned (Ptrofs.repr z))) in CMP1.
+      fold (Mem.weak_valid_pointer m b (Ptrofs.unsigned i0)) in CMP1.
+      destruct (Mem.ptr2int b (Ptrofs.unsigned i0) m) eqn:P2I; simpl in *; inv CMP2.
+      destruct (Mem.weak_valid_pointer m b (Ptrofs.unsigned (Ptrofs.repr z))
+                && Mem.weak_valid_pointer m b (Ptrofs.unsigned i0)) eqn: WVLD; inv CMP1.
+      eapply andb_prop in WVLD. des. exploit Mem.ptr2int_weak_valid'; eauto;[eapply Ptrofs.unsigned_range_2|].
+      exploit Mem.denormalize_info; eauto. i. des; subst. inv INRANGE. simpl in *.
+      assert (EQ: Ptrofs.eq (Ptrofs.repr (Int64.unsigned i - caddr0)) i0 = Int64.eq i (Int64.repr (caddr + Ptrofs.unsigned i0))).
+      { unfold Ptrofs.eq, Int64.eq. rewrite Ptrofs.unsigned_repr; [|lia]. rewrite Int64.unsigned_repr.
+        2:{ unfold Int64.max_unsigned. rewrite <- BIT. lia. }
+        des_ifs; lia. }
+      assert (LT: Ptrofs.ltu (Ptrofs.repr (Int64.unsigned i - caddr0)) i0 = Int64.ltu i (Int64.repr (caddr + Ptrofs.unsigned i0))).
+      { unfold Ptrofs.ltu, Int64.ltu. rewrite Ptrofs.unsigned_repr; [|lia]. rewrite Int64.unsigned_repr.
+        2:{ unfold Int64.max_unsigned. rewrite <- BIT. lia. }
+        des_ifs; lia. }
+      eapply lt_eq_cmplu; eauto.
+  - destruct v2; simpl in *; subst; try rewrite BIT; [clarify|clarify| |clarify|clarify| ].
+    + unfold to_ptr_val, to_int_val in *. simpl in *. rewrite BIT in *. simpl in *.
+      destruct (Int64.eq i0 Int64.zero) eqn: NULL.
+      { unfold Vnullptr, Val.cmplu_bool in *.
+        simpl in *. eapply Int64.same_if_eq in NULL. rewrite BIT in *. subst. rewrite Int64.eq_true in CMP1.
+        destruct (Mem.ptr2int b (Ptrofs.unsigned i)) eqn:P2I; simpl in *.
+        2:{ inv CMP2. }
+        destruct (Mem.valid_pointer m b (Ptrofs.unsigned i)
+                  || Mem.valid_pointer m b (Ptrofs.unsigned i - 1)) eqn:WVLD.
+        2:{ inv CMP1. }
+        eapply Ptrofs.modulus_eq64 in BIT.
+        exploit Mem.ptr2int_weak_valid'; eauto; [eapply Ptrofs.unsigned_range_2|]. i. des.
+        assert (Int64.eq Int64.zero (Int64.repr z) = false).
+        { inv INRANGE. simpl in *. unfold Int64.zero. unfold Int64.eq.
+          rewrite BIT in *. rewrite Int64.unsigned_repr.
+          2:{ split. lia. unfold Int64.max_unsigned. specialize Int64.modulus_gt_one. lia. }
+          rewrite Int64.unsigned_repr; [| unfold Int64.max_unsigned;lia]. des_ifs; subst; lia. }
+        rewrite Int64.eq_sym in H. inv CMP2. destruct c; simpl in *; inv CMP1; rewrite H; eauto. }
+      destruct (Mem.denormalize (Int64.unsigned i0) m) eqn:DENO2; simpl in *; [|clarify]. destruct p. simpl in *.
+      destruct (eq_block b b0); try rewrite BIT in *.
+      2:{ eapply Ptrofs.modulus_eq64 in BIT.
+          unfold Mem.ptr2int in CMP2.
+          destruct (Mem.valid_pointer m b (Ptrofs.unsigned i)
+                    && Mem.valid_pointer m b0 (Ptrofs.unsigned (Ptrofs.repr z))) eqn:VLD; [|clarify].
+          destruct ((Mem.mem_concrete m) ! b) eqn:CONCB; simpl in *; [|clarify].
+          simpl in *. inv CMP2.
+          assert (Int64.eq (Int64.repr (z0 + Ptrofs.unsigned i)) i0 = false).
+          { eapply andb_prop in VLD. des. exploit Mem.denormalize_info; eauto. i. des. subst.
+            assert (BLK1: Mem.addr_in_block (Mem.mem_concrete m) (Mem.mem_access m) (Int64.unsigned i0) b0).
+            { eapply Mem.conditions_of_addr_in_block; eauto. }
+            assert (BLK2: Mem.addr_in_block (Mem.mem_concrete m) (Mem.mem_access m) (z0 + Ptrofs.unsigned i) b).
+            { eapply Mem.conditions_of_addr_in_block; eauto.
+              - replace (z0 + Ptrofs.unsigned i - z0) with (Ptrofs.unsigned i) by lia.
+                eapply Mem.perm_cur_max. rewrite <- Mem.valid_pointer_nonempty_perm. eauto.
+              - replace (z0 + Ptrofs.unsigned i - z0) with (Ptrofs.unsigned i) by lia.
+                eapply Ptrofs.unsigned_range_2. }
+            exploit Mem._valid_pointer_range; eauto. i. inv H. unfold fst, snd in *.
+            rewrite BIT in SND. clear BIT. unfold Int64.eq. des_ifs. rewrite <- e in *. exfalso. eapply n.
+            eapply Mem.no_concrete_overlap; eauto. rewrite Int64.unsigned_repr in BLK1; eauto.
+            unfold Int64.max_unsigned. lia. }
+          clear BIT. des_ifs. destruct c; ss; rewrite H; clarify. }
+      (* same block *)
+      subst b0. eapply Ptrofs.modulus_eq64 in BIT; eauto.
+      fold (Mem.weak_valid_pointer m b (Ptrofs.unsigned (Ptrofs.repr z))) in CMP1.
+      fold (Mem.weak_valid_pointer m b (Ptrofs.unsigned i)) in CMP1.
+      destruct (Mem.ptr2int b (Ptrofs.unsigned i) m) eqn:P2I; simpl in *; inv CMP2.
+      destruct (Mem.weak_valid_pointer m b (Ptrofs.unsigned i)
+                && Mem.weak_valid_pointer m b (Ptrofs.unsigned (Ptrofs.repr z))) eqn: WVLD; inv CMP1.
+      eapply andb_prop in WVLD. des. exploit Mem.ptr2int_weak_valid'; eauto;[eapply Ptrofs.unsigned_range_2|].
+      exploit Mem.denormalize_info; eauto. i. des; subst. inv INRANGE. simpl in *.
+      assert (EQ: Ptrofs.eq i (Ptrofs.repr (Int64.unsigned i0 - caddr0)) = Int64.eq (Int64.repr (caddr + Ptrofs.unsigned i)) i0).
+      { unfold Ptrofs.eq, Int64.eq. rewrite Ptrofs.unsigned_repr; [|lia]. rewrite Int64.unsigned_repr.
+        2:{ unfold Int64.max_unsigned. rewrite <- BIT. lia. }
+        des_ifs; lia. }
+      assert (LT: Ptrofs.ltu i (Ptrofs.repr (Int64.unsigned i0 - caddr0)) = Int64.ltu (Int64.repr (caddr + Ptrofs.unsigned i)) i0).
+      { unfold Ptrofs.ltu, Int64.ltu. rewrite Ptrofs.unsigned_repr; [|lia]. rewrite Int64.unsigned_repr.
+        2:{ unfold Int64.max_unsigned. rewrite <- BIT. lia. }
+        des_ifs; lia. }
+      eapply lt_eq_cmplu; eauto.
+    + unfold to_int_val, Mem.to_int in *. simpl in *. rewrite BIT in *.
+      destruct (eq_block b b0).
+      2:{ destruct (Mem.valid_pointer m b (Ptrofs.unsigned i)
+                    && Mem.valid_pointer m b0 (Ptrofs.unsigned i0)) eqn:VLD; inv CMP1.
+          destruct (Mem.ptr2int b (Ptrofs.unsigned i) m) eqn:P2I; simpl in *;[|clarify].
+          destruct (Mem.ptr2int b0 (Ptrofs.unsigned i0) m) eqn:P2I'; simpl in *;[|clarify].
+          inv CMP2. eapply andb_prop in VLD. des.
+          exploit Mem.ptr2int_to_denormalize; try eapply P2I; eauto.
+          { eapply Ptrofs.unsigned_range_2. }
+          exploit Mem.ptr2int_to_denormalize; try eapply P2I'; eauto.
+          { eapply Ptrofs.unsigned_range_2. }
+          i. des. exploit Mem.denormalize_info; try eapply H; eauto. exploit Mem.denormalize_info; try eapply H0; eauto.
+          i. des. subst.
+          assert (Int64.eq (Int64.repr z) (Int64.repr z0) = false).
+          { assert (BLK1: Mem.addr_in_block (Mem.mem_concrete m) (Mem.mem_access m) z0 b0).
+            { eapply Mem.conditions_of_addr_in_block; eauto.
+              - rewrite <- OFS. eauto.
+              - rewrite <- OFS. eapply Ptrofs.unsigned_range_2. }
+            assert (BLK2: Mem.addr_in_block (Mem.mem_concrete m) (Mem.mem_access m) z b).
+            { eapply Mem.conditions_of_addr_in_block; eauto.
+              - rewrite <- OFS0. eauto.
+              - rewrite <- OFS0. eapply Ptrofs.unsigned_range_2. }
+            exploit Mem._valid_pointer_range; eauto. i. inv H2. unfold fst, snd in *.
+            eapply Ptrofs.modulus_eq64 in BIT. rewrite BIT in *.
+            unfold Int64.eq. rewrite Int64.unsigned_repr.
+            2:{ unfold Int64.max_unsigned. lia. }
+            rewrite Int64.unsigned_repr.
+            2:{ unfold Int64.max_unsigned, Ptrofs.max_unsigned in *. rewrite <- BIT. lia. }
+            destruct (zeq z z0); eauto. exfalso. subst. eapply n. eapply Mem.no_concrete_overlap; eauto. }
+          clear BIT. des_ifs. destruct c; ss; rewrite H2; clarify. }
+      { subst b0. eapply Ptrofs.modulus_eq64 in BIT; eauto.
+        fold (Mem.weak_valid_pointer m b (Ptrofs.unsigned i0)) in CMP1.
+        fold (Mem.weak_valid_pointer m b (Ptrofs.unsigned i)) in CMP1.
+        destruct (Mem.ptr2int b (Ptrofs.unsigned i) m) eqn:P2I; simpl in *; inv CMP2.
+        destruct (Mem.ptr2int b (Ptrofs.unsigned i0) m) eqn:P2I'; simpl in *; inv H0.
+        destruct (Mem.weak_valid_pointer m b (Ptrofs.unsigned i)
+                  && Mem.weak_valid_pointer m b (Ptrofs.unsigned i0)) eqn:WVLD; inv CMP1.
+        eapply andb_prop in WVLD. des.
+        exploit Mem.ptr2int_weak_valid'; try eapply P2I; eauto;[eapply Ptrofs.unsigned_range_2|].
+        exploit Mem.ptr2int_weak_valid'; try eapply P2I'; eauto;[eapply Ptrofs.unsigned_range_2|].
+        i. des. subst. inv INRANGE; inv INRANGE0. simpl in *. rewrite CONC in CONC0. inv CONC0.
+        assert (EQ: Ptrofs.eq i i0 = Int64.eq (Int64.repr (caddr0 + Ptrofs.unsigned i)) (Int64.repr (caddr0 + Ptrofs.unsigned i0))).
+        { unfold Ptrofs.eq, Int64.eq. rewrite BIT in *. do 2 (rewrite Int64.unsigned_repr; [|unfold Int64.max_unsigned; lia]).
+          des_ifs; lia. }
+        assert (LT: Ptrofs.ltu i i0 = Int64.ltu (Int64.repr (caddr0 + Ptrofs.unsigned i)) (Int64.repr (caddr0 + Ptrofs.unsigned i0))).
+        { unfold Ptrofs.ltu, Int64.ltu. rewrite BIT in *. do 2 (rewrite Int64.unsigned_repr; [|unfold Int64.max_unsigned; lia]).
+          des_ifs; lia. }
+        eapply lt_eq_cmplu; eauto. }
+Qed.
+
+Lemma cmplu_no_angelic' m c v1 v2 vp vi
+    (CMP1: Val.cmplu (Mem.valid_pointer m) c (to_ptr_val m v1) (to_ptr_val m v2) = Some vp)
+    (CMP2: Val.cmplu (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2) = Some vi) :
+  <<NOANGELIC: vp = vi>>.
+Proof.
+  unfold Val.cmplu in *. unfold option_map, Val.of_bool in *. des_ifs; eauto; exploit cmplu_no_angelic; eauto; clarify.
+Qed.
+
+Definition is_only_int (v: val) : bool :=
+  match v with
+  | Vundef | Vint _ | Vlong _ => true | _ => false
+  end.
+
+Lemma psub_is_only_int v1 v2 : <<ONLYINT: is_only_int (Val.psub v1 v2) = true>>.
+Proof. unfold Val.psub. des_ifs. Qed.
+
+Lemma psubl_is_only_int v1 v2 : <<ONLYINT: is_only_int (Val.psubl v1 v2) = true>>.
+Proof. unfold Val.psubl. des_ifs. Qed.
+
+Lemma cmpu_is_only_int m c v1 v2 :
+  <<ONLYINT: is_only_int (Val.cmpu (Mem.valid_pointer m) c v1 v2) = true>>.
+Proof. unfold Val.cmpu, Val.of_bool, Val.of_optbool. des_ifs. Qed.
+
+Lemma cmplu_is_only_int m c v1 v2 v
+    (CMP: Val.cmplu (Mem.valid_pointer m) c v1 v2 = Some v) :
+  <<ONLYINT: is_only_int v = true >>.
+Proof. unfold Val.cmplu, Val.of_bool, Val.of_optbool, option_map in *. des_ifs. Qed.
+
+Definition val_join (v1 v2: val) : val :=
+  match v1, v2 with
+  | Vundef, _ => v2 | _, Vundef => v1
+  | Vint n1, Vint n2 => if Int.eq n1 n2 then Vint n1 else Vundef
+  | Vlong n1, Vlong n2 => if Int64.eq n1 n2 then Vlong n1 else Vundef
+  | _, _ => Vundef
+  end.
+
+Lemma val_join_same_val v
+    (IRET: is_only_int v = true) :        
+  <<SAME: val_join v v = v>>.
+Proof. destruct v; ss; [rewrite Int.eq_true|rewrite Int64.eq_true]; eauto. Qed.
+
+Lemma val_join_angelic_vp vp vi
+    (ISINT: is_only_int vp = true)
+    (NOANGELIC: vp = Vundef \/ vi = Vundef \/ vi = vp)
+    (SUCCSS: vp <> Vundef) :
+  <<VAL: val_join vp vi = vp>>.
+Proof.
+  des; subst; clarify; unfold val_join; des_ifs.
+  - rewrite Int.eq_true in Heq. clarify.
+  - rewrite Int64.eq_true in Heq. clarify.
+Qed.
+
+Lemma val_join_angelic_vi vp vi
+    (ISINT: is_only_int vi = true)
+    (NOANGELIC: vp = Vundef \/ vi = Vundef \/ vi = vp)
+    (SUCCSS: vi <> Vundef) :
+  <<VAL: val_join vp vi = vi>>.
+Proof.
+  des; subst; clarify; unfold val_join; des_ifs.
+  - rewrite Int.eq_true in Heq. clarify.
+  - rewrite Int64.eq_true in Heq. clarify.
+Qed.
+
+Definition bool_join (b1 b2: bool) : option bool:= if eqb b1 b2 then Some b1 else None.
+
+Lemma bool_join_angelic b1 b2
+    (NOANGELIC: b1 = b2) :
+  <<BOOL: bool_join b1 b2 = Some b1>>.
+Proof. subst. unfold bool_join. rewrite eqb_reflx. eauto. Qed.
+
+Section OPTJOIN.
+
+Set Implicit Arguments.
+Variable R: Type.
+Variable rjoin : R -> R -> option R.
+
+Definition opt_join (or1 or2: option R) : option R :=
+  match or1, or2 with
+  | Some r1, Some r2 => rjoin r1 r2
+  | None, Some r2 => Some r2
+  | Some r1, None => Some r1
+  | _, _ => None
+  end.
+
+End OPTJOIN.
+
+Definition val_optjoin (ov1 ov2: option val) : option val :=
+  opt_join (fun v1 v2 => Some (val_join v1 v2)) ov1 ov2.
+
+Lemma val_optjoin_same_val v
+    (IRET: is_only_int v = true) :
+  <<SAME: val_optjoin (Some v) (Some v) = Some v>>.
+Proof. unfold val_optjoin. ss. rewrite val_join_same_val; eauto. Qed.
+
+Lemma val_optjoin_angelic_vp vp ovi
+    (IRET: is_only_int vp = true)
+    (NOANGELIC: ovi = Some vp \/ ovi = Some Vundef \/ ovi = None)
+    (SUCCESS: vp <> Vundef) :
+  <<SAME: val_optjoin (Some vp) ovi = Some vp>>.
+Proof.
+  des; subst; ss.
+  - rewrite val_join_same_val; eauto.
+  - unfold val_join. ss. des_ifs.
+Qed.
+
+Lemma val_optjoin_angelic_vi vi ovp
+    (IRET: is_only_int vi = true)
+    (NOANGELIC: ovp = Some vi \/ ovp = Some Vundef \/ ovp = None)
+    (SUCCESS: vi <> Vundef) :
+  <<SAME: val_optjoin ovp (Some vi) = Some vi>>.
+Proof. des; subst; ss. rewrite val_join_same_val; eauto. Qed.
+
+Definition bool_optjoin (ob1 ob2: option bool) : option bool := opt_join bool_join ob1 ob2.
+
+Lemma bool_optjoin_same_bool b:
+  <<SAME: bool_optjoin (Some b) (Some b) = Some b>>.
+Proof. destruct b; ss. Qed.
+
+Lemma bool_optjoin_angelic_vp vp ovi
+    (NOANGELIC: ovi = Some vp \/ ovi = None) :
+  <<SAME: bool_optjoin (Some vp) ovi = Some vp>>.
+Proof. des; subst; ss. eapply bool_optjoin_same_bool. Qed.
+
+Lemma bool_optjoin_angelic_vi vi ovp
+    (NOANGELIC: ovp = Some vi \/ ovp = None) :
+  <<SAME: bool_optjoin ovp (Some vi) = Some vi>>.
+Proof. des; subst; ss. eapply bool_optjoin_same_bool. Qed.
+
+(** Pointer Binary Operation Join *)
+
+Section PTRBINJOIN.
+
+Variable m : mem.
+
+Definition psub_join (v1 v2: val) : val :=
+  val_join (Val.psub (to_ptr_val m v1) (to_ptr_val m v2)) (Val.psub (to_int_val m v1) (to_int_val m v2)).
+
+Definition psubl_join (v1 v2: val) : val :=
+  val_join (Val.psubl (to_ptr_val m v1) (to_ptr_val m v2)) (Val.psubl (to_int_val m v1) (to_int_val m v2)).
+
+Definition cmpu_join (c: comparison) (v1 v2: val) : option bool :=
+  bool_optjoin (Val.cmpu_bool (Mem.valid_pointer m) c (to_ptr_val m v1) (to_ptr_val m v2))
+               (Val.cmpu_bool (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2)).
+
+Definition cmplu_join (c: comparison) (v1 v2: val) : option bool :=
+  bool_optjoin (Val.cmplu_bool (Mem.valid_pointer m) c (to_ptr_val m v1) (to_ptr_val m v2))
+               (Val.cmplu_bool (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2)).
+
+Definition cmpu_join_common (c: comparison) (v1 v2: val) : option bool :=
+  match v1, v2 with
+  | Vptr _ _, Vptr _ _ | Vint _, Vint _ => Val.cmpu_bool (Mem.valid_pointer m) c v1 v2
+  | Vptr _ _, Vint n | Vint n, Vptr _ _ => if Int.eq n Int.zero
+                                          then Val.cmpu_bool (Mem.valid_pointer m) c v1 v2
+                                          else cmpu_join c v1 v2
+  | _, _ => None
+  end.
+
+Definition cmplu_join_common (c: comparison) (v1 v2: val) : option bool :=
+  match v1, v2 with
+  | Vptr _ _, Vptr _ _ | Vlong _, Vlong _ => Val.cmplu_bool (Mem.valid_pointer m) c v1 v2
+  | Vptr _ _, Vlong n | Vlong n, Vptr _ _ => if Int64.eq n Int64.zero
+                                            then Val.cmplu_bool (Mem.valid_pointer m) c v1 v2
+                                            else cmplu_join c v1 v2
+  | _, _ => None
+  end.
+
+(* Definition cmpu_join' (c: comparison) (v1 v2: val) : val := *)
+(*   val_join (Val.cmpu (Mem.valid_pointer m) c (to_ptr_val m v1) (to_ptr_val m v2)) *)
+(*            (Val.cmpu (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2)). *)
+
+(* Definition cmplu_join' (c: comparison) (v1 v2: val) : option val := *)
+(*   val_optjoin (Val.cmplu (Mem.valid_pointer m) c (to_ptr_val m v1) (to_ptr_val m v2)) *)
+(*               (Val.cmplu (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2)). *)
+
+Lemma to_ptr_val_add_comm_l1 b ofs n:
+  to_ptr_val m (Val.addl (Vptr b ofs) n) = Val.addl (to_ptr_val m (Vptr b ofs)) n.
+Proof. unfold Val.addl, to_ptr_val; destruct n; simpl; eauto. Qed.
+
+Lemma to_ptr_val_add_comm_l2 b ofs n:
+  to_ptr_val m (Val.addl n (Vptr b ofs)) = Val.addl n (to_ptr_val m (Vptr b ofs)).
+Proof. unfold Val.addl, to_ptr_val; destruct n; simpl; eauto. Qed.
+
+Lemma psubl_always_captured1 i b ofs n
+    (SUCCESS: psubl_join (Vlong i) (Vptr b ofs) = Vlong n) :
+  exists caddr, (Mem.mem_concrete m) ! b = Some caddr.
+Proof.
+  unfold psubl_join in *. unfold val_join in *. des_ifs.
+  - unfold Val.psubl in SUCCESS. des_ifs. unfold to_int_val in Heq1. ss. des_ifs.
+    unfold Mem.ptr2int in Heq3. des_ifs. eauto.
+  - unfold Val.psubl in Heq. des_ifs. unfold to_ptr_val in *. ss. des_ifs_safe.
+    ss. inv Heq1. eapply Mem.denormalize_info in Heq4. des; eauto.
+  - unfold Val.psubl in Heq0. des_ifs. unfold to_int_val in Heq3. ss. des_ifs.
+    unfold Mem.ptr2int in Heq0. des_ifs. eauto.
+Qed.
+
+Lemma cmplu_always_captured1 c i b ofs bi
+    (NOTEQ: c <> Ceq /\ c <> Cne)
+    (NOTNULL: Int64.eq i Int64.zero = false)
+    (SUCCESS: cmplu_join c (Vlong i) (Vptr b ofs) = Some bi) :
+  exists caddr, (Mem.mem_concrete m) ! b = Some caddr.
+Proof.
+  unfold cmplu_join in *. unfold bool_optjoin in *.
+  destruct (Val.cmplu_bool (Mem.valid_pointer m) c (to_ptr_val m (Vlong i)) (to_ptr_val m (Vptr b ofs))) eqn:CMP1;
+  destruct (Val.cmplu_bool (Mem.valid_pointer m) c (to_int_val m (Vlong i)) (to_int_val m (Vptr b ofs))) eqn:CMP2; ss.
+  - rewrite NOTNULL in *. ss. des_ifs_safe. unfold to_int_val in Heq. ss. des_ifs.
+    unfold Mem.ptr2int in Heq0. des_ifs. eauto.
+  - clear CMP2. unfold Val.cmplu_bool in CMP1. des_ifs.
+    { unfold to_ptr_val in Heq. ss. des_ifs. }
+    { unfold to_ptr_val, Mem.to_ptr in *. des_ifs. ss. clarify.
+      eapply Mem.denormalize_info in Heq4. des. eauto. }
+    { destruct c; ss; des; clarify. }
+  - clear CMP1. rewrite NOTNULL in *. ss. des_ifs_safe. unfold to_int_val in Heq. ss. des_ifs.
+    unfold Mem.ptr2int in Heq0. des_ifs. eauto.
+Qed.
+
+Lemma cmplu_always_captured1' c i b ofs caddr
+    (CAP: (Mem.mem_concrete m) ! b = Some caddr) :
+  <<SUCCESS: cmplu_join c (Vlong i) (Vptr b ofs) = Some (Int64.cmpu c i (Int64.repr (caddr + Ptrofs.unsigned ofs)))>>.
+Proof.
+  unfold cmplu_join.
+  destruct (Val.cmplu_bool (Mem.valid_pointer m) c (to_ptr_val m (Vlong i)) (to_ptr_val m (Vptr b ofs))) eqn: CMPP;
+  destruct (Val.cmplu_bool (Mem.valid_pointer m) c (to_int_val m (Vlong i)) (to_int_val m (Vptr b ofs))) eqn: CMPI.
+  - rewrite bool_optjoin_angelic_vi; eauto.
+    { ss. unfold to_int_val in CMPI; ss. unfold Mem.ptr2int in CMPI. des_ifs. ss. inv Heq. eauto. }
+    left. f_equal. eapply cmplu_no_angelic; eauto.
+  - exfalso. unfold to_int_val in CMPI; ss. unfold Mem.ptr2int in CMPI. des_ifs.
+  - rewrite bool_optjoin_angelic_vi; eauto.
+    unfold to_int_val in CMPI; ss. unfold Mem.ptr2int in CMPI. des_ifs. ss. inv Heq. eauto.
+  - exfalso. unfold to_int_val in CMPI; ss. unfold Mem.ptr2int in CMPI. des_ifs.
+Qed.
+
+Lemma psubl_always_captured2 i b ofs n
+    (SUCCESS: psubl_join (Vptr b ofs) (Vlong i) = Vlong n) :
+  exists caddr, (Mem.mem_concrete m) ! b = Some caddr.
+Proof.
+  unfold psubl_join in *. unfold val_join in *. des_ifs.
+  - unfold Val.psubl in SUCCESS. des_ifs. unfold to_int_val in Heq0. ss. des_ifs_safe.
+    unfold Mem.ptr2int in Heq3. des_ifs_safe. eauto.
+  - unfold Val.psubl in Heq. des_ifs. unfold to_ptr_val in *. ss. des_ifs_safe.
+    ss. inv Heq2. eapply Mem.denormalize_info in Heq4. des; eauto.
+  - unfold Val.psubl in Heq0. des_ifs. unfold to_int_val in Heq2. ss. des_ifs.
+    unfold Mem.ptr2int in Heq0. des_ifs. eauto.
+Qed.
+
+Lemma cmplu_always_captured2 c i b ofs bi
+    (NOTEQ: c <> Ceq /\ c <> Cne)
+    (NOTNULL: Int64.eq i Int64.zero = false)
+    (SUCCESS: cmplu_join c (Vptr b ofs) (Vlong i) = Some bi) :
+  exists caddr, (Mem.mem_concrete m) ! b = Some caddr.
+Proof.
+  unfold cmplu_join in *. unfold bool_optjoin in *.
+  destruct (Val.cmplu_bool (Mem.valid_pointer m) c (to_int_val m (Vptr b ofs)) (to_int_val m (Vlong i))) eqn:CMPI;
+  destruct (Val.cmplu_bool (Mem.valid_pointer m) c (to_ptr_val m (Vptr b ofs)) (to_ptr_val m (Vlong i))) eqn:CMPP; ss.
+  - clear CMPP. unfold Val.cmplu_bool in CMPI. des_ifs.
+    { unfold to_int_val in Heq. ss. des_ifs.
+      unfold Mem.ptr2int in Heq1. des_ifs. eauto. }
+    { unfold to_int_val in Heq. ss. des_ifs. }
+  - clear CMPP. unfold Val.cmplu_bool in CMPI. des_ifs.
+    { unfold to_int_val in Heq. ss. des_ifs.
+      unfold Mem.ptr2int in Heq1. des_ifs. eauto. }
+    { unfold to_int_val in Heq. ss. des_ifs. }
+  - clear CMPI. des_ifs.
+    { destruct c; ss; des; clarify. }
+    { unfold to_ptr_val, Mem.to_ptr in *. des_ifs. ss. clarify.
+      eapply Mem.denormalize_info in Heq3. des. eauto. }
+    { destruct c; ss; des; clarify. }
+Qed.
+
+Lemma cmplu_always_captured2' c i b ofs caddr
+    (CAP: (Mem.mem_concrete m) ! b = Some caddr) :
+  <<SUCCESS: cmplu_join c (Vptr b ofs) (Vlong i) = Some (Int64.cmpu c (Int64.repr (caddr + Ptrofs.unsigned ofs)) i)>>.
+Proof.
+  unfold cmplu_join.
+  destruct (Val.cmplu_bool (Mem.valid_pointer m) c (to_ptr_val m (Vptr b ofs)) (to_ptr_val m (Vlong i))) eqn: CMPP;
+  destruct (Val.cmplu_bool (Mem.valid_pointer m) c (to_int_val m (Vptr b ofs)) (to_int_val m (Vlong i))) eqn: CMPI.
+  - rewrite bool_optjoin_angelic_vi; eauto.
+    { ss. unfold to_int_val in CMPI; ss. unfold Mem.ptr2int in CMPI. des_ifs. }
+    left. f_equal. eapply cmplu_no_angelic; eauto.
+  - exfalso. unfold to_int_val in CMPI; ss. unfold Mem.ptr2int in CMPI. des_ifs.
+  - rewrite bool_optjoin_angelic_vi; eauto.
+    unfold to_int_val in CMPI; ss. unfold Mem.ptr2int in CMPI. des_ifs.
+  - exfalso. unfold to_int_val in CMPI; ss. unfold Mem.ptr2int in CMPI. des_ifs.
+Qed.
+
+Lemma psubl_always_captured1' b caddr i ofs
+    (CAP: (Mem.mem_concrete m) ! b = Some caddr) :
+  <<SUCCESS: psubl_join (Vlong i) (Vptr b ofs) = Vlong (Int64.sub i (Int64.repr (caddr + Ptrofs.unsigned ofs)))>>.
+Proof.
+  unfold psubl_join. unfold val_join.
+  assert (Val.psubl (to_int_val m (Vlong i)) (to_int_val m (Vptr b ofs)) 
+          = Vlong (Int64.sub i (Int64.repr (caddr + Ptrofs.unsigned ofs)))).
+  { unfold to_int_val; ss. unfold Mem.ptr2int. rewrite CAP. des_ifs. }
+  exploit psubl_wrapper_no_angelic; eauto. i. des; des_ifs.
+  rewrite Int64.eq_true in Heq1. clarify.
+Qed.
+
+Lemma psubl_always_captured2' b caddr i ofs
+    (CAP: (Mem.mem_concrete m) ! b = Some caddr) :
+  <<SUCCESS: psubl_join (Vptr b ofs) (Vlong i) = Vlong (Int64.sub (Int64.repr (caddr + Ptrofs.unsigned ofs)) i)>>.
+Proof.
+  unfold psubl_join. unfold val_join.
+  assert (Val.psubl (to_int_val m (Vptr b ofs)) (to_int_val m (Vlong i))
+          = Vlong (Int64.sub (Int64.repr (caddr + Ptrofs.unsigned ofs)) i)).
+  { unfold to_int_val; ss. unfold Mem.ptr2int. rewrite CAP. ss. }
+  exploit psubl_wrapper_no_angelic; eauto. i. des; des_ifs.
+  rewrite Int64.eq_true in Heq1. clarify.
+Qed.
+
+Lemma psub_always_captured1' b caddr i ofs
+    (SF: Archi.ptr64 = false)
+    (CAP: (Mem.mem_concrete m) ! b = Some caddr) :
+  <<SUCCESS: psub_join (Vint i) (Vptr b ofs) = Vint (Int.sub i (Int.repr (caddr + Ptrofs.unsigned ofs)))>>.
+Proof.
+  unfold psub_join, val_join.
+  assert (Val.psub (to_int_val m (Vint i)) (to_int_val m (Vptr b ofs)) 
+          = Vint (Int.sub i (Int.repr (caddr + Ptrofs.unsigned ofs)))).
+  { unfold to_int_val; simpl. unfold Mem.ptr2int. rewrite SF, CAP. des_ifs. }
+  eapply psub_wrapper_no_angelic in H; [|eauto]. i.
+  unfold to_int_val, Mem.to_int in *; simpl in *. unfold Mem.ptr2int in *. rewrite SF in *.
+  clear SF. des; des_ifs. ss. inv Heq0. ss.
+Qed.
+
+Lemma psub_always_captured2' b caddr i ofs
+  (SF: Archi.ptr64 = false)
+  (CAP: (Mem.mem_concrete m) ! b = Some caddr) :
+  <<SUCCESS: psub_join (Vptr b ofs) (Vint i) = Vint (Int.sub (Int.repr (caddr + Ptrofs.unsigned ofs)) i)>>.
+Proof.
+  unfold psub_join, val_join.
+  assert (Val.psub (to_int_val m (Vptr b ofs)) (to_int_val m (Vint i))
+          = Vint (Int.sub (Int.repr (caddr + Ptrofs.unsigned ofs)) i)).
+  { unfold to_int_val; simpl. unfold Mem.ptr2int. rewrite SF, CAP. des_ifs. }
+  eapply psub_wrapper_no_angelic in H; [|eauto]. i.
+  unfold to_int_val, Mem.to_int in *; simpl in *. unfold Mem.ptr2int in *.
+  rewrite CAP, SF in *. simpl in *. rewrite SF.
+  simpl in *. clear SF. des; rewrite H.
+  - reflexivity.
+  - inv H.
+  - rewrite <- H. rewrite Int.eq_true. reflexivity.
+Qed.
+
+Lemma psubl_always_captured1_undef b i ofs
+    (CAP: (Mem.mem_concrete m) ! b = None) :
+  <<FAIL: psubl_join (Vlong i) (Vptr b ofs) = Vundef>>.
+Proof.
+  unfold psubl_join, to_int_val. ss. unfold Mem.ptr2int. rewrite CAP. ss.
+  destruct (to_ptr_val m (Vlong i)) eqn:TOPTR; ss.
+  unfold to_ptr_val in TOPTR. ss. des_ifs. ss. clarify.
+  eapply Mem.denormalize_info in Heq2. des. clarify.
+Qed.
+
+Lemma psubl_always_captured2_undef b i ofs
+    (CAP: (Mem.mem_concrete m) ! b = None) :
+  <<FAIL: psubl_join (Vptr b ofs) (Vlong i) = Vundef>>.
+Proof.
+  unfold psubl_join, to_int_val. ss. unfold Mem.ptr2int. rewrite CAP. ss.
+  destruct (to_ptr_val m (Vlong i)) eqn:TOPTR; ss.
+  unfold to_ptr_val in TOPTR. ss. des_ifs. ss. clarify.
+  eapply Mem.denormalize_info in Heq2. des. clarify.
+Qed.
+
+Lemma psub_always_captured1_undef b i ofs
+    (SF: Archi.ptr64 = false)
+    (CAP: (Mem.mem_concrete m) ! b = None) :
+  <<FAIL: psub_join (Vint i) (Vptr b ofs) = Vundef>>.
+Proof.
+  unfold psub_join, to_int_val. simpl. unfold Mem.ptr2int. rewrite SF, CAP. simpl.
+  destruct (to_ptr_val m (Vint i)) eqn:TOPTR;
+  unfold to_ptr_val in *; simpl in *; try rewrite SF in *; clear SF; auto.
+  simpl in *. des_ifs. eapply Mem.denormalize_info in Heq0. des. ss; clarify.
+Qed.
+
+Lemma psub_always_captured2_undef b i ofs
+    (SF: Archi.ptr64 = false)
+    (CAP: (Mem.mem_concrete m) ! b = None) :
+  <<FAIL: psub_join (Vptr b ofs) (Vint i) = Vundef>>.
+Proof.
+  unfold psub_join, to_int_val. simpl. unfold Mem.ptr2int. rewrite SF, CAP. simpl.
+  destruct (to_ptr_val m (Vint i)) eqn:TOPTR;
+  unfold to_ptr_val in *; simpl in *; try rewrite SF in *; clear SF; auto.
+  simpl in *. des_ifs. eapply Mem.denormalize_info in Heq0. des. ss; clarify.
+Qed.
+
+Lemma psubl_join_addl_l v1 v2 i:
+  psubl_join (Val.addl v1 (Vlong i)) v2 = Val.addl (psubl_join v1 v2) (Vlong i).
+Proof.
+  destruct v1; simpl; eauto.
+  - rename i0 into n1. destruct v2; try (by (unfold psubl_join, to_ptr_val, to_int_val; ss; des_ifs)).
+    (* long long *)
+    + rename i0 into n2. unfold psubl_join.
+      assert (Val.psubl (to_int_val m (Vlong (Int64.add n1 i))) (to_int_val m (Vlong n2))
+              = Vlong (Int64.sub (Int64.add n1 i) n2)) by ss.
+      assert (Val.psubl (to_int_val m (Vlong n1)) (to_int_val m (Vlong n2)) = Vlong (Int64.sub n1 n2)) by ss.
+      exploit psubl_wrapper_no_angelic; try eapply H; eauto.
+      exploit psubl_wrapper_no_angelic; try eapply H0; eauto. i.
+      exploit val_join_angelic_vi; try eapply H1; try (by ss). i.
+      exploit val_join_angelic_vi; try eapply H2; try (by ss). i. clear H1 H2. des.
+      unfold to_int_val. ss. destruct Archi.ptr64 eqn:SF; [|clarify].
+      rewrite H3, H4. ss. f_equal. rewrite Int64.sub_add_l. eauto.
+    (* long ptr *)
+    + rename b into b2. rename i0 into ofs2.
+      destruct ((Mem.mem_concrete m) ! b2) eqn:CONC.
+      { erewrite psubl_always_captured1'; eauto. erewrite psubl_always_captured1'; eauto.
+        ss. f_equal. rewrite Int64.sub_add_l. eauto. }
+      rewrite psubl_always_captured1_undef; eauto. rewrite psubl_always_captured1_undef; eauto.
+  - rename b into b1. rename i0 into ofs1. destruct Archi.ptr64 eqn:SF; [|clarify].
+    destruct v2; try (by (unfold psubl_join, to_ptr_val, to_int_val; ss; des_ifs)).
+    (* ptr long *)
+    + destruct ((Mem.mem_concrete m) ! b1) eqn:CONC.
+      { erewrite psubl_always_captured2'; eauto. erewrite psubl_always_captured2'; eauto.
+        ss. f_equal. rewrite <- Int64.sub_add_l.
+        replace (Int64.repr (z + Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.of_int64 i))))
+          with (Int64.add (Int64.repr (z + Ptrofs.unsigned ofs1)) i); eauto.
+        { unfold Int64.add. eapply Int64.same_if_eq. unfold Ptrofs.add. unfold Ptrofs.of_int64.
+          do 2 rewrite Ptrofs.unsigned_repr_eq. unfold Int64.eq. des_ifs. exfalso. eapply n.
+          do 3 rewrite Int64.unsigned_repr_eq. rewrite Ptrofs.modulus_eq64; eauto.
+          rewrite (Zplus_mod_idemp_r (Int64.unsigned i) (Ptrofs.unsigned ofs1)). rewrite Zplus_mod_idemp_l.
+          rewrite Zplus_mod_idemp_r. rewrite Z.add_assoc. auto. } }
+      rewrite psubl_always_captured2_undef; eauto. rewrite psubl_always_captured2_undef; eauto.
+    (* ptr ptr *)
+    + rename b into b2. rename i0 into ofs2. unfold psubl_join.
+      destruct (eq_block b1 b2); subst.
+      * assert (Val.psubl (to_ptr_val m (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.of_int64 i)))) (to_ptr_val m (Vptr b2 ofs2))
+                =  Vlong (Ptrofs.to_int64 (Ptrofs.sub (Ptrofs.add ofs1 (Ptrofs.of_int64 i)) ofs2))) by (ss; des_ifs).
+        assert (Val.psubl (to_ptr_val m (Vptr b2 ofs1)) (to_ptr_val m (Vptr b2 ofs2))
+                = Vlong (Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs2))) by (ss; des_ifs).
+        exploit psubl_wrapper_no_angelic; try eapply H; eauto.
+        exploit psubl_wrapper_no_angelic; try eapply H0; eauto. i.
+        exploit val_join_angelic_vp; try eapply H1; try (by ss). i.
+        exploit val_join_angelic_vp; try eapply H2; try (by ss). i. clear H1 H2. des.
+        simpl. rewrite SF. destruct (eq_block b2 b2); [|clarify]. des_ifs.
+        rewrite H3, H4. simpl. f_equal.
+        unfold Ptrofs.to_int64, Ptrofs.sub, Int64.add, Ptrofs.add, Ptrofs.to_int64, Ptrofs.of_int64.
+        repeat rewrite Ptrofs.unsigned_repr_eq. eapply Int64.same_if_eq. unfold Int64.eq. des_ifs. exfalso. eapply n.
+        repeat rewrite Int64.unsigned_repr_eq. repeat (rewrite Ptrofs.modulus_eq64; eauto).
+        rewrite Zplus_mod_idemp_r. rewrite Zminus_mod_idemp_l. do 2 rewrite Zplus_mod_idemp_l.
+        rewrite Z.mod_mod. 2:{ specialize Int64.modulus_pos. lia. } f_equal. lia.
+      * simpl. rewrite SF. simpl. des_ifs. simpl. unfold to_int_val; simpl. unfold Mem.ptr2int.
+        destruct ((Mem.mem_concrete m) ! b1) eqn:CONC1;
+          destruct ((Mem.mem_concrete m) ! b2) eqn:CONC2; try rewrite SF; simpl; eauto.
+        { rewrite SF. unfold Val.addl. f_equal. rewrite <- Int64.sub_add_l.
+          unfold Int64.add, Int64.sub, Ptrofs.add, Ptrofs.of_int64.
+          eapply Int64.same_if_eq. unfold Int64.eq. des_ifs. exfalso. eapply n1.
+          repeat rewrite Ptrofs.unsigned_repr_eq. repeat rewrite Int64.unsigned_repr_eq.
+          rewrite (Zplus_mod_idemp_r (Int64.unsigned i) (Ptrofs.unsigned ofs1)).
+          repeat rewrite Zplus_mod_idemp_r. repeat rewrite Zplus_mod_idemp_l.
+          repeat rewrite Zminus_mod_idemp_r. repeat rewrite Zminus_mod_idemp_l. f_equal. lia. }
+Qed.
+
+Definition psubl_join_common (arg1 arg2: val) :=
+  match arg1, arg2 with
+  | Vptr _ _, Vptr _ _ | Vlong _, Vlong _ => (Val.psubl arg1 arg2)
+  | Vptr _ _, Vlong _ | Vlong _, Vptr _ _ => (psubl_join arg1 arg2)
+  | _, _ => Vundef
+  end.
+
+Definition psub_join_common (arg1 arg2: val) :=
+  match arg1, arg2 with
+  | Vptr _ _, Vptr _ _ | Vint _, Vint _ => (Val.psub arg1 arg2)
+  | Vptr _ _, Vint _ | Vint _, Vptr _ _ => (psub_join arg1 arg2)
+  | _, _ => Vundef
+  end.
+
+(* Definition psubl_join_common_src (arg1 arg2: val) := *)
+(*   match arg1, arg2 with *)
+(*   | Vptr _ _, Vptr _ _ | Vlong _, Vlong _ => (Val.psubl arg1 arg2) *)
+(*   | Vptr _ _, Vlong n | Vlong n, Vptr _ _ => if Int64.eq n Int64.zero then Vundef else (psubl_join arg1 arg2) *)
+(*   | _, _ => Vundef *)
+(*   end. *)
+
+(* Definition psub_join_common_src (arg1 arg2: val) := *)
+(*   match arg1, arg2 with *)
+(*   | Vptr _ _, Vptr _ _ | Vint _, Vint _ => (Val.psub arg1 arg2) *)
+(*   | Vptr _ _, Vint n | Vint n, Vptr _ _ => if Int.eq n Int.zero then Vundef else (psub_join arg1 arg2) *)
+(*   | _, _ => Vundef *)
+(*   end. *)
+
+(* Lemma psubl_join_common_refine v1 v2: Val.lessdef (psubl_join_common_src v1 v2) (psubl_join_common v1 v2). *)
+(* Proof. unfold psubl_join_common, psubl_join_common_src. des_ifs. Qed. *)
+
+(* Lemma psub_join_common_refine v1 v2: Val.lessdef (psub_join_common_src v1 v2) (psub_join_common v1 v2). *)
+(* Proof. unfold psub_join_common, psub_join_common_src. des_ifs. Qed. *)
+
+Lemma psubl_join_common_addl_l v1 v2 i:
+  psubl_join_common (Val.addl v1 (Vlong i)) v2 = Val.addl (psubl_join_common v1 v2) (Vlong i).
+Proof.
+  destruct v1; destruct v2; ss; des_ifs.
+  - ss. rewrite Int64.sub_add_l. eauto.
+  - erewrite <- psubl_join_addl_l. ss.
+  - ss. erewrite <- psubl_join_addl_l. ss.
+  - ss. des_ifs. f_equal. unfold Ptrofs.sub, Ptrofs.to_int64, Int64.add, Ptrofs.add, Ptrofs.of_int64.
+    eapply Int64.same_if_eq. unfold Int64.eq. des_ifs. exfalso. eapply n.
+    repeat rewrite Ptrofs.unsigned_repr_eq. repeat rewrite Int64.unsigned_repr_eq.
+    repeat rewrite Zplus_mod_idemp_r. repeat rewrite Zplus_mod_idemp_l.
+    repeat rewrite Zminus_mod_idemp_l. rewrite Zmod_mod. f_equal. lia.
+  - ss. des_ifs.
+Qed.
+ 
+Lemma psubl_join_common_addl_r v1 v2 i:
+  psubl_join_common v1 (Val.addl v2 (Vlong i)) = Val.addl (psubl_join_common v1 v2) (Vlong (Int64.neg i)).
+Proof.
+  destruct v1; destruct v2; ss; des_ifs.
+  (* int int *)
+  - simpl. rewrite <- Int64.sub_add_r. rewrite Int64.add_commut. eauto.
+  (* int ptr *)
+  - rename b0 into b2. rename i1 into ofs2.
+    destruct ((Mem.mem_concrete m) ! b2) eqn:CONC.
+    { erewrite psubl_always_captured1'; eauto. erewrite psubl_always_captured1'; eauto.
+      ss. f_equal. rewrite <- Int64.sub_add_r. f_equal.
+      unfold Ptrofs.add, Ptrofs.of_int64, Int64.add.
+      eapply Int64.same_if_eq. unfold Int64.eq. des_ifs. exfalso. eapply n.
+      repeat rewrite Ptrofs.unsigned_repr_eq. repeat rewrite Int64.unsigned_repr_eq.
+      rewrite (Zplus_mod_idemp_r (Int64.unsigned i)). repeat rewrite Zplus_mod_idemp_r. f_equal. lia. }
+    rewrite psubl_always_captured1_undef; eauto. rewrite psubl_always_captured1_undef; eauto.
+  (* ptr int *)
+  - rename b into b1. rename i0 into ofs1.
+    destruct ((Mem.mem_concrete m) ! b1) eqn:CONC.
+    { erewrite psubl_always_captured2'; eauto. erewrite psubl_always_captured2'; eauto.
+      ss. f_equal. rewrite <- Int64.sub_add_r. rewrite Int64.add_commut. eauto. }
+    rewrite psubl_always_captured2_undef; eauto. rewrite psubl_always_captured2_undef; eauto.
+  - ss. f_equal. unfold Ptrofs.to_int64, Ptrofs.sub, Ptrofs.add, Ptrofs.of_int64, Int64.add, Int64.neg.
+    eapply Int64.same_if_eq. unfold Int64.eq. des_ifs. exfalso. eapply n.
+    repeat rewrite Ptrofs.unsigned_repr_eq. repeat rewrite Int64.unsigned_repr_eq.
+    rewrite (Zplus_mod_idemp_r (Int64.unsigned i)). repeat rewrite Zminus_mod_idemp_r.
+    repeat rewrite Zmod_mod. rewrite Zplus_mod_idemp_r. rewrite Zplus_mod_idemp_l. f_equal. lia.
+Qed.
+
+Lemma psub_join_common_addl_l v1 v2 i:
+  psub_join_common (Val.add v1 (Vint i)) v2 = Val.add (psub_join_common v1 v2) (Vint i).
+Proof.
+  destruct Archi.ptr64 eqn:SF.
+  { unfold psub_join_common. unfold psub_join, Val.psub. rewrite SF. des_ifs. }
+  destruct v1; destruct v2; simpl in *; try rewrite SF; auto.
+  - simpl. rewrite Int.sub_add_l. eauto.
+  (* int ptr *)
+  - rename b into b2. rename i1 into ofs2.
+    destruct ((Mem.mem_concrete m) ! b2) eqn:CONC.
+    { erewrite psub_always_captured1'; eauto. erewrite psub_always_captured1'; eauto.
+      simpl. f_equal. rewrite <- Int.sub_add_l. reflexivity. }
+    rewrite psub_always_captured1_undef; eauto. rewrite psub_always_captured1_undef; eauto.
+  (* ptr int *)
+  - simpl. rename b into b1. rename i0 into ofs1.
+    destruct ((Mem.mem_concrete m) ! b1) eqn:CONC.
+    { erewrite psub_always_captured2'; eauto. erewrite psub_always_captured2'; eauto.
+      simpl. f_equal. rewrite <- Int.sub_add_l. f_equal. ss. }
+    rewrite psub_always_captured2_undef; eauto. rewrite psub_always_captured2_undef; eauto.
+  - simpl. rewrite SF. destruct (eq_block b b0); [|simpl; auto]. ss.
+Qed.
+ 
+Lemma psub_join_common_addl_r v1 v2 i:
+  psub_join_common v1 (Val.add v2 (Vint i)) = Val.add (psub_join_common v1 v2) (Vint (Int.neg i)).
+Proof.
+  destruct Archi.ptr64 eqn:SF.
+  { unfold psub_join_common. unfold psub_join, Val.psub. rewrite SF. des_ifs. }
+  destruct v1; destruct v2; simpl in *; try rewrite SF; auto.
+  - simpl. rewrite Int.add_commut. rewrite Int.sub_add_r. reflexivity.
+  (* int ptr *)
+  - rename b into b2. rename i1 into ofs2.
+    destruct ((Mem.mem_concrete m) ! b2) eqn:CONC.
+    { erewrite psub_always_captured1'; eauto. erewrite psub_always_captured1'; eauto.
+      simpl. f_equal. rewrite <- Int.sub_add_r. ss. }
+    rewrite psub_always_captured1_undef; eauto. rewrite psub_always_captured1_undef; eauto.
+  (* ptr int *)
+  - simpl. rename b into b1. rename i0 into ofs1.
+    destruct ((Mem.mem_concrete m) ! b1) eqn:CONC.
+    { erewrite psub_always_captured2'; eauto. erewrite psub_always_captured2'; eauto.
+      simpl. f_equal. rewrite <- Int.sub_add_r. rewrite Int.add_commut. reflexivity. }
+    rewrite psub_always_captured2_undef; eauto. rewrite psub_always_captured2_undef; eauto.
+  - simpl. destruct (eq_block b b0); [|simpl; auto]. ss.
+Qed.
+
+End PTRBINJOIN.
+
+Section GENREL.
+
+Variable f: meminj.
+Variable m1: mem.
+Variable m2: mem.
+
+Hypothesis mi_inj_perm: forall b1 b2 delta ofs k p,
+    f b1 = Some (b2, delta) ->
+    Mem.perm m1 b1 ofs k p -> Mem.perm m2 b2 (ofs + delta) k p.
+
+Hypothesis valid_pointer_inj:
+  forall b1 ofs b2 delta,
+  f b1 = Some(b2, delta) ->
+  Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->
+  Mem.valid_pointer m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.
+
+Hypothesis weak_valid_pointer_inj:
+  forall b1 ofs b2 delta,
+  f b1 = Some(b2, delta) ->
+  Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->
+  Mem.weak_valid_pointer m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.
+
+Hypothesis weak_valid_pointer_no_overflow:
+  forall b1 ofs b2 delta,
+  f b1 = Some(b2, delta) ->
+  Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->
+  0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <= Ptrofs.max_unsigned.
+
+Hypothesis valid_different_pointers_inj:
+  forall b1 ofs1 b2 ofs2 b1' delta1 b2' delta2,
+  b1 <> b2 ->
+  Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->
+  Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->
+  f b1 = Some (b1', delta1) ->
+  f b2 = Some (b2', delta2) ->
+  b1' <> b2' \/
+  Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <> Ptrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).
+
+Hypothesis src_concrete_private: forall b, f b = None -> (Mem.mem_concrete m1) ! b = None.
+
+Hypothesis mappedblocks: forall b b' delta, Mem.valid_block m1 b -> f b = Some (b', delta) -> Mem.valid_block m2 b'.
+
+Hypothesis src_concrete_public: forall b1 b2 addr delta,
+    f b1 = Some (b2, delta) ->
+    (Mem.mem_concrete m1) ! b1 = Some addr ->
+    (Mem.mem_concrete m2) ! b2 = Some (addr - delta).
+
+Hypothesis representable: forall b b' delta ofs,
+    f b = Some (b', delta) ->
+    Mem.perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \/
+    Mem.perm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->
+    delta >= 0 /\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.
+
+Lemma psubl_join_inj
+    v1 v1' v2 v2' v
+    (VINJ1: Val.inject f v1 v1')
+    (VINJ2: Val.inject f v2 v2')
+    (PSUB: psubl_join m1 v1 v2 = v) :
+  exists v', <<PSUB: psubl_join m2 v1' v2' = v'>> /\ <<VINJ: Val.inject f v v'>>.
+Proof.
+  unfold psubl_join in *.
+  exploit to_int_val_inject'; try eapply VINJ1; eauto. i. exploit to_int_val_inject'; try eapply VINJ2; eauto. i.
+  exploit to_ptr_val_inject'; try eapply VINJ1; eauto. i. exploit to_ptr_val_inject'; try eapply VINJ2; eauto. i.
+  exploit (psubl_wrapper_no_angelic m1 v1 v2); eauto. i.
+  exploit (Val.psubl_inject f (to_ptr_val m1 v1) (to_ptr_val m2 v1') (to_ptr_val m1 v2) (to_ptr_val m2 v2')); eauto. i.
+  exploit (Val.psubl_inject f (to_int_val m1 v1) (to_int_val m2 v1') (to_int_val m1 v2) (to_int_val m2 v2')); eauto. i.
+  r in H4. r in H5. des.
+  - rewrite H3 in *. destruct (classic ((Val.psubl (to_int_val m1 v1) (to_int_val m1 v2)) = Vundef)).
+    { rewrite H6 in *. ss. inv PSUB. esplits; eauto. }
+    subst. rewrite val_join_angelic_vi; eauto.
+    { eapply psubl_is_only_int. }
+    { eapply psubl_wrapper_no_angelic; eauto. }
+    { ii. rewrite H7 in *. inv H5; clarify. rewrite <- H9 in *. clarify. }
+  - rewrite H3 in *. destruct (classic ((Val.psubl (to_ptr_val m1 v1) (to_ptr_val m1 v2)) = Vundef)).
+    { rewrite H6 in *. ss. inv PSUB. esplits; eauto. }
+    subst. rewrite (val_join_angelic_vp _ Vundef); eauto.
+    2:{ eapply psubl_is_only_int. }
+    rewrite val_join_angelic_vp; eauto.
+    { eapply psubl_is_only_int. }
+    { eapply psubl_wrapper_no_angelic; eauto. }
+    { ii. rewrite H7 in *. inv H4; eauto. }
+  - destruct (classic ((Val.psubl (to_int_val m1 v1) (to_int_val m1 v2)) = Vundef)).
+    { rewrite H3, H6 in *. ss. subst. esplits; eauto. }
+    rewrite <- H3 in PSUB. rewrite val_join_same_val in PSUB.
+    2:{ eapply psubl_is_only_int. }
+    subst. rewrite val_join_angelic_vi; eauto.
+    { eapply psubl_is_only_int. }
+    { eapply psubl_wrapper_no_angelic; eauto. }
+    { ii. rewrite H7 in *. inv H5; eauto. }
+Qed.
+
+Lemma psub_join_inj
+    v1 v1' v2 v2' v
+    (VINJ1: Val.inject f v1 v1')
+    (VINJ2: Val.inject f v2 v2')
+    (PSUB: psub_join m1 v1 v2 = v) :
+  exists v', <<PSUB: psub_join m2 v1' v2' = v'>> /\ <<VINJ: Val.inject f v v'>>.
+Proof.
+  unfold psub_join in *.
+  exploit to_int_val_inject'; try eapply VINJ1; eauto. i. exploit to_int_val_inject'; try eapply VINJ2; eauto. i.
+  exploit to_ptr_val_inject'; try eapply VINJ1; eauto. i. exploit to_ptr_val_inject'; try eapply VINJ2; eauto. i.
+  exploit (psub_wrapper_no_angelic m1 v1 v2); eauto. i.
+  exploit (Val.psub_inject f (to_ptr_val m1 v1) (to_ptr_val m2 v1') (to_ptr_val m1 v2) (to_ptr_val m2 v2')); eauto. i.
+  exploit (Val.psub_inject f (to_int_val m1 v1) (to_int_val m2 v1') (to_int_val m1 v2) (to_int_val m2 v2')); eauto. i.
+  r in H4. r in H5. des.
+  - rewrite H3 in *. destruct (classic ((Val.psub (to_int_val m1 v1) (to_int_val m1 v2)) = Vundef)).
+    { rewrite H6 in *. ss. inv PSUB. esplits; eauto. }
+    subst. rewrite val_join_angelic_vi; eauto.
+    { eapply psub_is_only_int. }
+    { eapply psub_wrapper_no_angelic; eauto. }
+    { ii. rewrite H7 in *. inv H5; clarify. rewrite <- H9 in *. clarify. }
+  - rewrite H3 in *. destruct (classic ((Val.psub (to_ptr_val m1 v1) (to_ptr_val m1 v2)) = Vundef)).
+    { rewrite H6 in *. ss. inv PSUB. esplits; eauto. }
+    subst. rewrite (val_join_angelic_vp _ Vundef); eauto.
+    2:{ eapply psub_is_only_int. }
+    rewrite val_join_angelic_vp; eauto.
+    { eapply psub_is_only_int. }
+    { eapply psub_wrapper_no_angelic; eauto. }
+    { ii. rewrite H7 in *. inv H4; eauto. }
+  - destruct (classic ((Val.psub (to_int_val m1 v1) (to_int_val m1 v2)) = Vundef)).
+    { rewrite H3, H6 in *. ss. subst. esplits; eauto. }
+    rewrite <- H3 in PSUB. rewrite val_join_same_val in PSUB.
+    2:{ eapply psub_is_only_int. }
+    subst. rewrite val_join_angelic_vi; eauto.
+    { eapply psub_is_only_int. }
+    { eapply psub_wrapper_no_angelic; eauto. }
+    { ii. rewrite H7 in *. inv H5; eauto. }
+Qed.
+
+Lemma psubl_join_common_inj
+    v1 v1' v2 v2' v
+    (VINJ1: Val.inject f v1 v1')
+    (VINJ2: Val.inject f v2 v2')
+    (PSUB: psubl_join_common m1 v1 v2 = v) :
+  exists v', <<PSUB: psubl_join_common m2 v1' v2' = v'>> /\ <<VINJ: Val.inject f v v'>>.
+Proof.
+  destruct Archi.ptr64 eqn:SF; cycle 1.
+  { esplits; eauto. unfold psubl_join_common, psubl_join, Val.psubl in PSUB.
+    rewrite SF in *. clear SF. inv VINJ1; inv VINJ2; simpl in *; esplits; eauto; des_ifs. }
+  destruct v1, v2; simpl in *; try rewrite SF in *; try by (clear SF; subst v; esplits; eauto).
+- inv VINJ1; inv VINJ2; simpl. rewrite SF. clear SF. esplits; eauto.
+- exploit psubl_join_inj; try eapply PSUB; eauto. i. des; subst.
+  inv VINJ1; inv VINJ2; simpl. esplits; eauto.
+- exploit psubl_join_inj; try eapply PSUB; eauto. i. des; subst.
+  inv VINJ1; inv VINJ2; simpl. esplits; eauto.
+- exploit Val.psubl_inject. eapply VINJ1. eapply VINJ2.
+  inv VINJ1; inv VINJ2. simpl in *. rewrite SF. esplits; eauto.
+Qed.
+
+Lemma psub_join_common_inj
+    v1 v1' v2 v2' v
+    (VINJ1: Val.inject f v1 v1')
+    (VINJ2: Val.inject f v2 v2')
+    (PSUB: psub_join_common m1 v1 v2 = v) :
+  exists v', <<PSUB: psub_join_common m2 v1' v2' = v'>> /\ <<VINJ: Val.inject f v v'>>.
+Proof.
+  destruct Archi.ptr64 eqn:SF.
+  { esplits; eauto. unfold psub_join_common, psub_join, Val.psub in PSUB.
+    rewrite SF in *. clear SF. inv VINJ1; inv VINJ2; simpl in *; esplits; eauto; des_ifs. }
+  destruct v1, v2; simpl in *; try rewrite SF in *; try by (clear SF; subst v; esplits; eauto).
+- inv VINJ1; inv VINJ2; simpl. rewrite SF. clear SF. esplits; eauto.
+- exploit psub_join_inj; try eapply PSUB; eauto. i. des; subst.
+  inv VINJ1; inv VINJ2; simpl. esplits; eauto.
+- exploit psub_join_inj; try eapply PSUB; eauto. i. des; subst.
+  inv VINJ1; inv VINJ2; simpl. esplits; eauto.
+- exploit Val.psub_inject. eapply VINJ1. eapply VINJ2.
+  inv VINJ1; inv VINJ2. simpl in *. rewrite SF. esplits; eauto.
+Qed.
+
+Lemma cmplu_join_inj
+    c v1 v2 v1' v2' b
+    (VINJ1: Val.inject f v1 v1')
+    (VINJ2: Val.inject f v2 v2')
+    (CMP: cmplu_join m1 c v1 v2 = Some b) :
+  <<CMP: cmplu_join m2 c v1' v2' = Some b>>.
+Proof.
+  unfold cmplu_join in *.
+  exploit to_int_val_inject'; try eapply VINJ1; eauto. i. exploit to_int_val_inject'; try eapply VINJ2; eauto. i.
+  exploit to_ptr_val_inject'; try eapply VINJ1; eauto. i. exploit to_ptr_val_inject'; try eapply VINJ2; eauto. i.
+  destruct (Val.cmplu_bool (Mem.valid_pointer m1) c (to_ptr_val m1 v1) (to_ptr_val m1 v2)) eqn:PCMP.
+  - destruct (Val.cmplu_bool (Mem.valid_pointer m1) c (to_int_val m1 v1) (to_int_val m1 v2)) eqn:ICMP.
+    + exploit cmplu_no_angelic; eauto. i. des; subst.
+      erewrite Val.cmplu_bool_inject; try eapply PCMP; eauto. erewrite Val.cmplu_bool_inject; try eapply ICMP; eauto.
+    + exploit Val.cmplu_bool_inject; try eapply PCMP; eauto. i.
+      destruct (Val.cmplu_bool (Mem.valid_pointer m2) c (to_int_val m2 v1') (to_int_val m2 v2')) eqn:ICMP'.
+      { exploit cmplu_no_angelic; eauto. i. des; subst. rewrite H3. rewrite bool_optjoin_same_bool. ss. }
+      rewrite H3. ss.
+  - destruct (Val.cmplu_bool (Mem.valid_pointer m1) c (to_int_val m1 v1) (to_int_val m1 v2)) eqn:ICMP; [|ss].
+    exploit Val.cmplu_bool_inject; try eapply ICMP; eauto. i. rewrite H3.
+    destruct (Val.cmplu_bool (Mem.valid_pointer m2) c (to_ptr_val m2 v1') (to_ptr_val m2 v2')) eqn:PCMP'; [|ss].
+    exploit cmplu_no_angelic; eauto. i. des; subst. simpl in CMP. inv CMP. eapply bool_optjoin_same_bool.
+Qed.
+
+Lemma cmpu_join_inj c v1 v2 v1' v2' b
+    (VINJ1: Val.inject f v1 v1')
+    (VINJ2: Val.inject f v2 v2')
+    (CMP: cmpu_join m1 c v1 v2 = Some b) :
+  <<CMP: cmpu_join m2 c v1' v2' = Some b>>.
+Proof.
+  unfold cmpu_join in *.
+  exploit to_int_val_inject'; try eapply VINJ1; eauto. i. exploit to_int_val_inject'; try eapply VINJ2; eauto. i.
+  exploit to_ptr_val_inject'; try eapply VINJ1; eauto. i. exploit to_ptr_val_inject'; try eapply VINJ2; eauto. i.
+  destruct (Val.cmpu_bool (Mem.valid_pointer m1) c (to_ptr_val m1 v1) (to_ptr_val m1 v2)) eqn:PCMP.
+  - destruct (Val.cmpu_bool (Mem.valid_pointer m1) c (to_int_val m1 v1) (to_int_val m1 v2)) eqn:ICMP.
+    + exploit cmpu_no_angelic; eauto. i. des; subst.
+      erewrite Val.cmpu_bool_inject; try eapply PCMP; eauto. erewrite Val.cmpu_bool_inject; try eapply ICMP; eauto.
+    + exploit Val.cmpu_bool_inject; try eapply PCMP; eauto. i.
+      destruct (Val.cmpu_bool (Mem.valid_pointer m2) c (to_int_val m2 v1') (to_int_val m2 v2')) eqn:ICMP'.
+      { exploit cmpu_no_angelic; eauto. i. des; subst. rewrite H3. rewrite bool_optjoin_same_bool. ss. }
+      rewrite H3. ss.
+  - destruct (Val.cmpu_bool (Mem.valid_pointer m1) c (to_int_val m1 v1) (to_int_val m1 v2)) eqn:ICMP; [|ss].
+    exploit Val.cmpu_bool_inject; try eapply ICMP; eauto. i. rewrite H3.
+    destruct (Val.cmpu_bool (Mem.valid_pointer m2) c (to_ptr_val m2 v1') (to_ptr_val m2 v2')) eqn:PCMP'; [|ss].
+    exploit cmpu_no_angelic; eauto. i. des; subst. simpl in CMP. inv CMP. eapply bool_optjoin_same_bool.
+Qed.
+
+Lemma cmplu_join_common_inj
+    c v1 v2 v1' v2' b
+    (VINJ1: Val.inject f v1 v1')
+    (VINJ2: Val.inject f v2 v2')
+    (CMP: cmplu_join_common m1 c v1 v2 = Some b) :
+  <<CMP: cmplu_join_common m2 c v1' v2' = Some b>>.
+Proof.
+  unfold cmplu_join_common in *. inv VINJ1; inv VINJ2; try by inv CMP.
+  - des_ifs.
+    + eapply Val.cmplu_bool_inject; try eapply CMP; eauto.
+    + eapply cmplu_join_inj; try eapply CMP; eauto.
+  - des_ifs.
+    + eapply Val.cmplu_bool_inject; try eapply CMP; eauto.
+    + eapply cmplu_join_inj; try eapply CMP; eauto.
+  - eapply Val.cmplu_bool_inject; try eapply CMP; eauto.
+Qed.
+
+Lemma cmpu_join_common_inj
+    c v1 v2 v1' v2' b
+    (VINJ1: Val.inject f v1 v1')
+    (VINJ2: Val.inject f v2 v2')
+    (CMP: cmpu_join_common m1 c v1 v2 = Some b) :
+  <<CMP: cmpu_join_common m2 c v1' v2' = Some b>>.
+Proof.
+  unfold cmpu_join_common in *. inv VINJ1; inv VINJ2; try by inv CMP.
+  - destruct (Int.eq i Int.zero) eqn:NULL.
+    + eapply Val.cmpu_bool_inject; try eapply CMP; eauto.
+    + eapply cmpu_join_inj; try eapply CMP; eauto.
+  - destruct (Int.eq i Int.zero) eqn:NULL.
+    + eapply Val.cmpu_bool_inject; try eapply CMP; eauto.
+    + eapply cmpu_join_inj; try eapply CMP; eauto.
+Qed.
+
+End GENREL.
+
+Section PTRBINLESSDEF.
+
+  Lemma psub_join_lessdef
+    v1 v1' v2 v2' m m' v
+    (LESS1: Val.lessdef v1 v1')
+    (LESS2: Val.lessdef v2 v2')
+    (MEXT: Mem.extends m m')
+    (PSUB: psub_join m v1 v2 = v) :
+  exists v', <<PSUB: psub_join m' v1' v2' = v'>> /\ <<LESS: Val.lessdef v v'>>.
+Proof.
+  unfold psub_join in *.
+  exploit to_int_val_lessdef; try eapply LESS1; eauto. i. exploit to_int_val_lessdef; try eapply LESS2; eauto. i.
+  exploit to_ptr_val_lessdef; try eapply LESS1; eauto. i. exploit to_ptr_val_lessdef; try eapply LESS2; eauto. i.
+  exploit (psub_wrapper_no_angelic m v1 v2); eauto. i.
+  exploit (Val.psub_inject inject_id (to_ptr_val m v1) (to_ptr_val m' v1') (to_ptr_val m v2) (to_ptr_val m' v2'));
+    try rewrite val_inject_id; eauto. i.
+  exploit (Val.psub_inject inject_id (to_int_val m v1) (to_int_val m' v1') (to_int_val m v2) (to_int_val m' v2'));
+    try rewrite val_inject_id; eauto. i. r in H4. r in H5. rewrite val_inject_id in H4, H5. des.
+  - rewrite H3 in *. destruct (classic ((Val.psub (to_int_val m v1) (to_int_val m v2)) = Vundef)).
+    { rewrite H6 in *. ss. inv PSUB. esplits; eauto. }
+    subst. rewrite val_join_angelic_vi; eauto.
+    { eapply psub_is_only_int. }
+    { eapply psub_wrapper_no_angelic; eauto. }
+    { ii. rewrite H7 in *. inv H5; clarify. rewrite <- H9 in *. clarify. }
+  - rewrite H3 in *. destruct (classic ((Val.psub (to_ptr_val m v1) (to_ptr_val m v2)) = Vundef)).
+    { rewrite H6 in *. ss. inv PSUB. esplits; eauto. }
+    subst. rewrite (val_join_angelic_vp _ Vundef); eauto.
+    2:{ eapply psub_is_only_int. }
+    rewrite val_join_angelic_vp; eauto.
+    { eapply psub_is_only_int. }
+    { eapply psub_wrapper_no_angelic; eauto. }
+    { ii. rewrite H7 in *. inv H4; eauto. }
+  - destruct (classic ((Val.psub (to_int_val m v1) (to_int_val m v2)) = Vundef)).
+    { rewrite H3, H6 in *. ss. subst. esplits; eauto. }
+    rewrite <- H3 in PSUB. rewrite val_join_same_val in PSUB.
+    2:{ eapply psub_is_only_int. }
+    subst. rewrite val_join_angelic_vi; eauto.
+    { eapply psub_is_only_int. }
+    { eapply psub_wrapper_no_angelic; eauto. }
+    { ii. rewrite H7 in *. inv H5; eauto. }
+Qed.
+
+Lemma psubl_join_lessdef
+    v1 v1' v2 v2' m m' v
+    (LESS1: Val.lessdef v1 v1')
+    (LESS2: Val.lessdef v2 v2')
+    (MEXT: Mem.extends m m')
+    (PSUB: psubl_join m v1 v2 = v) :
+  exists v', <<PSUB: psubl_join m' v1' v2' = v'>> /\ <<LESS: Val.lessdef v v'>>.
+Proof.
+  unfold psubl_join in *.
+  exploit to_int_val_lessdef; try eapply LESS1; eauto. i. exploit to_int_val_lessdef; try eapply LESS2; eauto. i.
+  exploit to_ptr_val_lessdef; try eapply LESS1; eauto. i. exploit to_ptr_val_lessdef; try eapply LESS2; eauto. i.
+  exploit (psubl_wrapper_no_angelic m v1 v2); eauto. i.
+  exploit (Val.psubl_inject inject_id (to_ptr_val m v1) (to_ptr_val m' v1') (to_ptr_val m v2) (to_ptr_val m' v2'));
+    try rewrite val_inject_id; eauto. i.
+  exploit (Val.psubl_inject inject_id (to_int_val m v1) (to_int_val m' v1') (to_int_val m v2) (to_int_val m' v2'));
+    try rewrite val_inject_id; eauto. i. r in H4. r in H5. rewrite val_inject_id in H4, H5. des.
+  - rewrite H3 in *. destruct (classic ((Val.psubl (to_int_val m v1) (to_int_val m v2)) = Vundef)).
+    { rewrite H6 in *. ss. inv PSUB. esplits; eauto. }
+    subst. rewrite val_join_angelic_vi; eauto.
+    { eapply psubl_is_only_int. }
+    { eapply psubl_wrapper_no_angelic; eauto. }
+    { ii. rewrite H7 in *. inv H5; clarify. rewrite <- H9 in *. clarify. }
+  - rewrite H3 in *. destruct (classic ((Val.psubl (to_ptr_val m v1) (to_ptr_val m v2)) = Vundef)).
+    { rewrite H6 in *. ss. inv PSUB. esplits; eauto. }
+    subst. rewrite (val_join_angelic_vp _ Vundef); eauto.
+    2:{ eapply psubl_is_only_int. }
+    rewrite val_join_angelic_vp; eauto.
+    { eapply psubl_is_only_int. }
+    { eapply psubl_wrapper_no_angelic; eauto. }
+    { ii. rewrite H7 in *. inv H4; eauto. }
+  - destruct (classic ((Val.psubl (to_int_val m v1) (to_int_val m v2)) = Vundef)).
+    { rewrite H3, H6 in *. ss. subst. esplits; eauto. }
+    rewrite <- H3 in PSUB. rewrite val_join_same_val in PSUB.
+    2:{ eapply psubl_is_only_int. }
+    subst. rewrite val_join_angelic_vi; eauto.
+    { eapply psubl_is_only_int. }
+    { eapply psubl_wrapper_no_angelic; eauto. }
+    { ii. rewrite H7 in *. inv H5; eauto. }
+Qed.
+
+Lemma cmpu_join_lessdef
+    v1 v1' v2 v2' c m m' b
+    (LESS1: Val.lessdef v1 v1')
+    (LESS2: Val.lessdef v2 v2')
+    (MEXT: Mem.extends m m')
+    (CMP: cmpu_join m c v1 v2 = Some b) :
+  <<CMP: cmpu_join m' c v1' v2' = Some b>>.
+Proof.
+  assert (SAMEVLD: forall b ofs, Mem.valid_pointer m b ofs = true -> Mem.valid_pointer m' b ofs = true).
+  { ii. eapply Mem.valid_pointer_extends; eauto. }
+  unfold cmpu_join in *.
+  exploit to_int_val_lessdef; try eapply LESS1; eauto. i. exploit to_int_val_lessdef; try eapply LESS2; eauto. i.
+  exploit to_ptr_val_lessdef; try eapply LESS1; eauto. i. exploit to_ptr_val_lessdef; try eapply LESS2; eauto. i.
+  destruct (Val.cmpu_bool (Mem.valid_pointer m) c (to_ptr_val m v1) (to_ptr_val m v2)) eqn:PCMP.
+  - destruct (Val.cmpu_bool (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2)) eqn:ICMP.
+    + exploit cmpu_no_angelic; eauto. i. des; subst.
+      erewrite Val.cmpu_bool_lessdef; try eapply PCMP; eauto. erewrite Val.cmpu_bool_lessdef; try eapply ICMP; eauto.
+    + exploit Val.cmpu_bool_lessdef; try eapply PCMP; eauto. i. unfold to_ptr_val.
+      destruct (Val.cmpu_bool (Mem.valid_pointer m') c (to_int_val m' v1') (to_int_val m' v2')) eqn:ICMP'.
+      { exploit cmpu_no_angelic; eauto. i. des; subst. rewrite H3. rewrite bool_optjoin_same_bool. ss. }
+      rewrite H3. ss.
+  - destruct (Val.cmpu_bool (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2)) eqn:ICMP; [|ss].
+    exploit Val.cmpu_bool_lessdef; try eapply ICMP; eauto. i. unfold to_int_val. rewrite H3.
+    destruct (Val.cmpu_bool (Mem.valid_pointer m') c (to_ptr_val m' v1') (to_ptr_val m' v2')) eqn:PCMP'; [|ss].
+    exploit cmpu_no_angelic; eauto. i. des; subst. simpl in CMP. inv CMP. eapply bool_optjoin_same_bool.
+Qed.
+
+Lemma cmplu_join_lessdef
+    v1 v1' v2 v2' c m m' b
+    (LESS1: Val.lessdef v1 v1')
+    (LESS2: Val.lessdef v2 v2')
+    (MEXT: Mem.extends m m')
+    (CMP: cmplu_join m c v1 v2 = Some b) :
+  <<CMP: cmplu_join m' c v1' v2' = Some b>>.
+Proof.
+  assert (SAMEVLD: forall b ofs, Mem.valid_pointer m b ofs = true -> Mem.valid_pointer m' b ofs = true).
+  { ii. eapply Mem.valid_pointer_extends; eauto. }
+  unfold cmplu_join in *.
+  exploit to_int_val_lessdef; try eapply LESS1; eauto. i. exploit to_int_val_lessdef; try eapply LESS2; eauto. i.
+  exploit to_ptr_val_lessdef; try eapply LESS1; eauto. i. exploit to_ptr_val_lessdef; try eapply LESS2; eauto. i.
+  destruct (Val.cmplu_bool (Mem.valid_pointer m) c (to_ptr_val m v1) (to_ptr_val m v2)) eqn:PCMP.
+  - destruct (Val.cmplu_bool (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2)) eqn:ICMP.
+    + exploit cmplu_no_angelic; eauto. i. des; subst.
+      erewrite Val.cmplu_bool_lessdef; try eapply PCMP; eauto. erewrite Val.cmplu_bool_lessdef; try eapply ICMP; eauto.
+    + exploit Val.cmplu_bool_lessdef; try eapply PCMP; eauto. i. unfold to_ptr_val.
+      destruct (Val.cmplu_bool (Mem.valid_pointer m') c (to_int_val m' v1') (to_int_val m' v2')) eqn:ICMP'.
+      { exploit cmplu_no_angelic; eauto. i. des; subst. rewrite H3. rewrite bool_optjoin_same_bool. ss. }
+      rewrite H3. ss.
+  - destruct (Val.cmplu_bool (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2)) eqn:ICMP; [|ss].
+    exploit Val.cmplu_bool_lessdef; try eapply ICMP; eauto. i. unfold to_int_val. rewrite H3.
+    destruct (Val.cmplu_bool (Mem.valid_pointer m') c (to_ptr_val m' v1') (to_ptr_val m' v2')) eqn:PCMP'; [|ss].
+    exploit cmplu_no_angelic; eauto. i. des; subst. simpl in CMP. inv CMP. eapply bool_optjoin_same_bool.
+Qed.
+
+End PTRBINLESSDEF.
+
+Section PTRBININJ.
+
+Variable f: meminj.
+
+Lemma psubl_join_common_inject
+    m1 m2 v1 v1' v2 v2' v
+    (MINJ: Mem.inject f m1 m2)
+    (VINJ1: Val.inject f v1 v1')
+    (VINJ2: Val.inject f v2 v2')
+    (PSUB: psubl_join_common m1 v1 v2 = v) :
+  exists v', <<PSUB: psubl_join_common m2 v1' v2' = v'>> /\ <<VINJ: Val.inject f v v'>>.
+Proof.
+  eapply psubl_join_common_inj; eauto.
+- i. eapply Mem.mi_perm; eauto. eapply Mem.mi_inj; eauto.
+- i. eapply Mem.mi_src_concrete_private; eauto.
+- i. eapply Mem.mi_mappedblocks; eauto.
+- i. eapply Mem.mi_src_concrete_public; eauto.
+- i. eapply Mem.mi_representable; eauto.
+Qed.
+
+Lemma psub_join_common_inject
+    m1 m2 v1 v1' v2 v2' v
+    (MINJ: Mem.inject f m1 m2)
+    (VINJ1: Val.inject f v1 v1')
+    (VINJ2: Val.inject f v2 v2')
+    (PSUB: psub_join_common m1 v1 v2 = v) :
+  exists v', <<PSUB: psub_join_common m2 v1' v2' = v'>> /\ <<VINJ: Val.inject f v v'>>.
+Proof.
+  eapply psub_join_common_inj; eauto.
+- i. eapply Mem.mi_perm; eauto. eapply Mem.mi_inj; eauto.
+- i. eapply Mem.mi_src_concrete_private; eauto.
+- i. eapply Mem.mi_mappedblocks; eauto.
+- i. eapply Mem.mi_src_concrete_public; eauto.
+- i. eapply Mem.mi_representable; eauto.
+Qed.
+
+Lemma cmpu_bool_inject'
+    c m1 m2 v1 v2 v1' v2' b
+    (MINJ: Mem.inject f m1 m2)
+    (VINJ1: Val.inject f v1 v1')
+    (VINJ2: Val.inject f v2 v2')
+    (CMP1: Val.cmpu_bool (Mem.valid_pointer m1) c v1 v2 = Some b) :
+  <<CMP2: Val.cmpu_bool (Mem.valid_pointer m2) c v1' v2' = Some b>>.
+Proof.
+  exploit (Val.cmpu_bool_inject f (Mem.valid_pointer m1) (Mem.valid_pointer m2)); try eapply CMP1; eauto; i.
+  { exploit Mem.valid_pointer_inject_val; eauto. }
+  { exploit Mem.weak_valid_pointer_inject_val; eauto. }
+  { exploit Mem.weak_valid_pointer_inject_no_overflow; eauto. }
+  { exploit Mem.different_pointers_inject; eauto. }
+Qed.
+
+Lemma cmplu_bool_inject'
+    c m1 m2 v1 v2 v1' v2' b
+    (MINJ: Mem.inject f m1 m2)
+    (VINJ1: Val.inject f v1 v1')
+    (VINJ2: Val.inject f v2 v2')
+    (CMP1: Val.cmplu_bool (Mem.valid_pointer m1) c v1 v2 = Some b) :
+  <<CMP2: Val.cmplu_bool (Mem.valid_pointer m2) c v1' v2' = Some b>>.
+Proof.
+  exploit (Val.cmplu_bool_inject f (Mem.valid_pointer m1) (Mem.valid_pointer m2)); try eapply CMP1; eauto; i.
+  { exploit Mem.valid_pointer_inject_val; eauto. }
+  { exploit Mem.weak_valid_pointer_inject_val; eauto. }
+  { exploit Mem.weak_valid_pointer_inject_no_overflow; eauto. }
+  { exploit Mem.different_pointers_inject; eauto. }
+Qed.
+
+Lemma cmpu_join_inject
+    c m1 m2 v1 v2 v1' v2' b
+    (MINJ: Mem.inject f m1 m2)
+    (VINJ1: Val.inject f v1 v1')
+    (VINJ2: Val.inject f v2 v2')
+    (CMP: cmpu_join m1 c v1 v2 = Some b) :
+  <<CMP: cmpu_join m2 c v1' v2' = Some b>>.
+Proof.
+  unfold cmpu_join in *.
+  exploit to_int_val_inject; try eapply VINJ1; eauto. i. exploit to_int_val_inject; try eapply VINJ2; eauto. i.
+  exploit to_ptr_val_inject; try eapply VINJ1; eauto. i. exploit to_ptr_val_inject; try eapply VINJ2; eauto. i.
+  destruct (Val.cmpu_bool (Mem.valid_pointer m1) c (to_ptr_val m1 v1) (to_ptr_val m1 v2)) eqn:PCMP.
+  - destruct (Val.cmpu_bool (Mem.valid_pointer m1) c (to_int_val m1 v1) (to_int_val m1 v2)) eqn:ICMP.
+    + exploit cmpu_no_angelic; eauto. i. des; subst.
+      erewrite cmpu_bool_inject'; try eapply PCMP; eauto. erewrite cmpu_bool_inject'; try eapply ICMP; eauto.
+    + exploit cmpu_bool_inject'; try eapply PCMP; eauto. i.
+      destruct (Val.cmpu_bool (Mem.valid_pointer m2) c (to_int_val m2 v1') (to_int_val m2 v2')) eqn:ICMP'.
+      { exploit cmpu_no_angelic; eauto. i. des; subst. rewrite H3. rewrite bool_optjoin_same_bool. ss. }
+      rewrite H3. ss.
+  - destruct (Val.cmpu_bool (Mem.valid_pointer m1) c (to_int_val m1 v1) (to_int_val m1 v2)) eqn:ICMP; [|ss].
+    exploit cmpu_bool_inject'; try eapply ICMP; eauto. i. rewrite H3.
+    destruct (Val.cmpu_bool (Mem.valid_pointer m2) c (to_ptr_val m2 v1') (to_ptr_val m2 v2')) eqn:PCMP'; [|ss].
+    exploit cmpu_no_angelic; eauto. i. des; subst. simpl in CMP. inv CMP. eapply bool_optjoin_same_bool.
+Qed.
+
+Lemma cmplu_join_inject
+    c m1 m2 v1 v2 v1' v2' b
+    (MINJ: Mem.inject f m1 m2)
+    (VINJ1: Val.inject f v1 v1')
+    (VINJ2: Val.inject f v2 v2')
+    (CMP: cmplu_join m1 c v1 v2 = Some b) :
+  <<CMP: cmplu_join m2 c v1' v2' = Some b>>.
+Proof.
+  unfold cmplu_join in *.
+  exploit to_int_val_inject; try eapply VINJ1; eauto. i. exploit to_int_val_inject; try eapply VINJ2; eauto. i.
+  exploit to_ptr_val_inject; try eapply VINJ1; eauto. i. exploit to_ptr_val_inject; try eapply VINJ2; eauto. i.
+  destruct (Val.cmplu_bool (Mem.valid_pointer m1) c (to_ptr_val m1 v1) (to_ptr_val m1 v2)) eqn:PCMP.
+  - destruct (Val.cmplu_bool (Mem.valid_pointer m1) c (to_int_val m1 v1) (to_int_val m1 v2)) eqn:ICMP.
+    + exploit cmplu_no_angelic; eauto. i. des; subst.
+      erewrite cmplu_bool_inject'; try eapply PCMP; eauto. erewrite cmplu_bool_inject'; try eapply ICMP; eauto.
+    + exploit cmplu_bool_inject'; try eapply PCMP; eauto. i.
+      destruct (Val.cmplu_bool (Mem.valid_pointer m2) c (to_int_val m2 v1') (to_int_val m2 v2')) eqn:ICMP'.
+      { exploit cmplu_no_angelic; eauto. i. des; subst. rewrite H3. rewrite bool_optjoin_same_bool. ss. }
+      rewrite H3. ss.
+  - destruct (Val.cmplu_bool (Mem.valid_pointer m1) c (to_int_val m1 v1) (to_int_val m1 v2)) eqn:ICMP; [|ss].
+    exploit cmplu_bool_inject'; try eapply ICMP; eauto. i. rewrite H3.
+    destruct (Val.cmplu_bool (Mem.valid_pointer m2) c (to_ptr_val m2 v1') (to_ptr_val m2 v2')) eqn:PCMP'; [|ss].
+    exploit cmplu_no_angelic; eauto. i. des; subst. simpl in CMP. inv CMP. eapply bool_optjoin_same_bool.
+Qed.
+
+Lemma cmpu_join_common_inject
+    c m1 m2 v1 v2 v1' v2' b
+    (MINJ: Mem.inject f m1 m2)
+    (VINJ1: Val.inject f v1 v1')
+    (VINJ2: Val.inject f v2 v2')
+    (CMP: cmpu_join_common m1 c v1 v2 = Some b) :
+  <<CMP: cmpu_join_common m2 c v1' v2' = Some b>>.
+Proof.
+  eapply cmpu_join_common_inj; eauto.
+- i. eapply Mem.mi_perm; eauto. eapply Mem.mi_inj; eauto.
+- i. eapply Mem.valid_pointer_inject_val; eauto.
+- i. eapply Mem.weak_valid_pointer_inject_val; eauto.
+- i. eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.
+- i. eapply Mem.different_pointers_inject; eauto.
+- i. eapply Mem.mi_src_concrete_private; eauto.
+- i. eapply Mem.mi_mappedblocks; eauto.
+- i. eapply Mem.mi_src_concrete_public; eauto.
+- i. eapply Mem.mi_representable; eauto.
+Qed.
+
+Lemma cmplu_join_common_inject
+    c m1 m2 v1 v2 v1' v2' b
+    (MINJ: Mem.inject f m1 m2)
+    (VINJ1: Val.inject f v1 v1')
+    (VINJ2: Val.inject f v2 v2')
+    (CMP: cmplu_join_common m1 c v1 v2 = Some b) :
+  <<CMP: cmplu_join_common m2 c v1' v2' = Some b>>.
+Proof.
+  eapply cmplu_join_common_inj; eauto.
+- i. eapply Mem.mi_perm; eauto. eapply Mem.mi_inj; eauto.
+- i. eapply Mem.valid_pointer_inject_val; eauto.
+- i. eapply Mem.weak_valid_pointer_inject_val; eauto.
+- i. eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.
+- i. eapply Mem.different_pointers_inject; eauto.
+- i. eapply Mem.mi_src_concrete_private; eauto.
+- i. eapply Mem.mi_mappedblocks; eauto.
+- i. eapply Mem.mi_src_concrete_public; eauto.
+- i. eapply Mem.mi_representable; eauto.
+Qed.
+
+End PTRBININJ.
+
+Section MemRel.
+
+Lemma perm_concrete_extends
+    m1 m2 b ofs k p
+    (CE: concrete_extends m1 m2)
+    (PERM: Mem.perm m1 b ofs k p):
+  <<PERM: Mem.perm m2 b ofs k p>>.
+Proof. inv CE. eauto. Qed.
+
+Lemma range_perm_concrete_extends
+    m1 m2 b lo hi k p
+    (CE: concrete_extends m1 m2)
+    (PERM: Mem.range_perm m1 b lo hi k p):
+  <<PERM: Mem.range_perm m2 b lo hi k p>>.
+Proof. ii. eapply perm_concrete_extends; eauto. Qed.
+
+Lemma valid_access_concrete_extends
+    m1 m2 chunk b ofs p
+    (CE: concrete_extends m1 m2)
+    (PERM: Mem.valid_access m1 chunk b ofs p):
+  <<PERM: Mem.valid_access m2 chunk b ofs p>>.
+Proof. unfold Mem.valid_access in *. des. split; auto. eapply range_perm_concrete_extends; eauto. Qed.
+
+Lemma same_conc_val_intptr m1 m2 v1 v2
+    (SAME: m1.(Mem.mem_concrete) = m2.(Mem.mem_concrete)) (BIND: val_intptr m1 v1 v2) :
+  <<BIND: val_intptr m2 v1 v2>>.
+Proof.
+  inv BIND; try by econs. econs; eauto. ss; unfold Mem.ptr2int_v, Mem.ptr2int in *. des_ifs_safe.
+  rewrite <- SAME. des_ifs.
+Qed.
+
+Lemma store_val_intptr chunk m1 m2 b ofs v v1 v2
+    (STORE:Mem.store chunk m1 b ofs v = Some m2) (BIND: val_intptr m1 v1 v2) :
+  <<BIND: val_intptr m2 v1 v2>>.
+Proof. eapply Mem.concrete_store in STORE. eapply same_conc_val_intptr; eauto. Qed.
+
+Lemma free_val_intptr m1 m2 b lo hi v1 v2
+    (FREE: Mem.free m1 b lo hi = Some m2) (BIND: val_intptr m1 v1 v2) :
+  <<BIND: val_intptr m2 v1 v2>>.
+Proof. eapply Mem.concrete_free in FREE. eapply same_conc_val_intptr; eauto. Qed.
+
+Lemma alloc_val_intptr m1 m2 b lo hi v1 v2
+    (ALLOC: Mem.alloc m1 lo hi = (m2, b)) (BIND: val_intptr m1 v1 v2) :
+  <<BIND: val_intptr m2 v1 v2>>.
+Proof. eapply Mem.concrete_alloc in ALLOC. eapply same_conc_val_intptr; eauto. Qed.
+
+Lemma same_concrete_memval_intptr
+    m1 m2 mv1 mv2
+    (SAME: m1.(Mem.mem_concrete) = m2.(Mem.mem_concrete))
+    (BIND: memval_intptr m1 mv1 mv2) :
+  <<BIND: memval_intptr m2 mv1 mv2>>.
+Proof.
+  inv BIND; ss; try by econs.
+  - econs; eauto. ss. unfold Mem.ptr2int in *. rewrite <- SAME. ss.
+  - econs; eauto. eapply same_conc_val_intptr; eauto.
+Qed.
+
+Lemma same_concrete_memval_intptr_list
+    m1 m2 mvl1 mvl2
+    (SAME: m1.(Mem.mem_concrete) = m2.(Mem.mem_concrete))
+    (BIND: list_forall2 (memval_intptr m1) mvl1 mvl2) :
+  <<BIND: list_forall2 (memval_intptr m2) mvl1 mvl2>>.
+Proof.
+  ginduction BIND; ss; i; [econs|].
+  econs; eauto; [eapply same_concrete_memval_intptr; eauto|].
+  eapply IHBIND; eauto.
+Qed.
+
+Lemma concrete_extends_perm
+    m1 m2 b ofs k p
+    (CE: concrete_extends m1 m2)
+    (PERM: Mem.perm m1 b ofs k p):
+  <<PERM: Mem.perm m2 b ofs k p>>.
+Proof. inv CE; eauto. Qed.
+
+Lemma concrete_extends_range_perm
+    m1 m2 b lo hi k p
+    (CE: concrete_extends m1 m2)
+    (PERM: Mem.range_perm m1 b lo hi k p):
+  <<PERM: Mem.range_perm m2 b lo hi k p>>.
+Proof. ii. eapply concrete_extends_perm; eauto. Qed.
+
+Lemma getN_concrete_extends
+    m1 m2 b ofs n 
+    (CE: concrete_extends m1 m2)
+    (PERM: Mem.range_perm m1 b ofs (ofs + Z.of_nat n) Cur Readable):
+  <<BINDED: list_forall2 (memval_intptr m2) (Mem.getN n ofs (Mem.mem_contents m1) # b) (Mem.getN n ofs (Mem.mem_contents m2) # b)>>.
+Proof.
+  revert PERM. revert ofs.
+  ginduction n; ss; ii; [econs|]. econs.
+- inv CE. eapply extended_contents0. eapply PERM. lia.
+- eapply IHn; eauto. ii. eapply PERM. lia.
+Qed.
+
+Lemma byte_memval_intptr_byte
+    m2 vl1 vl2 bl1
+    (BIND : list_forall2 (memval_intptr m2) vl1 vl2)
+    (PB1 : proj_bytes vl1 = Some bl1) :
+  <<PB2: exists bl2, proj_bytes vl2 = Some bl2 /\ bl1 = bl2>>.
+Proof.
+  ginduction BIND; ss; i.
+  { clarify. esplits; eauto. }
+  des_ifs; try by inv H.
+  2:{ exploit IHBIND; eauto. i. des; clarify. }
+  inv H. exploit IHBIND; eauto. i. des; clarify. esplits; eauto.
+Qed.
+
+(* Lemma pure_memval_intptr_pure *)
+(*   vl1 vl2 m *)
+(*   (UNDEF: ~ In Undef vl1) *)
+(*   (PURE: bytes_not_pure vl1 = false) *)
+(*   (BIND: list_forall2 (memval_intptr m) vl1 vl2) : *)
+(*   <<PURE: bytes_not_pure vl2 = false>>. *)
+(* Proof. *)
+(*   ginduction BIND; ss; i. *)
+(*   exploit IHBIND; eauto. i. *)
+(*   (* false : mix of two different pointer fragment in src - one pointer is captured byte in tgt *) *)
+(* Abort. *)
+
+Lemma inj_bytes_all_bytes bl:
+  <<BYTES: forallb is_byte_mv (inj_bytes bl) = true>>.
+Proof. ginduction bl; ss. Qed.
+
+Lemma setN_concrete_extends
+    (access: Z -> Prop) m vl1 vl2
+    (BIND: list_forall2 (memval_intptr m) vl1 vl2)
+    p c1 c2
+    (SRC: forall q, access q -> memval_intptr m (ZMap.get q c1) (ZMap.get q c2)):
+  (forall q, access q -> memval_intptr m (ZMap.get q (Mem.setN vl1 p c1))
+                                   (ZMap.get q (Mem.setN vl2 p c2))).
+Proof.
+  ginduction BIND; ii; ss; eauto.
+  eapply IHBIND; eauto.
+  i. rewrite ZMap.gsspec at 1. destruct (ZIndexed.eq q0 p).
+  { subst q0. rewrite ZMap.gss. auto. }
+  rewrite ZMap.gso. auto. unfold ZIndexed.t in *. lia.
+Qed.
+
+Lemma proj_bytes_binded m vl1 vl2 bl
+    (BIND: list_forall2 (memval_intptr m) vl1 vl2)
+    (BYTES: proj_bytes vl1 = Some bl) :
+  <<BYTES: proj_bytes vl2 = Some bl>>.
+Proof.
+  ginduction BIND; ss; i. des_ifs_safe. erewrite IHBIND; eauto. inv H; ss.
+Qed.
+
+Lemma intptr_val_intptr_intptr m vl1 vl2
+    (BIND: list_forall2 (memval_intptr m) vl1 vl2)
+    (IP: forallb Mem.is_intptr_mv vl1 = true):
+  <<IP: forallb Mem.is_intptr_mv vl2 = true>>.
+Proof.
+  ginduction BIND; ss. i.
+  eapply andb_prop in IP. des. rewrite IHBIND; eauto.
+  clear IHBIND. unfold Mem.is_intptr_mv in *. des_ifs; ss; inv H; inv H1.
+  repeat rewrite andb_true_iff in IP. des; subst. rewrite IP, IP1. auto.
+Qed.
+
+Lemma bytes_binded_bytes m vl1 vl2
+    (BIND: list_forall2 (memval_intptr m) vl1 vl2)
+    (BYTE: forallb is_byte_mv vl1 = true):
+  <<BYTE: forallb is_byte_mv vl2 = true /\ vl1 = vl2>>.
+Proof.
+  ginduction BIND; ss. i.
+  eapply andb_prop in BYTE. des. exploit IHBIND; eauto. i. des. subst.
+  clear IHBIND. unfold is_byte_mv in *. des_ifs; ss; inv H. esplits; eauto.
+Qed.
+
+Lemma ptrlike_binded_ptrlike m vl1 vl2
+    (BIND: list_forall2 (memval_intptr m) vl1 vl2)
+    (PL: forallb Mem.is_ptrlike_mv vl1 = true):
+  <<PL: forallb Mem.is_ptrlike_mv vl2 = true>>.
+Proof.
+  ginduction BIND; ss. i.
+  eapply andb_prop in PL. des. rewrite IHBIND; eauto.
+  clear IHBIND. unfold Mem.is_ptrlike_mv in *. des_ifs; ss; inv H; ss. des_ifs; inv H0.
+  all: destruct q; ss.
+Qed.
+
+Lemma notptr_binded_notptr m vl1 vl2
+    (BIND: list_forall2 (memval_intptr m) vl1 vl2)
+    (PTRL: forallb Mem.is_ptrlike_mv vl1 = true)
+    (IP: forallb is_ptr_mv vl1 = false):
+  <<IP: forallb is_ptr_mv vl2 = false>>.
+Proof.
+  ginduction BIND; ss. i.
+  rewrite andb_false_iff in IP. des.
+  { destruct a1; ss; [inv H; ss|]. des_ifs; inv H; inv H4; ss. des_ifs. }
+  erewrite IHBIND; eauto.
+  2:{ eapply andb_prop in PTRL; des. eauto. }
+  eapply andb_false_r.
+Qed.
+
+Lemma mixed_bind_mixed m vl1 vl2
+    (BIND: list_forall2 (memval_intptr m) vl1 vl2)
+    (MIX: Mem.is_mixed_mvs vl1 = true) : 
+  <<MIX: Mem.is_mixed_mvs vl2 = true>>.
+Proof.
+  unfold Mem.is_mixed_mvs in *. eapply andb_prop in MIX. des.
+  exploit ptrlike_binded_ptrlike; eauto. i. rewrite H. ss.
+  rewrite negb_true_iff in MIX0. erewrite notptr_binded_notptr; eauto.
+Qed.
+
+Lemma normalize_check_bind_normalize_check
+    chunk m1 m2 vl1 vl2
+    (CE: concrete_extends m1 m2)
+    (BIND: list_forall2 (memval_intptr m2) vl1 vl2)
+    (MIX: Mem.normalize_check chunk vl1 = true) : 
+  <<MIX: Mem.normalize_check chunk vl2 = true>>.
+Proof.
+  unfold Mem.normalize_check in *. des_ifs; eapply andb_prop in MIX; des;
+  erewrite mixed_bind_mixed; eauto.
+Qed.
+
+Lemma check_value_is_ptr n b ofs vl
+    (CHECK: check_value n (Vptr b ofs) Q64 vl = true):
+  <<PTR: forallb is_ptr_mv vl = true>>.
+Proof.
+  ginduction n; ss; i; des_ifs.
+  des_ifs. repeat rewrite andb_true_iff in CHECK. des.
+  destruct v; destruct q; ss. des_ifs. erewrite IHn; eauto.
+Qed.
+
+Lemma check_value_not_ptrlike n' n v vl
+    (NOTPTR: Mem.is_ptrlike_mv (Fragment v Q64 n') = false)
+    (CHECK: check_value n v Q64 vl = true):
+  <<PTR: forallb (fun mv => (negb (Mem.is_ptrlike_mv mv))) vl = true>>.
+Proof.
+  ginduction n; ss; i; des_ifs. des_ifs. InvBooleans. subst.
+  simpl. erewrite IHn; eauto. unfold Mem.is_ptrlike_mv in *. clear - NOTPTR. ss. des_ifs.
+Qed.
+
+(* move to memory.v *)
+Lemma normalize_fail chunk m vl
+    (MIX: Mem.normalize_check chunk vl = true)
+    (FAIL: forallb is_byte_mv (Mem.normalize_mvs chunk m vl) = false) :
+  <<UNDEF: decode_val chunk (Mem.normalize_mvs chunk m vl) = Vundef>>.
+Proof.
+  unfold decode_val. rewrite Mem.not_bytes_proj_bytes_fail; eauto.
+  unfold Mem.normalize_mvs in *. rewrite MIX in *. des_ifs.
+  - destruct vl as [| mv vl]; [ss|]. simpl in FAIL. destruct mv; simpl in FAIL; try by (ss; eauto).
+    des_ifs.
+    { destruct v; try by (ss; clarify).
+      - simpl in Heq0. clarify. simpl. des_ifs_safe. exfalso. ss. rewrite Heq1 in Heq0. clear - Heq1 Heq0.
+        subst. eapply nth_error_in in Heq1. unfold rev_if_be_mv in Heq1. des_ifs.
+        rewrite <- in_rev in Heq1. eapply Mem.inj_bytes_no_fragment; eauto. rewrite encode_int_length. lia.
+      - simpl in Heq0. clarify. simpl. des_ifs_safe. exfalso. ss. clear - Heq0.
+        subst. eapply nth_error_in in Heq0. unfold rev_if_be_mv in Heq0. des_ifs.
+        rewrite <- in_rev in Heq0. eapply Mem.inj_bytes_no_fragment; eauto. rewrite encode_int_length. lia. }
+    { unfold Mem._decode_normalize_mv. simpl. rewrite Heq0, Heq1.
+      destruct v; simpl in Heq0; clarify; des_ifs_safe.
+      - repeat rewrite andb_true_iff in Heq0. des. clarify.
+      - repeat rewrite andb_true_iff in Heq2. des. clarify. }
+    { simpl in FAIL. destruct v; simpl in Heq0; clarify. des_ifs.
+      (* proj val success -> all ptr -> not mixed. see Mem.long_proj_long_fragment *)
+      destruct (check_value (size_quantity_nat Q64) (Vptr b i) Q64 (map (Mem._decode_normalize_mv m) (Fragment (Vptr b i) q n :: vl))) eqn: CHECK'.
+      2:{ unfold proj_value. des_ifs. simpl in Heq2. des_ifs. }
+      destruct (check_value (size_quantity_nat Q64) (Vptr b i) q (map (Mem._decode_normalize_mv m) (Fragment (Vptr b i) q n :: vl))) eqn: CHECK.
+      2:{ unfold proj_value. des_ifs. simpl in Heq2. des_ifs.
+          assert (q0 = Q64).
+          { simpl in Heq3. repeat rewrite andb_true_iff in Heq3. des. destruct q0; ss. }
+          subst. clarify. }
+      assert (forallb is_ptr_mv (map (Mem._decode_normalize_mv m) (Fragment (Vptr b i) q n :: vl)) = true).
+      { eapply check_value_is_ptr; eauto. }
+      clear CHECK'.
+      assert (forallb is_ptr_mv (Fragment (Vptr b i) q n :: vl) = true).
+      { (* make lemma *)
+        rewrite forallb_forall in *. ii. eapply in_map with (f:= (Mem._decode_normalize_mv m)) in H0.
+        eapply H in H0. clear - H0. destruct x; ss. unfold Mem.to_int in H0.
+        destruct v; try by ss.
+        - ss. des_ifs. specialize (inj_bytes_all_bytes (encode_int 4 (Int.unsigned i))). i.
+          eapply nth_error_In in Heq. unfold rev_if_be_mv in *. des_ifs. ss.
+          r in H. rewrite <- in_rev in Heq. rewrite forallb_forall in H. eapply H in Heq. destruct m0; ss.
+        - ss. des_ifs. specialize (inj_bytes_all_bytes (encode_int 8 (Int64.unsigned i))). i.
+          eapply nth_error_In in Heq. unfold rev_if_be_mv in *. des_ifs. ss.
+          r in H. rewrite <- in_rev in Heq. rewrite forallb_forall in H. eapply H in Heq. destruct m0; ss.
+        - ss. des_ifs. ss. specialize (inj_bytes_all_bytes (encode_int 8 (Int64.unsigned (Int64.repr z)))). i.
+          eapply nth_error_In in Heq1. unfold rev_if_be_mv in *. des_ifs. ss.
+          r in H. rewrite <- in_rev in Heq1. rewrite forallb_forall in H. eapply H in Heq1. destruct m0; ss. }
+      unfold Mem.normalize_check, Mem.is_mixed_mvs in MIX. rewrite H0 in MIX.
+      repeat rewrite andb_true_iff in MIX. des. ss. }
+  - destruct vl as [| mv vl]; [ss|]. simpl in FAIL. destruct mv; simpl in FAIL; try by (ss; eauto).
+    des_ifs.
+    { destruct v; try by (ss; clarify).
+      - simpl in Heq. clarify. simpl. des_ifs_safe. exfalso. ss. rewrite Heq0 in Heq. clear - Heq Heq0.
+        subst. eapply nth_error_in in Heq0. unfold rev_if_be_mv in Heq0. des_ifs.
+        rewrite <- in_rev in Heq0. eapply Mem.inj_bytes_no_fragment; eauto. rewrite encode_int_length. lia.
+      - simpl in Heq. clarify. simpl. des_ifs_safe. exfalso. ss. clear - Heq.
+        subst. eapply nth_error_in in Heq. unfold rev_if_be_mv in Heq. des_ifs.
+        rewrite <- in_rev in Heq. eapply Mem.inj_bytes_no_fragment; eauto. rewrite encode_int_length. lia. }
+    { unfold Mem._decode_normalize_mv. simpl. rewrite Heq, Heq0.
+      destruct v; simpl in Heq; clarify; des_ifs_safe.
+      - repeat rewrite andb_true_iff in Heq. des. clarify.
+      - repeat rewrite andb_true_iff in Heq1. des. clarify. }
+    { simpl in FAIL. destruct v; simpl in Heq; clarify. des_ifs.
+      (* proj val success -> all ptr -> not mixed. see Mem.long_proj_long_fragment *)
+      destruct (check_value (size_quantity_nat Q64) (Vptr b i) Q64 (map (Mem._decode_normalize_mv m) (Fragment (Vptr b i) q n :: vl))) eqn: CHECK'.
+      2:{ unfold proj_value. des_ifs. simpl in Heq1. des_ifs. }
+      destruct (check_value (size_quantity_nat Q64) (Vptr b i) q (map (Mem._decode_normalize_mv m) (Fragment (Vptr b i) q n :: vl))) eqn: CHECK.
+      2:{ unfold proj_value. des_ifs. simpl in Heq1. des_ifs.
+          assert (q0 = Q64).
+          { simpl in Heq2. repeat rewrite andb_true_iff in Heq2. des. destruct q0; ss. }
+          subst. clarify. }
+      assert (forallb is_ptr_mv (map (Mem._decode_normalize_mv m) (Fragment (Vptr b i) q n :: vl)) = true).
+      { eapply check_value_is_ptr; eauto. }
+      clear CHECK'.
+      assert (forallb is_ptr_mv (Fragment (Vptr b i) q n :: vl) = true).
+      { (* make lemma *)
+        rewrite forallb_forall in *. ii. eapply in_map with (f:= (Mem._decode_normalize_mv m)) in H0.
+        eapply H in H0. clear - H0. destruct x; ss. unfold Mem.to_int in H0.
+        destruct v; try by ss.
+        - ss. des_ifs. specialize (inj_bytes_all_bytes (encode_int 4 (Int.unsigned i))). i.
+          eapply nth_error_In in Heq. unfold rev_if_be_mv in *. des_ifs. ss.
+          r in H. rewrite <- in_rev in Heq. rewrite forallb_forall in H. eapply H in Heq. destruct m0; ss.
+        - ss. des_ifs. specialize (inj_bytes_all_bytes (encode_int 8 (Int64.unsigned i))). i.
+          eapply nth_error_In in Heq. unfold rev_if_be_mv in *. des_ifs. ss.
+          r in H. rewrite <- in_rev in Heq. rewrite forallb_forall in H. eapply H in Heq. destruct m0; ss.
+        - ss. des_ifs. ss. specialize (inj_bytes_all_bytes (encode_int 8 (Int64.unsigned (Int64.repr z)))). i.
+          eapply nth_error_In in Heq1. unfold rev_if_be_mv in *. des_ifs. ss.
+          r in H. rewrite <- in_rev in Heq1. rewrite forallb_forall in H. eapply H in Heq1. destruct m0; ss. }
+      unfold Mem.normalize_check, Mem.is_mixed_mvs in MIX. rewrite H0 in MIX.
+      repeat rewrite andb_true_iff in MIX. des. ss. }
+Qed.
+
+Lemma binded_normalize_binded m1 m2 vl1 vl2 chunk
+    (CE : concrete_extends m1 m2)
+    (UNDEF1 : ~ In Undef vl1)
+    (UNDEF2 : forall q n, ~ In (Fragment Vundef q n) vl1)
+  (BIND : list_forall2 (memval_intptr m2) vl1 vl2):
+  <<BIND: list_forall2 (memval_intptr m2) (Mem.normalize_mvs chunk m1 vl1) (Mem.normalize_mvs chunk m2 vl2)>>.
+Proof.
+  destruct (Mem.normalize_check chunk vl1) eqn:MIXED1.
+  { exploit normalize_check_bind_normalize_check; eauto. intros MIXED2.
+    unfold Mem.normalize_mvs. rewrite MIXED1, MIXED2.
+    assert (PTRL1: forallb Mem.is_ptrlike_mv vl1 = true).
+    { clear - MIXED1. unfold Mem.normalize_check, Mem.is_mixed_mvs in MIXED1. des_ifs; ss.
+      - do 2 rewrite andb_true_iff in *. des; eauto.
+      - do 2 rewrite andb_true_iff in *. des; eauto. }
+    clear MIXED1 MIXED2.
+    ginduction BIND; i; ss; [econs|].
+    econs; eauto.
+    2:{ eapply IHBIND; eauto. ii. eapply UNDEF2. eauto. eapply andb_prop in PTRL1. des; eauto. }
+    inv H; ss; try by econs.
+    - des_ifs; try by econs.
+      2:{ ss. rewrite nth_error_None in Heq0.
+          assert (z = z0).
+          { unfold Mem.ptr2int in *. des_ifs. eapply extended_concrete in Heq3; eauto. clarify. }
+          subst. exploit nth_error_Some. erewrite H3. ii. inv H. exploit H1; eauto; ii; clarify. lia. }
+      2:{ econs; eauto; ss.
+          - ss. rewrite Heq2. des_ifs.
+          - ss. }
+      assert (z = z0).
+      { unfold Mem.ptr2int in *. des_ifs. eapply extended_concrete in Heq3; eauto. clarify. }
+      subst. ss. clarify. econs.
+    - inv H0; ss; try by (econs; econs).
+      + eapply memval_intptr_refl.
+      + unfold Mem.ptr2int.
+        destruct ((Mem.mem_concrete m1) ! b) eqn:CONC1; cycle 1.
+        { destruct ((Mem.mem_concrete m2) ! b) eqn:CONC2; cycle 1.
+          { eapply memval_intptr_refl. }
+          des_ifs; cycle 1.
+          { eapply memval_intptr_refl. }
+          ss. dup Heq.
+          unfold rev_if_be_mv in Heq1. des_ifs. eapply nth_error_In in Heq1.
+          rewrite <- in_rev in Heq1. 
+          specialize (inj_bytes_all_bytes (encode_int 8 (Int64.unsigned (Int64.repr (z + Ptrofs.unsigned ofs))))).
+          i. des. rewrite forallb_forall in H. exploit H; eauto. i. destruct m; ss.
+          exploit memval_intptr_byte_frag64; eauto.
+          { instantiate (2:=m2). unfold Mem.to_int. ss. unfold Mem.ptr2int. rewrite CONC2. instantiate (2:=ofs).
+            des_ifs. }
+          { unfold Mptr. des_ifs. ss. eauto. }
+          i. eauto. eapply andb_prop in PTRL1. des. destruct q; ss. }
+        eapply extended_concrete in CONC1; eauto. rewrite CONC1. eapply memval_intptr_refl.
+      + des_ifs_safe.
+        destruct (Mem.ptr2int b (Ptrofs.unsigned ofs) m1) eqn:P.
+        2:{ des_ifs.
+            2:{ econs. econs; eauto. ss. unfold Mem.ptr2int_v. rewrite Heq. ss. }
+            unfold rev_if_be_mv in Heq0. des_ifs. (* unfold Mem.ptr2int in Heq. des_ifs. *)
+            assert (exists byt, m = Byte byt).
+            { eapply nth_error_In in Heq0. rewrite <- in_rev in Heq0. clear - Heq0.
+              specialize (inj_bytes_all_bytes (encode_int 8 (Int64.unsigned (Int64.repr z)))). i.
+              r in H. rewrite forallb_forall in H. eapply H in Heq0. destruct m; ss. eauto. }
+            des. subst.
+            assert (q = Q64).
+            { eapply andb_prop in PTRL1. des. clear - PTRL1. destruct q; ss. }
+            subst. exploit memval_intptr_byte_frag64; eauto.
+            { ss. erewrite Heq. ss. }
+            { unfold rev_if_be_mv. des_ifs. } }
+        ss. assert (z = z0).
+        { unfold Mem.ptr2int in *. des_ifs. eapply extended_concrete in Heq0; eauto. clarify. }
+        subst. des_ifs.
+        { eapply memval_intptr_refl. }
+        econs; eauto. econs; eauto. ss. rewrite Heq. ss. }
+  destruct (Mem.normalize_check chunk vl2) eqn:MIXED2.
+  2:{ unfold Mem.normalize_mvs. des_ifs. }
+  unfold Mem.normalize_mvs. rewrite MIXED1, MIXED2.
+  assert (forallb is_ptr_mv vl1 = true).
+  { unfold Mem.normalize_check in *. des_ifs.
+    - eapply andb_prop in MIXED2. des. rewrite MIXED2 in MIXED1. ss.
+      eapply andb_prop in MIXED0. des.
+      assert (forallb Mem.is_ptrlike_mv vl1 = true).
+      { clear MIXED3 MIXED1. ginduction BIND; ss. ii. rewrite andb_true_iff in *. des. split.
+        { inv H; ss.
+          - inv H0; ss.
+            2:{ exfalso. eapply UNDEF2. eauto. }
+            des_ifs. ss. clear - MIXED0. unfold Mem.is_ptrlike_mv in *. ss. des_ifs. destruct q; ss.
+          - exfalso. eapply UNDEF2. eauto.
+          - exfalso. eapply UNDEF1. eauto. }
+        eapply IHBIND; eauto. ii. eapply UNDEF2. eauto. }
+      unfold Mem.is_mixed_mvs in MIXED1. rewrite H in MIXED1. ss. rewrite negb_false_iff in MIXED1. ss.
+    - eapply andb_prop in MIXED2. des. rewrite MIXED2 in MIXED1. ss.
+      eapply andb_prop in MIXED0. des.
+      assert (forallb Mem.is_ptrlike_mv vl1 = true).
+      { clear MIXED3 MIXED1. ginduction BIND; ss. ii. rewrite andb_true_iff in *. des. split.
+        { inv H; ss.
+          - inv H0; ss.
+            2:{ exfalso. eapply UNDEF2. eauto. }
+            des_ifs. ss. clear - MIXED0. unfold Mem.is_ptrlike_mv in *. ss. des_ifs. destruct q; ss.
+          - exfalso. eapply UNDEF2. eauto.
+          - exfalso. eapply UNDEF1. eauto. }
+        eapply IHBIND; eauto. ii. eapply UNDEF2. eauto. }
+      unfold Mem.is_mixed_mvs in MIXED1. rewrite H in MIXED1. ss. rewrite negb_false_iff in MIXED1. ss. }
+  clear MIXED1 MIXED2.
+  ginduction BIND; ss; ii; [econs|].
+  eapply andb_prop in H0. des. econs; eauto.
+  2:{ eapply IHBIND; eauto. ii. eapply UNDEF2; eauto. }
+  inv H; try by ss.
+  - econs; eauto.
+  - simpl in H0. des_ifs. inv H2; ss.
+    + des_ifs; try by (econs; econs). ss.
+      assert (exists b, m = Byte b).
+      { specialize (inj_bytes_all_bytes (encode_int 8 (Int64.unsigned (Int64.repr z)))). i.
+        r in H. eapply nth_error_In in Heq1. rewrite forallb_forall in H.
+        unfold rev_if_be_mv in Heq1. des_ifs. rewrite <- in_rev in Heq1.
+        eapply H in Heq1. destruct m; ss. eauto. }
+      des. subst. destruct q; ss. econs; eauto.
+      { ss. rewrite Heq2. des_ifs. }
+      ss.
+    + des_ifs.
+      2:{ econs; eauto. econs; eauto. ss; unfold Mem.ptr2int_v. rewrite Heq1. ss. }
+      assert (exists b, m = Byte b).
+      { specialize (inj_bytes_all_bytes (encode_int 8 (Int64.unsigned (Int64.repr z)))). i.
+        r in H. eapply nth_error_In in Heq0. rewrite forallb_forall in H.
+        unfold rev_if_be_mv in Heq0. des_ifs. rewrite <- in_rev in Heq0.
+        eapply H in Heq0. destruct m; ss. eauto. }
+      des. subst. destruct q; ss. econs; eauto.
+      { ss. rewrite Heq1. des_ifs. }
+      ss.
+Qed.
+
+Lemma not_ptrlike_not_normalize chunk vl
+    (PTRL: forallb Mem.is_ptrlike_mv vl = false):
+  <<NORM: Mem.normalize_check chunk vl = false>>.
+Proof.
+  unfold Mem.normalize_check, Mem.is_mixed_mvs. rewrite PTRL. ss. des_ifs.
+Qed.
+
+Lemma remove_inj_byte l1 l2
+    (BYTE: map Byte l1 = map Byte l2): l1 = l2.
+Proof.
+  ginduction l1; ss; i; [destruct l2; ss|].
+  destruct l2; ss. clarify. erewrite IHl1; eauto.
+Qed.
+
+Lemma ptr_byte_binded vl1 vl2 chunk m
+  (CHUNK: chunk = Mint64 \/ chunk = Many64)
+  (LEN: ((Datatypes.length vl1) > 0)%nat)
+  (PTR : forallb is_ptr_mv vl1 = true)
+  (BYTE: forallb is_byte_mv vl2 = true)
+  (BIND: list_forall2 (memval_intptr m) vl1 vl2):
+  <<BIND: val_intptr m (decode_val chunk vl1) (decode_val chunk vl2)>>.
+Proof.
+  unfold decode_val.
+  assert (PB1: proj_bytes vl1 = None).
+  { clear - LEN PTR. ginduction vl1; ss; i; [lia|]. des_ifs; ss. }
+  assert (PB2: exists bl2, proj_bytes vl2 = Some bl2).
+  { clear - BYTE. ginduction vl2; ss; i.
+    - esplits; eauto.
+    - eapply andb_prop in BYTE. des. exploit IHvl2; eauto. i. des. des_ifs. esplits; eauto. }
+  des; rewrite PB1, PB2; subst; ss.
+  - des_ifs; try by econs.
+    { unfold proj_value in Heq0. des_ifs. }
+    unfold proj_value in Heq0. des_ifs.
+    econs; eauto. simpl. unfold Mem.ptr2int_v. des_ifs.
+    2:{ inv BIND. inv H1; try by ss. simpl in H7. des_ifs. }
+    assert (bl2 = (encode_int 8 (Int64.unsigned (Int64.repr z)))).
+    { simpl in Heq1.
+      (* 7 *)
+      repeat rewrite andb_true_iff in Heq1. des. destruct q; ss.
+      assert (n = 7%nat) by (clear - Heq3; des_ifs). subst.
+      (* 6 *)
+      destruct l; clarify. destruct m0; ss. des_ifs_safe.
+      repeat rewrite andb_true_iff in Heq2. des. destruct q; ss.
+      assert (n = 6%nat) by (clear - Heq6; des_ifs). subst.
+      (* 5 *)
+      destruct l; clarify. destruct m0; ss. des_ifs_safe.
+      repeat rewrite andb_true_iff in Heq5. des. destruct q; ss.
+      assert (n = 5%nat) by (clear - Heq9; des_ifs). subst.
+      (* 4 *)
+      destruct l; clarify. destruct m0; ss. des_ifs_safe.
+      repeat rewrite andb_true_iff in Heq8. des. destruct q; ss.
+      assert (n = 4%nat) by (clear - Heq12; des_ifs). subst.
+      (* 3 *)
+      destruct l; clarify. destruct m0; ss. des_ifs_safe.
+      repeat rewrite andb_true_iff in Heq11. des. destruct q; ss.
+      assert (n = 3%nat) by (clear - Heq15; des_ifs). subst.
+      (* 2 *)
+      destruct l; clarify. destruct m0; ss. des_ifs_safe.
+      repeat rewrite andb_true_iff in Heq14. des. destruct q; ss.
+      assert (n = 2%nat) by (clear - Heq18; des_ifs). subst.
+      (* 1 *)
+      destruct l; clarify. destruct m0; ss. des_ifs_safe.
+      repeat rewrite andb_true_iff in Heq17. des. destruct q; ss.
+      assert (n = 1%nat) by (clear - Heq21; des_ifs). subst.
+      (* 0 *)
+      destruct l; clarify. destruct m0; ss. des_ifs_safe.
+      repeat rewrite andb_true_iff in Heq20. des. destruct q; ss.
+      assert (n = 0%nat) by (clear - Heq24; des_ifs). subst.
+      des_ifs_safe.
+      eapply proj_sumbool_true in Heq1, Heq2, Heq5, Heq8, Heq11, Heq14, Heq17, Heq20.
+      clarify.
+      inv BIND. inv H1; ss. unfold Mptr in *. des_ifs_safe.
+      inv H3. inv H1; ss. unfold Mptr in *. des_ifs_safe.
+      rewrite Heq2 in Heq8. clarify.
+      inv H5. inv H1; ss. unfold Mptr in *. des_ifs_safe.
+      rewrite Heq2 in Heq0. clarify.
+      inv H6. inv H1; ss. unfold Mptr in *. des_ifs_safe.
+      rewrite Heq2 in Heq0. clarify.
+      inv H7. inv H1; ss. unfold Mptr in *. des_ifs_safe.
+      rewrite Heq2 in Heq0. clarify.
+      inv H8. inv H1; ss. unfold Mptr in *. des_ifs_safe.
+      rewrite Heq2 in Heq0. clarify.
+      inv H9. inv H1; ss. unfold Mptr in *. des_ifs_safe.
+      rewrite Heq2 in Heq0. clarify.
+      inv H10. inv H1; ss. unfold Mptr in *. des_ifs_safe.
+      rewrite Heq2 in Heq0. clarify.
+      inv H11. ss. clarify. unfold rev_if_be_mv in *. des_ifs.
+      assert (l0 = []); subst.
+      { destruct l0; ss. }
+      assert (rev (rev (inj_bytes (encode_int 8 (Int64.unsigned (Int64.repr z))))) =
+                rev [Byte bt6; Byte bt5; Byte bt4; Byte bt3; Byte bt2; Byte bt1; Byte bt0; Byte bt]).
+      { rewrite Heq2. ss. }
+      clear Heq2. rewrite rev_involutive in H. ss. unfold inj_bytes in H.
+      replace [Byte bt; Byte bt0; Byte bt1; Byte bt2; Byte bt3; Byte bt4; Byte bt5; Byte bt6] with
+        (map Byte [bt; bt0; bt1; bt2; bt3; bt4; bt5; bt6]) in H by ss.
+      eapply remove_inj_byte; eauto. }
+    subst. erewrite decode_encode_int_8; eauto.
+  - unfold proj_value. des_ifs; [| econs]. simpl in PTR. des_ifs_safe. destruct q; try by ss.
+    eapply andb_prop in PTR. des. clear PTR.
+    econs; eauto. simpl. unfold Mem.ptr2int_v. des_ifs.
+    2:{ inv BIND. inv H1; try by ss. simpl in H5. des_ifs. }
+    assert (bl2 = (encode_int 8 (Int64.unsigned (Int64.repr z)))).
+    { simpl in Heq.
+      (* 7 *)
+      repeat rewrite andb_true_iff in Heq. des. (* destruct q; ss. *)
+      assert (n = 7%nat) by (clear - Heq3; des_ifs). subst.
+      (* 6 *)
+      destruct l; clarify. destruct m0; ss. des_ifs_safe.
+      repeat rewrite andb_true_iff in Heq2. des. destruct q; ss.
+      assert (n = 6%nat) by (clear - Heq6; des_ifs). subst.
+      (* 5 *)
+      destruct l; clarify. destruct m0; ss. des_ifs_safe.
+      repeat rewrite andb_true_iff in Heq5. des. destruct q; ss.
+      assert (n = 5%nat) by (clear - Heq9; des_ifs). subst.
+      (* 4 *)
+      destruct l; clarify. destruct m0; ss. des_ifs_safe.
+      repeat rewrite andb_true_iff in Heq8. des. destruct q; ss.
+      assert (n = 4%nat) by (clear - Heq12; des_ifs). subst.
+      (* 3 *)
+      destruct l; clarify. destruct m0; ss. des_ifs_safe.
+      repeat rewrite andb_true_iff in Heq11. des. destruct q; ss.
+      assert (n = 3%nat) by (clear - Heq15; des_ifs). subst.
+      (* 2 *)
+      destruct l; clarify. destruct m0; ss. des_ifs_safe.
+      repeat rewrite andb_true_iff in Heq14. des. destruct q; ss.
+      assert (n = 2%nat) by (clear - Heq18; des_ifs). subst.
+      (* 1 *)
+      destruct l; clarify. destruct m0; ss. des_ifs_safe.
+      repeat rewrite andb_true_iff in Heq17. des. destruct q; ss.
+      assert (n = 1%nat) by (clear - Heq21; des_ifs). subst.
+      (* 0 *)
+      destruct l; clarify. destruct m0; ss. des_ifs_safe.
+      repeat rewrite andb_true_iff in Heq20. des. destruct q; ss.
+      assert (n = 0%nat) by (clear - Heq24; des_ifs). subst.
+      des_ifs_safe.
+      InvBooleans. clarify. clarify.
+      inv BIND. inv H4; ss. unfold Mptr in *. des_ifs_safe.
+      inv H6. inv H4; ss. unfold Mptr in *. des_ifs_safe.
+      rewrite Heq5 in Heq. clarify.
+      inv H8. inv H4; ss. unfold Mptr in *. des_ifs_safe.
+      rewrite Heq5 in Heq. clarify.
+      inv H10. inv H4; ss. unfold Mptr in *. des_ifs_safe.
+      rewrite Heq5 in Heq. clarify.
+      inv H11. inv H4; ss. unfold Mptr in *. des_ifs_safe.
+      rewrite Heq5 in Heq. clarify.
+      inv H12. inv H4; ss. unfold Mptr in *. des_ifs_safe.
+      rewrite Heq5 in Heq. clarify.
+      inv H13. inv H4; ss. unfold Mptr in *. des_ifs_safe.
+      rewrite Heq5 in Heq. clarify.
+      inv H14. inv H4; ss. unfold Mptr in *. des_ifs_safe.
+      rewrite Heq5 in Heq. clarify.
+      inv H15. ss. clarify. unfold rev_if_be_mv in *. des_ifs.
+      assert (l0 = []); subst.
+      { destruct l0; ss. }
+      assert (rev (rev (inj_bytes (encode_int 8 (Int64.unsigned (Int64.repr z))))) =
+                rev [Byte bt6; Byte bt5; Byte bt4; Byte bt3; Byte bt2; Byte bt1; Byte bt0; Byte bt]).
+      { rewrite Heq5. ss. }
+      clear Heq5. rewrite rev_involutive in H2. ss. unfold inj_bytes in H2.
+      replace [Byte bt; Byte bt0; Byte bt1; Byte bt2; Byte bt3; Byte bt4; Byte bt5; Byte bt6] with
+        (map Byte [bt; bt0; bt1; bt2; bt3; bt4; bt5; bt6]) in H2 by ss.
+      symmetry. eapply remove_inj_byte; eauto. }
+    subst. erewrite decode_encode_int_8; eauto.
+Qed.
+
+Lemma load_result_binded chunk m v1 v2
+    (BIND: val_intptr m v1 v2):
+  <<BIND: val_intptr m (Val.load_result chunk v1) (Val.load_result chunk v2)>>.
+Proof.
+  inv BIND; destruct chunk; ss; try by econs.
+Qed.
+
+(* move *)
+Lemma proj_bytes_Some_bytes vl bl
+    (BYTES: proj_bytes vl = Some bl):
+  <<BYTES: forallb is_byte_mv vl = true>>.
+Proof. ginduction vl; ss; i. des_ifs; ss. erewrite IHvl; eauto. Qed.
+
+(* move *)
+Lemma check_value_binded
+    m vl vl'
+    (BIND: list_forall2 (memval_intptr m) vl vl')
+    (PTR1: forallb is_ptr_mv vl = true)
+    (PTR2: forallb is_ptr_mv vl' = true)
+    v v' q n
+    (CHECK: check_value n v q vl = true)
+    (BINDV: val_intptr m v v') (PTR: exists b' ofs', v' = Vptr b' ofs'):
+  <<CHECK: check_value n v' q vl' = true>>.
+Proof.
+  ginduction BIND; i; destruct n; simpl in *; auto.
+  inv H; auto.
+  InvBooleans. assert (n = n0) by (apply beq_nat_true; auto). subst v1 q0 n0.
+  replace v2 with v'.
+  { unfold proj_sumbool; rewrite ! dec_eq_true. rewrite <- beq_nat_refl. simpl; eauto. }
+  des. inv BINDV; try discriminate; inv H0; ss.
+Qed.
+
+Lemma proj_value_inject:
+  forall f q vl1 vl2,
+  list_forall2 (memval_inject f) vl1 vl2 ->
+  Val.inject f (proj_value q vl1) (proj_value q vl2).
+Proof.
+  intros. unfold proj_value.
+  inversion H; subst. auto. inversion H0; subst; auto.
+  destruct (check_value (size_quantity_nat q) v1 q (Fragment v1 q0 n :: al)) eqn:B; auto.
+  destruct (Val.eq v1 Vundef). subst; auto.
+  erewrite check_value_inject by eauto. auto.
+Qed.
+
+(* Lemma check_value_binded_no_ptrlike *)
+(*     m vl1 vl2 n v1 v2 q  *)
+(*     (NPTRL1: forallb Mem.is_ptrlike_mv vl1 = false) *)
+(*     (BIND: list_forall2 (memval_intptr m) vl1 vl2) *)
+(*     (CHECK: check_value n v1 q vl1 = true) *)
+(*     (BINDV: val_intptr m v1 v2) *)
+(*     (UNDEF: v1 <> Vundef) : *)
+(*   <<CHECK: check_value n v2 q vl2 = true>>. *)
+(* Proof. *)
+(*   ginduction BIND; ss. i. destruct n; ss. inv H; ss. *)
+(*   { eapply andb_false_iff in NPTRL1. des; ss. InvBooleans; subst. *)
+(*     eapply check_value_is_ptr in H2. exfalso. eapply forallb_false_forall in NPTRL1. *)
+(*     eapply NPTRL1. ii. eapply forallb_forall in H2; eauto. unfold Mem.is_ptrlike_mv. rewrite H2. *)
+(*     rewrite orb_true_r. ss. } *)
+(*   2:{ InvBooleans; subst. clarify. } *)
+(*   InvBooleans. des; subst. des_ifs_safe. *)
+(*   assert (v2 = v3). *)
+(*   { inv BINDV; try discriminate; inv H0; auto; ss. *)
+(*     3:{ des_ifs. } *)
+(*     (* this lemma is not true. because Q32 Vptr is not ptrlike but it can have binded long with Q32. *)
+(*        Q32 Vptr will be Vundef by Val.load_result function. not proj_value level -> Q64(Q32 at 32bit) needed. *) *)
+(* Abort. *)
+
+Lemma check_value_binded_no_ptrlike
+    m vl1 vl2 n v1 v2
+    (NPTRL1: forallb Mem.is_ptrlike_mv vl1 = false)
+    (BIND: list_forall2 (memval_intptr m) vl1 vl2)
+    (CHECK: check_value n v1 Q64 vl1 = true)
+    (BINDV: val_intptr m v1 v2)
+    (UNDEF: v1 <> Vundef) :
+  <<CHECK: check_value n v2 Q64 vl2 = true>>.
+Proof.
+  ginduction BIND; ss. i. destruct n; ss. inv H; ss.
+  { eapply andb_false_iff in NPTRL1. des; ss. InvBooleans; subst.
+    eapply check_value_is_ptr in H2. exfalso. eapply forallb_false_forall in NPTRL1.
+    eapply NPTRL1. ii. eapply forallb_forall in H2; eauto. unfold Mem.is_ptrlike_mv. rewrite H2.
+    rewrite orb_true_r. ss. }
+  2:{ InvBooleans; subst. clarify. }
+  InvBooleans. des; subst. des_ifs_safe.
+  assert (v2 = v3).
+  { inv BINDV; try discriminate; inv H0; auto; ss.
+    3:{ des_ifs. }
+    - eapply andb_false_iff in NPTRL1. des; ss.
+      exploit check_value_is_ptr; eauto. i. exfalso. eapply forallb_false_forall in NPTRL1.
+      eapply NPTRL1. ii. eapply forallb_forall in H; eauto. unfold Mem.is_ptrlike_mv. rewrite H.
+      rewrite orb_true_r. ss.
+    - eapply andb_false_iff in NPTRL1. des; ss.
+      exploit check_value_is_ptr; eauto. i. exfalso. eapply forallb_false_forall in NPTRL1.
+      eapply NPTRL1. ii. eapply forallb_forall in H0; eauto. unfold Mem.is_ptrlike_mv. rewrite H0.
+      rewrite orb_true_r. ss. }
+  subst. r. eapply andb_false_iff in NPTRL1. des.
+  - destruct al.
+    { destruct n; ss. inv BIND. ss. repeat rewrite andb_true_iff. esplits; eauto.
+      unfold proj_sumbool. des_ifs. }
+    exploit check_value_not_ptrlike; eauto. i. erewrite IHBIND; eauto.
+    2:{ rewrite forallb_false_forall. ii. r in H.
+        rewrite forallb_forall in H. ss. exploit H; eauto. i. exploit H2; eauto. i.
+        rewrite H5 in H4. ss. }
+    repeat rewrite andb_true_iff. esplits; eauto. unfold proj_sumbool. des_ifs.
+  - erewrite IHBIND; eauto. repeat rewrite andb_true_iff. esplits; eauto. unfold proj_sumbool. des_ifs.
+Qed.
+
+Lemma decode_val_binded_no_ptrlike
+    m1 m2 vl1 vl2 chunk
+    (CE: concrete_extends m1 m2)
+    (LEN: ((Datatypes.length vl1) > 0)%nat)
+    (NPTRL1: forallb Mem.is_ptrlike_mv vl1 = false)
+    (BIND: list_forall2 (memval_intptr m2) vl1 vl2) :
+  <<BIND: val_intptr m2 (decode_val chunk (Mem.normalize_mvs chunk m1 vl1))
+                        (decode_val chunk (Mem.normalize_mvs chunk m2 vl2))>>.
+Proof.
+  assert (CHECK1: Mem.normalize_check chunk vl1 = false).
+  { unfold Mem.normalize_check, Mem.is_mixed_mvs. des_ifs. }
+  unfold Mem.normalize_mvs. rewrite CHECK1.
+  assert (BYTES1: proj_bytes vl1 = None).
+  { clear - NPTRL1. ginduction vl1; ss. ii. rewrite andb_false_iff in NPTRL1. des; des_ifs.
+    exploit IHvl1; eauto. i. clarify. }
+  destruct (classic (In Undef vl1)).
+  { assert (decode_val chunk vl1 = Vundef).
+    { unfold decode_val. rewrite BYTES1. do 2 (erewrite proj_value_undef; eauto). des_ifs. }
+    rewrite H0. econs. }
+  destruct (classic (forall q n, ~ In (Fragment Vundef q n) vl1)); cycle 1.
+  { assert (decode_val chunk vl1 = Vundef).
+    { unfold decode_val. rewrite BYTES1.
+      eapply not_all_ex_not in H0. des. eapply not_all_ex_not in H0. des. eapply NNPP in H0.
+      do 2 (erewrite Mem.proj_value_undef_frag; eauto). des_ifs. }
+    rewrite H1. econs. }
+  rename H into UNDEF1. rename H0 into UNDEF2.
+  assert (NPTRL2: forallb Mem.is_ptrlike_mv vl2 = false).
+  { clear BYTES1 CHECK1. ginduction BIND; ss; i. rewrite andb_false_iff in *. des.
+    - left. inv H; ss.
+      + inv H0; ss.
+        * des_ifs. destruct q; ss.
+        * exfalso. eapply UNDEF2; eauto.
+      + exfalso. eapply UNDEF2. eauto.
+      + exfalso. eapply UNDEF1. eauto.
+    - right. exploit IHBIND; eauto.
+      { destruct al; ss. lia. }
+      ii. eapply UNDEF2. eauto. }
+  assert (CHECK2: Mem.normalize_check chunk vl2 = false).
+  { unfold Mem.normalize_check, Mem.is_mixed_mvs. des_ifs. }
+  rewrite CHECK2.
+  assert (BYTES2: proj_bytes vl2 = None).
+  { clear - NPTRL2. ginduction vl2; ss. ii. rewrite andb_false_iff in NPTRL2. des; des_ifs.
+    exploit IHvl2; eauto. i. clarify. }
+  unfold decode_val. rewrite BYTES1, BYTES2.
+  assert (BINDV: val_intptr m2 (proj_value Q64 vl1) (proj_value Q64 vl2)).
+  { i. unfold proj_value. des_ifs; try by econs.
+    - inv BIND. inv H2. econs.
+    - inv BIND. inv H2; try by ss.
+      2:{ econs. }
+      des_ifs. exploit check_value_is_ptr; eauto. i. exfalso.
+      clear - NPTRL1 H. eapply andb_false_iff in NPTRL1. des; ss. des_ifs.
+      eapply andb_prop in H. des. rewrite forallb_forall in H0.
+      eapply forallb_false_forall in NPTRL1. eapply NPTRL1. i. eapply H0 in H1.
+      unfold Mem.is_ptrlike_mv. rewrite H1. rewrite orb_true_r. ss.
+    - inv BIND. inv H2; eauto. econs.
+    - clear CHECK1 CHECK2 BYTES1 BYTES2 LEN.
+      exploit check_value_binded_no_ptrlike; try eapply Heq; eauto.
+      { inv BIND. inv H2. eauto. exfalso. eapply UNDEF2. ss. eauto. }
+      { ii. subst. exfalso. eapply UNDEF2. ss. eauto. }
+      i. clarify. }
+  des_ifs; try by econs.
+  - eapply load_result_binded; eauto.
+  - clear BINDV. unfold Val.load_result.
+    destruct (proj_value Q32 vl1) eqn:PROJ1; try by econs.
+    (* int make lemma *)
+    + assert (vl1 = vl2).
+      { unfold proj_value in PROJ1. des_ifs. clear -Heq BIND.
+        remember (size_quantity_nat Q32) as qn. clear Heqqn.
+        remember (Fragment (Vint i) q n :: l) as vl1. clear Heqvl1.
+        ginduction BIND; eauto. ii. destruct qn; ss. des_ifs. InvBooleans. subst.
+        erewrite IHBIND; eauto. inv H. inv H6. ss. }
+      subst. rewrite PROJ1. econs.
+    + assert (vl1 = vl2).
+      { unfold proj_value in PROJ1. des_ifs. clear -Heq BIND.
+        remember (size_quantity_nat Q32) as qn. clear Heqqn.
+        remember (Fragment (Vsingle f) q n :: l) as vl1. clear Heqvl1.
+        ginduction BIND; eauto. ii. destruct qn; ss. des_ifs. InvBooleans. subst.
+        erewrite IHBIND; eauto. inv H. inv H6. ss. }
+      subst. rewrite PROJ1. econs.
+Qed.
+
+Lemma decode_val_binded
+    m1 m2 vl1 vl2 chunk
+    (CE: concrete_extends m1 m2)
+    (LEN: ((Datatypes.length vl1) > 0)%nat)
+    (BIND: list_forall2 (memval_intptr m2) vl1 vl2) :
+  <<BIND: val_intptr m2 (decode_val chunk (Mem.normalize_mvs chunk m1 vl1))
+                        (decode_val chunk (Mem.normalize_mvs chunk m2 vl2))>>.
+Proof.
+  destruct (forallb Mem.is_ptrlike_mv vl1) eqn:PTRL; cycle 1.
+  { exploit (not_ptrlike_not_normalize chunk); eauto. intros NORM1.
+    eapply decode_val_binded_no_ptrlike; eauto. }
+  assert (UNDEF1: ~ In Undef vl1).
+  { rewrite forallb_forall in PTRL. ii. eapply PTRL in H. ss. }
+  assert (UNDEF2: (forall q n, ~ In (Fragment Vundef q n) vl1)).
+  { rewrite forallb_forall in PTRL. ii. eapply PTRL in H. ss. }
+  destruct Archi.ptr64 eqn:SF; ss.
+  destruct (classic (chunk = Mint64 \/ chunk = Many64)).
+  2:{ assert (NORM1: Mem.normalize_check chunk vl1 = false).
+      { destruct chunk; ss; des; clarify; exfalso; eapply H; auto. }
+      assert (NORM2: Mem.normalize_check chunk vl2 = false).
+      { destruct chunk; ss; des; clarify; exfalso; eapply H; auto. }
+      unfold Mem.normalize_mvs. rewrite NORM1, NORM2.
+      destruct (proj_bytes vl1) eqn:BYTES1.
+      { exploit proj_bytes_binded; eauto. i. unfold decode_val. rewrite BYTES1, H0.
+        des_ifs; econs. }
+      (* make lemma *)
+      assert (UNDEF: decode_val chunk vl1 = Vundef).
+      { unfold decode_val. rewrite BYTES1.
+        destruct (classic (chunk = Many32)).
+        { subst. destruct vl1; [ss|]. simpl in PTRL. destruct m; try by ss.
+          destruct v; try by ss.
+          - eapply andb_prop in PTRL. des. unfold Mem.is_ptrlike_mv in PTRL.
+            simpl in PTRL. destruct q; ss; des_ifs.
+          - eapply andb_prop in PTRL. des. unfold Mem.is_ptrlike_mv in PTRL.
+            simpl in PTRL. destruct q; ss; des_ifs. }
+        des_ifs; exfalso; eapply H; eauto. }
+      rewrite UNDEF. econs. }
+  rename H into CHUNK.
+  destruct (Mem.normalize_check chunk vl1) eqn:MIXED1.
+(* src mix - tgt mix *)
+- exploit normalize_check_bind_normalize_check; eauto. intros MIXED2. des_safe.
+  destruct (forallb is_byte_mv (Mem.normalize_mvs chunk m1 vl1)) eqn:BYTES1.
+  2:{ exploit normalize_fail; try eapply BYTES1; eauto. i. rewrite H. eapply val_intptr_undef. }
+  exploit binded_normalize_binded; eauto. instantiate (1:= chunk). i.
+  exploit bytes_binded_bytes; eauto. i. des_safe. rewrite H1. unfold decode_val.
+  assert (BYTES : exists bl2, proj_bytes (Mem.normalize_mvs chunk m2 vl2) = Some bl2).
+  { destruct (proj_bytes (Mem.normalize_mvs chunk m2 vl2)) eqn:A; eauto.
+    rewrite Mem.not_bytes_proj_bytes_iff in A; clarify. }
+  des_safe. rewrite BYTES. des_ifs; econs.
+(* src not mix *)
+- assert (PTR1: forallb is_ptr_mv vl1 = true).
+  { unfold Mem.normalize_check, Mem.is_mixed_mvs in MIXED1. rewrite PTRL, SF in MIXED1.
+    des_ifs; try by (des; clarify); ss.
+    - eapply andb_false_iff in MIXED1. des; clarify. ss. rewrite negb_false_iff in MIXED1. ss.
+    - eapply andb_false_iff in MIXED1. des; clarify. ss. rewrite negb_false_iff in MIXED1. ss. }
+  destruct (Mem.normalize_check chunk vl2) eqn:MIXED2; cycle 1.
+  (* src not mix - tgt not mix *)
++ assert (PTR2: forallb is_ptr_mv vl2 = true).
+  { unfold Mem.normalize_check, Mem.is_mixed_mvs in MIXED2.
+    erewrite ptrlike_binded_ptrlike in MIXED2; eauto. rewrite SF in MIXED2.
+    des_ifs; try by (des; clarify); ss.
+    - eapply andb_false_iff in MIXED2. des; clarify. ss. rewrite negb_false_iff in MIXED2. ss.
+    - eapply andb_false_iff in MIXED2. des; clarify. ss. rewrite negb_false_iff in MIXED2. ss. }
+  (* exploit binded_normalize_binded; eauto. instantiate (1:=chunk). i. *)
+  unfold Mem.normalize_mvs. rewrite MIXED1, MIXED2.
+  assert (BYTES1: proj_bytes vl1 = None).
+  { clear - PTR1 LEN. ginduction vl1; ss; i; [lia|]. eapply andb_prop in PTR1. des. des_ifs; ss. }
+  assert (BYTES2: proj_bytes vl2 = None).
+  { erewrite list_forall2_length in LEN; eauto.
+    clear - PTR2 LEN. ginduction vl2; ss; i; [lia|]. eapply andb_prop in PTR2. des. des_ifs; ss. }
+  unfold decode_val. rewrite BYTES1, BYTES2. des; subst. des_ifs_safe.
+  * eapply load_result_binded.
+    ss. unfold proj_value. inv BIND. ss. inversion H; subst; try by ss.
+    destruct (check_value (size_quantity_nat Q64) v1 Q64 (Fragment v1 q n :: al)) eqn:B; try by econs.
+    destruct (Val.eq v1 Vundef). subst; econs.
+    exploit check_value_binded; try eapply B; eauto.
+    { econs; eauto. }
+    { simpl in PTR2. des_ifs. esplits; eauto. }
+    i. rewrite H2. eauto.
+  * ss. unfold proj_value. inv BIND. ss. inversion H; subst; try by ss.
+    destruct (check_value (size_quantity_nat Q64) v1 Q64 (Fragment v1 q n :: al)) eqn:B; try by econs.
+    destruct (Val.eq v1 Vundef). subst; econs.
+    exploit check_value_binded; try eapply B; eauto.
+    { econs; eauto. }
+    { simpl in PTR2. des_ifs. esplits; eauto. }
+    i. rewrite H2. eauto.
+  (* src not mix - tgt mix *)
++ exploit binded_normalize_binded; eauto. instantiate (1:=chunk). intros BIND'.
+  unfold Mem.normalize_mvs in *. rewrite MIXED1, MIXED2 in *.
+  destruct (classic (decode_val chunk vl1 = Vundef)).
+  { rewrite H. econs. }
+  rename H into NOUNDEF.
+  assert (BYTE: forallb is_byte_mv (map (Mem._decode_normalize_mv m2) vl2) = true).
+  { assert (BYTES: proj_bytes vl1 = None).
+    { clear - PTR1 LEN. ginduction vl1; ss; i; [lia|]. des_ifs; ss. }
+    unfold decode_val in NOUNDEF. rewrite BYTES in NOUNDEF. des_ifs.
+    - ss. des_ifs.
+      { destruct vl1; try by ss. destruct m; try by ss. destruct v; try by ss.
+        unfold proj_value in Heq. des_ifs. }
+      unfold proj_value in Heq. des_ifs.
+      (* make lemma *)
+      assert (ALLPTR: forall mv, In mv (Fragment (Vptr b i) q n :: l) -> exists q n, mv = Fragment (Vptr b i) q n).
+      { clear - Heq0. remember (size_quantity_nat Q64) as qn. clear Heqqn.
+        remember (Fragment (Vptr b i) q n :: l) as ll. clear Heqll.        
+        ginduction qn; ss; i.
+        { des_ifs. }
+        des_ifs. repeat rewrite andb_true_iff in Heq0. des.
+        ss. des.
+        { unfold proj_sumbool in Heq0. des_ifs. eauto. }
+        exploit IHqn; eauto. }
+      assert (CONC: exists caddr, m2.(Mem.mem_concrete) ! b = Some caddr).
+      { unfold Mem.is_mixed_mvs in MIXED2. repeat rewrite andb_true_iff in MIXED2. des_safe.
+        rewrite negb_true_iff in MIXED3.
+        assert (existsb (fun mv => Mem.is_intptr_mv mv || is_byte_mv mv) vl2 = true).
+        { clear - MIXED0 MIXED3. ginduction vl2; ss; ii. eapply andb_prop in MIXED0. des.
+          rewrite andb_false_iff in MIXED3. des.
+          - unfold Mem.is_ptrlike_mv in MIXED0. repeat rewrite orb_true_iff in MIXED0. des; clarify.
+            rewrite orb_true_r. rewrite orb_true_l. ss.
+          - exploit IHvl2; eauto. i. rewrite H. rewrite orb_true_r. ss. }
+        rewrite existsb_exists in H. des. exploit list_forall2_in_right; try eapply BIND; eauto. i.
+        des. exploit ALLPTR; eauto. i. des. subst. inv H2.
+        - simpl in H9. unfold Mem.ptr2int in H9. des_ifs. eauto.
+        - ss.
+        - inv H7; try by ss. simpl in H6. unfold Mem.ptr2int in H6. des_ifs. eauto. }
+      remember (Fragment (Vptr b i) q n :: l) as ll. clear Heqll.
+      remember (size_quantity_nat Q64) as qn.
+      assert (QQ: (qn <= 8)%nat).
+      { clear - Heqqn. subst. unfold size_quantity_nat. lia. }
+      clear Heqqn. clear - QQ Heq0 BIND' CONC.
+      (* eapply andb_prop in MIXED2. des_safe. *)
+      remember (map (Mem._decode_normalize_mv m2) vl2) as ll'.
+      ginduction qn; ss.
+      { ii. des_ifs. inv BIND'. ss. }
+      ii. des_ifs. des. destruct vl2; ss.
+      repeat rewrite andb_true_iff in Heq0. des.
+      eapply proj_sumbool_true in Heq0. subst. inv BIND'. dup H2. inv H2; ss.
+      2:{ rewrite <- H6 in *. inv H0. inv H2; ss.
+          - destruct m; ss. unfold Mem.to_int in H6. des_ifs; ss.
+            + specialize (inj_bytes_all_bytes (encode_int 4 (Int.unsigned i0))). i.
+              eapply nth_error_In in Heq0. unfold rev_if_be_mv in *. des_ifs. ss.
+              r in H. rewrite <- in_rev in Heq0. rewrite forallb_forall in H. eapply H in Heq0. ss.
+            + specialize (inj_bytes_all_bytes (encode_int 8 (Int64.unsigned i0))). i.
+              eapply nth_error_In in Heq0. unfold rev_if_be_mv in *. des_ifs. ss.
+              r in H. rewrite <- in_rev in Heq0. rewrite forallb_forall in H. eapply H in Heq0. ss.
+            + des_ifs; ss.
+              specialize (inj_bytes_all_bytes (encode_int 8 (Int64.unsigned (Int64.repr z)))). i.
+              eapply nth_error_In in Heq0. unfold rev_if_be_mv in *. des_ifs. ss.
+              r in H. rewrite <- in_rev in Heq0. rewrite forallb_forall in H. eapply H in Heq0. ss.
+            + des_ifs. ss. eapply beq_nat_true in Heq2. subst.
+              erewrite nth_error_None in Heq0. unfold rev_if_be_mv in Heq0. des_ifs.
+              rewrite rev_length in Heq0. erewrite length_inj_bytes, encode_int_length in Heq0. lia.
+            + des_ifs. unfold Mem.ptr2int in Heq0. rewrite CONC in Heq0. clarify.
+          - unfold Mem.ptr2int in H7. rewrite CONC in H7. des_ifs. ss.
+            unfold Mem._decode_normalize_mv in H6. des_ifs.
+            + destruct v; ss; clarify; ss.
+              * specialize (inj_bytes_all_bytes (encode_int 4 (Int.unsigned i0))). i.
+                eapply nth_error_In in Heq0. unfold rev_if_be_mv in *. des_ifs. ss.
+                r in H. rewrite <- in_rev in Heq0. rewrite forallb_forall in H. eapply H in Heq0. ss.
+              * specialize (inj_bytes_all_bytes (encode_int 8 (Int64.unsigned i0))). i.
+                eapply nth_error_In in Heq0. unfold rev_if_be_mv in *. des_ifs. ss.
+                r in H. rewrite <- in_rev in Heq0. rewrite forallb_forall in H. eapply H in Heq0. ss.
+              * des_ifs. ss.
+                specialize (inj_bytes_all_bytes (encode_int 8 (Int64.unsigned (Int64.repr z)))). i.
+                eapply nth_error_In in Heq0. unfold rev_if_be_mv in *. des_ifs. ss.
+                r in H. rewrite <- in_rev in Heq0. rewrite forallb_forall in H. eapply H in Heq0. ss.
+            + ss. clarify. ss. eapply beq_nat_true in Heq2. subst.
+              erewrite nth_error_None in Heq0. unfold rev_if_be_mv in Heq0. des_ifs.
+              rewrite rev_length in Heq0. erewrite length_inj_bytes, encode_int_length in Heq0. lia. }
+      des_ifs_safe. erewrite IHqn; try eapply Heq1; eauto. lia.
+    - ss. des_ifs.
+      unfold proj_value in NOUNDEF. des_ifs. simpl in PTR1. des_ifs.
+      (* make lemma *)
+      assert (ALLPTR: forall mv, In mv (Fragment (Vptr b i) q n :: l) -> exists q n, mv = Fragment (Vptr b i) q n).
+      { clear - Heq. remember (size_quantity_nat Q64) as qn. clear Heqqn.
+        remember (Fragment (Vptr b i) q n :: l) as ll. clear Heqll. 
+        ginduction qn; ss; i.
+        { des_ifs. }
+        des_ifs. repeat rewrite andb_true_iff in Heq. des.
+        ss. des.
+        { unfold proj_sumbool in Heq. des_ifs. eauto. }
+        exploit IHqn; eauto. }
+      assert (CONC: exists caddr, m2.(Mem.mem_concrete) ! b = Some caddr).
+      { unfold Mem.is_mixed_mvs in MIXED2. repeat rewrite andb_true_iff in MIXED2. des_safe.
+        rewrite negb_true_iff in MIXED3.
+        assert (existsb (fun mv => Mem.is_intptr_mv mv || is_byte_mv mv) vl2 = true).
+        { clear - MIXED0 MIXED3. ginduction vl2; ss; ii. eapply andb_prop in MIXED0. des.
+          rewrite andb_false_iff in MIXED3. des.
+          - unfold Mem.is_ptrlike_mv in MIXED0. repeat rewrite orb_true_iff in MIXED0. des; clarify.
+            rewrite orb_true_r. rewrite orb_true_l. ss.
+          - exploit IHvl2; eauto. i. rewrite H. rewrite orb_true_r. ss. }
+        rewrite existsb_exists in H. des. exploit list_forall2_in_right; try eapply BIND; eauto. i.
+        des. exploit ALLPTR; eauto. i. des. subst. inv H2.
+        - simpl in H9. unfold Mem.ptr2int in H9. des_ifs. eauto.
+        - ss.
+        - inv H7; try by ss. simpl in H6. unfold Mem.ptr2int in H6. des_ifs. eauto. }
+      remember (Fragment (Vptr b i) q n :: l) as ll. clear Heqll.
+      remember (size_quantity_nat Q64) as qn.
+      assert (QQ: (qn <= 8)%nat).
+      { clear - Heqqn. subst. unfold size_quantity_nat. lia. }
+      clear Heqqn. clear - QQ Heq BIND' CONC.
+      (* eapply andb_prop in MIXED2. des_safe. *)
+      remember (map (Mem._decode_normalize_mv m2) vl2) as ll'.
+      ginduction qn; ss.
+      { ii. des_ifs. inv BIND'. ss. }
+      ii. des_ifs. des. destruct vl2; ss.
+      repeat rewrite andb_true_iff in Heq. des.
+      eapply proj_sumbool_true in Heq. subst. inv BIND'. dup H2. inv H2; ss.
+      2:{ rewrite <- H6 in *. inv H0. inv H2; ss.
+          - destruct m; ss. unfold Mem.to_int in H6. des_ifs; ss.
+            + specialize (inj_bytes_all_bytes (encode_int 4 (Int.unsigned i0))). i.
+              eapply nth_error_In in Heq3. unfold rev_if_be_mv in *. des_ifs. ss.
+              r in H. rewrite <- in_rev in Heq3. rewrite forallb_forall in H. eapply H in Heq3. ss.
+            + specialize (inj_bytes_all_bytes (encode_int 8 (Int64.unsigned i0))). i.
+              eapply nth_error_In in Heq3. unfold rev_if_be_mv in *. des_ifs. ss.
+              r in H. rewrite <- in_rev in Heq3. rewrite forallb_forall in H. eapply H in Heq3. ss.
+            + des_ifs; ss.
+              specialize (inj_bytes_all_bytes (encode_int 8 (Int64.unsigned (Int64.repr z)))). i.
+              eapply nth_error_In in Heq3. unfold rev_if_be_mv in *. des_ifs. ss.
+              r in H. rewrite <- in_rev in Heq3. rewrite forallb_forall in H. eapply H in Heq3. ss.
+            + des_ifs. ss. eapply beq_nat_true in Heq1. subst.
+              erewrite nth_error_None in Heq3. unfold rev_if_be_mv in Heq3. des_ifs.
+              rewrite rev_length in Heq3. erewrite length_inj_bytes, encode_int_length in Heq3. lia.
+            + des_ifs. unfold Mem.ptr2int in Heq3. rewrite CONC in Heq3. clarify.
+          - unfold Mem.ptr2int in H7. rewrite CONC in H7. des_ifs. ss.
+            unfold Mem._decode_normalize_mv in H6. des_ifs.
+            + destruct v; ss; clarify; ss.
+              * specialize (inj_bytes_all_bytes (encode_int 4 (Int.unsigned i0))). i.
+                eapply nth_error_In in Heq3. unfold rev_if_be_mv in *. des_ifs. ss.
+                r in H. rewrite <- in_rev in Heq3. rewrite forallb_forall in H. eapply H in Heq3. ss.
+              * specialize (inj_bytes_all_bytes (encode_int 8 (Int64.unsigned i0))). i.
+                eapply nth_error_In in Heq3. unfold rev_if_be_mv in *. des_ifs. ss.
+                r in H. rewrite <- in_rev in Heq3. rewrite forallb_forall in H. eapply H in Heq3. ss.
+              * des_ifs. ss.
+                specialize (inj_bytes_all_bytes (encode_int 8 (Int64.unsigned (Int64.repr z)))). i.
+                eapply nth_error_In in Heq3. unfold rev_if_be_mv in *. des_ifs. ss.
+                r in H. rewrite <- in_rev in Heq3. rewrite forallb_forall in H. eapply H in Heq3. ss.
+            + ss. clarify. ss. eapply beq_nat_true in Heq1. subst.
+              erewrite nth_error_None in Heq3. unfold rev_if_be_mv in Heq3. des_ifs.
+              rewrite rev_length in Heq3. erewrite length_inj_bytes, encode_int_length in Heq3. lia. }
+      des_ifs_safe. erewrite IHqn; try eapply Heq1; eauto. lia. }
+  eapply ptr_byte_binded; eauto.
+Qed.
+
+Lemma load_concrete_extends chunk m1 m2 b ofs v1
+    (CE: concrete_extends m1 m2)
+    (LOAD: Mem.load chunk m1 b ofs = Some v1):
+  exists v2, <<LOAD: Mem.load chunk m2 b ofs = Some v2>> /\ <<BIND: val_intptr m2 v1 v2>>.
+Proof.
+  Local Transparent Mem.load. unfold Mem.load in *. des_ifs_safe.
+  exploit valid_access_concrete_extends; eauto. i. des_ifs_safe. esplits; eauto.
+  eapply decode_val_binded; eauto.
+  { rewrite Mem.getN_length. unfold size_chunk_nat. destruct chunk; ss; lia. }
+  eapply getN_concrete_extends; eauto.
+  rewrite <- size_chunk_conv. inv v. auto.
+Qed.
+
+Lemma loadv_concrete_extends chunk m1 m2 addr1 addr2 v1
+      (CEXT: concrete_extends m1 m2)
+      (LDV: Mem.loadv chunk m1 addr1 = Some v1)
+      (BIND: val_intptr m2 addr1 addr2):
+  exists v2, Mem.loadv chunk m2 addr2 = Some v2 /\ val_intptr m2 v1 v2.
+Proof.
+  i. Local Transparent Mem.loadv. unfold Mem.loadv in LDV. destruct addr1; ss; des_ifs.
+  - inv BIND. exploit denormalize_concrete_extends; eauto. i. des.
+    unfold Mem.loadv. ss. des_ifs. eapply load_concrete_extends; eauto.
+  - inv BIND; ss.
+    + ss. eapply load_concrete_extends; eauto.
+    + unfold Mem.loadv. ss. des_ifs_safe. exploit Mem.load_valid_access; eauto. i. inv H.
+      r in H0. specialize (H0 (Ptrofs.unsigned i)). exploit H0.
+      { destruct chunk; ss; lia. }
+      i. eapply Mem.perm_implies in H.
+      2:{ eapply perm_any_N. }
+      rewrite <- Mem.valid_pointer_nonempty_perm in H.
+      exploit Mem.ptr2int_to_denormalize; eauto.
+      { eapply Ptrofs.unsigned_range_2. }
+      { rewrite Mem.valid_pointer_nonempty_perm in *. eapply concrete_extends_perm_implies; eauto. }
+      i. exploit Mem.denormalize_info; eauto. i. des. rewrite Int64.unsigned_repr; cycle 1.
+      { unfold Ptrofs.max_unsigned, Int64.max_unsigned in *. rewrite <- Ptrofs.modulus_eq64; eauto. lia. }
+      rewrite H3. des_ifs.
+      { exfalso. unfold Int64.eq in Heq1. des_ifs. unfold Ptrofs.max_unsigned in CRANGE0.
+        rewrite Ptrofs.modulus_eq64 in CRANGE0; eauto. rewrite Int64.unsigned_repr in e; cycle 1.
+        { unfold Int64.max_unsigned. lia. }
+        rewrite Int64.unsigned_zero in e. subst. lia. }
+      eapply load_concrete_extends; eauto.
+      erewrite Ptrofs.unsigned_repr; eauto.
+Qed.
+
+Lemma bind_memval_list_refl m vl :
+  <<MINDL: list_forall2  (memval_intptr m) vl vl>>.
+Proof.
+  ginduction vl; ii; ss; econs; eauto. eapply memval_intptr_refl. eapply IHvl.
+Qed.
+
+Lemma bind_memval_intptr m chunk v1 v2
+    (BIND: val_intptr m v1 v2):
+  <<BINDMV: list_forall2 (memval_intptr m) (encode_val chunk v1) (encode_val chunk v2)>>.
+Proof.
+  inv BIND; ss. des_ifs; try by eapply bind_memval_list_refl.
+  - des_ifs; try by eapply bind_memval_list_refl.
+  - des_ifs; try by eapply bind_memval_list_refl.
+  - des_ifs; try by eapply bind_memval_list_refl.
+  - des_ifs; try by eapply bind_memval_list_refl.
+  - des_ifs; try by eapply bind_memval_list_refl.
+    + unfold inj_bytes. unfold encode_int, rev_if_be. des_ifs. ss.
+      assert (TOINT: Mem.to_int (Vptr b ofs) m = Some (Vlong (Int64.repr z))).
+      { ss. rewrite Heq. ss. }
+      repeat (econs; eauto).
+    + unfold inj_bytes. unfold encode_int, rev_if_be. des_ifs. ss.
+      assert (TOINT: Mem.to_int (Vptr b ofs) m = Some (Vlong (Int64.repr z))).
+      { ss. rewrite Heq. ss. }
+      repeat (econs; eauto).
+    + unfold inj_value. generalize (size_quantity_nat Q64).
+      induction n; ss; [econs|].
+      econs; eauto. econs; eauto. econs; eauto. simpl. unfold Mem.ptr2int_v. rewrite Heq. ss.
+  - unfold encode_val; des_ifs; ss; try by (repeat econs).
+Qed.
+
+Lemma store_concrete_extends
+    chunk m1 m2 b ofs v1 m1' v2
+    (CE: concrete_extends m1 m2)
+    (STORE: Mem.store chunk m1 b ofs v1 = Some m1')
+    (BIND: val_intptr m2 v1 v2):
+  exists m2', <<STORE: Mem.store chunk m2 b ofs v2 = Some m2'>> /\ <<CE: concrete_extends m1' m2'>>.
+Proof.
+  exploit Mem.store_valid_access_3; eauto. intros VLD1.
+  exploit valid_access_concrete_extends; eauto. intros VLD2. des.
+  Local Transparent Mem.store. unfold Mem.store in *. des_ifs_safe. esplits; eauto.
+  econs; ss.
+- eapply same_nextblock; eauto.
+- i. unfold Mem.perm in *. ss. eapply extended_access; eauto.
+- i. destruct (eq_block b b0); try subst b0.
++ repeat rewrite PMap.gss in *; eauto.
+  eapply same_concrete_memval_intptr with (m1:=m2); ss.
+  exploit bind_memval_intptr; eauto. instantiate (1:=chunk). i.
+  assert (ACC: forall ofs, Mem.perm m1 b ofs Cur Readable -> memval_intptr m2 (ZMap.get ofs (Mem.mem_contents m1) # b)
+                                                                        (ZMap.get ofs (Mem.mem_contents m2) # b)).
+  { ii. eapply extended_contents; eauto. }
+  destruct (classic (ofs <= ofs0 < ofs + size_chunk chunk)).
+  2:{ erewrite Mem.setN_outside in *.
+      2:{ rewrite encode_val_length. rewrite <- size_chunk_conv. lia. }
+      erewrite Mem.setN_outside.
+      2:{ rewrite encode_val_length. rewrite <- size_chunk_conv. lia. }
+      eapply same_concrete_memval_intptr with (m1:=m2); eauto. }
+  assert (ACC': Mem.perm m1 b ofs0 Cur Readable).
+  { inv VLD1. r in H2. exploit H2; eauto. }
+  clear - H0 ACC ACC'.
+  remember (encode_val chunk v1) as vl1. remember (encode_val chunk v2) as vl2.
+  remember ((Mem.mem_contents m1) # b) as c1. remember ((Mem.mem_contents m2) # b) as c2.
+  clear - H0 ACC ACC'. revert ACC'. revert ofs0. revert ACC. revert c1 c2 ofs. induction H0; ss; i.
+  eapply IHlist_forall2; eauto. ii. rewrite ZMap.gsspec at 1. des_ifs.
+  { rewrite ZMap.gss; eauto. }
+  { rewrite ZMap.gso; eauto. }
++ repeat (rewrite PMap.gso; eauto). eapply same_concrete_memval_intptr with (m1:=m2); eauto.
+  eapply extended_contents; eauto.
+- eapply extended_concrete; eauto.
+Qed.
+
+Theorem storev_concrete_extends
+    chunk m1 m2 addr1 v1 m1' addr2 v2
+    (CEXT: concrete_extends m1 m2)
+    (STRV: Mem.storev chunk m1 addr1 v1 = Some m1')
+    (BIND: val_intptr m2 addr1 addr2)
+    (BIND': val_intptr m2 v1 v2):
+  exists m2', Mem.storev chunk m2 addr2 v2 = Some m2' /\ concrete_extends m1' m2'.
+Proof.
+  i. Local Transparent Mem.storev. unfold Mem.storev in STRV. des_ifs.
+  - inv BIND. exploit denormalize_concrete_extends; eauto. i. des.
+    unfold Mem.storev. des_ifs. eapply store_concrete_extends; eauto.
+  - inv BIND; ss.
+    + ss. eapply store_concrete_extends; eauto.
+    + des_ifs_safe. exploit Mem.store_valid_access_3; eauto. i. inv H.
+      r in H0. specialize (H0 (Ptrofs.unsigned i)). exploit H0.
+      { destruct chunk; ss; lia. }
+      i. eapply Mem.perm_implies in H.
+      2:{ eapply perm_any_N. }
+      rewrite <- Mem.valid_pointer_nonempty_perm in H.
+      exploit Mem.ptr2int_to_denormalize; eauto.
+      { eapply Ptrofs.unsigned_range_2. }
+      { rewrite Mem.valid_pointer_nonempty_perm in *. eapply concrete_extends_perm_implies; eauto. }
+      i. exploit Mem.denormalize_info; eauto. i. des. rewrite Int64.unsigned_repr; cycle 1.
+      { unfold Ptrofs.max_unsigned, Int64.max_unsigned in *. rewrite <- Ptrofs.modulus_eq64; eauto. lia. }
+      rewrite H3. eapply store_concrete_extends; eauto.
+Qed.
+
+Lemma free_concrete_extends
+    m1 m2 b lo hi m1'
+    (CE: concrete_extends m1 m2)
+    (FREE: Mem.free m1 b lo hi = Some m1') :
+  exists m2', <<FREE: Mem.free m2 b lo hi = Some m2'>> /\ <<CE: concrete_extends m1' m2'>>.
+Proof.
+  Local Transparent Mem.free.
+  assert (RPERM: Mem.range_perm m1 b lo hi Cur Freeable) by (eapply Mem.free_range_perm; eauto).
+  dup RPERM. eapply range_perm_concrete_extends in RPERM; eauto. unfold Mem.free in *. des_ifs_safe.
+  esplits; eauto. econs.
+  - ss. eapply same_nextblock; eauto.
+  - unfold Mem.perm. ss. i.
+    destruct (peq b b0); cycle 1.
+    { erewrite PMap.gso in *; eauto. eapply extended_access; eauto. }
+    subst. erewrite PMap.gss in *. des_ifs.
+    eapply extended_access; eauto.
+  - ii. ss. eapply same_concrete_memval_intptr with (m1:=m2); eauto.
+    inv CE. eapply extended_contents0; eauto. unfold Mem.unchecked_free in H. unfold Mem.perm in *. ss.
+    destruct (classic (b = b0)); subst.
+    2:{ rewrite PMap.gso in H; eauto. }
+    rewrite PMap.gss in H.
+    destruct (zle lo ofs && zlt ofs hi) eqn: RANGE; ss.
+  - ss. eapply extended_concrete; eauto.
+Qed.
+
+Lemma alloc_concrete_extends
+    m1 m2 b lo hi m1'
+    (CE: concrete_extends m1 m2)
+    (ALLOC: Mem.alloc m1 lo hi = (m1', b)) :
+  exists m2',  <<FREE: Mem.alloc m2 lo hi = (m2', b)>> /\ <<CE: concrete_extends m1' m2'>>.
+Proof.
+  Local Transparent Mem.alloc. esplits; eauto.
+  { unfold Mem.alloc. eauto. f_equal. injection ALLOC. i. subst b. inv CE; eauto. }
+  econs; ss; ii.
+  - injection ALLOC; i. subst. ss. erewrite same_nextblock; eauto.
+  - injection ALLOC; i. subst. ss. unfold Mem.perm in *; ss. erewrite <- same_nextblock; eauto.
+    destruct (peq b0 (Mem.nextblock m1)); subst; ss.
+    2:{ rewrite PMap.gso in *; eauto. eapply extended_access; eauto. }
+    rewrite PMap.gss in *; ss.
+  - injection ALLOC; i; subst. ss. inv CE. rewrite same_nextblock0.
+    destruct (classic (b0 = Mem.nextblock m2)); subst.
+    { do 2 (rewrite PMap.gss; eauto). rewrite ZMap.gi. econs. }
+    do 2 (rewrite PMap.gso; eauto).
+    unfold Mem.alloc. ss. esplits; eauto.
+    esplits; eauto. eapply same_concrete_memval_intptr with (m1:=m2); ss.
+    eapply extended_contents0. unfold Mem.perm in *. ss. rewrite PMap.gso in H; eauto.
+    rewrite same_nextblock0. ss.
+  - inv CE. eapply extended_concrete0. rewrite <- H.
+    eapply Mem.concrete_alloc in ALLOC. rewrite ALLOC. eauto.
+Qed.
+
+Lemma capture_concrete_extends
+  m1 m2 m2' b addr
+  (CE: concrete_extends m1 m2)
+  (CAPTURE: Mem.capture m2 b addr m2'):
+  exists m1', <<CAPSRC: Mem.capture m1 b addr m1'>> /\ <<CE: concrete_extends m1' m2'>>.
+Proof.
+  inv CAPTURE.
+  assert (Mem.valid_block m1 b).
+  { unfold Mem.valid_block in *. erewrite same_nextblock; eauto. }
+  destruct (m1.(Mem.mem_concrete) ! b) eqn:CONC.
+  { exploit extended_concrete; eauto. i.
+    exploit PREVADDR; eauto. i. des; subst. esplits.
+    { econs; eauto; i; clarify. }
+    assert (m2 = m2').
+    { inv CE. destruct m2, m2'; ss. eapply Mem.mkmem_ext; eauto. }
+    subst. eauto. }
+  set (conc_m1' := PTree.set b addr (Mem.mem_concrete m1)).
+
+  assert (SAME: forall blk caddr, PTree.get blk conc_m1' = Some caddr -> PTree.get blk (m2'.(Mem.mem_concrete)) = Some caddr).
+  { subst conc_m1'. i. destruct (peq b blk); subst.
+    - erewrite PTree.gss in H0; eauto. clarify.
+      destruct ((Mem.mem_concrete m2) ! blk) eqn:CONC2.
+      { exploit PREVADDR; eauto. i. des; subst. rewrite <- H1. eauto. }
+      exploit CAPTURED; eauto. i. rewrite H0. erewrite PTree.gss; eauto.
+    - erewrite PTree.gso in H0; eauto.
+      destruct ((Mem.mem_concrete m2) ! b) eqn:CONC2.
+      { exploit extended_concrete; eauto. i.
+        exploit PREVADDR; eauto. i. des; subst. rewrite <- H3. eauto. }
+      exploit CAPTURED; eauto. i. rewrite H1. erewrite PTree.gso; eauto.
+      eapply extended_concrete; eauto. }
+  
+  assert (NEXTLOG: forall b, ~Plt b m1.(Mem.nextblock) -> conc_m1' ! b = None).
+  { ii. subst conc_m1'. destruct (eq_block b b0); subst.
+    - rewrite PTree.gss. exfalso. eapply H0. unfold Mem.valid_block in VALID. eauto.
+    - rewrite PTree.gso; eauto. eapply (Mem.nextblocks_logical m1); eauto. }
+
+  assert (VB: forall b addr, Mem.addr_in_block conc_m1' m1.(Mem.mem_access) addr b ->
+                        addr < Ptrofs.modulus - 1).
+  { ii. eapply m2'.(Mem.valid_address_bounded). rewrite <- ACCESS.
+    instantiate (1:=b0). inv H0. des. econs; eauto.
+    exploit extended_access; eauto.
+    { unfold Mem.perm. erewrite PERM; eauto. ss. econs. }
+    i. unfold Mem.perm, Mem.perm_order' in H0. des_ifs; eauto. }
+
+  assert (NC: forall addr, uniqueness (Mem.addr_in_block conc_m1' m1.(Mem.mem_access) addr)).
+  { ii.
+    specialize (m2'.(Mem.no_concrete_overlap) addr0). i. r in H2. eapply H2.
+    { inv H0. des.
+      exploit extended_access; eauto.
+      { unfold Mem.perm. erewrite PERM; eauto. ss. econs. }
+      i. unfold Mem.perm, Mem.perm_order' in H0. des_ifs; eauto.
+      econs; eauto. rewrite <- ACCESS; eauto. }
+    { inv H1. des.
+      exploit extended_access; eauto.
+      { unfold Mem.perm. erewrite PERM; eauto. ss. econs. }
+      i. unfold Mem.perm, Mem.perm_order' in H1. des_ifs; eauto.
+      econs; eauto. rewrite <- ACCESS; eauto. }
+  }
+
+  assert (CA: forall b addr, conc_m1' ! b = Some addr ->
+                        forall ofs chunk, (forall o, ofs <= o < ofs + size_chunk chunk ->
+                                           Mem.perm_order' (m1.(Mem.mem_access) # b o Max) Nonempty) ->
+                                           (align_chunk chunk | addr)).
+  { i. eapply SAME in H0.
+    eapply m2'.(Mem.concrete_align); eauto. i. eapply H1 in H2.
+    rewrite <- ACCESS. eapply extended_access; eauto.
+  }
+
+  assert (WVR: forall b addr ofs, conc_m1' ! b = Some addr -> 0 <= ofs < Ptrofs.modulus ->
+                             Mem._weak_valid_pointer m1.(Mem.mem_access) b ofs Max ->
+                             Mem.in_range (addr + ofs) (1, Ptrofs.modulus)).
+  { i. eapply SAME in H0.
+    eapply m2'.(Mem.weak_valid_address_range); eauto. rewrite <- ACCESS.
+    eapply _weak_valid_concrete_extends; eauto. }
+
+  exists (Mem.mkmem m1.(Mem.mem_contents) m1.(Mem.mem_access) conc_m1' m1.(Mem.nextblock)
+               m1.(Mem.access_max) m1.(Mem.nextblock_noaccess) m1.(Mem.contents_default)
+               NEXTLOG VB NC CA WVR).
+  split.
+  - econs; eauto; ss. i; clarify.
+  - econs; eauto; ss.
+    + erewrite same_nextblock; eauto.
+    + unfold Mem.perm. ss. erewrite <- ACCESS. eapply extended_access; eauto.
+    + i; ss. rewrite <- CONTENTS.
+      exploit extended_contents; eauto. ii.
+      inv H1; try by econs; eauto.
+      * econs; eauto. unfold Mem.to_int, Mem.ptr2int_v, Mem.ptr2int in H5. des_ifs.
+        assert ((Mem.mem_concrete m2') ! b1 = Some z0).
+        { destruct (eq_block b1 b); subst.
+          { exploit PREVADDR; eauto. i. des. rewrite <- H5; eauto. }
+          destruct ((Mem.mem_concrete m2) ! b) eqn:CONC2.
+          { exploit PREVADDR; eauto. i. des; subst. rewrite <- H5. eauto. }
+          exploit CAPTURED; eauto. i. rewrite H1. rewrite PTree.gso; eauto. }
+        unfold Mem.to_int, Mem.ptr2int_v, Mem.ptr2int in *. rewrite H1. des_ifs.
+      * econs; eauto. inv H4; try by econs; eauto. econs; eauto.
+        destruct (eq_block b1 b); subst.
+        { unfold Mem.to_int, Mem.ptr2int_v, Mem.ptr2int in *.
+          destruct ((Mem.mem_concrete m2) ! b) eqn:CONC2.
+          { exploit PREVADDR; eauto. i. des. subst. des_ifs_safe. rewrite <- H6, CONC2. eauto. }
+          clarify. }
+        unfold Mem.to_int, Mem.ptr2int_v, Mem.ptr2int in H5. des_ifs.
+        destruct ((Mem.mem_concrete m2) ! b) eqn:CONC2.
+        { exploit PREVADDR; eauto. i. des. subst.
+          unfold Mem.to_int, Mem.ptr2int_v, Mem.ptr2int. rewrite <- H5. rewrite Heq0. des_ifs. }
+        exploit CAPTURED; eauto. i.
+        unfold Mem.to_int, Mem.ptr2int_v, Mem.ptr2int. rewrite H4.
+        erewrite PTree.gso; eauto. rewrite Heq0. des_ifs.
+Qed.
+
+Lemma capture_concrete_extends_backward_progress
+    m1 b addr m1' m2
+    (CONC: concrete_extends m1 m1')
+    (CAPTURE: Mem.capture m1 b addr m2) :
+  (exists m2' addr',
+      <<CAPTGT: Mem.capture m1' b addr' m2'>>)
+    \/ <<OOM: Mem.capture_oom m1' b>>.
+Proof.
+  inv CAPTURE; inv CONC.
+  assert (Mem.valid_block m1' b).
+  { unfold Mem.valid_block in *. rewrite <- same_nextblock0. auto. }
+  destruct (classic (exists m2' addr', Mem.capture m1' b addr' m2')).
+  - des. left; eauto.
+  - right. red. split; eauto.
+Qed.
+
+Theorem loadbytes_concrete_extends
+    m1 m2 b ofs len bytes1
+    (CONC: concrete_extends m1 m2)
+    (LD: Mem.loadbytes m1 b ofs len = Some bytes1):
+  exists bytes2, Mem.loadbytes m2 b ofs len = Some bytes2 /\ list_forall2 (memval_intptr m2) bytes1 bytes2.
+Proof.
+  Local Transparent Mem.loadbytes.
+  unfold Mem.loadbytes in LD.
+  destruct (Mem.range_perm_dec m1 b ofs (ofs + len) Cur Readable); inv LD.
+  exists (Mem.getN (Z.to_nat len) ofs (m2.(Mem.mem_contents)#b)).
+  split.
+  - apply pred_dec_true. eapply concrete_extends_range_perm_implies; eauto.
+  - eapply getN_concrete_extends; eauto. 
+    destruct (zle 0 len). rewrite Z2Nat.id by lia. auto.
+    rewrite Z_to_nat_neg by lia. simpl. red; intros; extlia.
+Qed.
+
+Theorem storebytes_within_concrete_extends
+    m1 m2 b ofs bytes1 m1' bytes2
+    (CONC: concrete_extends m1 m2)
+    (SB: Mem.storebytes m1 b ofs bytes1 = Some m1')
+    (BIND: list_forall2 (memval_intptr m2) bytes1 bytes2):
+  exists m2',
+    Mem.storebytes m2 b ofs bytes2 = Some m2'
+  /\ concrete_extends m1' m2'.
+Proof.
+  assert (Mem.range_perm m2 b ofs (ofs + Z.of_nat (length bytes2)) Cur Writable).
+  { eapply concrete_extends_range_perm_implies; eauto.
+    exploit list_forall2_length; eauto. i. erewrite <- H.
+    eapply Mem.storebytes_range_perm; eauto. }
+  destruct (Mem.range_perm_storebytes _ _ _ _ H) as [n2 STORE].
+  exists n2. esplits; eauto. inv CONC. econs.
+  - eapply Mem.nextblock_storebytes in SB, STORE. rewrite SB, STORE; eauto.
+  - eapply Mem.storebytes_access in SB, STORE. unfold Mem.perm.
+    rewrite SB, STORE. eapply extended_access0; eauto.
+  - i. assert (Mem.perm m1 b0 ofs0 Cur Readable). eapply Mem.perm_storebytes_2; eauto.
+    rewrite (Mem.storebytes_mem_contents _ _ _ _ _ SB).
+    rewrite (Mem.storebytes_mem_contents _ _ _ _ _ STORE).
+    rewrite ! PMap.gsspec. destruct (peq b0 b).
+    + subst b0. apply setN_concrete_extends with (access := fun ofs => Mem.perm m1 b ofs Cur Readable); eauto.
+      { eapply same_concrete_memval_intptr_list; try eapply BIND.
+        eapply Mem.concrete_storebytes. eauto. }
+      i. eapply same_concrete_memval_intptr; try eapply H2.
+      eapply Mem.concrete_storebytes. eauto. eapply extended_contents0; eauto.
+    + exploit extended_contents0; eauto. i. eapply same_concrete_memval_intptr; try eapply H2.
+      eapply Mem.concrete_storebytes. eauto.
+  - eapply Mem.concrete_storebytes in SB, STORE. rewrite <- SB, <- STORE. eauto.
+Qed.
+
+End MemRel.
+
+Lemma to_int_bind m m' v v'
+    (CONCEXT: concrete_extends m m')
+    (BIND: val_intptr m' v v') :
+  <<BIND': val_intptr m' (to_int_val m v) (to_int_val m' v')>>.
+Proof.
+  inv BIND; ss; unfold to_int_val; ss; try (by econs).
+  - destruct (Mem.ptr2int b (Ptrofs.unsigned ofs) m) eqn:P2I; ss; [|econs].
+    exploit ptr2int_conc_ext; eauto. i. destruct (Archi.ptr64) eqn:BIT; rewrite H; econs.
+  - des_ifs; ss; try econs. exploit ptr2int_conc_ext; eauto. i. clarify. econs.
+Qed.
+
+(** 32bit lemmas *)
+
+Lemma add_bind m2 v1 v2 v1' v2'
+  (BIND1: val_intptr m2 v1 v1')
+  (BIND2: val_intptr m2 v2 v2') :
+  <<BIND: val_intptr m2 (Val.add v1 v2) (Val.add v1' v2')>>.
+Proof.
+  intros. unfold Val.add. destruct Archi.ptr64 eqn:SF.
+- inv BIND1; inv BIND2; econs.
+- destruct v1; (try by econs); destruct v2; try by econs.
+  + inv BIND1; inv BIND2. eapply val_intptr_refl.
+  + inv BIND1; inv BIND2; [| |clarify].
+    { eapply val_intptr_refl. }
+    { simpl in *. unfold Mem.ptr2int_v, Mem.ptr2int in *.
+      destruct ((Mem.mem_concrete m2) ! b) eqn: CONC; [| clarify].
+      rewrite SF in *. inv H3. econs; eauto.
+      simpl. unfold Mem.ptr2int_v, Mem.ptr2int. rewrite CONC, SF. do 2 f_equal.
+      eapply Int.same_if_eq. unfold Int.eq, Ptrofs.to_int, Ptrofs.of_int, Int.add, Ptrofs.add.
+      repeat rewrite Int.unsigned_repr_eq. repeat rewrite Ptrofs.unsigned_repr_eq.
+      eapply Ptrofs.modulus_eq32 in SF. rewrite SF.
+      repeat rewrite Zplus_mod_idemp_r. rewrite Z.add_assoc.
+      replace (z + (Ptrofs.unsigned i0 + Int.unsigned i mod Int.modulus))
+        with ((z + Ptrofs.unsigned i0) + Int.unsigned i mod Int.modulus) by lia.
+      rewrite Zplus_mod_idemp_r.
+      replace (z + Ptrofs.unsigned i0 + Int.unsigned i) with
+        (Int.unsigned i + z + Ptrofs.unsigned i0) by lia. des_ifs; eauto. }
+  + inv BIND1; inv BIND2; [| |clarify].
+    { eapply val_intptr_refl. }
+    { simpl in *. unfold Mem.ptr2int_v, Mem.ptr2int in *.
+      destruct ((Mem.mem_concrete m2) ! b) eqn: CONC; [| clarify].
+      rewrite SF in *. inv H3. econs; eauto.
+      simpl in *. unfold Mem.ptr2int_v, Mem.ptr2int. rewrite CONC, SF. do 2 f_equal.
+      eapply Int.same_if_eq. unfold Int.eq, Ptrofs.to_int, Ptrofs.of_int, Int.add, Ptrofs.add.
+      repeat rewrite Int.unsigned_repr_eq. repeat rewrite Ptrofs.unsigned_repr_eq.
+      eapply Ptrofs.modulus_eq32 in SF. rewrite SF.
+      rewrite Zplus_mod_idemp_r. rewrite Zplus_mod_idemp_l.
+      replace (z + (Ptrofs.unsigned i + Int.unsigned i0 mod Int.modulus))
+        with ((z + Ptrofs.unsigned i) + Int.unsigned i0 mod Int.modulus) by lia.
+      rewrite Zplus_mod_idemp_r. des_ifs; lia. }
+Qed.
+
+Lemma sub_bind m2 v1 v2 v1' v2'
+    (BIND1: val_intptr m2 v1 v1')
+    (BIND2: val_intptr m2 v2 v2') :
+  <<BIND: val_intptr m2 (Val.sub v1 v2) (Val.sub v1' v2')>>.
+Proof.
+  intros. unfold Val.sub. destruct Archi.ptr64 eqn:SF.
+- inv BIND1; inv BIND2; econs.
+- destruct v1; (try by econs); destruct v2; try by econs.
+  + inv BIND1; inv BIND2. eapply val_intptr_refl.
+  + inv BIND1; inv BIND2; [| |clarify].
+    { eapply val_intptr_refl. }
+    { simpl in *. unfold Mem.ptr2int_v, Mem.ptr2int in *.
+      destruct ((Mem.mem_concrete m2) ! b) eqn: CONC; [|clarify].
+      rewrite SF in *. inv H3. econs; eauto.
+      simpl. unfold Mem.ptr2int_v, Mem.ptr2int. rewrite CONC, SF. do 2 f_equal.
+      eapply Int.same_if_eq. unfold Int.eq, Ptrofs.to_int, Ptrofs.of_int, Int.sub, Ptrofs.sub.
+      repeat rewrite Int.unsigned_repr_eq. repeat rewrite Ptrofs.unsigned_repr_eq.
+      eapply Ptrofs.modulus_eq32 in SF. rewrite SF.
+      rewrite Zminus_mod_idemp_l. rewrite Zminus_mod_idemp_r. rewrite Zplus_mod_idemp_r.
+      rewrite <- Z.add_opp_r. rewrite Z.add_assoc. des_ifs; lia. }
+Qed.
+
+Lemma mul_bind m2 v1 v2 v1' v2'
+    (BIND1: val_intptr m2 v1 v1')
+    (BIND2: val_intptr m2 v2 v2') :
+  <<BIND: val_intptr m2 (Val.mul v1 v2) (Val.mul v1' v2')>>.
+Proof. inv BIND1; inv BIND2; ss; econs; eauto. Qed.
+
+Lemma addl_bind m2 v1 v2 v1' v2'
+    (BIND1: val_intptr m2 v1 v1')
+    (BIND2: val_intptr m2 v2 v2') :
+  <<BIND: val_intptr m2 (Val.addl v1 v2) (Val.addl v1' v2')>>.
+Proof.
+  intros. unfold Val.addl. destruct Archi.ptr64 eqn:SF; cycle 1.
+- inv BIND1; inv BIND2; econs.
+- destruct v1; (try by econs); destruct v2; try by econs.
+  + inv BIND1; inv BIND2. eapply val_intptr_refl.
+  + inv BIND1; inv BIND2; [|clarify|].
+    { eapply val_intptr_refl. }
+    { simpl in *. unfold Mem.ptr2int_v, Mem.ptr2int in *.
+      destruct ((Mem.mem_concrete m2) ! b) eqn: CONC; [|clarify].
+      rewrite SF in *. inv H3. econs; eauto.
+      simpl. unfold Mem.ptr2int_v, Mem.ptr2int. rewrite CONC, SF. do 2 f_equal.
+      eapply Int64.same_if_eq. unfold Int64.eq, Ptrofs.to_int64, Ptrofs.of_int64, Int64.add, Ptrofs.add.
+      repeat rewrite Int64.unsigned_repr_eq. repeat rewrite Ptrofs.unsigned_repr_eq.
+      eapply Ptrofs.modulus_eq64 in SF. rewrite SF.
+      repeat rewrite Zplus_mod_idemp_r.
+      replace (z + (Ptrofs.unsigned i0 + Int64.unsigned i mod Int64.modulus))
+        with ((z + Ptrofs.unsigned i0) + Int64.unsigned i mod Int64.modulus) by lia.
+      rewrite Zplus_mod_idemp_r. rewrite Z.add_assoc.
+      replace (z + Ptrofs.unsigned i0 + Int64.unsigned i) with
+        (Int64.unsigned i + z + Ptrofs.unsigned i0) by lia. des_ifs; eauto. }
+  + inv BIND1; inv BIND2; [|clarify|].
+    { eapply val_intptr_refl. }
+    { simpl in *. unfold Mem.ptr2int_v, Mem.ptr2int in *.
+      destruct ((Mem.mem_concrete m2) ! b) eqn: CONC; [|clarify].
+      rewrite SF in *. inv H3. econs; eauto.
+      simpl. unfold Mem.ptr2int_v, Mem.ptr2int. rewrite CONC, SF. do 2 f_equal.
+      eapply Int64.same_if_eq. unfold Int64.eq, Ptrofs.to_int64, Ptrofs.of_int64, Int64.add, Ptrofs.add.
+      repeat rewrite Int64.unsigned_repr_eq. repeat rewrite Ptrofs.unsigned_repr_eq.
+      eapply Ptrofs.modulus_eq64 in SF. rewrite SF.
+      rewrite Zplus_mod_idemp_r. rewrite Zplus_mod_idemp_l.
+      replace (z + (Ptrofs.unsigned i + Int64.unsigned i0 mod Int64.modulus))
+        with ((z + Ptrofs.unsigned i) + Int64.unsigned i0 mod Int64.modulus) by lia.
+      rewrite Zplus_mod_idemp_r. des_ifs; lia. }
+Qed.
+
+Lemma subl_bind m2 v1 v2 v1' v2'
+  (BIND1: val_intptr m2 v1 v1')
+  (BIND2: val_intptr m2 v2 v2') :
+  <<BIND: val_intptr m2 (Val.subl v1 v2) (Val.subl v1' v2')>>.
+Proof.
+  intros. unfold Val.subl. destruct Archi.ptr64 eqn:SF; cycle 1 .
+- inv BIND1; inv BIND2; econs.
+- destruct v1; (try by econs); destruct v2; try by econs.
+  + inv BIND1; inv BIND2. eapply val_intptr_refl.
+  + inv BIND1; inv BIND2; [|clarify|].
+    { eapply val_intptr_refl. }
+    { simpl in *. unfold Mem.ptr2int_v, Mem.ptr2int in *.
+      destruct ((Mem.mem_concrete m2) ! b) eqn: CONC; [|clarify].
+      rewrite SF in *. inv H3. econs; eauto.
+      simpl. unfold Mem.ptr2int_v, Mem.ptr2int. rewrite CONC, SF. do 2 f_equal.
+      eapply Int64.same_if_eq. unfold Int64.eq, Ptrofs.to_int64, Ptrofs.of_int64, Int64.sub, Ptrofs.sub.
+      repeat rewrite Int64.unsigned_repr_eq. repeat rewrite Ptrofs.unsigned_repr_eq.
+      eapply Ptrofs.modulus_eq64 in SF. rewrite SF.
+      rewrite Zminus_mod_idemp_l. rewrite Zminus_mod_idemp_r. rewrite Zplus_mod_idemp_r.
+      rewrite <- Z.add_opp_r. rewrite Z.add_assoc. des_ifs; lia. }
+Qed.
+
+Lemma mull_bind m2 v1 v2 v1' v2'
+    (BIND1: val_intptr m2 v1 v1')
+    (BIND2: val_intptr m2 v2 v2') :
+  <<BIND: val_intptr m2 (Val.mull v1 v2) (Val.mull v1' v2')>>.
+Proof. inv BIND1; inv BIND2; ss; econs; eauto. Qed.
+
+(* merge IntPtrRef version *)
+Lemma normalize_binded m' v v' ty
+    (BIND: val_intptr m' v v') :
+  <<BIND: val_intptr m' (Val.normalize v ty) (Val.normalize v' ty)>>.
+Proof.
+  intros. inv BIND.
+- destruct ty; constructor.
+- destruct ty; constructor.
+- destruct ty; constructor.
+- destruct ty; constructor.
+- simpl. destruct ty.
++ destruct Archi.ptr64; econstructor; eauto.
++ econs.
++ destruct Archi.ptr64; econstructor; eauto.
++ econs.
++ destruct Archi.ptr64; econstructor; eauto.
++ econstructor; eauto.
+- destruct ty; unfold Val.normalize.
+  { rewrite H. econs; eauto. }
+  { econs. }
+  { rewrite H. econs. }
+  { econs. }
+  { rewrite H. econs; eauto. }
+  { econs; eauto. }
+- destruct ty; try (by ss).
+  { ss. rewrite H. econs. }
+  { ss. econs. }
+  { ss. rewrite H. econs; eauto. }
+  { ss. econs. }
+  { ss. rewrite H. econs. }
+  { ss. econs; eauto. }
+- constructor.
+Qed.
+
+Section MEMCONC.
+
+Definition memory_block_concretize (m m': mem) : Prop :=
+    m.(Mem.mem_contents) = m'.(Mem.mem_contents)
+  /\ m.(Mem.mem_access) = m'.(Mem.mem_access)
+  /\ m.(Mem.nextblock) = m'.(Mem.nextblock)
+  /\ (forall b addr, m.(Mem.mem_concrete) ! b = Some addr -> m'.(Mem.mem_concrete) ! b = Some addr)
+  /\ (forall b (VLD: Mem.valid_block m b), exists addr, m'.(Mem.mem_concrete) ! b = Some addr).
+
+Definition valid_pointer_frag (q: quantity) (n: nat) : bool :=
+  if Archi.ptr64 then (quantity_eq q Q64) && (Nat.ltb n 8) else (quantity_eq q Q32) && (Nat.ltb n 4).
+
+Definition memval_intptr_lbd (m: mem) (mv mv': memval) : Prop :=
+  match mv with
+  | Fragment (Vptr b ofs) q n =>
+      if (valid_pointer_frag q n) && (Mem.is_valid m b)
+      then memval_intptr m mv mv' /\ (is_byte_mv mv')
+      (* invalid fragment. CompCert can't read or concretize this *)
+      else mv = mv' 
+  | Fragment Vundef _ _ => (* mv' = Byte Byte.zero *) mv = mv'
+  | Undef => (* mv' = Byte Byte.zero *) mv = mv'
+  | _ => memval_intptr m mv mv'
+  end.
+
+Definition memval_intptr_lbd_func (m: mem) (mv: memval) : memval :=
+  match mv with
+  | Fragment (Vptr b ofs) q n =>
+      if (valid_pointer_frag q n) && (Mem.is_valid m b)
+      then (match Mem.to_int (Vptr b ofs) m with
+            | Some v => match (nth_error (rev_if_be_mv (encode_val Mptr v)) n) with
+                       | Some bt => bt
+                       | _ => Undef
+                       end
+            | _ => Undef
+            end)        
+      (* invalid fragment. CompCert can't read or concretize this *)
+      else mv
+  (* undef fragment *)
+  | Fragment Vundef _ _ => mv
+  (* undef fragment *)
+  | Undef => mv
+  | _ => mv
+  end.
+
+Definition memory_concretize_contents (m m': mem) : Prop :=
+    m.(Mem.mem_access) = m'.(Mem.mem_access)
+  /\ m.(Mem.nextblock) = m'.(Mem.nextblock)
+  /\ m.(Mem.mem_concrete) = m'.(Mem.mem_concrete)
+  /\ forall b ofs,
+      memval_intptr_lbd m' (ZMap.get ofs (m.(Mem.mem_contents) # b)) (ZMap.get ofs (m'.(Mem.mem_contents) # b)).
+
+Lemma memval_intptr_lbd_success m mv
+    (ALLCONC: forall b (VLD: Mem.valid_block m b), exists addr, m.(Mem.mem_concrete) ! b = Some addr):
+  exists mv', memval_intptr_lbd m mv mv'.
+Proof.
+  destruct mv; ss; try by (esplits; eauto).
+  { eexists. econs. }
+  destruct v; try by (esplits; eauto; try eapply memval_intptr_refl). des_ifs.
+  2:{ esplits; eauto. }
+  eapply andb_prop in Heq. des.
+  exploit (ALLCONC b).
+  { rewrite Mem.valid_block_iff_is_valid. eauto. }
+  i. des.
+  unfold valid_pointer_frag in Heq. des_ifs. eapply andb_prop in Heq. des.
+  destruct q; ss.
+  assert (exists v, Mem.to_int (Vptr b i) m = Some v).
+  { ss. unfold Mem.ptr2int. rewrite H. esplits; eauto. }
+  des.
+  assert (exists bt, nth_error (rev_if_be_mv (encode_val Mptr v)) n = Some bt).
+  { destruct (nth_error (rev_if_be_mv (encode_val Mptr v)) n) eqn:NTH; eauto.
+    exfalso. 
+    simpl in H0. des_ifs. unfold Mem.ptr2int in Heq3. des_ifs. ss.
+    unfold Mptr. des_ifs. unfold rev_if_be_mv in *; des_ifs.
+    rewrite nth_error_None in NTH. rewrite rev_length in NTH.
+    rewrite length_inj_bytes in NTH. rewrite encode_int_length in NTH.
+    rewrite Nat.ltb_lt in Heq2. lia. }
+  des.
+  assert (exists b, bt = Byte b).
+  { simpl in H0. des_ifs. unfold Mem.ptr2int in Heq3. des_ifs. ss.
+    unfold Mptr. des_ifs. unfold rev_if_be_mv in *; des_ifs.
+    eapply nth_error_In in H1. rewrite <- in_rev in H1.
+    specialize (inj_bytes_all_bytes (encode_int 8 (Int64.unsigned (Int64.repr (addr + Ptrofs.unsigned i))))).
+    i. des. rewrite forallb_forall in H. eapply H in H1. destruct bt; ss; eauto. }
+  des. subst. dup H0.
+  simpl in H0. des_ifs. unfold Mem.ptr2int in Heq3. des_ifs.
+  esplits; [econs; eauto| ss].
+Qed.
+
+Lemma memval_intptr_lbd_determ m mv mv1 mv2
+    (MVL1: memval_intptr_lbd m mv mv1)
+    (MVL2: memval_intptr_lbd m mv mv2):
+  mv1 = mv2.
+Proof.
+  unfold memval_intptr_lbd in *. des_ifs; inv MVL1; inv MVL2; ss; eauto.
+  { inv H3; inv H4; eauto. }
+  { inv H3; inv H4; eauto. }
+  { inv H3; inv H4; eauto. }
+  { inv H3; inv H4; eauto. }
+  inv H; inv H1; ss. des_ifs.
+Qed.
+
+Lemma memval_intptr_lbd_same_func m mv
+    (ALLCONC: forall b (VLD: Mem.valid_block m b), exists addr, m.(Mem.mem_concrete) ! b = Some addr):
+  memval_intptr_lbd m mv (memval_intptr_lbd_func m mv).
+Proof.
+  unfold memval_intptr_lbd_func. des_ifs; try by (repeat econs).
+  - dup Heq0. dup Heq1. unfold Mem.to_int in Heq2. simpl in Heq2. des_ifs.
+    unfold Mem.ptr2int in Heq4. des_ifs. unfold Mptr in Heq3. des_ifs.
+    destruct q; try by ss. unfold rev_if_be_mv in Heq3. des_ifs.
+    exploit nth_error_In; eauto. i. simpl in H. rewrite <- in_rev in H.
+    specialize (inj_bytes_all_bytes (encode_int 8 (Int64.unsigned (Int64.repr (z0 + Ptrofs.unsigned i))))).
+    i. des. rewrite forallb_forall in H0. exploit H0; eauto. i. destruct m0; ss.
+    rewrite Heq. esplits; eauto. econs; eauto.
+  - exfalso. eapply nth_error_None in Heq1. ss. des_ifs.
+    unfold Mem.ptr2int, Mptr, rev_if_be_mv in *. des_ifs.
+    rewrite rev_length in Heq1. ss. erewrite length_inj_bytes in Heq1. erewrite encode_int_length in Heq1.
+    eapply andb_prop in Heq. unfold valid_pointer_frag in Heq. des. des_ifs. eapply andb_prop in Heq. des.
+    rewrite Nat.ltb_lt in Heq5. lia.
+  - exfalso. eapply andb_prop in Heq. des. erewrite <- Mem.valid_block_iff_is_valid in Heq1.
+    exploit ALLCONC; eauto. i. des. ss. unfold Mem.ptr2int in *. des_ifs.
+  - r. rewrite Heq. eauto.
+Qed.
+
+Lemma lbd_contents_success
+    (cont: PMap.t (ZMap.t memval)) m
+    (ALLCONC: forall b (VLD: Mem.valid_block m b), exists addr, m.(Mem.mem_concrete) ! b = Some addr):
+  exists cont', forall b ofs, memval_intptr_lbd m (ZMap.get ofs (PMap.get b cont)) (ZMap.get ofs cont' !! b).
+Proof.
+  remember (ZMap.map (memval_intptr_lbd_func m)) as zm.
+  remember (PMap.map zm) as pm.
+  exists (pm cont). subst. i. rewrite PMap.gmap. rewrite ZMap.gmap.
+  eapply memval_intptr_lbd_same_func; eauto.
+Qed.
+
+Lemma same_concrete_memval_intptr_lbd
+    m1 m2 mv1 mv2
+    (SAMENXT: Mem.nextblock m1 = Mem.nextblock m2)
+    (SAME: Mem.mem_concrete m1 = Mem.mem_concrete m2)
+    (LBD: memval_intptr_lbd m1 mv1 mv2):
+  memval_intptr_lbd m2 mv1 mv2.
+Proof.
+  unfold memval_intptr_lbd in *. des_ifs; try by eapply same_concrete_memval_intptr; eauto.
+  - des. esplit; eauto. eapply same_concrete_memval_intptr; eauto.
+  - eapply andb_prop in Heq. des. rewrite Heq in Heq0. ss.
+    exfalso. unfold Mem.is_valid in *. rewrite SAMENXT in Heq0. clarify.
+  - eapply andb_prop in Heq0. des. rewrite Heq0 in Heq. ss.
+    exfalso. unfold Mem.is_valid in *. rewrite SAMENXT in Heq1. clarify.
+Qed.
+
+Lemma memory_concretize_contents_exists_aux m
+    (ALLCONC: forall b (VLD: Mem.valid_block m b), exists addr, m.(Mem.mem_concrete) ! b = Some addr):
+  exists m', memory_concretize_contents m m'.
+Proof.
+  remember (PMap.map (ZMap.map (memval_intptr_lbd_func m)) m.(Mem.mem_contents)) as cont'.
+
+  assert (AM : forall b ofs, Mem.perm_order'' (m.(Mem.mem_access) !! b ofs Max) (m.(Mem.mem_access) !! b ofs Cur)).
+  { eapply Mem.access_max. }
+  
+  assert (NBD: forall b ofs k, ~ Plt b m.(Mem.nextblock) -> m.(Mem.mem_access) !! b ofs k = None).
+  { eapply Mem.nextblock_noaccess. }
+  
+  assert (CD: forall b, fst cont' !! b = Undef).
+  { subst. i. specialize (Mem.contents_default m b). i.
+    destruct ((Mem.mem_contents m) !! b) eqn:A. ss. subst.
+    rewrite PMap.gmap. rewrite A. ss. }
+
+  assert (NL: forall b, ~ Plt b m.(Mem.nextblock) -> m.(Mem.mem_concrete) ! b = None).
+  { eapply Mem.nextblocks_logical. }
+
+  assert (VAB: forall bo addr,
+             Mem.addr_in_block m.(Mem.mem_concrete) m.(Mem.mem_access) addr bo -> addr < Ptrofs.modulus - 1).
+  { eapply Mem.valid_address_bounded. }
+
+  assert (NCO: forall addr, uniqueness (Mem.addr_in_block m.(Mem.mem_concrete) m.(Mem.mem_access) addr)).
+  { eapply Mem.no_concrete_overlap. }
+  
+  assert (CA:  forall (b : positive) (zero_addr : Z),
+             m.(Mem.mem_concrete) ! b = Some zero_addr ->
+             forall (ofs : Z) (chunk : memory_chunk),
+               (forall o : Z, ofs <= o < ofs + size_chunk chunk -> Mem.perm_order' (m.(Mem.mem_access) !! b o Max) Nonempty) ->
+               (align_chunk chunk | zero_addr)).
+  { eapply Mem.concrete_align. }
+  
+  assert (WVAR: forall b zero_addr ofs,
+             m.(Mem.mem_concrete) ! b = Some zero_addr ->
+             0 <= ofs < Ptrofs.modulus ->
+             Mem._weak_valid_pointer m.(Mem.mem_access) b ofs Max -> Mem.in_range (zero_addr + ofs) (1, Ptrofs.modulus)).
+  { eapply Mem.weak_valid_address_range. }
+
+  exists (Mem.mkmem cont' m.(Mem.mem_access) m.(Mem.mem_concrete) m.(Mem.nextblock) AM NBD CD NL VAB NCO CA WVAR).
+  econs; ss; esplits; eauto.
+  i. eapply same_concrete_memval_intptr_lbd; simpl; eauto.
+  subst. rewrite PMap.gmap. rewrite ZMap.gmap.
+  eapply memval_intptr_lbd_same_func; eauto.
+Qed.
+
+End MEMCONC.
diff --git a/common/Linking.v b/common/Linking.v
index 089f4fd2..f363a2b0 100644
--- a/common/Linking.v
+++ b/common/Linking.v
@@ -19,8 +19,7 @@
 Require Import Coqlib Maps Errors AST.
 
 (** This file follows "approach A" from the paper
-       "Lightweight Verification of Separate Compilation"
-    by Kang, Kim, Hur, Dreyer and Vafeiadis, POPL 2016. *)
+       "Lightweight Verification of Separate Compilation", POPL 2016. *)
 
 
 (** * Syntactic linking *)
diff --git a/common/Memdata.v b/common/Memdata.v
index 1bd87169..e2219636 100644
--- a/common/Memdata.v
+++ b/common/Memdata.v
@@ -24,6 +24,7 @@ Require Import AST.
 Require Import Integers.
 Require Import Floats.
 Require Import Values.
+Require Import sflib.
 
 (** * Properties of memory chunks *)
 
@@ -179,6 +180,9 @@ Fixpoint int_of_bytes (l: list byte): Z :=
 Definition rev_if_be (l: list byte) : list byte :=
   if Archi.big_endian then List.rev l else l.
 
+Definition rev_if_be_mv (l: list memval) : list memval :=
+  if Archi.big_endian then l else List.rev l.
+
 Definition encode_int (sz: nat) (x: Z) : list byte :=
   rev_if_be (bytes_of_int sz x).
 
@@ -321,6 +325,167 @@ Fixpoint proj_bytes (vl: list memval) : option (list byte) :=
   | _ => None
   end.
 
+Fixpoint proj_fragment (vl: list memval) : option (list memval) :=
+  match vl with
+  | nil => Some nil
+  | Fragment v q n :: vl' =>
+      match proj_fragment vl' with None => None | Some mvl => Some(Fragment v q n :: mvl) end
+  | _ => None
+  end.
+
+(* Fixpoint proj_fragment (vl: list memval) : option (list memval) := *)
+(*   match vl with *)
+(*   | nil => Some nil *)
+(*   | Fragment v q n :: vl' => *)
+(*       match proj_fragment vl' with None => None | Some mvl => Some(Fragment v q n :: mvl) end *)
+(*   | _ => None *)
+(*   end. *)
+Definition is_byte_mv (mv: memval) : bool :=
+  match mv with
+  | Byte _ => true
+  | _ => false
+  end.
+
+Definition is_long_mv (mv: memval) : bool :=
+  match mv with
+  | Fragment (Vlong _) _ _ => true
+  | _ => false
+  end.
+
+Definition is_int_mv (mv: memval) : bool :=
+  match mv with
+  | Fragment (Vint _) _ _ => true
+  | _ => false
+  end.
+
+Definition is_ptr_mv (mv: memval) : bool :=
+  match mv with
+  | Fragment (Vptr _ _) q n => if Archi.ptr64
+                              then quantity_eq q Q64 (* && Nat.ltb n 8 *)
+                              else quantity_eq q Q32 (* && Nat.ltb n 4 *)
+  | _ => false
+  end.
+
+Definition is_frag_mv (mv: memval) : bool :=
+  match mv with
+  | Fragment _ _ _ => true
+  | _ => false
+  end.
+
+(* true: vl contains "pointer" and "byte" memval *)
+Definition proj_fragment_byte_mixed (vl: list memval) : bool :=
+  (existsb is_byte_mv vl) && (existsb is_frag_mv vl).
+
+(* true: vl contains "pointer" and "long" Fragement *)
+Definition proj_fragment_mixed (vl: list memval) : bool :=
+  if Archi.ptr64 then (existsb is_long_mv vl) && (existsb is_ptr_mv vl)
+  else (existsb is_int_mv vl) && (existsb is_ptr_mv vl).
+  (* match vl with *)
+  (* | nil => Some nil *)
+  (* | Fragment v q n :: vl' =>  match proj_fragment vl' with *)
+  (*                           | None => None *)
+  (*                           | Some mvl => match v with *)
+  (*                                        | Vptr b ofs => Some(Fragment (Vptr b ofs) q n :: mvl) *)
+  (*                                        | Vlong i => if Archi.ptr64 then Some(Fragment (Vlong i) q n :: mvl) else None *)
+  (*                                        | Vint i => if negb Archi.ptr64 then Some(Fragment (Vint i) q n :: mvl) else None *)
+  (*                                        | _ => None *)
+  (*                                        end *)
+  (*                           end *)
+  (* | _ => None *)
+  (* end. *)
+
+Fixpoint proj_undef (vl: list memval) : option (list memval) :=
+  match vl with
+  | nil => Some nil
+  | Undef :: vl' =>
+      match proj_undef vl' with None => None | Some mvl => Some(Undef :: mvl) end
+  | _ => None
+  end.
+
+Definition bytes_mixed_byte_frag (mvs: list memval) : bool :=
+  (match (proj_bytes mvs), (proj_fragment mvs) with
+   | None, None => true
+   | _, _ => false
+   end).
+(* if not pure & Ptr fragment -> it can be Vlong or Vundef *)
+(* if pure -> value is same if bytes are not changed  *)
+Definition bytes_not_pure (mvs: list memval) : bool :=
+  (proj_fragment_byte_mixed mvs) || (proj_fragment_mixed mvs).
+
+Lemma proj_bytes_not_mixed
+  bytes bl
+  (BYTES: proj_bytes bytes = Some bl):
+  <<PURE: proj_fragment_byte_mixed bytes = false>>.
+Proof.
+  unfold proj_fragment_byte_mixed. eapply andb_false_intro2.
+  ginduction bytes; ss; i. des_ifs. ss. eauto.
+Qed.
+
+Lemma proj_fragment_not_mixed
+  bytes bl
+  (BYTES: proj_fragment bytes = Some bl):
+  <<PURE: proj_fragment_byte_mixed bytes = false>>.
+Proof.
+  unfold proj_fragment_byte_mixed. eapply andb_false_intro1.
+  ginduction bytes; ss; i. des_ifs. ss. eauto.
+Qed.
+
+Lemma proj_bytes_not_mixed_fragment
+  bytes bl
+  (BYTES: proj_bytes bytes = Some bl):
+  <<PURE: proj_fragment_mixed bytes = false>>.
+Proof.
+  unfold proj_fragment_mixed. des_ifs. eapply andb_false_intro2.
+  ginduction bytes; ss; i. des_ifs. ss. eauto.
+Qed.
+
+Lemma proj_bytes_pure
+  bytes bl
+  (BYTES: proj_bytes bytes = Some bl):
+  <<PURE: bytes_not_pure bytes = false>>.
+Proof.
+  unfold bytes_not_pure. erewrite proj_bytes_not_mixed; eauto. erewrite proj_bytes_not_mixed_fragment; eauto.
+Qed.
+
+
+Definition bytes_mixed_byte_frag_int (vl: list memval) : bool :=
+  if Archi.ptr64 then (existsb is_long_mv vl) && (existsb is_byte_mv vl)
+  else (existsb is_int_mv vl) && (existsb is_byte_mv vl).
+
+(* Definition bytes_not_pure (mvs: list memval) : bool := *)
+(*   (bytes_mixed_byte_frag mvs) || (proj_fragment_mixed mvs). *)
+
+(* match  *)
+(*   match chunk with *)
+(*   | Mint64 => if Archi.ptr64 then (match (proj_bytes mvs), (proj_fragment mvs) with *)
+(*                                   | None, None => true *)
+(*                                   | _, _ => false *)
+(*                                   end) *)
+(*              else false *)
+(*   | Mint32 => if negb Archi.ptr64 then (match (proj_bytes mvs), (proj_fragment mvs) with *)
+(*                                        | None, None => true *)
+(*                                        | _, _ => false *)
+(*                                        end) *)
+(*              else false *)
+(*   | Many64 => if Archi.ptr64 then proj_fragment_mixed mvs else false *)
+(*   | Many32 => if negb Archi.ptr64 then proj_fragment_mixed mvs else false *)
+(*   | _ => false *)
+(*   end. *)
+
+Let _undef_same := fun mv => match mv with
+                          | Undef => true
+                          | _ => false
+                          end.
+
+Definition bytes_all_undef (mvs: list memval) : bool :=
+  forallb (_undef_same) mvs.
+
+Definition undef_in_bytes (mvs: list memval) : bool :=
+  existsb (_undef_same) mvs.
+
+Definition bytes_not_change (mvs: list memval) : bool :=
+  (existsb (_undef_same) mvs) || (negb (bytes_not_pure mvs)).
+
 Remark length_inj_bytes:
   forall bl, length (inj_bytes bl) = length bl.
 Proof.
@@ -390,12 +555,10 @@ Definition decode_val (chunk: memory_chunk) (vl: list memval) : val :=
       | Mint8unsigned => Vint(Int.zero_ext 8 (Int.repr (decode_int bl)))
       | Mint16signed => Vint(Int.sign_ext 16 (Int.repr (decode_int bl)))
       | Mint16unsigned => Vint(Int.zero_ext 16 (Int.repr (decode_int bl)))
-      | Mint32 => Vint(Int.repr(decode_int bl))
-      | Mint64 => Vlong(Int64.repr(decode_int bl))
+      | Mint32 | Many32 => Vint(Int.repr(decode_int bl))
+      | Mint64 | Many64 => Vlong(Int64.repr(decode_int bl))
       | Mfloat32 => Vsingle(Float32.of_bits (Int.repr (decode_int bl)))
       | Mfloat64 => Vfloat(Float.of_bits (Int64.repr (decode_int bl)))
-      | Many32 => Vundef
-      | Many64 => Vundef
       end
   | None =>
       match chunk with
@@ -801,7 +964,7 @@ Proof.
   replace v2 with v'.
   unfold proj_sumbool; rewrite ! dec_eq_true. rewrite <- beq_nat_refl. simpl; eauto.
   inv H2; try discriminate; inv H4; congruence.
-  discriminate.
+  (* discriminate. *)
 Qed.
 
 Lemma proj_value_inject:
diff --git a/common/Memory.v b/common/Memory.v
index fa60455b..933c865a 100644
--- a/common/Memory.v
+++ b/common/Memory.v
@@ -39,6 +39,8 @@ Require Import Floats.
 Require Import Values.
 Require Export Memdata.
 Require Export Memtype.
+Require Export sflib.
+Require Import Classical.
 
 (* To avoid useless definitions of inductors in extracted code. *)
 Local Unset Elimination Schemes.
@@ -61,29 +63,143 @@ Definition perm_order'' (po1 po2: option permission) :=
   | None, Some _ => False
  end.
 
+Inductive in_range (z: Z) (r: Z * Z) :=
+| in_range_intro
+    (FST: (fst r) <= z)
+    (SND: (snd r) > z) :
+  in_range z r.
+
+Definition in_rangeb (z:Z) (r: Z * Z) : bool :=
+  if (Z.leb (fst r) z) && (Z.ltb z (snd r)) then true else false.
+
+Lemma in_range_iff: forall z r,
+    in_range z r <-> in_rangeb z r = true.
+Proof.
+  split; i.
+  - inv H. des. unfold in_rangeb. des_ifs. lia.
+  - unfold in_rangeb in H. des_ifs. econs; lia.
+Qed.
+
+(* Meaning of (addr_in_block mem_concrete mem_access addr blk) :  *)
+(* a concrete address "addr" corresponds to a logical address in the logical block "blk". *)
+Inductive addr_in_block (conc:PTree.t Z) (acc:PMap.t (Z -> perm_kind -> option permission)) (addr:Z) (blk: block) : Prop :=
+| addr_in_block_intro
+    caddr
+    (CONCRETE: conc!blk = Some caddr)
+    (PERM: exists perm, acc#blk (addr-caddr) Max = Some perm)
+    (POS: 0 <= (addr-caddr) < Ptrofs.modulus) :
+    addr_in_block conc acc addr blk.
+
+Definition addr_is_in_block (conc:PTree.t Z) (acc:PMap.t (Z -> perm_kind -> option permission)) (addr:Z) (blk: block) : bool :=
+  match (conc!blk) with
+  | Some caddr => match acc#blk (addr-caddr) Max with
+                 | Some _ => Z.leb 0 (addr-caddr) && Z.ltb (addr-caddr) Ptrofs.modulus
+                 | _ => false
+                 end
+  | _ => false
+  end.
+
+Lemma addr_in_block_iff: forall conc acc addr blk,
+    addr_in_block conc acc addr blk <-> addr_is_in_block conc acc addr blk = true.
+Proof.
+  split; i.
+  - inv H. des. unfold addr_is_in_block. des_ifs. lia.
+  - unfold addr_is_in_block in H. des_ifs. econs; eauto. lia.
+Qed.
+
+(* weak valid pointer & max permission *)
+
+Definition _valid_pointer (acc:PMap.t (Z -> perm_kind -> option permission)) (blk: block) (ofs: Z) (k: perm_kind) : Prop :=
+  perm_order' (acc#blk ofs k) Nonempty.
+
+Definition _weak_valid_pointer (acc:PMap.t (Z -> perm_kind -> option permission)) (blk: block) (ofs: Z) (k: perm_kind) : Prop :=
+  _valid_pointer acc blk ofs k \/ _valid_pointer acc blk (ofs - 1) k.
+
 Record mem' : Type := mkmem {
   mem_contents: PMap.t (ZMap.t memval);  (**r [block -> offset -> memval] *)
   mem_access: PMap.t (Z -> perm_kind -> option permission);
                                          (**r [block -> offset -> kind -> option permission] *)
+  mem_concrete: PTree.t Z; (** [block -> option Z] **)
   nextblock: block;
   access_max:
     forall b ofs, perm_order'' (mem_access#b ofs Max) (mem_access#b ofs Cur);
   nextblock_noaccess:
     forall b ofs k, ~(Plt b nextblock) -> mem_access#b ofs k = None;
   contents_default:
-    forall b, fst mem_contents#b = Undef
+    forall b, fst mem_contents#b = Undef;
+  nextblocks_logical:
+    forall b, ~(Plt b nextblock) -> mem_concrete!b = None;
+  valid_address_bounded:
+    forall bo addr (IN_BLOCK: addr_in_block mem_concrete mem_access addr bo),
+      addr < Ptrofs.modulus - 1;
+  no_concrete_overlap:
+    forall addr, uniqueness (addr_in_block mem_concrete mem_access addr);
+  concrete_align:
+    forall b zero_addr (CADDR: mem_concrete!b = Some zero_addr)
+      ofs chunk (RPERM: forall o, ofs <= o < ofs + (size_chunk chunk) -> perm_order' (mem_access#b o Max) Nonempty),
+      (align_chunk chunk | zero_addr);
+  weak_valid_address_range:
+    forall b zero_addr ofs (CADDR: mem_concrete!b = Some zero_addr)
+                      (RANGE: 0 <= ofs < Ptrofs.modulus)
+                      (WVLD: _weak_valid_pointer mem_access b ofs Max),
+      in_range (zero_addr + ofs) (1, Ptrofs.modulus);
 }.
-
 Definition mem := mem'.
 
 Lemma mkmem_ext:
- forall cont1 cont2 acc1 acc2 next1 next2 a1 a2 b1 b2 c1 c2,
-  cont1=cont2 -> acc1=acc2 -> next1=next2 ->
-  mkmem cont1 acc1 next1 a1 b1 c1 = mkmem cont2 acc2 next2 a2 b2 c2.
+  forall cont1 cont2 acc1 acc2 conc1 conc2 nxt1 nxt2 a1 a2 b1 b2 c1 c2 d1 d2 e1 e2 f1 f2 g1 g2 h1 h2,
+  cont1=cont2 -> acc1=acc2 -> conc1=conc2 -> nxt1=nxt2 ->
+  mkmem cont1 acc1 conc1 nxt1 a1 b1 c1 d1 e1 f1 g1 h1 = mkmem cont2 acc2 conc2 nxt2 a2 b2 c2 d2 e2 f2 g2 h2.
 Proof.
   intros. subst. f_equal; apply proof_irr.
 Qed.
 
+Lemma _weak_valid_block_zero m b addr
+    (IN_BLOCK: addr_in_block m.(mem_concrete) m.(mem_access) addr b) :
+  <<INRANGE: 1 <= addr>>.
+Proof.
+  specialize (weak_valid_address_range m). intros WVLD. inv IN_BLOCK.
+  des. exploit WVLD; eauto.
+  { left. unfold _valid_pointer. rewrite PERM. ss. eapply perm_any_N. }
+  i. inv H. ss. r. lia.
+Qed.
+
+(* Lemma valid_addr_bound_cant_implies_weak_valid_bound *)
+(*   m b zero_addr ofs *)
+(*   (CADDR: m.(mem_concrete)!b = Some zero_addr) *)
+(*   (RANGE: 0 <= ofs < Ptrofs.modulus) *)
+(*   (WVLD: _weak_valid_pointer m.(mem_access) b ofs Max) : *)
+(*   zero_addr + ofs < Ptrofs.modulus. *)
+(* Proof. *)
+(*   specialize (valid_address_bounded m). i. *)
+(*   destruct WVLD as [VLD | WVLD]. *)
+(*   - assert (addr_in_block (mem_concrete m) (mem_access m) (zero_addr + ofs) b). *)
+(*     { econs; eauto; [|lia]. *)
+(*       unfold _valid_pointer, perm_order' in *. des_ifs. *)
+(*       replace (zero_addr + ofs - zero_addr) with ofs by lia. eauto. } *)
+(*     eapply H in H0. lia. *)
+(*   - assert (addr_in_block (mem_concrete m) (mem_access m) (zero_addr + (ofs - 1)) b). *)
+(*     { econs; eauto. *)
+(*       (* split;[|lia]. replace (zero_addr + (ofs - 1) - zero_addr) with (ofs - 1) by lia. *) *)
+(*       (* it can't guarantee zero size weak valid pointer's upperbound *) *)
+(*       (* (if permission in ofs = -1, (b, ofs + 1) ~ paddr -> paddr < Ptorfs.modulus is not guaranteed  *) *)
+(* Abort. *)
+
+Lemma _valid_pointer_range
+  m b addr
+  (IN_BLOCK: addr_in_block m.(mem_concrete) m.(mem_access) addr b) :
+  <<INRANGE: in_range addr (1, Ptrofs.modulus - 1)>>.
+Proof.
+  specialize (weak_valid_address_range m). intros WVLD.
+  exploit valid_address_bounded; eauto. intros BOUND. inv IN_BLOCK.
+  des. exploit WVLD; eauto.
+  { unfold _weak_valid_pointer, _valid_pointer. rewrite PERM.
+    left. ss. eapply perm_any_N. }
+  replace (caddr + (addr - caddr)) with addr by lia. ii. inv H.
+  econs; eauto. unfold snd. simpl in FST, SND.
+  destruct (zeq addr (Ptrofs.modulus - 1)); [lia|lia].
+Qed.
+
 (** * Validity of blocks and accesses *)
 
 (** A block address is valid if it was previously allocated. It remains valid
@@ -97,6 +213,21 @@ Proof.
   intros; red; intros. subst b'. contradiction.
 Qed.
 
+Definition is_valid (m: mem) (b: block) : bool := Pos.ltb b (nextblock m).
+
+Lemma valid_block_iff_is_valid m b : valid_block m b <-> is_valid m b = true.
+Proof.
+  unfold valid_block, is_valid. split.
+  - ii. erewrite Pos.ltb_lt. eauto.
+  - ii. erewrite <- Pos.ltb_lt. eauto.
+Qed.
+
+Lemma concrete_valid m b addr (CONC: m.(mem_concrete) ! b = Some addr) :
+  <<VLD: valid_block m b>>.
+Proof.
+  r. eapply NNPP. ii. unfold valid_block in H. eapply nextblocks_logical in H. clarify.
+Qed.
+
 Local Hint Resolve valid_not_valid_diff: mem.
 
 (** Permissions *)
@@ -338,6 +469,74 @@ Proof.
   intros. apply weak_valid_pointer_spec. auto.
 Qed.
 
+Lemma captured_valid_in_block
+    m b caddr ofs
+    (CAPTURED: (mem_concrete m) ! b = Some caddr)
+    (VLD: Mem.valid_pointer m b (Ptrofs.unsigned ofs) = true) :
+  addr_in_block (Mem.mem_concrete m) (Mem.mem_access m) (caddr + Ptrofs.unsigned ofs) b.
+Proof.
+  econs; eauto; replace (caddr + Ptrofs.unsigned ofs - caddr) with (Ptrofs.unsigned ofs) by lia.
+  - rewrite Mem.valid_pointer_nonempty_perm in VLD. eapply Mem.perm_cur_max in VLD.
+    unfold Mem.perm, Mem.perm_order' in VLD. des_ifs. eauto.
+  - eapply Ptrofs.unsigned_range.
+Qed.
+
+Lemma weak_valid_pointer_weak_valid' m b ofs
+    (WVLD: Mem.weak_valid_pointer m b ofs = true) :
+  Mem._weak_valid_pointer (Mem.mem_access m) b ofs Max.
+Proof.
+  rewrite Mem.weak_valid_pointer_spec in WVLD. unfold Mem._weak_valid_pointer.
+  do 2 rewrite Mem.valid_pointer_nonempty_perm in WVLD. des.
+  - left. eapply Mem.perm_cur_max; eauto.
+  - right. eapply Mem.perm_cur_max; eauto.
+Qed.
+
+Lemma weak_valid_pointer_weak_valid m b ofs
+    (WVLD: Mem.weak_valid_pointer m b (Ptrofs.unsigned ofs) = true) :
+  Mem._weak_valid_pointer (Mem.mem_access m) b (Ptrofs.unsigned ofs) Max.
+Proof.
+  eapply weak_valid_pointer_weak_valid'; eauto.
+Qed.
+
+(** * Memory Properties *)
+
+(* [access_le m1 m2] states that the permissions of m1's permission is None each time m2's is *)
+Definition access_le (acc1 acc2:PMap.t (Z -> perm_kind -> option permission)): Prop :=
+  forall b off (M2_NONE: acc2#b off Max = None),
+    acc1#b off Max = None.
+
+Lemma access_le_in_block
+    acc1 acc2 concrete addr block
+    (WEAK:access_le acc1 acc2)
+    (IN_BLOCK_M1: addr_in_block concrete acc1 addr block) :
+  addr_in_block concrete acc2 addr block.
+Proof.
+  intros. unfold access_le in WEAK.
+  inversion IN_BLOCK_M1.
+  destruct ((acc2#block (addr-caddr) Max)) as [a|] eqn:H.
+  + econs. exact CONCRETE. exists a. exact H. eauto.
+  + apply WEAK in H. destruct PERM as [a PERM]. simpl in PERM. rewrite PERM in H. inversion H.
+Qed.
+
+Lemma access_le_no_overlap:
+  forall acc1 acc2 concrete
+    (WEAK: access_le acc1 acc2)
+    (NO_OVERLAP_M2: forall addr, uniqueness (addr_in_block concrete acc2 addr)),
+  forall addr, uniqueness (addr_in_block concrete acc1 addr).
+Proof.
+  intros. unfold uniqueness in *. intros b1 b2 B1 B2.
+  apply NO_OVERLAP_M2 with (addr:=addr);
+  apply access_le_in_block with (acc1:=acc1); try exact WEAK;
+  try exact B1; try exact B2.
+Qed.
+
+Lemma logical_nextblock (m:mem): m.(mem_concrete)!(m.(nextblock)) = None.
+Proof.
+  apply m.(nextblocks_logical).
+  unfold not. intros. apply Plt_ne in H.
+  unfold not in H. apply H. reflexivity.
+Qed.
+
 (** * Operations over memory stores *)
 
 (** The initial store *)
@@ -345,7 +544,8 @@ Qed.
 Program Definition empty: mem :=
   mkmem (PMap.init (ZMap.init Undef))
         (PMap.init (fun ofs k => None))
-        1%positive _ _ _.
+        (PTree.empty Z)
+        1%positive _ _ _ _ _ _ _ _.
 Next Obligation.
   repeat rewrite PMap.gi. red; auto.
 Qed.
@@ -355,6 +555,25 @@ Qed.
 Next Obligation.
   rewrite PMap.gi. auto.
 Qed.
+Next Obligation.
+  rewrite PTree.gempty. eauto.
+Qed.
+Next Obligation.
+  inversion IN_BLOCK. des. ss.
+  erewrite empty_obligation_2 in PERM. clarify.
+Qed.
+Next Obligation.
+  unfold uniqueness in *. intros b1 b2 B1 B2.
+  inversion B1. des. erewrite empty_obligation_2 in PERM. clarify.
+Qed.
+Next Obligation.
+  specialize (RPERM ofs). exploit RPERM; eauto.
+  { split; [lia | ]. destruct chunk; ss; lia. }
+  ii. des. erewrite empty_obligation_2 in H. clarify.
+Qed.
+Next Obligation.
+  rewrite PTree.gempty in CADDR. clarify.
+Qed.
 
 (** Allocation of a fresh block with the given bounds.  Return an updated
   memory state and the address of the fresh block, which initially contains
@@ -368,8 +587,9 @@ Program Definition alloc (m: mem) (lo hi: Z) :=
          (PMap.set m.(nextblock)
                    (fun ofs k => if zle lo ofs && zlt ofs hi then Some Freeable else None)
                    m.(mem_access))
+         (m.(mem_concrete))
          (Pos.succ m.(nextblock))
-         _ _ _,
+         _ _ _ _ _ _ _ _,
    m.(nextblock)).
 Next Obligation.
   repeat rewrite PMap.gsspec. destruct (peq b (nextblock m)).
@@ -385,6 +605,762 @@ Qed.
 Next Obligation.
   rewrite PMap.gsspec. destruct (peq b (nextblock m)). auto. apply contents_default.
 Qed.
+Next Obligation.
+  rewrite m.(nextblocks_logical). reflexivity.
+  unfold not in *. intro H0. apply H.
+  apply Plt_trans_succ. exact H0.
+Qed.
+Next Obligation.
+  assert (RESULT: addr_in_block m.(mem_concrete) m.(mem_access) addr bo).
+  { inversion IN_BLOCK. clear IN_BLOCK.
+    destruct (Pos.eq_dec bo m.(nextblock)).
+    + rewrite e in CONCRETE. simpl in CONCRETE.
+      rewrite logical_nextblock in CONCRETE. inversion CONCRETE.
+    + econs. exact CONCRETE.
+      destruct PERM as [perm PERM].
+      rewrite PMap.gso in PERM.
+      exists perm. exact PERM. exact n. eauto. }
+  apply m.(valid_address_bounded) in RESULT. exact RESULT.
+Qed.
+Next Obligation.
+  unfold uniqueness in *. intros b1 b2 B1 B2.
+  destruct (Pos.eq_dec b1 m.(nextblock)).
+  - rewrite e in *. clear B2.
+    inversion B1. clear B1. simpl in CONCRETE.
+    rewrite logical_nextblock in CONCRETE. inversion CONCRETE.
+  - destruct (Pos.eq_dec b2 m.(nextblock)).
+    + rewrite e in *. clear B1.
+      inversion B2. clear B2. simpl in CONCRETE.
+      rewrite logical_nextblock in CONCRETE. inversion CONCRETE.
+    + apply m.(no_concrete_overlap) with (addr:=addr);
+        [inversion B1 | inversion B2]; simpl in CONCRETE;
+          econs; try exact CONCRETE;
+          destruct PERM as [perm PERM]; eauto; exists perm;
+            rewrite PMap.gso in PERM; try exact PERM; try exact n; try exact n0.
+Qed.
+Next Obligation.
+  assert (b <> (nextblock m)).
+  { ii. subst. rewrite logical_nextblock in CADDR. clarify. }
+  eapply (concrete_align m); eauto. ii.
+  exploit RPERM; eauto. ii. des. rewrite PMap.gso in H1; eauto.
+Qed.
+Next Obligation.
+  eapply weak_valid_address_range; eauto.
+  assert (b <> (nextblock m)).
+  { ii. subst. rewrite logical_nextblock in CADDR; clarify. }
+  unfold _weak_valid_pointer, _valid_pointer in *. rewrite PMap.gso in *; eauto.
+Qed.
+
+Definition is_concrete (m: mem) (b: block) : bool :=
+  match m.(mem_concrete)!b with
+  | Some _ => true
+  | _ => false
+  end.
+
+Program Definition nonempty_alloc (m: mem) (b: block) (lo hi: Z) :=
+  if perm_dec m b lo Max Nonempty then
+    Some (mkmem m.(mem_contents)
+                (if (is_concrete m b)
+                 then m.(mem_access)
+                 else (PMap.set b
+                         (fun ofs k => if zle lo ofs && zlt ofs hi then Some Nonempty else None)
+                         m.(mem_access)))
+                m.(mem_concrete)
+                m.(nextblock)
+                _ _ _ _ _ _ _ _)
+  else None.
+Next Obligation.
+  repeat rewrite PMap.gsspec. destruct (peq b0 b).
+  - subst. destruct (is_concrete m b) eqn:CONC.
+    { apply access_max. }
+    rewrite PMap.gss. destruct (zle lo ofs && zlt ofs hi); red; auto with mem.
+  - destruct (is_concrete m b) eqn:CONC; eauto.
+    { apply access_max. }
+    { erewrite PMap.gso; eauto. eapply access_max. }
+Qed.
+Next Obligation.
+  destruct (is_concrete m b) eqn:CONC; eauto.
+  { apply nextblock_noaccess. eauto. }
+  rewrite PMap.gsspec. destruct (peq b0 b).
+  2:{ apply nextblock_noaccess. eauto. }
+  des_ifs. exfalso. unfold is_concrete in CONC. des_ifs.
+  eapply H0. eapply perm_valid_block; eauto.
+Qed.
+Next Obligation.
+  destruct m; ss.
+Qed.
+Next Obligation.
+  eapply nextblocks_logical. eauto.
+Qed.
+Next Obligation.
+  destruct (peq b bo).
+  { subst. inv IN_BLOCK. des. destruct (is_concrete m bo) eqn:CONC.
+    - eapply valid_address_bounded with (m:=m) (bo:=bo).
+      econs; eauto.
+    - unfold is_concrete in CONC. erewrite CONCRETE in CONC. clarify. }
+  destruct (is_concrete m b) eqn:CONC.
+  { eapply valid_address_bounded with (m:=m) (bo:=bo). eauto. }
+  eapply valid_address_bounded with (m:=m) (bo:=bo).
+  inv IN_BLOCK. des. rewrite PMap.gso in PERM; eauto. econs; eauto.
+Qed.
+Next Obligation.
+  destruct (is_concrete m b) eqn:CONC.
+  { eapply no_concrete_overlap with (m:=m) (addr:=addr). }
+  ii. destruct (peq b x); subst.
+  { inv H0. exfalso. unfold is_concrete in CONC. des_ifs. }
+  destruct (peq b y); subst.
+  { inv H1. exfalso. unfold is_concrete in CONC. des_ifs. }
+  eapply no_concrete_overlap with (m:=m) (addr:=addr).
+  - inv H0. des. rewrite PMap.gso in PERM; eauto. econs; eauto.
+  - inv H1. des. rewrite PMap.gso in PERM; eauto. econs; eauto.
+Qed.
+Next Obligation.
+  destruct (is_concrete m b) eqn:CONC.
+  { eapply concrete_align; eauto. }
+  destruct (peq b b0); subst.
+  { exfalso. unfold is_concrete in CONC. des_ifs. }
+  eapply concrete_align; eauto. i. eapply RPERM in H0.
+  rewrite PMap.gso in H0; eauto.
+Qed.
+Next Obligation.
+  destruct (is_concrete m b) eqn:CONC.
+  { eapply weak_valid_address_range; eauto. }
+  destruct (peq b b0); subst.
+  { exfalso. unfold is_concrete in CONC. des_ifs. }
+  eapply weak_valid_address_range; eauto.
+  r in WVLD. unfold _valid_pointer in WVLD.
+  erewrite PMap.gso in WVLD; eauto.
+Qed.
+
+(** the capture of a block is non-deterministic.
+    the concrete address that can be given to this block is non-deterministic.
+    Thus, we describe with a Proposition.
+    [capture m1 b addr m2] states that m2 is the memory m1 at the only difference that the block b has been captured at concrete address addr. *)
+
+Inductive capture (m1:mem) (b:block) (addr:Z) (m2:mem): Prop :=
+| capture_intro
+    (VALID: valid_block m1 b)
+    (CONTENTS: m1.(mem_contents) = m2.(mem_contents))
+    (ACCESS: m1.(mem_access) = m2.(mem_access))
+    (NEXTBLOCK: m1.(nextblock) = m2.(nextblock))
+    (CAPTURED: m1.(mem_concrete)!b = None ->               
+               m2.(mem_concrete) = PTree.set b addr m1.(mem_concrete))
+    (PREVADDR: forall previous_addr, m1.(mem_concrete)!b = Some previous_addr ->
+                            previous_addr = addr /\ m1.(mem_concrete) = m2.(mem_concrete)):
+  capture m1 b addr m2.
+
+Inductive capture_list (m1:mem) : list block -> list Z -> mem -> Prop :=
+| capture_list_nil :
+  capture_list m1 [] [] m1
+| capture_list_cons
+   b addr m2 bs addrs m3
+   (CAP: capture m1 b addr m2)
+   (CAPLIST: capture_list m2 bs addrs m3) :
+  capture_list m1 (b::bs) (addr::addrs) m3.
+
+Definition valid_block_list (m: mem) (bs: list block) : Prop := Forall (valid_block m) bs. 
+
+Lemma capture_concrete m1 b addr m2
+    (CAPTURED: capture m1 b addr m2) :
+  <<CONC: m2.(mem_concrete)!b = Some addr>>.
+Proof.
+  inv CAPTURED.
+  destruct (m1.(mem_concrete)!b) eqn:CONC1.
+  { exploit PREVADDR; eauto. ii. des; subst. rewrite <- H0. eauto. }
+  rewrite CAPTURED0; eauto. rewrite PTree.gss; eauto.
+Qed.  
+
+Lemma capture_list_prevaddr m1 b addr bl addrl m2
+    (PREVADDR: m1.(mem_concrete) ! b = Some addr)
+    (CAPTURED: capture_list m1 bl addrl m2) :
+  m2.(mem_concrete) ! b = Some addr.
+Proof.
+  ginduction bl; ss; i. inv CAPTURED; eauto.
+  inv CAPTURED; eauto. eapply IHbl; try eapply CAPLIST; eauto.
+  inv CAP; eauto.
+  destruct ((mem_concrete m1) ! a) eqn:CAP.
+  - exploit PREVADDR0; eauto. i. des. rewrite <- H0; eauto.
+  - destruct (peq b a); subst; eauto; clarify.
+    erewrite CAPTURED; eauto. erewrite PTree.gso; eauto.
+Qed.
+
+Lemma capture_list_concrete m1 bl addrl m2
+    (CAPTURED: capture_list m1 bl addrl m2) :
+  forall b, In b bl -> exists addr, m2.(mem_concrete)!b = Some addr /\ In addr addrl.
+Proof.
+  ginduction bl; ss; i.
+  inv CAPTURED. exploit capture_concrete; eauto. i. des; subst.
+  - exists addr. ss. split; auto. eapply capture_list_prevaddr; eauto.
+  - exploit IHbl; eauto. i. des. esplits; eauto. ss. auto.
+Qed.  
+
+Lemma capture_list_nextblock m1 bl addrs m2
+    (CAP : Mem.capture_list m1 bl addrs m2):
+  (nextblock m1) = (nextblock m2).
+Proof.
+  ginduction bl; ss; i; [inv CAP; eauto|].
+  inv CAP. exploit IHbl; eauto. i. erewrite <- H. inv CAP0; eauto.
+Qed.
+
+Definition capture_oom (m:mem) (b:block) : Prop :=
+  valid_block m b /\ (forall addr m', ~ capture m b addr m').
+
+Definition ptr2int (b:block) (o:Z) (m:mem): option Z :=
+  match m.(mem_concrete) ! b with
+  | None => None
+  | Some caddr => Some (Z.add caddr o)
+  end.
+
+Definition ptr2int_v (ptr: val) (m: mem): option val :=
+  match ptr with
+  | Vptr b ofs => match ptr2int b (Ptrofs.unsigned ofs) m with
+                 | Some z => Some (if Archi.ptr64 then Vlong (Int64.repr z) else Vint (Int.repr z))
+                 | _ => None
+                 end
+  | _ => None
+  end.
+
+Lemma ptr2int_weak_valid_aux b ofs m addr
+    (PTR2INT: ptr2int b ofs m = Some addr)
+    (WVLD: _weak_valid_pointer (mem_access m) b ofs Max)
+    (RANGE: 0 <= ofs <= Ptrofs.max_unsigned) :
+  exists caddr, <<INRANGE: in_range addr (1, Ptrofs.modulus)>>
+         /\ <<CONC: (mem_concrete m) ! b = Some caddr>>
+         /\ <<OFS: addr = caddr + ofs>>.
+Proof.
+  unfold ptr2int in PTR2INT. des_ifs. esplits; eauto.
+  eapply weak_valid_address_range; eauto.
+  unfold Ptrofs.max_unsigned in RANGE. lia.
+Qed.
+
+Lemma ptr2int_weak_valid b ofs m addr
+    (PTR2INT: ptr2int b ofs m = Some addr)
+    (WVLD: weak_valid_pointer m b ofs = true)
+    (RANGE: 0 <= ofs <= Ptrofs.max_unsigned) :
+  in_range addr (1, Ptrofs.modulus).
+Proof.
+  eapply weak_valid_pointer_weak_valid' in WVLD.
+  unfold ptr2int in PTR2INT. des_ifs.
+  eapply weak_valid_address_range; eauto.
+  unfold Ptrofs.max_unsigned in RANGE. lia.
+Qed.
+
+Lemma ptr2int_weak_valid' b ofs m addr
+    (PTR2INT: ptr2int b ofs m = Some addr)
+    (WVLD: weak_valid_pointer m b ofs = true)
+    (RANGE: 0 <= ofs <= Ptrofs.max_unsigned) :
+  exists caddr, <<INRANGE: in_range addr (1, Ptrofs.modulus)>>
+         /\ <<CONC: (mem_concrete m) ! b = Some caddr>>
+         /\ <<OFS: addr = caddr + ofs>>.
+Proof.
+  eapply weak_valid_pointer_weak_valid' in WVLD.
+  eapply ptr2int_weak_valid_aux; eauto.
+Qed.
+
+Lemma ptr2int_not_nullptr32 z m b ofs
+    (BIT: Archi.ptr64 = false)
+    (PTR2INT: ptr2int b ofs m = Some z)
+    (WVLD: weak_valid_pointer m b ofs = true)
+    (RANGE: 0 <= ofs <= Ptrofs.max_unsigned) :
+  <<NOTNULL: Int.eq (Int.repr z) Int.zero = false>>.
+Proof.
+  exploit ptr2int_weak_valid'; eauto. i. des. subst. inv INRANGE. simpl in *.
+  eapply Ptrofs.modulus_eq32 in BIT. unfold Ptrofs.max_unsigned in *. rewrite BIT in *.
+  unfold Int.eq. rewrite Int.unsigned_repr; [|unfold Int.max_unsigned; lia].
+  rewrite Int.unsigned_zero. des_ifs; lia.
+Qed.
+
+Lemma ptr2int_not_nullptr64 z m b ofs
+    (BIT: Archi.ptr64 = true)
+    (PTR2INT: ptr2int b ofs m = Some z)
+    (WVLD: weak_valid_pointer m b ofs = true)
+    (RANGE: 0 <= ofs <= Ptrofs.max_unsigned) :
+  <<NOTNULL: Int64.eq (Int64.repr z) Int64.zero = false>>.
+Proof.
+  exploit ptr2int_weak_valid'; eauto. i. des. subst. inv INRANGE. simpl in *.
+  eapply Ptrofs.modulus_eq64 in BIT. unfold Ptrofs.max_unsigned in *. rewrite BIT in *.
+  unfold Int64.eq. rewrite Int64.unsigned_repr; [|unfold Int64.max_unsigned; lia].
+  rewrite Int64.unsigned_zero. des_ifs; lia.
+Qed.
+
+Lemma ptr2int_not_nullptr64_max z m b ofs
+    (BIT: Archi.ptr64 = true)
+    (PTR2INT: ptr2int b ofs m = Some z)
+    (WVLD: _weak_valid_pointer (mem_access m) b ofs Max)
+    (RANGE: 0 <= ofs <= Ptrofs.max_unsigned) :
+  <<NOTNULL: Int64.eq (Int64.repr z) Int64.zero = false>>.
+Proof.
+  exploit ptr2int_weak_valid_aux; eauto. i. des. subst. inv INRANGE. simpl in *.
+  eapply Ptrofs.modulus_eq64 in BIT. unfold Ptrofs.max_unsigned in *. rewrite BIT in *.
+  unfold Int64.eq. rewrite Int64.unsigned_repr; [|unfold Int64.max_unsigned; lia].
+  rewrite Int64.unsigned_zero. des_ifs; lia.
+Qed.
+
+(** reverse function of capture for int to ptr casting *)
+
+Definition denormalize_aux :=
+  fun i m b =>
+    match m.(mem_concrete) ! b with
+    | Some caddr => if ((is_valid m b) && (addr_is_in_block m.(mem_concrete) m.(mem_access) i b))
+                   then Some (b, Z.sub i caddr) else None
+    | _ => None
+    end.
+
+Definition denormalize (i: Z) (m:mem): option (block * Z) :=
+  PTree.select (fun b _ => denormalize_aux i m b) m.(mem_concrete).
+
+Definition to_valid (v: val) (m:mem) : option val :=
+  match v with
+  | Vint n => if negb Archi.ptr64
+             then (match denormalize (Int.unsigned n) m with
+                   | Some (b, ofs) => Some (Vptr b (Ptrofs.repr ofs))
+                   | _ => None
+                   end)
+             else None
+  | Vlong n => if Archi.ptr64
+              then (match denormalize (Int64.unsigned n) m with
+                    | Some (b, ofs) => Some (Vptr b (Ptrofs.repr ofs))
+                    | _ => None
+                    end)
+              else None
+  | _ => None
+  end.
+
+Definition to_int (v: val) (m: mem) : option val :=
+  match v with
+  | Vptr b ofs => ptr2int_v (Vptr b ofs) m
+  | Vint n => Some (Vint n) (* Vtrue, Vfalse always "Vint" *) (* if negb Archi.ptr64 then Some (Vint n) else None *)
+  | Vlong n => Some (Vlong n) (* if Archi.ptr64 then Some (Vlong n) else None *)
+  | _ => None
+  end.
+
+Definition denormalize_to_val (z: Z) (m: mem) : option val :=
+  match denormalize z m with
+  | Some (b, ofs) => Some (Vptr b (Ptrofs.repr ofs))
+  | _ => None
+  end.
+
+Definition to_ptr (v: val) (m: mem) : option val :=
+  match v with
+  | Vptr b ofs => Some (Vptr b ofs)
+  | Vint n => if negb Archi.ptr64
+             then (if (Int.eq n Int.zero)
+                   then Some Vnullptr
+                   else (match denormalize (Int.unsigned n) m with
+                         | Some (b, ofs) => Some (Vptr b (Ptrofs.repr ofs))
+                         | _ => None
+                         end))
+             else None
+  | Vlong n => if Archi.ptr64
+              then (if (Int64.eq n Int64.zero)
+                    then Some Vnullptr
+                    else (match denormalize (Int64.unsigned n) m with
+                          | Some (b, ofs) => Some (Vptr b (Ptrofs.repr ofs))
+                          | _ => None
+                          end))
+             else None
+  | _ => None
+  end.
+
+Lemma denormalize_in_range z m b ofs
+    (DENO: denormalize z m = Some (b, ofs)) :
+  <<INRANGE: 0 <= ofs < Ptrofs.modulus>>.
+Proof.
+  eapply PTree.gselectf in DENO. des.
+  unfold denormalize_aux in DENO0. des_ifs.
+  eapply andb_prop in Heq0. des.
+  unfold addr_is_in_block in Heq1. des_ifs. rr. lia.
+Qed.
+
+Lemma denormalize_paddr_in_range z m b ofs
+    (DENO: denormalize z m = Some (b, ofs)) :
+  <<INRANGE: in_range z (1, Ptrofs.modulus - 1)>>.
+Proof.
+  eapply PTree.gselectf in DENO. des. unfold denormalize_aux in DENO0. des_ifs.
+  eapply andb_prop in Heq0. des. rewrite <- addr_in_block_iff in Heq1.
+  exploit _valid_pointer_range; eauto.
+Qed.
+
+Lemma denormalize_not_in_range m z
+    (NOTRANGE: ~ in_range z (1, Ptrofs.modulus - 1)) :
+  <<DENOFAIL: denormalize z m = None>>.
+Proof.
+  destruct (denormalize z m) eqn: DENO; eauto.
+  exfalso. destruct p. eapply NOTRANGE. eapply denormalize_paddr_in_range; eauto.
+Qed.
+
+Lemma denormalize_nullptr m : <<DENOFAIL: denormalize 0 m = None>>.
+Proof. eapply denormalize_not_in_range; eauto. ii. inv H; ss. Qed.
+
+Lemma denormalize_perm z m b ofs
+    (DENO: denormalize z m = Some (b, ofs)) :
+  <<PERM: exists p, perm m b ofs Max p>>.
+Proof.
+  eapply PTree.gselectf in DENO. des.
+  unfold denormalize_aux in DENO0. des_ifs.
+  eapply andb_prop in Heq0. des. unfold addr_is_in_block in Heq1. des_ifs.
+  r. exists p. unfold perm, perm_order'. rewrite Heq. eapply perm_refl.
+Qed.
+
+Lemma to_ptr_nullptr m :
+  <<TOPTRFAIL: to_ptr Vnullptr m = Some Vnullptr>>.
+Proof. unfold to_ptr. des_ifs. Qed.
+
+Lemma denormalize_info z m b ofs
+  (DENO: denormalize z m = Some (b, ofs)) :
+  exists caddr, <<VBLK: valid_block m b>>
+         /\ <<CONC: (mem_concrete m)!b = Some caddr>>
+         /\ <<OFS: ofs = z - caddr>>
+         /\ <<PERM: perm m b ofs Max Nonempty>>
+         /\ <<ORANGE: 0 <= ofs <= Ptrofs.max_unsigned>>
+         /\ <<CRANGE: 1 <= z < Ptrofs.max_unsigned>>.
+Proof.
+  exploit denormalize_perm; eauto. i.
+  exploit denormalize_paddr_in_range; eauto. i.
+  exploit denormalize_in_range; eauto. i. des.
+  eapply PTree.gselectf in DENO. des.
+  unfold denormalize_aux in DENO0. des_ifs.
+  eapply andb_prop in Heq0. des. rewrite <- addr_in_block_iff in Heq1.
+  inv Heq1. des. clarify. esplits; eauto.
+  - eapply NNPP. ii. eapply nextblocks_logical in H3. clarify.
+  - unfold perm. rewrite PERM. eapply perm_any_N.
+  - unfold Ptrofs.max_unsigned. lia.
+  - inv H0; eauto.
+  - inv H0. unfold snd in SND. unfold Ptrofs.max_unsigned. lia.
+Qed.
+
+Lemma conditions_of_addr_in_block m b caddr addr
+    (CONC: (Mem.mem_concrete m)!b = Some caddr)
+    (PERM: Mem.perm m b (addr - caddr) Max Nonempty)
+    (RANGE: 0 <= addr - caddr <= Ptrofs.max_unsigned) :
+  <<INBLK: Mem.addr_in_block (Mem.mem_concrete m) (Mem.mem_access m) addr b>>.
+Proof.
+  unfold Ptrofs.max_unsigned in RANGE. econs; eauto; [|lia].
+  unfold Mem.perm, Mem.perm_order' in PERM. des_ifs. eauto.
+Qed.
+
+Lemma ptr2int_to_denormalize_max b ofs m z
+    (P2I: Mem.ptr2int b ofs m = Some z)
+    (RANGE: 0 <= ofs <= Ptrofs.max_unsigned)
+    (VLD: perm m b ofs Max Nonempty) :
+  <<DENO: Mem.denormalize z m = Some (b, ofs)>>.
+Proof.
+  exploit Mem.ptr2int_weak_valid_aux; eauto.
+  { unfold _weak_valid_pointer. unfold _valid_pointer, perm in *. eauto. }
+  i. des. subst.
+  destruct (Mem.denormalize (caddr + ofs) m) eqn:DENO.
+  - destruct p. eapply PTree.gselectf in DENO. i. des.
+    unfold Mem.denormalize_aux in DENO0. des_ifs.
+    eapply andb_prop in Heq0. des. rewrite <- Mem.addr_in_block_iff in Heq1.
+    assert (INBLK: Mem.addr_in_block (Mem.mem_concrete m) (Mem.mem_access m) (caddr + ofs) b).
+    { eapply conditions_of_addr_in_block; eauto;[|lia].
+      replace (caddr + ofs - caddr) with ofs by lia. eauto. }
+    assert (b0 = b) by (eapply Mem.no_concrete_overlap; eauto).
+    subst. clarify. replace (caddr + ofs - caddr) with ofs by lia. eauto.
+  - eapply PTree.gselectnf in DENO. exfalso. eapply DENO. esplits; eauto.
+    ii. unfold Mem.denormalize_aux in *. des_ifs. rewrite andb_false_iff in Heq0. des.
+    { rewrite Mem.nextblocks_logical in *; clarify. ii.
+      assert (Mem.valid_block m b); eauto. rewrite Mem.valid_block_iff_is_valid in H1. clarify. }
+    { unfold Mem.addr_is_in_block in *. des_ifs.
+      - unfold Ptrofs.max_unsigned in RANGE0. lia.
+      - replace (caddr + ofs - caddr) with ofs in Heq by lia.
+        unfold Mem.perm in VLD. rewrite Heq in VLD. ss. }
+Qed.
+
+Lemma ptr2int_to_denormalize b ofs m z
+    (P2I: ptr2int b ofs m = Some z)
+    (RANGE: 0 <= ofs <= Ptrofs.max_unsigned)
+    (VLD: valid_pointer m b ofs = true) :
+  <<DENO: denormalize z m = Some (b, ofs)>>.
+Proof.
+  rewrite valid_pointer_nonempty_perm in VLD. eapply perm_cur_max in VLD.
+  eapply ptr2int_to_denormalize_max; eauto.
+Qed.
+
+Lemma denormalized_not_nullptr32 z m b ofs
+    (BIT: Archi.ptr64 = false)
+    (DENO: denormalize z m = Some (b, ofs)) :
+  <<NOTNULL: Int.eq (Int.repr z) Int.zero = false>>.
+Proof.
+  eapply denormalize_info in DENO. des. subst.
+  eapply Ptrofs.modulus_eq32 in BIT. unfold Ptrofs.max_unsigned in *. rewrite BIT in *.
+  unfold Int.eq. rewrite Int.unsigned_repr; [|unfold Int.max_unsigned; lia].
+  des_ifs; lia.
+Qed.
+
+Lemma denormalized_not_nullptr64 z m b ofs
+  (BIT: Archi.ptr64 = true)
+  (DENO: denormalize z m = Some (b, ofs)) :
+  <<NOTNULL: Int64.eq (Int64.repr z) Int64.zero = false>>.
+Proof.
+  eapply denormalize_info in DENO. des. subst.
+  eapply Ptrofs.modulus_eq64 in BIT. unfold Ptrofs.max_unsigned in *. rewrite BIT in *.
+  unfold Int64.eq. rewrite Int64.unsigned_repr; [|unfold Int64.max_unsigned; lia].
+  des_ifs; lia.
+Qed.
+
+(* Definition bo2val (bo: block * Z) : val := *)
+(*   Vptr (fst bo) (Ptrofs.repr (snd bo)). *)
+
+(* (* val2ptr v m = [exact pointer; weak valid pointer; *) *)
+(* Definition val2ptr (v:val) (m:mem) : list val := *)
+(*   match v with *)
+(*   | Vint n => *)
+(*       if Archi.ptr64 *)
+(*       then [] *)
+(*       else map bo2val (addr2ptr (Int.intval n) m) *)
+(*   | Vlong n => *)
+(*       if Archi.ptr64 *)
+(*       then map bo2val (addr2ptr (Int64.intval n) m) *)
+(*       else [] *)
+(*   | Vptr b ofs => [(Vptr b ofs)] *)
+(*   | _ => [] *)
+(*   end *)
+(* . *)
+
+(* Lemma addr2ptr_length *)
+(*   z m pl *)
+(*   (A2P: addr2ptr z m = pl) *)
+(*   : *)
+(*   <<PLEN: (length pl <= 2)%nat>>. *)
+(* Proof. *)
+(*   unfold addr2ptr in A2P. des_ifs; rr; ss; try lia. *)
+(* Qed. *)
+
+(* Lemma val2ptr_length *)
+(*   v m pl *)
+(*   (V2P: val2ptr v m = pl) *)
+(*   : *)
+(*   <<PLEN: (length pl <= 2)%nat>>. *)
+(* Proof. *)
+(*   unfold val2ptr in V2P. des_ifs; rr; ss; try lia. *)
+(*   unfold addr2ptr. des_ifs; ss; try lia. *)
+(* Qed. *)
+
+(* Lemma addr2ptr_nullptr *)
+(*   m *)
+(*   : *)
+(*   <<NONE: addr2ptr 0 m = []>>. *)
+(* Proof. *)
+(*   unfold addr2ptr in *. des_ifs; try (rewrite denormalize_nullptr in Heq; clarify). *)
+(*   erewrite denormalize_not_in_range in Heq0; clarify. ii. inv H; ss. *)
+(* Qed. *)
+
+(* Lemma val2ptr_nullptr *)
+(*   m *)
+(*   : *)
+(*   <<NONE: val2ptr Vnullptr m = []>>. *)
+(* Proof. *)
+(*   unfold Vnullptr, val2ptr. des_ifs. destruct (addr2ptr (Int64.intval Int64.zero) m) eqn: A2P; ss. *)
+(*   replace (Int64.intval Int64.zero) with (Int64.unsigned Int64.zero) in A2P; cycle 1. *)
+(*   { unfold Int64.unsigned. ss. } *)
+(*   erewrite Int64.unsigned_zero in A2P. rewrite addr2ptr_nullptr in A2P. clarify. *)
+(* Qed. *)
+
+(* Lemma addr2ptr_valid_weak_valid *)
+(*   z m b1 ofs1 b2 ofs2 *)
+(*   (V2P: addr2ptr z m = [(b1, ofs1); (b2, ofs2)]) *)
+(*   : *)
+(*     <<VLD: valid_pointer m b1 ofs1 = true>> *)
+(*   /\ <<WVLD1: weak_valid_pointer m b2 ofs2 = true>> *)
+(*   /\ <<WVLD2: valid_pointer m b2 ofs2 = false>> *)
+(* . *)
+(* Proof. *)
+(*   unfold addr2ptr in *. des_ifs. *)
+(*   eapply PTree.gselectf in Heq, Heq0. des. *)
+(*   unfold denormalize_aux in *. des_ifs. *)
+(*   eapply andb_prop in Heq, Heq0. des. *)
+(*   replace (z - 1 - a + 1) with (z - a) by lia. *)
+(*   esplits. *)
+(*   { unfold addr_is_in_block in Heq5. des_ifs. *)
+(*     rewrite valid_pointer_nonempty_perm. *)
+(*     unfold perm, perm_order'. *)
+(*     rewrite Heq2. eapply perm_any_N. } *)
+(*   { rewrite weak_valid_pointer_spec. *)
+(*     right. unfold addr_is_in_block in Heq3. des_ifs. *)
+(*     replace (z - a - 1) with (z - 1 - a) by lia. *)
+(*     rewrite valid_pointer_nonempty_perm.  *)
+(*     unfold perm, perm_order'. des_ifs. *)
+(*     eapply perm_any_N. } *)
+(*   { destruct (valid_pointer m b2 (z - a)) eqn:VLD; eauto. *)
+(*     rewrite valid_pointer_nonempty_perm in VLD. *)
+(*     exfalso. *)
+(*     unfold perm, perm_order' in VLD. des_ifs. *)
+(*     assert (INBLK:addr_in_block (mem_concrete m) (mem_access m) z b2). *)
+(*     { econs; eauto. unfold in_rangeb in Heq1. ss. des_ifs. lia. } *)
+(*     rewrite <- addr_in_block_iff in Heq5. *)
+(*     exploit no_concrete_overlap. *)
+(*     { eapply Heq5. } *)
+(*     { eapply INBLK. } *)
+(*     ii. clarify. } *)
+(* Qed. *)
+
+(* Lemma val2ptr_valid_weak_valid *)
+(*   v m b1 ofs1 b2 ofs2 *)
+(*   (V2P: val2ptr v m = [Vptr b1 ofs1; Vptr b2 ofs2]) *)
+(*   : *)
+(*     <<VLD: valid_pointer m b1 (Ptrofs.unsigned ofs1) = true>> *)
+(*   /\ <<WVLD1: weak_valid_pointer m b2 (Ptrofs.unsigned ofs2) = true>> *)
+(*   /\ <<WVLD2: valid_pointer m b2 (Ptrofs.unsigned ofs2) = false>> *)
+(* . *)
+(* Proof. *)
+(*   destruct v; ss. des_ifs. *)
+(*   remember (addr2ptr (Int64.intval i) m) as pl. symmetry in Heqpl. *)
+(*   do 3 (destruct pl; ss). destruct p; destruct p0. clarify. *)
+(*   exploit addr2ptr_valid_weak_valid; eauto. *)
+(*   unfold addr2ptr in *. des_ifs. ii. des. *)
+(*   eapply denormalize_in_range in Heq0. unfold in_rangeb in *. ss. des_ifs. des. *)
+(*   esplits; rewrite Ptrofs.unsigned_repr; eauto; unfold max_address, Ptrofs.max_unsigned in *; lia. *)
+(* Qed. *)
+
+(* Lemma addr2ptr_permission *)
+(*   z m b1 ofs1 b2 ofs2 *)
+(*   (V2P: addr2ptr z m = [(b1, ofs1); (b2, ofs2)]) *)
+(*   : *)
+(*     <<PERMVLD: Mem.perm m b1 ofs1 Cur Nonempty>> *)
+(*   /\ <<PERMWVLD: ~ Mem.perm m b2 ofs2 Cur Nonempty>>. *)
+(* Proof. *)
+(*   exploit (addr2ptr_valid_weak_valid z m b1 ofs1 b2 ofs2); eauto. *)
+(*   i. des. esplits. *)
+(*   { rewrite <- valid_pointer_nonempty_perm. eauto. } *)
+(*   { ii. rewrite <- valid_pointer_nonempty_perm in H. clarify. } *)
+(* Qed. *)
+
+(* Lemma val2ptr_permission *)
+(*   v m b1 ofs1 b2 ofs2 *)
+(*   (V2P: val2ptr v m = [Vptr b1 ofs1; Vptr b2 ofs2]) *)
+(*   : *)
+(*     <<PERMVLD: Mem.perm m b1 (Ptrofs.unsigned ofs1) Cur Nonempty>> *)
+(*   /\ <<PERMWVLD: ~ Mem.perm m b2 (Ptrofs.unsigned ofs2) Cur Nonempty>>. *)
+(* Proof. *)
+(*   exploit (val2ptr_valid_weak_valid v m b1 ofs1 b2 ofs2); eauto. *)
+(*   i. des. esplits. *)
+(*   { rewrite <- valid_pointer_nonempty_perm. eauto. } *)
+(*   { ii. rewrite <- valid_pointer_nonempty_perm in H. clarify. } *)
+(* Qed. *)
+
+(* Lemma val2ptr_permission_valid *)
+(*   v m b ofs *)
+(*   (V2P: In (Vptr b ofs) (val2ptr v m)) *)
+(*   (PERM: perm m b (Ptrofs.unsigned ofs) Cur Nonempty) *)
+(*   : *)
+(*   exists pl, <<V2P: val2ptr v m = (Vptr b ofs)::pl>> *)
+(* . *)
+(* Proof. *)
+(*   destruct (Mem.val2ptr v m) eqn:V2P'; ss. *)
+(*   destruct l; ss. *)
+(*   { des; clarify. esplits; eauto. } *)
+(*   destruct l; ss. *)
+(*   2:{ eapply Mem.val2ptr_length in V2P'. inv V2P'. inv H0. inv H1. } *)
+(*   des; clarify. *)
+(*   { esplits; eauto. } *)
+(*   assert (exists b0 ofs0, v0 = Vptr b0 ofs0). *)
+(*   { unfold val2ptr, addr2ptr, bo2val in *; des_ifs; ss. clarify. eauto. } *)
+(*   des; subst. eapply val2ptr_permission in V2P'. des; clarify. *)
+(* Qed. *)
+
+(* Lemma addr2ptr_different_block *)
+(*   z m b1 ofs1 b2 ofs2 *)
+(*   (V2P: addr2ptr z m = [(b1, ofs1); (b2, ofs2)]) *)
+(*   : *)
+(*   <<DFFBLK: b1 <> b2>> *)
+(* . *)
+(* Proof. unfold addr2ptr in V2P. des_ifs. Qed. *)
+
+(* Lemma val2ptr_different_block *)
+(*   z m b1 ofs1 b2 ofs2 *)
+(*   (V2P: val2ptr z m = [Vptr b1 ofs1; Vptr b2 ofs2]) *)
+(*   : *)
+(*   <<DFFBLK: b1 <> b2>> *)
+(* . *)
+(* Proof. unfold val2ptr, addr2ptr, bo2val in V2P. des_ifs; ss. clarify. Qed. *)
+
+Lemma Z_sub_reg_r (a b c:Z)
+    (SUB: a - c = b - c) : a = b.
+Proof.
+  do 2 rewrite <- Z.add_opp_r in SUB.
+  rewrite Z.add_comm in SUB. rewrite (Z.add_comm b) in SUB.
+  eapply Z.add_reg_l; eauto.
+Qed.
+
+(* Lemma denormalize_same_addr *)
+(*   i1 i2 m b o *)
+(*   (DENO1: denormalize i1 m = Some (b, o)) *)
+(*   (DENO2: denormalize i2 m = Some (b, o)) : *)
+(*   <<SAMEADD: i1 = i2>>. *)
+(* Proof. *)
+(*   eapply PTree.gselectf in DENO1, DENO2. *)
+(*   des. unfold denormalize_aux in *. des_ifs. *)
+(*   eapply Z_sub_reg_r; eauto. *)
+(* Qed. *)
+  
+(* Lemma addr2ptr_same_addr *)
+(*   i1 i2 m pl *)
+(*   (A2P1: addr2ptr i1 m = pl) *)
+(*   (A2P2: addr2ptr i2 m = pl) *)
+(*   (LEN: Zlength pl >= 1) *)
+(*   : *)
+(*   <<SAMEADD: i1 = i2>>. *)
+(* Proof. *)
+(*   dup A2P1. dup A2P2. *)
+(*   unfold addr2ptr in A2P1, A2P2. *)
+(*   des_ifs; (try (by (eapply denormalize_same_addr; eauto))). *)
+(*   { eapply PTree.gselectf in Heq, Heq2. *)
+(*     des. unfold denormalize_aux in *. des_ifs. *)
+(*     eapply andb_prop in Heq2, Heq. des. *)
+(*     replace (i1 - 1 - a0 + 1) with (i1 - a0) in H0 by lia. *)
+(*     eapply Z_sub_reg_r; eauto. } *)
+(*   { eapply PTree.gselectnf in Heq2. *)
+(*     assert (~ perm m b1 (z1 + 1) Cur Nonempty). *)
+(*     { clear - Heq2 Heq3 Heq4. *)
+(*       ii. eapply PTree.gselectf in Heq3. des. *)
+(*       eapply Heq2. esplits; eauto. ii. *)
+(*       clear Heq2. *)
+(*       unfold denormalize_aux in *. des_ifs. *)
+(*       eapply andb_prop in Heq2. des. *)
+(*       rewrite andb_false_iff in Heq1. des; clarify. *)
+(*       replace (i1 - 1 - a + 1) with (i1 - a) in Heq4, H by lia. *)
+(*       unfold addr_is_in_block in Heq1. des_ifs. *)
+(*       { unfold in_rangeb in Heq4. des_ifs. ss. lia. } *)
+(*       unfold perm, perm_order' in H. rewrite Heq in H. clarify. } *)
+(*     exfalso. eapply H. eapply denormalize_perm in Heq. des. *)
+(*     eapply perm_implies; eauto. eapply perm_any_N. } *)
+(*   { eapply PTree.gselectf in Heq, Heq2. *)
+(*     des. unfold denormalize_aux in *. des_ifs. *)
+(*     eapply andb_prop in Heq2, Heq. des. *)
+(*     replace (i1 - 1 - a0 + 1) with (i1 - a0) in H0 by lia. *)
+(*     eapply Z_sub_reg_r; eauto. } *)
+(*   { eapply PTree.gselectnf in Heq. *)
+(*     assert (~ perm m b1 (z + 1) Cur Nonempty). *)
+(*     { clear - Heq Heq0 Heq1. *)
+(*       ii. eapply PTree.gselectf in Heq0. des. *)
+(*       eapply Heq. esplits; eauto. ii. *)
+(*       clear Heq. *)
+(*       unfold denormalize_aux in *. des_ifs. *)
+(*       eapply andb_prop in Heq3. des. *)
+(*       rewrite andb_false_iff in Heq0. des; clarify. *)
+(*       replace (i2 - 1 - a + 1) with (i2 - a) in Heq1, H by lia. *)
+(*       unfold addr_is_in_block in Heq0. des_ifs. *)
+(*       { unfold in_rangeb in Heq1. des_ifs. ss. lia. } *)
+(*       unfold perm, perm_order' in H. rewrite Heq in H. clarify. } *)
+(*     exfalso. eapply H. eapply denormalize_perm in Heq2. des. *)
+(*     eapply perm_implies; eauto. eapply perm_any_N. } *)
+(*   { eapply PTree.gselectf in Heq2, Heq3, Heq0. *)
+(*     des. unfold denormalize_aux in *. des_ifs. *)
+(*     eapply andb_prop in Heq2, Heq3, Heq0. des. *)
+(*     replace (i2 - 1 - a1 + 1) with (i2 - a1) in H0 by lia. *)
+(*     eapply Z_sub_reg_r; eauto. } *)
+(*   { eapply PTree.gselectf in Heq2, Heq0. *)
+(*     des. unfold denormalize_aux in *. des_ifs. *)
+(*     eapply andb_prop in Heq2, Heq0. des. *)
+(*     replace (i2 - 1 - a0 + 1) with (i2 - a0) in H0 by lia. *)
+(*     eapply Z_sub_reg_r; eauto. } *)
+(*   { assert (z = z0) by lia. *)
+(*     subst. eapply (Z_sub_reg_r _ _ 1) . *)
+(*     eapply denormalize_same_addr; eauto. } *)
+(* Qed. *)
+
+(* Definition ptr2val (ptr: block * ptrofs) : val := Vptr (fst ptr) (snd ptr). *)
 
 (** Freeing a block between the given bounds.
   Return the updated memory state where the given range of the given block
@@ -396,7 +1372,9 @@ Program Definition unchecked_free (m: mem) (b: block) (lo hi: Z): mem :=
         (PMap.set b
                 (fun ofs k => if zle lo ofs && zlt ofs hi then None else m.(mem_access)#b ofs k)
                 m.(mem_access))
-        m.(nextblock) _ _ _.
+        m.(mem_concrete)
+        m.(nextblock)
+        _ _ _ _ _ _ _ _.
 Next Obligation.
   repeat rewrite PMap.gsspec. destruct (peq b0 b).
   destruct (zle lo ofs && zlt ofs hi). red; auto. apply access_max.
@@ -410,6 +1388,47 @@ Qed.
 Next Obligation.
   apply contents_default.
 Qed.
+Next Obligation.
+  apply m.(nextblocks_logical). exact H.
+Qed.
+Next Obligation.
+  eapply m.(valid_address_bounded).
+  inversion IN_BLOCK.
+  econs.
+  exact CONCRETE.
+  destruct (Pos.eq_dec bo b).
+  - rewrite e in *. rewrite PMap.gss in PERM.
+    destruct PERM as [perm PERM]. simpl in PERM.
+    destruct (zle lo (addr - caddr) && zlt (addr - caddr) hi); try inversion PERM. exists perm. simpl. exact H0.
+  - rewrite PMap.gso in PERM. exact PERM. exact n.
+  - eauto.
+Qed.
+Next Obligation.
+  unfold uniqueness in *. intros b1 b2 B1 B2.
+  apply access_le_no_overlap with (acc2:=m.(mem_access)) (concrete:=m.(mem_concrete)) (addr:=addr) (acc1:=(PMap.set b (fun (ofs : Z) (k : perm_kind) => if zle lo ofs && zlt ofs hi then None else (mem_access m) # b ofs k) (mem_access m))).
+  - unfold access_le. intros.
+    destruct (Pos.eq_dec b0 b).
+    + rewrite e in *. rewrite PMap.gss.
+      destruct(zle lo off && zlt off hi); try reflexivity; try exact M2_NONE.
+    + rewrite PMap.gso; try exact n; try exact M2_NONE.
+  - apply m.(no_concrete_overlap).
+  - exact B1. - exact B2.
+Qed.
+Next Obligation.
+  eapply concrete_align; eauto. ii.
+  exploit RPERM; eauto. ii. des.
+  destruct (peq b b0); subst.
+  - rewrite PMap.gss in H0; eauto.
+    des_ifs; clarify; eauto.
+  - rewrite PMap.gso in H0; eauto.
+Qed.
+Next Obligation.
+  eapply weak_valid_address_range; eauto.
+  destruct (Pos.eq_dec b0 b); subst; unfold _weak_valid_pointer, _valid_pointer in *.
+  2: { rewrite PMap.gso in WVLD; eauto. }
+  subst. rewrite PMap.gss in WVLD; eauto.
+  des_ifs; des; clarify; eauto.
+Qed.
 
 Definition free (m: mem) (b: block) (lo hi: Z): option mem :=
   if range_perm_dec m b lo hi Cur Freeable
@@ -436,6 +1455,231 @@ Fixpoint getN (n: nat) (p: Z) (c: ZMap.t memval) {struct n}: list memval :=
   | S n' => ZMap.get p c :: getN n' (p + 1) c
   end.
 
+Definition val2chunk (v:val): memory_chunk :=
+  match v with
+  | Vint _ => Mint32
+  | Vlong _ => Mint64
+  | Vptr _ _ => Mptr
+  | _ => if Archi.ptr64 then Many64 else Many32
+  end.
+
+Definition _decode_normalize_mv := fun m mv => match mv with
+                                             | Fragment v q n =>
+                                                 match (Mem.to_int v m) with
+                                                 | Some v' =>
+                                                     match (nth_error (rev_if_be_mv (encode_val (val2chunk v') v')) n) with
+                                                     | Some b => b
+                                                     | None => mv
+                                                     end
+                                                 | None => mv
+                                                 end
+                                             | _ => mv
+                                             end.
+
+Definition is_intptr_mv (mv:memval) : bool :=
+  match mv with
+  | Fragment v q n =>
+      match v with
+      | Vint _ => negb Archi.ptr64 && quantity_eq q Q32 (* && Nat.ltb n 4 *)
+      | Vlong _ => Archi.ptr64 && quantity_eq q Q64 (* && Nat.ltb n 8 *)
+      | _ => false
+      end
+  | _ => false
+  end.
+
+Definition qarchi := if Archi.ptr64 then Q64 else Q32.
+
+Definition is_ptrlike_mv (mv: memval) : bool :=
+  is_intptr_mv mv || is_ptr_mv mv || is_byte_mv mv.
+
+Definition is_mixed_mvs (mvs: list memval) : bool :=
+  forallb is_ptrlike_mv mvs && (negb (forallb is_ptr_mv mvs)).
+
+Definition is_mixed_mvs_old (mvs: list memval) : bool :=
+  forallb is_ptrlike_mv mvs && (negb (forallb is_byte_mv mvs)) && (negb (forallb is_ptr_mv mvs)) && (negb (forallb is_intptr_mv mvs)).
+
+Lemma inj_bytes_all_bytes bl (LEN: (Datatypes.length bl > 0)%nat):
+  <<NOFRAG: forallb is_byte_mv (inj_bytes bl) = true>>.
+Proof. destruct bl; ss. ginduction bl; ss. i. eapply IHbl; eauto. ss. lia. Qed.
+
+(* merge *)
+Lemma inj_bytes_all_bytes' bl:
+  <<NOFRAG: forallb is_byte_mv (inj_bytes bl) = true>>.
+Proof. destruct bl; ss. ginduction bl; ss. Qed.
+
+Lemma inj_bytes_no_fragment v q n bl (LEN: (Datatypes.length bl > 0)%nat):
+  <<NOFRAG: ~ In (Fragment v q n) (inj_bytes bl)>>.
+Proof.
+  ii. exploit inj_bytes_all_bytes; eauto. i. des. rewrite forallb_forall in H0.
+  eapply H0 in H. ss.
+Qed.
+
+Lemma inj_bytes_no_fragment' v q n bl:
+  <<NOFRAG: ~ In (Fragment v q n) (inj_bytes bl)>>.
+Proof.
+  ii. exploit inj_bytes_all_bytes'; eauto. i. des. rewrite forallb_forall in H0.
+  eapply H0 in H. ss.
+Qed.
+
+Definition normalize_check (chunk: memory_chunk) (mvs: list memval) : bool :=
+  match chunk with
+  | Mint64 | Many64 => Archi.ptr64 && (is_mixed_mvs mvs)
+  | Mint32 | Many32 => (negb Archi.ptr64) && (is_mixed_mvs mvs)
+  | _ => false
+  end.
+  
+
+Definition normalize_mvs (chunk: memory_chunk) (m: mem) (mvs: list memval) : (list memval) :=
+  if (normalize_check chunk mvs) then map (_decode_normalize_mv m) mvs else mvs.
+
+Lemma normalize_mvs_not_ptr
+  chunk m bytes (NOTP: chunk <> Mptr) (NOANY: chunk <> Many64) :
+  <<EQ: normalize_mvs chunk m bytes = bytes>>.
+Proof. unfold normalize_mvs, normalize_check. des_ifs. Qed.
+
+Definition change_check (chunk: memory_chunk) (mvs: list memval) : bool :=
+  normalize_check chunk mvs && (negb (forallb is_byte_mv mvs)) && match proj_value qarchi mvs with
+                                                                  | Vundef => negb (undef_in_bytes mvs)
+                                                                  | _ => false
+                                                                  end.
+
+Lemma intptr_normalize_mvs_same_aux
+  mv (NPTR: is_intptr_mv mv = true):
+  forall m1 m2, _decode_normalize_mv m1 mv = _decode_normalize_mv m2 mv.
+Proof. i. destruct mv; ss. des_ifs; ss; clarify. Qed.
+
+Lemma intptr_normalize_mvs_same_aux2
+  mvs (NPTR: forallb is_intptr_mv mvs = true):
+  forall m1 m2, map (_decode_normalize_mv m1) mvs = map (_decode_normalize_mv m2) mvs.
+Proof.
+  i. ginduction mvs; ss. i. eapply andb_prop in NPTR. des.
+  erewrite (IHmvs _ m1 m2); eauto. erewrite intptr_normalize_mvs_same_aux; eauto.
+  Unshelve. eauto.
+Qed.
+
+Lemma intptr_normalize_mvs_same
+  mvs (NPTR: forallb is_intptr_mv mvs = true):
+  forall chunk m1 m2, normalize_mvs chunk m1 mvs = normalize_mvs chunk m2 mvs.
+Proof.
+  i. unfold normalize_mvs, normalize_check. des_ifs_safe.
+  eapply intptr_normalize_mvs_same_aux2; eauto.
+Qed.
+
+(* i think not all undef, in undef is also unchange *)
+Lemma bytes_all_undef_not_change l chunk
+    (LEN: l <> [])
+    (UNDEFS: bytes_all_undef l = true):
+  Mem.change_check chunk l = false.
+Proof.
+  destruct chunk; ss.
+  - unfold change_check. repeat erewrite andb_false_iff. left. left.
+    ss. unfold is_mixed_mvs. destruct Archi.ptr64; ss. erewrite andb_false_iff. left.
+    destruct l; ss. eapply andb_prop in UNDEFS. des. ginduction l; ss; i.
+    + destruct m; ss.
+    + eapply andb_prop in UNDEFS0. des. destruct m; ss.
+  - unfold change_check. repeat erewrite andb_false_iff. left. left.
+    ss. unfold is_mixed_mvs. destruct Archi.ptr64; ss. erewrite andb_false_iff. left.
+    destruct l; ss. eapply andb_prop in UNDEFS. des. ginduction l; ss; i.
+    + destruct m; ss.
+    + eapply andb_prop in UNDEFS0. des. destruct m; ss.
+Qed.
+
+Lemma undef_in_bytes_not_change l chunk
+    (LEN: l <> [])
+    (UNDEFS: undef_in_bytes l = true):
+  Mem.change_check chunk l = false.
+Proof.
+  destruct chunk; ss.
+  - unfold change_check. repeat erewrite andb_false_iff. left. left.
+    ss. unfold is_mixed_mvs. destruct Archi.ptr64; ss. erewrite andb_false_iff. left.
+    unfold undef_in_bytes in UNDEFS. erewrite existsb_exists in UNDEFS. des.
+    erewrite forallb_false_forall. ii. exploit H; eauto. i. destruct x; ss.
+  - unfold change_check. repeat erewrite andb_false_iff. left. left.
+    ss. unfold is_mixed_mvs. destruct Archi.ptr64; ss. erewrite andb_false_iff. left.
+    unfold undef_in_bytes in UNDEFS. erewrite existsb_exists in UNDEFS. des.
+    erewrite forallb_false_forall. ii. exploit H; eauto. i. destruct x; ss.
+Qed.
+
+Lemma _decode_normalize_mv_byte m b:
+  <<EQ: _decode_normalize_mv m (Byte b) = Byte b>>.
+Proof. ss. Qed.
+
+Lemma _decode_normalize_mv_byte_map
+  m bytes (BYTES: forallb is_byte_mv bytes = true):
+  <<EQ: map (_decode_normalize_mv m) bytes = bytes>>.
+Proof.
+  ginduction bytes; ss; ii. des_ifs. destruct a; ss. r. decEq. eapply IHbytes; eauto.
+Qed.
+
+Lemma bytes_mixed bytes (LEN: (Datatypes.length bytes > 0)%nat)
+  (BYTES: forallb is_byte_mv bytes = true):
+  <<MIXED: is_mixed_mvs bytes = true>>.
+Proof.
+  unfold is_mixed_mvs. r. rewrite andb_true_iff. split.
+  { rewrite forallb_forall in *. ii. eapply BYTES in H. unfold is_ptrlike_mv. destruct x; ss. }
+  rewrite negb_true_iff. rewrite forallb_false_forall. ii. rewrite forallb_forall in BYTES.
+  destruct bytes; ss; [lia|]. exploit H; eauto. i. exploit BYTES; eauto. i. destruct m; ss.
+Qed.
+
+Lemma normalize_mvs_pure
+  chunk m bytes (PURE: is_mixed_mvs bytes = false \/ forallb is_byte_mv bytes = true) :
+  <<EQ: normalize_mvs chunk m bytes = bytes>>.
+Proof.
+  destruct bytes; ss.
+  { unfold normalize_mvs, normalize_check. ss. des_ifs. }
+  unfold normalize_mvs, normalize_check. des.
+  { rewrite PURE. des_ifs. }
+  exploit (bytes_mixed (m0::bytes)); eauto; [ss; lia|]. i.
+  rewrite H. rewrite _decode_normalize_mv_byte_map; eauto. des_ifs.
+Qed.
+
+Lemma chunk_normalize_mvs
+  chunk m bytes (CHUNK: ~(chunk = Mint64 \/ chunk = Mint32 \/ chunk = Many64 \/ chunk = Many32)):
+  <<EQ: normalize_mvs chunk m bytes = bytes>>.
+Proof. unfold normalize_mvs. destruct chunk; ss; exfalso; eapply CHUNK; eauto. Qed.
+
+Lemma chunk_normalize_mvs64
+  chunk m bytes (SF: Archi.ptr64 = true) (CHUNK: ~(chunk = Mint64 \/ chunk = Many64)):
+  <<EQ: normalize_mvs chunk m bytes = bytes>>.
+Proof. unfold normalize_mvs. destruct chunk; ss; exfalso; eapply CHUNK; eauto. Qed.
+
+Lemma _normalize_mv_same_concrete m m' byte
+    (SAME: mem_concrete m = mem_concrete m'):
+  <<EQ: _decode_normalize_mv m byte = _decode_normalize_mv m' byte>>.
+Proof.
+  unfold _decode_normalize_mv. des_ifs; unfold to_int, ptr2int_v, ptr2int in *; rewrite SAME in Heq; des_ifs.
+Qed.
+
+Lemma normalize_mvs_same_concrete m m' chunk bytes
+    (SAME: mem_concrete m = mem_concrete m'):
+  <<EQ: normalize_mvs chunk m bytes = normalize_mvs chunk m' bytes>>.
+Proof.
+  unfold normalize_mvs, normalize_check. des_ifs;
+    clear Heq; induction bytes; ss; rewrite IHbytes; erewrite _normalize_mv_same_concrete; eauto.
+Qed.
+
+Lemma inj_bytes_no_undef bl (INJBYTE: In Undef (inj_bytes bl)): <<FALSE: False>>.
+Proof. ginduction bl; ss. ii. des; clarify. eauto. Qed.
+
+Lemma encode_val_pure chunk v:
+  <<PURE: (~ In Undef (encode_val chunk v) /\ (is_mixed_mvs_old (encode_val chunk v) = false)) \/ bytes_all_undef (encode_val chunk v) = true>>.
+Proof.
+  destruct chunk, v; ss; auto; des_ifs; left; split; ss; ii; des; clarify.
+  all: try (eapply inj_bytes_no_undef; eauto).
+Qed.
+
+Lemma normalize_mvs_undef m chunk mvl:
+  <<EQ: exists mvl', normalize_mvs chunk m (Undef :: mvl) = Undef :: mvl' >>.
+Proof. unfold normalize_mvs. des_ifs; esplits; eauto; ss. Qed.
+
+Lemma encode_val_change_check_false chunk v:
+  change_check chunk (encode_val chunk v) = false.
+Proof.
+  unfold change_check. destruct chunk; destruct v; ss.
+  unfold qarchi. des_ifs_safe. unfold inj_value in Heq0.
+  erewrite check_inj_value in Heq0. clarify.
+Qed.
+
 (** [load chunk m b ofs] perform a read in memory state [m], at address
   [b] and offset [ofs].  It returns the value of the memory chunk
   at that address.  [None] is returned if the accessed bytes
@@ -443,17 +1687,19 @@ Fixpoint getN (n: nat) (p: Z) (c: ZMap.t memval) {struct n}: list memval :=
 
 Definition load (chunk: memory_chunk) (m: mem) (b: block) (ofs: Z): option val :=
   if valid_access_dec m chunk b ofs Readable
-  then Some(decode_val chunk (getN (size_chunk_nat chunk) ofs (m.(mem_contents)#b)))
+  then
+    Some (decode_val chunk (normalize_mvs chunk m (getN (size_chunk_nat chunk) ofs (m.(mem_contents)#b))))
   else None.
 
 (** [loadv chunk m addr] is similar, but the address and offset are given
   as a single value [addr], which must be a pointer value. *)
 
 Definition loadv (chunk: memory_chunk) (m: mem) (addr: val) : option val :=
-  match addr with
-  | Vptr b ofs => load chunk m b (Ptrofs.unsigned ofs)
+  match to_ptr addr m with
+  | Some (Vptr b ofs) => load chunk m b (Ptrofs.unsigned ofs)
   | _ => None
-  end.
+  end
+.
 
 (** [loadbytes m b ofs n] reads [n] consecutive bytes starting at
   location [(b, ofs)].  Returns [None] if the accessed locations are
@@ -464,6 +1710,9 @@ Definition loadbytes (m: mem) (b: block) (ofs n: Z): option (list memval) :=
   then Some (getN (Z.to_nat n) ofs (m.(mem_contents)#b))
   else None.
 
+Definition loadbytes_no_perm (m: mem) (b: block) (ofs n: Z): list memval :=
+  (getN (Z.to_nat n) ofs (m.(mem_contents)#b)).
+
 (** Memory stores. *)
 
 (** Writing N adjacent bytes in a block content. *)
@@ -550,8 +1799,9 @@ Program Definition store (chunk: memory_chunk) (m: mem) (b: block) (ofs: Z) (v:
                           (setN (encode_val chunk v) ofs (m.(mem_contents)#b))
                           m.(mem_contents))
                 m.(mem_access)
+                m.(mem_concrete)
                 m.(nextblock)
-                _ _ _)
+                _ _ _ _ _ _ _ _ )
   else
     None.
 Next Obligation. apply access_max. Qed.
@@ -561,6 +1811,28 @@ Next Obligation.
   rewrite setN_default. apply contents_default.
   apply contents_default.
 Qed.
+Next Obligation.
+  apply m.(nextblocks_logical). exact H0.
+Qed.
+Next Obligation.
+  eapply m.(valid_address_bounded).
+  inversion IN_BLOCK.
+  econs.
+  exact CONCRETE.  exact PERM. eauto.
+Qed.
+Next Obligation.
+  unfold uniqueness in *. intros b1 b2 B1 B2.
+  apply access_le_no_overlap with (acc2:=m.(mem_access)) (acc1:=m.(mem_access)) (addr:=addr) (concrete:=m.(mem_concrete)).
+  - unfold access_le. intros. exact M2_NONE.
+  - apply m.(no_concrete_overlap).
+  - exact B1. - exact B2.
+Qed.
+Next Obligation.
+  eapply concrete_align; eauto.
+Qed.
+Next Obligation.
+  eapply weak_valid_address_range; eauto.
+Qed.
 
 (** [storev chunk m addr v] is similar, but the address and offset are given
   as a single value [addr], which must be a pointer value. *)
@@ -568,6 +1840,18 @@ Qed.
 Definition storev (chunk: memory_chunk) (m: mem) (addr v: val) : option mem :=
   match addr with
   | Vptr b ofs => store chunk m b (Ptrofs.unsigned ofs) v
+  | Vint n => if negb Archi.ptr64 then 
+               (match denormalize (Int.unsigned n) m with
+                | Some (b, ofs) => store chunk m b ofs v
+                | _ => None
+                end)
+             else None
+  | Vlong n => if Archi.ptr64 then 
+                (match denormalize (Int64.unsigned n) m with
+                 | Some (b, ofs) => store chunk m b ofs v
+                 | _ => None
+                 end)
+              else None
   | _ => None
   end.
 
@@ -580,8 +1864,9 @@ Program Definition storebytes (m: mem) (b: block) (ofs: Z) (bytes: list memval)
     Some (mkmem
              (PMap.set b (setN bytes ofs (m.(mem_contents)#b)) m.(mem_contents))
              m.(mem_access)
+             m.(mem_concrete)
              m.(nextblock)
-             _ _ _)
+             _ _ _ _ _ _ _ _)
   else
     None.
 Next Obligation. apply access_max. Qed.
@@ -591,6 +1876,64 @@ Next Obligation.
   rewrite setN_default. apply contents_default.
   apply contents_default.
 Qed.
+Next Obligation.
+  apply m.(nextblocks_logical). exact H0.
+Qed.
+Next Obligation.
+  eapply m.(valid_address_bounded).
+  inversion IN_BLOCK.
+  econs; eauto.
+Qed.
+Next Obligation.
+  unfold uniqueness in *. intros b1 b2 B1 B2.
+  apply access_le_no_overlap with (acc2:=m.(mem_access)) (acc1:=m.(mem_access)) (addr:=addr) (concrete:=m.(mem_concrete)).
+  - unfold access_le. intros. exact M2_NONE.
+  - apply m.(no_concrete_overlap).
+  - exact B1. - exact B2.
+Qed.
+Next Obligation.
+  eapply concrete_align; eauto.
+Qed.
+Next Obligation.
+  eapply weak_valid_address_range; eauto.
+Qed.
+
+Program Definition storebytes_no_perm (m: mem) (b: block) (ofs: Z) (bytes: list memval) : mem :=
+  (mkmem
+     (PMap.set b (setN bytes ofs (m.(mem_contents)#b)) m.(mem_contents))
+     m.(mem_access)
+     m.(mem_concrete)
+     m.(nextblock)
+     _ _ _ _ _ _ _ _).
+Next Obligation. apply access_max. Qed.
+Next Obligation. apply nextblock_noaccess; auto. Qed.
+Next Obligation.
+  rewrite PMap.gsspec. destruct (peq b0 b).
+  rewrite setN_default. apply contents_default.
+  apply contents_default.
+Qed.
+Next Obligation.
+  apply m.(nextblocks_logical). exact H.
+Qed.
+Next Obligation.
+  eapply m.(valid_address_bounded).
+  inversion IN_BLOCK.
+  econs; eauto.
+Qed.
+Next Obligation.
+  unfold uniqueness in *. intros b1 b2 B1 B2.
+  apply access_le_no_overlap with (acc2:=m.(mem_access)) (acc1:=m.(mem_access)) (addr:=addr) (concrete:=m.(mem_concrete)).
+  - unfold access_le. intros. exact M2_NONE.
+  - apply m.(no_concrete_overlap).
+  - exact B1.
+  - exact B2.
+Qed.
+Next Obligation.
+  eapply concrete_align; eauto.
+Qed.
+Next Obligation.
+  eapply weak_valid_address_range; eauto.
+Qed.
 
 (** [drop_perm m b lo hi p] sets the max permissions of the byte range
     [(b, lo) ... (b, hi - 1)] to [p].  These bytes must have current permissions
@@ -603,7 +1946,9 @@ Program Definition drop_perm (m: mem) (b: block) (lo hi: Z) (p: permission): opt
                 (PMap.set b
                         (fun ofs k => if zle lo ofs && zlt ofs hi then Some p else m.(mem_access)#b ofs k)
                         m.(mem_access))
-                m.(nextblock) _ _ _)
+                m.(mem_concrete)
+                m.(nextblock)
+                _ _ _ _ _ _ _ _)
   else None.
 Next Obligation.
   repeat rewrite PMap.gsspec. destruct (peq b0 b). subst b0.
@@ -621,6 +1966,92 @@ Qed.
 Next Obligation.
   apply contents_default.
 Qed.
+Next Obligation.
+  apply m.(nextblocks_logical). exact H0.
+Qed.
+Next Obligation.
+  eapply m.(valid_address_bounded).
+  inversion IN_BLOCK.
+  econs; eauto.
+  destruct (Pos.eq_dec bo b).
+  - rewrite e in *. rewrite PMap.gss in PERM.
+    destruct PERM as [perm PERM].
+    unfold range_perm in H. specialize H with (addr-caddr).
+    assert (zle lo (addr - caddr) && zlt (addr - caddr) hi = true -> lo <= addr - caddr < hi).
+    {  intros. split.
+      destruct zle in H0. exact l. inversion H0.
+      destruct zlt in H0. exact l. inversion H0. apply andb_true_iff in H2. destruct H2. inversion H2. }
+    simpl in PERM. destruct (zle lo (addr - caddr) && zlt (addr - caddr) hi).
+    + assert (Mem.perm m b (addr - caddr) Cur Freeable).
+      apply H. apply H0. reflexivity.
+      exists Freeable. unfold Mem.perm in H1. unfold perm_order' in H1. simpl.
+      induction  ((mem_access m) # b (addr - caddr) Cur); inv H1.
+      { exploit H; eauto. i. eapply perm_cur_max in H1.
+        unfold Mem.perm, perm_order' in *. des_ifs; inv H1; eauto. }
+      { exploit H; eauto. i. eapply perm_cur_max in H1.
+        unfold Mem.perm, perm_order' in *. des_ifs; inv H1; eauto. }
+    + exists perm. exact PERM.
+  - rewrite PMap.gso in PERM. exact PERM. exact n.
+Qed.
+Next Obligation.
+  unfold uniqueness in *. intros b1 b2 B1 B2.
+  apply access_le_no_overlap with (acc2:=m.(mem_access)) (acc1:=(PMap.set b (fun (ofs : Z) (k : perm_kind) => if zle lo ofs && zlt ofs hi then Some p else (mem_access m)# b ofs k) m.(mem_access))) (addr:=addr) (concrete:=m.(mem_concrete)).
+  - unfold access_le. intros.
+    destruct (Pos.eq_dec b0 b).
+    + rewrite e in *. rewrite PMap.gss.
+      unfold range_perm in H. specialize H with off.
+      assert (zle lo off && zlt off hi = true -> lo <= off < hi).
+      { intros. split.
+      destruct zle in H0. exact l. inversion H0.
+      destruct zlt in H0. exact l. inversion H0. apply andb_true_iff in H2. destruct H2. inversion H2. }
+      destruct(zle lo off && zlt off hi).
+      * assert (lo <= off <hi).
+        { apply H0. reflexivity. }
+        apply H in H1. unfold perm, perm_order' in H1. des_ifs.
+        assert (perm m b off Cur Freeable).
+        { unfold perm, perm_order'. rewrite Heq. ss. }
+        eapply perm_cur_max in H2. unfold perm, perm_order' in H2. des_ifs.
+      * exact M2_NONE.
+    + rewrite PMap.gso; try exact n; try exact M2_NONE.
+  - apply m.(no_concrete_overlap).
+  - exact B1. - exact B2.
+Qed.
+Next Obligation.
+  eapply concrete_align; eauto. ii.
+  exploit RPERM; eauto. ii. des.
+  destruct (peq b b0); subst.
+  - rewrite PMap.gss in H1. des_ifs; eauto.
+    assert (lo <= o < hi).
+    { i; split.
+      destruct zle in Heq. exact l. inversion Heq.
+      destruct zlt in Heq. exact l. inversion Heq.
+      apply andb_true_iff in H4. des; clarify. }
+    eapply H in H3. eapply perm_cur_max in H3.
+    eapply perm_implies; eauto. eapply perm_any_N.
+  - rewrite PMap.gso in H1; eauto.
+Qed.
+Next Obligation.
+  unfold _weak_valid_pointer, _valid_pointer in WVLD.
+  destruct (peq b b0); subst.
+  2: { rewrite PMap.gso in WVLD; eauto.
+       eapply weak_valid_address_range; eauto. }
+  eapply weak_valid_address_range; eauto.
+  rewrite PMap.gss in WVLD; eauto.
+  unfold _weak_valid_pointer, _valid_pointer.
+  des_ifs.
+  - unfold range_perm in H. specialize (H ofs). unfold perm in H.
+    left. exploit H; eauto. eapply andb_prop in Heq. inv Heq.
+    destruct zle in H2; inv H2. destruct zlt in H3; inv H3.
+    eauto. ii. eapply perm_cur_max. eapply perm_implies; eauto. eapply perm_any_N.
+  - unfold range_perm in H. specialize (H ofs). unfold perm in H.
+    left. exploit H; eauto. eapply andb_prop in Heq. inv Heq.
+    destruct zle in H2; inv H2. destruct zlt in H3; inv H3.
+    eauto. ii.  eapply perm_cur_max. eapply perm_implies; eauto. eapply perm_any_N.
+  - unfold range_perm in H. specialize (H (ofs - 1)). unfold perm in H.
+    right. exploit H; eauto. eapply andb_prop in Heq0. inv Heq0.
+    destruct zle in H2; inv H2. destruct zlt in H3; inv H3.
+    eauto. ii. eapply perm_cur_max. eapply perm_implies; eauto. eapply perm_any_N.
+Qed.
 
 (** * Properties of the memory operations *)
 
@@ -664,7 +2095,7 @@ Qed.
 Lemma load_result:
   forall chunk m b ofs v,
   load chunk m b ofs = Some v ->
-  v = decode_val chunk (getN (size_chunk_nat chunk) ofs (m.(mem_contents)#b)).
+  v = decode_val chunk (normalize_mvs chunk m (getN (size_chunk_nat chunk) ofs (m.(mem_contents)#b))).
 Proof.
   intros until v. unfold load.
   destruct (valid_access_dec m chunk b ofs Readable); intros.
@@ -714,7 +2145,8 @@ Theorem load_int8_signed_unsigned:
 Proof.
   intros. unfold load.
   change (size_chunk_nat Mint8signed) with (size_chunk_nat Mint8unsigned).
-  set (cl := getN (size_chunk_nat Mint8unsigned) ofs m.(mem_contents)#b).
+  set (cl := (getN (size_chunk_nat Mint8unsigned) ofs m.(mem_contents)#b)).
+  unfold normalize_mvs. des_ifs_safe.
   destruct (valid_access_dec m Mint8signed b ofs Readable).
   rewrite pred_dec_true; auto. unfold decode_val.
   destruct (proj_bytes cl); auto.
@@ -727,9 +2159,11 @@ Theorem load_int16_signed_unsigned:
   load Mint16signed m b ofs = option_map (Val.sign_ext 16) (load Mint16unsigned m b ofs).
 Proof.
   intros. unfold load.
+  repeat (rewrite chunk_normalize_mvs; eauto); try by (ii; des; clarify).
   change (size_chunk_nat Mint16signed) with (size_chunk_nat Mint16unsigned).
   set (cl := getN (size_chunk_nat Mint16unsigned) ofs m.(mem_contents)#b).
   destruct (valid_access_dec m Mint16signed b ofs Readable).
+  simpl.
   rewrite pred_dec_true; auto. unfold decode_val.
   destruct (proj_bytes cl); auto.
   simpl. decEq. decEq. rewrite Int.sign_ext_zero_ext. auto. compute; auto.
@@ -759,7 +2193,7 @@ Theorem loadbytes_load:
   forall chunk m b ofs bytes,
   loadbytes m b ofs (size_chunk chunk) = Some bytes ->
   (align_chunk chunk | ofs) ->
-  load chunk m b ofs = Some(decode_val chunk bytes).
+  load chunk m b ofs = Some(decode_val chunk (normalize_mvs chunk m bytes)).
 Proof.
   unfold loadbytes, load; intros.
   destruct (range_perm_dec m b ofs (ofs + size_chunk chunk) Cur Readable);
@@ -772,7 +2206,7 @@ Theorem load_loadbytes:
   forall chunk m b ofs v,
   load chunk m b ofs = Some v ->
   exists bytes, loadbytes m b ofs (size_chunk chunk) = Some bytes
-             /\ v = decode_val chunk bytes.
+             /\ v = decode_val chunk (normalize_mvs chunk m bytes).
 Proof.
   intros. exploit load_valid_access; eauto. intros [A B].
   exploit load_result; eauto. intros.
@@ -855,31 +2289,32 @@ Proof.
   red; intros; apply r; lia.
 Qed.
 
-Theorem load_rep:
- forall ch m1 m2 b ofs v1 v2,
-  (forall z, 0 <= z < size_chunk ch -> ZMap.get (ofs + z) m1.(mem_contents)#b = ZMap.get (ofs + z) m2.(mem_contents)#b) ->
-  load ch m1 b ofs = Some v1 ->
-  load ch m2 b ofs = Some v2 ->
-  v1 = v2.
-Proof.
-  intros.
-  apply load_result in H0.
-  apply load_result in H1.
-  subst.
-  f_equal.
-  rewrite size_chunk_conv in H.
-  remember (size_chunk_nat ch) as n; clear Heqn.
-  revert ofs H; induction n; intros; simpl; auto.
-  f_equal.
-  rewrite Nat2Z.inj_succ in H.
-  replace ofs with (ofs+0) by lia.
-  apply H; lia.
-  apply IHn.
-  intros.
-  rewrite <- Z.add_assoc.
-  apply H.
-  rewrite Nat2Z.inj_succ. lia.
-Qed.
+(* not true. if concrete memory is same, it will be true *)
+(* Theorem load_rep: *)
+(*  forall ch m1 m2 b ofs v1 v2, *)
+(*   (forall z, 0 <= z < size_chunk ch -> ZMap.get (ofs + z) m1.(mem_contents)#b = ZMap.get (ofs + z) m2.(mem_contents)#b) -> *)
+(*   load ch m1 b ofs = Some v1 -> *)
+(*   load ch m2 b ofs = Some v2 -> *)
+(*   v1 = v2. *)
+(* Proof. *)
+(*   intros. *)
+(*   apply load_result in H0. *)
+(*   apply load_result in H1. *)
+(*   subst. *)
+(*   f_equal. *)
+(*   rewrite size_chunk_conv in H. *)
+(*   remember (size_chunk_nat ch) as n; clear Heqn. *)
+(*   revert ofs H; induction n; intros; simpl; auto. *)
+(*   f_equal. *)
+(*   rewrite Nat2Z.inj_succ in H. *)
+(*   replace ofs with (ofs+0) by lia. *)
+(*   apply H; lia. *)
+(*   apply IHn. *)
+(*   intros. *)
+(*   rewrite <- Z.add_assoc. *)
+(*   apply H. *)
+(*   rewrite Nat2Z.inj_succ. lia. *)
+(* Qed. *)
 
 Theorem load_int64_split:
   forall m b ofs v,
@@ -903,13 +2338,11 @@ Proof.
   exploit loadbytes_load. eexact LB2.
   simpl. apply Z.divide_add_r. apply Z.divide_trans with 8; auto. exists 2; auto. exists 1; auto.
   intros L2.
-  exists (decode_val Mint32 (if Archi.big_endian then bytes1 else bytes2));
-  exists (decode_val Mint32 (if Archi.big_endian then bytes2 else bytes1)).
+  exists (decode_val Mint32 (if Archi.big_endian then (normalize_mvs Mint32 m bytes1) else (normalize_mvs Mint32 m bytes2)));
+  exists (decode_val Mint32 (if Archi.big_endian then (normalize_mvs Mint32 m bytes2) else (normalize_mvs Mint32 m bytes1))).
   split. destruct Archi.big_endian; auto.
   split. destruct Archi.big_endian; auto.
-  rewrite EQ. rewrite APP. apply decode_val_int64; auto.
-  erewrite loadbytes_length; eauto. reflexivity.
-  erewrite loadbytes_length; eauto. reflexivity.
+  rewrite EQ. rewrite APP. ss.
 Qed.
 
 Lemma addressing_int64_split:
@@ -941,6 +2374,8 @@ Theorem loadv_int64_split:
   /\ Val.lessdef v (Val.longofwords v1 v2).
 Proof.
   intros. destruct a; simpl in H; inv H.
+  { unfold loadv, to_ptr in H2. rewrite H0 in H2. clarify. }
+  unfold loadv in H2. simpl in H2.
   exploit load_int64_split; eauto. intros (v1 & v2 & L1 & L2 & EQ).
   unfold Val.add; rewrite H0.
   assert (NV: Ptrofs.unsigned (Ptrofs.add i (Ptrofs.of_int (Int.repr 4))) = Ptrofs.unsigned i + 4).
@@ -948,6 +2383,7 @@ Proof.
     exploit load_valid_access. eexact H2. intros [P Q]. auto. }
   exists v1, v2.
 Opaque Ptrofs.repr.
+  unfold loadv. simpl.
   split. auto.
   split. simpl. rewrite NV. auto.
   auto.
@@ -969,6 +2405,35 @@ Defined.
 
 Local Hint Resolve valid_access_store: mem.
 
+Section NALLOC.
+
+Variable lo hi: Z.
+Variable b: block.
+Variable m m': mem.
+Hypothesis NA: nonempty_alloc m b lo hi = Some m'.
+
+Lemma nonempty_alloc_concrete:
+  m.(mem_concrete) = m'.(mem_concrete).
+Proof.  
+  destruct (perm_dec m b lo Max Nonempty).
+  2:{ unfold Mem.nonempty_alloc in NA. des_ifs. }
+  destruct (is_concrete m b) eqn:CONC.
+  { unfold Mem.nonempty_alloc in NA. des_ifs. }
+  unfold Mem.nonempty_alloc in NA. des_ifs.
+Qed.
+
+Lemma nonempty_alloc_nextblock:
+  m.(nextblock) = m'.(nextblock).
+Proof.
+  destruct (perm_dec m b lo Max Nonempty).
+  2:{ unfold Mem.nonempty_alloc in NA. des_ifs. }
+  destruct (is_concrete m b) eqn:CONC.
+  { unfold Mem.nonempty_alloc in NA. des_ifs. }
+  unfold Mem.nonempty_alloc in NA. des_ifs.
+Qed.
+
+End NALLOC.
+
 Section STORE.
 Variable chunk: memory_chunk.
 Variable m1: mem.
@@ -1014,6 +2479,12 @@ Proof.
   auto.
 Qed.
 
+Theorem concrete_store:
+  m1.(mem_concrete) = m2.(mem_concrete).
+Proof.
+  unfold store in STORE. destruct ( valid_access_dec m1 chunk b ofs Writable); inv STORE. reflexivity.
+Qed.
+
 Theorem store_valid_block_1:
   forall b', valid_block m1 b' -> valid_block m2 b'.
 Proof.
@@ -1052,6 +2523,39 @@ Qed.
 
 Local Hint Resolve store_valid_access_1 store_valid_access_2 store_valid_access_3: mem.
 
+Lemma store_pure_memval
+    bytes (LB: loadbytes m2 b ofs (size_chunk chunk) = Some bytes):
+  <<PURE:((~ In Undef bytes) /\ (is_mixed_mvs_old bytes = false)) \/ bytes_all_undef bytes = true>>.
+Proof.
+  unfold loadbytes in LB. des_ifs. rewrite store_mem_contents. ss.
+  replace (Z.to_nat (size_chunk chunk)) with (size_chunk_nat chunk) by ss.
+  replace (size_chunk_nat chunk) with (length (encode_val chunk v)).
+  2:{ rewrite encode_val_length. repeat rewrite size_chunk_conv in H. apply Nat2Z.inj; auto. }
+  rewrite PMap.gss. rewrite getN_setN_same. eapply encode_val_pure.
+Qed.
+
+Lemma store_pure_memval_check
+    bytes (LB: loadbytes m2 b ofs (size_chunk chunk) = Some bytes):
+  <<PURE: change_check chunk bytes = false>>.
+Proof.
+  unfold loadbytes in LB. des_ifs. rewrite store_mem_contents. ss.
+  replace (Z.to_nat (size_chunk chunk)) with (size_chunk_nat chunk) by ss.
+  replace (size_chunk_nat chunk) with (length (encode_val chunk v)).
+  2:{ rewrite encode_val_length. repeat rewrite size_chunk_conv in H. apply Nat2Z.inj; auto. }
+  rewrite PMap.gss. rewrite getN_setN_same. eapply encode_val_change_check_false.
+Qed.
+
+Lemma store_loadbytes_same
+    bytes (LB: loadbytes m2 b ofs (size_chunk chunk) = Some bytes):
+  <<EQ: encode_val chunk v = bytes>>.
+Proof.
+  unfold loadbytes in LB. des_ifs. rewrite store_mem_contents.
+  replace (Z.to_nat (size_chunk chunk)) with (size_chunk_nat chunk) by ss.
+  replace (size_chunk_nat chunk) with (length (encode_val chunk v)).
+  2:{ rewrite encode_val_length. repeat rewrite size_chunk_conv in H. apply Nat2Z.inj; auto. }
+  rewrite PMap.gss. rewrite getN_setN_same. auto.
+Qed.
+
 Theorem load_store_similar:
   forall chunk',
   size_chunk chunk' = size_chunk chunk ->
@@ -1067,7 +2571,71 @@ Proof.
   rewrite B. rewrite store_mem_contents; simpl.
   rewrite PMap.gss.
   replace (size_chunk_nat chunk') with (length (encode_val chunk v)).
-  rewrite getN_setN_same. apply decode_encode_val_general.
+  rewrite getN_setN_same.
+  exploit load_loadbytes; eauto. i. des.
+  exploit store_pure_memval.
+  { rewrite <- H. eapply H1. }
+  i. des.
+  (* all undef *)
+  2: { rewrite H in H1. erewrite store_loadbytes_same; eauto.
+       assert (is_mixed_mvs bytes = false).
+       { clear - H3. induction bytes; ss. eapply andb_prop in H3. des.
+         destruct a; ss. }
+       unfold normalize_mvs, normalize_check. rewrite H4. 
+       exploit store_loadbytes_same; eauto. i. des. subst. des_ifs;
+         apply decode_encode_val_general. }
+  unfold is_mixed_mvs_old in H4. rewrite andb_false_iff in H4. des.
+  rewrite normalize_mvs_pure.
+  2:{ do 2 rewrite andb_false_iff in H4. rewrite negb_false_iff in H4.
+      erewrite (store_loadbytes_same bytes); eauto.
+      { rewrite negb_false_iff in H4. des; auto; left; unfold is_mixed_mvs; rewrite H4; ss.
+        rewrite andb_false_r. ss. }
+      rewrite <- H. eauto. }
+  apply decode_encode_val_general.
+  { rewrite negb_false_iff in H4.
+    assert (MIXED: is_mixed_mvs (encode_val chunk v) = true).
+    { unfold is_mixed_mvs.
+      assert (LEN: (Datatypes.length bytes > 0)%nat).
+      { erewrite loadbytes_length; eauto. destruct chunk'; ss; lia. }
+      exploit store_loadbytes_same; eauto.
+      { rewrite <- H. eauto. }
+      i. rewrite H5. repeat rewrite andb_true_iff. splits.
+      - rewrite forallb_forall in *. ii. eapply H4 in H6.
+        unfold is_ptrlike_mv. rewrite H6. ss.
+      - rewrite negb_true_iff. erewrite forallb_false_forall. ii.
+        rewrite forallb_forall in H4. destruct bytes; ss; [lia|].
+        specialize (H4 m). specialize (H6 m).
+        exploit H4; eauto. i. exploit H6; eauto. i.
+        clear - H7 H8. destruct m; ss. des_ifs. }
+    assert (chunk = Many64 \/ chunk = Many32).
+    { destruct Archi.ptr64 eqn:SF.
+      - unfold is_intptr_mv in H4. des_ifs_safe. ss.
+        erewrite H in H1. exploit store_loadbytes_same; eauto. i. des. subst.
+        destruct v; ss; clear - H4; try by des_ifs.
+        rewrite forallb_forall in H4. des_ifs; ss; try by (exploit H4; eauto; i; des_ifs).
+        assert (exists x, In x (inj_bytes (encode_int 8 (Int64.unsigned i)))).
+        { clear. remember (inj_bytes (encode_int 8 (Int64.unsigned i))).
+          specialize (length_inj_bytes (encode_int 8 (Int64.unsigned i))).
+          i. erewrite encode_int_length in H. rewrite <- Heql in H. clear Heql. destruct l; ss. eauto. }
+        des. exploit H4; eauto. i. des_ifs. exfalso. eapply inj_bytes_no_fragment'; eauto.
+      - ss. }
+    des.
+    2:{ unfold normalize_mvs, normalize_check. subst.
+        destruct chunk'; ss; des_ifs; apply decode_encode_val_general. }
+    subst. ss. destruct chunk'; ss.
+    { erewrite chunk_normalize_mvs; eauto. 2:{ ii. des; clarify. } apply decode_encode_val_general. }
+    destruct v; ss. unfold decode_val. ss.
+    assert (exists bl, proj_bytes (normalize_mvs Many64 m2 (inj_value Q64 (Vlong i))) = Some bl).
+    { (* make lemma *)
+      unfold normalize_mvs, normalize_check. rewrite MIXED. simpl. unfold rev_if_be_mv. des_ifs.
+      destruct l0; ss. des_ifs. esplits; eauto. }
+    des. rewrite H5. f_equal. unfold normalize_mvs, normalize_check in H5. simpl in H5. des_ifs.
+    assert (l0 = nil) by (destruct l0; ss).
+    subst. unfold rev_if_be_mv in Heq8. des_ifs.
+    assert (rev (rev (inj_bytes (encode_int 8 (Int64.unsigned i)))) = rev [m8; m7; m6; m5; m4; m3; m0; m]).
+    { rewrite <- Heq8. ss. }
+    clear Heq8. simpl in H6. rewrite rev_involutive in H6. rewrite <- H6 in H5.
+    rewrite proj_inj_bytes in H5. clarify. eapply decode_encode_int_8. }
   rewrite encode_val_length. repeat rewrite size_chunk_conv in H.
   apply Nat2Z.inj; auto.
 Qed.
@@ -1099,11 +2667,15 @@ Proof.
   intros. unfold load.
   destruct (valid_access_dec m1 chunk' b' ofs' Readable).
   rewrite pred_dec_true.
-  decEq. decEq. rewrite store_mem_contents; simpl.
+  decEq. decEq.
+  replace (getN (size_chunk_nat chunk') ofs' (mem_contents m1) # b') with (getN (size_chunk_nat chunk') ofs' (mem_contents m2) # b'); cycle 1.
+  rewrite store_mem_contents; simpl.
   rewrite PMap.gsspec. destruct (peq b' b). subst b'.
   apply getN_setN_outside. rewrite encode_val_length. repeat rewrite <- size_chunk_conv.
   intuition.
   auto.
+  symmetry.
+  erewrite normalize_mvs_same_concrete; try eapply concrete_store. eauto.
   eauto with mem.
   rewrite pred_dec_false. auto.
   eauto with mem.
@@ -1187,7 +2759,7 @@ Lemma load_store_overlap:
   ofs + size_chunk chunk > ofs' ->
   exists mv1 mvl mv1' mvl',
       shape_encoding chunk v (mv1 :: mvl)
-  /\  shape_decoding chunk' (mv1' :: mvl') v'
+  /\  shape_decoding chunk' (normalize_mvs chunk' m2 (mv1' :: mvl')) v'
   /\  (   (ofs' = ofs /\ mv1' = mv1)
        \/ (ofs' > ofs /\ In mv1' mvl)
        \/ (ofs' < ofs /\ In mv1 mvl')).
@@ -1203,25 +2775,30 @@ Proof.
   set (c' := setN (mv1::mvl) ofs c) in *.
   exists mv1, mvl, (ZMap.get ofs' c'), (getN sz' (ofs' + 1) c').
   split. rewrite <- ENC. apply encode_val_shape.
-  split. rewrite V', SIZE'. apply decode_val_shape.
+  split. rewrite V', SIZE'. ss.
+  remember (normalize_mvs chunk' m2 (ZMap.get ofs' c' :: getN sz' (ofs' + 1) c')) as ml.
+  destruct ml.
+  { clear - Heqml. unfold normalize_mvs in Heqml. des_ifs; ss; des_ifs. }
+  apply decode_val_shape.
+
   destruct (zeq ofs' ofs).
 - subst ofs'. left; split. auto. unfold c'. simpl.
   rewrite setN_outside by lia. apply ZMap.gss.
 - right. destruct (zlt ofs ofs').
-(* If ofs < ofs':  the load reads (at ofs') a continuation byte from the write.
-       ofs   ofs'   ofs+|chunk|
-        [-------------------]       write
-             [-------------------]  read
-*)
+(* If ofs < ofs':  the load reads (at ofs') a continuation byte from the write. *)
+(*        ofs   ofs'   ofs+|chunk| *)
+(*         [-------------------]       write *)
+(*              [-------------------]  read *)
+(* *)
 + left; split. lia. unfold c'. simpl. apply setN_in.
   assert (Z.of_nat (length (mv1 :: mvl)) = size_chunk chunk).
   { rewrite <- ENC; rewrite encode_val_length. rewrite size_chunk_conv; auto. }
   simpl length in H3. rewrite Nat2Z.inj_succ in H3. lia.
-(* If ofs > ofs':  the load reads (at ofs) the first byte from the write.
-       ofs'   ofs   ofs'+|chunk'|
-               [-------------------]  write
-         [----------------]           read
-*)
+(* If ofs > ofs':  the load reads (at ofs) the first byte from the write. *)
+(*        ofs'   ofs   ofs'+|chunk'| *)
+(*                [-------------------]  write *)
+(*          [----------------]           read *)
+(* *)
 + right; split. lia. replace mv1 with (ZMap.get ofs c').
   apply getN_in.
   assert (size_chunk chunk' = Z.succ (Z.of_nat sz')).
@@ -1248,6 +2825,55 @@ Proof.
   subst; red; auto; discriminate.
 Qed.
 
+Lemma proj_fragment_same bytes bytes' (FRAG: proj_fragment bytes = Some bytes'):
+  <<FRAG: bytes = bytes' >>.
+Proof.
+  ginduction bytes; ii; ss; clarify. des_ifs. r. decEq. eapply IHbytes; eauto.
+Qed.
+
+Lemma shape_decoding_pointer_all_ptr_mv
+    chunk b ofs mvl (SHAPE: shape_decoding chunk mvl (Vptr b ofs)):
+  <<FRAG: forallb is_ptr_mv mvl = true>>.
+Proof.
+  remember (Vptr b ofs) as v.
+  ginduction SHAPE; ss; [|des_ifs]; ii. des_ifs; try by (destruct chunk; ss).
+  assert (quantity_eq (quantity_chunk chunk) Q64).
+  { destruct chunk; ss. }
+  r. repeat rewrite andb_true_iff. splits; auto.
+  rewrite forallb_forall. ii. exploit H2; eauto. i. des_safe. inv H4. ss.
+Qed.
+
+Lemma ptr_normalize_mv_result_ptr m byte
+    (PTR: is_ptr_mv (_decode_normalize_mv m byte) = true):
+  <<PTR: is_ptr_mv byte = true>>.
+Proof.
+  destruct byte; ss. des_ifs; ss; clarify.
+  - destruct m0; ss. des_ifs. eapply nth_error_In in Heq0.
+    unfold rev_if_be_mv in Heq0. des_ifs_safe. rewrite <- in_rev in Heq0. ss.
+    exfalso. eapply inj_bytes_no_fragment'; eauto.
+  - destruct m0; ss. des_ifs. eapply nth_error_In in Heq0.
+    unfold rev_if_be_mv in Heq0. des_ifs_safe. rewrite <- in_rev in Heq0. ss.
+    exfalso. eapply inj_bytes_no_fragment'; eauto.
+  - destruct m0; ss. des_ifs. eapply nth_error_In in Heq1.
+    unfold rev_if_be_mv in Heq1. des_ifs_safe. rewrite <- in_rev in Heq1. ss.
+    exfalso. eapply inj_bytes_no_fragment'; eauto.
+Qed.
+
+Lemma ptr_normalize_mvs_result_ptr_aux m bytes
+    (PTR: forallb is_ptr_mv (map (_decode_normalize_mv m) bytes) = true):
+  <<PTR: forallb is_ptr_mv bytes = true>>.
+Proof.
+  ginduction bytes; ss; i. eapply andb_prop in PTR. des.
+  erewrite IHbytes; eauto. erewrite ptr_normalize_mv_result_ptr; eauto.
+Qed.
+
+Lemma ptr_normalize_mvs_result_ptr chunk m bytes
+    (PTR: forallb is_ptr_mv (normalize_mvs chunk m bytes) = true):
+  <<PTR: forallb is_ptr_mv bytes = true>>.
+Proof.
+  unfold normalize_mvs in *. des_ifs. eapply ptr_normalize_mvs_result_ptr_aux; eauto.
+Qed.
+
 Theorem load_pointer_store:
   forall chunk m1 b ofs v m2 chunk' b' ofs' v_b v_o,
   store chunk m1 b ofs v = Some m2 ->
@@ -1261,6 +2887,23 @@ Proof.
   destruct (zle (ofs + size_chunk chunk) ofs'); auto.
   exploit load_store_overlap; eauto.
   intros (mv1 & mvl & mv1' & mvl' & ENC & DEC & CASES).
+  exploit shape_decoding_pointer_all_ptr_mv; eauto. intros PTR.
+  rewrite normalize_mvs_pure in DEC.
+  2:{ assert (PTR': forallb is_ptr_mv (mv1' :: mvl') = true).
+      { clear - PTR. unfold normalize_mvs in PTR. des_ifs. des.
+        remember (mv1' :: mvl') as mvl. clear -PTR. ginduction mvl; ss.
+        i. eapply andb_prop in PTR. des. erewrite IHmvl; eauto.
+        clear -PTR. destruct a; ss. des_ifs; ss; clarify.
+        - ss. exfalso. eapply nth_error_In in Heq0.
+          unfold rev_if_be_mv in Heq0. des_ifs_safe. rewrite <- in_rev in Heq0.
+          destruct m; ss. des_ifs. eapply inj_bytes_no_fragment'; eauto.
+        - ss. exfalso. eapply nth_error_In in Heq0.
+          unfold rev_if_be_mv in Heq0. des_ifs_safe. rewrite <- in_rev in Heq0.
+          destruct m; ss. des_ifs. eapply inj_bytes_no_fragment'; eauto.
+        - des_ifs. ss. exfalso. eapply nth_error_In in Heq1.
+          unfold rev_if_be_mv in Heq1. des_ifs_safe. rewrite <- in_rev in Heq1.
+          destruct m; ss. des_ifs. eapply inj_bytes_no_fragment'; eauto. }
+      left. unfold is_mixed_mvs. rewrite PTR'. ss. eapply andb_false_r. }
   inv DEC; try contradiction.
   destruct CASES as [(A & B) | [(A & B) | (A & B)]].
 - (* Same offset *)
@@ -1281,47 +2924,52 @@ Proof.
   exploit H7; eauto. intros (j & P & Q). subst mv1. inv ENC. congruence.
 Qed.
 
-Theorem load_store_pointer_overlap:
-  forall chunk m1 b ofs v_b v_o m2 chunk' ofs' v,
-  store chunk m1 b ofs (Vptr v_b v_o) = Some m2 ->
-  load chunk' m2 b ofs' = Some v ->
-  ofs' <> ofs ->
-  ofs' + size_chunk chunk' > ofs ->
-  ofs + size_chunk chunk > ofs' ->
-  v = Vundef.
-Proof.
-  intros.
-  exploit load_store_overlap; eauto.
-  intros (mv1 & mvl & mv1' & mvl' & ENC & DEC & CASES).
-  destruct CASES as [(A & B) | [(A & B) | (A & B)]].
-- congruence.
-- inv ENC.
-  + exploit H9; eauto. intros (j & P & Q). subst mv1'. inv DEC. congruence. auto.
-  + contradiction.
-  + exploit H5; eauto. intros; subst. inv DEC; auto.
-- inv DEC.
-  + exploit H10; eauto. intros (j & P & Q). subst mv1. inv ENC. congruence.
-  + exploit H8; eauto. intros (n & P). subst mv1. inv ENC. contradiction.
-  + auto.
-Qed.
-
-Theorem load_store_pointer_mismatch:
-  forall chunk m1 b ofs v_b v_o m2 chunk' v,
-  store chunk m1 b ofs (Vptr v_b v_o) = Some m2 ->
-  load chunk' m2 b ofs = Some v ->
-  ~compat_pointer_chunks chunk chunk' ->
-  v = Vundef.
-Proof.
-  intros.
-  exploit load_store_overlap; eauto.
-  generalize (size_chunk_pos chunk'); lia.
-  generalize (size_chunk_pos chunk); lia.
-  intros (mv1 & mvl & mv1' & mvl' & ENC & DEC & CASES).
-  destruct CASES as [(A & B) | [(A & B) | (A & B)]]; try extlia.
-  inv ENC; inv DEC; auto.
-- elim H1. apply compat_pointer_chunks_true; auto.
-- contradiction.
-Qed.
+(* Theorem load_store_pointer_overlap: *)
+(*   forall chunk m1 b ofs v_b v_o m2 chunk' ofs' v, *)
+(*   store chunk m1 b ofs (Vptr v_b v_o) = Some m2 -> *)
+(*   load chunk' m2 b ofs' = Some v -> *)
+(*   ofs' <> ofs -> *)
+(*   ofs' + size_chunk chunk' > ofs -> *)
+(*   ofs + size_chunk chunk > ofs' -> *)
+(*   v = Vundef. *)
+(* Proof. *)
+(* (*   intros. *) *)
+(* (*   exploit load_store_overlap; eauto. *) *)
+(* (*   intros (mv1 & mvl & mv1' & mvl' & ENC & DEC & CASES). *) *)
+(* (*   exploit shape_decoding_pointer_fragment'; eauto. intros FRAG1. *) *)
+(* (*   exploit fragment_normalize_fragment; try eapply FRAG1. *) *)
+(* (*   { ss. lia. } *) *)
+(* (*   intros (mvl'' & FRAG2). erewrite decode_normalize_all_fragment in DEC; eauto. *) *)
+(* (*   destruct CASES as [(A & B) | [(A & B) | (A & B)]]. *) *)
+(* (* - congruence. *) *)
+(* (* - inv ENC. *) *)
+(* (*   + exploit H9; eauto. intros (j & P & Q). subst mv1'. inv DEC. congruence. auto. *) *)
+(* (*   + contradiction. *) *)
+(* (*   + exploit H5; eauto. intros; subst. inv DEC; auto. *) *)
+(* (* - inv DEC. *) *)
+(* (*   + exploit H10; eauto. intros (j & P & Q). subst mv1. inv ENC. congruence. *) *)
+(* (*   + exploit H8; eauto. intros (n & P). subst mv1. inv ENC. contradiction. *) *)
+(* (*     + auto. *) *)
+(* Qed. *)
+
+(* Theorem load_store_pointer_mismatch: *)
+(*   forall chunk m1 b ofs v_b v_o m2 chunk' v, *)
+(*   store chunk m1 b ofs (Vptr v_b v_o) = Some m2 -> *)
+(*   load chunk' m2 b ofs = Some v -> *)
+(*   ~compat_pointer_chunks chunk chunk' -> *)
+(*   v = Vundef. *)
+(* Proof. *)
+(*   intros. *)
+(*   exploit load_store_overlap; eauto. *)
+(*   generalize (size_chunk_pos chunk'); lia. *)
+(*   generalize (size_chunk_pos chunk); lia. *)
+(*   intros (mv1 & mvl & mv1' & mvl' & ENC & DEC & CASES). *)
+(*   destruct CASES as [(A & B) | [(A & B) | (A & B)]]; try extlia. *)
+
+(* (*   inv ENC; inv DEC; auto. *) *)
+(* (* - elim H1. apply compat_pointer_chunks_true; auto. *) *)
+(* (* - contradiction. *) *)
+(* Qed. *)
 
 Lemma store_similar_chunks:
   forall chunk1 chunk2 v1 v2 m b ofs,
@@ -1397,6 +3045,20 @@ Proof.
 Qed.
 *)
 
+Lemma storev_concrete chunk m addr v m'
+    (STORE: storev chunk m addr v = Some m') :
+  <<SAME: mem_concrete m = mem_concrete m'>>.
+Proof.
+  unfold storev in *. des_ifs; eapply concrete_store; eauto.
+Qed.
+
+Lemma storebytes_concrete m b ofs mvl m'
+    (STORE: storebytes m b ofs mvl = Some m') :
+  <<SAME: mem_concrete m = mem_concrete m'>>.
+Proof.
+  unfold storebytes in *. des_ifs.
+Qed.
+
 (** ** Properties related to [storebytes]. *)
 
 Theorem range_perm_storebytes:
@@ -1476,6 +3138,13 @@ Qed.
 
 Local Hint Resolve perm_storebytes_1 perm_storebytes_2: mem.
 
+Theorem concrete_storebytes:
+  m1.(mem_concrete) = m2.(mem_concrete).
+Proof.
+  unfold storebytes in STORE. destruct (range_perm_dec m1 b ofs (ofs + Z_of_nat (length bytes)) Cur Writable); inversion STORE.
+  reflexivity.
+Qed.
+
 Theorem storebytes_valid_access_1:
   forall chunk' b' ofs' p,
   valid_access m1 chunk' b' ofs' p -> valid_access m2 chunk' b' ofs' p.
@@ -1576,6 +3245,8 @@ Theorem load_storebytes_other:
   load chunk m2 b' ofs' = load chunk m1 b' ofs'.
 Proof.
   intros. unfold load.
+  exploit storebytes_concrete; eauto. intros CONC.
+  erewrite (normalize_mvs_same_concrete m1 m2); eauto.
   destruct (valid_access_dec m1 chunk b' ofs' Readable).
   rewrite pred_dec_true.
   rewrite storebytes_mem_contents. decEq.
@@ -1666,7 +3337,7 @@ Theorem storev_int64_split:
      storev Mint32 m a (if Archi.big_endian then Val.hiword v else Val.loword v) = Some m1
   /\ storev Mint32 m1 (Val.add a (Vint (Int.repr 4))) (if Archi.big_endian then Val.loword v else Val.hiword v) = Some m'.
 Proof.
-  intros. destruct a; simpl in H; inv H. rewrite H2.
+  intros. destruct a; simpl in H; inv H. { des_ifs. } rewrite H2.
   exploit store_int64_split; eauto. intros [m1 [A B]].
   exists m1; split.
   exact A.
@@ -1691,6 +3362,12 @@ Proof.
   injection ALLOC; intros. rewrite <- H0; auto.
 Qed.
 
+Theorem concrete_alloc:
+  m1.(mem_concrete) = m2.(mem_concrete).
+Proof.
+  unfold alloc in ALLOC. inversion ALLOC. reflexivity.
+Qed.
+
 Theorem alloc_result:
   b = nextblock m1.
 Proof.
@@ -1830,6 +3507,9 @@ Theorem load_alloc_other:
 Proof.
   intros. rewrite <- H. apply load_alloc_unchanged. eauto with mem.
 Qed.
+(* Lemma undef_normalize_to_fragment_undef chunk mvl: *)
+(*   exists mvl', <<UNDEF: normalize_to_fragment chunk (Undef :: mvl) = Undef :: mvl'>>. *)
+(* Proof. unfold normalize_to_fragment. des_ifs_safe. des_ifs; esplits; eauto. Qed. *)
 
 Theorem load_alloc_same:
   forall chunk ofs v,
@@ -1839,7 +3519,8 @@ Proof.
   intros. exploit load_result; eauto. intro. rewrite H0.
   injection ALLOC; intros. rewrite <- H2; simpl. rewrite <- H1.
   rewrite PMap.gss. destruct (size_chunk_nat_pos chunk) as [n E]. rewrite E. simpl.
-  rewrite ZMap.gi. apply decode_val_undef.
+  rewrite ZMap.gi. rewrite H2. specialize (normalize_mvs_undef m2 chunk (getN n (ofs + 1) (ZMap.init Undef))). i.
+  des. rewrite H3. apply decode_val_undef.
 Qed.
 
 Theorem load_alloc_same':
@@ -1919,6 +3600,14 @@ Proof.
   congruence. congruence.
 Qed.
 
+Theorem concrete_free:
+  m1.(mem_concrete) = m2.(mem_concrete).
+Proof.
+  unfold free, unchecked_free in FREE.
+  destruct (range_perm_dec m1 bf lo hi Cur Freeable); inversion FREE.
+  reflexivity.
+Qed.
+
 Theorem nextblock_free:
   nextblock m2 = nextblock m1.
 Proof.
@@ -2121,6 +3810,14 @@ Proof.
   unfold drop_perm in DROP. destruct (range_perm_dec m b lo hi Cur Freeable); inv DROP; auto.
 Qed.
 
+Theorem concrete_drop:
+  m.(mem_concrete) = m'.(mem_concrete).
+Proof.
+  unfold drop_perm in DROP.
+  destruct (range_perm_dec m b lo hi Cur Freeable) in DROP; inversion DROP.
+  reflexivity.
+Qed.
+
 Theorem drop_perm_valid_block_1:
   forall b', valid_block m b' -> valid_block m' b'.
 Proof.
@@ -2237,6 +3934,90 @@ Qed.
 
 End DROP.
 
+Lemma denormalize_store_other
+  m z b ofs b' ofs' chunk v m'
+  (DENO: denormalize z m = Some (b, ofs))
+  (STORE: store chunk m b' ofs' v = Some m')
+  :
+  <<DENO': denormalize z m' = Some (b, ofs)>>.
+Proof.
+  eapply denormalize_info in DENO. des.
+  eapply ptr2int_to_denormalize_max; eauto.
+- unfold ptr2int. erewrite concrete_store in CONC; eauto.
+  rewrite CONC. f_equal. lia.
+- eapply perm_store_1; eauto.
+Qed.
+
+Lemma denormalize_storebytes_other
+  m z b ofs b' ofs' vl m'
+  (DENO: denormalize z m = Some (b, ofs))
+  (STORE: storebytes m b' ofs' vl = Some m')
+  :
+  <<DENO': denormalize z m' = Some (b, ofs)>>.
+Proof.
+  eapply denormalize_info in DENO. des.
+  eapply ptr2int_to_denormalize_max; eauto.
+- unfold ptr2int. erewrite concrete_storebytes in CONC; eauto.
+  rewrite CONC. f_equal. lia.
+- eapply perm_storebytes_1; eauto.
+Qed.
+
+Section CAPTURE.
+  Variable chunk: memory_chunk.
+  Variable m1:mem.
+  Variable m2:mem.
+  Variable b:block.
+  Variable addr:Z.
+  Hypothesis CAPTURE: capture m1 b addr m2.
+
+  Theorem nextblock_capture:
+    nextblock m2 = nextblock m1.
+  Proof.
+    inv CAPTURE. ss.
+  Qed.
+
+  Theorem loadbytes_capture_unchanged:
+    forall b1 ofs1 n,
+      loadbytes m2 b1 ofs1 n = loadbytes m1 b1 ofs1 n.
+  Proof.
+    i. inv CAPTURE.
+    i. unfold loadbytes. des_ifs.
+    - rewrite CONTENTS. eauto.
+    - unfold range_perm, perm, perm_order' in *.
+      rewrite <- ACCESS in r.
+      exfalso. eapply n0. eauto.
+    - unfold range_perm, perm, perm_order' in *.
+      rewrite ACCESS in r.
+      exfalso. eapply n0. eauto.
+  Qed.
+
+  Lemma concrete_other :
+    forall blk, (blk<>b -> m1.(mem_concrete)!blk = m2.(mem_concrete)!blk).
+  Proof.
+    i. inv CAPTURE.
+    destruct ((mem_concrete m1)!b).
+    - exploit PREVADDR; eauto. i. des. subst. rewrite H1. auto.
+    - exploit CAPTURED; auto. i. rewrite H0.
+      exploit PTree.gso; eauto.
+  Qed.
+
+End CAPTURE.
+
+Lemma capture_trans_store
+      m1 m2 m b addr1 addr2 chunk blk ofs v1 v2 m1'
+      (CAPTURE1: Mem.capture m b addr1 m1)
+      (CAPTURE2: Mem.capture m b addr2 m2)
+      (STORE: Mem.store chunk m1 blk ofs v1 = Some m1')
+  :
+    exists m2', Mem.store chunk m2 blk ofs v2 = Some m2'.
+Proof.
+  inv CAPTURE1. inv CAPTURE2. eexists.
+  unfold Mem.store in *. des_ifs. exfalso. eapply n.
+  unfold Mem.valid_access in *. des. split; eauto. unfold Mem.range_perm in *. i.
+  unfold Mem.perm in *. rewrite <- ACCESS0. rewrite ACCESS. eauto.
+Qed.
+
+
 (** * Generic injections *)
 
 (** A memory state [m1] generically injects into another memory state [m2] via the
@@ -2263,7 +4044,7 @@ Record mem_inj (f: meminj) (m1 m2: mem) : Prop :=
       forall b1 ofs b2 delta,
       f b1 = Some(b2, delta) ->
       perm m1 b1 ofs Cur Readable ->
-      memval_inject f (ZMap.get ofs m1.(mem_contents)#b1) (ZMap.get (ofs+delta) m2.(mem_contents)#b2)
+      memval_inject f (ZMap.get ofs m1.(mem_contents)#b1) (ZMap.get (ofs+delta) m2.(mem_contents)#b2);
   }.
 
 (** Preservation of permissions *)
@@ -2326,19 +4107,386 @@ Proof.
   apply IHn. red; intros; apply H1; lia.
 Qed.
 
+Lemma long_proj_long_fragment q l i
+    (LONG: proj_value q l = Vlong i) :
+  <<LONG: forallb is_long_mv l = true>>.
+Proof.
+  unfold proj_value in LONG. des_ifs.
+  remember (Fragment (Vlong i) q0 n :: l0) as l. clear - Heq.
+  revert Heq. generalize (size_quantity_nat q). ginduction l; i; [ss|].
+  destruct n; ss. des_ifs; ss. des_ifs.
+  repeat rewrite andb_true_iff in Heq. des. erewrite IHl; eauto.
+Qed.
+
+Lemma long_proj_intptr_fragment l i
+    (SF: Archi.ptr64 = true) (LONG: proj_value Q64 l = Vlong i) :
+  <<LONG: forallb is_intptr_mv l = true>>.
+Proof.
+  unfold proj_value in LONG. des_ifs.
+  remember (Fragment (Vlong i) q n :: l0) as l. unfold is_intptr_mv.
+  rewrite SF. simpl. clear - Heq.
+  revert Heq. generalize (size_quantity_nat Q64). ginduction l; i; [ss|].
+  destruct n; ss. des_ifs; ss. des_ifs.
+  repeat rewrite andb_true_iff in Heq. des. erewrite IHl; eauto.
+  destruct q; ss.
+Qed.
+
+Lemma ptr_proj_ptr_fragment l b ofs
+    (PTR: proj_value Q64 l = Vptr b ofs) :
+  <<PTR: forallb is_ptr_mv l = true>>.
+Proof.
+  unfold proj_value in PTR. des_ifs.
+  remember (Fragment (Vptr b ofs) q n :: l0) as l. clear - Heq.
+  revert Heq. generalize (size_quantity_nat Q64). ginduction l; i; [ss|].
+  destruct n; ss. des_ifs; ss. des_ifs.
+  repeat rewrite andb_true_iff in Heq. des. erewrite IHl; eauto.
+  destruct q; ss.
+Qed.
+
+Lemma change_check_fail_normalize_mvs_same chunk mvs
+    (UNCHANGE: change_check chunk mvs = false):
+  forall m1 m2, normalize_mvs chunk m1 mvs = normalize_mvs chunk m2 mvs.
+Proof.
+  ii. unfold change_check in UNCHANGE. do 2 rewrite andb_false_iff in UNCHANGE. des.
+  - unfold normalize_mvs, normalize_check in *. rewrite UNCHANGE. ss.
+  - rewrite negb_false_iff in UNCHANGE. do 2 (erewrite normalize_mvs_pure; eauto).
+  - unfold qarchi in UNCHANGE. des_ifs_safe. unfold normalize_mvs, normalize_check. des_ifs_safe.
+    destruct chunk; ss.
+    + des_ifs; try by (unfold proj_value in Heq1; des_ifs).
+      * destruct mvs; try by ss.
+        exfalso. rewrite negb_false_iff in UNCHANGE. eapply andb_prop in Heq0. des.
+        clear - UNCHANGE Heq0. ginduction mvs; ss; i.
+        { destruct m; ss. }
+        { destruct m; ss; eauto. eapply andb_prop in Heq0. des; eauto. }
+      * exploit long_proj_intptr_fragment; eauto. i. eapply intptr_normalize_mvs_same_aux2; eauto.
+      * exploit ptr_proj_ptr_fragment; eauto. i. exfalso. unfold is_mixed_mvs in Heq0.
+        rewrite H in Heq0. ss. erewrite andb_false_r in Heq0. clarify.
+    + des_ifs; try by (unfold proj_value in Heq1; des_ifs).
+      * destruct mvs; try by ss.
+        exfalso. rewrite negb_false_iff in UNCHANGE. eapply andb_prop in Heq0. des.
+        clear - UNCHANGE Heq0. ginduction mvs; ss; i.
+        { destruct m; ss. }
+        { destruct m; ss; eauto. eapply andb_prop in Heq0. des; eauto. }
+      * exploit long_proj_intptr_fragment; eauto. i. eapply intptr_normalize_mvs_same_aux2; eauto.
+      * exploit ptr_proj_ptr_fragment; eauto. i. exfalso. unfold is_mixed_mvs in Heq0.
+        rewrite H in Heq0. ss. erewrite andb_false_r in Heq0. clarify.
+Qed.
+    
+Lemma ptrlike_inject_ptrlike f vl1 vl2
+    (MVINJ : list_forall2 (memval_inject f) vl1 vl2)
+    (UNDEF : ~ In Undef vl1) (UNDEF' : forall q n, ~ In (Fragment Vundef q n) vl1):
+  <<MIX: forallb is_ptrlike_mv vl1 = forallb is_ptrlike_mv vl2>>.
+Proof.
+  ginduction MVINJ; ss. ii. inv H; ss.
+  - eapply IHMVINJ; eauto. ii. eapply UNDEF'. eauto.
+  - inv H0; ss.
+    + r. erewrite IHMVINJ; eauto. ii. eapply UNDEF'; eauto.
+    + erewrite IHMVINJ; eauto. ii. eapply UNDEF'; eauto.
+    + exfalso. eapply UNDEF'; eauto.
+  - exfalso. eapply UNDEF. eauto.
+Qed.
+
+Lemma intptr_inject_intptr f vl1 vl2
+    (MVINJ : list_forall2 (memval_inject f) vl1 vl2)
+    (UNDEF : ~ In Undef vl1) (UNDEF' : forall q n, ~ In (Fragment Vundef q n) vl1):
+  <<MIX: forallb is_intptr_mv vl1 = forallb is_intptr_mv vl2>>.
+Proof.
+  ginduction MVINJ; ss. ii. inv H; ss.
+  - inv H0; ss. { rewrite IHMVINJ; eauto. ii. eapply UNDEF'; eauto. }
+    exfalso. eapply UNDEF'. eauto.
+  - exfalso. eapply UNDEF. eauto.
+Qed.
+
+Lemma ptr_inject_ptr f vl1 vl2
+    (MVINJ : list_forall2 (memval_inject f) vl1 vl2)
+    (UNDEF : ~ In Undef vl1) (UNDEF' : forall q n, ~ In (Fragment Vundef q n) vl1):
+  <<MIX: forallb is_ptr_mv vl1 = forallb is_ptr_mv vl2>>.
+Proof.
+  ginduction MVINJ; ss. ii. inv H; ss.
+  - inv H0; ss. { rewrite IHMVINJ; eauto. ii. eapply UNDEF'; eauto. }
+    exfalso. eapply UNDEF'. eauto.
+  - exfalso. eapply UNDEF. eauto.
+Qed.
+
+Lemma byte_inject_byte f vl1 vl2
+    (MVINJ : list_forall2 (memval_inject f) vl1 vl2)
+    (UNDEF : ~ In Undef vl1) (UNDEF' : forall q n, ~ In (Fragment Vundef q n) vl1):
+  <<MIX: forallb is_byte_mv vl1 = forallb is_byte_mv vl2>>.
+Proof.
+  ginduction MVINJ; ss. ii. inv H; ss.
+  - rewrite IHMVINJ; eauto. ii. eapply UNDEF'; eauto.
+  - exfalso. eapply UNDEF. eauto.
+Qed.
+  
+Lemma mix_inject_mix f vl1 vl2
+    (MVINJ : list_forall2 (memval_inject f) vl1 vl2)
+    (UNDEF : ~ In Undef vl1) (UNDEF' : forall q n, ~ In (Fragment Vundef q n) vl1):
+  <<MIX: is_mixed_mvs vl1 = is_mixed_mvs vl2>>.
+Proof.
+  unfold is_mixed_mvs. erewrite ptrlike_inject_ptrlike, ptr_inject_ptr; eauto.
+Qed.
+
+Lemma proj_value_undef_frag q' n q vl (FRAG: In (Fragment Vundef q' n) vl):
+  <<UNDEF: proj_value q vl = Vundef>>.
+Proof.
+  unfold proj_value. des_ifs. remember (size_quantity_nat q). clear Heqn1.
+  remember (Fragment v q0 n0 :: l) as l'. clear Heql'. ginduction n1; ss; i; des_ifs.
+  des_ifs. ss. repeat (eapply andb_prop in Heq; des_safe).
+  des; clarify; [destruct v; ss|]. eapply IHn1; eauto.
+Qed.
+
+(* move *)
+Lemma mixed_ptrlikes
+  mvs (MIX: is_mixed_mvs mvs = true):
+  <<PTR: forallb is_ptrlike_mv mvs = true>>.
+Proof. unfold is_mixed_mvs in MIX. repeat (eapply andb_prop in MIX; des). eauto. Qed.
+        
+(* Lemma memval_inject_normalize *)
+(*   f m1 m2 mv1 mv2 *)
+(*   (CONC: forall b1 b2 delta addr, *)
+(*       f b1 = Some (b2, delta) -> valid_block m1 b1 -> *)
+(*       m1.(mem_concrete)!b1 = Some addr -> *)
+(*       m2.(mem_concrete)!b2 = Some (addr-delta)) *)
+(*   (MVINJ: memval_inject f mv1 mv2): *)
+(*   <<MVINJ: memval_inject f (_decode_normalize_mv m1 mv1) (_decode_normalize_mv m2 mv2)>>. *)
+(* Proof. *)
+(*   (* inv MVINJ; ss; try econs. inv H; ss; try by econs. *) *)
+(*   (* "false. src concrete look up fail but tgt success: src -> Vptr frag / tgt -> byte. memval bind needed". *) *)
+(* Abort. *)
+
+Lemma normalize_result_fragments
+  mvs m (FRAG: forallb is_frag_mv (map (_decode_normalize_mv m) mvs) = true):
+  <<EQ: map (_decode_normalize_mv m) mvs = mvs>>.
+Proof.
+  ginduction mvs; ss; i. eapply andb_prop in FRAG. des. rewrite IHmvs; eauto.
+  r. f_equal. destruct a; ss. des_ifs. destruct v; ss; clarify.
+  - ss. exploit nth_error_In; eauto. i. destruct m0; ss.
+    unfold rev_if_be_mv in *. des_ifs_safe. rewrite <- in_rev in H.
+    exfalso. eapply inj_bytes_no_fragment; eauto. rewrite encode_int_length. lia.
+  - ss. exploit nth_error_In; eauto. i. destruct m0; ss.
+    unfold rev_if_be_mv in *. des_ifs_safe. rewrite <- in_rev in H.
+    exfalso. eapply inj_bytes_no_fragment; eauto. rewrite encode_int_length. lia.
+  - ss. des_ifs. exploit nth_error_In; eauto. i. destruct m0; ss.
+    unfold rev_if_be_mv in *. des_ifs_safe. rewrite <- in_rev in H.
+    exfalso. eapply inj_bytes_no_fragment; eauto. rewrite encode_int_length. lia.
+Qed.
+
+Lemma not_bytes_proj_bytes_fail vl (MIXED: forallb is_byte_mv vl = false):
+  <<FAIL: proj_bytes vl = None>>.
+Proof.
+  ginduction vl; ss. ii. eapply andb_false_iff in MIXED. des; des_ifs. exploit IHvl; eauto. i. clarify.
+Qed.
+
+Lemma not_bytes_proj_bytes_iff vl:
+  proj_bytes vl = None <-> forallb is_byte_mv vl = false.
+Proof.
+  split; i. 2:{ eapply not_bytes_proj_bytes_fail; eauto. }
+  ginduction vl; ss; ii. des_ifs. ss. eauto.
+Qed.
+
+Lemma mixed_check_value byte bytes n v q
+    (MIXED: is_mixed_mvs_old (byte :: bytes) = true):
+  <<FAIL: check_value n v q (byte :: bytes) = false>>.
+Proof.
+  ginduction n; ss; i. destruct byte; ss. destruct bytes; ss.
+  { unfold is_mixed_mvs_old, is_ptrlike_mv in MIXED. ss. des_ifs; destruct q0; ss. }
+  destruct (Val.eq v v0); destruct (quantity_eq q q0); ss.
+  destruct (Nat.eqb n n0) eqn:N; ss. rewrite Nat.eqb_eq in N. subst v0 q0 n0.
+  destruct (is_mixed_mvs_old (m :: bytes)) eqn:MIXED'; [eapply IHn; eauto|].
+  clear IHn. unfold is_mixed_mvs_old in MIXED, MIXED'. ss.
+  repeat rewrite andb_true_iff in MIXED. des. repeat rewrite negb_true_iff in MIXED1, MIXED0.
+  repeat rewrite andb_false_iff in MIXED'. des; clarify.
+  - rewrite negb_false_iff in MIXED'. eapply andb_prop in MIXED'. des.
+    destruct m; ss. destruct n; ss.
+  - rewrite negb_false_iff in MIXED'. eapply andb_prop in MIXED'. des.
+    rewrite andb_false_iff in MIXED1. des; clarify. des_ifs_safe.
+    destruct m; ss. des_ifs; destruct n; ss. destruct q, q0; ss.
+  - rewrite negb_false_iff in MIXED'. eapply andb_prop in MIXED'. des.
+    rewrite andb_false_iff in MIXED0. des; clarify. des_ifs_safe.
+    destruct m; ss. des_ifs; destruct n; ss. destruct q, q0; ss.
+Qed.
+
+Lemma mixed_decode_val_undefs vl chunk (MIXED: is_mixed_mvs_old vl = true):
+  <<UNDEF: decode_val chunk vl = Vundef>>.
+Proof.
+  assert (proj_bytes vl = None).
+  { unfold is_mixed_mvs_old in MIXED. repeat rewrite andb_true_iff in MIXED. des.
+    rewrite negb_true_iff in *. eapply not_bytes_proj_bytes_fail; ss. }
+  unfold decode_val. rewrite H. unfold proj_value. destruct vl; [ss|].
+  des_ifs; erewrite mixed_check_value in *; eauto; clarify.
+Qed.
+
+Lemma proj_bytes_undef bl (IN: In Undef bl):
+  <<BYTES: proj_bytes bl = None>>.
+Proof. ginduction bl; ss; ii. des; subst; des_ifs. eapply IHbl in IN; clarify. Qed.
+
+Lemma proj_bytes_fragment v q n bl (IN: In (Fragment v q n) bl) : <<BYTES: proj_bytes bl = None>>.
+Proof.
+  ginduction bl; ss; ii. des; subst; eauto. exploit IHbl; eauto. i. rewrite H. des_ifs.
+Qed.
+
+Lemma in_undef_normalize_in_undef chunk m vl (IN: In Undef vl) :
+  <<UNDEF: In Undef (normalize_mvs chunk m vl)>>.
+Proof.
+  dup IN. eapply in_map with (f:= (_decode_normalize_mv m)) in IN.
+  unfold normalize_mvs. des_ifs; ss.
+Qed.
+
+Lemma in_undef_frag_normalize_in_undef chunk m vl q n (IN: In (Fragment Vundef q n) vl) :
+  <<UNDEF: In (Fragment Vundef q n) (normalize_mvs chunk m vl)>>.
+Proof.
+  dup IN. eapply in_map with (f:= (_decode_normalize_mv m)) in IN.
+  unfold normalize_mvs. des_ifs; ss.
+Qed.
+
+Lemma normalized_intptr_undef chunk m vl
+    (LEN: (Datatypes.length vl > 0)%nat)
+    (NC: normalize_check chunk vl = true)
+    (IP : forallb is_intptr_mv (map (_decode_normalize_mv m) vl) = true):
+  <<UNDEF: decode_val chunk (map (_decode_normalize_mv m) vl) = Vundef>>.
+Proof.
+  unfold normalize_check in NC. des_ifs; ss.
+  - unfold decode_val. erewrite not_bytes_proj_bytes_fail; eauto.
+    2:{ destruct vl; [ss; lia|]. rewrite forallb_false_forall. ii. rewrite forallb_forall in IP.
+        ss. exploit IP; eauto. i. exploit H; eauto. i. destruct m0; ss. des_ifs. destruct m0; ss. }
+    des_ifs. destruct vl; [ss|]. simpl in IP. destruct m0; simpl in IP; clarify.
+    eapply andb_prop in IP. des. des_ifs.
+    { exfalso. destruct v; ss; clarify.
+      - ss. clear - Heq1 IP. unfold rev_if_be_mv in Heq1. des_ifs; ss.
+        eapply nth_error_In in Heq1. rewrite <- in_rev in Heq1.
+        unfold encode_int in Heq1. ss. unfold rev_if_be in Heq1. des_ifs. destruct m0; ss. des; clarify.
+      - des_ifs. ss. clear - Heq1 IP. unfold rev_if_be_mv in Heq1. des_ifs; ss.
+        eapply nth_error_In in Heq1. rewrite <- in_rev in Heq1.
+        unfold encode_int in Heq1. ss. unfold rev_if_be in Heq1. des_ifs. destruct m0; ss. des; clarify. }
+    { unfold proj_value. simpl in IP. des_ifs. simpl in Heq0. clarify.
+      simpl in Heq2, Heq1. rewrite Heq1 in Heq2. clarify. (* simpl in Heq3. *)
+      (* n0 is not 7 *)
+      rewrite nth_error_None in Heq1. unfold rev_if_be_mv in Heq1. des_ifs.
+      rewrite rev_length, length_inj_bytes, encode_int_length in Heq1.
+      simpl in Heq3. repeat rewrite andb_true_iff in Heq3. des. clear - Heq4 Heq1.
+      des_ifs; lia. }
+    { exfalso. destruct v; ss. }
+  - unfold decode_val. erewrite not_bytes_proj_bytes_fail; eauto.
+    2:{ destruct vl; [ss; lia|]. rewrite forallb_false_forall. ii. rewrite forallb_forall in IP.
+        ss. exploit IP; eauto. i. exploit H; eauto. i. destruct m0; ss. des_ifs. destruct m0; ss. }
+    des_ifs. destruct vl; [ss|]. simpl in IP. destruct m0; simpl in IP; clarify.
+    eapply andb_prop in IP. des. des_ifs.
+    { exfalso. destruct v; ss; clarify.
+      - ss. clear - Heq0 IP. unfold rev_if_be_mv in Heq0. des_ifs; ss.
+        eapply nth_error_In in Heq0. rewrite <- in_rev in Heq0.
+        unfold encode_int in Heq0. ss. unfold rev_if_be in Heq0. des_ifs. destruct m0; ss; des; clarify.
+      - des_ifs. ss. clear - Heq0 IP. unfold rev_if_be_mv in Heq0. des_ifs; ss.
+        eapply nth_error_In in Heq0. rewrite <- in_rev in Heq0.
+        unfold encode_int in Heq0. ss. unfold rev_if_be in Heq0. des_ifs. destruct m0; ss. des; clarify. }
+    { unfold proj_value. simpl in IP. des_ifs. simpl in Heq. clarify.
+      simpl in Heq0, Heq1. rewrite Heq0 in Heq1. clarify. (* simpl in Heq2. *)
+      (* n0 is not 7 *)
+      rewrite nth_error_None in Heq0. unfold rev_if_be_mv in Heq0. des_ifs.
+      rewrite rev_length, length_inj_bytes, encode_int_length in Heq0.
+      simpl in Heq2. repeat rewrite andb_true_iff in Heq2. des. clear - Heq3 Heq0.
+      des_ifs; lia. }
+    { exfalso. destruct v; ss. }
+Qed.
+
+Lemma normalize_mvs_decode_val_inject
+    f m1 m2 vl1 vl2 chunk
+    (LEN: (Datatypes.length vl1 > 0)%nat)
+    (CONC: forall b1 b2 delta addr,
+        f b1 = Some (b2, delta) -> valid_block m1 b1 ->
+        m1.(mem_concrete)!b1 = Some addr ->
+        m2.(mem_concrete)!b2 = Some (addr-delta))
+    (MVINJ: list_forall2 (memval_inject f) vl1 vl2):
+  <<VINJ: Val.inject f (decode_val chunk (normalize_mvs chunk m1 vl1))
+                       (decode_val chunk (normalize_mvs chunk m2 vl2))>>.
+Proof.
+  destruct (classic (In Undef vl1)); rename H into UNDEF1.
+  { exploit (in_undef_normalize_in_undef chunk m1); eauto. i. unfold decode_val.
+    rewrite proj_bytes_undef; eauto. do 2 (rewrite proj_value_undef; eauto). des_ifs; econs. }
+  destruct (classic (forall q n, ~ In (Fragment Vundef q n) vl1)); rename H into UNDEF2; cycle 1.
+  { do 2 (eapply not_all_ex_not in UNDEF2; des). eapply NNPP in UNDEF2.
+    exploit (in_undef_frag_normalize_in_undef chunk m1); eauto. i. des. unfold decode_val.
+    erewrite proj_bytes_fragment; eauto. do 2 (erewrite proj_value_undef_frag; eauto). des_ifs; econs. }
+  destruct (is_mixed_mvs vl1) eqn:MIXED.
+  { destruct (classic (chunk = Mint64 \/ chunk = Many64)).
+    2:{ do 2 (rewrite chunk_normalize_mvs64; eauto). exploit (decode_val_inject f vl1 vl2 chunk); eauto. }
+    rename H into CHUNK.
+    assert (MIXED': is_mixed_mvs vl2 = true).
+    { rewrite <- MIXED. symmetry. eapply mix_inject_mix; eauto. }
+    replace (normalize_mvs chunk m1 vl1) with (map (_decode_normalize_mv m1) vl1).
+    2:{ unfold normalize_mvs, normalize_check; rewrite MIXED; des_ifs; des; clarify. }
+    replace (normalize_mvs chunk m2 vl2) with (map (_decode_normalize_mv m2) vl2).
+    2:{ unfold normalize_mvs, normalize_check; rewrite MIXED'; des_ifs; des; clarify. }
+    destruct (proj_bytes (map (_decode_normalize_mv m1) vl1)) eqn:BYTES1.
+    { assert (BYTES2: proj_bytes (map (_decode_normalize_mv m2) vl2) = Some l).
+      { clear - MVINJ CONC MIXED MIXED' BYTES1. eapply mixed_ptrlikes in MIXED, MIXED'. des.
+        ginduction MVINJ; ss; i; clarify. des_ifs_safe. eapply andb_prop in MIXED, MIXED'. des.
+        exploit IHMVINJ; eauto. i. rewrite H0.
+        (* need lemma : src normalize to byte -> tgt too *)
+        assert (_decode_normalize_mv m2 b1 = Byte i).
+        { inv H; ss. des_ifs_safe. dup H1. inv H1; ss.
+          - clarify. ss. rewrite Heq2. ss.
+          - des_ifs_safe. ss. unfold ptr2int in *. des_ifs_safe. erewrite CONC; eauto.
+            2:{ eapply concrete_valid. eauto. }
+            ss. replace (Int64.repr (z0 - delta + Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta))))
+              with (Int64.repr (z0 + Ptrofs.unsigned ofs1)).
+            2:{ eapply Int64.same_if_eq. unfold Int64.eq. do 2 rewrite Int64.unsigned_repr_eq. des_ifs.
+                exfalso. eapply n0. rewrite <- Ptrofs.modulus_eq64; eauto.
+                unfold Ptrofs.add. repeat rewrite Int64.unsigned_repr_eq. repeat rewrite Ptrofs.unsigned_repr_eq.
+                rewrite (Zplus_mod_idemp_r delta). rewrite Zplus_mod_idemp_r.
+                f_equal. lia. }
+            rewrite Heq2. ss. }
+        rewrite H1. auto. }
+      unfold decode_val. rewrite BYTES1, BYTES2. des_ifs; econs. }
+    assert (UNDEF: decode_val chunk (map (_decode_normalize_mv m1) vl1) = Vundef).
+    { (* need lemma : vl mixed -> vl normalize mixed *)
+      assert (MIXED'': is_mixed_mvs (map (_decode_normalize_mv m1) vl1) = true).
+      { clear - BYTES1 MIXED.
+        unfold is_mixed_mvs. repeat rewrite andb_true_iff. splits.
+        - eapply mixed_ptrlikes in MIXED. clear BYTES1. des.
+          rewrite forallb_forall in *. i. exploit list_in_map_inv; eauto. i. des.
+          subst. exploit MIXED; eauto. i. destruct x0; ss. des_ifs. destruct v; ss; clarify.
+          + ss. eapply nth_error_In in Heq0. exploit (inj_bytes_all_bytes (encode_int 8 (Int64.unsigned i))).
+            { rewrite encode_int_length. lia. }
+            unfold rev_if_be_mv in Heq0. des_ifs. rewrite <- in_rev in Heq0.
+            i. des. rewrite forallb_forall in H2. eapply H2 in Heq0. destruct m; ss.
+          + des_ifs. ss. eapply nth_error_In in Heq0.
+            unfold rev_if_be_mv in Heq0. des_ifs. rewrite <- in_rev in Heq0.
+            exploit (inj_bytes_all_bytes (encode_int 8 (Int64.unsigned (Int64.repr z)))).
+            { rewrite encode_int_length. lia. }
+            i. des. rewrite forallb_forall in H2. eapply H2 in Heq0. destruct m; ss.
+        - destruct (forallb is_ptr_mv (map (_decode_normalize_mv m1) vl1)) eqn:PTR; auto.
+          exfalso. unfold is_mixed_mvs in MIXED. repeat rewrite andb_true_iff in MIXED. des.
+          rewrite negb_true_iff in MIXED0. erewrite normalize_result_fragments in PTR; clarify.
+          rewrite forallb_forall in *. ii. exploit PTR; eauto. i. destruct x; ss. }
+      destruct (forallb is_intptr_mv (map (_decode_normalize_mv m1) vl1)) eqn:IP.
+      { eapply normalized_intptr_undef; eauto. unfold normalize_check. des_ifs; des; clarify. }
+      eapply mixed_decode_val_undefs; eauto. unfold is_mixed_mvs_old, is_mixed_mvs in *.
+      rewrite IP. eapply andb_prop in MIXED''. des_safe. ss. clear - BYTES1.
+      erewrite not_bytes_proj_bytes_iff in BYTES1. rewrite BYTES1. ss. }
+    rewrite UNDEF. econs. }
+  assert (MIXED': is_mixed_mvs vl2 = false).
+  { rewrite <- MIXED. symmetry. eapply mix_inject_mix; eauto. }
+  unfold normalize_mvs, normalize_check. rewrite MIXED, MIXED'.
+  exploit (decode_val_inject f vl1 vl2 chunk); eauto. i. destruct chunk; ss.
+Qed.
+
 Lemma load_inj:
-  forall f m1 m2 chunk b1 ofs b2 delta v1,
+  forall f m1 m2 chunk b1 ofs b2 delta v1 (CONC: forall b1 b2 delta addr, f b1 = Some (b2, delta) -> valid_block m1 b1 ->
+                                                                m1.(mem_concrete)!b1 = Some addr ->
+                                                                m2.(mem_concrete)!b2 = Some (addr-delta)),
   mem_inj f m1 m2 ->
   load chunk m1 b1 ofs = Some v1 ->
   f b1 = Some (b2, delta) ->
   exists v2, load chunk m2 b2 (ofs + delta) = Some v2 /\ Val.inject f v1 v2.
 Proof.
   intros.
-  exists (decode_val chunk (getN (size_chunk_nat chunk) (ofs + delta) (m2.(mem_contents)#b2))).
+  exists (decode_val chunk (normalize_mvs chunk m2 (getN (size_chunk_nat chunk) (ofs + delta) (m2.(mem_contents)#b2)))).
   split. unfold load. apply pred_dec_true.
   eapply valid_access_inj; eauto with mem.
   exploit load_result; eauto. intro. rewrite H2.
-  apply decode_val_inject. apply getN_inj; auto.
+  apply normalize_mvs_decode_val_inject; eauto.
+  { rewrite getN_length. unfold size_chunk_nat. destruct chunk; ss; lia. }
+  apply getN_inj; auto.
   rewrite <- size_chunk_conv. exploit load_valid_access; eauto. intros [A B]. auto.
 Qed.
 
@@ -2854,7 +5002,11 @@ Record extends' (m1 m2: mem) : Prop :=
     mext_inj:  mem_inj inject_id m1 m2;
     mext_perm_inv: forall b ofs k p,
       perm m2 b ofs k p ->
-      perm m1 b ofs k p \/ ~perm m1 b ofs Max Nonempty
+      perm m1 b ofs k p \/ ~perm m1 b ofs Max Nonempty;
+    mext_concrete: forall b addr,
+      valid_block m1 b ->
+      m1.(mem_concrete)!b = Some addr ->
+      m2.(mem_concrete)!b = Some addr;
   }.
 
 Definition extends := extends'.
@@ -2868,6 +5020,302 @@ Proof.
   intros. unfold inject_id in H; inv H. replace (ofs + 0) with ofs by lia.
   apply memval_lessdef_refl.
   tauto.
+  eauto.
+Qed.
+
+Theorem valid_block_extends:
+  forall m1 m2 b,
+  extends m1 m2 ->
+  (valid_block m1 b <-> valid_block m2 b).
+Proof.
+  intros. inv H. unfold valid_block. rewrite mext_next0. tauto.
+Qed.
+
+Lemma range_perm_extends m1 m1'
+    (MEXT: extends m1 m1')
+    b ofs chunk k
+    (RPERM: forall o, ofs <= o < ofs + size_chunk chunk ->
+              exists p : permission, (mem_access m1) # b o k = Some p) :
+  forall o, ofs <= o < ofs + size_chunk chunk ->
+    exists p : permission, (mem_access m1') # b o k = Some p.
+Proof.
+  ii. eapply RPERM in H. des.
+  assert (perm m1 b o k p).
+  { unfold perm, perm_order'. rewrite H. eapply perm_refl. }
+  inv MEXT. eapply mi_perm in H0; eauto.
+  2: { unfold inject_id. eauto. }
+  rewrite Z.add_0_r in H0. unfold perm, perm_order' in H0.
+  des_ifs. eauto.
+Qed.
+
+Lemma _weak_valid_pointer_extends m1 m1'
+    (MEXT: extends m1 m1')
+    b ofs k
+    (WVLD: _weak_valid_pointer (mem_access m1) b ofs k) :
+  <<WVLD: _weak_valid_pointer (mem_access m1') b ofs k>>.
+Proof.
+  inv MEXT. inv mext_inj0.
+  unfold _weak_valid_pointer, _valid_pointer in *. ss. des.
+  - eapply mi_perm0 in WVLD; ss.
+    replace (ofs + 0) with ofs in WVLD by lia. eauto.
+  - eapply mi_perm0 in WVLD; ss.
+    replace ((ofs - 1) + 0) with (ofs - 1) in WVLD by lia. eauto.
+Qed.
+
+Lemma capture_extends_backward_aux
+      m1 m2 m2' m1' b addr
+      (CAPTGT: Mem.capture m1' b addr m2')
+      (CAPSRC: Mem.capture m1 b addr m2)
+      (MEXT: Mem.extends m1 m1') :
+    <<MEXT: Mem.extends m2 m2'>>.
+Proof.
+  assert (FB: forall b, inject_id b = Some (b, 0)) by auto.
+  inv CAPTGT. inv CAPSRC. inv MEXT. inv mext_inj0.
+  econs; eauto.
+  - rewrite <- NEXTBLOCK, <- NEXTBLOCK0. auto.
+  - econs; eauto.
+    + i. inv H. unfold perm, perm_order' in H0. des_ifs. ss.
+      exploit mi_perm0; try eapply FB; eauto.
+      { unfold perm, perm_order'. rewrite ACCESS0, Heq. eauto. }
+      i. unfold perm, perm_order' in *. rewrite <- ACCESS. eauto.
+    + unfold range_perm, perm. rewrite <- ACCESS0. auto.
+    + i. inv H. revert H0.
+      unfold perm. rewrite <- ACCESS0. rewrite <- CONTENTS0. rewrite <- CONTENTS. auto.
+  - (* perm_inv *)
+    i. unfold perm in *. rewrite <- ACCESS0.
+    rewrite <- ACCESS in H. eapply mext_perm_inv0 in H. auto.
+  - (* src_concrete *)
+    destruct ((mem_concrete m1) ! b) eqn:SRC_CAPTURED.
+    + i. exploit PREVADDR; eauto. i. des; subst.
+      exploit PREVADDR0; eauto. i. des; subst.
+      rewrite <- H2. rewrite <- H3 in H0.
+      eapply mext_concrete0; eauto.
+      unfold valid_block in *. rewrite NEXTBLOCK0. eauto.
+    + i.
+      destruct (classic (b = b0)); subst.
+      * destruct ((mem_concrete m1') ! b0) eqn:CONCTGT.
+        { exploit PREVADDR; eauto. i. des; subst.
+          rewrite H2 in CONCTGT.
+          rewrite CAPTURED0 in H0; eauto.
+          rewrite PTree.gss in H0. clarify. }
+        rewrite CAPTURED; eauto. rewrite CAPTURED0 in H0; eauto.
+        rewrite PTree.gss in *; eauto.
+      * rewrite CAPTURED0 in H0; eauto. rewrite PTree.gso in H0; eauto.
+        unfold valid_block in H. rewrite <- NEXTBLOCK0 in H.
+        exploit mext_concrete0; eauto. i.
+        erewrite <- concrete_other; eauto. econs; eauto.    
+Qed.
+
+Theorem capture_extends_backward
+    m1 m2' m1' b addr
+    (CAPTGT: capture m1' b addr m2')
+    (MEXT: extends m1 m1') :
+  (exists m2, <<CAPSRC: capture m1 b addr m2>> /\ <<MEXT: extends m2 m2'>>).
+Proof.
+  assert (FB: forall b, inject_id b = Some (b, 0)) by auto.
+  inversion CAPTGT. inversion MEXT.
+  assert (valid_block m1 b).
+  { rewrite (valid_block_extends m1 m1' b); eauto. }
+  destruct ((mem_concrete m1) ! b) eqn:SRC_CAPTURED.
+  (* already captured *)
+  - esplits.
+    (* check capture *)
+    + exploit mext_concrete0; eauto. i.
+      exploit PREVADDR; eauto. i. des. subst.
+      econs; eauto; i; clarify.
+    (* extends preserved *)
+    + econs; eauto.
+      * rewrite mext_next0. auto.
+      * inv mext_inj0. econs.
+        { i. exploit mi_perm0; eauto. i.
+          unfold perm in *. rewrite ACCESS in *. auto. }
+        { i. exploit mi_align0; eauto. }
+        { i. exploit mi_memval0; eauto. i. rewrite CONTENTS in *. auto. }
+      * i. unfold perm, perm_order' in H0. des_ifs; auto.
+        rewrite <- ACCESS in Heq.
+        exploit mext_perm_inv0; eauto.
+        { unfold perm. rewrite Heq. eauto. }
+      * i. exploit mext_concrete0; try eapply SRC_CAPTURED; eauto. i.
+        exploit PREVADDR; eauto. i. des; subst.
+        exploit mext_concrete0; try eapply H1; eauto. i.
+        rewrite <- H4; eauto.
+  (* capture new conc blk *)
+  - rename H into VALID0.
+    inv mext_inj0.
+    assert(NEXT_LOGICAL: forall b' : positive, ~ Plt b' (nextblock m1) -> (PTree.set b addr (mem_concrete m1)) ! b' = None).
+    { i. destruct (peq b' b).
+      - subst. unfold valid_block in VALID0. exfalso. apply H. auto.
+      - exploit PTree.gso. eapply n. i. erewrite H0. eapply (nextblocks_logical m1). eauto. }
+
+    assert (VALID_IN_RANGE: forall (bo : block) (addr0 : Z),
+               addr_in_block (PTree.set b addr (mem_concrete m1)) (mem_access m1) addr0 bo ->
+               addr0 < Ptrofs.modulus - 1).
+    { i. inv H. rewrite PTree.gsspec in CONCRETE. des_ifs.
+      (* about b *)
+      - exploit m2'.(valid_address_bounded); eauto.
+        { econs; ss; des.
+          - destruct ((mem_concrete m1') ! b) eqn:CONCTGT.
+            + exploit PREVADDR; eauto. i. des; subst.
+              rewrite <- H0. eauto.
+            + exploit CAPTURED; eauto. i.
+              rewrite H. rewrite PTree.gss. auto.
+          - rewrite <- ACCESS.
+            assert (perm m1 b (addr0-caddr) Max perm0) by (unfold perm; rewrite PERM; apply perm_refl).
+            exploit mi_perm0; try eapply FB; eauto. i.
+            unfold perm, perm_order' in H0. des_ifs.
+            rewrite Z.add_0_r in Heq. eauto.
+          - eauto. }
+      (* not b1 *)
+      - eapply (valid_address_bounded m1). econs; eauto. }
+
+    assert(NO_CONC_OVLP: forall addr0 : Z, uniqueness (addr_in_block (PTree.set b addr (mem_concrete m1)) (mem_access m1) addr0)).
+    { i. unfold uniqueness. i.
+      assert (AUX: forall a b, (a - b + 0 = a - b)) by (i; lia).
+      inv H; inv H0; ss. des. (* inv CAPTGT. *)
+      rename x into bx. rename y into bewhy.
+      rename caddr into caddrx. rename caddr0 into caddry. ss.
+      assert (SRCPERM1: perm m1 bx (addr0 - caddrx) Max perm1) by (unfold perm; rewrite PERM; apply perm_refl).
+      exploit mi_perm0. eapply FB. eauto. i.
+      assert (TGTPERM1: perm m2' bx (addr0 - caddrx) Max perm1).
+      { unfold perm in *. rewrite <- ACCESS. rewrite <- AUX. auto. }
+      assert (SRCPERM2: perm m1 bewhy (addr0 - caddry) Max perm0) by (unfold perm; rewrite PERM0; apply perm_refl).
+      exploit mi_perm0. eapply FB. eauto. i.
+      assert (TGTPERM2: perm m2' bewhy (addr0 - caddry) Max perm0).
+      { unfold perm in *. rewrite <- ACCESS. rewrite <- AUX. auto. }
+      destruct (classic(bx = b)); destruct (classic(bewhy = b)); subst; auto.
+      (* bx = b /\ by <> b *)
+      - rewrite AUX in *. rename bewhy into b'.
+        rewrite PTree.gss in CONCRETE; eauto. clarify.
+        rewrite PTree.gso in CONCRETE0; eauto.
+        exploit mext_concrete0; try eapply CONCRETE0; i.
+        { eapply NNPP. ii. eapply nextblocks_logical in H1. clarify. }
+        destruct ((mem_concrete m1') ! b) eqn:CONCTGT.
+        + exploit PREVADDR; eauto. i. des; subst.
+          assert (INBLK1: addr_in_block (mem_concrete m1') (mem_access m1') addr0 b).
+          { econs; eauto; ss. unfold perm, perm_order' in *. des_ifs; eauto. }
+          assert (INBLK2: addr_in_block (mem_concrete m1') (mem_access m1') addr0 b').
+          { econs; eauto; ss. unfold perm, perm_order' in *. des_ifs; eauto. }
+          exploit (no_concrete_overlap m1'). eapply INBLK1. eapply INBLK2. eauto.
+        + exploit CAPTURED; eauto. i.
+          assert (INBLK1: addr_in_block (mem_concrete m2') (mem_access m2') addr0 b).
+          { econs; ss.
+            - rewrite H3. rewrite PTree.gss; eauto.
+            - unfold perm, perm_order' in *. des_ifs; eauto.
+            - eauto. }
+          assert (INBLK2: addr_in_block (mem_concrete m2') (mem_access m2') addr0 b').
+          { econs; ss.
+            - rewrite H3. rewrite PTree.gso; eauto.
+            - unfold perm, perm_order' in *. des_ifs; eauto.
+            - eauto. }
+          exploit (no_concrete_overlap m2'). eapply INBLK1. eapply INBLK2. eauto.
+      (* bx <> b /\ by = b *)
+      - rewrite AUX in *. rename bx into b'.
+        rewrite PTree.gso in CONCRETE; eauto.
+        rewrite PTree.gss in CONCRETE0; eauto. clarify.
+        exploit mext_concrete0; try eapply CONCRETE; i.
+        { eapply NNPP. ii. eapply nextblocks_logical in H2. clarify. }  
+        destruct ((mem_concrete m1') ! b) eqn:CONCTGT.
+        + exploit PREVADDR; eauto. i. des; subst.
+          assert (INBLK1: addr_in_block (mem_concrete m1') (mem_access m1') addr0 b).
+          { econs; eauto; ss. unfold perm, perm_order' in *. des_ifs; eauto. }
+          assert (INBLK2: addr_in_block (mem_concrete m1') (mem_access m1') addr0 b').
+          { econs; eauto; ss. unfold perm, perm_order' in *. des_ifs; eauto. }
+          exploit (no_concrete_overlap m1'). eapply INBLK1. eapply INBLK2. eauto.
+        + exploit CAPTURED; eauto. i.
+          assert (INBLK1: addr_in_block (mem_concrete m2') (mem_access m2') addr0 b).
+          { econs; eauto; ss. rewrite H3. rewrite PTree.gss; eauto. unfold perm, perm_order' in *. des_ifs; eauto. }
+          assert (INBLK2: addr_in_block (mem_concrete m2') (mem_access m2') addr0 b').
+          { econs; ss.
+            - rewrite H3. rewrite PTree.gso; eauto.
+            - unfold perm, perm_order' in *. des_ifs; eauto.
+            - eauto. }
+          exploit (no_concrete_overlap m2'). eapply INBLK1. eapply INBLK2. eauto.
+      - rewrite PTree.gso in *; eauto.
+        assert (INBLK1: addr_in_block (mem_concrete m1) (mem_access m1) addr0 bx).
+        { econs; eauto; ss. }
+        assert (INBLK2: addr_in_block (mem_concrete m1) (mem_access m1) addr0 bewhy).
+        { econs; eauto; ss. }
+        exploit (no_concrete_overlap m1). eapply INBLK1. eapply INBLK2. eauto. }
+
+    assert (CONC_ALIGN: forall b' caddr, (PTree.set b addr (mem_concrete m1)) ! b' = Some caddr ->
+                                    forall ofs chunk,
+                                      (forall o, ofs <= o < ofs + size_chunk chunk -> perm_order' ((mem_access m1) # b' o Max) Nonempty) ->
+                                      (align_chunk chunk | caddr)).
+    { ii.
+      destruct (peq b' b).
+      { subst. rewrite PTree.gss in H; eauto. clarify.
+        exploit capture_concrete; eauto. ii. des.
+        eapply (concrete_align m2'); eauto.
+        instantiate (1:=ofs). ii.
+        eapply H0 in H1. rewrite <- ACCESS.
+        exploit mi_perm0; try eapply FB; unfold perm; eauto.
+        replace (o + 0) with o by lia. eauto. }
+      rewrite PTree.gso in H; eauto.
+      eapply (concrete_align m1); eauto. }
+
+    assert (WVLD_RANGE: forall b' caddr ofs, (PTree.set b addr (mem_concrete m1)) ! b' = Some caddr -> 0 <= ofs < Ptrofs.modulus ->
+                                        _weak_valid_pointer (mem_access m1) b' ofs Max ->
+                                        in_range (caddr + ofs) (1, Ptrofs.modulus)).
+    { intros. destruct (peq b' b).
+      { subst. rewrite PTree.gss in H; eauto. clarify.
+        eapply (m2'.(weak_valid_address_range) b); eauto.
+        2: { rewrite <- ACCESS. eapply _weak_valid_pointer_extends; eauto. }
+        destruct ((mem_concrete m1') ! b) eqn:CONC1'; ss.
+        - exploit PREVADDR; eauto. i. des; clarify. rewrite <- H2. eauto.
+        - rewrite CAPTURED; eauto. rewrite PTree.gss; eauto. }
+      rewrite PTree.gso in H; eauto. eapply m1.(weak_valid_address_range); eauto. }
+
+    remember (mkmem (mem_contents m1) (mem_access m1) (PTree.set b addr (mem_concrete m1))
+                (nextblock m1) (access_max m1) (nextblock_noaccess m1) (contents_default m1)
+                NEXT_LOGICAL VALID_IN_RANGE NO_CONC_OVLP CONC_ALIGN WVLD_RANGE) as m2.
+    exists m2.
+
+    assert (SRCCAP: capture m1 b addr m2).
+    { subst. econs; eauto; ss. ii. clarify. }
+    esplits; eauto.
+    exploit capture_extends_backward_aux.
+    { eapply CAPTGT. }
+    all: eauto.
+Qed.
+
+Lemma capture_extends_backward_progress
+    m1 b addr m1' m2
+    (MEXT: extends m1 m1')
+    (CAPTURE: capture m1 b addr m2) :
+  (exists m2' addr', <<CAPTGT: capture m1' b addr' m2'>>) \/ <<OOM: capture_oom m1' b>>.
+Proof.
+  inv CAPTURE; inv MEXT.
+  assert (valid_block m1' b).
+  { unfold valid_block in *. rewrite <- mext_next0. auto. }
+  destruct (classic (exists m2' addr', capture m1' b addr' m2')).
+  - des. left; eauto.
+  - right. red. split; eauto.
+Qed.
+
+Lemma denormalize_extends m z m' b ofs
+    (MEXT: extends m m')
+    (DENO: denormalize z m = Some (b, ofs)) :
+  <<DENOTGT: denormalize z m' = Some (b, ofs)>>.
+Proof.
+  assert (FB: forall b, inject_id b = Some (b, 0)) by auto.
+  exploit mext_inj; eauto. i.
+  eapply denormalize_info in DENO. des.
+  eapply ptr2int_to_denormalize_max; try lia.
+  - unfold ptr2int. erewrite mext_concrete; eauto. f_equal; lia.
+  - eapply mi_perm in PERM; eauto. replace ofs with (ofs + 0) by lia; eauto.
+Qed.
+
+Lemma denormalize_valid_access_extends
+    m z m' b ofs
+    (MEXT: extends m m')
+    (DENO: denormalize z m = Some (b, ofs))
+    chunk p
+    (VA: valid_access m chunk b ofs p) :
+  <<DENOTGT: denormalize z m' = Some (b, ofs)>> /\ <<VA: valid_access m' chunk b ofs p>>.
+Proof.
+  exploit denormalize_extends; eauto. ii. esplit; eauto.
+  eapply mext_inj in MEXT. eapply (valid_access_inj inject_id) in VA; ss; eauto.
+  replace (ofs + 0) with ofs in VA by lia. eauto.
 Qed.
 
 Theorem load_extends:
@@ -2876,12 +5324,32 @@ Theorem load_extends:
   load chunk m1 b ofs = Some v1 ->
   exists v2, load chunk m2 b ofs = Some v2 /\ Val.lessdef v1 v2.
 Proof.
-  intros. inv H. exploit load_inj; eauto. unfold inject_id; reflexivity.
+  intros. inv H. exploit load_inj; eauto.
+  { unfold inject_id. ii; clarify. exploit mext_concrete0; eauto. i. rewrite H. f_equal. lia. }
+  unfold inject_id; reflexivity.
   intros [v2 [A B]]. exists v2; split.
   replace (ofs + 0) with ofs in A by lia. auto.
   rewrite val_inject_id in B. auto.
 Qed.
 
+Theorem load_extends_backward
+    chunk m1 m2 b ofs v2
+    (MEXT: extends m1 m2)
+    (LOADTGT: load chunk m2 b ofs = Some v2) :
+  (exists v1, <<LOADSRC: load chunk m1 b ofs = Some v1>> /\ <<VLD: Val.lessdef v1 v2>>)
+  \/ (<<LOADFAIL: load chunk m1 b ofs = None>>).
+Proof.
+  destruct (load chunk m1 b ofs) eqn:LOADSRC; cycle 1.
+  { eauto. }
+  left. esplits; eauto.
+  exploit load_inj; try eapply MEXT; eauto.
+  { unfold inject_id. ii; clarify. erewrite mext_concrete; eauto. rewrite H1. f_equal. lia. }
+  { unfold inject_id; reflexivity. }
+  intros [v2' [A B]].
+  replace (ofs + 0) with ofs in A by lia. clarify.
+  rewrite val_inject_id in B. auto.
+Qed.
+
 Theorem loadv_extends:
   forall chunk m1 m2 addr1 addr2 v1,
   extends m1 m2 ->
@@ -2889,8 +5357,14 @@ Theorem loadv_extends:
   Val.lessdef addr1 addr2 ->
   exists v2, loadv chunk m2 addr2 = Some v2 /\ Val.lessdef v1 v2.
 Proof.
-  unfold loadv; intros. inv H1.
-  destruct addr2; try congruence. eapply load_extends; eauto.
+  intros. inv H1.
+  { unfold loadv, to_ptr in H0. des_ifs.
+    - dup H0. unfold load in H0. des_ifs. exploit denormalize_valid_access_extends; eauto.
+      { instantiate (1:=Readable). instantiate (1:=chunk). eapply denormalize_info in Heq2; eauto.
+        des. rewrite Ptrofs.unsigned_repr in v; try lia. eauto. }
+      i. des. unfold loadv, to_ptr. rewrite DENOTGT. des_ifs_safe. eapply load_extends; eauto.
+    - ss. eapply load_extends; eauto. }
+  unfold loadv in H0. simpl in H0.
   congruence.
 Qed.
 
@@ -2927,6 +5401,8 @@ Proof.
   rewrite (nextblock_store _ _ _ _ _ _ A).
   auto.
   intros. exploit mext_perm_inv0; intuition eauto using perm_store_1, perm_store_2.
+  unfold store in H0. destruct (valid_access_dec m1 chunk b ofs Writable); inversion H0.
+  unfold store in A. destruct (valid_access_dec m2 chunk b (ofs+0) Writable); inversion A. simpl. assumption.
 Qed.
 
 Theorem store_outside_extends:
@@ -2941,6 +5417,9 @@ Proof.
   eapply store_outside_inj; eauto.
   unfold inject_id; intros. inv H2. eapply H1; eauto. lia.
   intros. eauto using perm_store_2.
+  assert (mem_concrete m2 = mem_concrete m2').
+  { unfold store in *. des_ifs. }
+  rewrite H2 in *. eauto.
 Qed.
 
 Theorem storev_extends:
@@ -2953,8 +5432,12 @@ Theorem storev_extends:
      storev chunk m2 addr2 v2 = Some m2'
   /\ extends m1' m2'.
 Proof.
-  unfold storev; intros. inv H1.
-  destruct addr2; try congruence. eapply store_within_extends; eauto.
+  intros. inv H1.
+  { unfold storev in H0. des_ifs.
+    - dup H0. unfold store in H0. des_ifs. exploit denormalize_valid_access_extends; eauto.
+      i. des. unfold storev. rewrite DENOTGT. eapply store_within_extends; eauto.
+    - ss. eapply store_within_extends; eauto. }
+  simpl in *.
   congruence.
 Qed.
 
@@ -2979,6 +5462,9 @@ Proof.
   rewrite (nextblock_storebytes _ _ _ _ _ A).
   auto.
   intros. exploit mext_perm_inv0; intuition eauto using perm_storebytes_1, perm_storebytes_2.
+  unfold storebytes in H0. destruct (range_perm_dec m1 b ofs (ofs + Z.of_nat (length bytes1)) Cur Writable); inversion H0.
+  unfold storebytes in A. destruct (range_perm_dec m2 b (ofs + 0) (ofs + 0 + Z.of_nat (length bytes2)) Cur Writable); inversion A.
+  simpl. assumption.
 Qed.
 
 Theorem storebytes_outside_extends:
@@ -2993,6 +5479,9 @@ Proof.
   eapply storebytes_outside_inj; eauto.
   unfold inject_id; intros. inv H2. eapply H1; eauto. lia.
   intros. eauto using perm_storebytes_2.
+  assert (mem_concrete m2 = mem_concrete m2').
+  { unfold storebytes in *. des_ifs. }
+  rewrite <- H2 in *. eauto.
 Qed.
 
 Theorem alloc_extends:
@@ -3033,6 +5522,11 @@ Proof.
   left. apply perm_implies with Freeable; auto with mem. eapply perm_alloc_2; eauto.
   right; tauto.
   exploit mext_perm_inv0; intuition eauto using perm_alloc_1, perm_alloc_4.
+  i. exploit concrete_alloc. eapply H0. i.
+  exploit concrete_alloc. eapply ALLOC. i.
+  rewrite <- H4 in H3. rewrite <- H5. eapply mext_concrete0; eauto.
+  exploit valid_block_alloc_inv; try eapply H0; eauto. ii; des; clarify.
+  eapply fresh_block_alloc in H0. eapply nextblocks_logical in H0. clarify.
 Qed.
 
 Theorem free_left_extends:
@@ -3048,6 +5542,10 @@ Proof.
   eapply perm_free_inv in A; eauto. destruct A as [[A B]|A]; auto.
   subst b0. right; eapply perm_free_2; eauto.
   intuition eauto using perm_free_3.
+  ii. exploit concrete_free; eauto. i.
+  rewrite <- H2 in H1.
+  eapply mext_concrete0; eauto.
+  exploit nextblock_free; eauto. i. unfold valid_block in *. rewrite <- H3; eauto.
 Qed.
 
 Theorem free_right_extends:
@@ -3062,6 +5560,9 @@ Proof.
   eapply free_right_inj; eauto.
   unfold inject_id; intros. inv H. eapply H1; eauto. lia.
   intros. eauto using perm_free_3.
+  ii. exploit concrete_free; eauto. i.
+  rewrite <- H3.
+  eapply mext_concrete0; eauto.
 Qed.
 
 Theorem free_parallel_extends:
@@ -3090,14 +5591,10 @@ Proof.
   eapply perm_free_inv in A; eauto. destruct A as [[A B]|A]; auto.
   subst b0. right; eapply perm_free_2; eauto.
   right; intuition eauto using perm_free_3.
-Qed.
-
-Theorem valid_block_extends:
-  forall m1 m2 b,
-  extends m1 m2 ->
-  (valid_block m1 b <-> valid_block m2 b).
-Proof.
-  intros. inv H. unfold valid_block. rewrite mext_next0. tauto.
+  ii. exploit concrete_free. eapply H0. i.
+  exploit concrete_free. eapply FREE. i.
+  rewrite <- H4. rewrite <- H3 in H2. eapply mext_concrete0; eauto.
+  exploit nextblock_free; try eapply H0; eauto. i. unfold valid_block in *. rewrite <- H5; eauto.
 Qed.
 
 Theorem perm_extends:
@@ -3141,6 +5638,30 @@ Proof.
   intros []; eauto using valid_pointer_extends.
 Qed.
 
+Lemma to_ptr_extends m v v' m' v''
+    (MEXT: extends m m')
+    (LESS: Val.lessdef v v')
+    (TOPTR: to_ptr v m = Some v''):
+  <<TOPTRTGT: to_ptr v' m' = Some v''>>.
+Proof.
+  inv LESS; ss. destruct v'; ss. des_ifs.
+  { exploit denormalize_extends; try eapply Heq2; eauto. i. des. clarify. }
+  exploit denormalize_extends; try eapply Heq1; eauto. i. des. clarify.
+Qed.
+
+Lemma to_int_extends m v v' m' v''
+    (MEXT: extends m m')
+    (LESS: Val.lessdef v v')
+    (TOINT: to_int v m = Some v'') :
+  <<TOINTTGT: to_int v' m' = Some v''>>.
+Proof.
+  inv LESS; ss. destruct v'; ss; clarify. unfold ptr2int in *. des_ifs.
+  { eapply mext_concrete in MEXT; eauto; clarify.
+    eapply NNPP. ii. eapply nextblocks_logical in H. clarify. }
+  eapply mext_concrete in MEXT; eauto; clarify.
+  eapply NNPP. ii. eapply nextblocks_logical in H. clarify.
+Qed.
+
 (** * Memory injections *)
 
 (** A memory state [m1] injects into another memory state [m2] via the
@@ -3176,7 +5697,15 @@ Record inject' (f: meminj) (m1 m2: mem) : Prop :=
       forall b1 ofs b2 delta k p,
       f b1 = Some(b2, delta) ->
       perm m2 b2 (ofs + delta) k p ->
-      perm m1 b1 ofs k p \/ ~perm m1 b1 ofs Max Nonempty
+      perm m1 b1 ofs k p \/ ~perm m1 b1 ofs Max Nonempty;
+    mi_src_concrete_public
+      b1 b2 delta addr
+      (INJECT: f b1 = Some(b2, delta))
+      (CONCRETE: m1.(mem_concrete)!b1 = Some addr):
+      m2.(mem_concrete)!b2 = Some (addr-delta);
+    mi_src_concrete_private
+      b (NOINJECT: f b = None):
+      m1.(mem_concrete)!b = None;
   }.
 Definition inject := inject'.
 
@@ -3443,6 +5972,563 @@ Proof.
   congruence.
 Qed.
 
+Lemma addr_in_block_inject
+  f m m'
+  (MINJ: inject f m m')
+  b b' delta
+  (FB: f b = Some (b', delta))
+  addr
+  (INBLKSRC: addr_in_block (mem_concrete m) (mem_access m) addr b) :
+  <<INBLKTGT: addr_in_block (mem_concrete m') (mem_access m') addr b'>>
+.
+Proof.
+  inv INBLKSRC. des.
+  exploit mi_src_concrete_public; eauto. ii.
+  assert (perm m b (addr-caddr) Max perm0) by (unfold perm; rewrite PERM; apply perm_refl).
+  exploit mi_perm; eauto; ii.
+  { eapply mi_inj; eauto. }
+  econs; eauto.
+  { unfold perm, perm_order' in H1. des_ifs.
+    replace (addr - (caddr - delta)) with (addr - caddr + delta) by lia. eauto. }
+  exploit mi_representable; eauto.
+  { left. instantiate (1:=Ptrofs.repr (addr - caddr)).
+    erewrite Ptrofs.unsigned_repr; eauto.
+    2: { unfold Ptrofs.max_unsigned in *. lia. }
+    unfold perm, perm_order'. des_ifs. eapply perm_any_N. }
+  ii. des.
+  erewrite Ptrofs.unsigned_repr in H4; eauto.
+  2: { unfold Ptrofs.max_unsigned in *. lia. }
+  unfold Ptrofs.max_unsigned in *. lia.
+Qed.
+
+(** Preservation of inject with regards to the capture operation **)
+
+Lemma capture_inject_backward_aux
+    m1 m2 m1' m2' f b1 b2 addr delta
+    (INJECT: inject f m1 m1')
+    (CAPTURE1: capture m1' b2 (addr - delta) m2')
+    (CAPTURE2: capture m1 b1 addr m2)
+    (FB: f b1 = Some(b2, delta)) :
+  inject f m2 m2'.
+Proof.
+  inversion INJECT. split.
+  - inv mi_inj0. inv CAPTURE1. inv CAPTURE2.
+    split.
+    (* perm *)
+    + unfold perm. rewrite <- ACCESS. rewrite <- ACCESS0. auto.
+    (* align *)
+    + unfold range_perm, perm. rewrite <- ACCESS0. auto.
+    (* mem_val *)
+    + unfold perm. rewrite <- ACCESS0. rewrite <- CONTENTS0. rewrite <- CONTENTS. auto.
+  (* freeblocks *)
+  - inv CAPTURE2. unfold valid_block.
+    rewrite <- NEXTBLOCK. auto.
+  (* mappedblocks *)
+  - i. unfold valid_block in *. inversion CAPTURE1. rewrite <- NEXTBLOCK.
+    apply mi_mappedblocks0 with (b:= b) (delta:=delta0). auto.
+  (* meminj_no_overlap *)
+  - unfold meminj_no_overlap in *. intros.
+    apply mi_no_overlap0 with (b1:=b0) (b2:=b3); try assumption;
+      inv CAPTURE2; unfold perm in *; rewrite ACCESS; auto.
+  (* representable *)
+  - i. apply mi_representable0 with b b'. auto.
+    inv CAPTURE2. unfold perm in *. rewrite ACCESS. auto.
+  (* perm_inv *)
+  - i. inv CAPTURE2. unfold perm in *. rewrite <- ACCESS.
+    apply mi_perm_inv0 with b3 delta0. auto.
+    inv CAPTURE1. rewrite ACCESS0. auto.
+  (* src_concrete *)
+  - inversion CAPTURE1. inversion CAPTURE2. intros bm1 bm2 deltam addrm HM HBM1.
+    destruct (Pos.eq_dec bm1 b1); destruct (Pos.eq_dec bm2 b2); subst.
+    (* b = bm1, b' = bm2 *)
+    + rewrite FB in HM. inv HM.
+      destruct ((mem_concrete m1)!b1) eqn:SRC_CAP.
+      * exploit PREVADDR; eauto. i. des. rewrite <- H0.
+        exploit PREVADDR0; eauto. i. des. rewrite <- H2 in HBM1.
+        exploit mi_src_concrete_public0; eauto.
+      * destruct ((mem_concrete m1')!b2) eqn:TGT_CAP.
+        { exploit PREVADDR; eauto. i. des.
+          exploit CAPTURED0; eauto. i. subst. rewrite <- H0.
+          rewrite H1 in HBM1. rewrite PTree.gss in HBM1. clarify. }
+        exploit CAPTURED0; eauto. i. exploit CAPTURED. eauto. i.
+        rewrite H in HBM1. rewrite H0. rewrite PTree.gss in *. clarify.
+    (* b = bm1, b' <> bm2 *)
+    + rewrite HM in FB. inv FB.
+      unfold not in n. exfalso. apply n. auto.
+    (* b <> bm1, b' = bm2 *)
+    + exploit concrete_other; try eapply n1; eauto. i.
+      rewrite HBM1 in H.
+      exploit mi_src_concrete_public0; eauto. i.
+      exploit PREVADDR; eauto. i. des. rewrite <- H2. auto.
+    (* b <> bm1, b' <> bm2 *)
+    + exploit concrete_other; try eapply n; eauto. i.
+      exploit concrete_other; try eapply n0; eauto. i.
+      rewrite <- H0. apply mi_src_concrete_public0 with (b1:=bm1).
+      auto. rewrite H. auto.
+  (* src private *)
+  - i. inversion CAPTURE2. destruct (Pos.eq_dec b b1); subst.
+    + rewrite FB in NOINJECT. inv NOINJECT.
+    + exploit concrete_other. eapply CAPTURE2. eauto. i. rewrite <- H. apply mi_src_concrete_private0. auto.
+Qed.
+
+Theorem capture_inject_backward
+    m1 m2' m1' f b1 b2 addr delta
+    (INJECT: inject f m1 m1')
+    (CAPTURE: capture m1' b2 (addr-delta) m2')
+    (FB: f b1 = Some(b2, delta)) :
+  exists m2, <<CAPSRC: capture m1 b1 addr m2>> /\ <<MEM: inject f m2 m2'>>.
+Proof.
+  inversion INJECT. inv mi_inj0. inversion CAPTURE; subst. unfold meminj_no_overlap in *.
+  des. exploit valid_block_inject_1; try eapply FB;  eauto. i.
+  destruct ((mem_concrete m1) ! b1) eqn:SRC_CAPTURED.
+  (* already captured *)
+  - exists m1. exploit mi_src_concrete_public0. eapply FB. eapply SRC_CAPTURED. i.
+    exploit PREVADDR; eauto. i. des. rewrite Z.sub_cancel_r in H1. symmetry in H1. subst.
+    assert (SRCCAP: capture m1 b1 z m1).
+    { econs; eauto; i; clarify. }
+    split; auto. exploit capture_inject_backward_aux; eauto.
+  (* capture new concrete memory in src *)
+  - rename H into VALID0.
+    assert(NEXT_LOGICAL: forall b : positive, ~ Plt b (nextblock m1) -> (PTree.set b1 addr (mem_concrete m1)) ! b = None).
+    { i. destruct (peq b b1).
+      subst. unfold valid_block in VALID0. exfalso. apply H. auto.
+      exploit PTree.gso. eapply n. i. erewrite H0. eapply (nextblocks_logical m1). eauto. }
+
+    assert (VALID_IN_RANGE: forall bo addr0,
+                              addr_in_block (PTree.set b1 addr (mem_concrete m1)) (mem_access m1) addr0 bo ->
+                              addr0 < Ptrofs.modulus - 1).
+    { i. inv H.
+      destruct (peq bo b1).
+      (* about b1 *)
+      - rewrite e in *. rewrite PTree.gss in CONCRETE. inversion CONCRETE. rewrite <- H0 in *. clear e CONCRETE H0.
+        exploit (m2'.(valid_address_bounded) b2 addr0); eauto.
+        { econs; ss.
+          - destruct ((mem_concrete m1') ! b2) eqn:CPT_TGT.
+            + exploit PREVADDR; eauto. i. des. subst. rewrite <- H0. eauto.
+            + exploit CAPTURED; eauto. i. rewrite H. rewrite PTree.gss. auto.
+          - assert (AUX1: addr0-addr+delta= addr0-(addr-delta)) by lia.
+            rewrite <- AUX1. rewrite <- ACCESS. des.
+            assert (perm m1 b1 (addr0-addr) Max perm0) by (unfold perm; rewrite PERM; apply perm_refl).
+            exploit mi_perm0; try eapply FB; eauto. i.
+            unfold perm, perm_order' in H0. des_ifs. eauto.
+          - replace (addr0 - (addr - delta)) with (addr0 - addr + delta) by lia.
+            destruct PERM as [p PERM].
+            exploit mi_representable0; try eapply FB; eauto.
+            { instantiate (1:=Ptrofs.repr (addr0 - addr)).
+              left. rewrite Ptrofs.unsigned_repr; eauto.
+              2: { unfold Ptrofs.max_unsigned. lia. }
+              unfold perm. rewrite PERM. ss. eapply perm_any_N. }
+            rewrite Ptrofs.unsigned_repr; eauto.
+            2: { unfold Ptrofs.max_unsigned in *. lia. }
+            unfold Ptrofs.max_unsigned in *. lia. }
+      (* not b1 *)
+      - eapply (valid_address_bounded m1). econs; eauto.
+        erewrite PTree.gso in CONCRETE; auto. }
+
+    assert(NO_CONC_OVLP: forall addr0 : Z, uniqueness (addr_in_block (PTree.set b1 addr (mem_concrete m1)) (mem_access m1) addr0)).
+    { i. unfold uniqueness. i.
+      destruct (classic(x = b1)); destruct (classic(y = b1)); subst; auto.
+      (* y <> = (b1, addr) *)
+      - inv H; inv H0; ss. des.
+        rename y into b1'.
+        destruct (peq b1 b1'); subst; clarify.
+        erewrite PTree.gso in CONCRETE0; auto.
+        rewrite PTree.gss in CONCRETE.
+        destruct (f b1') eqn:FB'; cycle 1.
+        { exploit mi_src_concrete_private0; eauto. i. clarify. }
+        destruct p as [b2' delta']. clarify.
+        assert (SRCPERM1: perm m1 b1 (addr0 - caddr) Max perm1) by (unfold perm; rewrite PERM; apply perm_refl).
+        exploit mi_perm0. eapply FB. eauto. i.
+        assert (TGTPERM1: perm m2' b2 (addr0 - caddr + delta) Max perm1).
+        { unfold perm in *. rewrite <- ACCESS. auto. }
+        assert (SRCPERM2: perm m1 b1' (addr0 - caddr0) Max perm0) by (unfold perm; rewrite PERM0; apply perm_refl).
+        exploit mi_perm0. eapply FB'. eauto. i.
+        assert (TGTPERM2: perm m2' b2' (addr0 - caddr0+delta') Max perm0).
+        { unfold perm in *. rewrite <- ACCESS. auto. }
+        unfold perm, perm_order' in TGTPERM1, TGTPERM2. des_ifs.
+        exploit mi_src_concrete_public0; eauto. i.
+
+        assert (INBLK1: addr_in_block (mem_concrete m2') (mem_access m2') addr0 b2).
+        { econs. 
+          - destruct ((mem_concrete m1') ! b2) eqn:TGT_CPT.
+            + exploit PREVADDR; eauto. i. des. subst. rewrite <- H4. eauto.
+            + exploit CAPTURED; eauto. i. rewrite H3. rewrite PTree.gss. auto.
+          - assert ((addr0 - caddr + delta) = (addr0 - (caddr - delta))) by lia.
+            rewrite <- H3. eauto.
+          - exploit mi_representable0; try eapply FB; eauto.
+            { instantiate (1 := Ptrofs.repr (addr0 - caddr)).
+              rewrite Ptrofs.unsigned_repr; eauto.
+              2 :{ unfold Ptrofs.max_unsigned in *. lia. }
+              left. eapply perm_implies; eauto. eapply perm_any_N. }
+            rewrite Ptrofs.unsigned_repr; eauto.
+            2 :{ unfold Ptrofs.max_unsigned in *. lia. }
+            unfold Ptrofs.max_unsigned in *. lia. }
+        exploit perm_implies; try eapply SRCPERM1; eauto. eapply perm_any_N. i.
+        exploit perm_implies; try eapply SRCPERM2; eauto. eapply perm_any_N. i.
+        exploit mi_no_overlap0; eauto. unfold perm. i. des; cycle 1.
+        (* b2 = b2' *)
+        + assert (INBLK2: addr_in_block (mem_concrete m2') (mem_access m2') addr0 b2').
+          { destruct (peq b2 b2').
+            (* b2 = b2' *)
+            - subst. eauto.
+            (* b2 <> b2' *)
+            - econs.
+              + destruct ((mem_concrete m1') ! b2) eqn:TGT_CPT.
+                * exploit PREVADDR; eauto. i. des. subst. rewrite <- H7. eauto.
+                * exploit CAPTURED; eauto. i. rewrite H6. erewrite PTree.gso; eauto.
+              + assert ((addr0 - caddr0 + delta') = (addr0 - (caddr0 - delta'))) by lia.
+                rewrite <- H6. eauto.
+              + exploit mi_representable0; try eapply FB'; eauto.
+                { instantiate (1:= Ptrofs.repr (addr0 - caddr0)).
+                  left. rewrite Ptrofs.unsigned_repr; eauto.
+                  unfold Ptrofs.max_unsigned in *. lia. }
+                rewrite Ptrofs.unsigned_repr; eauto; [unfold Ptrofs.max_unsigned in *; lia|unfold Ptrofs.max_unsigned in *; lia]. }
+          exploit (no_concrete_overlap m2'). eapply INBLK1. eapply INBLK2. i. inv H6.
+          exploit PREVADDR; eauto. i. des. lia.
+        (* b2 <> b2' *)
+        + assert (INBLK2: addr_in_block (mem_concrete m2') (mem_access m2') addr0 b2').
+          { econs.
+            - destruct ((mem_concrete m1') ! b2) eqn:TGT_CPT.
+              * exploit PREVADDR; eauto. i. des. subst. rewrite <- H7. eauto.
+              * exploit CAPTURED; eauto. i. rewrite H6. erewrite PTree.gso; eauto.
+            - assert ((addr0 - caddr0 + delta') = (addr0 - (caddr0 - delta'))) by lia.
+              rewrite <- H6. eauto.
+            - exploit mi_representable0; try eapply FB'; eauto.
+              { instantiate (1:= Ptrofs.repr (addr0 - caddr0)).
+                left. rewrite Ptrofs.unsigned_repr; eauto.
+                unfold Ptrofs.max_unsigned in *. lia. }
+              rewrite Ptrofs.unsigned_repr; eauto.
+              unfold Ptrofs.max_unsigned in *. lia.
+              unfold Ptrofs.max_unsigned in *. lia. }
+          exploit (no_concrete_overlap m2'). eapply INBLK1. eapply INBLK2. i. inv H6. contradiction.
+      (* same as upper case *)
+      - inv H; inv H0; ss. des. rename x into b1'.
+        destruct (peq b1 b1'); subst; clarify.
+        erewrite PTree.gso in CONCRETE; auto.
+        rewrite PTree.gss in CONCRETE0.
+        destruct (f b1') eqn:FB'; cycle 1.
+        { exploit mi_src_concrete_private0; eauto. i. clarify. }
+        destruct p as [b2' delta'].
+        assert (SRCPERM1: perm m1 b1 (addr0 - caddr0) Max perm0) by (unfold perm; rewrite PERM0; apply perm_refl).
+        exploit mi_perm0. eapply FB. eauto. i.
+        assert (TGTPERM1: perm m2' b2 (addr0 - caddr0 + delta) Max perm0).
+        { unfold perm in *. rewrite <- ACCESS. auto. }
+        assert (SRCPERM2: perm m1 b1' (addr0 - caddr) Max perm1) by (unfold perm; rewrite PERM; apply perm_refl).
+        exploit mi_perm0. eapply FB'. eauto. i.
+        assert (TGTPERM2: perm m2' b2' (addr0 - caddr + delta') Max perm1).
+        { unfold perm in *. rewrite <- ACCESS. auto. }
+        unfold perm, perm_order' in TGTPERM1, TGTPERM2. des_ifs.
+        exploit mi_src_concrete_public0; eauto. i.
+        exploit perm_implies; try eapply SRCPERM2. eapply perm_any_N. i.
+        exploit perm_implies; try eapply SRCPERM1. eapply perm_any_N. i.
+
+        assert (INBLK1: addr_in_block (mem_concrete m2') (mem_access m2') addr0 b2).
+        { econs.
+          - destruct ((mem_concrete m1') ! b2) eqn:TGT_CPT.
+            + exploit PREVADDR; eauto. i. des. subst. rewrite <- H6. eauto.
+            + exploit CAPTURED; eauto. i. rewrite H5. rewrite PTree.gss. auto.
+          - assert ((addr0 - caddr0 + delta) = (addr0 - (caddr0 - delta))) by lia.
+            rewrite <- H5. eauto.
+          - exploit mi_representable0; try eapply FB; eauto.
+            { instantiate (1:= Ptrofs.repr (addr0 - caddr0)).
+              left. rewrite Ptrofs.unsigned_repr; eauto.
+              unfold Ptrofs.max_unsigned in *. lia. }
+            rewrite Ptrofs.unsigned_repr; eauto; [unfold Ptrofs.max_unsigned in *; lia|unfold Ptrofs.max_unsigned in *; lia]. }
+        exploit mi_no_overlap0; eauto. unfold perm. i. des; cycle 1.
+        (* b2 = b2' *)
+        + assert (INBLK2: addr_in_block (mem_concrete m2') (mem_access m2') addr0 b2').
+          { destruct (peq b2 b2').
+            (* b2 = b2' *)
+            - subst. eauto.
+            (* b2 <> b2' *)
+            - econs.
+              + destruct ((mem_concrete m1') ! b2) eqn:TGT_CPT.
+                * exploit PREVADDR; eauto. i. des. subst. rewrite <- H7. eauto.
+                * exploit CAPTURED; eauto. i. rewrite H6. erewrite PTree.gso; eauto.
+              + assert ((addr0 - caddr + delta') = (addr0 - (caddr - delta'))) by lia.
+                rewrite <- H6. eauto.
+              + exploit mi_representable0; try eapply FB'; eauto.
+                { instantiate (1:= Ptrofs.repr (addr0 - caddr)).
+                  left. rewrite Ptrofs.unsigned_repr; eauto.
+                  unfold Ptrofs.max_unsigned in *. lia. }
+                rewrite Ptrofs.unsigned_repr; eauto; [unfold Ptrofs.max_unsigned in *; lia|unfold Ptrofs.max_unsigned in *; lia]. }
+          exploit (no_concrete_overlap m2'). eapply INBLK1. eapply INBLK2. i. inv H6.
+          exploit PREVADDR; eauto. i. lia.
+        (* b2 <> b2' *)
+        + assert (INBLK2: addr_in_block (mem_concrete m2') (mem_access m2') addr0 b2').
+          { econs.
+            - destruct ((mem_concrete m1') ! b2) eqn:TGT_CPT.
+              * exploit PREVADDR; eauto. i. des. subst. rewrite <- H7. eauto.
+              * exploit CAPTURED; eauto. i. rewrite H6. erewrite PTree.gso; eauto.
+            - assert ((addr0 - caddr + delta') = (addr0 - (caddr - delta'))) by lia.
+              rewrite <- H6. eauto.
+            - exploit mi_representable0; try eapply FB'; eauto.
+              { instantiate (1:= Ptrofs.repr (addr0 - caddr)).
+                left. rewrite Ptrofs.unsigned_repr; eauto.
+                unfold Ptrofs.max_unsigned in *. lia. }
+              rewrite Ptrofs.unsigned_repr; eauto; [unfold Ptrofs.max_unsigned in *; lia|unfold Ptrofs.max_unsigned in *; lia]. }
+          exploit (no_concrete_overlap m2'). eapply INBLK1. eapply INBLK2. i. inv H6. contradiction.
+      (* x, y <> (b1, addr) *)
+      - rename x into bx. rename y into bewhy.
+        inv H; inv H0. des. ss.
+        destruct (peq bx b1); destruct (peq bewhy b1); subst.
+        (* b1 = bx = by *)
+        + rewrite PTree.gss in *. clarify.
+        (* bx = b1 /\ by <> b1 *)
+        + rewrite PTree.gss in CONCRETE. clarify.
+        (* bx <> b1 /\ by = b1 *)
+        + rewrite PTree.gss in CONCRETE0. clarify.
+        (* bx <> b1 /\ by <> b1 *)
+        + rewrite PTree.gso in *; eauto.
+          assert (INBLK1: addr_in_block (mem_concrete m1) (mem_access m1) addr0 bx) by (econs; eauto).
+          assert (INBLK2: addr_in_block (mem_concrete m1) (mem_access m1) addr0 bewhy) by (econs; eauto).
+          exploit (no_concrete_overlap m1). eapply INBLK1. eapply INBLK2. auto. }
+
+    assert (CONC_ALIGN: forall b1' caddr, (PTree.set b1 addr (mem_concrete m1)) ! b1' = Some caddr ->
+                            forall ofs chunk,
+                              (forall o, ofs <= o < ofs + size_chunk chunk -> perm_order' ((mem_access m1) # b1' o Max) Nonempty) ->
+                                (align_chunk chunk | caddr)).
+      { ii. destruct (peq b1' b1).
+        { subst. rewrite PTree.gss in H; eauto. clarify.
+          exploit capture_concrete; eauto. ii. des.
+          assert (ALIGNTGT: ((align_chunk chunk) | (caddr - delta))).
+          { eapply (concrete_align m2') in H; eauto.
+            instantiate (1:= (ofs + delta)). ii.
+            exploit range_perm_inject; [eauto|eauto| | | ].
+            { unfold range_perm. eauto. }
+            { instantiate (1:=o). lia. }
+            rewrite <- ACCESS. eauto. }
+          exploit mi_align0; try eapply FB.
+          { unfold range_perm. eapply H0. }
+          ii. eapply Z.divide_add_r with (m:= delta) (p:=caddr-delta) in ALIGNTGT; eauto.
+          replace (delta + (caddr - delta)) with caddr in ALIGNTGT by lia. eauto. }
+        rewrite PTree.gso in H; eauto.
+        eapply (concrete_align m1); eauto. }
+
+      assert (WVLD_RANGE: forall b1' caddr ofs, (PTree.set b1 addr (mem_concrete m1)) ! b1' = Some caddr ->
+                                           0 <= ofs < Ptrofs.modulus ->
+                                           _weak_valid_pointer (mem_access m1) b1' ofs Max ->
+                                           in_range (caddr + ofs) (1, Ptrofs.modulus)).
+      { intros. destruct (peq b1' b1).
+        2:{ subst. rewrite PTree.gso in H; eauto. clarify. eapply m1.(weak_valid_address_range); eauto. }
+        subst. rewrite PTree.gss in H; eauto. clarify.
+        exploit (weak_valid_address_range m2' b2 (caddr - delta) (ofs + delta)); eauto.
+        { destruct ((mem_concrete m1') ! b2) eqn:CONC1'.
+          - exploit PREVADDR; eauto. i. des. subst. rewrite <- H2. eauto.
+          - rewrite CAPTURED; eauto. rewrite PTree.gss; eauto. }
+        { exploit mi_representable0; eauto.
+          { instantiate (1:= (Ptrofs.repr ofs)). rewrite Ptrofs.unsigned_repr.
+            2: { unfold Ptrofs.max_unsigned in *. lia. }
+            unfold _weak_valid_pointer in H1. unfold perm. des; eauto. }
+          i. rewrite Ptrofs.unsigned_repr in H; unfold Ptrofs.max_unsigned in *; lia. }
+        { rewrite <- ACCESS. unfold _weak_valid_pointer, _valid_pointer in *.
+          des; [left; eapply mi_perm0; eauto|right].
+          replace (ofs + delta - 1) with ((ofs - 1) + delta) by lia. eapply mi_perm0; eauto. }
+        replace (caddr - delta + (ofs + delta)) with (caddr + ofs) by lia. ss. }
+          
+    remember (mkmem (mem_contents m1) (mem_access m1) (PTree.set b1 addr (mem_concrete m1))
+                    (nextblock m1) (access_max m1) (nextblock_noaccess m1) (contents_default m1)
+                    NEXT_LOGICAL VALID_IN_RANGE NO_CONC_OVLP CONC_ALIGN WVLD_RANGE) as m2.
+    exists m2.
+    assert (SRCCAP: capture m1 b1 addr m2).
+    { subst. econs; eauto; ss; i. ii. clarify. }
+    esplits; auto. exploit capture_inject_backward_aux; eauto.
+Qed.
+
+Lemma capture_injects_backward_progress
+    m1 b1 addr m1' f m2 b2 delta
+    (INJECT: inject f m1 m1')
+    (CAPTURE: capture m1 b1 addr m2)
+    (FB: f b1 = Some (b2, delta)) :
+  (exists m2' addr', <<CAPTGT: capture m1' b2 addr' m2'>>) \/ <<OOM: capture_oom m1' b2>>.
+Proof.
+  inv CAPTURE; inv INJECT.
+  exploit mi_mappedblocks0; eauto. i.
+  destruct (classic (exists m2' addr', capture m1' b2 addr' m2')).
+  - des. left; eauto.
+  - right. ii. split; eauto.
+Qed.
+
+Definition ptr_inj (f: meminj) (b b': block) (ofs ofs': Z) :=
+  exists delta, f b = Some (b', delta) /\ ofs' = ofs + delta.
+
+Definition ptr_inj_list_exists (f: meminj) (pl pl': list (block * Z)) :=
+    forall b o (INSRC: In (b, o) pl),
+    exists b' o', <<INTGT: In (b', o') pl'>> /\ <<PINJ: ptr_inj f b b' o o'>>.
+
+Section VAL2PTR.
+
+Variable m1: mem.
+Variable m2: mem.
+Variable f: meminj.
+
+Hypothesis mi_inj_perm: forall b1 b2 delta ofs k p, f b1 = Some (b2, delta) -> perm m1 b1 ofs k p -> perm m2 b2 (ofs + delta) k p.
+
+Hypothesis src_concrete_private: forall b, f b = None -> (mem_concrete m1) ! b = None.
+
+Hypothesis mappedblocks: forall b b' delta, valid_block m1 b -> f b = Some (b', delta) -> valid_block m2 b'.
+
+Hypothesis src_concrete_public: forall b1 b2 addr delta,
+    f b1 = Some (b2, delta) ->
+    (mem_concrete m1) ! b1 = Some addr ->
+    (mem_concrete m2) ! b2 = Some (addr - delta).
+
+Hypothesis representable: forall b b' delta ofs,
+    f b = Some (b', delta) ->
+    perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \/
+    perm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->
+    delta >= 0 /\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.
+
+Lemma denormalize_inject_aux
+    z b ofs
+    (DEMOSRC: denormalize z m1 = Some (b, ofs)) :
+  exists b' ofs', 
+    <<DENOTGT: denormalize z m2 = Some (b', ofs')>>
+  /\ <<VINJ: exists delta, f b = Some (b', delta) /\ ofs' = ofs + delta>>.
+Proof.
+  unfold denormalize in DEMOSRC.
+  eapply PTree.gselectf in DEMOSRC. des.
+  unfold denormalize_aux in DEMOSRC0. rewrite DEMOSRC in DEMOSRC0. des_ifs.
+  eapply andb_prop in Heq. des. rename Heq into VALIDSRC. rename Heq0 into INBLKSRC.
+  assert (f b = None \/ exists b' delta, f b = Some (b', delta)).
+  { destruct (f b); eauto. right. destruct p. esplits; eauto. }
+  des.
+  { exploit src_concrete_private; eauto. i. clarify. }
+  exploit src_concrete_public; eauto. i.
+  rewrite <- addr_in_block_iff in INBLKSRC.
+  assert (VALIDTGT: is_valid m2 b' = true).
+  { rewrite <- valid_block_iff_is_valid in *. eauto. }
+  assert (INBLKTGT: addr_in_block (mem_concrete m2) (mem_access m2) z b').
+  { inv INBLKSRC. des. clarify.
+    exploit mi_inj_perm; eauto.
+    - unfold perm, perm_order'. rewrite PERM. eapply perm_refl.
+    - ii. econs; eauto.
+      + unfold perm, perm_order' in H1. des_ifs.
+        replace (z - (a - delta)) with (z - a + delta) by lia. eauto.
+      + exploit representable; try eapply H; eauto.
+        { instantiate (1:= Ptrofs.repr (z - a)).
+          left. rewrite Ptrofs.unsigned_repr; eauto.
+          2:{ unfold Ptrofs.max_unsigned in *. lia. }
+          unfold perm, perm_order'. rewrite PERM. eapply perm_any_N. }
+        rewrite Ptrofs.unsigned_repr; eauto.
+        { unfold Ptrofs.max_unsigned in *. lia. }
+        unfold Ptrofs.max_unsigned in *. lia. }
+  destruct (denormalize z m2) eqn:TGT; cycle 1.
+  { exfalso. eapply PTree.gselectnf in TGT. eapply TGT. esplits; eauto. ii.
+    unfold denormalize_aux in H1. des_ifs. ss.
+    rewrite addr_in_block_iff in INBLKTGT. clarify. }
+  eapply PTree.gselectf in TGT. des. unfold denormalize_aux in TGT0. des_ifs.
+  eapply andb_prop in Heq0. des.
+  rewrite <- addr_in_block_iff in Heq1.
+  exploit no_concrete_overlap; [eapply Heq1|eapply INBLKTGT|].
+  ii. subst. esplits; eauto. ii. clarify. lia.
+Qed.
+
+Lemma denormalize_inject' z b ofs
+    (DENOSRC: denormalize z m1 = Some (b, ofs)) :
+  exists b' ofs', 
+    <<DENOTGT: denormalize z m2 = Some (b', ofs')>>
+  /\ <<VINJ: Val.inject f (Vptr b (Ptrofs.repr ofs)) (Vptr b' (Ptrofs.repr ofs'))>>.
+Proof.
+  exploit denormalize_inject_aux; eauto. ii. des.
+  esplits; eauto. econs; eauto. rewrite VINJ0. subst.
+  exploit representable; eauto.
+  { left. instantiate (1:= Ptrofs.repr ofs).
+    exploit denormalize_in_range; try eapply DENOSRC. ii. des.
+    eapply PTree.gselectf in DENOSRC. des. unfold denormalize_aux in DENOSRC0. des_ifs.
+    eapply andb_prop in Heq0. des. unfold addr_is_in_block in *.
+    des_ifs. rewrite Ptrofs.unsigned_repr.
+    2: { unfold Ptrofs.max_unsigned in *. lia. }
+    unfold perm, perm_order'. rewrite Heq. eapply perm_any_N. }
+  eapply denormalize_in_range in DENOSRC, DENOTGT. des.
+  ii. rewrite Ptrofs.unsigned_repr in H.
+  2: { unfold Ptrofs.max_unsigned in *. lia. }
+  des. assert (0 <= delta < Ptrofs.modulus) by lia.
+  unfold Ptrofs.add. f_equal.
+  rewrite Ptrofs.unsigned_repr.
+  2: { unfold Ptrofs.max_unsigned in *. lia. }
+  rewrite Ptrofs.unsigned_repr; eauto.
+  unfold Ptrofs.max_unsigned in *. lia.
+Qed.
+
+Lemma to_int_inject'
+    v1 v2 (VINJ: Val.inject f v1 v2)
+    v1' (TOINT: to_int v1 m1 = Some v1') :
+  exists v2', <<TOINTTGT: to_int v2 m2 = Some v2'>> /\ <<VINJ: Val.inject f v1' v2'>>.
+Proof.
+  inv VINJ; ss.
+  { des_ifs. esplits; eauto. }
+  { clarify. esplits; eauto. }
+  unfold ptr2int in TOINT. destruct ((mem_concrete m1) ! b1) eqn:CONC; cycle 1.
+  { inv TOINT. }
+  exploit src_concrete_public; eauto. i. destruct Archi.ptr64 eqn:SF.
+- inv TOINT. unfold ptr2int. rewrite H0. esplits; eauto.
+  assert (Int64.repr (z + Ptrofs.unsigned ofs1)
+          = Int64.repr (z - delta + Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))).
+  { eapply Int64.same_if_eq. unfold Int64.eq.
+    unfold Ptrofs.add. repeat rewrite Int64.unsigned_repr_eq. repeat rewrite Ptrofs.unsigned_repr_eq.
+    repeat (rewrite Ptrofs.modulus_eq64; eauto). rewrite (Zplus_mod_idemp_r delta). rewrite Zplus_mod_idemp_r.
+    replace (z - delta + (Ptrofs.unsigned ofs1 + delta)) with (z + Ptrofs.unsigned ofs1) by lia.
+    des_ifs; lia. }
+  rewrite H1. econs.
+- inv TOINT. unfold ptr2int. rewrite H0. esplits; eauto.
+  assert (Int.repr (z + Ptrofs.unsigned ofs1)
+          = Int.repr (z - delta + Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))).
+  { eapply Int.same_if_eq. unfold Int.eq.
+    unfold Ptrofs.add. repeat rewrite Int.unsigned_repr_eq. repeat rewrite Ptrofs.unsigned_repr_eq.
+    repeat (rewrite Ptrofs.modulus_eq32; eauto). rewrite (Zplus_mod_idemp_r delta). rewrite Zplus_mod_idemp_r.
+    replace (z - delta + (Ptrofs.unsigned ofs1 + delta)) with (z + Ptrofs.unsigned ofs1) by lia.
+    des_ifs; lia. }
+  rewrite H1. econs.
+Qed.
+
+Lemma to_ptr_inject'
+    v1 v2 (VINJ: Val.inject f v1 v2)
+    v1' (TOPTR: to_ptr v1 m1 = Some v1') :
+  exists v2', <<TOPTRTGT: to_ptr v2 m2 = Some v2'>> /\ <<VINJ: Val.inject f v1' v2'>>.
+Proof.
+  destruct Archi.ptr64 eqn:SF.
+- inv VINJ; simpl in *; try rewrite SF in *; simpl in *; try inv TOPTR; cycle 1.
+  { esplits; eauto. }
+  destruct (Int64.eq i Int64.zero) eqn:EQ.
+  { esplits; eauto. inv H0. econs. }
+  destruct (denormalize (Int64.unsigned i) m1) eqn:CONC; inv H0.
+  destruct p. inv H1. exploit denormalize_inject'; eauto. i. des.
+  rewrite DENOTGT. esplits; eauto.
+- inv VINJ; simpl in *; try rewrite SF in *; simpl in *; try inv TOPTR; cycle 1.
+  { esplits; eauto. }
+  destruct (Int.eq i Int.zero) eqn:EQ.
+  { esplits; eauto. inv H0. econs. }
+  destruct (denormalize (Int.unsigned i) m1) eqn:CONC; inv H0.
+  destruct p. inv H1. exploit denormalize_inject'; eauto. i. des.
+  rewrite DENOTGT. esplits; eauto.
+Qed.
+
+End VAL2PTR.
+
+Lemma to_int_inject
+    f m1 m2 (INJ: inject f m1 m2)
+    v1 v2 (VINJ: Val.inject f v1 v2)
+    v1' (TOINT: to_int v1 m1 = Some v1') :
+  exists v2', <<TOINTTGT: to_int v2 m2 = Some v2'>> /\ <<VINJ: Val.inject f v1' v2'>>.
+Proof. eapply to_int_inject'; eauto. inv INJ; eauto. Qed.
+
+Lemma denormalize_inject f m1 m2 z b ofs
+    (INJ: inject f m1 m2)
+    (DENOSRC: denormalize z m1 = Some (b, ofs)) :
+  exists b' ofs', 
+    <<DENOTGT: denormalize z m2 = Some (b', ofs')>>
+  /\ <<VINJ: Val.inject f (Vptr b (Ptrofs.repr ofs)) (Vptr b' (Ptrofs.repr ofs'))>>
+.
+Proof. inv INJ. inv mi_inj0. eapply denormalize_inject'; eauto. Qed.
+
+Lemma to_ptr_inject
+    f m1 m2 (INJ: inject f m1 m2)
+    v1 v2 (VINJ: Val.inject f v1 v2)
+    v1' (TOPTR: to_ptr v1 m1 = Some v1') :
+  exists v2', <<TOPTRTGT: to_ptr v2 m2 = Some v2'>> /\ <<VINJ: Val.inject f v1' v2'>>.
+Proof. eapply to_ptr_inject'; eauto; inv INJ; eauto. inv mi_inj0; eauto. Qed.
+
 (** Preservation of loads *)
 
 Theorem load_inject:
@@ -3455,6 +6541,21 @@ Proof.
   intros. inv H. eapply load_inj; eauto.
 Qed.
 
+Theorem load_inject_backward
+    f m1 m2 chunk b1 ofs b2 delta v2
+    (MINJ: inject f m1 m2)
+    (LOADTGT: load chunk m2 b2 (ofs + delta) = Some v2)
+    (FINJ: f b1 = Some (b2, delta)) :
+  (exists v1, <<LOADSRC: load chunk m1 b1 ofs = Some v1>> /\ <<VINJ: Val.inject f v1 v2>>)
+  \/ (<<LOADFAIL: load chunk m1 b1 ofs = None>>).
+Proof.
+  destruct (load chunk m1 b1 ofs) eqn: LOADSRC; eauto.
+  esplits; eauto. left. esplits ; eauto.
+  exploit load_inj; try eapply MINJ; eauto.
+  { i. eapply mi_src_concrete_public; eauto. }
+  i. des. clarify.
+Qed.
+
 Theorem loadv_inject:
   forall f m1 m2 chunk a1 a2 v1,
   inject f m1 m2 ->
@@ -3463,13 +6564,37 @@ Theorem loadv_inject:
   exists v2, loadv chunk m2 a2 = Some v2 /\ Val.inject f v1 v2.
 Proof.
   intros. inv H1; simpl in H0; try discriminate.
+  { unfold loadv in H0. des_ifs. exploit to_ptr_inject; try eapply Heq; eauto. i. des. inv VINJ.
+    exploit load_inject; eauto. intros [v2 [LOAD INJ]].
+    exists v2; split; auto. unfold loadv. des_ifs.
+    exploit load_valid_access; try eapply H0. i.
+    eapply (valid_access_perm _ _ _ _ Cur) in H1.
+    eapply perm_implies in H1; eauto; [|eapply perm_any_N].
+    replace (Ptrofs.unsigned (Ptrofs.add i0 (Ptrofs.repr delta)))
+      with (Ptrofs.unsigned i0 + delta); eauto.
+    symmetry. eapply address_inject'; eauto with mem. }
+  unfold loadv in H0. ss.
   exploit load_inject; eauto. intros [v2 [LOAD INJ]].
   exists v2; split; auto. unfold loadv.
+  ss.
   replace (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))
      with (Ptrofs.unsigned ofs1 + delta).
   auto. symmetry. eapply address_inject'; eauto with mem.
 Qed.
 
+Theorem loadv_inject_backward
+    f m1 m2 chunk a1 a2 v2
+    (MINJ: inject f m1 m2)
+    (LOADTGT: loadv chunk m2 a2 = Some v2)
+    (VINJ: Val.inject f a1 a2) :
+  (exists v1, <<LOADSRC: loadv chunk m1 a1 = Some v1>> /\ <<VINJ': Val.inject f v1 v2>>)
+  \/ (<<LOADFAIL: loadv chunk m1 a1 = None>>).
+Proof.
+  destruct (loadv chunk m1 a1) eqn: LOADSRC.
+  - left. exploit loadv_inject; eauto. i. des; clarify. esplits; eauto.
+  - right. eauto.
+Qed.
+
 Theorem loadbytes_inject:
   forall f m1 m2 b1 ofs len b2 delta bytes1,
   inject f m1 m2 ->
@@ -3510,6 +6635,21 @@ Proof.
 (* perm inv *)
   intros. exploit mi_perm_inv0; eauto using perm_store_2.
   intuition eauto using perm_store_1, perm_store_2.
+(* src concrete *)
+  intros.
+  assert (SAMECONC2: n2.(mem_concrete) = m2.(mem_concrete)).
+  { unfold store in STORE.
+    destruct (valid_access_dec m2 chunk b2 (ofs + delta) Writable); inversion STORE.
+    reflexivity. }
+  assert (SAMECONC1: n1.(mem_concrete) = m1.(mem_concrete)).
+  { unfold store in H0.
+    destruct (valid_access_dec m1 chunk b1 ofs Writable); inversion H0.
+    reflexivity. }
+  rewrite SAMECONC2. apply mi_src_concrete_public0 with (b1:=b0).
+  assumption. rewrite <- SAMECONC1. assumption.
+(* src private *)
+  intros. apply concrete_store in H0. rewrite <- H0.
+  apply mi_src_concrete_private0; assumption.
 Qed.
 
 Theorem store_unmapped_inject:
@@ -3535,6 +6675,14 @@ Proof.
 (* perm inv *)
   intros. exploit mi_perm_inv0; eauto using perm_store_2.
   intuition eauto using perm_store_1, perm_store_2.
+(* src concrete *)
+  intros.
+  assert (SAMECONC1: n1.(mem_concrete) = m1.(mem_concrete)).
+  { unfold store in H0. destruct (valid_access_dec m1 chunk b1 ofs Writable); inversion H0. reflexivity. }
+  apply mi_src_concrete_public0 with (b1:=b0). assumption. rewrite <- SAMECONC1. assumption.
+(* src private *)
+  intros. apply concrete_store in H0. rewrite <- H0.
+  apply mi_src_concrete_private0; assumption.
 Qed.
 
 Theorem store_outside_inject:
@@ -3560,6 +6708,13 @@ Proof.
   eauto with mem.
 (* perm inv *)
   intros. eauto using perm_store_2.
+(* src concrete *)
+  intros.
+  assert (SAMECONC2: m2'.(mem_concrete) = m2.(mem_concrete)).
+  { unfold store in H1. destruct (valid_access_dec m2 chunk b ofs Writable); inversion H1. reflexivity. }
+  rewrite SAMECONC2. apply mi_src_concrete_public0 with (b1:=b1); assumption.
+(* src private *)
+  intros. apply concrete_store in H1. apply mi_src_concrete_private0. assumption.
 Qed.
 
 Theorem storev_mapped_inject:
@@ -3572,6 +6727,24 @@ Theorem storev_mapped_inject:
     storev chunk m2 a2 v2 = Some n2 /\ inject f n1 n2.
 Proof.
   intros. inv H1; simpl in H0; try discriminate.
+  { des_ifs. exploit denormalize_inject; eauto. i. des.
+    unfold storev. des_ifs. inversion VINJ; subst.
+    exploit store_mapped_inject; eauto. i. des.
+    exploit store_valid_access_3; try eapply H0. i.
+    eapply (valid_access_perm _ _ _ _ Cur) in H4.
+    eapply perm_implies in H4; eauto; [|eapply perm_any_N].
+    eapply denormalize_in_range in Heq0, Heq1.
+    exploit mi_representable; try eapply H; eauto.
+    { instantiate (1:=Ptrofs.repr z).
+      left. eapply perm_cur_max.
+      rewrite Ptrofs.unsigned_repr; unfold Ptrofs.max_unsigned; [eauto|des; lia]. }
+    i. assert (ofs' = z + delta).
+    { rewrite Ptrofs.add_unsigned in H7. des.
+      do 2 rewrite Ptrofs.unsigned_repr in *; unfold Ptrofs.max_unsigned in *; try lia.
+      assert (Ptrofs.unsigned (Ptrofs.repr ofs') = Ptrofs.unsigned (Ptrofs.repr (z + delta))).
+      { rewrite H7. eauto. }
+      do 2 rewrite Ptrofs.unsigned_repr in *; unfold Ptrofs.max_unsigned in *; try lia. }
+    rewrite H8. eauto. }
   unfold storev.
   replace (Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)))
     with (Ptrofs.unsigned ofs1 + delta).
@@ -3606,6 +6779,17 @@ Proof.
 (* perm inv *)
   intros. exploit mi_perm_inv0; eauto using perm_storebytes_2.
   intuition eauto using perm_storebytes_1, perm_storebytes_2.
+(* src concrete *)
+  intros.
+  assert (SAMECONC2: n2.(mem_concrete) = m2.(mem_concrete)).
+  { unfold storebytes in STORE. destruct (range_perm_dec m2 b2 (ofs + delta) (ofs + delta + Z.of_nat (length bytes2)) Cur Writable); inversion STORE. reflexivity. }
+  assert (SAMECONC1: n1.(mem_concrete) = m1.(mem_concrete)).
+  { unfold storebytes in H0.
+    destruct (range_perm_dec m1 b1 ofs (ofs + Z.of_nat (length bytes1)) Cur Writable); inversion H0. reflexivity. }
+  rewrite SAMECONC2. apply mi_src_concrete_public0 with (b1:=b0). assumption. rewrite <- SAMECONC1. assumption.
+(* src private *)
+  intros. apply concrete_storebytes in H0. rewrite <- H0.
+  apply mi_src_concrete_private0. assumption.
 Qed.
 
 Theorem storebytes_unmapped_inject:
@@ -3631,6 +6815,14 @@ Proof.
 (* perm inv *)
   intros. exploit mi_perm_inv0; eauto.
   intuition eauto using perm_storebytes_1, perm_storebytes_2.
+(* src concrete *)
+  intros.
+  assert (SAMECONC1: n1.(mem_concrete) = m1.(mem_concrete)).
+  { unfold storebytes in H0.
+    destruct (range_perm_dec m1 b1 ofs (ofs + Z.of_nat (length bytes1)) Cur Writable); inversion H0. reflexivity. }
+  apply mi_src_concrete_public0 with (b1:=b0). assumption. rewrite <- SAMECONC1. assumption.
+  intros. apply concrete_storebytes in H0. rewrite <- H0.
+  apply mi_src_concrete_private0. assumption.
 Qed.
 
 Theorem storebytes_outside_inject:
@@ -3656,6 +6848,13 @@ Proof.
   auto.
 (* perm inv *)
   intros. eapply mi_perm_inv0; eauto using perm_storebytes_2.
+(* src concrete *)
+  intros.
+  assert (SAMECONC2: m2'.(mem_concrete) = m2.(mem_concrete)).
+  { unfold storebytes in H1. destruct (range_perm_dec m2 b ofs (ofs + Z.of_nat (length bytes2)) Cur Writable); inversion H1. reflexivity. }
+  rewrite SAMECONC2. apply mi_src_concrete_public0 with (b1:=b1); assumption.
+(* src private *)
+  intros. apply mi_src_concrete_private0; assumption.
 Qed.
 
 Theorem storebytes_empty_inject:
@@ -3680,6 +6879,17 @@ Proof.
 (* perm inv *)
   intros. exploit mi_perm_inv0; eauto using perm_storebytes_2.
   intuition eauto using perm_storebytes_1, perm_storebytes_2.
+(* src concrete *)
+  intros.
+  assert (SAMECONC2: m2'.(mem_concrete) = m2.(mem_concrete)).
+  { unfold storebytes in H1. destruct (range_perm_dec m2 b2 ofs2 (ofs2 + Z.of_nat (length nil)) Cur Writable); inversion H1. reflexivity. }
+  assert (SAMECONC1: m1'.(mem_concrete) = m1.(mem_concrete)).
+  { unfold storebytes in H0.
+    destruct (range_perm_dec m1 b1 ofs1 (ofs1 + Z.of_nat (length nil)) Cur Writable); inversion H0. reflexivity. }
+  rewrite SAMECONC2. apply mi_src_concrete_public0 with (b1:=b0). assumption. rewrite <- SAMECONC1. assumption.
+(* src private *)
+  intros. apply concrete_storebytes in H0. rewrite <- H0.
+  apply mi_src_concrete_private0. assumption.
 Qed.
 
 (* Preservation of allocations *)
@@ -3706,6 +6916,13 @@ Proof.
   intros. eapply perm_alloc_inv in H2; eauto. destruct (eq_block b0 b2).
   subst b0. eelim fresh_block_alloc; eauto.
   eapply mi_perm_inv0; eauto.
+(* src concrete *)
+  intros.
+  assert (SAMECONC2: m2'.(mem_concrete) = m2.(mem_concrete)).
+  { unfold alloc in H0. inversion H0. reflexivity. }
+  rewrite SAMECONC2. apply mi_src_concrete_public0 with (b1:=b1); assumption.
+(* src private *)
+  intros. apply mi_src_concrete_private0. assumption.
 Qed.
 
 Theorem alloc_left_unmapped_inject:
@@ -3753,6 +6970,23 @@ Proof.
   intros. unfold f' in H3; destruct (eq_block b0 b1); try discriminate.
   exploit mi_perm_inv0; eauto.
   intuition eauto using perm_alloc_1, perm_alloc_4.
+(* src concrete *)
+  { intros.
+    apply mi_src_concrete_public0 with (b1:=b0).
+    unfold f' in INJECT.
+    destruct (eq_block b0 b1).
+    - inversion INJECT.
+    - assumption.
+    - assert (CONC: m1.(mem_concrete) = m1'.(mem_concrete)).
+      { unfold alloc in H0. inversion H0 as [[H3 H4]]. reflexivity. }
+      rewrite CONC. assumption. }
+(* src private *)
+  { intros. unfold f' in NOINJECT. destruct (eq_block b b1).
+    + rewrite e in *.
+      rewrite <- concrete_alloc with (lo:=lo) (hi:=hi) (m2:=m1') (b:=b1) (m1:=m1).
+      apply alloc_result in H0. rewrite H0 in *. apply logical_nextblock. assumption.
+    + apply concrete_alloc in H0. rewrite <- H0.
+      apply mi_src_concrete_private0. assumption. }
 (* incr *)
   split. auto.
 (* image *)
@@ -3843,6 +7077,24 @@ Proof.
   left. apply perm_implies with Freeable; auto with mem. eapply perm_alloc_2; eauto.
   right; intros A. eapply perm_alloc_inv in A; eauto. rewrite dec_eq_true in A. tauto.
   exploit mi_perm_inv0; eauto. intuition eauto using perm_alloc_1, perm_alloc_4.
+(* src concrete *)
+  intros b0 b3 delta0 addr HF' CONC1.
+  clear mi_freeblocks0 mi_mappedblocks0 mi_no_overlap0 mi_representable0 mi_perm_inv0.
+    assert (HCONC: m1.(mem_concrete) = m1'.(mem_concrete)).
+  { unfold alloc in H0. inversion H0 as [[FST SND]]. reflexivity. }
+  assert (nextblock: m1.(nextblock) = b1).
+  { unfold alloc in H0. inversion H0 as [[FST SND]]. reflexivity. }
+  apply mi_src_concrete_public0 with (b1:=b0).
+  unfold f' in HF'.
+  destruct (eq_block b0 b1); inversion HF'. rewrite <- H10.
+  rewrite e in *. clear e.
+  rewrite <- HCONC in CONC1.  rewrite <- nextblock in CONC1.
+  rewrite logical_nextblock in CONC1. inversion CONC1. reflexivity.
+  rewrite HCONC. assumption.
+(* src private *)
+  intros. apply concrete_alloc in H0. rewrite <- H0.
+  apply mi_src_concrete_private0. unfold f' in NOINJECT.
+  destruct (eq_block b b1); try assumption. inversion NOINJECT.
 (* incr *)
   split. auto.
 (* image of b1 *)
@@ -3903,6 +7155,14 @@ Proof.
   intros. exploit mi_perm_inv0; eauto. intuition eauto using perm_free_3.
   eapply perm_free_inv in H4; eauto. destruct H4 as [[A B] | A]; auto.
   subst b1. right; eapply perm_free_2; eauto.
+(* src concrete *)
+  intros.
+  assert (SAMECONC1: m1'.(mem_concrete) = m1.(mem_concrete)).
+  { unfold free, unchecked_free in H0. destruct (range_perm_dec m1 b lo hi Cur Freeable); inversion H0. reflexivity. }
+  apply mi_src_concrete_public0 with (b1:=b1). assumption. rewrite <- SAMECONC1. assumption.
+(* src private *)
+  intros. apply concrete_free in H0. rewrite <- H0.
+  apply mi_src_concrete_private0. assumption.
 Qed.
 
 Lemma free_list_left_inject:
@@ -3940,6 +7200,13 @@ Proof.
   auto.
 (* perm inv *)
   intros. eauto using perm_free_3.
+(* src concrete *)
+  intros.
+  assert (SAMECONC2: m2'.(mem_concrete) = m2.(mem_concrete)).
+  { unfold free, unchecked_free in H0. destruct (range_perm_dec m2 b lo hi Cur Freeable); inversion H0. reflexivity. }
+  rewrite SAMECONC2. apply mi_src_concrete_public0 with (b1:=b1); assumption.
+(* src private *)
+  intros. apply mi_src_concrete_private0. assumption.
 Qed.
 
 Lemma perm_free_list:
@@ -4016,6 +7283,11 @@ Proof.
   eapply drop_outside_inj; eauto.
   intros. unfold valid_block in *. erewrite nextblock_drop; eauto.
   intros. eapply mi_perm_inv0; eauto using perm_drop_4.
+(* src concrete *)
+  intros.
+  assert (SAMECONC2: m2'.(mem_concrete) = m2.(mem_concrete)).
+  { unfold drop_perm in H0. destruct (range_perm_dec m2 b lo hi Cur Freeable); inversion H0. reflexivity. }
+  rewrite SAMECONC2. apply mi_src_concrete_public0 with (b1:=b1); assumption.  
 Qed.
 
 (** Composing two memory injections. *)
@@ -4098,6 +7370,15 @@ Proof.
   exploit mi_perm_inv1; eauto. intros [A|A].
   eapply mi_perm_inv0; eauto.
   right; red; intros. elim A. eapply perm_inj; eauto.
+(* src concrete *)
+  intros. des_ifs. exploit mi_src_concrete_public1; eauto. i.
+  rewrite H. f_equal. lia.
+(* src private *)
+  i. des_ifs.
+  exploit mi_src_concrete_private1; eauto. i.
+  destruct ((mem_concrete m1)!b) eqn:H2; clarify.
+  exploit mi_src_concrete_public0; eauto. i. clarify.
+  exploit mi_src_concrete_private0; eauto.
 Qed.
 
 Lemma val_lessdef_inject_compose:
@@ -4136,6 +7417,15 @@ Proof.
   exploit mi_perm_inv0; eauto. intros [A|A].
   eapply mext_perm_inv0; eauto.
   right; red; intros; elim A. eapply perm_extends; eauto.
+(* src concrete*)
+  apply mi_src_concrete_public0 with (b1:=b1). assumption.
+  eapply mext_concrete with (m2:=m2) (m1:=m1); eauto.
+  eapply NNPP. ii. eapply nextblocks_logical in H0; clarify.
+(* src private *)
+  intros. apply mi_src_concrete_private0 in NOINJECT.
+  destruct ((mem_concrete m1) ! b) eqn:M1CONC; eauto.
+  eapply mext_concrete0 in M1CONC; eauto; clarify.
+  eapply NNPP. ii. eapply nextblocks_logical in H0; clarify.
 Qed.
 
 Lemma inject_extends_compose:
@@ -4159,6 +7449,10 @@ Proof.
   exploit mext_perm_inv0; eauto. intros [A|A].
   eapply mi_perm_inv0; eauto.
   right; red; intros; elim A. eapply perm_inj; eauto.
+(* src concrete *)
+  eapply mext_concrete with (m1:=m2) (m2:=m3); eauto.
+(* src private *)
+  eauto.
 Qed.
 
 Lemma extends_extends_compose:
@@ -4176,6 +7470,10 @@ Proof.
   exploit mext_perm_inv1; eauto. intros [A|A].
   eapply mext_perm_inv0; eauto.
   right; red; intros; elim A. eapply perm_extends; eauto.
+  (* src private *)
+  exploit mext_concrete0; eauto. i.
+  exploit mext_concrete1; eauto.
+  eapply NNPP. ii. eapply nextblocks_logical in H3; clarify.
 Qed.
 
 (** Injecting a memory into itself. *)
@@ -4216,6 +7514,13 @@ Proof.
   unfold flat_inj; intros.
   destruct (plt b1 (nextblock m)); inv H0.
   rewrite Z.add_0_r in H1; auto.
+(* src concrete *)
+  i. unfold flat_inj in INJECT.
+  des_ifs. rewrite CONCRETE. f_equal. lia.
+(* src private *)
+  intros. unfold flat_inj in NOINJECT.
+  destruct (plt b (nextblock m)) eqn:PLT; inversion NOINJECT.
+  apply m.(nextblocks_logical). assumption.
 Qed.
 
 Theorem empty_inject_neutral:
@@ -4228,7 +7533,7 @@ Proof.
 (* align *)
   unfold flat_inj; intros. destruct (plt b1 thr); inv H. apply Z.divide_0_r.
 (* mem_contents *)
-  intros; simpl. rewrite ! PMap.gi. rewrite ! ZMap.gi. constructor.
+  intros; simpl. rewrite ! PMap.gi. rewrite ! ZMap.gi. constructor.  
 Qed.
 
 Theorem alloc_inject_neutral:
@@ -4245,7 +7550,8 @@ Proof.
   intros.
   apply perm_implies with Freeable; auto with mem.
   eapply perm_alloc_2; eauto. lia.
-  unfold flat_inj. apply pred_dec_true.
+  unfold flat_inj.
+  apply pred_dec_true.
   rewrite (alloc_result _ _ _ _ _ H). auto.
 Qed.
 
@@ -4259,7 +7565,8 @@ Theorem store_inject_neutral:
 Proof.
   intros; red.
   exploit store_mapped_inj. eauto. eauto. apply flat_inj_no_overlap.
-  unfold flat_inj. apply pred_dec_true; auto. eauto.
+  unfold flat_inj.
+  apply pred_dec_true; auto. eauto.
   replace (ofs + 0) with ofs by lia.
   intros [m'' [A B]]. congruence.
 Qed.
@@ -4294,13 +7601,19 @@ Record unchanged_on (m_before m_after: mem) : Prop := mk_unchanged_on {
     forall b ofs,
     P b ofs -> perm m_before b ofs Cur Readable ->
     ZMap.get ofs (PMap.get b m_after.(mem_contents)) =
-    ZMap.get ofs (PMap.get b m_before.(mem_contents))
+    ZMap.get ofs (PMap.get b m_before.(mem_contents));
+  unchanged_concrete:
+    forall b addr,
+      valid_block m_before b ->
+      m_before.(mem_concrete)!b = Some addr ->
+      m_after.(mem_concrete)!b = Some addr;
 }.
 
 Lemma unchanged_on_refl:
   forall m, unchanged_on m m.
 Proof.
   intros; constructor. apply Ple_refl. tauto. tauto.
+  tauto.
 Qed.
 
 Lemma valid_block_unchanged_on:
@@ -4335,6 +7648,12 @@ Proof.
   eapply valid_block_unchanged_on; eauto.
 - intros. transitivity (ZMap.get ofs (mem_contents m2)#b); apply unchanged_on_contents; auto.
   eapply perm_unchanged_on; eauto.
+- intros.
+  apply unchanged_concrete with (m_before:=m2); auto.
+  unfold valid_block in *.
+  assert (H3: Ple (nextblock m1) (nextblock m2)) by (apply unchanged_on_nextblock; assumption).
+  apply Plt_Ple_trans with (q:=nextblock m1); assumption.
+  apply unchanged_concrete with (m_before:=m1); auto.    
 Qed.
 
 Lemma loadbytes_unchanged_on_1:
@@ -4372,23 +7691,151 @@ Proof.
   intros. eauto with mem.
 Qed.
 
+Lemma not_pure_unchanged_on
+    m m' b ofs sz bytes bytes'
+    (UNCHANGE: unchanged_on m m')
+    (PRED: forall i, ofs <= i < ofs + sz -> P b i)
+    (LB1: loadbytes m b ofs sz = Some bytes)
+    (LB2: loadbytes m' b ofs sz = Some bytes'):
+  <<NPURE: bytes = bytes'>>.
+Proof. exploit loadbytes_unchanged_on; eauto. i. clarify. Qed.
+
 Lemma load_unchanged_on_1:
-  forall m m' chunk b ofs,
+  forall m m' chunk b ofs
+  (PURE: forall bytes, loadbytes m b ofs (size_chunk chunk) = Some bytes -> is_mixed_mvs bytes = false),
   unchanged_on m m' ->
   valid_block m b ->
   (forall i, ofs <= i < ofs + size_chunk chunk -> P b i) ->
   load chunk m' b ofs = load chunk m b ofs.
 Proof.
   intros. unfold load. destruct (valid_access_dec m chunk b ofs Readable).
+  specialize (PURE (getN (size_chunk_nat chunk) ofs (mem_contents m) # b)).
+  exploit PURE.
+  { unfold loadbytes. des_ifs. exfalso. eapply n. unfold valid_access in v. des. eauto. }
+  assert (LB1: loadbytes m b ofs (size_chunk chunk) =
+                 Some (getN (size_chunk_nat chunk) ofs (mem_contents m) # b)).
+  { inv v. unfold loadbytes. des_ifs. }
+  assert (LB2: loadbytes m' b ofs (size_chunk chunk) =
+                 Some (getN (size_chunk_nat chunk) ofs (mem_contents m') # b)).
+  { unfold loadbytes. des_ifs_safe. inv v. exfalso. eapply n. ii. exploit H2; eauto. ii.
+    eapply perm_unchanged_on; eauto. }
+  i. exploit not_pure_unchanged_on; try eapply H2; eauto. i.
+  rewrite H3 in H2. erewrite normalize_mvs_pure; eauto. erewrite normalize_mvs_pure; eauto.
   destruct v. rewrite pred_dec_true. f_equal. f_equal. apply getN_exten. intros.
-  rewrite <- size_chunk_conv in H4. eapply unchanged_on_contents; eauto.
+  rewrite <- size_chunk_conv in H6. eapply unchanged_on_contents; eauto.
   split; auto. red; intros. eapply perm_unchanged_on; eauto.
   rewrite pred_dec_false. auto.
   red; intros [A B]; elim n; split; auto. red; intros; eapply perm_unchanged_on_2; eauto.
 Qed.
 
+Lemma load_unchanged_on_check_1:
+  forall m m' chunk b ofs
+  (PURE: forall bytes, loadbytes m b ofs (size_chunk chunk) = Some bytes -> normalize_check chunk bytes = false),
+  unchanged_on m m' ->
+  valid_block m b ->
+  (forall i, ofs <= i < ofs + size_chunk chunk -> P b i) ->
+  load chunk m' b ofs = load chunk m b ofs.
+Proof.
+  intros. unfold load. destruct (valid_access_dec m chunk b ofs Readable).
+- specialize (PURE (getN (size_chunk_nat chunk) ofs (mem_contents m) # b)).
+  exploit PURE.
+  { unfold loadbytes. des_ifs. exfalso. eapply n. unfold valid_access in v. des. eauto. }
+  assert (LB1: loadbytes m b ofs (size_chunk chunk) =
+                 Some (getN (size_chunk_nat chunk) ofs (mem_contents m) # b)).
+  { inv v. unfold loadbytes. des_ifs. }
+  assert (LB2: loadbytes m' b ofs (size_chunk chunk) =
+                 Some (getN (size_chunk_nat chunk) ofs (mem_contents m') # b)).
+  { unfold loadbytes. des_ifs_safe. inv v. exfalso. eapply n. ii. exploit H2; eauto. ii.
+    eapply perm_unchanged_on; eauto. }
+  i. exploit not_pure_unchanged_on; try eapply H2; eauto. i.
+  unfold normalize_mvs. rewrite H2. rewrite H3 in H2.
+  assert (X: normalize_check chunk (getN (size_chunk_nat chunk) ofs (mem_contents m') # b) = false).
+  { clear -H2. unfold normalize_check in *. des_ifs. }
+  rewrite X. destruct v. rewrite pred_dec_true. f_equal. f_equal. apply getN_exten. intros.
+  rewrite <- size_chunk_conv in H6. eapply unchanged_on_contents; eauto.
+  split; auto. red; intros. eapply perm_unchanged_on; eauto.
+- rewrite pred_dec_false. auto.
+  red; intros [A B]; elim n; split; auto. red; intros; eapply perm_unchanged_on_2; eauto.
+Qed.
+
+Lemma load_unchanged_on_check_2:
+  forall m m' chunk b ofs
+  (PURE: forall bytes, loadbytes m b ofs (size_chunk chunk) = Some bytes -> change_check chunk bytes = false),
+  unchanged_on m m' ->
+  valid_block m b ->
+  (forall i, ofs <= i < ofs + size_chunk chunk -> P b i) ->
+  load chunk m' b ofs = load chunk m b ofs.
+Proof.
+  intros. unfold load. destruct (valid_access_dec m chunk b ofs Readable).
+- specialize (PURE (getN (size_chunk_nat chunk) ofs (mem_contents m) # b)).
+  exploit PURE.
+  { unfold loadbytes. des_ifs. exfalso. eapply n. unfold valid_access in v. des. eauto. }
+  assert (LB1: loadbytes m b ofs (size_chunk chunk) =
+                 Some (getN (size_chunk_nat chunk) ofs (mem_contents m) # b)).
+  { inv v. unfold loadbytes. des_ifs. }
+  assert (LB2: loadbytes m' b ofs (size_chunk chunk) =
+                 Some (getN (size_chunk_nat chunk) ofs (mem_contents m') # b)).
+  { unfold loadbytes. des_ifs_safe. inv v. exfalso. eapply n. ii. exploit H2; eauto. ii.
+    eapply perm_unchanged_on; eauto. }
+  i. exploit not_pure_unchanged_on; try eapply H2; eauto. i.
+  destruct v. rewrite pred_dec_true; cycle 1.
+  { split; auto. red; intros. eapply perm_unchanged_on; eauto. }
+  f_equal. f_equal. rewrite H3.
+  eapply change_check_fail_normalize_mvs_same. erewrite <- H3. eauto.
+- rewrite pred_dec_false. auto.
+  red; intros [A B]; elim n; split; auto. red; intros; eapply perm_unchanged_on_2; eauto.
+Qed.
+
+(* Lemma load_unchanged_on_encoded: *)
+(*   forall m m' chunk b ofs *)
+(*   (PURE: forall bytes, loadbytes m b ofs (size_chunk chunk) = Some bytes -> encoded_bytes bytes = true), *)
+(*   unchanged_on m m' -> *)
+(*   valid_block m b -> *)
+(*   (forall i, ofs <= i < ofs + size_chunk chunk -> P b i) -> *)
+(*   load chunk m' b ofs = load chunk m b ofs. *)
+(* Proof. *)
+(*   intros. unfold load. destruct (valid_access_dec m chunk b ofs Readable). *)
+(*   specialize (PURE (getN (size_chunk_nat chunk) ofs (mem_contents m) # b)). *)
+(*   exploit PURE. *)
+(*   { unfold loadbytes. des_ifs. exfalso. eapply n. unfold valid_access in v. des. eauto. } *)
+(*   assert (LB1: loadbytes m b ofs (size_chunk chunk) = *)
+(*                  Some (getN (size_chunk_nat chunk) ofs (mem_contents m) # b)). *)
+(*   { inv v. unfold loadbytes. des_ifs. } *)
+(*   assert (LB2: loadbytes m' b ofs (size_chunk chunk) = *)
+(*                  Some (getN (size_chunk_nat chunk) ofs (mem_contents m') # b)). *)
+(*   { unfold loadbytes. des_ifs_safe. inv v. exfalso. eapply n. ii. exploit H2; eauto. ii. *)
+(*     eapply perm_unchanged_on; eauto. } *)
+(*   i. exploit not_pure_unchanged_on; try eapply H2; eauto. i. *)
+(*   rewrite H3 in H2. erewrite decode_normalize_encoded_bytes; eauto. erewrite decode_normalize_encoded_bytes; eauto. *)
+(*   destruct v. rewrite pred_dec_true. f_equal. f_equal. f_equal. apply getN_exten. intros. *)
+(*   rewrite <- size_chunk_conv in H6. eapply unchanged_on_contents; eauto. *)
+(*   split; auto. red; intros. eapply perm_unchanged_on; eauto. *)
+(*   rewrite pred_dec_false. auto. *)
+(*   red; intros [A B]; elim n; split; auto. red; intros; eapply perm_unchanged_on_2; eauto. *)
+(* Qed. *)
+
+Lemma load_unchanged_on_2
+  m m' chunk b ofs
+  (CONC: m.(mem_concrete) = m'.(mem_concrete))
+  (UNCHANGE: unchanged_on m m')
+  (VLD: valid_block m b)
+  (PRED: forall i, ofs <= i < ofs + size_chunk chunk -> P b i):
+  <<SAME: load chunk m' b ofs = load chunk m b ofs>>.
+Proof.
+  i. unfold load. destruct (valid_access_dec m chunk b ofs Readable).
+- erewrite <- normalize_mvs_same_concrete; eauto.
+  destruct v. rewrite pred_dec_true.
+  2:{ split; auto. red; intros. eapply perm_unchanged_on; eauto. }
+  f_equal. f_equal. replace (getN (size_chunk_nat chunk) ofs (mem_contents m') # b)
+    with (getN (size_chunk_nat chunk) ofs (mem_contents m) # b); auto.
+  apply getN_exten. intros. symmetry. rewrite <- size_chunk_conv in H1. eapply unchanged_on_contents; eauto.
+- rewrite pred_dec_false. auto.
+  red; intros [A B]; elim n; split; auto. red; intros; eapply perm_unchanged_on_2; eauto.
+Qed.
+
 Lemma load_unchanged_on:
-  forall m m' chunk b ofs v,
+  forall m m' chunk b ofs v
+  (PURE: forall bytes, loadbytes m b ofs (size_chunk chunk) = Some bytes -> is_mixed_mvs bytes = false),
   unchanged_on m m' ->
   (forall i, ofs <= i < ofs + size_chunk chunk -> P b i) ->
   load chunk m b ofs = Some v ->
@@ -4397,6 +7844,70 @@ Proof.
   intros. rewrite <- H1. eapply load_unchanged_on_1; eauto with mem.
 Qed.
 
+Lemma load_unchanged_on_check:
+  forall m m' chunk b ofs v
+  (PURE: forall bytes, loadbytes m b ofs (size_chunk chunk) = Some bytes -> normalize_check chunk bytes = false),
+  unchanged_on m m' ->
+  (forall i, ofs <= i < ofs + size_chunk chunk -> P b i) ->
+  load chunk m b ofs = Some v ->
+  load chunk m' b ofs = Some v.
+Proof.
+  intros. rewrite <- H1. eapply load_unchanged_on_check_1; eauto with mem.
+Qed.
+
+Lemma load_unchanged_on_change_check:
+  forall m m' chunk b ofs v
+  (PURE: forall bytes, loadbytes m b ofs (size_chunk chunk) = Some bytes -> change_check chunk bytes = false),
+  unchanged_on m m' ->
+  (forall i, ofs <= i < ofs + size_chunk chunk -> P b i) ->
+  load chunk m b ofs = Some v ->
+  load chunk m' b ofs = Some v.
+Proof.
+  intros. rewrite <- H1. eapply load_unchanged_on_check_2; eauto with mem.
+Qed.
+
+Lemma inject_id_memval_inject_list bytes :
+  list_forall2 (memval_inject inject_id) bytes bytes.
+Proof.
+  ginduction bytes; ss; ii. econs. econs; eauto. destruct a; ss; econs.
+  destruct v; ss. unfold inject_id. econs; eauto. rewrite Ptrofs.add_zero. auto.
+Qed.
+
+Lemma load_unchanged_on_impure
+  m m' chunk b ofs v
+  (UNCHANGE: unchanged_on m m')
+  (PP: forall i, ofs <= i < ofs + size_chunk chunk -> P b i)
+  (LOAD: load chunk m b ofs = Some v):
+  exists v', <<LOAD: load chunk m' b ofs = Some v'>> /\ <<REL: v = Vundef \/ v = v'>>.
+Proof.
+  exploit load_loadbytes; eauto. i. des.
+  destruct (normalize_check chunk bytes) eqn:NPURE; cycle 1.
+  { exploit (load_unchanged_on_check m m' chunk b ofs v); eauto. ii. clarify. }
+  exploit loadbytes_unchanged_on; eauto. intros LB2. rename H into LB1.
+  destruct (classic (chunk = Mptr \/ chunk = Many64)); cycle 1.
+  { eapply not_or_and in H. des. exploit load_valid_access; eauto. i. inv H2.
+    exploit loadbytes_load; try eapply LB2; eauto. i. esplits; eauto.
+    right. unfold normalize_mvs, normalize_check. des_ifs_safe. destruct chunk; ss. }
+  exploit ( normalize_mvs_decode_val_inject inject_id m m' bytes bytes chunk).
+  { erewrite loadbytes_length; eauto. destruct chunk; ss; lia. }
+  { ii. inv UNCHANGE. unfold inject_id in H1. clarify. exploit unchanged_concrete0; eauto. i.
+    rewrite H0. f_equal. lia. }
+  { eapply inject_id_memval_inject_list. }
+  i. rewrite <- H0 in H1. exploit loadbytes_load; eauto.
+  { exploit load_valid_access; eauto. i. inv H2. auto. }
+  i. esplits; eauto. inv H1; auto. unfold inject_id in H4. clarify.
+  right. rewrite Ptrofs.add_zero. auto.
+Qed.
+
+Lemma load_unchanged_on_concrete
+  m m' chunk b ofs v
+  (CONC: m.(mem_concrete) = m'.(mem_concrete))
+  (UNCHANGE: unchanged_on m m')
+  (PRED: forall i, ofs <= i < ofs + size_chunk chunk -> P b i)
+  (LOAD: load chunk m b ofs = Some v) :
+  <<LOAD: load chunk m' b ofs = Some v>>.
+Proof. i. rewrite <- LOAD. eapply load_unchanged_on_2; eauto with mem. Qed.
+
 Lemma store_unchanged_on:
   forall chunk m b ofs v m',
   store chunk m b ofs v = Some m' ->
@@ -4412,6 +7923,7 @@ Proof.
   destruct (zlt ofs0 ofs); auto.
   destruct (zlt ofs0 (ofs + size_chunk chunk)); auto.
   elim (H0 ofs0). lia. auto.
+- rewrite <- H2. rewrite concrete_store with (chunk:=chunk) (b:=b) (ofs:=ofs) (v:=v) (m1:=m) (m2:=m'). reflexivity. assumption.  
 Qed.
 
 Lemma storebytes_unchanged_on:
@@ -4428,6 +7940,7 @@ Proof.
   destruct (zlt ofs0 ofs); auto.
   destruct (zlt ofs0 (ofs + Z.of_nat (length bytes))); auto.
   elim (H0 ofs0). lia. auto.
+- rewrite <- H2. rewrite concrete_storebytes with m b ofs bytes m'. reflexivity. assumption.  
 Qed.
 
 Lemma alloc_unchanged_on:
@@ -4443,6 +7956,8 @@ Proof.
   eapply valid_not_valid_diff; eauto with mem.
 - injection H; intros A B. rewrite <- B; simpl.
   rewrite PMap.gso; auto. rewrite A.  eapply valid_not_valid_diff; eauto with mem.
+- rewrite <- H1. rewrite concrete_alloc with (lo:=lo) (hi:=hi) (m2:=m') (b:=b)(m1:=m). reflexivity.
+  assumption.
 Qed.
 
 Lemma free_unchanged_on:
@@ -4460,6 +7975,8 @@ Proof.
   eapply perm_free_3; eauto.
 - unfold free in H. destruct (range_perm_dec m b lo hi Cur Freeable); inv H.
   simpl. auto.
+- rewrite <- H2. rewrite concrete_free with (bf:=b) (lo:=lo) (hi:=hi) (m2:=m')(m1:=m).
+  reflexivity. assumption.
 Qed.
 
 Lemma drop_perm_unchanged_on:
@@ -4478,6 +7995,23 @@ Proof.
   eapply perm_drop_4; eauto.
 - unfold drop_perm in H.
   destruct (range_perm_dec m b lo hi Cur Freeable); inv H; simpl. auto.
+- rewrite <- H2. rewrite concrete_drop with (b:=b) (lo:=lo) (hi:=hi) (p:=p) (m':=m') (m:=m).
+  reflexivity. assumption.
+Qed.
+
+Lemma capture_unchanged_on:
+  forall m b addr m',
+  capture m b addr m' -> unchanged_on m m'.
+Proof.
+  i. inv H. econs; i.
+  - rewrite NEXTBLOCK. eapply Ple_refl.
+  - unfold perm, perm_order'. rewrite ACCESS. eauto.
+  - rewrite CONTENTS. eauto.
+  - destruct ((mem_concrete m) ! b) eqn:CONC.
+    { exploit PREVADDR; eauto. i. des; subst. rewrite <- H2. eauto. }
+    erewrite CAPTURED; eauto.
+    destruct (peq b b0); subst; clarify.
+    rewrite PTree.gso; eauto.
 Qed.
 
 End UNCHANGED_ON.
@@ -4493,6 +8027,8 @@ Proof.
 - apply unchanged_on_perm0; auto.
 - apply unchanged_on_contents0; auto.
   apply H0; auto. eapply perm_valid_block; eauto.
+- apply unchanged_concrete0 with (addr:=addr);
+    try apply H0; assumption.
 Qed.
 
 End Mem.
@@ -4559,4 +8095,4 @@ Global Hint Resolve
   Mem.valid_access_free_inv_1
   Mem.valid_access_free_inv_2
   Mem.unchanged_on_refl
-: mem.
+  : mem.
diff --git a/common/Memtype.v b/common/Memtype.v
index b8ad1a6b..4c276201 100644
--- a/common/Memtype.v
+++ b/common/Memtype.v
@@ -120,18 +120,54 @@ Parameter load: forall (chunk: memory_chunk) (m: mem) (b: block) (ofs: Z), optio
   are not writable. *)
 Parameter store: forall (chunk: memory_chunk) (m: mem) (b: block) (ofs: Z) (v: val), option mem.
 
+(** integer to pointer cast *)
+Parameter denormalize: forall (z: Z) (m: mem), option (block * Z).
+
+(** to ptr *)
+Parameter to_ptr: forall (v: val) (m: mem), option val.
+
 (** [loadv] and [storev] are variants of [load] and [store] where
   the address being accessed is passed as a value (of the [Vptr] kind). *)
 
 Definition loadv (chunk: memory_chunk) (m: mem) (addr: val) : option val :=
-  match addr with
-  | Vptr b ofs => load chunk m b (Ptrofs.unsigned ofs)
+  match to_ptr addr m with
+  | Some (Vptr b ofs) => load chunk m b (Ptrofs.unsigned ofs)
   | _ => None
   end.
 
+(* Definition loadv (chunk: memory_chunk) (m: mem) (addr: val) : option val := *)
+(*   match addr with *)
+(*   | Vptr b ofs => load chunk m b (Ptrofs.unsigned ofs) *)
+(*   | Vint n => if negb Archi.ptr64 then  *)
+(*                (match denormalize (Int.unsigned n) m with *)
+(*                 | Some (b, ofs) => load chunk m b ofs *)
+(*                 | _ => None *)
+(*                 end) *)
+(*              else None *)
+(*   | Vlong n => if Archi.ptr64 then  *)
+(*                 (match denormalize (Int64.unsigned n) m with *)
+(*                  | Some (b, ofs) => load chunk m b ofs *)
+(*                  | _ => None *)
+(*                  end) *)
+(*               else None *)
+(*   | _ => None *)
+(*   end. *)
+
 Definition storev (chunk: memory_chunk) (m: mem) (addr v: val) : option mem :=
   match addr with
   | Vptr b ofs => store chunk m b (Ptrofs.unsigned ofs) v
+  | Vint n => if negb Archi.ptr64 then 
+               (match denormalize (Int.unsigned n) m with
+                | Some (b, ofs) => store chunk m b ofs v
+                | _ => None
+                end)
+             else None
+  | Vlong n => if Archi.ptr64 then 
+                (match denormalize (Int64.unsigned n) m with
+                 | Some (b, ofs) => store chunk m b ofs v
+                 | _ => None
+                 end)
+              else None
   | _ => None
   end.
 
@@ -342,6 +378,10 @@ Axiom loadbytes_range_perm:
   loadbytes m b ofs len = Some bytes ->
   range_perm m b ofs (ofs + len) Cur Readable.
 
+Parameter normalize_mvs: forall (chunk: memory_chunk) (m: mem) (bytes: list memval), list memval.
+
+(* Parameter normalize_to_fragment : forall (chunk: memory_chunk) (bytes: list memval), list memval. *)
+
 (** If [loadbytes] succeeds, the corresponding [load] succeeds and
   returns a value that is determined by the
   bytes read by [loadbytes]. *)
@@ -349,7 +389,7 @@ Axiom loadbytes_load:
   forall chunk m b ofs bytes,
   loadbytes m b ofs (size_chunk chunk) = Some bytes ->
   (align_chunk chunk | ofs) ->
-  load chunk m b ofs = Some(decode_val chunk bytes).
+  load chunk m b ofs = Some(decode_val chunk (normalize_mvs chunk m bytes)).
 
 (** Conversely, if [load] returns a value, the corresponding
   [loadbytes] succeeds and returns a list of bytes which decodes into the
@@ -358,7 +398,7 @@ Axiom load_loadbytes:
   forall chunk m b ofs v,
   load chunk m b ofs = Some v ->
   exists bytes, loadbytes m b ofs (size_chunk chunk) = Some bytes
-             /\ v = decode_val chunk bytes.
+             /\ v = decode_val chunk (normalize_mvs chunk m bytes).
 
 (** [loadbytes] returns a list of length [n] (the number of bytes read). *)
 Axiom loadbytes_length:
@@ -455,20 +495,20 @@ Definition compat_pointer_chunks (chunk1 chunk2: memory_chunk) : Prop :=
   | _, _ => False
   end.
 
-Axiom load_store_pointer_overlap:
-  forall chunk m1 b ofs v_b v_o m2 chunk' ofs' v,
-  store chunk m1 b ofs (Vptr v_b v_o) = Some m2 ->
-  load chunk' m2 b ofs' = Some v ->
-  ofs' <> ofs ->
-  ofs' + size_chunk chunk' > ofs ->
-  ofs + size_chunk chunk > ofs' ->
-  v = Vundef.
-Axiom load_store_pointer_mismatch:
-  forall chunk m1 b ofs v_b v_o m2 chunk' v,
-  store chunk m1 b ofs (Vptr v_b v_o) = Some m2 ->
-  load chunk' m2 b ofs = Some v ->
-  ~compat_pointer_chunks chunk chunk' ->
-  v = Vundef.
+(* Axiom load_store_pointer_overlap: *)
+(*   forall chunk m1 b ofs v_b v_o m2 chunk' ofs' v, *)
+(*   store chunk m1 b ofs (Vptr v_b v_o) = Some m2 -> *)
+(*   load chunk' m2 b ofs' = Some v -> *)
+(*   ofs' <> ofs -> *)
+(*   ofs' + size_chunk chunk' > ofs -> *)
+(*   ofs + size_chunk chunk > ofs' -> *)
+(*   v = Vundef. *)
+(* Axiom load_store_pointer_mismatch: *)
+(*   forall chunk m1 b ofs v_b v_o m2 chunk' v, *)
+(*   store chunk m1 b ofs (Vptr v_b v_o) = Some m2 -> *)
+(*   load chunk' m2 b ofs = Some v -> *)
+(*   ~compat_pointer_chunks chunk chunk' -> *)
+(*   v = Vundef. *)
 Axiom load_pointer_store:
   forall chunk m1 b ofs v m2 chunk' b' ofs' v_b v_o,
   store chunk m1 b ofs v = Some m2 ->
diff --git a/common/PrintAST.ml b/common/PrintAST.ml
index 61c76c91..647cd46d 100644
--- a/common/PrintAST.ml
+++ b/common/PrintAST.ml
@@ -63,6 +63,7 @@ let name_of_external = function
   | EF_inline_asm(text, sg, clob) -> sprintf "inline_asm %S" (camlstring_of_coqstring text)
   | EF_debug(kind, text, targs) ->
       sprintf "debug%d %S" (P.to_int kind) (extern_atom text)
+  | EF_capture -> "capture"
 
 let rec print_builtin_arg px oc = function
   | BA x -> px oc x
diff --git a/common/Separation.v b/common/Separation.v
index f41d94c3..e7de97f7 100644
--- a/common/Separation.v
+++ b/common/Separation.v
@@ -70,7 +70,7 @@ Qed.
 
 Remark massert_imp_trans: forall p q r, massert_imp p q -> massert_imp q r -> massert_imp p r.
 Proof.
-  unfold massert_imp; intros; firstorder auto.
+  unfold massert_imp; intros. des. split; eauto.
 Qed.
 
 Remark massert_eqv_refl: forall p, massert_eqv p p.
@@ -85,7 +85,7 @@ Qed.
 
 Remark massert_eqv_trans: forall p q r, massert_eqv p q -> massert_eqv q r -> massert_eqv p r.
 Proof.
-  unfold massert_eqv, massert_imp; intros. firstorder auto.
+  unfold massert_eqv, massert_imp; intros. des. esplits; eauto.
 Qed.
 
 (** Record [massert_eqv] and [massert_imp] as relations so that they can be used by rewriting tactics. *)
@@ -179,13 +179,19 @@ Qed.
 Lemma sep_assoc_1:
   forall P Q R, massert_imp ((P ** Q) ** R) (P ** (Q ** R)).
 Proof.
-  intros. unfold massert_imp, sepconj, disjoint_footprint; simpl; firstorder auto.
+  intros. unfold massert_imp, sepconj, disjoint_footprint; simpl.
+  esplits; ii.
+  { des. esplits; eauto. ii. des; eauto. }
+  { des; eauto. }
 Qed.
 
 Lemma sep_assoc_2:
   forall P Q R, massert_imp (P ** (Q ** R)) ((P ** Q) ** R).
 Proof.
-  intros. unfold massert_imp, sepconj, disjoint_footprint; simpl; firstorder auto.
+  intros. unfold massert_imp, sepconj, disjoint_footprint; simpl.
+  esplits; eauto; ii.
+  { des. esplits; eauto. ii. des; eauto. }
+  { des; eauto. }
 Qed.
 
 Lemma sep_assoc:
@@ -416,14 +422,24 @@ Program Definition contains (chunk: memory_chunk) (b: block) (ofs: Z) (spec: val
   m_pred := fun m =>
        0 <= ofs <= Ptrofs.max_unsigned
     /\ Mem.valid_access m chunk b ofs Freeable
+    /\ Mem.change_check chunk (Mem.getN (size_chunk_nat chunk) ofs (Maps.PMap.get b (Mem.mem_contents m))) = false
     /\ exists v, Mem.load chunk m b ofs = Some v /\ spec v;
   m_footprint := fun b' ofs' => b' = b /\ ofs <= ofs' < ofs + size_chunk chunk
 |}.
 Next Obligation.
-  rename H2 into v. split;[|split].
+  Local Transparent Mem.loadbytes.
+  rename H3 into v. split;[|split];[| | split].
 - auto.
 - destruct H1; split; auto. red; intros; eapply Mem.perm_unchanged_on; eauto. simpl; auto.
-- exists v. split; auto. eapply Mem.load_unchanged_on; eauto. simpl; auto.
+- exploit Mem.load_valid_access; eauto. i.
+  exploit (Mem.loadbytes_unchanged_on_1 _ m m' b ofs (size_chunk chunk) H0); eauto with mem.
+  i. unfold Mem.loadbytes in H7. des_ifs.
+  2:{ exfalso. inv H3. clarify. }
+  unfold size_chunk_nat in *. rewrite H7. auto.
+- exists v. split; auto. rewrite <- H5. eapply Mem.load_unchanged_on_check_2; eauto.
++ ii. unfold Mem.loadbytes in H3. des_ifs.
++ eapply Mem.load_valid_access in H5. eauto with mem.
++ ii. ss.
 Qed.
 Next Obligation.
   eauto with mem.
@@ -442,7 +458,7 @@ Lemma load_rule:
   m |= contains chunk b ofs spec ->
   exists v, Mem.load chunk m b ofs = Some v /\ spec v.
 Proof.
-  intros. destruct H as (D & E & v & F & G).
+  intros. destruct H as (D & E & F & v & G & H).
   exists v; auto.
 Qed.
 
@@ -452,9 +468,20 @@ Lemma loadv_rule:
   exists v, Mem.loadv chunk m (Vptr b (Ptrofs.repr ofs)) = Some v /\ spec v.
 Proof.
   intros. exploit load_rule; eauto. intros (v & A & B). exists v; split; auto.
+  unfold Mem.loadv.
   simpl. rewrite Ptrofs.unsigned_repr; auto. eapply contains_no_overflow; eauto.
 Qed.
 
+(* move to memory.v *)
+Lemma store_unchange_bytes
+    chunk m b ofs v m'
+    (STORE : Mem.store chunk m b ofs v = Some m'):
+  <<ENC: Mem.change_check chunk (Mem.getN (size_chunk_nat chunk) ofs (Maps.PMap.get b (Mem.mem_contents m'))) = false>>.
+Proof.
+  Local Transparent Mem.store. unfold Mem.store in STORE. des_ifs. ss. rewrite Maps.PMap.gss.
+  erewrite <- (encode_val_length chunk v). erewrite Mem.getN_setN_same. eapply Mem.encode_val_change_check_false.
+Qed.
+
 Lemma store_rule:
   forall chunk m b ofs v (spec1 spec: val -> Prop) P,
   m |= contains chunk b ofs spec1 ** P ->
@@ -462,11 +489,12 @@ Lemma store_rule:
   exists m',
   Mem.store chunk m b ofs v = Some m' /\ m' |= contains chunk b ofs spec ** P.
 Proof.
-  intros. destruct H as (A & B & C). destruct A as (D & E & v0 & F & G).
+  intros. destruct H as (A & B & C). destruct A as (D & E & F & v0 & G & H').
   assert (H: Mem.valid_access m chunk b ofs Writable) by eauto with mem.
   destruct (Mem.valid_access_store _ _ _ _ v H) as [m' STORE].
   exists m'; split; auto. simpl. intuition auto.
 - eapply Mem.store_valid_access_1; eauto.
+- eapply store_unchange_bytes in STORE. des. eauto.
 - exists (Val.load_result chunk v); split; auto. eapply Mem.load_store_same; eauto.
 - apply (m_invar P) with m; auto.
   eapply Mem.store_unchanged_on; eauto.
@@ -484,8 +512,168 @@ Proof.
   simpl. rewrite Ptrofs.unsigned_repr; auto. eapply contains_no_overflow. eapply sep_pick1; eauto.
 Qed.
 
+(* undefined area *)
+Program Definition undef_area (b: block) (lo hi: Z) : massert := {|
+  m_pred := fun m =>
+       0 <= lo /\ hi <= Ptrofs.max_unsigned
+    /\ (exists bytes, Mem.loadbytes m b lo (hi - lo) = Some bytes /\ bytes_all_undef bytes = true);
+  m_footprint := fun b' ofs' => b' = b /\ lo <= ofs' < hi
+|}.
+Next Obligation.
+  split; auto. split; auto. rename H2 into bytes.
+  exploit Mem.loadbytes_unchanged_on; eauto. ss; lia.
+Qed.
+Next Obligation.
+  Local Transparent Mem.loadbytes. unfold Mem.loadbytes in *. des_ifs.
+  specialize (r lo). eapply Mem.perm_valid_block. eapply r. lia.
+Qed.
+
+(* move to memory.v *)
+
+Lemma undef_all_bytes_sublist
+  bytes bytes0 bytes1
+  (UNDEF: bytes_all_undef bytes = true)
+  (APP: bytes = bytes0 ++ bytes1):
+  <<UNDEF: bytes_all_undef bytes0 = true /\ bytes_all_undef bytes1 = true>>.
+Proof.
+  ginduction bytes; ss; ii.
+  { destruct bytes0; ss. destruct bytes1; ss. }
+  destruct bytes0; ss.
+  - destruct bytes1; ss. clarify.
+  - clarify. eapply andb_prop in UNDEF. des. exploit IHbytes; eauto. i. des.
+    rewrite H, H0, UNDEF. ss.
+Qed.
+
+Lemma undef_area_split
+  b lo hi P mid m
+  (INRANGE: lo <= mid <= hi)
+  (UNDEF: m |= undef_area b lo hi ** P) :
+  <<UNDEFS: m |= undef_area b lo mid ** undef_area b mid hi ** P>>.
+Proof.
+  r. rewrite <- sep_assoc. eapply sep_imp; eauto.
+  split; ss; i.
+- intuition auto.
++ lia.
++ des. replace (hi - lo) with ((mid - lo) + (hi - mid)) in H8 by lia.
+  exploit Mem.loadbytes_split; try eapply H8; try lia. i. des. esplits; eauto.
+  exploit undef_all_bytes_sublist; try eapply H13; eauto. i. des; eauto.
++ lia.
++ des. replace (hi - lo) with ((mid - lo) + (hi - mid)) in H8 by lia.
+  exploit Mem.loadbytes_split; try eapply H8; try lia. i. des.
+  replace (lo + (mid - lo)) with mid in H12 by lia. esplits; eauto.
+  exploit undef_all_bytes_sublist; try eapply H13; eauto. i. des; eauto.
++ red; simpl; intros; lia.
+- intuition lia.
+Qed.
+
+Lemma undef_area_drop_left
+  b lo hi P mid m
+  (INRANGE: lo <= mid <= hi)
+  (UNDEF: m |= undef_area b lo hi ** P):
+  <<UNDEF: m |= undef_area b mid hi ** P>>.
+Proof.
+  i. apply sep_drop with (undef_area b lo mid). apply undef_area_split; auto.
+Qed.
+
+Lemma undef_area_drop_right
+  b lo hi P mid m
+  (INRANGE: lo <= mid <= hi)
+  (UNDEF: m |= undef_area b lo hi ** P):
+  <<UNDEF: m |= undef_area b lo mid ** P>>.
+Proof.
+  i. apply sep_drop2 with (undef_area b mid hi). apply undef_area_split; auto.
+Qed.
+
+(* move to memory.v *)
+Lemma loadbytes_divide
+  m b lo hi mid bytes bytes1 bytes2
+  (RANGE: lo <= mid <= hi)
+  (LB1: Mem.loadbytes m b lo (hi - lo) = Some bytes)
+  (LB2: Mem.loadbytes m b lo (mid - lo) = Some bytes1)
+  (LB3: Mem.loadbytes m b mid (hi - mid) = Some bytes2):
+  <<BYTES: bytes = bytes1 ++ bytes2>>.
+Proof.
+  unfold Mem.loadbytes in *. des_ifs.
+  replace (hi - lo) with ((mid - lo) + (hi - mid)) by lia. rewrite Z2Nat.inj_add; try lia.
+  rewrite Mem.getN_concat. rewrite Z2Nat.id; try lia. replace (lo + (mid - lo)) with mid by lia. ss.
+Qed.
+
+Lemma undef_all_bytes_sublist2
+  m b ofs sz bytes bytes' lo hi
+  (LB1: Mem.loadbytes m b ofs sz = Some bytes)
+  (BYTES: bytes_all_undef bytes = true)
+  (LB2: Mem.loadbytes m b lo (hi - lo) = Some bytes')
+  (IN1: ofs <= lo <= ofs + sz)
+  (IN2: ofs <= hi <= ofs + sz):
+  <<BYTES: bytes_all_undef bytes' = true>>.
+Proof.
+  destruct (Z_le_gt_dec lo hi); cycle 1.
+  { rewrite Mem.loadbytes_empty in LB2; try lia. clarify. }
+  assert (Mem.range_perm m b ofs (ofs + sz) Cur Readable).
+  { eapply Mem.loadbytes_range_perm; eauto. }
+  assert (Mem.range_perm m b lo (ofs + sz) Cur Readable).
+  { r. i. eapply H. lia. }
+  assert (Mem.range_perm m b ofs lo Cur Readable).
+  { r. i. eapply H. lia. }
+  replace (ofs + sz) with (lo + (ofs + sz - lo)) in H0 by lia.
+  replace lo with (ofs + (lo - ofs)) in H1 by lia.
+  replace sz with (ofs + sz - ofs) in LB1 by lia.
+  exploit Mem.range_perm_loadbytes; try eapply H0. i. des.
+  exploit Mem.range_perm_loadbytes; try eapply H1. i. des.
+  exploit loadbytes_divide. 2:{ eapply LB1. } 2:{ eapply H3. } 2:{ eapply H2. } lia. i.
+  exploit undef_all_bytes_sublist; try eapply H4; eauto. i. des.
+  clear H H1 H3 H4 H5. replace (lo + (ofs + sz - lo)) with (ofs + sz) in H0 by lia.
+  assert (Mem.range_perm m b hi (ofs + sz) Cur Readable).
+  { ii. eapply H0. lia. }
+  assert (Mem.range_perm m b lo hi Cur Readable).
+  { ii. eapply H0. lia. }
+  replace (ofs + sz) with (hi + (ofs + sz - hi)) in H by lia.
+  replace hi with (lo + (hi - lo)) in H1 by lia. 
+  exploit Mem.range_perm_loadbytes; try eapply H. i. des.
+  exploit Mem.range_perm_loadbytes; try eapply H1. i. des.
+  exploit loadbytes_divide. 3:{ eapply H4. } 3:{ eapply H3. } 2:{ eapply H2. } lia. i.
+  exploit undef_all_bytes_sublist; try eapply H4; eauto. i. des. clarify.
+Qed.
+  
+Lemma undef_area_split_2
+  b lo hi P mid al m
+  (INRANGE: lo <= align mid al <= hi)
+  (MID: lo <= mid)
+  (LEN: al > 0)
+  (UNDEF: m |= undef_area b lo hi ** P) :
+  <<UNDEFS: m |= undef_area b lo mid ** undef_area b (align mid al) hi ** P>>.
+Proof.
+  r. rewrite <- sep_assoc. eapply sep_imp; eauto.
+  assert (mid <= align mid al) by (apply align_le; auto).
+  split; simpl; intros.
+- intuition auto.
++ lia.
++ des. replace (hi - lo) with ((mid - lo) + (hi - mid)) in H5 by lia.
+  exploit Mem.loadbytes_split; try eapply H5; try lia.
+  i. des. esplits; eauto.
+  exploit undef_all_bytes_sublist; try eapply H8; eauto. i. des; eauto.
++ lia.
++ des.
+  assert (Mem.range_perm m0 b lo (lo + (hi - lo)) Cur Readable).
+  { eapply Mem.loadbytes_range_perm; eauto. }
+  assert (Mem.range_perm m0 b (align mid al) ((align mid al) + (hi - (align mid al))) Cur Readable).
+  { r in H6. r. ii. eapply H6. lia. }
+  exploit Mem.range_perm_loadbytes; try eapply H7. i. des. esplits; eauto.
+  exploit undef_all_bytes_sublist2. eapply H5. eauto. eapply H8. lia. lia. i. eauto.
++ red; simpl; intros; lia.
+- intuition lia.
+Qed.
+
+Program Definition Tmassert : massert := {|
+  m_pred := fun m => True;
+  m_footprint := fun b ofs => False
+|}.
+Next Obligation.
+  clarify.
+Qed.
+
 Lemma range_contains:
-  forall chunk b ofs P m,
+  forall chunk b ofs P m (ENC: Mem.change_check chunk (Mem.getN (size_chunk_nat chunk) ofs (Maps.PMap.get b (Mem.mem_contents m))) = false),
   m |= range b ofs (ofs + size_chunk chunk) ** P ->
   (align_chunk chunk | ofs) ->
   m |= contains chunk b ofs (fun v => True) ** P.
@@ -496,6 +684,8 @@ Proof.
   { split; auto. red; auto. }
   split. generalize (size_chunk_pos chunk). unfold Ptrofs.max_unsigned. lia.
   split. auto.
+  split.
++ auto.
 + destruct (Mem.valid_access_load m chunk b ofs) as [v LOAD].
   eauto with mem.
   exists v; auto.
@@ -509,7 +699,7 @@ Lemma contains_imp:
   massert_imp (contains chunk b ofs spec1) (contains chunk b ofs spec2).
 Proof.
   intros; split; simpl; intros.
-- intuition auto. destruct H4 as (v & A & B). exists v; auto.
+- intuition auto. destruct H5 as (v & A & B). exists v; auto.
 - auto.
 Qed.
 
@@ -606,6 +796,56 @@ Proof.
   intros. destruct H, H0. split; apply mconj_morph_1; auto.
 Qed.
 
+Lemma range_contains':
+  forall chunk b ofs P Q m,
+  m |= range b ofs (ofs + size_chunk chunk) ** P ->
+  m |= (undef_area b ofs (ofs + size_chunk chunk)) ** Q ->
+  (align_chunk chunk | ofs) ->
+  m |= contains chunk b ofs (fun v => True) ** P.
+Proof.
+  intros. destruct H as (A & B & C). rename H0 into A'. destruct A as (D & E & F).
+  split; [|split].
+- assert (Mem.valid_access m chunk b ofs Freeable).
+  { split; auto. red; auto. }
+  split. generalize (size_chunk_pos chunk). unfold Ptrofs.max_unsigned. lia.
+  split. auto.
+  split.
++ inv A'. inv H0. des. replace (ofs + (size_chunk chunk) - ofs) with (size_chunk chunk) in H0 by lia.
+  unfold Mem.loadbytes in H0. des_ifs.
+  eapply Mem.bytes_all_undef_not_change; eauto. destruct chunk; ss.
+  (* unfold Mem.encoded_bytes, size_chunk_nat. rewrite H5. eapply orb_true_r. *)
++ destruct (Mem.valid_access_load m chunk b ofs) as [v LOAD].
+  eauto with mem.
+  exists v; auto.
+- auto.
+- unfold disjoint_footprint in *; ii. eapply C; eauto.
+Qed.
+
+Lemma undef_contains:
+  forall chunk b ofs P Q m,
+  m |= range b ofs (ofs + size_chunk chunk) ** P ->
+  m |= (undef_area b ofs (ofs + size_chunk chunk)) ** Q ->
+  (align_chunk chunk | ofs) ->
+  m |= contains chunk b ofs (fun v => True) ** Q.
+Proof.
+  intros. destruct H as (A & B & C). rename H0 into A'. destruct A as (D & E & F).
+  split; [|split].
+- assert (Mem.valid_access m chunk b ofs Freeable).
+  { split; auto. red; auto. }
+  split. generalize (size_chunk_pos chunk). unfold Ptrofs.max_unsigned. lia.
+  split. auto.
+  split.
++ inv A'. inv H0. des. replace (ofs + (size_chunk chunk) - ofs) with (size_chunk chunk) in H0 by lia.
+  unfold Mem.loadbytes in H0. des_ifs.
+  eapply Mem.bytes_all_undef_not_change; eauto. destruct chunk; ss.
+  (* unfold Mem.encoded_bytes, size_chunk_nat. rewrite H5. eapply orb_true_r. *)
++ destruct (Mem.valid_access_load m chunk b ofs) as [v LOAD].
+  eauto with mem.
+  exists v; auto.
+- inv A'. des. auto.
+- inv A'. des. unfold disjoint_footprint in *; ii. eapply H2; eauto.
+Qed.
+
 (** The image of a memory injection *)
 
 Program Definition minjection (j: meminj) (m0: mem) : massert := {|
@@ -631,6 +871,8 @@ Next Obligation.
 - intros. destruct (Mem.perm_dec m0 b1 ofs Max Nonempty); auto.
   eapply mi_perm_inv; eauto.
   eapply Mem.perm_unchanged_on_2; eauto.
+- inv H0. i. eapply unchanged_concrete; eauto.
+- eauto.
 Qed.
 Next Obligation.
   eapply Mem.valid_block_inject_2; eauto.
@@ -657,6 +899,38 @@ Proof.
   intros. destruct H as (A & B & C). simpl in A.
   exploit Mem.storev_mapped_inject; eauto. intros (m2' & STORE & INJ).
   inv H1; simpl in STORE; try discriminate.
+  { esplits; eauto.
+    unfold Mem.storev in H0. des_ifs.
+    exploit Mem.denormalize_inject; try eapply Heq1; eauto.
+    i. des. clarify. inv VINJ.
+    rename b0 into b1. rename b into b2. rename z into ofs2. rename z0 into ofs1.
+    assert (VALID: Mem.valid_access m1 chunk b1 ofs1 Writable)
+      by eauto with mem.
+    eapply Mem.denormalize_in_range in Heq1, DENOTGT.
+    assert (OFS1: ofs1 = Ptrofs.unsigned (Ptrofs.repr ofs1)).
+    { rewrite Ptrofs.unsigned_repr; eauto. unfold Ptrofs.max_unsigned. des; lia. }
+    exploit Mem.mi_representable; try eapply A; eauto.
+    { left. eapply Mem.store_valid_access_3 in H0.
+      eapply (Mem.valid_access_perm _ _ _ _ Cur) in H0.
+      eapply Mem.perm_cur_max. rewrite OFS1 in H0.
+      eapply Mem.perm_implies; eauto. eapply perm_any_N. }
+    i.
+    assert (ofs2 = ofs1 + delta).
+    { rewrite Ptrofs.add_unsigned in H6.
+      do 2 rewrite Ptrofs.unsigned_repr in H6; unfold Ptrofs.max_unsigned in *; try ( by (des; lia)).
+      assert (Ptrofs.unsigned (Ptrofs.repr ofs2) = Ptrofs.unsigned (Ptrofs.repr (ofs1 + delta))).
+      { rewrite H6. eauto. }
+      do 2 rewrite Ptrofs.unsigned_repr in H1; unfold Ptrofs.max_unsigned in *; try ( by (des; lia)). }
+    split; [|split].
+    - exact INJ.
+    - apply (m_invar P) with m2; auto.
+      eapply Mem.store_unchanged_on; eauto.
+      intros; red; intros. eelim C; eauto. simpl.
+      exists b1, delta; split; auto. destruct VALID as [V1 V2].
+      apply Mem.perm_cur_max. apply Mem.perm_implies with Writable; auto with mem.
+      apply V1. lia.
+    - red; simpl; intros. destruct H3 as (b0 & delta0 & U & V).
+      eelim C; eauto. simpl. exists b0, delta0; eauto with mem. }
   assert (VALID: Mem.valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Writable)
     by eauto with mem.
   assert (EQ: Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta)) = Ptrofs.unsigned ofs1 + delta).
@@ -669,11 +943,27 @@ Proof.
   intros; red; intros. eelim C; eauto. simpl.
   exists b1, delta; split; auto. destruct VALID as [V1 V2].
   apply Mem.perm_cur_max. apply Mem.perm_implies with Writable; auto with mem.
-  apply V1. lia.
+  apply V1. omega.
 - red; simpl; intros. destruct H1 as (b0 & delta0 & U & V).
   eelim C; eauto. simpl. exists b0, delta0; eauto with mem.
 Qed.
 
+Lemma alloc_undef_rule
+  m1 lo hi m1' b1
+  (LO: 0 <= lo) (HI: hi <= Ptrofs.max_unsigned)
+  (ALLOC: Mem.alloc m1 lo hi = (m1', b1)):
+  <<UNDEF: m1' |= undef_area b1 lo hi>>.
+Proof.
+  repeat split; eauto.
+  assert (Mem.range_perm m1' b1 lo hi Cur Readable).
+  { ii. exploit Mem.perm_alloc_2; eauto. instantiate (1:=Cur). i.
+    eapply Mem.perm_implies; eauto. eapply perm_F_any. }
+  unfold Mem.loadbytes. replace (lo + (hi - lo)) with hi by lia. des_ifs_safe.
+  esplits; eauto. Local Transparent Mem.alloc. injection ALLOC. i; subst. ss.
+  rewrite Maps.PMap.gss; eauto. remember (Z.to_nat (hi - lo)) as n. clear.
+  ginduction n; ss; ii. rewrite IHn. rewrite Maps.ZMap.gi. ss.
+Qed.
+
 Lemma alloc_parallel_rule:
   forall m1 sz1 m1' b1 m2 sz2 m2' b2 P j lo hi delta,
   m2 |= minjection j m1 ** P ->
@@ -688,7 +978,7 @@ Lemma alloc_parallel_rule:
      m2' |= range b2 0 lo ** range b2 hi sz2 ** minjection j' m1' ** P
   /\ inject_incr j j'
   /\ j' b1 = Some(b2, delta)
-  /\ (forall b, b <> b1 -> j' b = j b).
+  /\ (forall b, b <> b1 -> j' b = j b) /\ m2' |= undef_area b2 0 lo ** undef_area b2 hi sz2 ** minjection j' m1' ** P.
 Proof.
   intros until delta; intros SEP ALLOC1 ALLOC2 ALIGN LO HI RANGE1 RANGE2 RANGE3.
   assert (RANGE4: lo <= hi) by extlia.
@@ -707,7 +997,55 @@ Proof.
   exists (8 / align_chunk chunk). destruct chunk; reflexivity.
 - intros. elim FRESH2. eapply Mem.valid_block_inject_2; eauto.
 - intros (j' & INJ' & J1 & J2 & J3).
-  exists j'; split; auto.
+  exists j'; split; auto; [|split; auto]; [|split; auto]; [|split; auto]; cycle 1.
+{ rewrite <- ! sep_assoc.
+  assert (PERM: Mem.range_perm m2' b2 0 sz2 Cur Readable).
+  { eapply (Mem.range_perm_implies _ _ _ _ _ Freeable); [|eapply perm_F_any].
+    ii. eapply Mem.perm_alloc_2; eauto. }
+  split; [|split]. 
+  + simpl. intuition auto; try (unfold Ptrofs.max_unsigned in *; lia).
+    * assert (Mem.range_perm m2' b2 0 lo Cur Readable).
+      { r in PERM. ii. eapply PERM. lia. }
+      replace lo with (0 + lo) in H1 by lia. replace (lo - 0) with lo by lia.
+      exploit Mem.range_perm_loadbytes; eauto. i. des. esplits; eauto.
+      replace sz2 with (0 + sz2) in PERM by lia.
+      exploit Mem.range_perm_loadbytes; try eapply PERM. i. des.
+      assert (bytes_all_undef bytes0 = true).
+      { unfold bytes_all_undef. rewrite forallb_forall. i.
+        exploit Mem.loadbytes_alloc_same; try eapply ALLOC2; eauto.
+        i. subst. ss. }
+      replace lo with (lo - 0) in H2 by lia.
+      eapply undef_all_bytes_sublist2; eauto; try lia.
+    * assert (Mem.range_perm m2' b2 hi sz2 Cur Readable).
+      { r in PERM. ii. eapply PERM. lia. }
+      replace sz2 with (hi + (sz2 - hi)) in H1 by lia. exploit Mem.range_perm_loadbytes; try eapply H1. i. des.
+      replace sz2 with (0 + sz2) in PERM by lia. exploit Mem.range_perm_loadbytes; try eapply PERM. i. des.
+      esplits; eauto.
+      assert (bytes_all_undef bytes0 = true).
+      { unfold bytes_all_undef. rewrite forallb_forall. i.
+        exploit Mem.loadbytes_alloc_same; try eapply ALLOC2; eauto.
+        i. subst. ss. }
+      eapply undef_all_bytes_sublist2; eauto; try lia.
+    * red; simpl; intros. destruct H1, H2. lia.
+    * red; simpl; intros.
+      assert (b = b2) by tauto. subst b.
+      assert (0 <= ofs < lo \/ hi <= ofs < sz2) by tauto. clear H1.
+      destruct H2 as (b0 & delta0 & D & E).
+      eapply Mem.perm_alloc_inv in E; eauto.
+      destruct (eq_block b0 b1).
+      subst b0. rewrite J2 in D. inversion D; clear D; subst delta0. extlia.
+      rewrite J3 in D by auto. elim FRESH2. eapply Mem.valid_block_inject_2; eauto.
+  + apply (m_invar P) with m2; auto. eapply Mem.alloc_unchanged_on; eauto.
+  + red; simpl; intros.
+    assert (VALID: Mem.valid_block m2 b) by (eapply (m_valid P); eauto).
+    destruct H as [A | (b0 & delta0 & A & B)].
+    * assert (b = b2) by tauto. subst b. contradiction.
+    * eelim DISJ; eauto. simpl.
+      eapply Mem.perm_alloc_inv in B; eauto.
+      destruct (eq_block b0 b1).
+      subst b0. rewrite J2 in A. inversion A; clear A; subst b delta0. contradiction.
+      rewrite J3 in A by auto. exists b0, delta0; auto.
+}
   rewrite <- ! sep_assoc.
   split; [|split].
 + simpl. intuition auto; try (unfold Ptrofs.max_unsigned in *; lia).
@@ -849,7 +1187,7 @@ Proof.
 Qed.
 
 Lemma external_call_parallel_rule:
-  forall (F V: Type) ef (ge: Genv.t F V) vargs1 m1 t vres1 m1' m2 j P vargs2,
+  forall (F V: Type) ef (ge: Genv.t F V) vargs1 m1 t vres1 m1' m2 j P vargs2 (DETERM: determ_properties ef),
   external_call ef ge vargs1 m1 t vres1 m1' ->
   m2 |= minjection j m1 ** globalenv_inject ge j ** P ->
   Val.inject_list j vargs1 vargs2 ->
@@ -860,7 +1198,7 @@ Lemma external_call_parallel_rule:
   /\ inject_incr j j'
   /\ inject_separated j j' m1 m2.
 Proof.
-  intros until vargs2; intros CALL SEP ARGS.
+  intros until vargs2; intros DETERM CALL SEP ARGS.
   destruct SEP as (A & B & C). simpl in A.
   exploit external_call_mem_inject; eauto.
   eapply globalenv_inject_preserves_globals. eapply sep_pick1; eauto.
@@ -897,7 +1235,7 @@ Lemma alloc_parallel_rule_2:
   exists j',
      m2' |= range b2 0 lo ** range b2 hi sz2 ** minjection j' m1' ** globalenv_inject ge j' ** P
   /\ inject_incr j j'
-  /\ j' b1 = Some(b2, delta).
+  /\ j' b1 = Some(b2, delta) /\ m2' |= undef_area b2 0 lo ** undef_area b2 hi sz2 ** minjection j' m1' ** globalenv_inject ge j' ** P.
 Proof.
   intros.
   set (j1 := fun b => if eq_block b b1 then Some(b2, delta) else j b).
@@ -912,9 +1250,92 @@ Proof.
   rewrite sep_swap in H. eapply globalenv_inject_incr with (j' := j1) in H; eauto. rewrite sep_swap in H.
   clear X Y.
   exploit alloc_parallel_rule; eauto.
-  intros (j' & A & B & C & D).
-  exists j'; split; auto.
+  intros (j' & A & B & C & D & E).
+  exists j'; split; auto; [|split;auto]; [|split;auto]; cycle 1.
+  { rewrite sep_swap4 in E. rewrite sep_swap4. apply globalenv_inject_incr with j1 m1; auto.
+    - red; unfold j1; intros. destruct (eq_block b b1). congruence. rewrite D; auto.
+    - red; unfold j1; intros. destruct (eq_block b0 b1). congruence. rewrite D in H9 by auto. congruence. }
   rewrite sep_swap4 in A. rewrite sep_swap4. apply globalenv_inject_incr with j1 m1; auto.
 - red; unfold j1; intros. destruct (eq_block b b1). congruence. rewrite D; auto.
 - red; unfold j1; intros. destruct (eq_block b0 b1). congruence. rewrite D in H9 by auto. congruence.
 Qed.
+
+Lemma external_call_parallel_rule_backward:
+  forall (F V: Type) ef (ge: Genv.t F V) vargs1 m1 t vres2 m2' m2 j P vargs2,
+  is_external_ef ef ->
+  external_call ef ge vargs2 m2 t vres2 m2' ->
+  m2 |= minjection j m1 ** globalenv_inject ge j ** P ->
+  Val.inject_list j vargs1 vargs2 ->
+  (exists t' vres m2, external_call ef ge vargs1 m1 t' vres m2) ->
+  (exists j' vres1 m1',
+    external_call ef ge vargs1 m1 t vres1 m1'
+  /\ Val.inject j' vres1 vres2
+  /\ m2' |= minjection j' m1' ** globalenv_inject ge j' ** P
+  /\ inject_incr j j'
+  /\ inject_separated j j' m1 m2)
+  \/ (forall t' vres1 m1', ~ external_call ef ge vargs1 m1 t' vres1 m1')
+  \/ (~ trace_intact t /\
+       (exists t' vres1 m1',
+          external_call ef ge vargs1 m1 t' vres1 m1' /\
+          (exists tl, t' = Eapp (trace_cut_pterm t) tl))).
+Proof.
+  intros until vargs2; intros EXT CALL SEP ARGS SAFESRC.
+  destruct SEP as (A & B & C). simpl in A.
+  exploit external_call_mem_inject_backward; eauto.
+  eapply globalenv_inject_preserves_globals. eapply sep_pick1; eauto.
+  intros [(j' & vres1 & m1' & CALL' & RES & INJ' & UNCH1 & UNCH2 & INCR & ISEP) |
+          [UBSRC | (INTACT & t' & vres1 & m1' & CALL' & tl & CUT)]].
+{ left.
+  assert (MAXPERMS: forall b ofs p,
+            Mem.valid_block m1 b -> Mem.perm m1' b ofs Max p -> Mem.perm m1 b ofs Max p).
+  { intros. eapply external_call_max_perm; eauto. }
+  exists j', vres1, m1'; intuition auto.
+  split; [|split]; auto.
+- apply m_invar with (m0 := m2).
++ apply globalenv_inject_incr with j m1; auto.
++ eapply Mem.unchanged_on_implies; eauto.
+  intros; red; intros; red; intros.
+  eelim C; eauto. simpl. exists b0, delta; auto.
+- red; intros. destruct H as (b0 & delta & J' & E).
+  destruct (j b0) as [[b' delta'] | ] eqn:J.
+* erewrite INCR in J' by eauto. inv J'.
+  eelim C; eauto. simpl. exists b0, delta; split; auto. apply MAXPERMS; auto.
+  eapply Mem.valid_block_inject_1; eauto.
+* exploit ISEP; eauto. intros (X & Y). elim Y. eapply m_valid; eauto. }
+{ des. exploit UBSRC; eauto. }
+{ right. right. esplits; eauto. }
+Qed.
+
+Lemma external_call_parallel_rule_backward_progress:
+  forall (F V: Type) ef (ge: Genv.t F V) vargs1 m1 t vres1 m1' m2 j P vargs2,
+  is_external_ef ef ->
+  external_call ef ge vargs1 m1 t vres1 m1' ->
+  m2 |= minjection j m1 ** globalenv_inject ge j ** P ->
+  Val.inject_list j vargs1 vargs2 ->
+  exists t' vres2 m2',
+    external_call ef ge vargs2 m2 t' vres2 m2'.
+Proof.
+  intros until vargs2; intros EXT CALL SEP ARGS.
+  destruct SEP as (A & B). simpl in A.
+  exploit external_call_mem_inject_backward_progress; eauto.
+  eapply globalenv_inject_preserves_globals. eapply sep_pick1; eauto.
+  eapply B.
+Qed.
+
+Lemma capture_parallel_rule_backward
+    j m1 m2 b1 b2 addr delta m2' P
+    (CAPTURE: Mem.capture m2 b2 (addr - delta) m2')
+    (SEP: m2 |= minjection j m1 ** P)
+    (INJ: j b1 = Some (b2, delta)) :
+  exists m1', Mem.capture m1 b1 addr m1' /\ m2' |= minjection j m1' ** P.
+Proof.
+  destruct SEP as (A & B). simpl in A. des.
+  exploit Mem.capture_inject_backward; eauto. i. des. esplits; eauto.
+  econs; ss.
+  split.
+- apply (m_invar P) with m2; auto. eapply Mem.capture_unchanged_on; eauto.
+- red; simpl; intros. destruct H as (b0 & delta0 & U & V).
+  eelim B0; eauto. simpl. exists b0, delta0; eauto with mem.
+  esplits; eauto. rewrite Genv.capture_same_perm; eauto.
+Qed.
+
diff --git a/common/Simulation.v b/common/Simulation.v
new file mode 100644
index 00000000..2865390f
--- /dev/null
+++ b/common/Simulation.v
@@ -0,0 +1,1228 @@
+Require Export Smallstep.
+Require Import Values.
+Require Import Globalenvs.
+Require Import Memory.
+Require Import Integers.
+Require Import Events.
+Require Import AST.
+From Paco Require Import paco.
+Require Import sflib.
+Require Import CoqlibC.
+Require Import Axioms.
+Require Import Relations.
+Require Import Wellfounded.
+Require Import Program.Equality.
+
+Set Implicit Arguments.
+
+
+
+(**********************************************************************************************************)
+(**********************************************************************************************************)
+(**********************************************************************************************************)
+
+Lemma well_founded_clos_trans
+      index
+      (order: index -> index -> Prop)
+      (WF: well_founded order):
+    <<WF: well_founded (clos_trans index order)>>.
+Proof.
+  hnf in WF. hnf. i. eapply Acc_clos_trans. eauto.
+Qed.
+
+Lemma clos_t_rt:
+  forall (A : Type) (R : relation A) (x y z : A),
+  clos_trans A R x y -> clos_refl_trans A R y z -> clos_trans A R x z.
+Proof.
+  i. induction H0; ss.
+  - eapply t_trans; eauto.
+  - eapply IHclos_refl_trans2; eauto.
+Qed.
+
+Definition gm_improves (gm1 gm2: positive -> option Z) :=
+  forall id z, gm1 id = Some z -> gm2 id = Some z.
+
+Definition tr_improves ev_rel1 ev_rel2 :=
+  @tr_rel ev_rel1 <2= @tr_rel ev_rel2.
+
+Lemma evval_rel_eq ev:
+  evval_rel (fun _  => None) ev ev.
+Proof. destruct ev; ss. Qed.
+
+Lemma evval_list_rel_eq ev:
+  Forall2 (evval_rel (fun _  => None)) ev ev.
+Proof. ginduction ev; ss. econs; eauto. eapply evval_rel_eq. Qed.
+
+Lemma ev_rel_eq ev:
+  ev_rel (fun _  => None) ev ev.
+Proof.
+  destruct ev; ss; esplits; eauto; try by eapply evval_rel_eq.
+  - eapply evval_list_rel_eq.
+  - eapply evval_list_rel_eq.
+Qed.
+
+Lemma tr_rel_eq tr :
+  tr_rel (ev_rel (fun _ => None)) tr tr.
+Proof. ginduction tr; ss; econs; eauto; ss. eapply ev_rel_eq. Qed.
+
+Lemma evval_rel_refl pm ev:
+  evval_rel pm ev ev.
+Proof. destruct ev; ss. Qed.
+
+Lemma evval_list_rel_refl pm ev:
+  Forall2 (evval_rel pm) ev ev.
+Proof. ginduction ev; ss. econs; eauto. eapply evval_rel_refl. Qed.
+
+Lemma tr_rel_div_r ev_rel t t1 t2
+    (TRREL: tr_rel ev_rel t (t1 ** t2)):
+  exists t1' t2', t = t1' ** t2' /\
+             tr_rel ev_rel t1' t1 /\
+             tr_rel ev_rel t2' t2.
+Proof.
+  ginduction t1; ss; ii.
+  { exists E0, t. esplits; eauto. econs. }
+  inv TRREL. exploit IHt1; eauto. i. des. subst.
+  exists (x::t1'), t2'. esplits; eauto. econs; eauto.
+Qed.
+
+Lemma tr_rel_div_l ev_rel t t1 t2
+    (TRREL: tr_rel ev_rel (t1 ** t2) t):
+  exists t1' t2', t = t1' ** t2' /\
+             tr_rel ev_rel t1 t1' /\
+             tr_rel ev_rel t2 t2'.
+Proof.
+  ginduction t1; ss; ii.
+  { exists E0, t. esplits; eauto. econs. }
+  inv TRREL. exploit IHt1; eauto. i. des. subst.
+  exists (y::t1'), t2'. esplits; eauto. econs; eauto.
+Qed.
+
+(**********************************************************************************************************)
+(**********************************************************************************************************)
+(**********************************************************************************************************)
+
+Module NOSTUTTER.
+
+Section BACKWARD_SIM.
+
+  Variables L1 L2: semantics.
+  
+  Variable gvmap : ident -> option Z. (* initial map *)
+
+  Variable index: Type.
+  Variable order: index -> index -> Prop.
+
+  Variant bsim_step bsim (i0: index) (st_src0: L1.(state)) (st_tgt0: L2.(state)) : Prop :=
+  | bsim_step_step
+      (STEP: forall tr' st_tgt1
+               (STEPTGT: Step L2 st_tgt0 tr' st_tgt1),
+             (exists st_src1 tr i1,
+                <<TREL: tr_rel (ev_rel gvmap) tr tr'>> /\
+                (<<PLUS: Plus L1 st_src0 tr st_src1>> \/ <<STAR: Star L1 st_src0 tr st_src1 /\ order i1 i0>>) /\
+                <<BSIM: bsim i1 st_src1 st_tgt1>>)
+             \/
+             (exists st_src1 tr,
+              <<PTERM: ~ trace_intact tr' >> /\
+              <<STAR: Star L1 st_src0 tr st_src1>> /\ 
+              <<TREL: exists tl, tr_rel (ev_rel gvmap) tr ((trace_cut_pterm tr') ** tl)>>))
+      (FINAL: forall retv
+                (FINALTGT: final_state L2 st_tgt0 retv),
+              exists st_src1,
+              <<STEPSRC: Star L1 st_src0 E0 st_src1>> /\
+              <<FINALSRC: final_state L1 st_src1 retv>>)
+      (PROGRESS: <<FINAL: exists retv, final_state L2 st_tgt0 retv>> \/
+                 <<STEP: exists tr st', Step L2 st_tgt0 tr st'>>).
+
+  Variant _bsim bsim (i0: index) (st_src0: state L1) (st_tgt0: state L2): Prop :=
+  | bsim_intro
+      (STEP: forall
+            (SAFESRC: safe L1 st_src0),
+          <<STEP: bsim_step bsim i0 st_src0 st_tgt0>>).
+
+  Definition bsim: _ -> _ -> _ -> Prop := paco3 _bsim bot3.
+
+  Lemma bsim_mon: monotone3 _bsim.
+  Proof.
+    ii. inv IN. econs; eauto. i. exploit STEP; eauto. i; des_safe. inv H.
+    - econs; eauto. i. exploit STEP0; eauto.
+      i. destruct H; des_safe.
+      + left; esplits; eauto.
+      + right. esplits; eauto.
+  Qed.
+
+End BACKWARD_SIM.
+
+Hint Unfold bsim.
+Hint Resolve bsim_mon: paco.
+
+Record bsim_properties (L1 L2: semantics)
+   (index: Type) (order: index -> index -> Prop) : Prop := {
+    bsim_order_wf: <<WF: well_founded order>>;
+    bsim_initial_states_exist: forall st_init_src
+        (INITSRC: initial_state L1 st_init_src),
+        exists st_init_tgt, <<INITTGT: initial_state L2 st_init_tgt>>;
+    bsim_match_initial_states: forall st_init_src_
+        (INITSRC: initial_state L1 st_init_src_)
+        st_init_tgt
+        (INITTGT: initial_state L2 st_init_tgt)
+        st_init_tgt1
+        (TGTCAP: initial_capture L2 st_init_tgt st_init_tgt1)
+        gmtgt
+        (GVMAPTGT: initial_pimap L2 st_init_tgt1 = gmtgt),
+      exists i0 st_init_src st_init_src1 gmsrc,
+      <<INITSRC: initial_state L1 st_init_src>> /\
+      <<SRCCAP: initial_capture L1 st_init_src st_init_src1>> /\
+      <<GVMAPSRC: initial_pimap L1 st_init_src1 = gmsrc>> /\
+      <<GMSUB: gm_improves gmsrc gmtgt>> /\                                                          
+      <<BSIM: @bsim L1 L2 gmtgt index order i0 st_init_src1 st_init_tgt1>>;
+}.
+
+Arguments bsim_properties: clear implicits.
+
+Variant backward_simulation (L1 L2: semantics): Prop :=
+  Backward_simulation (index: Type)
+                      (order: index -> index -> Prop)
+                      (props: bsim_properties L1 L2 index order).
+
+Arguments Backward_simulation {L1 L2 index} order props.
+
+End NOSTUTTER.
+
+
+Section BACKWARD_SIM.
+
+  Variables L1 L2: semantics.
+  
+  Variable gvmap : ident -> option Z.  (* Initial map *)
+
+  Variable index: Type.
+  Variable order: index -> index -> Prop.
+
+  Variant bsim_step bsim (i0: index) (st_src0: L1.(state)) (st_tgt0: L2.(state)) : Prop :=
+  | bsim_step_step
+      (STEP: forall tr' st_tgt1
+               (STEPTGT: Step L2 st_tgt0 tr' st_tgt1),
+             (exists st_src1 tr i1,
+                <<TREL: tr_rel (ev_rel gvmap) tr tr'>> /\
+                (<<PLUS: Plus L1 st_src0 tr st_src1>> \/ <<STAR: Star L1 st_src0 tr st_src1 /\ order i1 i0>>) /\
+                <<BSIM: bsim i1 st_src1 st_tgt1>>)
+             \/
+             (exists st_src1 tr,
+              <<PTERM: ~ trace_intact tr' >> /\
+              <<STAR: Star L1 st_src0 tr st_src1>> /\ 
+              <<TREL: exists tl, tr_rel (ev_rel gvmap) tr ((trace_cut_pterm tr') ** tl)>>))
+      (FINAL: forall retv
+                (FINALTGT: final_state L2 st_tgt0 retv),
+              exists st_src1,
+              <<STEPSRC: Star L1 st_src0 E0 st_src1>> /\
+              <<FINALSRC: final_state L1 st_src1 retv>>)
+      (PROGRESS: <<FINAL: exists retv, final_state L2 st_tgt0 retv>> \/
+                 <<STEP: exists tr st', Step L2 st_tgt0 tr st'>>)
+  | bsim_step_stutter
+      i1 st_src1
+      (ORD: order i1 i0)
+      (STAR: Star L1 st_src0 E0 st_src1)
+      (BSIM: bsim i1 st_src1 st_tgt0).
+
+  Variant _bsim bsim (i0: index) (st_src0: state L1) (st_tgt0: state L2): Prop :=
+  | bsim_intro
+      (STEP: forall
+            (SAFESRC: safe L1 st_src0),
+          <<STEP: bsim_step bsim i0 st_src0 st_tgt0>>).
+
+  Definition bsim: _ -> _ -> _ -> Prop := paco3 _bsim bot3.
+
+  Lemma bsim_mon: monotone3 _bsim.
+  Proof.
+    ii. inv IN. econs; eauto. i. exploit STEP; eauto. i; des_safe. inv H.
+    - econs; eauto. i. exploit STEP0; eauto.
+      i. destruct H; des_safe.
+      + left; esplits; eauto.
+      + right. esplits; eauto.
+    - eright; eauto.
+  Qed.
+
+End BACKWARD_SIM.
+
+Hint Unfold bsim.
+Hint Resolve bsim_mon: paco.
+
+Definition unboundedOrd A (order: A -> A -> Prop) : Prop :=
+  forall a, exists a', order a a'.
+
+Lemma unbdd_lex_ord
+    A B (ordA: A -> A -> Prop) (ordB: B -> B -> Prop)
+    (UNBDDA: unboundedOrd ordA)
+    (UNBDDB: unboundedOrd ordB):
+  unboundedOrd (lex_ord ordA ordB).
+Proof.
+  unfold unboundedOrd in *. i. destruct a.
+  specialize (UNBDDA a). specialize (UNBDDB b). des.
+  exists (a'0, a'). econs; eauto.
+Qed.
+
+Record bsim_properties (L1 L2: semantics)
+   (index: Type) (order: index -> index -> Prop) : Prop := {
+    bsim_order_wf: <<WF: well_founded order>>;
+    bsim_initial_states_exist: forall st_init_src
+        (INITSRC: initial_state L1 st_init_src),
+        exists st_init_tgt, <<INITTGT: initial_state L2 st_init_tgt>>;
+    bsim_match_initial_states: forall st_init_src_
+        (INITSRC: initial_state L1 st_init_src_)
+        st_init_tgt
+        (INITTGT: initial_state L2 st_init_tgt)
+        st_init_tgt1
+        (TGTCAP: initial_capture L2 st_init_tgt st_init_tgt1)
+        gmtgt
+        (GVMAPTGT: initial_pimap L2 st_init_tgt1 = gmtgt),
+      exists i0 st_init_src st_init_src1 gmsrc,
+      <<INITSRC: initial_state L1 st_init_src>> /\
+      <<SRCCAP: initial_capture L1 st_init_src st_init_src1>> /\
+      <<GVMAPSRC: initial_pimap L1 st_init_src1 = gmsrc>> /\
+      <<GMSUB: gm_improves gmsrc gmtgt>> /\                                                          
+      <<BSIM: @bsim L1 L2 gmtgt index order i0 st_init_src1 st_init_tgt1>>;
+}.
+
+Arguments bsim_properties: clear implicits.
+
+Variant backward_simulation (L1 L2: semantics): Prop :=
+  Backward_simulation (index: Type)
+                      (order: index -> index -> Prop)
+                      (props: bsim_properties L1 L2 index order).
+
+Arguments Backward_simulation {L1 L2 index} order props.
+
+(**********************************************************************************************************)
+(**********************************************************************************************************)
+(**********************************************************************************************************)
+
+(** Aux Lemmas for event relation *)
+
+Lemma evval_rel_mon gm gm'
+    (GIMP: gm_improves gm gm'):
+  evval_rel gm <2= evval_rel gm'.
+Proof.
+  ii. unfold evval_rel, eventval_bind in *. des_ifs; des; split; auto.
+  - unfold to_int_ev in *. des_ifs.
+  - unfold to_int_ev in *. des_ifs_safe. exploit GIMP; eauto. i. erewrite H. eauto.
+Qed.
+
+Lemma evval_list_rel_mon gm gm'
+    (GIMP: gm_improves gm gm'):
+  Forall2 (evval_rel gm) <2= Forall2 (evval_rel gm').
+Proof. ii. ginduction PR; ss. i. econs; eauto. eapply evval_rel_mon; eauto. Qed.
+
+Lemma ev_rel_mon gm gm'
+    (GIMP: gm_improves gm gm'):
+  ev_rel gm <2= ev_rel gm'.
+Proof.
+  ii. unfold ev_rel, event_rel in *. destruct x0; ss.
+  - destruct x1; ss. des; esplits; eauto.
+    { eapply evval_list_rel_mon; eauto. }
+    { eapply evval_rel_mon; eauto. }
+  - destruct x1; ss. des; esplits; eauto. eapply evval_rel_mon; eauto.
+  - destruct x1; ss. des; esplits; eauto. eapply evval_rel_mon; eauto.
+  - destruct x1; ss. des; esplits; eauto. eapply evval_list_rel_mon; eauto.
+Qed.
+
+Lemma tr_rel_mon ev_rel1 ev_rel2
+  (EIMP: ev_rel1 <2= ev_rel2):
+  @tr_rel ev_rel1 <2= @tr_rel ev_rel2.
+Proof. ii. ginduction PR; ii; econs; eauto. eapply IHPR; eauto. Qed.
+
+Lemma tr_improves_trans ev_rel1 ev_rel2 ev_rel3
+    (TR1: @tr_improves ev_rel1 ev_rel2)
+    (TR2: @tr_improves ev_rel2 ev_rel3) :
+  tr_improves ev_rel1 ev_rel3.
+Proof. ii. eapply TR2. eapply TR1; eauto. Qed.
+
+(** Lemmas For bsim *)
+
+Lemma bsim_mon_rel
+    L1 L2 gm gm' index1 index2 order1 order2 (inj: index1 -> index2)
+    (TIMP: gm_improves gm gm')
+    (DIMP: forall i1 i2, order1 i1 i2 <0= order2 (inj i1) (inj i2)) i :
+  @bsim L1 L2 gm index1 order1 i <2=
+  @bsim L1 L2 gm' index2 order2 (inj i).
+Proof.
+  revert_until DIMP. pcofix CIH. i.
+  pstep. econs. i. punfold PR. inv PR.
+  exploit STEP; eauto; i. clear STEP. inv H; pclearbot.
+  econs; ii.
+  - exploit STEP; eauto. i. destruct H; des_safe.
+    + left. esplits; pclearbot; eauto.
+      { eapply tr_rel_mon. eapply ev_rel_mon; eauto. eauto. }
+      des; eauto.
+    + right. esplits; pclearbot; eauto.
+      { eapply tr_rel_mon. eapply ev_rel_mon; eauto. eauto. }
+  - exploit FINAL; eauto.
+  - esplits; eauto.
+  - econs 2; eauto.
+Qed.
+
+Lemma bsim_properties_mon_rel
+    L1 L2
+    index1 index2 order1 order2 (inj: index1 -> index2)
+    (DIMP: forall i1 i2, order1 i1 i2 <0= order2 (inj i1) (inj i2))
+    (WF: well_founded order2) :
+  bsim_properties L1 L2 index1 order1 ->
+  bsim_properties L1 L2 index2 order2.
+Proof.
+  ii. inv H. econs; eauto. ii.
+  exploit bsim_match_initial_states0; eauto. i. des. esplits; eauto.
+  eapply bsim_mon_rel; cycle 2; eauto.
+  { ii. eauto. }
+Qed.
+
+Lemma tc_mon
+    idx (order order2: idx -> idx -> Prop) i i'
+    (ORD : tc order i i')
+    (ORDLE : order <2= order2):
+  tc order2 i i'.
+Proof.
+  ginduction ORD; ii; ss; eauto using t_trans. econs; eauto.
+Qed.
+
+Lemma not_intact_pterm tr:
+  ~ trace_intact tr <-> In Event_pterm tr.
+Proof.
+  split; i; eauto. apply NNPP in H; eauto. Qed.
+
+Lemma tr_rel_pterm ev_rel tr tr'
+    (EPTM: forall ev1 ev2 (ER: ev_rel ev1 ev2: Prop), ev1 = Event_pterm <-> ev2 = Event_pterm)
+    (TREL : tr_rel ev_rel tr tr'):
+  ~ trace_intact tr' <-> ~ trace_intact tr.
+Proof.
+  rewrite !not_intact_pterm.
+  move TREL before ev_rel. revert_until TREL.
+  induction TREL; i; eauto.
+  ss. split; i; des; subst.
+  - left. eapply EPTM in H. apply H. eauto.
+  - right. eapply IHTREL; eauto.
+  - left. eapply EPTM in H. apply H. eauto.
+  - right. eapply IHTREL; eauto.
+Qed.
+
+Lemma tr_rel_intact ev_rel tr tr'
+    (EPTM: forall ev1 ev2 (ER: ev_rel ev1 ev2: Prop), ev1 = Event_pterm <-> ev2 = Event_pterm)
+    (TREL : tr_rel ev_rel tr tr'):
+  trace_intact tr' <-> trace_intact tr.
+Proof.
+  unfold trace_intact. rewrite <-!not_intact_pterm, tr_rel_pterm; eauto.
+Qed.
+
+Lemma trace_cut_pterm_intact_eq tr
+    (INTACT: trace_intact tr):
+  trace_cut_pterm tr = tr.
+Proof.
+  assert (X := trace_cut_pterm_intact_app tr E0 INTACT).
+  ss. rewrite !E0_right in *. eauto.
+Qed.
+
+Lemma tr_rel_cut_pterm ev_rel tr tr'
+    (EPTM: forall ev1 ev2 (ER: ev_rel ev1 ev2: Prop), ev1 = Event_pterm <-> ev2 = Event_pterm)
+    (REL: tr_rel ev_rel tr tr'):
+  tr_rel ev_rel (trace_cut_pterm tr) (trace_cut_pterm tr').
+Proof.
+  induction REL; try (by ss; eauto).
+  destruct (classic (x = Event_pterm)).
+  - rewrite H0. rewrite EPTM in H0; eauto. rewrite H0. ss.
+  - rewrite (cons_app x), (cons_app y), !trace_cut_pterm_intact_app; ss.
+    + econs; eauto.
+    + ii. inv H1; eauto. apply H0. eapply EPTM; eauto.
+    + ii. inv H1; eauto.
+Qed.
+
+Definition single_events_at (L: semantics) (s:L.(state)) : Prop :=
+  forall t s', Step L s t s' -> (length t <= 1)%nat.
+
+Inductive Dfinal_state (L: semantics) (st: L.(state)) (retv: int): Prop :=
+| Dfinal_state_intro
+    (FINAL: final_state L st retv)
+    (DTM: forall retv0 retv1
+        (FINAL0: final_state L st retv0)
+        (FINAL1: final_state L st retv1),
+        retv0 = retv1)
+    (DTM: forall retv0
+        (FINAL: final_state L st retv0),
+        Nostep L st).
+
+Inductive Dinitial_state (L: semantics) (st: L.(state)): Prop :=
+| Dinitial_state_intro
+    (INIT: initial_state L st)
+    (DTM: forall st0 st1
+        (INIT0: initial_state L st0)
+        (INIT1: initial_state L st1),
+        st0 = st1).
+
+Record receptive_at (L: semantics) (s:L.(state)) : Prop :=
+  Receptive_at {
+    sr_receptive_at: forall t1 s1 t2,
+      Step L s t1 s1 -> match_traces L.(symbolenv) t1 t2 -> exists s2, Step L s t2 s2;
+    sr_traces_at:
+      single_events_at L s
+  }.
+
+Record deterministic_at (L: semantics) (s:L.(state)) : Prop :=
+  Deterministic_at {
+      sd_deterministic_at: forall t1 s1 t2 s2
+        (STEP0: Step L s t1 s1)
+        (STEP1 :Step L s t2 s2),
+        <<EQ: t1 = t2>> /\ <<EQ: s1 = s2>>;
+    sd_deterministic_at_final: forall tr s' retv
+        (FINAL: final_state L s retv)
+        (STEP: Step L s tr s'),
+        False;
+    sd_deterministic_traces_at:
+      single_events_at L s;
+    }.
+
+Record determinate_at (L: semantics) (s:L.(state)) : Prop :=
+  Determinate_at {
+    sd_determ_at: forall t1 s1 t2 s2,
+      Step L s t1 s1 -> Step L s t2 s2 ->
+      match_traces L.(symbolenv) t1 t2 /\ (t1 = t2 -> s1 = s2);
+    sd_determ_at_final: forall
+        tr s' retv
+        (FINAL: final_state L s retv)
+        (STEP: Step L s tr s'),
+        False;
+    sd_traces_at:
+      single_events_at L s
+  }.
+
+Definition DStep (L: semantics) :=
+  (fun s1 t s2 => deterministic_at L s1 /\ Step L s1 t s2).
+
+Definition DStar (L: semantics) :=
+  (star (fun _ => DStep L)) L.(globalenv).
+
+Definition DStarN (L: semantics) :=
+  (starN (fun _ => DStep L)) L.(globalenv).
+
+Definition DPlus (L: semantics) :=
+  (plus (fun _ => DStep L)) L.(globalenv).
+
+Hint Unfold DStep DStar DStarN DPlus.
+
+Lemma tr_improves_refl (ev_rel: event -> event -> Prop):
+  tr_improves ev_rel ev_rel.
+Proof. ii. ginduction PR; ii; ss. econs; eauto. Qed.
+
+Definition is_internal (L: semantics): L.(genvtype) -> L.(state) -> Prop := fun ge s => ~ (is_external L ge s).
+
+Definition IStep (L: semantics) :=
+  (fun s1 t s2 =>  is_internal L L.(globalenv) s1 /\ Step L s1 t s2).
+
+Definition IStar (L: semantics) :=
+  (star (fun _ => IStep L)) L.(globalenv).
+
+Definition IStarN (L: semantics) :=
+  (starN (fun _ => IStep L)) L.(globalenv).
+
+Definition IPlus (L: semantics) :=
+  (plus (fun _ => IStep L)) L.(globalenv).
+
+Hint Unfold IStep IStar IStarN IPlus.
+
+Section MIXED_SIM.
+
+  Variables L1 L2: semantics.
+
+  Variable gvmap : ident -> option Z.  (* Initial map *)
+  
+  Variable index: Type.
+  Variable order: index -> index -> Prop.
+
+  Inductive fsim_step xsim (i0: index) (st_src0: L1.(state)) (st_tgt0: L2.(state)): Prop :=
+  | fsim_step_step
+      (STEP: forall st_src1 tr
+             (STEPSRC: Step L1 st_src0 tr st_src1),
+           exists i1 tr' st_tgt1,
+           <<TRREL: tr_rel (ev_rel gvmap) tr tr'>> /\
+           ((<<PLUS: DPlus L2 st_tgt0 tr' st_tgt1 /\ (<<RECEPTIVE: receptive_at L1 st_src0>>)>>)
+             \/
+             <<STUTTER: st_tgt0 = st_tgt1 /\ tr' = E0 /\ order i1 i0>>) /\
+            <<XSIM: xsim i1 st_src1 st_tgt1>>)
+      (FINAL: forall retv
+          (FINALSRC: final_state L1 st_src0 retv),
+          <<FINALTGT: Dfinal_state L2 st_tgt0 retv>>)
+  | fsim_step_stutter
+      i1 st_tgt1
+      (PLUS: DPlus L2 st_tgt0 nil st_tgt1 /\ order i1 i0)
+      (XSIM: xsim i1 st_src0 st_tgt1).
+
+  Variant _xsim_forward xsim (i0: index) (st_src0: state L1) (st_tgt0: state L2): Prop :=
+  | _xsim_forward_intro
+      (STEP: fsim_step xsim i0 st_src0 st_tgt0).
+
+  Let bsim_step := bsim_step L1 L2 gvmap order.
+
+  Variant _xsim_backward xsim (i0: index) (st_src0: state L1) (st_tgt0: state L2): Prop :=
+  | _xsim_backward_intro
+      (STEP: forall
+          (SAFESRC: safe L1 st_src0),
+          <<STEP: bsim_step xsim i0 st_src0 st_tgt0>>).
+
+  Definition _xsim xsim (i0: index) (st_src0: state L1) (st_tgt0: state L2): Prop :=
+    (<<XSIM: (_xsim_forward \4/ _xsim_backward) xsim i0 st_src0 st_tgt0>>).
+
+  Definition xsim: _ -> _ -> _ -> Prop := paco3 _xsim bot3.
+
+  Lemma _xsim_forward_mon: monotone3 (_xsim_forward).
+  Proof.
+    ii. inv IN. econs; eauto. inv STEP.
+    - econs 1; eauto. i. exploit STEP0; eauto. i; des_safe. esplits; eauto.
+    - econs 2; eauto.
+  Qed.
+
+  Lemma _xsim_backward_mon: monotone3 (_xsim_backward).
+  Proof.
+    ii. inv IN. econs; eauto. i. exploit STEP; eauto. i; des_safe. inv H.
+    - econs; eauto. i. exploit STEP0; eauto. i; des1.
+      + left. des_safe. esplits; eauto.
+      + des_safe. right. esplits; eauto.
+    - eright; eauto.
+  Qed.
+
+  Lemma xsim_mon: monotone3 _xsim.
+  Proof.
+    ii. repeat spc IN. inv IN.
+    (* - left. left. eapply _xsim_strict_forward_mon; eauto. *)
+    - left. eapply _xsim_forward_mon; eauto.
+    - right. eapply _xsim_backward_mon; eauto.
+  Qed.
+
+End MIXED_SIM.
+
+Hint Unfold xsim.
+Hint Resolve xsim_mon: paco.
+Hint Resolve _xsim_forward_mon: paco.
+Hint Resolve _xsim_backward_mon: paco.
+
+Inductive xsim_init_sim (L1 L2: semantics)
+  (index: Type) (order: index -> index -> Prop) : Prop :=
+| xsim_init_forward
+    (INITSIM: forall st_init_src
+        (INITSRC: initial_state L1 st_init_src),
+        exists st_init_tgt,
+          (<<INITTGT: Dinitial_state L2 st_init_tgt>>) /\
+            (<<CAP: forall st_init_tgt1 (CAPTGT: initial_capture L2 st_init_tgt st_init_tgt1)
+                      gmtgt
+                      (GVMAPTGT: initial_pimap L2 st_init_tgt1 = gmtgt),
+                exists i1 st_init_src1 gmsrc,
+                  (<<CAPSRC: initial_capture L1 st_init_src st_init_src1>>) /\
+                  (<<GVMAPSRC: initial_pimap L1 st_init_src1 = gmsrc>>) /\
+                  (<<GMSUB: gm_improves gmsrc gmtgt>>) /\
+                  (<<XSIMCAP: xsim L1 L2 gmtgt order i1 st_init_src1 st_init_tgt1>>)>>))
+| xsim_init_backward
+    (INITEXISTS: forall st_init_src
+        (INITSRC: initial_state L1 st_init_src),
+        exists st_init_tgt, <<INITTGT: initial_state L2 st_init_tgt>>)
+    (INITSIM: forall st_init_src_
+        (INITSRC: initial_state L1 st_init_src_)
+        st_init_tgt
+        (INITTGT: initial_state L2 st_init_tgt)
+        st_init_tgt1
+        (TGTCAP: initial_capture L2 st_init_tgt st_init_tgt1)
+        gmtgt
+        (GVMAPTGT: initial_pimap L2 st_init_tgt1 = gmtgt),
+        exists i0 st_init_src st_init_src1 gmsrc,
+          (<<INITSRC: initial_state L1 st_init_src>>) /\
+          (<<SRCCAP: initial_capture L1 st_init_src st_init_src1>>) /\
+          (<<GVMAPSRC: initial_pimap L1 st_init_src1 = gmsrc>>) /\
+          (<<GMSUB: gm_improves gmsrc gmtgt>>) /\
+          (<<XSIM: xsim L1 L2 gmtgt order i0 st_init_src1 st_init_tgt1>>)).
+
+Record xsim_properties (L1 L2: semantics) (index: Type) (order: index -> index -> Prop) : Prop := {
+    xsim_order_wf: <<WF: well_founded order>>;
+    xsim_order_unbounded: <<UBD: unboundedOrd order>>;
+    xsim_initial_states_sim: <<INIT: xsim_init_sim  L1 L2 order>>;
+    xsim_public_preserved:
+      forall id, Senv.public_symbol (symbolenv L2) id = Senv.public_symbol (symbolenv L1) id;
+}.
+
+Arguments xsim_properties: clear implicits.
+
+Inductive mixed_simulation (L1 L2: semantics) : Prop :=
+  Mixed_simulation (index: Type)
+                   (order: index -> index -> Prop)
+                   (props: xsim_properties L1 L2 index order).
+
+Arguments Mixed_simulation {L1 L2 index} order props.
+
+Section MIXED_TO_BACKWARD.
+
+Variables L1 L2: semantics.
+  
+Variable index: Type.
+Variable order: index -> index -> Prop.
+
+Hypothesis XSIM: xsim_properties L1 L2 index order.
+
+Variable st_init_tgt st_init_tgt1: L2.(state).
+Hypothesis TINIT1: L2.(initial_state) st_init_tgt.
+Hypothesis ICAP1: L2.(initial_capture) st_init_tgt st_init_tgt1.
+
+Definition gmtgt : ident -> option Z := L2.(initial_pimap) st_init_tgt1.
+Definition ev_rel2 : event -> event -> Prop := ev_rel gmtgt.
+
+Let match_states := xsim L1 L2 gmtgt order.
+
+(** Orders *)
+
+Inductive x2b_index : Type :=
+  | X2BI_before (n: nat)
+  | X2BI_after (n: nat) (i: index).
+
+Inductive x2b_order: x2b_index -> x2b_index -> Prop :=
+  | x2b_order_before: forall n n',
+      (n' < n)%nat ->
+      x2b_order (X2BI_before n') (X2BI_before n)
+  | x2b_order_after: forall n n' i,
+      (n' < n)%nat ->
+      x2b_order (X2BI_after n' i) (X2BI_after n i)
+  | x2b_order_after': forall n m i' i,
+      clos_trans _ order i' i ->
+      x2b_order (X2BI_after m i') (X2BI_after n i)
+  | x2b_order_switch: forall n n' i,
+      x2b_order (X2BI_before n') (X2BI_after n i).
+
+Lemma wf_x2b_order:
+  well_founded x2b_order.
+Proof.
+  assert (ACC1: forall n, Acc x2b_order (X2BI_before n)).
+  { intros n0; pattern n0; apply lt_wf_ind; intros.
+    constructor; intros. inv H0. auto. }
+  assert (ACC2: forall i n, Acc x2b_order (X2BI_after n i)).
+  { intros i; pattern i. eapply well_founded_ind.
+    { apply wf_clos_trans. eapply xsim_order_wf; eauto. }
+    i. pattern n. apply lt_wf_ind; i. clear n. econs; eauto. i. inv H1; eauto. }
+  red; intros. destruct a; auto.
+Qed.
+
+Lemma unbdd_x2b_order:
+  unboundedOrd x2b_order.
+Proof.
+  r. ii. destruct a.
+  - exists (X2BI_before (S n)). econs. lia.
+  - exists (X2BI_after (S n) i). econs 2. lia.
+Qed.
+
+(** Constructing the backward simulation *)
+
+Inductive x2b_match_states: x2b_index -> state L1 -> state L2 -> Prop :=
+  | x2b_match_at: forall i s1 s2,
+      match_states i s1 s2 ->
+      x2b_match_states (X2BI_after O i) s1 s2
+  | x2b_match_before: forall s1 t s1' t' s2b s2 n s2a,
+      Step L1 s1 t s1' ->  t <> E0 ->
+      DStar L2 s2b E0 s2 ->
+      DStarN L2 n s2 t' s2a ->
+      tr_rel ev_rel2 t t' ->
+      (forall t s1',
+         Step L1 s1 t s1' ->
+         exists i', exists t', exists s2',
+         <<TRREL: tr_rel ev_rel2 t t'>> /\
+         ((<<PLUS: DPlus L2 s2b t' s2' /\ (<<RECEPTIVE: receptive_at L1 s1>>)>>)
+           \/
+           <<STUTTER: s2b = s2' /\ t' = E0>>)
+       /\ match_states i' s1' s2') ->
+      x2b_match_states (X2BI_before n) s1 s2
+  | x2b_match_after: forall n s2 s2a s1 i,
+      DStarN L2 (S n) s2 E0 s2a ->
+      match_states i s1 s2a ->
+      x2b_match_states (X2BI_after (S n) i) s1 s2.
+
+Remark x2b_match_after':
+  forall n s2 s2a s1 i,
+  DStarN L2 n s2 E0 s2a ->
+  match_states i s1 s2a ->
+  x2b_match_states (X2BI_after n i) s1 s2.
+Proof.
+  intros. inv H. econstructor; eauto. econstructor; eauto. econstructor; eauto.
+Qed.
+
+Definition x2b_ostar (i0 i1: x2b_index) (st0: L1.(state)) (tr: trace) (st1: L1.(state)) : Prop :=
+  <<PLUS: Plus L1 st0 tr st1>> \/ <<STAR: Star L1 st0 tr st1 /\ x2b_order i1 i0>>.
+
+Lemma x2b_ostar_left
+    i i' s1 s1' s1'' tr1 tr2
+    (STEP : Step L1 s1 tr1 s1')
+    (OSTAR : x2b_ostar i i' s1' tr2 s1''):
+  exists i1 i1', x2b_ostar i1 i1' s1 (tr1 ** tr2) s1''.
+Proof.
+  inv OSTAR.
+  - esplits; eauto. left. eapply plus_left'; eauto.
+  - des. esplits; eauto. left. eapply plus_left; eauto.
+Unshelve. all: econs; econs.
+Qed.
+
+Lemma x2b_ostar_star_left
+    i i' s1 s1' s1'' tr1 tr2
+    (STAR : Star L1 s1 tr1 s1')
+    (OSTAR : x2b_ostar i i' s1' tr2 s1''):
+  exists i1 i1', x2b_ostar i1 i1' s1 (tr1 ** tr2) s1''.
+Proof.
+  ginduction STAR; i; ss.
+  - esplits; eauto.
+  - subst. exploit IHSTAR; eauto. i. des. subst.
+    exploit x2b_ostar_left; eauto. i. des. traceEq. esplits; eauto.
+Qed.
+
+Lemma _xsim_backward_mon_x2b
+    i0 st_src0 st_tgt0
+    (BSIM: _xsim_backward L1 L2 gmtgt order match_states i0 st_src0 st_tgt0):
+  <<BSIM: _xsim_backward L1 L2 gmtgt x2b_order x2b_match_states (X2BI_after 0 i0) st_src0 st_tgt0>>.
+Proof.
+  red. inv BSIM. econs; eauto. i. exploit STEP; eauto. i; des. inv H.
+  - econs 1; eauto. i. exploit STEP0; eauto. i. des1.
+    + left. des_safe; pclearbot. inv H0.
+      * esplits; eauto; econs; eauto.
+      * esplits; eauto.
+        { right. des_safe. esplits; eauto. econs 3; eauto. }
+        econs; eauto.
+    + i. des_safe.
+      right. esplits; eauto.
+  - pclearbot. des. econs 2; eauto. esplits; eauto. econs 3; eauto. econs; eauto.
+Qed.
+
+(** Exploiting mixed simulation *)
+
+Inductive x2b_transitions: index -> state L1 -> state L2 -> Prop :=
+  | x2b_trans_forward_final
+      i st_src0 st_src1 st_tgt0 r
+      (TAU: Star L1 st_src0 E0 st_src1)
+      (FINALSRC: final_state L1 st_src1 r)
+      (FINALTGT: Dfinal_state L2 st_tgt0 r):
+      x2b_transitions i st_src0 st_tgt0
+  | x2b_trans_forward_step: forall i s1 s2 s1' t t' s1'' s2' i' i'',
+      Star L1 s1 E0 s1' ->
+      Step L1 s1' t s1'' ->
+      DPlus L2 s2 t' s2' ->
+      tr_rel ev_rel2 t t' ->
+      forall (STEP: forall st_src1 tr
+                 (STEPSRC: Step L1 s1' tr st_src1),
+              exists i1 tr' st_tgt1,
+              <<TRREL: tr_rel ev_rel2 tr tr'>> /\
+              ((<<PLUS: DPlus L2 s2 tr' st_tgt1 /\ (<<RECEPTIVE: receptive_at L1 s1'>>)>>)
+                \/
+                <<STUTTER: s2 = st_tgt1 /\ tr' = E0 /\ order i1 i'>>) /\
+              <<FSIM: match_states i1 st_src1 st_tgt1>>),
+        match_states i'' s1'' s2' ->
+        x2b_transitions i s1 s2
+  | x2b_trans_forward_stutter: forall i s1 s2 s1' s2' i' i'',
+      Star L1 s1 E0 s1' ->
+      True ->
+      DPlus L2 s2 E0 s2' ->
+      match_states i'' s1' s2' ->
+      forall (ORD0: clos_refl_trans _ order i' i)
+        (ORD1: order i'' i'),
+        x2b_transitions i s1 s2
+  | x2b_trans_backward
+      i0 st_src0 st_tgt0
+      (BSIM: _xsim_backward L1 L2 gmtgt x2b_order x2b_match_states (X2BI_after 0 i0) st_src0 st_tgt0):
+      x2b_transitions i0 st_src0 st_tgt0.
+
+Lemma x2b_transitions_src_tau_rev
+      s1 s1' i i' s2
+      (STEPSRC: Star L1 s1 E0 s1')
+      (ORDER: order i' i)
+      (TRANS: x2b_transitions i' s1' s2):
+    <<TRANS: x2b_transitions i s1 s2>>.
+Proof.
+  inv TRANS.
+  * eapply x2b_trans_forward_final; try eapply star_trans; eauto.
+  * eapply x2b_trans_forward_step; cycle 1; eauto. eapply star_trans; eauto.
+  * eapply x2b_trans_forward_stutter; cycle 1; eauto.
+    eapply rt_trans; eauto. constructor. auto. eapply star_trans; eauto.
+  * eapply x2b_trans_backward; cycle 1; eauto. inv BSIM. econs; eauto. i. hexploit1 STEP.
+    { eapply star_safe; eauto. }
+    inv STEP.
+    - econs 1; eauto.
+      + i. exploit STEP0; eauto. i; destruct H; des_safe.
+        { left. esplits; eauto. inv H0.
+          - left. eapply star_plus_trans; eauto.
+          - des_safe. right. esplits; eauto.
+            { eapply star_trans; eauto. }
+            inv H0.
+            + econs. econs; eauto.
+            + econs. eapply t_trans; eauto.
+            + econs. }
+        { right. esplits.
+          - eauto.
+          - eapply star_trans; eauto.
+          - traceEq. eauto. }
+      + i. exploit FINAL; eauto. ii. des_safe. esplits; try eapply FINALSRC; eauto. eapply star_trans; eauto.
+    - econs 2; try apply BSIM; eauto.
+      + inv ORD; try by (econs; eauto). econs. eapply t_trans; eauto.
+      + eapply star_trans; eauto.
+Qed.
+
+Lemma x2b_progress:
+  forall i s1 s2,
+    match_states i s1 s2 -> safe L1 s1 -> x2b_transitions i s1 s2.
+Proof.
+  intros i0; pattern i0. apply well_founded_ind with (R := order). eapply xsim_order_wf; eauto.
+  intros i REC s1 s2 MATCH SAFE. dup MATCH. punfold MATCH0. repeat spc MATCH0. des. inv MATCH0; des.
+  { (* forward *)
+    inversion H; subst. unfold NW in *. destruct (SAFE s1) as [[r FINAL1] | [t [s1' STEP1]]]. apply star_refl.
+    - (* final state reached *)
+      inv STEP.
+      + eapply x2b_trans_forward_final; try eapply star_refl; eauto. eapply FINAL; eauto.
+      + des. pclearbot. inv PLUS.
+        eapply x2b_trans_forward_stutter; try apply STAR0; try eapply star_refl; eauto.
+        { econs; eauto. }
+        econs 2; eauto.
+
+    - inv STEP.
+      + (* L1 can make one step *)
+        hexploit STEP0; eauto. intros [i' [tr' [s2' [TRREL [A MATCH']]]]]. pclearbot.
+        assert (B: DPlus L2 s2 tr' s2' \/ (s2 = s2' /\ tr' = E0 /\ order i' i)).
+        { des; eauto. }
+        clear A. destruct B as [PLUS2 | [EQ1 [EQ2 ORDER]]].
+        { eapply x2b_trans_forward_step; try eapply PLUS2; eauto. apply star_refl.
+          des_safe.
+          i. exploit STEP0; eauto. i; des_safe. pclearbot.
+          eexists. exists tr'0. esplits; eauto. }
+        subst. inv TRREL. exploit REC; try apply MATCH'; eauto.
+        { eapply star_safe; eauto. apply star_one; auto. }
+        i. eapply x2b_transitions_src_tau_rev; eauto. apply star_one; ss.
+      + des. pclearbot. clears t. clear t. inv PLUS.
+        destruct t1, t2; ss. clear_tac.
+        eapply x2b_trans_forward_stutter; eauto. apply star_refl. econs; eauto. apply rt_refl.
+  }
+  { (* backward *)
+    econs 4. eapply _xsim_backward_mon_x2b; eauto. eapply _xsim_backward_mon; eauto. i. pclearbot. ss.
+  }
+Qed.
+
+Lemma xsim_simulation_not_E0:
+  forall s1 t s1', Step L1 s1 t s1' -> t <> E0 ->
+  forall s2,
+    receptive_at L1 s1 ->
+    (forall t s1', Step L1 s1 t s1' ->
+     exists i', exists t', exists s2',
+       tr_rel ev_rel2 t t'
+     /\ (DPlus L2 s2 t' s2' \/ (s2 = s2' /\ t' = E0))
+     /\ match_states i' s1' s2') ->
+    exists i', exists t', exists s2',
+      tr_rel ev_rel2 t t'
+    /\ DPlus L2 s2 t' s2'
+    /\ match_states i' s1' s2'.
+Proof.
+  intros. exploit H2; eauto. intros [i' [t' [s2' [A [B C]]]]].
+  exists i'; exists t'; exists s2'; split; auto. destruct B; auto. des. subst. inv A. clarify.
+Qed.
+
+(** Backward simulation of L2 steps *)
+
+Lemma x2b_match_states_bsim
+      i0_x2b st_src0 st_tgt0
+      (MATCH: x2b_match_states i0_x2b st_src0 st_tgt0):
+    <<BSIM: bsim L1 L2 gmtgt x2b_order i0_x2b st_src0 st_tgt0>>.
+Proof.
+  red. revert_until match_states.
+  pcofix CIH. i. rename r into rr. pfold.
+  assert(PROGRESS: safe L1 st_src0 ->
+                   <<FINAL: exists retv : int, final_state L2 st_tgt0 retv >> \/
+                   <<STEP: exists (tr : trace) (st_tgt1 : state L2), Step L2 st_tgt0 tr st_tgt1 >>).
+  { (* PROGRESS *)
+    generalize dependent st_src0. generalize dependent st_tgt0. pattern i0_x2b.
+    eapply (well_founded_ind wf_x2b_order). clear i0_x2b. intros ? IH ? ? ? SAFE. i. inv MATCH.
+    + exploit x2b_progress; eauto. intros TRANS; inv TRANS.
+      * left. esplits; eauto. apply FINALTGT.
+      * rename H2 into PLUS. inv PLUS. unfold DStep in *. des. right; econstructor; econstructor; eauto.
+      * right. rename H2 into PLUS. inv PLUS. rename H2 into STEP. inv STEP. esplits; eauto.
+      * inv BSIM. specialize (STEP SAFE). inv STEP.
+        { eauto. }
+        { des. exploit IH; try apply BSIM; eauto. eapply star_safe; eauto. }
+    + rename H2 into STARN. inv STARN. inv H3. clarify. unfold DStep in *. des. right; econstructor; econstructor; eauto.
+    + rename H into STARN. inv STARN. des. inv H1. right; econstructor; econstructor; eauto.
+  }
+  econs; eauto.
+  assert(FINALLEMMA: forall retv (SAFESRC: safe L1 st_src0) (FINALTGT: final_state L2 st_tgt0 retv),
+            exists st_src1, <<STAR: Star L1 st_src0 E0 st_src1 >> /\ <<FINAL: final_state L1 st_src1 retv >>).
+  { (* FINAL *)
+    clear - MATCH CIH XSIM TINIT1 ICAP1. (* SSSRC SSTGT. *)
+    generalize dependent MATCH. generalize dependent st_src0. generalize dependent st_tgt0. pattern i0_x2b.
+    eapply (well_founded_ind wf_x2b_order); eauto. i. rename H into IH. clear i0_x2b.
+    i. inv MATCH.
+    + exploit x2b_progress; eauto. intro TRANS. inv TRANS.
+      * assert(retv = r). { inv FINALTGT0. eapply DTM; eauto. } clarify. esplits; eauto.
+      * rename H2 into PLUS. inv PLUS. unfold DStep in *. des. exploit sd_deterministic_at_final; eauto. contradiction. 
+      * rename H2 into PLUS. inv PLUS. unfold DStep in *. des. exploit sd_deterministic_at_final; eauto. contradiction.
+      * inv BSIM. hexploit1 STEP; eauto. inv STEP; eauto.
+        des. exploit IH; try apply BSIM; eauto.
+        { eapply star_safe; eauto. }
+        i; des. esplits; try apply FINAL. eapply star_trans; eauto.
+    + rename H2 into STARN. inv STARN. inv H3. clarify. unfold DStep in *. des. exploit sd_deterministic_at_final; eauto. contradiction.
+    + rename H into STARN. inv STARN. unfold DStep in *. des. exploit sd_deterministic_at_final; eauto. contradiction.
+  }
+  { (* STEP *)
+    i. inv MATCH.
+  - (* 1. At matching states *)
+    exploit x2b_progress; eauto. intros TRANS; inv TRANS.
+    { (* final *)
+      (* 1.1  L1 can reach final state and L2 is at final state: impossible! *)
+      econs 1; ss; eauto. i. inv FINALTGT. exploit DTM0; eauto. i; ss.
+    }
+    { (* forward *)
+      (* 1.2  L1 can make 0 or several steps; L2 can make 1 or several matching steps. *)
+      econs 1; ss; eauto.
+      i. rename H4 into MATCH. inv H2.
+      exploit STEP; eauto. intros [i''' [tr'' [s2''' [TRREL''' [STEP''' MATCH''']]]]].
+      destruct H4. exploit sd_deterministic_at. eexact H2. eexact H4. eexact STEPTGT. i.
+      destruct (silent_or_not_silent t1).
+      (* 1.2.1  L2 makes a silent transition *)
+      + destruct (silent_or_not_silent t2).
+        (* 1.2.1.1  L1 makes a silent transition too: perform transition now and go to "after" state *)
+        * des_safe. subst. simpl in *. destruct (star_starN H5) as [n STEPS2].
+          left. exists s1''. exists E0. exists (X2BI_after n i''). inv H3. splits; eauto.
+          { econs. }
+          { econs 1. eapply plus_right; eauto. }
+          right. eapply CIH. eapply x2b_match_after'; eauto.
+        (* 1.2.1.2 L1 makes a non-silent transition: keep it for later and go to "before" state *)
+        * des_safe. subst. simpl in *. destruct (star_starN H5) as [n STEPS2].
+          left. exists s1'. exists E0. exists (X2BI_before n). splits.
+          { econs. }
+          { econs 2. esplits; eauto. econs. }
+          right. eapply CIH.
+          econs.
+          { eauto. }
+          { destruct t; ss. inv H3; clarify. }
+          { eapply star_one. eauto. }
+          { eapply STEPS2. }
+          { eauto. }
+          intros. exploit STEP; eauto. intros [i'''' [tr''' [s2'''' [A [B MATCH'''']]]]].
+          destruct B as [?|[? [? ?]]]; eauto.
+          { exists i''''. exists tr'''. exists s2''''. esplits; eauto. }
+          { subst. esplits; eauto. }
+      (* 1.2.2 L2 makes a non-silent transition, and so does L1 *)
+      + des; cycle 1.
+        { subst. inv TRREL'''.  inv H3. exploit Eapp_E0_inv; eauto. i. des; clarify. }
+        exploit tr_rel_div_r; eauto. i. des; subst.
+        exploit not_silent_length. eapply RECEPTIVE; eauto. intros [EQ | EQ].
+        { subst. inv H8. clarify. }
+        subst t2'. inv H9. rewrite E0_right in *.
+        (* make lemma *)
+        assert (SAME: tr' = tr'').
+        { inv PLUS.
+          assert (t1 = tr').
+          { inv H6. exploit sd_deterministic_at. eapply H10. eapply STEPTGT. eapply H11. i. des; subst. eauto. }
+          subst.
+          assert (t2 = E0).
+          { destruct t2; ss. destruct tr'; ss. destruct tr'; ss.
+            2:{ inv H6. inv H10. exploit sd_deterministic_traces_at0. eauto. i. ss. lia. }
+            inv H8. inv H14. inv TRREL'''. inv H15. }
+          subst. traceEq. }
+        subst.
+        (* inv PLUS. *)
+        destruct (star_starN H5) as [n STEPS2]. left. exists s1''. exists t1'. exists (X2BI_after n i''). splits.
+        { eauto. }
+        { econs. eapply plus_right; eauto. }
+        right. eapply CIH.
+        eapply x2b_match_after'; eauto.
+    }
+    { econs 1; ss; eauto.
+      i. inv H2.
+      - destruct t1, t2; ss. clear_tac.
+        exploit sd_deterministic_at. apply H4. apply H4. apply STEPTGT. i; des. clarify.
+        destruct H4. clear_tac. destruct (star_starN H5) as [n STEPS2]. destruct n.
+        + inv STEPS2. ss. left. eexists. exists E0. exists (X2BI_after 0 i''). esplits; eauto.
+          * econs.
+          * right. esplits; eauto. econs; eauto. eapply clos_t_rt; eauto.
+          * right. eapply CIH. econs; eauto.
+        + left. eexists. exists E0. exists (X2BI_after (S n) i''). esplits; eauto.
+          * econs.
+          * right. esplits; eauto. econs; eauto. eapply clos_t_rt; eauto.
+          * right. eapply CIH. econs 3; eauto.
+    }
+    { (* backward *)
+      inv BSIM. exploit STEP; eauto. i. inv H0.
+      - econs 1; eauto. i. exploit STEP0; eauto. i; des1.
+        + des_safe. left. esplits; eauto.
+        + des1. des_safe. right. esplits; eauto.
+      - econs 2; eauto.
+    }
+  - (* 2. Before *)
+    econs 1; ss; eauto.
+    i. inv H2. { inv H3. clarify. } destruct H5.
+    exploit sd_deterministic_at. apply H2. apply H5. apply STEPTGT. i; des.
+    destruct (silent_or_not_silent t1).
+    + (* 2.1 L2 makes a silent transition: remain in "before" state *)
+      subst. simpl in *. left. exists st_src0. eexists. exists (X2BI_before n0). splits.
+      { econs. }
+      { right. split. apply star_refl. constructor. lia. }
+      right. eapply CIH; et.
+      econstructor; eauto. eapply star_right; eauto.
+    + (* 2.2 L2 make a non-silent transition *)
+      exploit tr_rel_div_r; eauto. i. des; subst.
+      assert(SINGLE : single_events_at L1 st_src0).
+      { exploit H4; eauto. i. des; clarify.
+        - inv RECEPTIVE; eauto.
+        - subst. ii. inv TRREL. exploit Eapp_E0_inv; eauto. i. des; subst; clarify. }
+      exploit not_silent_length. eapply SINGLE. eauto. i. des; subst.
+      { inv H9. clarify. }
+      inv H10. subst. rewrite E0_right in *.
+      exploit H4; eauto. i. des.
+      2:{ subst. inv TRREL. inv H9. clarify. }
+      assert (NOT: t' <> E0).
+      { destruct t'; ss. inv TRREL. clarify. }  
+      assert (DStar L2 st_tgt0 t' s2').
+      { clear - NOT H1 PLUS. eapply plus_star in PLUS. remember E0 as tr' in H1. ginduction H1; ii.
+        - eauto.
+        - subst. eapply Eapp_E0_inv in Heqtr'. des; subst. eapply IHstar; eauto. inv PLUS.
+          { clarify. }
+          inv H. inv H0. exploit sd_deterministic_at. eexact H3. eapply H4. eapply H5. i.
+          des; subst. traceEq. }
+      assert (SAME: t' = tr').
+      { inv H10; clarify.
+        inv H11. exploit sd_deterministic_at. eexact H10. eapply STEPTGT. eapply H13. i.
+        des; subst. destruct t2; traceEq.
+        destruct t1, t1'; ss. inv TRREL. destruct t1'; ss.
+        2:{ exploit SINGLE; eauto. i. ss. lia. }
+        destruct t1; ss; inv H18. }
+      subst.
+      assert (STARN': exists n', DStarN L2 n' st_tgt1 E0 s2').
+      { inv H10; clarify. inv H11.
+        exploit sd_deterministic_at. eexact H10. eapply STEPTGT. eapply H13. i. des; subst.
+        assert (t2 = E0).
+        { clear - EQ. ginduction t1; ss. i. inv EQ; eauto. }
+        subst. traceEq. eapply star_starN; eauto. }
+      des.
+      left. eexists s1'. eexists. eexists. (* exists (X2BI_after n0 i'). splits; cycle 1. *)
+      splits; cycle 1.
+      { left. eapply plus_one. eauto. }
+      { right. eapply CIH; eauto. eapply x2b_match_after'; try eapply H11; eauto. }
+      { eauto. }
+  - (* 3. After *)
+    econs 1; ss; eauto.
+    i. inv H. exploit Eapp_E0_inv; eauto. intros [EQ1 EQ2]; subst.
+    destruct H2. exploit sd_deterministic_at. eapply H. eexact H1. eexact STEPTGT. i; des. clarify.
+    left. exists st_src0. exists E0. exists (X2BI_after n i). splits.
+    { econs. }
+    { right. split. eapply star_refl. econs. lia. }
+    { right. eapply CIH; et.
+      eapply x2b_match_after'; eauto. } }
+Qed.
+
+End MIXED_TO_BACKWARD.
+
+(** The backward simulation *)
+
+Lemma mixed_to_backward_simulation L1 L2
+    (XSIM: mixed_simulation L1 L2):
+  backward_simulation L1 L2.
+Proof.
+  inversion XSIM. eapply Backward_simulation. constructor.
+  2:{ inv props. inv xsim_initial_states_sim0; eauto.
+      i. exploit INITSIM; eauto. i; des. inv INITTGT. eauto. }
+  2:{ i. destruct props.(xsim_initial_states_sim); eauto; cycle 1.
+      - subst. exploit INITSIM; eauto. i; des. esplits; eauto.
+        eapply bsim_mon_rel.
+        { rr. i. eapply H. }
+        2:{ eapply x2b_match_states_bsim; eauto. econs; eauto. }
+        { ii. instantiate (1:= fun x => x). eauto. }
+      - exploit INITSIM; eauto. i; des. inv INITTGT0.
+        assert(st_init_tgt = st_init_tgt0).
+        { eapply DTM; eauto. }
+        clarify. exploit CAP; eauto. i. des. esplits; eauto. eapply bsim_mon_rel.
+        { ii. eapply H. }
+        2:{ eapply x2b_match_states_bsim; eauto. econs; eauto. }
+        { ii. instantiate (1:= fun x => x). ss. } }
+  { eapply wf_x2b_order; eauto. }
+Qed.
+
+(**********************************************************************************************************)
+(**********************************************************************************************************)
+(**********************************************************************************************************)
+
+Lemma xsim_mon_rel
+    L1 L2 gm gm' index1 index2 order1 order2 (inj: index1 -> index2)
+    (TIMP: gm_improves gm gm')
+    (DIMP: forall i1 i2, order1 i1 i2 <0= order2 (inj i1) (inj i2)) i:
+  @xsim L1 L2 gm index1 order1 i <2=
+  @xsim L1 L2 gm' index2 order2 (inj i).
+Proof.
+  revert_until DIMP. pcofix CIH. i.
+  pstep. i. punfold PR. inv PR.
+  - econs. inv H. inv STEP.
+    + econs. econs.
+      * ii. exploit STEP0; eauto. i. des_safe. destruct H0.
+        { esplits; pclearbot; eauto. eapply tr_rel_mon. eapply ev_rel_mon; eauto. eauto. }
+        { des; subst. esplits; pclearbot; eauto. inv TRREL. econs. }
+      * ii. exploit FINAL; eauto.
+    + econs. des. econs 2; eauto. right. eapply CIH. pclearbot. eauto.
+  - right. inv H. econs. i. exploit STEP; eauto. i. inv H; pclearbot.
+    econs; ii.
+    + exploit STEP0; eauto. i. destruct H; des_safe.
+      * left. esplits; pclearbot; eauto.
+        { eapply tr_rel_mon. eapply ev_rel_mon; eauto. eauto. }
+        destruct H0; esplits; eauto. right. des_safe; eauto.
+      * right. esplits; pclearbot; eauto.
+        eapply tr_rel_mon. eapply ev_rel_mon; eauto. eauto.
+    + exploit FINAL; eauto.
+    + esplits; eauto.
+    + econs 2; eauto.
+Qed.
+
+Lemma bsim_to_nostutter_bsim
+      (L1 L2: semantics) gm
+      index i0 st_src0 st_tgt0
+      (ord: index -> index -> Prop)
+      (WF: well_founded ord)
+      (BSIM: bsim L1 L2 gm ord i0 st_src0 st_tgt0):
+    <<BSIM: NOSTUTTER.bsim L1 L2 gm (clos_trans _ ord) i0 st_src0 st_tgt0>>.
+Proof.
+  red. generalize dependent i0. generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold. econs; eauto. i. econs.
+  - generalize dependent st_src0. generalize dependent st_tgt0. pattern i0.
+    eapply (well_founded_ind WF); eauto. i. rename H into IH.
+    punfold BSIM. inv BSIM. exploit STEP; eauto. i; des_safe. inv H.
+
+    + exploit STEP0; eauto. i. des1.
+      * left. des_safe. pclearbot. esplits; eauto. inv H0.
+        -- left; ss.
+        -- des_safe. right; ss. esplits; eauto.
+      * right. ss.
+    + pclearbot. des. specialize (IH _ ORD).
+      exploit IH; eauto.
+      { ii. eapply SAFESRC. eapply star_trans; eauto. }
+      i; des_safe. des1.
+      { left. des_safe.
+        esplits; eauto. des.
+        * left. eapply star_plus_trans; eauto.
+        * right. esplits; eauto. eapply star_trans; eauto.
+          apply clos_trans_tn1_iff. econs 2; eauto. apply clos_trans_tn1_iff. ss. }
+      { right. des_safe.
+        esplits; [eauto| eapply star_trans; eauto| ss; eauto]. }
+  - generalize dependent BSIM. generalize dependent st_src0. generalize dependent st_tgt0. pattern i0.
+    eapply (well_founded_ind WF); eauto. i. rename H into IH. clear i0.
+    punfold BSIM. inv BSIM. hexploit1 STEP; eauto. inv STEP.
+    + eapply FINAL; eauto.
+    + pclearbot. des.
+      hexploit star_safe; eauto. i.
+      exploit IH; try eapply H; eauto.
+      i; des. esplits; try apply FINALSRC.
+      eapply star_trans; eauto.
+
+  - generalize dependent BSIM. generalize dependent st_src0. generalize dependent st_tgt0. pattern i0.
+    eapply (well_founded_ind WF); eauto. i. rename H into IH. clear i0.
+    punfold BSIM. inv BSIM. specialize (STEP SAFESRC). inv STEP.
+    + eauto.
+    + des. pclearbot.
+      hexploit star_safe; eauto.
+Qed.
+
+Lemma backward_to_nostutter_backward_simulation L1 L2
+      (BS: backward_simulation L1 L2):
+    <<BS: NOSTUTTER.backward_simulation L1 L2>>.
+Proof.
+  inv BS. inv props. econs; eauto.
+  instantiate (1:= (clos_trans _ order)). econs; eauto.
+  { eapply well_founded_clos_trans. eauto. }
+  i. exploit bsim_match_initial_states0; eauto. i; des.
+  esplits; eauto. eapply bsim_to_nostutter_bsim; eauto.
+Qed.
+
diff --git a/common/Smallstep.v b/common/Smallstep.v
index f337ba3c..bd219b3d 100644
--- a/common/Smallstep.v
+++ b/common/Smallstep.v
@@ -26,6 +26,7 @@ Require Import Coqlib.
 Require Import Events.
 Require Import Globalenvs.
 Require Import Integers.
+Require Import sflib.
 
 Set Implicit Arguments.
 
@@ -299,18 +300,21 @@ Qed.
 (** Infinitely many transitions *)
 
 CoInductive forever (ge: genv): state -> traceinf -> Prop :=
-  | forever_intro: forall s1 t s2 T,
+  | forever_intro: forall s1 t s2 T (INTACT: trace_intact t),
       step ge s1 t s2 -> forever ge s2 T ->
       forever ge s1 (t *** T).
 
 Lemma star_forever:
-  forall ge s1 t s2, star ge s1 t s2 ->
+  forall ge s1 t s2 (INTACT: trace_intact t), star ge s1 t s2 ->
   forall T, forever ge s2 T ->
   forever ge s1 (t *** T).
 Proof.
-  induction 1; intros. simpl. auto.
+  induction 2; intros. simpl. auto.
   subst t. rewrite Eappinf_assoc.
   econstructor; eauto.
+  apply trace_intact_app_rev in INTACT. des. auto.
+  eapply IHstar; eauto.
+  apply trace_intact_app_rev in INTACT. des. auto.
 Qed.
 
 (** An alternate, equivalent definition of [forever] that is useful
@@ -325,11 +329,13 @@ CoInductive forever_N (ge: genv) : A -> state -> traceinf -> Prop :=
       order a2 a1 ->
       forever_N ge a2 s2 T2 ->
       T1 = t *** T2 ->
+      forall (INTACT: trace_intact t),
       forever_N ge a1 s1 T1
   | forever_N_plus: forall s1 t s2 a1 a2 T1 T2,
       plus ge s1 t s2 ->
       forever_N ge a2 s2 T2 ->
       T1 = t *** T2 ->
+      forall (INTACT: trace_intact t),
       forever_N ge a1 s1 T1.
 
 Hypothesis order_wf: well_founded order.
@@ -338,7 +344,7 @@ Lemma forever_N_inv:
   forall ge a s T,
   forever_N ge a s T ->
   exists t, exists s', exists a', exists T',
-  step ge s t s' /\ forever_N ge a' s' T' /\ T = t *** T'.
+  step ge s t s' /\ forever_N ge a' s' T' /\ T = t *** T' /\ <<INTACT: trace_intact t>>.
 Proof.
   intros ge a0. pattern a0. apply (well_founded_ind order_wf).
   intros. inv H0.
@@ -348,14 +354,18 @@ Proof.
   change (E0 *** T2) with T2. apply H with a2. auto. auto.
   (* at least one transition *)
   exists t1; exists s0; exists x; exists (t2 *** T2).
+  apply trace_intact_app_rev in INTACT. des.
   split. auto. split. eapply forever_N_star; eauto.
+  split; cycle 1. auto.
   apply Eappinf_assoc.
   (* plus case *)
   inv H1.
   exists t1; exists s0; exists a2; exists (t2 *** T2).
   split. auto.
+  apply trace_intact_app_rev in INTACT. des.
   split. inv H3. auto.
   eapply forever_N_plus. econstructor; eauto. eauto. auto.
+  auto. split; cycle 1. auto.
   apply Eappinf_assoc.
 Qed.
 
@@ -363,8 +373,8 @@ Lemma forever_N_forever:
   forall ge a s T, forever_N ge a s T -> forever ge s T.
 Proof.
   cofix COINDHYP; intros.
-  destruct (forever_N_inv H) as [t [s' [a' [T' [P [Q R]]]]]].
-  rewrite R. apply forever_intro with s'. auto.
+  destruct (forever_N_inv H) as [t [s' [a' [T' [P [Q [R INTACT]]]]]]].
+  rewrite R. apply forever_intro with s'. auto. auto.
   apply COINDHYP with a'; auto.
 Qed.
 
@@ -375,16 +385,18 @@ CoInductive forever_plus (ge: genv) : state -> traceinf -> Prop :=
       plus ge s1 t s2 ->
       forever_plus ge s2 T2 ->
       T1 = t *** T2 ->
+      forall (INTACT: trace_intact t),
       forever_plus ge s1 T1.
 
 Lemma forever_plus_inv:
   forall ge s T,
   forever_plus ge s T ->
   exists s', exists t, exists T',
-  step ge s t s' /\ forever_plus ge s' T' /\ T = t *** T'.
+  step ge s t s' /\ forever_plus ge s' T' /\ T = t *** T' /\ <<INTACT: trace_intact t>>.
 Proof.
   intros. inv H. inv H0. exists s0; exists t1; exists (t2 *** T2).
   split. auto.
+  apply trace_intact_app_rev in INTACT. des.
   split. exploit star_inv; eauto. intros [[P Q] | R].
     subst. simpl. auto. econstructor; eauto.
   traceEq.
@@ -394,7 +406,7 @@ Lemma forever_plus_forever:
   forall ge s T, forever_plus ge s T -> forever ge s T.
 Proof.
   cofix COINDHYP; intros.
-  destruct (forever_plus_inv H) as [s' [t [T' [P [Q R]]]]].
+  destruct (forever_plus_inv H) as [s' [t [T' [P [Q [R INTACT]]]]]].
   subst. econstructor; eauto.
 Qed.
 
@@ -453,16 +465,17 @@ Qed.
 (** Infinitely many non-silent transitions *)
 
 CoInductive forever_reactive (ge: genv): state -> traceinf -> Prop :=
-  | forever_reactive_intro: forall s1 s2 t T,
+  | forever_reactive_intro: forall s1 s2 t T (INTACT: trace_intact t),
       star ge s1 t s2 -> t <> E0 -> forever_reactive ge s2 T ->
       forever_reactive ge s1 (t *** T).
 
 Lemma star_forever_reactive:
-  forall ge s1 t s2 T,
+  forall ge s1 t s2 T (INTACT: trace_intact t),
   star ge s1 t s2 -> forever_reactive ge s2 T ->
   forever_reactive ge s1 (t *** T).
 Proof.
   intros. inv H0. rewrite <- Eappinf_assoc. econstructor.
+  eapply trace_intact_app; eauto.
   eapply star_trans; eauto.
   red; intro. exploit Eapp_E0_inv; eauto. intros [P Q]. contradiction.
   auto.
@@ -479,7 +492,11 @@ Record semantics : Type := Semantics_gen {
   genvtype: Type;
   step : genvtype -> state -> trace -> state -> Prop;
   initial_state: state -> Prop;
+  initial_capture: state -> state -> Prop;
+  (* remove Senv.t, change name to initial_pimap *)
+  initial_pimap: state -> positive -> option Z;
   final_state: state -> int -> Prop;
+  is_external: genvtype -> state -> Prop;
   globalenv: genvtype;
   symbolenv: Senv.t
 }.
@@ -489,13 +506,19 @@ Record semantics : Type := Semantics_gen {
 Definition Semantics {state funtype vartype: Type}
                      (step: Genv.t funtype vartype -> state -> trace -> state -> Prop)
                      (initial_state: state -> Prop)
+                     (initial_capture: state -> state -> Prop)
+                     (initial_pimap: state -> positive -> option Z)
                      (final_state: state -> int -> Prop)
+                     (is_external: Genv.t funtype vartype -> state -> Prop)
                      (globalenv: Genv.t funtype vartype) :=
   {| state := state;
      genvtype := Genv.t funtype vartype;
      step := step;
      initial_state := initial_state;
+     initial_capture := initial_capture;
+     initial_pimap := initial_pimap;
      final_state := final_state;
+     is_external := is_external;
      globalenv := globalenv;
      symbolenv := Genv.to_senv globalenv |}.
 
@@ -1721,12 +1744,20 @@ Inductive atomic_step (ge: genvtype L): (trace * state L) -> trace -> (trace * s
       output_trace (ev :: t) ->
       atomic_step ge (ev :: t, s) (ev :: nil) (t, s).
 
+Inductive atomic_init_capture : (trace * state L) -> (trace * state L) -> Prop :=
+  | atomic_init_capture_intro s s'
+      (CAP: L.(initial_capture) s s') :
+    atomic_init_capture (E0, s) (E0, s').
+
 Definition atomic : semantics := {|
   state := (trace * state L)%type;
   genvtype := genvtype L;
   step := atomic_step;
   initial_state := fun s => initial_state L (snd s) /\ fst s = E0;
+  initial_capture := atomic_init_capture;
+  initial_pimap := fun s => initial_pimap L (snd s);
   final_state := fun s r => final_state L (snd s) r /\ fst s = E0;
+  is_external := fun ge s => is_external L ge (snd s);
   globalenv := globalenv L;
   symbolenv := symbolenv L
 |}.
diff --git a/common/Values.v b/common/Values.v
index 891c9a88..0870dcfb 100644
--- a/common/Values.v
+++ b/common/Values.v
@@ -21,6 +21,7 @@ Require Import Coqlib.
 Require Import AST.
 Require Import Integers.
 Require Import Floats.
+Require Import sflib.
 
 Definition block : Type := positive.
 Definition eq_block := peq.
@@ -55,6 +56,21 @@ Definition Vnullptr :=
 Definition Vptrofs (n: ptrofs) :=
   if Archi.ptr64 then Vlong (Ptrofs.to_int64 n) else Vint (Ptrofs.to_int n).
 
+Definition is_ptr_val (v: val) : bool :=
+  match v with
+  | Vint _ => if negb Archi.ptr64 then true else false
+  | Vlong _ => if Archi.ptr64 then true else false
+  | Vptr _ _ => true
+  | _ => false
+  end.
+
+Definition is_int_value (v: val) : Prop :=
+  match v with
+  | Vlong _ => if Archi.ptr64 then True else False
+  | Vint _ => if negb Archi.ptr64 then False else True
+  | _ => False
+  end.
+
 (** * Operations over values *)
 
 (** The module [Val] defines a number of arithmetic and logical operations
@@ -322,6 +338,15 @@ Definition sub (v1 v2: val): val :=
   match v1, v2 with
   | Vint n1, Vint n2 => Vint(Int.sub n1 n2)
   | Vptr b1 ofs1, Vint n2 => if Archi.ptr64 then Vundef else Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int n2))
+  (* | Vptr b1 ofs1, Vptr b2 ofs2 => *)
+  (*     if Archi.ptr64 then Vundef else *)
+  (*     if eq_block b1 b2 then Vint(Ptrofs.to_int (Ptrofs.sub ofs1 ofs2)) else Vundef *)
+  | _, _ => Vundef
+  end.
+
+Definition psub (v1 v2: val): val :=
+  match v1, v2 with
+  | Vint n1, Vint n2 => if Archi.ptr64 then Vundef else Vint(Int.sub n1 n2)
   | Vptr b1 ofs1, Vptr b2 ofs2 =>
       if Archi.ptr64 then Vundef else
       if eq_block b1 b2 then Vint(Ptrofs.to_int (Ptrofs.sub ofs1 ofs2)) else Vundef
@@ -638,6 +663,15 @@ Definition subl (v1 v2: val): val :=
   | Vlong n1, Vlong n2 => Vlong(Int64.sub n1 n2)
   | Vptr b1 ofs1, Vlong n2 =>
       if Archi.ptr64 then Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int64 n2)) else Vundef
+  (* | Vptr b1 ofs1, Vptr b2 ofs2 => *)
+  (*     if negb Archi.ptr64 then Vundef else *)
+  (*     if eq_block b1 b2 then Vlong(Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs2)) else Vundef *)
+  | _, _ => Vundef
+  end.
+
+Definition psubl (v1 v2: val): val :=
+  match v1, v2 with
+  | Vlong n1, Vlong n2 => if Archi.ptr64 then Vlong(Int64.sub n1 n2) else Vundef
   | Vptr b1 ofs1, Vptr b2 ofs2 =>
       if negb Archi.ptr64 then Vundef else
       if eq_block b1 b2 then Vlong(Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs2)) else Vundef
@@ -1182,6 +1216,15 @@ Proof.
 - rewrite Int.sub_add_l; auto.
 - rewrite Int.sub_add_l; auto.
 - rewrite Ptrofs.sub_add_l; auto.
+(* - destruct (eq_block b b0); auto. *)
+(*   f_equal. rewrite Ptrofs.sub_add_l. auto with ptrofs. *)
+Qed.
+
+Theorem psub_add_l
+  v1 v2 i: psub (add v1 (Vint i)) v2 = add (psub v1 v2) (Vint i).
+Proof.
+  unfold psub, add; intros; destruct Archi.ptr64 eqn:SF, v1, v2; auto.
+- rewrite Int.sub_add_l; auto.
 - destruct (eq_block b b0); auto.
   f_equal. rewrite Ptrofs.sub_add_l. auto with ptrofs.
 Qed.
@@ -1196,6 +1239,15 @@ Proof.
   rewrite Ptrofs.sub_add_r. f_equal.
   symmetry. auto with ptrofs.
   symmetry. rewrite Int.add_commut. auto with ptrofs.
+(* - destruct (eq_block b b0); auto. *)
+(*   f_equal. rewrite Ptrofs.add_commut. rewrite Ptrofs.sub_add_r. auto with ptrofs. *)
+Qed.
+
+Theorem psub_add_r
+  v1 v2 i: psub v1 (add v2 (Vint i)) = add (psub v1 v2) (Vint (Int.neg i)).
+Proof.
+  unfold psub, add; intros; destruct Archi.ptr64 eqn:SF, v1, v2; auto.
+- rewrite Int.add_commut. rewrite Int.sub_add_r. auto.
 - destruct (eq_block b b0); auto.
   f_equal. rewrite Ptrofs.add_commut. rewrite Ptrofs.sub_add_r. auto with ptrofs.
 Qed.
@@ -1553,9 +1605,16 @@ Proof.
   unfold subl, addl; intros; destruct Archi.ptr64 eqn:SF, v1, v2; auto.
 - rewrite Int64.sub_add_l; auto.
 - rewrite Ptrofs.sub_add_l; auto.
+- rewrite Int64.sub_add_l; auto.
+Qed.
+
+Theorem psubl_addl_l
+  v1 v2 i: psubl (addl v1 (Vlong i)) v2 = addl (psubl v1 v2) (Vlong i).
+Proof.
+  unfold psubl, addl; intros; destruct Archi.ptr64 eqn:SF, v1, v2; auto.
+- rewrite Int64.sub_add_l; auto.  
 - destruct (eq_block b b0); auto.
   simpl. f_equal. rewrite Ptrofs.sub_add_l. auto with ptrofs.
-- rewrite Int64.sub_add_l; auto.
 Qed.
 
 Theorem subl_addl_r:
@@ -1567,9 +1626,16 @@ Proof.
   rewrite Ptrofs.sub_add_r. f_equal.
   symmetry. auto with ptrofs.
   symmetry. rewrite Int64.add_commut. auto with ptrofs.
+- rewrite Int64.add_commut. rewrite Int64.sub_add_r. auto.
+Qed.
+
+Theorem psubl_addl_r
+  v1 v2 i: psubl v1 (addl v2 (Vlong i)) = addl (psubl v1 v2) (Vlong (Int64.neg i)).
+Proof.
+  unfold psubl, addl; intros; destruct Archi.ptr64 eqn:SF, v1, v2; auto.
+- rewrite Int64.add_commut. rewrite Int64.sub_add_r. auto.  
 - destruct (eq_block b b0); auto.
   simpl; f_equal. rewrite Ptrofs.add_commut. rewrite Ptrofs.sub_add_r. auto with ptrofs.
-- rewrite Int64.add_commut. rewrite Int64.sub_add_r. auto.
 Qed.
 
 Theorem mull_commut: forall x y, mull x y = mull y x.
@@ -2122,7 +2188,7 @@ Proof.
 + destruct (valid_ptr b0 (Ptrofs.unsigned i) && valid_ptr b1 (Ptrofs.unsigned i0)) eqn:A; inv H2.
   InvBooleans. rewrite ! H; auto.
 Qed.
-
+        
 Lemma of_optbool_lessdef:
   forall ob ob',
   (forall b, ob = Some b -> ob' = Some b) ->
@@ -2283,8 +2349,23 @@ Proof.
 - inv H; inv H0; simpl; auto.
 + econstructor; eauto.
   rewrite Ptrofs.sub_add_l. auto.
-+ destruct (eq_block b1 b0); auto.
-  subst. rewrite H1 in H. inv H. rewrite dec_eq_true.
+(* + destruct (eq_block b1 b0); auto. *)
+(*   subst. rewrite H1 in H. inv H. rewrite dec_eq_true. *)
+(*   rewrite Ptrofs.sub_shifted. auto. *)
+Qed.
+
+Remark psub_inject
+  v1 v1' v2 v2'
+  (INJ1: inject f v1 v1')
+  (INJ2: inject f v2 v2')
+  :
+  <<INJ: inject f (Val.psub v1 v2) (Val.psub v1' v2')>>.
+Proof.
+  intros. unfold Val.psub. destruct Archi.ptr64 eqn:SF.
+- inv INJ1; inv INJ2; constructor.
+- inv INJ1; inv INJ2; simpl; auto.
+  destruct (eq_block b1 b0); auto.
+  subst. rewrite H0 in H. inv H. rewrite dec_eq_true.
   rewrite Ptrofs.sub_shifted. auto.
 Qed.
 
@@ -2313,12 +2394,24 @@ Proof.
 - inv H; inv H0; simpl; auto.
 + econstructor; eauto.
   rewrite Ptrofs.sub_add_l. auto.
-+ destruct (eq_block b1 b0); auto.
-  subst. rewrite H1 in H. inv H. rewrite dec_eq_true.
-  rewrite Ptrofs.sub_shifted. auto.
 - inv H; inv H0; constructor.
 Qed.
 
+Remark psubl_inject
+  v1 v1' v2 v2'
+  (INJ1: inject f v1 v1')
+  (INJ2: inject f v2 v2')
+  :
+  <<INJ: inject f (Val.psubl v1 v2) (Val.psubl v1' v2')>>.
+Proof.
+  intros. unfold Val.psubl. destruct Archi.ptr64 eqn:SF.
+- inv INJ1; inv INJ2; simpl; auto.
+  destruct (eq_block b1 b0); auto.
+  subst. rewrite H0 in H. inv H. rewrite dec_eq_true.
+  rewrite Ptrofs.sub_shifted. auto.
+- inv INJ1; inv INJ2; constructor.
+Qed.
+
 Lemma offset_ptr_inject:
   forall v v' ofs, inject f v v' -> inject f (offset_ptr v ofs) (offset_ptr v' ofs).
 Proof.
@@ -2601,3 +2694,4 @@ Proof.
   unfold compose_meminj; rewrite H1; rewrite H3; eauto.
   rewrite Ptrofs.add_assoc. decEq. unfold Ptrofs.add. apply Ptrofs.eqm_samerepr. auto with ints.
 Qed.
+
diff --git a/driver/Compiler.v b/driver/Compiler.v
index 5c37f3f3..6cbdaa83 100644
--- a/driver/Compiler.v
+++ b/driver/Compiler.v
@@ -17,7 +17,7 @@ Require Import String.
 Require Import Coqlib Errors.
 Require Import AST Linking Smallstep.
 (** Languages (syntax and semantics). *)
-Require Ctypes Csyntax Csem Cstrategy Cexec.
+Require Ctypes Csyntax Csem (* Cstrategy *) Cexec.
 Require Clight.
 Require Csharpminor.
 Require Cminor.
@@ -47,8 +47,9 @@ Require RTLnorm.
 Require RTLdfs.
 Require RTLdfsgen.
 Require SSAvalid.
-Require SCCPopt.
-Require GVNopt.
+(* Require SCCPopt. *)
+Require Captureprop.
+Require Copyprop.
 Require CSSAgen.
 Require RTLpargen.
 Require RTLparcleanup.
@@ -80,8 +81,9 @@ Require Unusedglobproof.
 Require RTLnormproof.
 Require RTLdfsproof.
 Require SSAvalidproof.
-Require SCCPoptproof.
-Require GVNoptproof.
+(* Require SCCPoptproof. *)
+Require Capturepropproof.
+Require Copypropproof.
 Require CSSAproof CSSAgenwf.
 Require RTLparproof.
 Require RTLparcleanup.
@@ -96,6 +98,7 @@ Require Stackingproof.
 Require Asmgenproof.
 (** Command-line flags. *)
 Require Import Compopts.
+Require Import sflib.
 
 (** Pretty-printers (defined in Caml). *)
 Parameter print_Clight: Clight.program -> unit.
@@ -194,16 +197,17 @@ Definition transf_rtl_program_via_SSA (f: RTL.program) : res Asm.program :=
    @@ print (print_RTL 7)
   @@@ time "Unused globals" Unusedglob.transform_program
    @@ print (print_RTL 8)
-
+   
   @@@ time "RTL normalization" RTLnorm.transl_program
   @@@ time "RTL unreachable code elimination" RTLdfsgen.transf_program
    @@ print print_RTL_norm
   @@@ time "SSA generation" SSAvalid.transf_program
    @@ print (print_SSA 0)
-   @@ time "GVN optimization" GVNopt.transf_program
+   @@ time "Copy Propagation" Copyprop.transf_program
    @@ print (print_SSA 1)
-   @@ time "SCCP optimization" SCCPopt.transf_program
+  @@@ time "Capture Propagation" Captureprop.transf_program
    @@ print (print_SSA 2)
+
   @@@ time "CSSA generation" CSSAgen.transl_program
    @@ print print_CSSA
   @@@ time "RTLpargen" RTLpargen.transl_program
@@ -213,6 +217,9 @@ Definition transf_rtl_program_via_SSA (f: RTL.program) : res Asm.program :=
    @@ time "Renumbering" Renumber.transf_program
    @@ print (print_RTL 9)
 
+  @@@ partial_if Compopts.optim_CSE (time "CSE" CSE.transf_program)
+   @@ print (print_RTL 10)
+
   @@@ time "Register allocation" Allocation.transf_program
    @@ print print_LTL
    @@ time "Branch tunneling" Tunneling.tunnel_program
@@ -245,6 +252,13 @@ Definition transf_clight_program (p: Clight.program) : res Asm.program :=
   @@@ time "Cminor generation" Cminorgen.transl_program
   @@@ transf_cminor_program.
 
+Definition transf_clight2_program (p: Clight.program) : res Asm.program :=
+  OK p
+   @@ print print_Clight
+  @@@ time "C#minor generation" Cshmgen.transl_program
+  @@@ time "Cminor generation" Cminorgen.transl_program
+  @@@ transf_cminor_program.
+
 Definition transf_clight_program_via_SSA (p: Clight.program) : res Asm.program :=
   OK p
    @@ print print_Clight
@@ -253,6 +267,13 @@ Definition transf_clight_program_via_SSA (p: Clight.program) : res Asm.program :
   @@@ time "Cminor generation" Cminorgen.transl_program
   @@@ transf_cminor_program_via_SSA.
 
+Definition transf_clight2_program_via_SSA (p: Clight.program) : res Asm.program :=
+  OK p
+   @@ print print_Clight
+  @@@ time "C#minor generation" Cshmgen.transl_program
+  @@@ time "Cminor generation" Cminorgen.transl_program
+  @@@ transf_cminor_program_via_SSA.
+
 Definition transf_c_program (p: Csyntax.program) : res Asm.program :=
   OK p
   @@@ time "Clight generation" SimplExpr.transl_program
@@ -364,18 +385,136 @@ Definition CompCertSSA's_passes :=
   ::: mkpass (match_if Compopts.optim_CSE CSEproof.match_prog)
   ::: mkpass (match_if Compopts.optim_redundancy Deadcodeproof.match_prog)
   ::: mkpass Unusedglobproof.match_prog
+  
+  ::: mkpass RTLnormproof.match_prog
+  ::: mkpass RTLdfsproof.match_prog
+  ::: mkpass SSAvalidproof.match_prog
+  ::: mkpass Copypropproof.match_prog
+  ::: mkpass Capturepropproof.match_prog
+  ::: mkpass CSSAproof.match_prog
+  ::: mkpass RTLparproof.match_prog
+  ::: mkpass RTLparcleanup.match_prog
+  ::: mkpass RTLdparproof.match_prog
+  ::: mkpass Renumberproof.match_prog
+
+  ::: mkpass (match_if Compopts.optim_CSE CSEproof.match_prog)
+  
+  ::: mkpass Allocproof.match_prog
+  ::: mkpass Tunnelingproof.match_prog
+  ::: mkpass Linearizeproof.match_prog
+  ::: mkpass CleanupLabelsproof.match_prog
+  ::: mkpass (match_if Compopts.debug Debugvarproof.match_prog)
+  ::: mkpass Stackingproof.match_prog
+  ::: mkpass Asmgenproof.match_prog
+  ::: pass_nil _.
+
+Definition Clight_to_Asm :=
+      mkpass SimplLocalsproof.match_prog
+  ::: mkpass Cshmgenproof.match_prog
+  ::: mkpass Cminorgenproof.match_prog
+  ::: mkpass Selectionproof.match_prog
+  ::: mkpass RTLgenproof.match_prog
+  ::: mkpass (match_if Compopts.optim_tailcalls Tailcallproof.match_prog)
+  ::: mkpass Inliningproof.match_prog
+  ::: mkpass Renumberproof.match_prog
+  ::: mkpass (match_if Compopts.optim_constprop Constpropproof.match_prog)
+  ::: mkpass (match_if Compopts.optim_constprop Renumberproof.match_prog)
+  ::: mkpass (match_if Compopts.optim_CSE CSEproof.match_prog)
+  ::: mkpass (match_if Compopts.optim_redundancy Deadcodeproof.match_prog)
+  ::: mkpass Unusedglobproof.match_prog
+  ::: mkpass Allocproof.match_prog
+  ::: mkpass Tunnelingproof.match_prog
+  ::: mkpass Linearizeproof.match_prog
+  ::: mkpass CleanupLabelsproof.match_prog
+  ::: mkpass (match_if Compopts.debug Debugvarproof.match_prog)
+  ::: mkpass Stackingproof.match_prog
+  ::: mkpass Asmgenproof.match_prog
+  ::: pass_nil _.
+
+Definition Clight2_to_Asm :=
+      mkpass Cshmgenproof.match_prog
+  ::: mkpass Cminorgenproof.match_prog
+  ::: mkpass Selectionproof.match_prog
+  ::: mkpass RTLgenproof.match_prog
+  ::: mkpass (match_if Compopts.optim_tailcalls Tailcallproof.match_prog)
+  ::: mkpass Inliningproof.match_prog
+  ::: mkpass Renumberproof.match_prog
+  ::: mkpass (match_if Compopts.optim_constprop Constpropproof.match_prog)
+  ::: mkpass (match_if Compopts.optim_constprop Renumberproof.match_prog)
+  ::: mkpass (match_if Compopts.optim_CSE CSEproof.match_prog)
+  ::: mkpass (match_if Compopts.optim_redundancy Deadcodeproof.match_prog)
+  ::: mkpass Unusedglobproof.match_prog
+  ::: mkpass Allocproof.match_prog
+  ::: mkpass Tunnelingproof.match_prog
+  ::: mkpass Linearizeproof.match_prog
+  ::: mkpass CleanupLabelsproof.match_prog
+  ::: mkpass (match_if Compopts.debug Debugvarproof.match_prog)
+  ::: mkpass Stackingproof.match_prog
+  ::: mkpass Asmgenproof.match_prog
+  ::: pass_nil _.
 
+Definition Clight_to_Asm_ssa :=
+      mkpass SimplLocalsproof.match_prog
+  ::: mkpass Cshmgenproof.match_prog
+  ::: mkpass Cminorgenproof.match_prog
+  ::: mkpass Selectionproof.match_prog
+  ::: mkpass RTLgenproof.match_prog
+  ::: mkpass (match_if Compopts.optim_tailcalls Tailcallproof.match_prog)
+  ::: mkpass Inliningproof.match_prog
+  ::: mkpass Renumberproof.match_prog
+  ::: mkpass (match_if Compopts.optim_constprop Constpropproof.match_prog)
+  ::: mkpass (match_if Compopts.optim_constprop Renumberproof.match_prog)
+  ::: mkpass (match_if Compopts.optim_CSE CSEproof.match_prog)
+  ::: mkpass (match_if Compopts.optim_redundancy Deadcodeproof.match_prog)
+  ::: mkpass Unusedglobproof.match_prog
+  
   ::: mkpass RTLnormproof.match_prog
   ::: mkpass RTLdfsproof.match_prog
   ::: mkpass SSAvalidproof.match_prog
-  ::: mkpass GVNoptproof.match_prog
-  ::: mkpass SCCPoptproof.match_prog
+  ::: mkpass Copypropproof.match_prog
+  ::: mkpass Capturepropproof.match_prog
   ::: mkpass CSSAproof.match_prog
   ::: mkpass RTLparproof.match_prog
   ::: mkpass RTLparcleanup.match_prog
   ::: mkpass RTLdparproof.match_prog
   ::: mkpass Renumberproof.match_prog
+  ::: mkpass (match_if Compopts.optim_CSE CSEproof.match_prog)
+  
+  ::: mkpass Allocproof.match_prog
+  ::: mkpass Tunnelingproof.match_prog
+  ::: mkpass Linearizeproof.match_prog
+  ::: mkpass CleanupLabelsproof.match_prog
+  ::: mkpass (match_if Compopts.debug Debugvarproof.match_prog)
+  ::: mkpass Stackingproof.match_prog
+  ::: mkpass Asmgenproof.match_prog
+  ::: pass_nil _.
 
+Definition Clight2_to_Asm_ssa :=
+      mkpass Cshmgenproof.match_prog
+  ::: mkpass Cminorgenproof.match_prog
+  ::: mkpass Selectionproof.match_prog
+  ::: mkpass RTLgenproof.match_prog
+  ::: mkpass (match_if Compopts.optim_tailcalls Tailcallproof.match_prog)
+  ::: mkpass Inliningproof.match_prog
+  ::: mkpass Renumberproof.match_prog
+  ::: mkpass (match_if Compopts.optim_constprop Constpropproof.match_prog)
+  ::: mkpass (match_if Compopts.optim_constprop Renumberproof.match_prog)
+  ::: mkpass (match_if Compopts.optim_CSE CSEproof.match_prog)
+  ::: mkpass (match_if Compopts.optim_redundancy Deadcodeproof.match_prog)
+  ::: mkpass Unusedglobproof.match_prog
+  
+  ::: mkpass RTLnormproof.match_prog
+  ::: mkpass RTLdfsproof.match_prog
+  ::: mkpass SSAvalidproof.match_prog
+  ::: mkpass Copypropproof.match_prog
+  ::: mkpass Capturepropproof.match_prog
+  ::: mkpass CSSAproof.match_prog
+  ::: mkpass RTLparproof.match_prog
+  ::: mkpass RTLparcleanup.match_prog
+  ::: mkpass RTLdparproof.match_prog
+  ::: mkpass Renumberproof.match_prog
+  ::: mkpass (match_if Compopts.optim_CSE CSEproof.match_prog)
+  
   ::: mkpass Allocproof.match_prog
   ::: mkpass Tunnelingproof.match_prog
   ::: mkpass Linearizeproof.match_prog
@@ -392,20 +531,23 @@ Definition CompCertSSA's_passes :=
 Definition match_prog: Csyntax.program -> Asm.program -> Prop :=
   pass_match (compose_passes CompCert's_passes).
 
+Definition match_prog_clight: Clight.program -> Asm.program -> Prop :=
+  pass_match (compose_passes Clight_to_Asm).
+
+Definition match_prog_clight2: Clight.program -> Asm.program -> Prop :=
+  pass_match (compose_passes Clight2_to_Asm).
+
 (** The [transf_c_program] function, when successful, produces
   assembly code that is in the [match_prog] relation with the source C program. *)
 
-Theorem transf_c_program_match:
+Theorem transf_clight2_program_match:
   forall p tp,
-  transf_c_program p = OK tp ->
-  match_prog p tp.
+  transf_clight2_program p = OK tp ->
+  match_prog_clight2 p tp.
 Proof.
   intros p tp T.
-  unfold transf_c_program, time in T. simpl in T.
-  destruct (SimplExpr.transl_program p) as [p1|e] eqn:P1; simpl in T; try discriminate.
-  unfold transf_clight_program, time in T. rewrite ! compose_print_identity in T. simpl in T.
-  destruct (SimplLocals.transf_program p1) as [p2|e] eqn:P2; simpl in T; try discriminate.
-  destruct (Cshmgen.transl_program p2) as [p3|e] eqn:P3; simpl in T; try discriminate.
+  unfold transf_clight2_program, time in T. rewrite ! compose_print_identity in T. simpl in T.
+  destruct (Cshmgen.transl_program p) as [p3|e] eqn:P3; simpl in T; try discriminate.
   destruct (Cminorgen.transl_program p3) as [p4|e] eqn:P4; simpl in T; try discriminate.
   unfold transf_cminor_program, time in T. rewrite ! compose_print_identity in T. simpl in T.
   destruct (Selection.sel_program p4) as [p5|e] eqn:P5; simpl in T; try discriminate.
@@ -425,9 +567,7 @@ Proof.
   set (p18 := CleanupLabels.transf_program p17) in *.
   destruct (partial_if debug Debugvar.transf_program p18) as [p19|e] eqn:P19; simpl in T; try discriminate.
   destruct (Stacking.transf_program p19) as [p20|e] eqn:P20; simpl in T; try discriminate.
-  unfold match_prog; simpl.
-  exists p1; split. apply SimplExprproof.transf_program_match; auto.
-  exists p2; split. apply SimplLocalsproof.match_transf_program; auto.
+  unfold match_prog_clight; simpl.
   exists p3; split. apply Cshmgenproof.transf_program_match; auto.
   exists p4; split. apply Cminorgenproof.transf_program_match; auto.
   exists p5; split. apply Selectionproof.transf_program_match; auto.
@@ -450,11 +590,31 @@ Proof.
   reflexivity.
 Qed.
 
+Theorem transf_clight_program_match:
+  forall p tp,
+  transf_clight_program p = OK tp ->
+  match_prog_clight p tp.
+Proof.
+  intros p tp T.
+  unfold transf_clight_program, time in T. rewrite ! compose_print_identity in T. simpl in T.
+  destruct (SimplLocals.transf_program p) as [p2|e] eqn:P2; simpl in T; try discriminate.
+
+  unfold match_prog_clight; simpl.
+  exists p2; split. apply SimplLocalsproof.match_transf_program; auto.
+  eapply transf_clight2_program_match; eauto.
+Qed.
+
 (** The [transf_c_program_via_SSA] function, when successful, produces
   assembly code that is in the [match_prog_SSA] relation with the source C program. *)
 Definition match_prog_SSA: Csyntax.program -> Asm.program -> Prop :=
   pass_match (compose_passes CompCertSSA's_passes).
 
+Definition match_prog_SSA_clight: Clight.program -> Asm.program -> Prop :=
+  pass_match (compose_passes Clight_to_Asm_ssa).
+
+Definition match_prog_SSA_clight2: Clight.program -> Asm.program -> Prop :=
+  pass_match (compose_passes Clight2_to_Asm_ssa).
+
 Lemma simpl_total_if : forall (A: Type) (x: A) b (f: A -> A),
     OK x @@ total_if b f = OK (total_if b f x).
 Proof.
@@ -467,25 +627,31 @@ Proof.
   reflexivity.
 Qed.
 
-Theorem transf_c_program_via_SSA_match:
+Theorem transf_clight2_program_via_SSA_match:
   forall p tp,
-  transf_c_program_via_SSA p = OK tp ->
-  match_prog_SSA p tp.
+  transf_clight2_program_via_SSA p = OK tp ->
+  match_prog_SSA_clight2 p tp.
 Proof.
   intros p tp T.
-  unfold transf_c_program_via_SSA, time in T. simpl in T.
-  destruct (SimplExpr.transl_program p) as [p1|e] eqn:P1; simpl in T; try discriminate.
-  unfold transf_clight_program_via_SSA, time in T. rewrite ! compose_print_identity in T. simpl in T.
-  destruct (SimplLocals.transf_program p1) as [p2|e] eqn:P2; simpl in T; try discriminate.
-  destruct (Cshmgen.transl_program p2) as [p3|e] eqn:P3; simpl in T; try discriminate.
+  unfold transf_clight2_program_via_SSA, time in T. rewrite ! compose_print_identity in T. simpl in T.
+  destruct (Cshmgen.transl_program p) as [p3|e] eqn:P3; simpl in T; try discriminate.
   destruct (Cminorgen.transl_program p3) as [p4|e] eqn:P4; simpl in T; try discriminate.
   unfold transf_cminor_program_via_SSA, time in T. rewrite ! compose_print_identity in T. simpl in T.
   destruct (Selection.sel_program p4) as [p5|e] eqn:P5; simpl in T; try discriminate.
   destruct (RTLgen.transl_program p5) as [p6|e] eqn:P6; simpl in T; try discriminate.
   unfold transf_rtl_program_via_SSA, time in T. rewrite ! compose_print_identity in T.
-  rewrite simpl_total_if in T; rewrite simpl_partial_total in T.
+  replace (OK p6 @@ total_if optim_tailcalls Tailcall.transf_program @@@ Inlining.transf_program) with
+    (Inlining.transf_program (total_if optim_tailcalls Tailcall.transf_program p6)) in T.
+  2:{ simpl. auto. }
   set (p7 := total_if optim_tailcalls Tailcall.transf_program p6) in *.
-  destruct (Inlining.transf_program p7) as [p8|e] eqn:P8; simpl in T; try discriminate.
+  destruct (Inlining.transf_program p7) as [p8|e] eqn:P8.
+  2:{ simpl in T. clarify. }
+  replace (OK p8 @@ Renumber.transf_program @@ total_if optim_constprop Constprop.transf_program @@
+             total_if optim_constprop Renumber.transf_program @@@ partial_if optim_CSE CSE.transf_program) with
+    (partial_if optim_CSE CSE.transf_program
+        (total_if optim_constprop Renumber.transf_program
+           (total_if optim_constprop Constprop.transf_program (Renumber.transf_program p8)))) in T.
+  2:{ simpl. auto. }
   set (p9 := Renumber.transf_program p8) in *.
   set (p10 := total_if optim_constprop Constprop.transf_program p9) in *.
   set (p11 := total_if optim_constprop Renumber.transf_program p10) in *.
@@ -496,27 +662,23 @@ Proof.
   destruct (RTLnorm.transl_program p14) as [p141|e] eqn:P141; simpl in T; try discriminate.
   destruct (RTLdfsgen.transf_program p141) as [p142|e] eqn:P142; simpl in T; try discriminate.
   destruct (SSAvalid.transf_program p142) as [p143|e] eqn:P143; simpl in T; try discriminate.
-  set (p144 := GVNopt.transf_program p143) in *.
-  set (p145 := SCCPopt.transf_program p144) in *.
-
-  destruct (CSSAgen.transl_program p145) as [p146|e] eqn: P146; simpl in T; try discriminate.
+  set (p144 := Copyprop.transf_program p143) in *.
+  destruct (Captureprop.transf_program p144) as [p101|e] eqn:P101; simpl in T; try discriminate.
+    
+  destruct (CSSAgen.transl_program p101) as [p146|e] eqn: P146; simpl in T; try discriminate.
   destruct (RTLpargen.transl_program p146) as [p147|e] eqn: P147; simpl in T; try discriminate.
   destruct (RTLparcleanup.transl_program p147) as [p148|e] eqn: P148; simpl in T; try discriminate.
   destruct (RTLdpar.transl_program p148) as [p149|e] eqn:P149; simpl in T; try discriminate.
-
   set (p150 := Renumber.transf_program p149) in *.
-
-  destruct (Allocation.transf_program p150) as [p15|e] eqn:P15; simpl in T; try discriminate.
+  destruct (partial_if optim_CSE CSE.transf_program p150) as [p151|e] eqn:P151; simpl in T; try discriminate.
+  
+  destruct (Allocation.transf_program p151) as [p15|e] eqn:P15; simpl in T; try discriminate.
   set (p16 := Tunneling.tunnel_program p15) in *.
   destruct (Linearize.transf_program p16) as [p17|e] eqn:P17; simpl in T; try discriminate.
   set (p18 := CleanupLabels.transf_program p17) in *.
   destruct (partial_if debug Debugvar.transf_program p18) as [p19|e] eqn:P19; simpl in T; try discriminate.
   destruct (Stacking.transf_program p19) as [p20|e] eqn:P20; simpl in T; try discriminate.
-
-  unfold match_prog_SSA; simpl.
-
-  exists p1; split. apply SimplExprproof.transf_program_match; auto.
-  exists p2; split. apply SimplLocalsproof.match_transf_program; auto.
+  unfold match_prog_SSA_clight; simpl.
   exists p3; split. apply Cshmgenproof.transf_program_match; auto.
   exists p4; split. apply Cminorgenproof.transf_program_match; auto.
   exists p5; split. apply Selectionproof.transf_program_match; auto.
@@ -529,12 +691,12 @@ Proof.
   exists p12; split. eapply partial_if_match; eauto. apply CSEproof.transf_program_match.
   exists p13; split. eapply partial_if_match; eauto. apply Deadcodeproof.transf_program_match.
   exists p14; split. apply Unusedglobproof.transf_program_match; auto.
-
   exists p141; split. apply RTLnormproof.transf_program_match; auto.
   exists p142; split. apply RTLdfsproof.transf_program_match; auto.
   exists p143; split. apply SSAvalidproof.transf_program_match; auto.
-  exists p144; split. apply GVNoptproof.transf_program_match; auto.
-  exists p145; split. apply SCCPoptproof.transf_program_match; auto.
+  exists p144; split. apply Copypropproof.transf_program_match; auto.
+  exists p101; split. apply Capturepropproof.transf_program_match; auto.
+  
 
   exists p146; split. apply CSSAproof.transf_program_match; auto.
   exists p147; split. apply RTLparproof.transf_program_match; auto.
@@ -542,7 +704,8 @@ Proof.
   exists p149; split. apply RTLdparproof.transf_program_match; auto.
 
   exists p150; split. apply Renumberproof.transf_program_match; auto.
-
+  exists p151; split. eapply partial_if_match; eauto. apply CSEproof.transf_program_match.
+  
   exists p15; split. apply Allocproof.transf_program_match; auto.
   exists p16; split. apply Tunnelingproof.transf_program_match.
   exists p17; split. apply Linearizeproof.transf_program_match; auto.
@@ -553,6 +716,21 @@ Proof.
   reflexivity.
 Qed.
 
+Theorem transf_clight_program_via_SSA_match:
+  forall p tp,
+  transf_clight_program_via_SSA p = OK tp ->
+  match_prog_SSA_clight p tp.
+Proof.
+  intros p tp T.
+  unfold transf_clight_program_via_SSA, time in T. rewrite ! compose_print_identity in T. simpl in T.
+  destruct (SimplLocals.transf_program p) as [p2|e] eqn:P2; simpl in T; try discriminate.
+
+  unfold match_prog_SSA_clight; simpl.
+  exists p2; split. apply SimplLocalsproof.match_transf_program; auto.
+  eapply transf_clight2_program_via_SSA_match; eauto.
+Qed.
+
+
 (** * Semantic preservation *)
 
 (** We now prove that the whole CompCert compiler (as characterized by the
@@ -586,283 +764,3 @@ Proof.
   intros. unfold match_if in *. destruct (flag tt). eauto. subst. apply forward_simulation_identity.
 Qed.
 
-Theorem cstrategy_semantic_preservation:
-  forall p tp,
-  match_prog p tp ->
-  forward_simulation (Cstrategy.semantics p) (Asm.semantics tp)
-  /\ backward_simulation (atomic (Cstrategy.semantics p)) (Asm.semantics tp).
-Proof.
-  intros p tp M. unfold match_prog, pass_match in M; simpl in M.
-Ltac DestructM :=
-  match goal with
-    [ H: exists p, _ /\ _ |- _ ] =>
-      let p := fresh "p" in let M := fresh "M" in let MM := fresh "MM" in
-      destruct H as (p & M & MM); clear H
-  end.
-  repeat DestructM. subst tp.
-  assert (F: forward_simulation (Cstrategy.semantics p) (Asm.semantics p21)).
-  {
-  eapply compose_forward_simulations.
-    eapply SimplExprproof.transl_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply SimplLocalsproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply Cshmgenproof.transl_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply Cminorgenproof.transl_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply Selectionproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply RTLgenproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply match_if_simulation. eassumption. exact Tailcallproof.transf_program_correct.
-  eapply compose_forward_simulations.
-    eapply Inliningproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations. eapply Renumberproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply match_if_simulation. eassumption. exact Constpropproof.transf_program_correct.
-  eapply compose_forward_simulations.
-    eapply match_if_simulation. eassumption. exact Renumberproof.transf_program_correct.
-  eapply compose_forward_simulations.
-    eapply match_if_simulation. eassumption. exact CSEproof.transf_program_correct.
-  eapply compose_forward_simulations.
-    eapply match_if_simulation. eassumption. exact Deadcodeproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply Unusedglobproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply Allocproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply Tunnelingproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply Linearizeproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply CleanupLabelsproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply match_if_simulation. eassumption. exact Debugvarproof.transf_program_correct.
-  eapply compose_forward_simulations.
-    eapply Stackingproof.transf_program_correct with (return_address_offset := Asmgenproof0.return_address_offset).
-    exact Asmgenproof.return_address_exists.
-    eassumption.
-  eapply Asmgenproof.transf_program_correct; eassumption.
-  }
-  split. auto.
-  apply forward_to_backward_simulation.
-  apply factor_forward_simulation. auto. eapply sd_traces. eapply Asm.semantics_determinate.
-  apply atomic_receptive. apply Cstrategy.semantics_strongly_receptive.
-  apply Asm.semantics_determinate.
-Qed.
-
-Theorem cstrategy_semantic_preservation_via_SSA:
-  forall p tp,
-  match_prog_SSA p tp ->
-  forward_simulation (Cstrategy.semantics p) (Asm.semantics tp)
-  /\ backward_simulation (atomic (Cstrategy.semantics p)) (Asm.semantics tp).
-Proof.
-  intros p tp M. unfold match_prog_SSA, pass_match in M; simpl in M.
-  repeat DestructM. subst tp.
-  assert (F: forward_simulation (Cstrategy.semantics p) (Asm.semantics p31)).
-  {
-  eapply compose_forward_simulations.
-    eapply SimplExprproof.transl_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply SimplLocalsproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply Cshmgenproof.transl_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply Cminorgenproof.transl_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply Selectionproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply RTLgenproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply match_if_simulation. eassumption. exact Tailcallproof.transf_program_correct.
-  eapply compose_forward_simulations.
-    eapply Inliningproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations. eapply Renumberproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply match_if_simulation. eassumption. exact Constpropproof.transf_program_correct.
-  eapply compose_forward_simulations.
-    eapply match_if_simulation. eassumption. exact Renumberproof.transf_program_correct.
-  eapply compose_forward_simulations.
-    eapply match_if_simulation. eassumption. exact CSEproof.transf_program_correct.
-  eapply compose_forward_simulations.
-    eapply match_if_simulation. eassumption. exact Deadcodeproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply Unusedglobproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply RTLnormproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply RTLdfsproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply SSAvalidproof.transf_program_correct; eauto.
-    eapply RTLdfsproof.match_prog_wf_dfs; eauto.
-  eapply compose_forward_simulations.
-    eapply GVNoptproof.transf_program_correct; eauto.
-    eapply SSAvalidproof.match_prog_wf_ssa; eauto.
-    eapply RTLdfsproof.match_prog_wf_dfs; eauto.
-
-  eapply compose_forward_simulations.
-    eapply SCCPoptproof.transf_program_correct; eauto.
-    eapply GVNoptproof.match_prog_wf_ssa; eauto.
-    eapply SSAvalidproof.match_prog_wf_ssa; eauto.
-    eapply RTLdfsproof.match_prog_wf_dfs; eauto.
-
-  eapply compose_forward_simulations.
-    eapply CSSAproof.transf_program_correct; eauto.
-    eapply SCCPoptproof.match_prog_wf_ssa; eauto.
-    eapply GVNoptproof.match_prog_wf_ssa; eauto.
-    eapply SSAvalidproof.match_prog_wf_ssa; eauto.
-    eapply RTLdfsproof.match_prog_wf_dfs; eauto.
-
-  eapply compose_forward_simulations.
-    eapply RTLparproof.transf_program_correct; eauto.
-    eapply CSSAgenwf.wf_cssa_tprog; eauto.
-    eapply SCCPoptproof.match_prog_wf_ssa; eauto.
-    eapply GVNoptproof.match_prog_wf_ssa; eauto.
-    eapply SSAvalidproof.match_prog_wf_ssa; eauto.
-    eapply RTLdfsproof.match_prog_wf_dfs; eauto.
-
-  eapply compose_forward_simulations.
-   eapply RTLparcleanup.transf_program_correct; eauto.
-  eapply compose_forward_simulations.
-   eapply RTLdparproof.transf_program_correct; eauto.
-   eapply RTLparcleanup.match_prof_wf_program; eauto.
-   eapply RTLparproof.is_wf_program; eauto.
-   eapply CSSAgenwf.wf_cssa_tprog; eauto.
-   eapply SCCPoptproof.match_prog_wf_ssa; eauto.
-   eapply GVNoptproof.match_prog_wf_ssa; eauto.
-   eapply SSAvalidproof.match_prog_wf_ssa; eauto.
-   eapply RTLdfsproof.match_prog_wf_dfs; eauto.
-   eapply RTLparcleanup.is_mill_program; eauto.
-
-   eapply compose_forward_simulations.
-    eapply Renumberproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply Allocproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations.
-  eapply compose_forward_simulations.
-    eapply Tunnelingproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply Linearizeproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply CleanupLabelsproof.transf_program_correct; eassumption.
-  eapply compose_forward_simulations.
-    eapply match_if_simulation. eassumption. exact Debugvarproof.transf_program_correct.
-  eapply compose_forward_simulations.
-    eapply Stackingproof.transf_program_correct with (return_address_offset := Asmgenproof0.return_address_offset).
-    exact Asmgenproof.return_address_exists.
-    eassumption.
-    eapply Asmgenproof.transf_program_correct; eassumption.
-    eapply forward_simulation_identity.
-  }
-  split. auto.
-  apply forward_to_backward_simulation.
-  apply factor_forward_simulation. auto. eapply sd_traces. eapply Asm.semantics_determinate.
-  apply atomic_receptive. apply Cstrategy.semantics_strongly_receptive.
-  apply Asm.semantics_determinate.
-Qed.
-
-Theorem c_semantic_preservation:
-  forall p tp,
-  match_prog p tp ->
-  backward_simulation (Csem.semantics p) (Asm.semantics tp).
-Proof.
-  intros.
-  apply compose_backward_simulation with (atomic (Cstrategy.semantics p)).
-  eapply sd_traces; eapply Asm.semantics_determinate.
-  apply factor_backward_simulation.
-  apply Cstrategy.strategy_simulation.
-  apply Csem.semantics_single_events.
-  eapply ssr_well_behaved; eapply Cstrategy.semantics_strongly_receptive.
-  exact (proj2 (cstrategy_semantic_preservation _ _ H)).
-Qed.
-
-Theorem c_semantic_preservation_via_SSA:
-  forall p tp,
-  match_prog_SSA p tp ->
-  backward_simulation (Csem.semantics p) (Asm.semantics tp).
-Proof.
-  intros.
-  apply compose_backward_simulation with (atomic (Cstrategy.semantics p)).
-  eapply sd_traces; eapply Asm.semantics_determinate.
-  apply factor_backward_simulation.
-  apply Cstrategy.strategy_simulation.
-  apply Csem.semantics_single_events.
-  eapply ssr_well_behaved; eapply Cstrategy.semantics_strongly_receptive.
-  exact (proj2 (cstrategy_semantic_preservation_via_SSA _ _ H)).
-Qed.
-
-(** * Correctness of the CompCert compiler *)
-
-(** Combining the results above, we obtain semantic preservation for two
-  usage scenarios of CompCert: compilation of a single monolithic program,
-  and separate compilation of multiple source files followed by linking.
-
-  In the monolithic case, we have a whole C program [p] that is
-  compiled in one run of CompCert to a whole Asm program [tp].
-  Then, [tp] preserves the semantics of [p], in the sense that there
-  exists a backward simulation of the dynamic semantics of [p]
-  by the dynamic semantics of [tp]. *)
-
-Theorem transf_c_program_correct:
-  forall p tp,
-  transf_c_program p = OK tp ->
-  backward_simulation (Csem.semantics p) (Asm.semantics tp).
-Proof.
-  intros. apply c_semantic_preservation. apply transf_c_program_match; auto.
-Qed.
-
-Theorem transf_c_program_correct_via_SSA:
-  forall p tp,
-  transf_c_program_via_SSA p = OK tp ->
-  backward_simulation (Csem.semantics p) (Asm.semantics tp).
-Proof.
-  intros. apply c_semantic_preservation_via_SSA.
-  apply transf_c_program_via_SSA_match; auto.
-Qed.
-
-(** Here is the separate compilation case.  Consider a nonempty list [c_units]
-  of C source files (compilation units), [C1 ,,, Cn].  Assume that every
-  C compilation unit [Ci] is successfully compiled by CompCert, obtaining
-  an Asm compilation unit [Ai].  Let [asm_unit] be the nonempty list
-  [A1 ... An].  Further assume that the C units [C1 ... Cn] can be linked
-  together to produce a whole C program [c_program].  Then, the generated
-  Asm units can be linked together, producing a whole Asm program
-  [asm_program].  Moreover, [asm_program] preserves the semantics of
-  [c_program], in the sense that there exists a backward simulation of
-  the dynamic semantics of [asm_program] by the dynamic semantics of [c_program].
-*)
-
-Theorem separate_transf_c_program_correct:
-  forall c_units asm_units c_program,
-  nlist_forall2 (fun cu tcu => transf_c_program cu = OK tcu) c_units asm_units ->
-  link_list c_units = Some c_program ->
-  exists asm_program,
-      link_list asm_units = Some asm_program
-   /\ backward_simulation (Csem.semantics c_program) (Asm.semantics asm_program).
-Proof.
-  intros.
-  assert (nlist_forall2 match_prog c_units asm_units).
-  { eapply nlist_forall2_imply. eauto. simpl; intros. apply transf_c_program_match; auto. }
-  assert (exists asm_program, link_list asm_units = Some asm_program /\ match_prog c_program asm_program).
-  { eapply link_list_compose_passes; eauto. }
-  destruct H2 as (asm_program & P & Q).
-  exists asm_program; split; auto. apply c_semantic_preservation; auto.
-Qed.
-
-Theorem separate_transf_c_program_via_SSA_correct:
-  forall c_units asm_units c_program,
-  nlist_forall2 (fun cu tcu => transf_c_program_via_SSA cu = OK tcu) c_units asm_units ->
-  link_list c_units = Some c_program ->
-  exists asm_program,
-      link_list asm_units = Some asm_program
-   /\ backward_simulation (Csem.semantics c_program) (Asm.semantics asm_program).
-Proof.
-  intros.
-  assert (nlist_forall2 match_prog_SSA c_units asm_units).
-  { eapply nlist_forall2_imply. eauto. simpl; intros. apply transf_c_program_via_SSA_match; auto. }
-  assert (exists asm_program, link_list asm_units = Some asm_program /\ match_prog_SSA c_program asm_program).
-  { eapply link_list_compose_passes; eauto. }
-  destruct H2 as (asm_program & P & Q).
-  exists asm_program; split; auto. apply c_semantic_preservation_via_SSA; auto.
-Qed.
diff --git a/driver/Complements.v b/driver/Complements.v
index 7ad686e6..4e4dc07f 100644
--- a/driver/Complements.v
+++ b/driver/Complements.v
@@ -15,338 +15,837 @@
 Require Import Classical.
 Require Import Coqlib Errors.
 Require Import AST Linking Events Smallstep Behaviors.
-Require Import Csyntax Csem Cstrategy Asm.
+Require Import Csyntax Csem (* Cstrategy *) Asm.
 Require Import Compiler.
+Require Import sflib CoqlibC.
+Require Import ClightD CsharpminorD.
+Require Import Cminor CminorSelD RTL RTLD LTLD LinearD MachD.
+Require Import RTLdfsD SSAD CSSAD RTLparD.
+Require Import AsmD.
 
-(** * Preservation of whole-program behaviors *)
-
-(** From the simulation diagrams proved in file [Compiler]. it follows that
-  whole-program observable behaviors are preserved in the following sense.
-  First, every behavior of the generated assembly code is matched by
-  a behavior of the source C code.  The behavior [beh] of the assembly
-  code is either identical to the behavior [beh'] of the source C code
-  or ``improves upon'' [beh']  by replacing a ``going wrong'' behavior
-  with a more defined behavior. *)
-
-Theorem transf_c_program_preservation:
-  forall p tp beh,
-  transf_c_program p = OK tp ->
-  program_behaves (Asm.semantics tp) beh ->
-  exists beh', program_behaves (Csem.semantics p) beh' /\ behavior_improves beh' beh.
+Require Import Simulation.
+
+Set Implicit Arguments.
+
+Definition improves (L1 L2: semantics): Prop := forall obs2
+    (BEH: program_observes L2 obs2),
+    exists obs1, <<BEH: program_observes L1 obs1>> /\ <<IMPRV: observation_improves obs1 obs2>>.
+
+Global Program Instance improves_PreOrder: PreOrder improves.
+Next Obligation.
+  ii. esplits; eauto. eapply observation_improves_refl.
+Qed.
+Next Obligation.
+  ii. r in H. r in H0. repeat spc H0. des. specialize (H _ BEH0). des.
+  esplits; eauto. eapply observation_improves_trans; eauto.
+Qed.
+
+Lemma bsim_improves L1 L2
+      (BSIM: Simulation.backward_simulation L1 L2):
+    <<IMRPV: improves L1 L2>>.
 Proof.
-  intros. eapply backward_simulation_behavior_improves; eauto.
-  apply transf_c_program_correct; auto.
+  ii. eapply backward_simulation_observation_improves; eauto.
+  eapply backward_to_nostutter_backward_simulation. eauto.
 Qed.
 
-Theorem transf_c_program_preservation_via_SSA:
-  forall p tp beh,
-  transf_c_program_via_SSA p = OK tp ->
-  program_behaves (Asm.semantics tp) beh ->
-  exists beh', program_behaves (Csem.semantics p) beh' /\ behavior_improves beh' beh.
+Lemma rtc_improves src tgt
+    (REL: rtc improves src tgt) :
+  improves src tgt.
+Proof. induction REL; try refl. etrans; eauto. Qed.
+
+Section SimplLocals.
+
+  Lemma SimplLocals_correct src tgt
+      (TRANSF: SimplLocalsproof.match_prog src tgt):
+    improves (Clight.semantics1 src) (Clight.semantics2 tgt).
+  Proof.
+    eapply bsim_improves. eapply mixed_to_backward_simulation.
+    eapply SimplLocalsproof.transf_program_correct. eauto.
+  Qed.
+
+End SimplLocals.
+
+Section Cshmgen.
+
+  Lemma Cshmgen_correct src tgt
+      (TRANSF: Cshmgenproof.match_prog src tgt):
+    improves (Clight.semantics2 src) (Csharpminor.semantics tgt).
+  Proof.
+    eapply bsim_improves. eapply mixed_to_backward_simulation.
+    eapply Cshmgenproof.transl_program_correct. eauto.
+  Qed.
+
+End Cshmgen.
+
+Section Cminorgen.
+
+  Lemma Cminorgen_correct
+        src tgt
+        (TRANSF: Cminorgenproof.match_prog src tgt):
+    improves (Csharpminor.semantics src) (Cminor.semantics tgt).
+  Proof.
+    eapply bsim_improves. eapply mixed_to_backward_simulation.
+    eapply Cminorgenproof.transl_program_correct. eauto.
+  Qed.
+
+End Cminorgen.
+
+Section Selection.
+
+  Lemma Selection_correct src tgt
+      (TRANSF: Selectionproof.match_prog src tgt):
+    improves (Cminor.semantics src) (CminorSel.semantics tgt).
+  Proof.
+    eapply bsim_improves. eapply mixed_to_backward_simulation.
+    eapply Selectionproof.transf_program_correct. eauto.
+  Qed.
+
+End Selection.
+
+Section RTLgen.
+
+  Lemma RTLgen_correct src tgt
+      (TRANSF: RTLgenproof.match_prog src tgt):
+    improves (CminorSel.semantics src) (RTL.semantics tgt).
+  Proof.
+    eapply bsim_improves. eapply mixed_to_backward_simulation.
+    eapply RTLgenproof.transf_program_correct. eauto.
+  Qed.
+
+End RTLgen.
+
+Section Renumber0.
+
+  Lemma Renumber0_correct src tgt
+      (TRANSF: Renumberproof.match_prog src tgt):
+    improves (RTL.semantics src) (RTL.semantics tgt).
+  Proof.
+    eapply bsim_improves. eapply mixed_to_backward_simulation.
+    eapply Renumberproof.transf_program_correct. eauto.
+  Qed.
+
+End Renumber0.
+
+Section Tailcall.
+
+  Lemma Tailcall_correct src tgt
+      (TRANSF: match_if Compopts.optim_tailcalls Tailcallproof.match_prog src tgt):
+    rtc improves (RTL.semantics src) (RTL.semantics tgt).
+  Proof.
+    unfold match_if in *. des_ifs; try refl.
+    - apply rtc_once.
+      eapply bsim_improves. eapply mixed_to_backward_simulation.
+      eapply Tailcallproof.transf_program_correct. eauto.
+  Qed.
+
+End Tailcall.
+
+
+Section Inlining.
+
+  Lemma Inlining_correct src tgt
+      (TRANSF: Inliningproof.match_prog src tgt):
+    improves (RTL.semantics src) (RTL.semantics tgt).
+  Proof.
+    eapply bsim_improves. eapply mixed_to_backward_simulation.
+    eapply Inliningproof.transf_program_correct. eauto.
+  Qed.
+
+End Inlining.
+
+
+Section Constprop.
+
+  Lemma Constprop_correct src tgt
+      (TRANSF: match_if Compopts.optim_constprop Constpropproof.match_prog src tgt):
+    rtc improves (RTL.semantics src) (RTL.semantics tgt).
+  Proof.
+    unfold match_if in *. des_ifs; try refl.
+    - apply rtc_once. eapply bsim_improves. eapply mixed_to_backward_simulation.
+      eapply Constpropproof.transf_program_correct. eauto.
+  Qed.
+
+End Constprop.
+
+
+
+Section Renumber1.
+
+  Lemma Renumber1_correct src tgt
+      (TRANSF: match_if Compopts.optim_constprop Renumberproof.match_prog src tgt):
+    rtc improves (RTL.semantics src) (RTL.semantics tgt).
+  Proof.
+    unfold match_if in *. des_ifs; try refl.
+    apply rtc_once. eapply bsim_improves. eapply mixed_to_backward_simulation.
+    eapply Renumberproof.transf_program_correct. eauto.
+  Qed.
+
+End Renumber1.
+
+Section CSE.
+
+  Lemma CSE_correct src tgt
+        (TRANSF: match_if Compopts.optim_CSE CSEproof.match_prog src tgt):
+    rtc improves (RTL.semantics src) (RTL.semantics tgt).
+  Proof.
+    unfold match_if in *. des_ifs; try refl.
+    apply rtc_once. eapply bsim_improves. eapply mixed_to_backward_simulation.
+    eapply CSEproof.transf_program_correct. eauto.
+  Qed.
+
+End CSE.
+
+Section Deadcode.
+
+  Lemma Deadcode_correct src tgt
+    (TRANSF: match_if Compopts.optim_redundancy Deadcodeproof.match_prog src tgt):
+    rtc improves (RTL.semantics src) (RTL.semantics tgt).
+  Proof.
+    unfold match_if in *. des_ifs; try refl.
+    apply rtc_once. eapply bsim_improves. eapply mixed_to_backward_simulation.
+    eapply Deadcodeproof.transf_program_correct. eauto.
+  Qed.
+
+End Deadcode.
+
+Section Unusedglob.
+
+  Lemma Unusedglob_correct src tgt
+      (TRANSF: Unusedglobproof.match_prog src tgt):
+    improves (RTL.semantics src) (RTL.semantics tgt).
+  Proof.
+    eapply bsim_improves. eapply mixed_to_backward_simulation.
+    eapply Unusedglobproof.transf_program_correct. eauto.
+  Qed.
+
+End Unusedglob.
+
+Section Allocation.
+
+  Lemma Allocation_correct src tgt
+      (TRANSF: Allocproof.match_prog src tgt):
+    improves (RTL.semantics src) (LTL.semantics tgt).
+  Proof.
+    eapply bsim_improves. eapply mixed_to_backward_simulation.
+    eapply Allocproof.transf_program_correct. eauto.
+  Qed.
+
+End Allocation.
+
+Section Tunneling.
+
+  Lemma Tunneling_correct src tgt
+      (TRANSF: Tunnelingproof.match_prog src tgt):
+    improves (LTL.semantics src) (LTL.semantics tgt).
+  Proof.
+    eapply bsim_improves. eapply mixed_to_backward_simulation.
+    eapply Tunnelingproof.transf_program_correct. eauto.
+  Qed.
+
+End Tunneling.
+
+Section Linearize.
+
+  Lemma Linearize_correct src tgt
+      (TRANSF: Linearizeproof.match_prog src tgt):
+    improves (LTL.semantics src) (Linear.semantics tgt).
+  Proof.
+    eapply bsim_improves. eapply mixed_to_backward_simulation.
+    eapply Linearizeproof.transf_program_correct. eauto.
+  Qed.
+
+End Linearize.
+
+Section CleanupLabels.
+
+  Lemma CleanupLabels_correct src tgt
+      (TRANSF: CleanupLabelsproof.match_prog src tgt):
+    improves (Linear.semantics src) (Linear.semantics tgt).
+  Proof.
+    eapply bsim_improves. eapply mixed_to_backward_simulation.
+    eapply CleanupLabelsproof.transf_program_correct. eauto.
+  Qed.
+
+End CleanupLabels.
+
+Section Debugvar.
+
+  Lemma Debugvar_correct src tgt
+      (TRANSF: match_if Compopts.debug Debugvarproof.match_prog src tgt):
+    rtc improves (Linear.semantics src) (Linear.semantics tgt).
+  Proof.
+    unfold match_if in *. des_ifs; try refl.
+    apply rtc_once. eapply bsim_improves. eapply mixed_to_backward_simulation.
+    eapply Debugvarproof.transf_program_correct. eauto.
+  Qed.
+
+End Debugvar.
+
+
+
+Section Stacking.
+
+  Lemma return_address_offset_deterministic:
+    forall f c ofs ofs',
+      Asmgenproof0.return_address_offset f c ofs ->
+      Asmgenproof0.return_address_offset f c ofs' ->
+      ofs = ofs'.
+  Proof.
+    i. inv H; inv H0.
+    rewrite TF in TF0. inv TF0. rewrite TC in TC0. inv TC0.
+    eapply Asmgenproof0.code_tail_unique in TL; eauto.
+    assert(Integers.Ptrofs.eq ofs ofs' = true).
+    unfold Integers.Ptrofs.eq. rewrite TL. rewrite zeq_true. auto.
+    exploit Integers.Ptrofs.eq_spec. rewrite H. auto.
+  Qed.
+
+  Lemma Stacking_correct src tgt
+      (TRANSF: Stackingproof.match_prog src tgt)
+      (COMPILESUCCED: exists final_tgt, Asmgenproof.match_prog tgt final_tgt):
+    improves (Linear.semantics src) (Mach.semantics Asmgenproof0.return_address_offset tgt).
+  Proof.
+    eapply bsim_improves. des. eapply mixed_to_backward_simulation. eapply Stackingproof.transf_program_correct. eauto.
+    eapply Asmgenproof.return_address_exists. eauto.
+    eapply return_address_offset_deterministic.
+  Qed.
+
+End Stacking.
+
+Section Asmgen.
+
+  Lemma Asmgen_correct src tgt
+      (TRANSF: Asmgenproof.match_prog src tgt):
+    improves (Mach.semantics Asmgenproof0.return_address_offset src) (Asm.semantics tgt).
+  Proof.
+    eapply bsim_improves. eapply mixed_to_backward_simulation.
+    eapply Asmgenproof.transf_program_correct. eauto.
+  Qed.
+
+End Asmgen.
+
+(** SSA optimization Correctness *)
+
+Section RTLnorm.
+
+  Lemma RTLnorm_correct src tgt
+      (TRANSF: RTLnormproof.match_prog src tgt):
+    improves (RTL.semantics src) (RTL.semantics tgt).
+  Proof.
+    eapply bsim_improves. eapply mixed_to_backward_simulation.
+    eapply RTLnormproof.transf_program_correct. eauto.
+  Qed.
+
+End RTLnorm.
+
+Section RTLdfs.
+
+  Lemma RTLdfs_correct src tgt
+    (TRANSF: RTLdfsproof.match_prog src tgt):
+    improves (RTL.semantics src) (RTLdfs.semantics tgt).
+  Proof.
+    eapply bsim_improves. eapply mixed_to_backward_simulation.
+    eapply RTLdfsproof.transf_program_correct. eauto.
+  Qed.
+
+End RTLdfs.
+
+Section SSA.
+
+  Lemma SSA_correct src tgt
+      (WF: RTLdfsgen.wf_dfs_program src)
+      (TRANSF: SSAvalidproof.match_prog src tgt):
+    improves (RTLdfs.semantics src) (SSA.semantics tgt).
+  Proof.
+    eapply bsim_improves. eapply mixed_to_backward_simulation.
+    eapply SSAvalidproof.transf_program_correct; eauto.
+  Qed.
+
+End SSA.
+
+Section Copyprop.
+
+  Lemma Copyprop_correct src tgt
+      (WF : SSA.wf_ssa_program src)
+      (TRANSF: Copypropproof.match_prog src tgt):
+    improves (SSA.semantics src) (SSA.semantics tgt).
+  Proof.
+    exploit Copypropproof.tprog_transf; eauto. i; clarify.
+    exploit Copypropproof.transf_program_repeatn; i; des. rewrite H. clear H.
+    induction n; ss; i.
+    - econs. esplits; eauto. eapply observation_improves_refl.
+    - etrans.
+      + ii. exploit IHn; eauto.
+      + eapply bsim_improves. eapply mixed_to_backward_simulation.
+        eapply Copypropproof.transf_program_step_correct.
+        eapply Copypropproof.transf_program_step_match.
+        generalize n as n'; induction n'; ss.
+        eapply Copypropproof.match_prog_step_wf_ssa; eauto.
+        eapply Copypropproof.transf_program_step_match.
+  Qed.
+
+End Copyprop.
+
+Section Captureprop.
+
+  Lemma Captureprop_correct src tgt
+      (TRANSF: Capturepropproof.match_prog src tgt)
+      (WF: SSA.wf_ssa_program src):
+    improves (SSA.semantics src) (SSA.semantics tgt).
+  Proof.
+    exploit Capturepropproof.match_prog_repeatn; eauto. i; des.
+    remember (Capturepropproof.capture_node_list (prog_defs src)) as l.
+    assert (Datatypes.length l = Datatypes.length (prog_defs src)).
+    { rewrite Heql. generalize (prog_defs src) as defs. induction defs; ss; ii.
+      des_ifs; ss; lia. }
+    clear Heql. clear TRANSF.
+    generalize dependent l. generalize dependent src. induction n.
+    - s; i. inv H. econs; eauto. split; eauto. eapply observation_improves_refl.
+    - i. unfold Capturepropproof.repeatn_monad in H. symmetry in H. monadInv H.
+      fold (Capturepropproof.repeatn_monad Capturepropproof.transf_program_step n x) in EQ0.
+      destruct x. symmetry in EQ0. eapply IHn in EQ0.
+      etrans; eauto. eapply bsim_improves. eapply mixed_to_backward_simulation.
+      eapply Capturepropproof.transf_program_step_correct; eauto.
+      exploit Capturepropproof.transf_program_step_match; eauto.
+      eapply Capturepropproof.transf_program_step_wf_ssa; eauto.
+      exploit Capturepropproof.transf_program_step_match; eauto.
+      destruct p; destruct src.
+      eapply Capturepropproof.transf_program_step_len_preserved in EQ; des; ss. lia.
+  Qed.
+
+End Captureprop.
+
+Section CSSA.
+  Lemma CSSA_correct src tgt
+      (WF: SSA.wf_ssa_program src)
+      (TRANSF: CSSAproof.match_prog src tgt):
+    improves (SSA.semantics src) (CSSA.semantics tgt).
+  Proof.
+    eapply bsim_improves. eapply mixed_to_backward_simulation.
+    eapply CSSAproof.transf_program_correct; eauto.
+  Qed.
+  
+End CSSA.
+
+Section RTLpar.
+
+  Lemma RTLpar_correct src tgt
+    (WF: CSSA.wf_cssa_program src)
+    (TRANSF: RTLparproof.match_prog src tgt):
+    improves (CSSA.semantics src) (RTLpar.semantics tgt).
+  Proof.
+    eapply bsim_improves. eapply mixed_to_backward_simulation.
+    eapply RTLparproof.transf_program_correct; eauto.
+  Qed.
+
+End RTLpar.
+
+Section RTLparcleanup.
+  Lemma RTLparcleanup_correct src tgt
+    (TRANSF: RTLparcleanup.match_prog src tgt):
+    improves (RTLpar.semantics src) (RTLpar.semantics tgt).
+  Proof.
+    eapply bsim_improves. eapply mixed_to_backward_simulation.
+    eapply RTLparcleanup.transf_program_correct; eauto.
+  Qed.
+  
+End RTLparcleanup.
+
+Section RTLdpar.
+  Lemma RTLdpar_correct src tgt
+    (WF: RTLpar.wf_program src)
+    (WF': RTLpar.mill_program src)
+    (TRANSF: RTLdparproof.match_prog src tgt):
+    improves (RTLpar.semantics src) (RTL.semantics tgt).
+  Proof.
+    eapply bsim_improves. eapply mixed_to_backward_simulation.
+    eapply RTLdparproof.transf_program_correct; eauto.
+  Qed.
+  
+End RTLdpar.
+
+Require Import Lowerbound.
+
+Section Lowerbound.
+  Lemma Lowerbound_correct prog:
+    improves (Asm.semantics prog) (Lowerbound.semantics prog).
+  Proof.
+    eapply bsim_improves. eapply Lowerbound.lowerbound_correct.
+  Qed.
+  
+End Lowerbound.
+
+
+(** Composing the [match_prog] relations above, we obtain the relation
+  between CompCert C sources and Asm code that characterize CompCert's
+  compilation. *)
+
+Definition match_prog_clight: Clight.program -> Asm.program -> Prop :=
+  pass_match (compose_passes Clight_to_Asm).
+
+Definition match_prog_clight_ssa: Clight.program -> Asm.program -> Prop :=
+  pass_match (compose_passes Clight_to_Asm_ssa).
+
+Definition match_prog_clight2: Clight.program -> Asm.program -> Prop :=
+  pass_match (compose_passes Clight2_to_Asm).
+
+Definition match_prog_clight2_ssa: Clight.program -> Asm.program -> Prop :=
+  pass_match (compose_passes Clight2_to_Asm_ssa).
+
+Lemma transf_clight2_program_preservation p tp
+    (TRANSF: match_prog_clight2 p tp) :
+  improves (Clight.semantics2 p) (Asm.semantics tp).
 Proof.
-  intros. eapply backward_simulation_behavior_improves; eauto.
-  apply transf_c_program_correct_via_SSA; auto.
+  unfold match_prog_clight2, pass_match in TRANSF; simpl in TRANSF.
+  Ltac DestructM :=
+    match goal with
+      [ H: exists p, _ /\ _ |- _ ] =>
+      let p := fresh "p" in let M := fresh "M" in let MM := fresh "MM" in
+      destruct H as (p & M & MM); clear H
+  end.
+  repeat DestructM. subst tp.
+
+  etrans. eapply Cshmgen_correct; eauto.
+  etrans. eapply Cminorgen_correct; eauto.
+  etrans. eapply Selection_correct; eauto.
+  etrans. eapply RTLgen_correct; eauto.
+  etrans. exploit Tailcall_correct; eauto. intros REL. eapply rtc_improves; eauto.
+  etrans. eapply Inlining_correct; eauto.
+  etrans. eapply Renumber0_correct; eauto.
+  etrans. exploit Constprop_correct; eauto. intros REL. eapply rtc_improves; eauto.
+  etrans. exploit Renumber1_correct; eauto. intros REL. eapply rtc_improves; eauto.
+  etrans. exploit CSE_correct; eauto. intros REL. eapply rtc_improves; eauto.
+  etrans. exploit Deadcode_correct; eauto. intros REL. eapply rtc_improves; eauto.
+  etrans. eapply Unusedglob_correct; eauto.
+  etrans. eapply Allocation_correct; eauto.
+  etrans. eapply Tunneling_correct; eauto.
+  etrans. eapply Linearize_correct; eauto.
+  etrans. eapply CleanupLabels_correct; eauto.
+  etrans. exploit Debugvar_correct; eauto. intros REL. eapply rtc_improves; eauto.
+  etrans. eapply Stacking_correct; eauto.
+  etrans. eapply Asmgen_correct; eauto. refl.
 Qed.
 
-(** As a corollary, if the source C code cannot go wrong, i.e. is free of
-  undefined behaviors, the behavior of the generated assembly code is
-  one of the possible behaviors of the source C code. *)
+Lemma transf_clight2_program_preservation_ssa p tp
+    (TRANSF: match_prog_clight2_ssa p tp) :
+  improves (Clight.semantics2 p) (Asm.semantics tp).
+Proof.
+  unfold match_prog_clight2_ssa, pass_match in TRANSF; simpl in TRANSF.
+  Ltac Destructm :=
+    match goal with
+      [ H: exists p, _ /\ _ |- _ ] =>
+      let p := fresh "p" in let M := fresh "M" in let MM := fresh "MM" in
+      destruct H as (p & M & MM); clear H
+  end.
+  repeat Destructm. subst tp.
+
+  etrans. eapply Cshmgen_correct; eauto.
+  etrans. eapply Cminorgen_correct; eauto.
+  etrans. eapply Selection_correct; eauto.
+  etrans. eapply RTLgen_correct; eauto.
+  etrans. exploit Tailcall_correct; eauto. intros REL. eapply rtc_improves; eauto.
+  etrans. eapply Inlining_correct; eauto.
+  etrans. eapply Renumber0_correct; eauto.
+  etrans. exploit Constprop_correct; eauto. intros REL. eapply rtc_improves; eauto.
+  etrans. exploit Renumber1_correct; eauto. intros REL. eapply rtc_improves; eauto.
+  etrans. exploit CSE_correct; try apply M8. intros REL. eapply rtc_improves; eauto.
+  etrans. exploit Deadcode_correct; eauto. intros REL. eapply rtc_improves; eauto.
+  etrans. eapply Unusedglob_correct; eauto.
+
+  etrans. eapply RTLnorm_correct; eauto.
+  etrans. eapply RTLdfs_correct; eauto.
+  etrans. eapply SSA_correct; eauto. eapply RTLdfsproof.match_prog_wf_dfs; eauto.
+  etrans. eapply Copyprop_correct; eauto.
+    eapply SSAvalidproof.match_prog_wf_ssa; eauto.
+    eapply RTLdfsproof.match_prog_wf_dfs; eauto.
+  etrans. eapply Captureprop_correct; eauto.
+    eapply Copypropproof.match_prog_wf_ssa; eauto.
+    eapply SSAvalidproof.match_prog_wf_ssa; eauto.
+    eapply RTLdfsproof.match_prog_wf_dfs; eauto.
+  etrans. eapply CSSA_correct; eauto.
+    eapply Capturepropproof.match_prog_wf_ssa; eauto.
+    eapply Copypropproof.match_prog_wf_ssa; eauto.
+    eapply SSAvalidproof.match_prog_wf_ssa; eauto.
+    eapply RTLdfsproof.match_prog_wf_dfs; eauto.
+    (* eapply CSSAgenwf.wf_cssa_tprog; eauto. *)
+  etrans. eapply RTLpar_correct; eauto.
+  (* etrans. eapply RTLpar_correct; eauto. *)
+    eapply CSSAgenwf.wf_cssa_tprog; eauto.
+    eapply Capturepropproof.match_prog_wf_ssa; eauto.
+    eapply Copypropproof.match_prog_wf_ssa; eauto.
+    eapply SSAvalidproof.match_prog_wf_ssa; eauto.
+    eapply RTLdfsproof.match_prog_wf_dfs; eauto.
+
+  etrans. eapply RTLparcleanup_correct; eauto.
+  etrans. eapply RTLdpar_correct; eauto.
+  2:eapply RTLparcleanup.is_mill_program; eauto.
+    eapply RTLparcleanup.match_prof_wf_program; eauto.
+    eapply RTLparproof.is_wf_program; eauto.
+    eapply CSSAgenwf.wf_cssa_tprog; eauto.
+    eapply Capturepropproof.match_prog_wf_ssa; eauto.
+    eapply Copypropproof.match_prog_wf_ssa; eauto.
+    eapply SSAvalidproof.match_prog_wf_ssa; eauto.
+    eapply RTLdfsproof.match_prog_wf_dfs; eauto.
+  
+  etrans. eapply Renumber0_correct; eauto.
+  etrans. exploit CSE_correct; eauto. intros REL. eapply rtc_improves; eauto.
+  etrans. eapply Allocation_correct; eauto.
+  etrans. eapply Tunneling_correct; eauto.
+  etrans. eapply Linearize_correct; eauto.
+  etrans. eapply CleanupLabels_correct; eauto.
+  etrans. exploit Debugvar_correct; eauto. intros REL. eapply rtc_improves; eauto.
+  etrans. eapply Stacking_correct; eauto.
+  etrans. eapply Asmgen_correct; eauto. refl.
+Qed.
 
-Theorem transf_c_program_is_refinement:
-  forall p tp,
-  transf_c_program p = OK tp ->
-  (forall beh, program_behaves (Csem.semantics p) beh -> not_wrong beh) ->
-  (forall beh, program_behaves (Asm.semantics tp) beh -> program_behaves (Csem.semantics p) beh).
+Lemma transf_clight_program_preservation p tp
+    (TRANSF: match_prog_clight p tp) :
+  improves (Clight.semantics1 p) (Asm.semantics tp).
 Proof.
-  intros. eapply backward_simulation_same_safe_behavior; eauto.
-  apply transf_c_program_correct; auto.
+  unfold match_prog_clight, pass_match in TRANSF; simpl in TRANSF.
+  repeat DestructM. subst tp.
+  etrans. eapply SimplLocals_correct; eauto.
+  etrans. eapply transf_clight2_program_preservation. 2:{ refl. }
+  unfold match_prog_clight2, pass_match. ss. esplits; eauto.
 Qed.
 
-Theorem transf_c_program_is_refinement_via_SSA:
-  forall p tp,
-  transf_c_program_via_SSA p = OK tp ->
-  (forall beh, program_behaves (Csem.semantics p) beh -> not_wrong beh) ->
-  (forall beh, program_behaves (Asm.semantics tp) beh -> program_behaves (Csem.semantics p) beh).
+Lemma transf_clight_program_preservation_ssa p tp
+    (TRANSF: match_prog_clight_ssa p tp) :
+  improves (Clight.semantics1 p) (Asm.semantics tp).
 Proof.
-  intros. eapply backward_simulation_same_safe_behavior; eauto.
-  apply transf_c_program_correct_via_SSA; auto.
+  unfold match_prog_clight_ssa, pass_match in TRANSF; simpl in TRANSF.
+  repeat Destructm. subst tp.
+
+  etrans. eapply SimplLocals_correct; eauto.
+  etrans. eapply transf_clight2_program_preservation_ssa. 2:{ refl. }
+  unfold match_prog_clight2_ssa, pass_match. ss. esplits; eauto.
 Qed.
 
-(** If we consider the C evaluation strategy implemented by the compiler,
-  we get stronger preservation results. *)
-
-Theorem transf_cstrategy_program_preservation:
-  forall p tp,
-  transf_c_program p = OK tp ->
-  (forall beh, program_behaves (Cstrategy.semantics p) beh ->
-     exists beh', program_behaves (Asm.semantics tp) beh' /\ behavior_improves beh beh')
-/\(forall beh, program_behaves (Asm.semantics tp) beh ->
-     exists beh', program_behaves (Cstrategy.semantics p) beh' /\ behavior_improves beh' beh)
-/\(forall beh, not_wrong beh ->
-     program_behaves (Cstrategy.semantics p) beh -> program_behaves (Asm.semantics tp) beh)
-/\(forall beh,
-     (forall beh', program_behaves (Cstrategy.semantics p) beh' -> not_wrong beh') ->
-     program_behaves (Asm.semantics tp) beh ->
-     program_behaves (Cstrategy.semantics p) beh).
+Lemma transf_clight_program_preservation_lbd p tp
+    (TRANSF: match_prog_clight p tp) :
+  improves (Clight.semantics1 p) (Lowerbound.semantics tp).
 Proof.
-  assert (WBT: forall p, well_behaved_traces (Cstrategy.semantics p)).
-    intros. eapply ssr_well_behaved. apply Cstrategy.semantics_strongly_receptive.
-  intros.
-  assert (MATCH: match_prog p tp) by (apply transf_c_program_match; auto).
-  intuition auto.
-  eapply forward_simulation_behavior_improves; eauto.
-    apply (proj1 (cstrategy_semantic_preservation _ _ MATCH)).
-  exploit backward_simulation_behavior_improves.
-    apply (proj2 (cstrategy_semantic_preservation _ _ MATCH)).
-    eauto.
-  intros [beh1 [A B]]. exists beh1; split; auto. rewrite atomic_behaviors; auto.
-  eapply forward_simulation_same_safe_behavior; eauto.
-    apply (proj1 (cstrategy_semantic_preservation _ _ MATCH)).
-  exploit backward_simulation_same_safe_behavior.
-    apply (proj2 (cstrategy_semantic_preservation _ _ MATCH)).
-    intros. rewrite <- atomic_behaviors in H2; eauto. eauto.
-    intros. rewrite atomic_behaviors; auto.
+  hexploit transf_clight_program_preservation; eauto. i.
+  etrans; eauto. eapply Lowerbound_correct; eauto.
 Qed.
 
-Theorem transf_cstrategy_program_preservation_via_SSA:
-  forall p tp,
-  transf_c_program_via_SSA p = OK tp ->
-  (forall beh, program_behaves (Cstrategy.semantics p) beh ->
-     exists beh', program_behaves (Asm.semantics tp) beh' /\ behavior_improves beh beh')
-/\(forall beh, program_behaves (Asm.semantics tp) beh ->
-     exists beh', program_behaves (Cstrategy.semantics p) beh' /\ behavior_improves beh' beh)
-/\(forall beh, not_wrong beh ->
-     program_behaves (Cstrategy.semantics p) beh -> program_behaves (Asm.semantics tp) beh)
-/\(forall beh,
-     (forall beh', program_behaves (Cstrategy.semantics p) beh' -> not_wrong beh') ->
-     program_behaves (Asm.semantics tp) beh ->
-     program_behaves (Cstrategy.semantics p) beh).
+Lemma transf_clight_program_preservation_ssa_lbd p tp
+    (TRANSF: match_prog_clight_ssa p tp) :
+  improves (Clight.semantics1 p) (Lowerbound.semantics tp).
 Proof.
-  assert (WBT: forall p, well_behaved_traces (Cstrategy.semantics p)).
-    intros. eapply ssr_well_behaved. apply Cstrategy.semantics_strongly_receptive.
-  intros. 
-  assert (MATCH: match_prog_SSA p tp) by (apply transf_c_program_via_SSA_match; auto).
-  intuition auto.
-  eapply forward_simulation_behavior_improves; eauto.
-    apply (proj1 (cstrategy_semantic_preservation_via_SSA _ _ MATCH)).
-  exploit backward_simulation_behavior_improves.
-    apply (proj2 (cstrategy_semantic_preservation_via_SSA _ _ MATCH)).
-    eauto.
-  intros [beh1 [A B]]. exists beh1; split; auto. rewrite atomic_behaviors; auto.
-  eapply forward_simulation_same_safe_behavior; eauto.
-    apply (proj1 (cstrategy_semantic_preservation_via_SSA _ _ MATCH)).
-  exploit backward_simulation_same_safe_behavior.
-    apply (proj2 (cstrategy_semantic_preservation_via_SSA _ _ MATCH)).
-    intros. rewrite <- atomic_behaviors in H2; eauto. eauto.
-    intros. rewrite atomic_behaviors; auto.
+  hexploit transf_clight_program_preservation_ssa; eauto. i.
+  etrans; eauto. eapply Lowerbound_correct; eauto.
 Qed.
 
-(** We can also use the alternate big-step semantics for [Cstrategy]
-  to establish behaviors of the generated assembly code. *)
-
-Theorem bigstep_cstrategy_preservation:
-  forall p tp,
-  transf_c_program p = OK tp ->
-  (forall t r,
-     Cstrategy.bigstep_program_terminates p t r ->
-     program_behaves (Asm.semantics tp) (Terminates t r))
-/\(forall T,
-     Cstrategy.bigstep_program_diverges p T ->
-       program_behaves (Asm.semantics tp) (Reacts T)
-    \/ exists t, program_behaves (Asm.semantics tp) (Diverges t) /\ traceinf_prefix t T).
+Lemma transf_clight2_program_preservation_lbd p tp
+    (TRANSF: match_prog_clight2 p tp) :
+  improves (Clight.semantics2 p) (Lowerbound.semantics tp).
 Proof.
-  intuition.
-  apply transf_cstrategy_program_preservation with p; auto. red; auto.
-  apply behavior_bigstep_terminates with (Cstrategy.bigstep_semantics p); auto.
-  apply Cstrategy.bigstep_semantics_sound.
-  exploit (behavior_bigstep_diverges (Cstrategy.bigstep_semantics_sound p)). eassumption.
-  intros [A | [t [A B]]].
-  left. apply transf_cstrategy_program_preservation with p; auto. red; auto.
-  right; exists t; split; auto. apply transf_cstrategy_program_preservation with p; auto. red; auto.
+  hexploit transf_clight2_program_preservation; eauto. i.
+  etrans; eauto. eapply Lowerbound_correct; eauto.
 Qed.
 
-Theorem bigstep_cstrategy_preservation_via_SSA:
-  forall p tp,
-  transf_c_program_via_SSA p = OK tp ->
-  (forall t r,
-     Cstrategy.bigstep_program_terminates p t r ->
-     program_behaves (Asm.semantics tp) (Terminates t r))
-/\(forall T,
-     Cstrategy.bigstep_program_diverges p T ->
-       program_behaves (Asm.semantics tp) (Reacts T)
-    \/ exists t, program_behaves (Asm.semantics tp) (Diverges t) /\ traceinf_prefix t T).
+Lemma transf_clight2_program_preservation_ssa_lbd p tp
+    (TRANSF: match_prog_clight2_ssa p tp) :
+  improves (Clight.semantics2 p) (Lowerbound.semantics tp).
 Proof.
-  intuition.
-  apply transf_cstrategy_program_preservation_via_SSA with p; auto. red; auto.
-  apply behavior_bigstep_terminates with (Cstrategy.bigstep_semantics p); auto.
-  apply Cstrategy.bigstep_semantics_sound.
-  exploit (behavior_bigstep_diverges (Cstrategy.bigstep_semantics_sound p)). eassumption.
-  intros [A | [t [A B]]].
-  left. apply transf_cstrategy_program_preservation_via_SSA with p; auto. red; auto.
-  right; exists t; split; auto. apply transf_cstrategy_program_preservation_via_SSA with p; auto. red; auto.
+  hexploit transf_clight2_program_preservation_ssa; eauto. i.
+  etrans; eauto. eapply Lowerbound_correct; eauto.
 Qed.
 
-(** * Satisfaction of specifications *)
+Lemma transf_clight_program_preservation_lbd' p tp
+    (TRANSF: transf_clight_program p = OK tp) :
+  improves (Clight.semantics1 p) (Lowerbound.semantics tp).
+Proof.
+  eapply transf_clight_program_match in TRANSF.
+  eapply transf_clight_program_preservation_lbd; eauto.
+Qed.
 
-(** The second additional results shows that if all executions
-  of the source C program satisfies a given specification,
-  then all executions of the produced Asm program satisfy
-  this specification as well.  *)
+Lemma transf_clight_program_preservation_ssa_lbd' p tp
+    (TRANSF: transf_clight_program_via_SSA p = OK tp) :
+  improves (Clight.semantics1 p) (Lowerbound.semantics tp).
+Proof.
+  eapply transf_clight_program_via_SSA_match in TRANSF.
+  eapply transf_clight_program_preservation_ssa_lbd; eauto.
+Qed.
 
-(** The specifications we consider here are sets of observable
-  behaviors, representing the good behaviors a program is expected
-  to have.  A specification can be as simple as
-  ``the program does not go wrong'' or as precise as
-  ``the program prints a prime number then terminates with code 0''.
-  As usual in Coq, sets of behaviors are represented as predicates
-  [program_behavior -> Prop]. *)
+(** * Extension to separate compilation *)
 
-Definition specification := program_behavior -> Prop.
+(** The results above were given in terms of whole-program compilation.
+    They also extend to separate compilation followed by linking. *)
 
-(** A program satisfies a specification if all its observable behaviors
-  are in the specification. *)
+Theorem separate_transf_clight_program_correct:
+  forall c_units asm_units c_program,
+  nlist_forall2 (fun cu tcu => transf_clight_program cu = OK tcu) c_units asm_units ->
+  link_list c_units = Some c_program ->
+  exists asm_program,
+      link_list asm_units = Some asm_program
+    /\ improves (Clight.semantics1 c_program) (Asm.semantics asm_program).
+Proof.
+  intros.
+  assert (nlist_forall2 match_prog_clight c_units asm_units).
+  { eapply nlist_forall2_imply. eauto. simpl; intros. apply transf_clight_program_match; auto. }
+  assert (exists asm_program, link_list asm_units = Some asm_program /\ match_prog_clight c_program asm_program).
+  { eapply link_list_compose_passes; eauto. }
+  destruct H2 as (asm_program & P & Q).
+  exists asm_program; split; auto. apply transf_clight_program_preservation; auto.
+Qed.
 
-Definition c_program_satisfies_spec (p: Csyntax.program) (spec: specification): Prop :=
-  forall beh,  program_behaves (Csem.semantics p) beh -> spec beh.
-Definition asm_program_satisfies_spec (p: Asm.program) (spec: specification): Prop :=
-  forall beh,  program_behaves (Asm.semantics p) beh -> spec beh.
-  
-(** It is not always the case that if the source program satisfies a
-  specification, then the generated assembly code satisfies it as
-  well.  For example, if the specification is ``the program goes wrong
-  on an undefined behavior'', a C source that goes wrong satisfies
-  this specification but can be compiled into Asm code that does not
-  go wrong and therefore does not satisfy the specification.
-
-  For this reason, we restrict ourselves to safety-enforcing specifications:
-  specifications that exclude ``going wrong'' behaviors and are satisfied
-  only by programs that execute safely. *)
-
-Definition safety_enforcing_specification (spec: specification): Prop :=
-  forall beh, spec beh -> not_wrong beh.
-
-(** As the main result of this section, we show that CompCert
-  compilation preserves safety-enforcing specifications: 
-  any such specification that is satisfied by the source C program is
-  always satisfied by the generated assembly code. *)
-
-Theorem transf_c_program_preserves_spec:
-  forall p tp spec,
-  transf_c_program p = OK tp ->
-  safety_enforcing_specification spec ->
-  c_program_satisfies_spec p spec ->
-  asm_program_satisfies_spec tp spec.
+Theorem separate_transf_clight2_program_correct:
+  forall c_units asm_units c_program,
+  nlist_forall2 (fun cu tcu => transf_clight2_program cu = OK tcu) c_units asm_units ->
+  link_list c_units = Some c_program ->
+  exists asm_program,
+      link_list asm_units = Some asm_program
+    /\ improves (Clight.semantics2 c_program) (Asm.semantics asm_program).
+Proof.
+  intros.
+  assert (nlist_forall2 match_prog_clight2 c_units asm_units).
+  { eapply nlist_forall2_imply. eauto. simpl; intros. apply transf_clight2_program_match; auto. }
+  assert (exists asm_program, link_list asm_units = Some asm_program /\ match_prog_clight2 c_program asm_program).
+  { eapply link_list_compose_passes; eauto. }
+  destruct H2 as (asm_program & P & Q).
+  exists asm_program; split; auto. apply transf_clight2_program_preservation; auto.
+Qed.
+
+Theorem separate_transf_clight_program_correct_lbd:
+  forall c_units asm_units c_program,
+  nlist_forall2 (fun cu tcu => transf_clight_program cu = OK tcu) c_units asm_units ->
+  link_list c_units = Some c_program ->
+  exists asm_program,
+      link_list asm_units = Some asm_program
+    /\ improves (Clight.semantics1 c_program) (Lowerbound.semantics asm_program).
 Proof.
-  intros p tp spec TRANSF SES CSAT; red; intros beh AEXEC.
-  exploit transf_c_program_preservation; eauto. intros (beh' & CEXEC & IMPR).
-  apply CSAT in CEXEC. destruct IMPR as [EQ | [t [A B]]].
-- congruence.
-- subst beh'. apply SES in CEXEC. contradiction. 
+  intros.
+  assert (nlist_forall2 match_prog_clight c_units asm_units).
+  { eapply nlist_forall2_imply. eauto. simpl; intros. apply transf_clight_program_match; auto. }
+  assert (exists asm_program, link_list asm_units = Some asm_program /\ match_prog_clight c_program asm_program).
+  { eapply link_list_compose_passes; eauto. }
+  destruct H2 as (asm_program & P & Q).
+  exists asm_program; split; auto. apply transf_clight_program_preservation_lbd; auto.
 Qed.
 
-Theorem transf_c_program_preserves_spec_via_SSA:
-  forall p tp spec,
-  transf_c_program_via_SSA p = OK tp ->
-  safety_enforcing_specification spec ->
-  c_program_satisfies_spec p spec ->
-  asm_program_satisfies_spec tp spec.
+Theorem separate_transf_clight2_program_correct_lbd:
+  forall c_units asm_units c_program,
+  nlist_forall2 (fun cu tcu => transf_clight2_program cu = OK tcu) c_units asm_units ->
+  link_list c_units = Some c_program ->
+  exists asm_program,
+      link_list asm_units = Some asm_program
+    /\ improves (Clight.semantics2 c_program) (Lowerbound.semantics asm_program).
 Proof.
-  intros p tp spec TRANSF SES CSAT; red; intros beh AEXEC.
-  exploit transf_c_program_preservation_via_SSA; eauto. intros (beh' & CEXEC & IMPR).
-  apply CSAT in CEXEC. destruct IMPR as [EQ | [t [A B]]].
-- congruence.
-- subst beh'. apply SES in CEXEC. contradiction. 
+  intros.
+  assert (nlist_forall2 match_prog_clight2 c_units asm_units).
+  { eapply nlist_forall2_imply. eauto. simpl; intros. apply transf_clight2_program_match; auto. }
+  assert (exists asm_program, link_list asm_units = Some asm_program /\ match_prog_clight2 c_program asm_program).
+  { eapply link_list_compose_passes; eauto. }
+  destruct H2 as (asm_program & P & Q).
+  exists asm_program; split; auto. apply transf_clight2_program_preservation_lbd; auto.
 Qed.
 
-(** Safety-enforcing specifications are not the only good properties
-  of source programs that are preserved by compilation.  Another example
-  of a property that is preserved is the ``initial trace'' property:
-  all executions of the program start by producing an expected trace
-  of I/O actions, representing the good behavior expected from the program.
-  After that, the program may terminate, or continue running, or go wrong
-  on an undefined behavior.  What matters is that the program produced
-  the expected trace at the beginning of its execution.  This is a typical
-  liveness property, and it is preserved by compilation. *)
-
-Definition c_program_has_initial_trace (p: Csyntax.program) (t: trace): Prop :=
-  forall beh, program_behaves (Csem.semantics p) beh -> behavior_prefix t beh.
-Definition asm_program_has_initial_trace (p: Asm.program) (t: trace): Prop :=
-  forall beh, program_behaves (Asm.semantics p) beh -> behavior_prefix t beh.
-
-Theorem transf_c_program_preserves_initial_trace:
-  forall p tp t,
-  transf_c_program p = OK tp ->
-  c_program_has_initial_trace p t ->
-  asm_program_has_initial_trace tp t.
+Theorem separate_transf_clight_program_via_SSA_correct:
+  forall c_units asm_units c_program,
+  nlist_forall2 (fun cu tcu => transf_clight_program_via_SSA cu = OK tcu) c_units asm_units ->
+  link_list c_units = Some c_program ->
+  exists asm_program,
+      link_list asm_units = Some asm_program
+   /\ improves (Clight.semantics1 c_program) (Asm.semantics asm_program).
 Proof.
-  intros p tp t TRANSF CTRACE; red; intros beh AEXEC.
-  exploit transf_c_program_preservation; eauto. intros (beh' & CEXEC & IMPR).
-  apply CTRACE in CEXEC. destruct IMPR as [EQ | [t' [A B]]].
-- congruence.
-- destruct CEXEC as (beh1' & EQ').
-  destruct B as (beh1 & EQ).
-  subst beh'. destruct beh1'; simpl in A; inv A. 
-  exists (behavior_app t0 beh1). apply behavior_app_assoc.
+  intros.
+  assert (nlist_forall2 match_prog_clight_ssa c_units asm_units).
+  { eapply nlist_forall2_imply. eauto. simpl; intros. apply transf_clight_program_via_SSA_match; auto. }
+  assert (exists asm_program, link_list asm_units = Some asm_program /\ match_prog_clight_ssa c_program asm_program).
+  { eapply link_list_compose_passes; eauto. }
+  destruct H2 as (asm_program & P & Q).
+  exists asm_program; split; auto. apply transf_clight_program_preservation_ssa; auto.
 Qed.
 
-Theorem transf_c_program_preserves_initial_trace_via_SSA:
-  forall p tp t,
-  transf_c_program_via_SSA p = OK tp ->
-  c_program_has_initial_trace p t ->
-  asm_program_has_initial_trace tp t.
+Theorem separate_transf_clight2_program_via_SSA_correct:
+  forall c_units asm_units c_program,
+  nlist_forall2 (fun cu tcu => transf_clight2_program_via_SSA cu = OK tcu) c_units asm_units ->
+  link_list c_units = Some c_program ->
+  exists asm_program,
+      link_list asm_units = Some asm_program
+   /\ improves (Clight.semantics2 c_program) (Asm.semantics asm_program).
 Proof.
-  intros p tp t TRANSF CTRACE; red; intros beh AEXEC.
-  exploit transf_c_program_preservation_via_SSA; eauto. intros (beh' & CEXEC & IMPR).
-  apply CTRACE in CEXEC. destruct IMPR as [EQ | [t' [A B]]].
-- congruence.
-- destruct CEXEC as (beh1' & EQ').
-  destruct B as (beh1 & EQ).
-  subst beh'. destruct beh1'; simpl in A; inv A. 
-  exists (behavior_app t0 beh1). apply behavior_app_assoc.
+  intros.
+  assert (nlist_forall2 match_prog_clight2_ssa c_units asm_units).
+  { eapply nlist_forall2_imply. eauto. simpl; intros. apply transf_clight2_program_via_SSA_match; auto. }
+  assert (exists asm_program, link_list asm_units = Some asm_program /\ match_prog_clight2_ssa c_program asm_program).
+  { eapply link_list_compose_passes; eauto. }
+  destruct H2 as (asm_program & P & Q).
+  exists asm_program; split; auto. apply transf_clight2_program_preservation_ssa; auto.
 Qed.
 
-(** * Extension to separate compilation *)
+Theorem separate_transf_clight_program_via_SSA_correct_lbd:
+  forall c_units asm_units c_program,
+  nlist_forall2 (fun cu tcu => transf_clight_program_via_SSA cu = OK tcu) c_units asm_units ->
+  link_list c_units = Some c_program ->
+  exists asm_program,
+      link_list asm_units = Some asm_program
+   /\ improves (Clight.semantics1 c_program) (Lowerbound.semantics asm_program).
+Proof.
+  intros.
+  assert (nlist_forall2 match_prog_clight_ssa c_units asm_units).
+  { eapply nlist_forall2_imply. eauto. simpl; intros. apply transf_clight_program_via_SSA_match; auto. }
+  assert (exists asm_program, link_list asm_units = Some asm_program /\ match_prog_clight_ssa c_program asm_program).
+  { eapply link_list_compose_passes; eauto. }
+  destruct H2 as (asm_program & P & Q).
+  exists asm_program; split; auto. apply transf_clight_program_preservation_ssa_lbd; auto.
+Qed.
 
-(** The results above were given in terms of whole-program compilation.
-    They also extend to separate compilation followed by linking. *)
+Theorem separate_transf_clight2_program_via_SSA_correct_lbd:
+  forall c_units asm_units c_program,
+  nlist_forall2 (fun cu tcu => transf_clight2_program_via_SSA cu = OK tcu) c_units asm_units ->
+  link_list c_units = Some c_program ->
+  exists asm_program,
+      link_list asm_units = Some asm_program
+   /\ improves (Clight.semantics2 c_program) (Lowerbound.semantics asm_program).
+Proof.
+  intros.
+  assert (nlist_forall2 match_prog_clight2_ssa c_units asm_units).
+  { eapply nlist_forall2_imply. eauto. simpl; intros. apply transf_clight2_program_via_SSA_match; auto. }
+  assert (exists asm_program, link_list asm_units = Some asm_program /\ match_prog_clight2_ssa c_program asm_program).
+  { eapply link_list_compose_passes; eauto. }
+  destruct H2 as (asm_program & P & Q).
+  exists asm_program; split; auto. apply transf_clight2_program_preservation_ssa_lbd; auto.
+Qed.
 
 Section SEPARATE_COMPILATION.
 
 (** The source: a list of C compilation units *)
-Variable c_units: nlist Csyntax.program.
+Variable c_units: nlist Clight.program.
 
 (** The compiled code: a list of Asm compilation units, obtained by separate compilation *)
 Variable asm_units: nlist Asm.program.
-Hypothesis separate_compilation_succeeds: 
-  nlist_forall2 (fun cu tcu => transf_c_program cu = OK tcu) c_units asm_units.
+Hypothesis separate_compilation_succeeds:
+  nlist_forall2 (fun cu tcu => transf_clight_program cu = OK tcu) c_units asm_units.
 
 Variable asm_units_SSA: nlist Asm.program.
-Hypothesis separate_compilation_succeeds_via_SSA: 
-  nlist_forall2 (fun cu tcu => transf_c_program_via_SSA cu = OK tcu) c_units asm_units_SSA.
+Hypothesis separate_compilation_succeeds_via_SSA:
+  nlist_forall2 (fun cu tcu => transf_clight_program_via_SSA cu = OK tcu) c_units asm_units_SSA.
 
-(** We assume that the source C compilation units can be linked together
-    to obtain a monolithic C program [c_program]. *)
-Variable c_program: Csyntax.program.
+(** We assume that the source C compilation units can be linked together *)
+(*     to obtain a monolithic C program [c_program]. *)
+Variable c_program: Clight.program.
 Hypothesis source_linking: link_list c_units = Some c_program.
 
 (** Then, linking the Asm units obtained by separate compilation succeeds. *)
 Lemma compiled_linking_succeeds:
   { asm_program | link_list asm_units = Some asm_program }.
 Proof.
-  destruct (link_list asm_units) eqn:E. 
+  destruct (link_list asm_units) eqn:E.
 - exists p; auto.
-- exfalso. 
-  exploit separate_transf_c_program_correct; eauto. intros (a & P & Q).
+- exfalso.
+  exploit separate_transf_clight_program_correct; eauto. intros (a & P & Q).
   congruence.
 Qed.
 
 Lemma compiled_linking_succeeds_via_SSA:
   { asm_program | link_list asm_units_SSA = Some asm_program }.
 Proof.
-  destruct (link_list asm_units_SSA) eqn:E. 
+  destruct (link_list asm_units_SSA) eqn:E.
 - exists p; auto.
-- exfalso. 
-  exploit separate_transf_c_program_via_SSA_correct; eauto. intros (a & P & Q).
+- exfalso.
+  exploit separate_transf_clight_program_via_SSA_correct; eauto. intros (a & P & Q).
   congruence.
 Qed.
 
@@ -357,118 +856,50 @@ Let compiled_linking: link_list asm_units = Some asm_program := proj2_sig compil
 Let asm_program_SSA: Asm.program := proj1_sig compiled_linking_succeeds_via_SSA.
 Let compiled_linking_SSA: link_list asm_units_SSA = Some asm_program_SSA := proj2_sig compiled_linking_succeeds_via_SSA.
 
-(** Then, [asm_program] preserves the semantics and the specifications of
-  [c_program], in the following sense.
-  First, every behavior of [asm_program] improves upon one of the possible
-  behaviors of [c_program]. *)
-
-Theorem separate_transf_c_program_preservation:
-  forall beh,
-  program_behaves (Asm.semantics asm_program) beh ->
-  exists beh', program_behaves (Csem.semantics c_program) beh' /\ behavior_improves beh' beh.
-Proof.
-  intros. exploit separate_transf_c_program_correct; eauto. intros (a & P & Q).
-  assert (a = asm_program) by congruence. subst a. 
-  eapply backward_simulation_behavior_improves; eauto.
-Qed.
-
-Theorem separate_transf_c_program_preservation_via_SSA:
-  forall beh,
-  program_behaves (Asm.semantics asm_program_SSA) beh ->
-  exists beh', program_behaves (Csem.semantics c_program) beh' /\ behavior_improves beh' beh.
-Proof.
-  intros. exploit separate_transf_c_program_via_SSA_correct; eauto. intros (a & P & Q).
-  assert (a = asm_program_SSA) by congruence. subst a. 
-  eapply backward_simulation_behavior_improves; eauto.
-Qed.
-
-(** As a corollary, if [c_program] is free of undefined behaviors, 
-  the behavior of [asm_program] is one of the possible behaviors of [c_program]. *)
-
-Theorem separate_transf_c_program_is_refinement:
-  (forall beh, program_behaves (Csem.semantics c_program) beh -> not_wrong beh) ->
-  (forall beh, program_behaves (Asm.semantics asm_program) beh -> program_behaves (Csem.semantics c_program) beh).
-Proof.
-  intros. exploit separate_transf_c_program_preservation; eauto. intros (beh' & P & Q).
-  assert (not_wrong beh') by auto.
-  inv Q.
-- auto.
-- destruct H2 as (t & U & V). subst beh'. elim H1. 
-Qed.
-
-Theorem separate_transf_c_program_is_refinement_via_SSA:
-  (forall beh, program_behaves (Csem.semantics c_program) beh -> not_wrong beh) ->
-  (forall beh, program_behaves (Asm.semantics asm_program_SSA) beh -> program_behaves (Csem.semantics c_program) beh).
-Proof.
-  intros. exploit separate_transf_c_program_preservation_via_SSA; eauto. intros (beh' & P & Q).
-  assert (not_wrong beh') by auto.
-  inv Q.
-- auto.
-- destruct H2 as (t & U & V). subst beh'. elim H1. 
-Qed.
-
-(** We now show that if all executions of [c_program] satisfy a specification,
-  then all executions of [asm_program] also satisfy the specification, provided
-  the specification is of the safety-enforcing kind. *)
+(** Then, [asm_program] preserves the semantics and the specifications of *)
+(*   [c_program], in the following sense. *)
+(*   First, every behavior of [asm_program] improves upon one of the possible *)
+(*   behaviors of [c_program]. *)
 
-Theorem separate_transf_c_program_preserves_spec:
-  forall spec,
-  safety_enforcing_specification spec ->
-  c_program_satisfies_spec c_program spec ->
-  asm_program_satisfies_spec asm_program spec.
+Theorem separate_transf_clight_program_preservation:
+  improves (Clight.semantics1 c_program) (Asm.semantics asm_program).
 Proof.
-  intros spec SES CSAT; red; intros beh AEXEC.
-  exploit separate_transf_c_program_preservation; eauto. intros (beh' & CEXEC & IMPR).
-  apply CSAT in CEXEC. destruct IMPR as [EQ | [t [A B]]].
-- congruence.
-- subst beh'. apply SES in CEXEC. contradiction. 
+  exploit separate_transf_clight_program_correct; eauto. intros (a & P & Q).
+  assert (a = asm_program) by congruence. subst a. eauto.
 Qed.
 
-Theorem separate_transf_c_program_preserves_spec_via_SSA:
-  forall spec,
-  safety_enforcing_specification spec ->
-  c_program_satisfies_spec c_program spec ->
-  asm_program_satisfies_spec asm_program_SSA spec.
+Theorem separate_transf_clight_program_preservation_via_SSA:
+  improves (Clight.semantics1 c_program) (Asm.semantics asm_program_SSA).
 Proof.
-  intros spec SES CSAT; red; intros beh AEXEC.
-  exploit separate_transf_c_program_preservation_via_SSA; eauto. intros (beh' & CEXEC & IMPR).
-  apply CSAT in CEXEC. destruct IMPR as [EQ | [t [A B]]].
-- congruence.
-- subst beh'. apply SES in CEXEC. contradiction. 
+  intros. exploit separate_transf_clight_program_via_SSA_correct; eauto. intros (a & P & Q).
+  rewrite compiled_linking_SSA in P. clarify.
 Qed.
 
-(** As another corollary of [separate_transf_c_program_preservation],
-  if all executions of [c_program] have a trace [t] as initial trace,
-  so do all executions of [asm_program]. *)
+(** As a corollary, if [c_program] is free of undefined behaviors,  *)
+(**   the behavior of [asm_program] is one of the possible behaviors of [c_program]. *)
 
-Theorem separate_transf_c_program_preserves_initial_trace:
-  forall t,
-  c_program_has_initial_trace c_program t ->
-  asm_program_has_initial_trace asm_program t.
+Theorem separate_transf_clight_program_is_refinement:
+  (forall pm beh, program_observes (Clight.semantics1 c_program) (Some pm, beh) -> not_wrong beh /\ (pm <> fun _ => None)) ->
+  (forall pm beh, program_observes (Asm.semantics asm_program) (Some pm, beh) -> intact beh) ->
+  (forall pm_asm beh_asm, program_observes (Asm.semantics asm_program) (Some pm_asm, beh_asm) -> exists pm_c beh_c, program_observes (Clight.semantics1 c_program) (Some pm_c, beh_c) /\ gm_improves pm_c pm_asm /\ behav_rel pm_asm beh_c beh_asm).
 Proof.
-  intros t CTRACE; red; intros beh AEXEC.
-  exploit separate_transf_c_program_preservation; eauto. intros (beh' & CEXEC & IMPR).
-  apply CTRACE in CEXEC. destruct IMPR as [EQ | [t' [A B]]].
-- congruence.
-- destruct CEXEC as (beh1' & EQ').
-  destruct B as (beh1 & EQ).
-  subst beh'. destruct beh1'; simpl in A; inv A. 
-  exists (behavior_app t0 beh1). apply behavior_app_assoc.
+  intros. exploit separate_transf_clight_program_preservation; eauto. intros (obs' & P & Q).
+  destruct obs' as [pm' beh']. des. r in Q. ss. des. r in Q0. des_ifs.
+  assert (not_wrong beh'). { exploit H; eauto. i. des; eauto. }
+  assert (intact beh_asm). { exploit H0; eauto. }
+  exists o, beh'. esplits; eauto. r in Q. des ;eauto; subst; clarify.
 Qed.
 
-Theorem separate_transf_c_program_preserves_initial_trace_via_SSA:
-  forall t,
-  c_program_has_initial_trace c_program t ->
-  asm_program_has_initial_trace asm_program_SSA t.
+Theorem separate_transf_clight_program_is_refinement_via_SSA:
+  (forall pm beh, program_observes (Clight.semantics1 c_program) (Some pm, beh) -> not_wrong beh /\ (pm <> fun _ => None)) ->
+  (forall pm beh, program_observes (Asm.semantics asm_program_SSA) (Some pm, beh) -> intact beh) ->
+  (forall pm_asm beh_asm, program_observes (Asm.semantics asm_program_SSA) (Some pm_asm, beh_asm) -> exists pm_c beh_c, program_observes (Clight.semantics1 c_program) (Some pm_c, beh_c) /\ gm_improves pm_c pm_asm /\ behav_rel pm_asm beh_c beh_asm).
 Proof.
-  intros t CTRACE; red; intros beh AEXEC.
-  exploit separate_transf_c_program_preservation_via_SSA; eauto. intros (beh' & CEXEC & IMPR).
-  apply CTRACE in CEXEC. destruct IMPR as [EQ | [t' [A B]]].
-- congruence.
-- destruct CEXEC as (beh1' & EQ').
-  destruct B as (beh1 & EQ).
-  subst beh'. destruct beh1'; simpl in A; inv A. 
-  exists (behavior_app t0 beh1). apply behavior_app_assoc.
+  intros. exploit separate_transf_clight_program_preservation_via_SSA; eauto. intros (obs' & P & Q).
+  destruct obs' as [pm' beh']. des. r in Q. ss. des. r in Q0. des_ifs.
+  assert (not_wrong beh'). { exploit H; eauto. i. des; eauto. }
+  assert (intact beh_asm). { exploit H0; eauto. }
+  exists o, beh'. esplits; eauto. r in Q. des ;eauto; subst; clarify.
 Qed.
 
 End SEPARATE_COMPILATION.
diff --git a/driver/Interp.ml b/driver/Interp.ml
index 6c83e819..0b032887 100644
--- a/driver/Interp.ml
+++ b/driver/Interp.ml
@@ -73,7 +73,8 @@ let print_event p = function
       fprintf p "annotation \"%s\" %a"
                 (camlstring_of_coqstring text)
                 print_eventval_list args
-
+  | Event_pterm -> fprintf p "out-of-memory"
+ 
 (* Printing states *)
 
 let name_of_fundef prog fd =
diff --git a/exportclight/ExportClight.ml b/exportclight/ExportClight.ml
index 474a1bd8..546c165a 100644
--- a/exportclight/ExportClight.ml
+++ b/exportclight/ExportClight.ml
@@ -287,6 +287,7 @@ let external_function p = function
               coqstring text
               signatur sg
               (print_list coqstring) clob
+  | EF_capture -> fprintf p "EF_capture"
 
 (* Expressions *)
 
diff --git a/extraction/extraction.v b/extraction/extraction.v
index e890e6b1..2c2d58b2 100644
--- a/extraction/extraction.v
+++ b/extraction/extraction.v
@@ -133,7 +133,7 @@ Extract Constant Compiler.print_SSA => "PrintSSA.print_ssa".
 Extract Constant DomTest.fuel => "DomTreeExtern.fuel".
 Extract Constant SSAvalid.extern_d => "DomTreeExtern.DomTree.idom".
 
-Extract Constant GVNopt.extern_gvn => "GvnExtern.extern_gvn2".
+(* Extract Constant GVNopt.extern_gvn => "GvnExtern.extern_gvn2". *)
 
 Extract Constant RTLpargen.compute_cssaval_function => "CssaExtern.compute_cssaval_function".
 Extract Constant RTLpargen.build_coalescing_classes_extern => "CssaExtern.build_coalescing_classes_extern".
diff --git a/lib/AxiomsC.v b/lib/AxiomsC.v
new file mode 100644
index 00000000..401a3b08
--- /dev/null
+++ b/lib/AxiomsC.v
@@ -0,0 +1,7 @@
+Require ClassicalFacts.
+Require FunctionalExtensionality.
+(** newly added **)
+Require Export Axioms.
+
+Axiom prop_ext: ClassicalFacts.prop_extensionality.
+
diff --git a/lib/Coqlib.v b/lib/Coqlib.v
index 1e93b91d..75693dc1 100644
--- a/lib/Coqlib.v
+++ b/lib/Coqlib.v
@@ -1310,3 +1310,18 @@ Lemma nlist_forall2_imply:
 Proof.
   induction 1; simpl; intros; constructor; auto.
 Qed.
+
+(* To prevent "subst" *)
+Inductive my_eq {A: Type} (x: A): A -> Prop :=
+| my_eq_refl: my_eq x x.
+
+Notation "a m= b" := (my_eq a b) (at level 10).
+
+Ltac Eq :=
+  match goal with
+  | [ H1: ?a = ?b, H2: ?a = ?c |- _ ] =>
+    rewrite H1 in H2; inv H2; auto; Eq
+  | _ => idtac
+  end.
+
+
diff --git a/lib/CoqlibC.v b/lib/CoqlibC.v
new file mode 100644
index 00000000..0e37b879
--- /dev/null
+++ b/lib/CoqlibC.v
@@ -0,0 +1,1199 @@
+(** copied && added "C" **)
+Require Export ZArith.
+Require Export Znumtheory.
+Require Export List.
+Require Export Bool.
+
+(** newly added **)
+Require Export Coqlib.
+Ltac check_safe := let n := numgoals in guard n < 2.
+Require Export sflib.
+From Paco Require Export paco.
+Require Export Basics.
+
+Require Import Relations.
+Require Export RelationClasses.
+Require Import Wellfounded.
+Require Export Classical_Prop.
+Require Export Lia.
+Require Import AxiomsC.
+Require Import Relation_Operators.
+Require Export List.
+
+Set Implicit Arguments.
+
+
+
+Ltac determ_tac LEMMA :=
+  let tac := eauto in
+  let x := rev_all ltac:(fun f => apply f) in
+  let y := all ltac:(fun f => apply f) in
+  first[
+      exploit LEMMA; [x|y|]
+    | exploit LEMMA; [tac|x|y|]
+    | exploit LEMMA; [tac|tac|x|y|]
+    | exploit LEMMA; [tac|tac|tac|x|y|]
+    | exploit LEMMA; [tac|tac|tac|tac|x|y|]
+    ];
+  i; des; clarify.
+
+(* TODO: if it is mature enough, move it to sflib & remove this file *)
+
+Definition update_fst {A B C: Type} (f: A -> C) (ab: A * B): C * B := (f (fst ab), (snd ab)).
+
+Definition update_snd {A B C: Type} (f: B -> C) (ab: A * B): A * C := (fst ab, f (snd ab)).
+
+Lemma dep_split_right
+      (A B: Prop) (PA: A)
+      (PB: <<LEFT: A>> -> B):
+    <<SPLIT: A /\ B>>.
+Proof. split; eauto. Qed.
+
+Lemma dep_split_left
+      (A B: Prop)
+      (PA: <<RIGHT: B>> -> A)
+      (PB: B):
+    A /\ B.
+Proof. split; eauto. Qed.
+
+Lemma list_forall2_map
+      X Y (f: X -> Y) xs:
+    list_forall2 (fun x0 x1 => x1 = f x0) xs (map f xs).
+Proof. ginduction xs; ii; ss; econs; eauto. Qed.
+
+
+Lemma list_forall2_map_right
+      X Y (f: X -> Y) xs:
+    list_forall2 (fun x0 x1 => x0 = f x1) (map f xs) xs.
+Proof. ginduction xs; ii; ss; econs; eauto. Qed.
+
+Lemma Forall_app A P (l0 l1: list A)
+      (FORALL0: Forall P l0)
+      (FORALL1: Forall P l1):
+    Forall P (l0 ++ l1).
+Proof. ginduction l0; i; ss. inv FORALL0. econs; eauto. Qed.
+
+Lemma list_forall2_stronger
+      X Y xs ys (P: X -> Y -> Prop) Q
+      (FORALL2: list_forall2 P xs ys)
+      (STRONGER: P <2= Q):
+    <<FORALL2: list_forall2 Q xs ys>>.
+Proof. ginduction FORALL2; ii; ss; econs; eauto. eapply IHFORALL2; eauto. Qed.
+
+Global Program Instance incl_PreOrder {A}: PreOrder (@incl A).
+Next Obligation. ii. ss. Qed.
+Next Obligation. ii. eauto. Qed.
+
+(* is_Some & is_None? a bit harder to type *)
+Definition is_some {X} (x: option X): bool :=
+  match x with
+  | Some _ => true
+  | _ => false
+  end.
+
+Definition is_none {X} := negb <*> (@is_some X).
+
+Hint Unfold is_some is_none.
+
+
+Notation "x $" := ((proj1_sig x)) (at level 50, no associativity (* , only parsing *)).
+
+Notation top1 := (fun _ => True).
+Notation top2 := (fun _ _ => True).
+Notation top3 := (fun _ _ _ => True).
+Notation top4 := (fun _ _ _ _ => True).
+Notation top5 := (fun _ _ _ _ _ => True).
+Notation top6 := (fun _ _ _ _ _ _ => True).
+
+Notation " 'all1' p" := (forall x0, p x0) (at level 50, no associativity, only parsing).
+Notation " 'all2' p" := (forall x0 x1, p x0 x1) (at level 50, no associativity, only parsing).
+Notation " 'all3' p" := (forall x0 x1 x2, p x0 x1 x2) (at level 50, no associativity, only parsing).
+Notation " 'all4' p" := (forall x0 x1 x2 x3, p x0 x1 x2 x3) (at level 50, no associativity, only parsing).
+
+Notation " ~1 p" := (fun x0 => ~ (p x0)) (at level 50, no associativity).
+Notation " ~2 p" := (fun x0 x1 => ~ (p x0 x1)) (at level 50, no associativity).
+Notation " ~3 p" := (fun x0 x1 x2 => ~ (p x0 x1 x2)) (at level 50, no associativity).
+Notation " ~4 p" := (fun x0 x1 x2 x3 => ~ (p x0 x1 x2 x3)) (at level 50, no associativity).
+
+Notation "p /1\ q" := (fun x0 => and (p x0) (q x0)) (at level 50, no associativity).
+Notation "p /2\ q" := (fun x0 x1 => and (p x0 x1) (q x0 x1)) (at level 50, no associativity).
+Notation "p /3\ q" := (fun x0 x1 x2 => and (p x0 x1 x2) (q x0 x1 x2)) (at level 50, no associativity).
+Notation "p /4\ q" := (fun x0 x1 x2 x3 => and (p x0 x1 x2 x3) (q x0 x1 x2 x3)) (at level 50, no associativity).
+
+Notation "p -1> q" := (fun x0 => (forall (PR: p x0: Prop), q x0): Prop) (at level 50, no associativity).
+Notation "p -2> q" := (fun x0 x1 => (forall (PR: p x0 x1: Prop), q x0 x1): Prop) (at level 50, no associativity).
+Notation "p -3> q" := (fun x0 x1 x2 => ((forall (PR: p x0 x1 x2: Prop), q x0 x1 x2): Prop)) (at level 50, no associativity).
+Notation "p -4> q" := (fun x0 x1 x2 x3 => (forall (PR: p x0 x1 x2 x3: Prop), q x0 x1 x2 x3): Prop) (at level 50, no associativity).
+
+Goal all1 ((bot1: unit -> Prop) -1> top1). ii. ss. Qed.
+Goal ((bot1: unit -> Prop) <1= top1). ii. ss. Qed.
+Goal (bot2: unit -> unit -> Prop) <2= top2. ii. ss. Qed.
+
+
+Definition less1 X0 (p q: X0 -> Prop) := (forall x0 (PR: p x0 : Prop), q x0 : Prop).
+Definition less2 X0 X1 (p q: X0 -> X1 -> Prop) := (forall x0 x1 (PR: p x0 x1 : Prop), q x0 x1 : Prop).
+Definition less3 X0 X1 X2 (p q: X0 -> X1 -> X2 -> Prop) := (forall x0 x1 x2 (PR: p x0 x1 x2 : Prop), q x0 x1 x2 : Prop).
+Definition less4 X0 X1 X2 X3 (p q: X0 -> X1 -> X2 -> X3 -> Prop) := (forall x0 x1 x2 x3 (PR: p x0 x1 x2 x3 : Prop), q x0 x1 x2 x3 : Prop).
+
+Notation "p <1= q" := (less1 p q) (at level 50).
+Notation "p <2= q" := (less2 p q) (at level 50).
+Notation "p <3= q" := (less3 p q) (at level 50).
+Notation "p <4= q" := (less4 p q) (at level 50).
+
+Global Program Instance less1_PreOrder X0: PreOrder (@less1 X0).
+Next Obligation. ii. ss. Qed.
+Next Obligation. ii. eapply H0; eauto. Qed.
+Global Program Instance less2_PreOrder X0 X1: PreOrder (@less2 X0 X1).
+Next Obligation. ii. ss. Qed.
+Next Obligation. ii. eapply H0; eauto. Qed.
+Global Program Instance less3_PreOrder X0 X1 X2: PreOrder (@less3 X0 X1 X2).
+Next Obligation. ii. ss. Qed.
+Next Obligation. ii. eapply H0; eauto. Qed.
+Global Program Instance less4_PreOrder X0 X1 X2 X3 : PreOrder (@less4 X0 X1 X2 X3).
+Next Obligation. ii. ss. Qed.
+Next Obligation. ii. eapply H0; eauto. Qed.
+Hint Unfold less1 less2 less3 less4.
+
+Goal ((bot1: unit -> Prop) <1= top1). ii. ss. Qed.
+Goal (bot2: unit -> unit -> Prop) <2= top2. ii. ss. Qed.
+
+(* Notation "p =1= q" := (forall x0, eq (p x0) (q x0)) (at level 50, no associativity). *)
+Notation "p =1= q" := (fun x0 => eq (p x0) (q x0)) (at level 50, no associativity).
+Notation "p =2= q" := (fun x0 x1 => eq (p x0 x1) (q x0 x1)) (at level 50, no associativity).
+Notation "p =3= q" := (fun x0 x1 x2 => eq (p x0 x1 x2) (q x0 x1 x2)) (at level 50, no associativity).
+Notation "p =4= q" := (fun x0 x1 x2 x3 => eq (p x0 x1 x2 x3) (q x0 x1 x2 x3)) (at level 50, no associativity).
+
+Notation "p <1> q" := (fun x0 => iff (p x0) (q x0)) (at level 50, no associativity).
+Notation "p <2> q" := (fun x0 x1 => iff (p x0 x1) (q x0 x1)) (at level 50, no associativity).
+Notation "p <3> q" := (fun x0 x1 x2 => iff (p x0 x1 x2) (q x0 x1 x2)) (at level 50, no associativity).
+Notation "p <4> q" := (fun x0 x1 x2 x3 => iff (p x0 x1 x2 x3) (q x0 x1 x2 x3)) (at level 50, no associativity).
+
+Lemma prop_ext1
+      X0
+      (P Q: X0 -> Prop)
+      (IFF: all1 (P <1> Q)):
+    <<EQ: all1 (P =1= Q)>>.
+Proof. ss. ii. eapply prop_ext; eauto. Qed.
+
+Lemma prop_ext2
+      X0 X1
+      (P Q: X0 -> X1 -> Prop)
+      (IFF: all2 (P <2> Q)):
+    <<EQ: all2 (P =2= Q)>>.
+Proof. ss. ii. eapply prop_ext; eauto. Qed.
+
+Lemma prop_ext3
+      X0 X1 X2
+      (P Q: X0 -> X1 -> X2 -> Prop)
+      (IFF: all3 (P <3> Q)):
+    <<EQ: all3 (P =3= Q)>>.
+Proof. ss. ii. eapply prop_ext; eauto. Qed.
+
+Lemma prop_ext4
+      X0 X1 X2 X3
+      (P Q: X0 -> X1 -> X2 -> X3 -> Prop)
+      (IFF: all4 (P <4> Q)):
+    <<EQ: all4 (P =4= Q)>>.
+Proof. ss. ii. eapply prop_ext; eauto. Qed.
+
+Lemma func_ext1
+      X0 Y0
+      (P Q: X0 -> Y0)
+      (EQ: all1 (P =1= Q)):
+    <<EQ: P = Q>>.
+Proof. apply Axioms.functional_extensionality. ii; ss. Qed.
+
+Lemma func_ext2
+      X Y Z
+      (P Q: X -> Y -> Z)
+      (EQ: all2 (P =2= Q)):
+    <<EQ: P = Q>>.
+Proof. apply func_ext1; ss. i. apply func_ext1; ss. Qed.
+
+Lemma func_ext3
+      X Y Z W
+      (P Q: X -> Y -> Z -> W)
+      (EQ: all3 (P =3= Q)):
+    <<EQ: P = Q>>.
+Proof. apply func_ext2; ss. i. apply func_ext1; ss. Qed.
+
+(* Originally in sflib, (t):Prop *)
+(* Removed it for use in "privs" of ASTM *)
+(* Notation "<< x : t >>" := (NW (fun x => (t))) (at level 80, x ident, no associativity). *)
+
+
+Hint Unfold Basics.compose.
+
+
+(* Note: not clos_refl_trans. That is not well-founded.. *)
+Lemma well_founded_clos_trans
+      index
+      (order: index -> index -> Prop)
+      (WF: well_founded order):
+    <<WF: well_founded (clos_trans index order)>>.
+Proof. hnf in WF. hnf. i. eapply Acc_clos_trans. eauto. Qed.
+
+Lemma Forall2_impl
+      X Y
+      (xs: list X) (ys: list Y)
+      (P Q: X -> Y -> Prop)
+      (* (IMPL: all3 (P <3= Q)) *)
+      (IMPL: (P <2= Q))
+      (FORALL: Forall2 P xs ys):
+    <<FORALL: Forall2 Q xs ys>>.
+Proof. induction FORALL; econs; eauto. Qed.
+
+Inductive Forall3 X Y Z (R: X -> Y -> Z -> Prop): list X -> list Y -> list Z -> Prop :=
+| Forall3_nil: Forall3 R [] [] []
+| Forall3_cons
+    x y z xs ys zs
+    (TAIL: Forall3 R xs ys zs):
+    Forall3 R (x :: xs) (y :: ys) (z :: zs).
+
+Lemma Forall3_impl
+      X Y Z
+      (xs: list X) (ys: list Y) (zs: list Z)
+      (P Q: X -> Y -> Z -> Prop)
+      (* (IMPL: all3 (P <3= Q)) *)
+      (IMPL: (P <3= Q))
+      (FORALL: Forall3 P xs ys zs):
+    <<FORALL: Forall3 Q xs ys zs>>.
+Proof. induction FORALL; econs; eauto. Qed.
+
+
+Definition o_map A B (oa: option A) (f: A -> B): option B :=
+  match oa with
+  | Some a => Some (f a)
+  | None => None
+  end.
+
+Definition o_join A (a: option (option A)): option A :=
+  match a with
+  | Some a => a
+  | None => None
+  end.
+
+Definition o_bind A B (oa: option A) (f: A -> option B): option B := o_join (o_map oa f).
+Hint Unfold o_map o_join o_bind.
+
+Definition curry2 A B C (f: A -> B -> C): (A * B) -> C := fun ab => f (fst ab) (snd ab).
+
+Definition o_bind2 A B C (oab: option (A * B)) (f: A -> B -> option C) : option C :=
+o_join (o_map oab (curry2 f)).
+
+(* Notation "o >>= f" := (o_bind o f) (at level 50, no associativity) : option_monad_scope. *)
+
+(* Copied from Errors.v *)
+
+Notation "'do' X <- A ; B" := (o_bind A (fun X => B))
+ (at level 200, X ident, A at level 100, B at level 200)
+ : o_monad_scope.
+
+
+Notation "'do' ( X , Y ) <- A ; B" := (o_bind2 A (fun X Y => B))
+ (at level 200, X ident, Y ident, A at level 100, B at level 200)
+ : o_monad_scope.
+
+Notation "'assertion' A ; B" := (if A then B else None)
+  (at level 200, A at level 100, B at level 200, only parsing)
+  : o_monad_scope.
+
+Open Scope o_monad_scope.
+
+Lemma o_bind_ignore
+      X Y
+      (x: option X) (y: option Y):
+    (do _ <- x ; y) = assertion(x) ; y.
+Proof. des_ifs. Qed.
+
+Ltac subst_locals := all ltac:(fun H => is_local_definition H; subst H).
+
+Hint Unfold flip.
+
+Notation "p -1 q" := (p /1\ ~1 q) (at level 50).
+Notation "p -2 q" := (p /2\ ~2 q) (at level 50).
+Notation "p -3 q" := (p /3\ ~3 q) (at level 50).
+Notation "p -4 q" := (p /4\ ~4 q) (at level 50).
+
+Tactic Notation "u" "in" hyp(H) := repeat (autounfold with * in H; cbn in H).
+Tactic Notation "u" := repeat (autounfold with *; cbn).
+Tactic Notation "u" "in" "*" := repeat (autounfold with * in *; cbn in *).
+
+Lemma dependent_split_right
+      (A B: Prop)
+      (PA: A)
+      (PB: <<HINTLEFT: A>> -> B):
+    <<PAB: A /\ B>>.
+Proof. eauto. Qed.
+
+Lemma dependent_split_left
+      (A B: Prop)
+      (PA: <<HINTRIGHT: B>> -> A)
+      (PB: B):
+    <<PAB: A /\ B>>.
+Proof. eauto. Qed.
+
+Ltac dsplit_r := eapply dependent_split_right.
+Ltac dsplit_l := eapply dependent_split_left.
+Ltac dsplits :=
+  repeat (let NAME := fresh "SPLITHINT" in try (dsplit_r; [|intro NAME])).
+
+Locate des_sumbool.
+(* TODO: Update Coqlib *)
+Lemma proj_sumbool_is_false
+      P
+      (a: {P} + {~ P})
+      (FALSE: ~ P):
+    <<FALSE: proj_sumbool a = false>>.
+Proof. unfold proj_sumbool. des_ifs. Qed.
+
+Ltac des_sumbool :=
+  repeat
+    (unfold Datatypes.is_true, is_true in *;
+     match goal with
+     | [ H: proj_sumbool ?x = true |- _ ] => apply proj_sumbool_true in H
+     | [ H: proj_sumbool ?x = false |- _ ] => apply proj_sumbool_false in H
+     | [ H: true = proj_sumbool ?x |- _ ] => symmetry in H; apply proj_sumbool_true in H
+     | [ H: false = proj_sumbool ?x |- _ ] => symmetry in H; apply proj_sumbool_false in H
+
+     | [ |- proj_sumbool ?x = true ] => apply proj_sumbool_is_true
+     | [ |- proj_sumbool ?x = false ] => apply proj_sumbool_is_false
+     | [ |- true = proj_sumbool ?x ] => symmetry; apply proj_sumbool_is_true
+     | [ |- false = proj_sumbool ?x ] => symmetry; apply proj_sumbool_is_false
+     end).
+
+Ltac is_prop H :=
+  let ty := type of H in
+  match type of ty with
+  | Prop => idtac
+  | _ => fail 1
+  end.
+
+Ltac all_prop TAC := all ltac:(fun H => tryif is_prop H then TAC H else idtac).
+
+Ltac all_prop_inv := all_prop inv.
+(* TODO: infinite loop when inv-ing "a+b = c+d". "progress" tactic does not help here. *)
+(* TODO: add all_once, which captures only current hypotheses and apply TAC *)
+
+Ltac all_rewrite := all ltac:(fun H => rewrite_all H).
+
+Definition bar_True: Type := True.
+Global Opaque bar_True.
+Ltac bar :=
+  let NAME := fresh
+                "TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT" in
+  assert(NAME: bar_True) by ss.
+
+Ltac clear_until id :=
+  on_last_hyp ltac:(fun id' => match id' with
+                               | id => idtac
+                               | _ => clear id'; clear_until id
+                               end).
+
+Ltac clear_until_bar :=
+  on_last_hyp ltac:(fun id' => match (type of id') with
+                               | bar_True => idtac
+                               | _ => clear id'; clear_until_bar
+                               end).
+
+Goal True -> True -> False.
+  intro. bar. intro. clear_until H0. clear_until H. Undo 2. clear_until_bar. clear_tac.
+Abort.
+
+
+
+Definition aof_true: Type := True.
+Global Opaque aof_true.
+
+Ltac all_once_fast TAC :=
+  generalize (I: aof_true);
+  let name := fresh "bar" in
+  assert(name: aof_true) by constructor; move name at top; revert_until name;
+  repeat
+    match goal with
+    | [ |- aof_true -> _ ] => fail 1
+    | _ => intro; on_last_hyp TAC
+    end;
+  intro; on_last_hyp ltac:(fun H => clear H);
+  clear name.
+
+Goal forall (a b c d e: bool) f,
+    (negb true = false) -> (* IT SHOULD NOT RUN INF LOOP *)
+    (negb false = true) ->
+    (negb a = true) ->
+    (negb b = true) ->
+    (negb c = true) ->
+    True -> (* SHOULD IGNORE THIS *)
+    (negb d = true) ->
+    (negb e = true) ->
+    (0 :: 2 :: nil = f) -> (* SHOULD IGNORE THIS *)
+    (negb (true && false) = true) -> True -> False.
+Proof.
+  i. revert H9. all_once_fast ltac:(fun H => try apply negb_true_iff in H).
+Abort.
+
+Ltac spc H :=
+  let TAC := ss; eauto in
+  let ty := type of H in
+  match eval hnf in ty with
+  | forall (a: ?A), _ =>
+    (* let A := (eval compute in _A) in *)
+    match goal with
+    | [a0: A, a1: A, a2: A, a3: A, a4: A, a5: A |- _] => fail 2 "6 candidates!" a0 "," a1 "," a2 "," a3 "," a4 "," a5
+    | [a0: A, a1: A, a2: A, a3: A, a4: A |- _] => fail 2 "5 candidates!" a0 "," a1 "," a2 "," a3 "," a4
+    | [a0: A, a1: A, a2: A, a3: A |- _] => fail 2 "4 candidates!" a0 "," a1 "," a2 "," a3
+    | [a0: A, a1: A, a2: A |- _] => fail 2 "3 candidates!" a0 "," a1 "," a2
+    | [a0: A, a1: A |- _] => fail 2 "2 candidates!" a0 "," a1
+    | [a0: A |- _] => specialize (H a0)
+    | _ =>
+      tryif is_prop A
+      then
+        let name := fresh in
+        assert(name: A) by TAC; specialize (H name); clear name
+      else
+        fail 2 "No specialization possible!"
+    end
+  | _ => fail 1 "Nothing to specialize!"
+  end.
+
+Ltac spcN n H :=
+  let TAC := ss; eauto in
+  let ty := type of H in
+  match type of n with
+  | Z => idtac
+  | _ => fail "second argument should be 'Z'"
+  end;
+  match eval hnf in ty with
+  | forall (a: ?A), _ =>
+    (* let A := (eval compute in _A) in *)
+    match goal with
+    | [a0: A, a1: A, a2: A, a3: A, a4: A, a5: A |- _] =>
+      match n with
+      | - 5 => specialize (H a1)
+      | - 4 => specialize (H a2)
+      | - 3 => specialize (H a3)
+      | - 2 => specialize (H a4)
+      | - 1 => specialize (H a5)
+      | 0%Z => specialize (H a0)
+      | 1%Z => specialize (H a1)
+      | 2%Z => specialize (H a2)
+      | 3%Z => specialize (H a3)
+      | 4%Z => specialize (H a4)
+      | 5%Z => specialize (H a5)
+      | _ => fail 2 "6 candidates!" a0 "," a1 "," a2 "," a3 "," a4 "," a5
+      end
+    | [a0: A, a1: A, a2: A, a3: A, a4: A |- _] =>
+      match n with
+      | - 4 => specialize (H a1)
+      | - 3 => specialize (H a2)
+      | - 2 => specialize (H a3)
+      | - 1 => specialize (H a4)
+      | 0%Z => specialize (H a0)
+      | 1%Z => specialize (H a1)
+      | 2%Z => specialize (H a2)
+      | 3%Z => specialize (H a3)
+      | 4%Z => specialize (H a4)
+      | _ => fail 2 "5 candidates!" a0 "," a1 "," a2 "," a3 "," a4
+      end
+    | [a0: A, a1: A, a2: A, a3: A |- _] =>
+      match n with
+      | - 3 => specialize (H a1)
+      | - 2 => specialize (H a2)
+      | - 1 => specialize (H a3)
+      | 0%Z => specialize (H a0)
+      | 1%Z => specialize (H a1)
+      | 2%Z => specialize (H a2)
+      | 3%Z => specialize (H a3)
+      | _ => fail 2 "4 candidates!" a0 "," a1 "," a2 "," a3
+      end
+    | [a0: A, a1: A, a2: A |- _] =>
+      match n with
+      | - 2 => specialize (H a1)
+      | - 1 => specialize (H a2)
+      | 0%Z => specialize (H a0)
+      | 1%Z => specialize (H a1)
+      | 2%Z => specialize (H a2)
+      | _ => fail 2 "3 candidates!" a0 "," a1 "," a2
+      end
+    | [a0: A, a1: A |- _] =>
+      match n with
+      | - 1 => specialize (H a1)
+      | 0%Z => specialize (H a0)
+      | 1%Z => specialize (H a1)
+      | _ => fail 2 "2 candidates!" a0 "," a1
+      end
+    | [a0: A |- _] => specialize (H a0)
+    | _ =>
+      tryif is_prop A
+      then
+        let name := fresh in
+        assert(name: A) by TAC; specialize (H name); clear name
+      else
+        fail 2 "No specialization possible!"
+    end
+  | _ => fail 1 "Nothing to specialize!"
+  end.
+
+Goal let my_nat := nat in
+     let my_f := my_nat -> Prop in
+     forall (f: my_f) (g: nat -> Prop) (x: nat) (y: my_nat), False.
+  i. spc f. spc g.
+Abort.
+
+Lemma map_ext_strong
+      X Y (f g: X -> Y) xs
+      (EXT: forall x (IN: In x xs), f x = g x):
+    map f xs = map g xs.
+Proof.
+  ginduction xs; ii; ss. exploit EXT; eauto. i; des.
+  f_equal; ss. eapply IHxs; eauto.
+Qed.
+
+(* copied from : https://robbertkrebbers.nl/research/ch2o/tactics.html *)
+Hint Extern 998 (_ = _) => f_equal : f_equal.
+Hint Extern 999 => congruence : congruence.
+Hint Extern 1000 => lia : lia.
+
+
+
+Section ALIGN.
+
+  Lemma align_refl
+        x
+        (NONNEG: x >= 0):
+    <<ALIGN: align x x = x>>.
+  Proof.
+    destruct (Z.eqb x 0) eqn: T.
+    { rewrite Z.eqb_eq in T. clarify. }
+    rewrite Z.eqb_neq in T. red. unfold align.
+    replace ((x + x - 1) / x) with 1.
+    { extlia. }
+    replace (x + x - 1) with (1 * x + (1 * x + (- 1))); cycle 1.
+    { extlia. }
+    rewrite Z.div_add_l; try eassumption.
+    rewrite Z.div_add_l; try eassumption.
+    replace (Z.div (Zneg xH) x) with (Zneg xH).
+    { extlia. }
+    destruct x; ss. clear - p. unfold Z.div. des_ifs. ginduction p; i; ss; des_ifs.
+  Qed.
+
+  Lemma align_zero: forall x, <<ALIGN: align x 0 = 0>>.
+  Proof. i. unfold align. red. ss. extlia. Qed.
+
+  Lemma align_divisible
+        z y
+        (DIV: (y | z))
+        (NONNEG: y > 0):
+      <<ALIGN: align z y = z>>.
+  Proof.
+    red. unfold align.
+    replace ((z + y - 1) / y) with (z / y + (y - 1) / y); cycle 1.
+    { unfold Z.divide in *. des. clarify. rewrite Z_div_mult; ss.
+      replace (z0 * y + y - 1) with (z0 * y + (y - 1)); cycle 1.
+      { extlia. }
+      rewrite Z.div_add_l with (b := y); ss. extlia.
+    }
+    replace ((y - 1) / y) with 0; cycle 1.
+    { erewrite Zdiv_small; ss. extlia. }
+    unfold Z.divide in *. des. clarify. rewrite Z_div_mult; ss. rewrite Z.add_0_r. extlia.
+  Qed.
+
+  Lemma align_idempotence
+        x y
+        (NONNEG: y > 0):
+      <<ALIGN: align (align x y) y = align x y>>.
+  Proof. apply align_divisible; ss. apply align_divides; ss. Qed.
+
+End ALIGN.
+
+Hint Rewrite align_refl: align.
+Hint Rewrite align_zero: align.
+Hint Rewrite align_idempotence: align.
+
+Ltac inv_all_once := all_once_fast ltac:(fun H => try inv H).
+Ltac apply_all_once LEMMA :=  all_once_fast ltac:(fun H => try apply LEMMA in H).
+
+Lemma find_map
+      X Y (f: Y -> bool) (x2y: X -> Y) xs:
+    find f (map x2y xs) = o_map (find (f <*> x2y) xs) x2y.
+Proof. u. ginduction xs; ii; ss. des_ifs; ss. Qed.
+
+Ltac revert_until_bar :=
+  on_last_hyp ltac:(fun id' => match (type of id') with
+                               | bar_True => idtac
+                               | _ => revert id'; revert_until_bar
+                               end).
+
+(* Ltac folder := all_once_fast ltac:(fun H => try (is_local_definition H; fold_all H)). *)
+Ltac folder :=
+  repeat multimatch goal with
+         | [ H: _ |- _ ] => is_local_definition H; fold_all H
+         end.
+
+(* copied from promising/lib/Basic.v *)
+
+Ltac refl := reflexivity.
+Ltac etrans := etransitivity.
+Ltac congr := congruence.
+
+Notation rtc := (clos_refl_trans_1n _). (* reflexive transitive closure *)
+Notation rc := (clos_refl _). (* reflexive transitive closure *)
+Notation tc := (clos_trans _). (* transitive closure *)
+Hint Immediate rt1n_refl rt1n_trans t_step.
+
+Program Instance rtc_PreOrder A (R:A -> A -> Prop): PreOrder (rtc R).
+Next Obligation.
+  ii. revert H0. induction H; auto. i. exploit IHclos_refl_trans_1n; eauto.
+Qed.
+
+Lemma rtc_tail A R
+      (a1 a3:A)
+      (REL: rtc R a1 a3):
+  (exists a2, rtc R a1 a2 /\ R a2 a3) \/
+  (a1 = a3).
+Proof.
+  induction REL; auto. des; subst; left; eexists; splits; [|eauto| | eauto]; econs; eauto.
+Qed.
+
+Lemma rtc_implies A (R1 R2: A -> A -> Prop)
+      (IMPL: R1 <2= R2):
+  rtc R1 <2= rtc R2.
+Proof.
+  ii. induction PR; eauto. etrans; [|eauto]. econs 2; [|econs 1]. apply IMPL. auto.
+Qed.
+
+Lemma rtc_refl
+      A R (a b:A)
+      (EQ: a = b):
+  rtc R a b.
+Proof. subst. econs. Qed.
+
+Lemma rtc_n1
+      A R (a b c:A)
+      (AB: rtc R a b)
+      (BC: R b c):
+  rtc R a c.
+Proof. etrans; eauto. econs 2; eauto. Qed.
+
+Lemma rtc_reverse
+      A R (a b:A)
+      (RTC: rtc R a b):
+  rtc (fun x y => R y x) b a.
+Proof. induction RTC; eauto. etrans; eauto. econs 2; eauto. Qed.
+
+Lemma rtc_once
+      A (R: A -> A -> Prop) a b
+      (ONCE: R a b):
+    rtc R a b.
+Proof. econs; eauto. Qed.
+
+Lemma Forall2_length
+      X Y (P: X -> Y -> Prop) xs ys
+      (FORALL2: Forall2 P xs ys):
+    length xs = length ys.
+Proof. ginduction FORALL2; ii; ss. extlia. Qed.
+
+Ltac hexpl_aux H NAME :=
+  let n := fresh NAME in
+  first[hexploit H; eauto; check_safe; repeat intro n; des].
+Tactic Notation "hexpl" constr(H) := hexpl_aux H H.
+(* Tactic Notation "hexpl" constr(H) tactic(TAC) := hexpl_aux H TAC. *)
+Tactic Notation "hexpl" constr(H) ident(NAME) := hexpl_aux H NAME.
+
+(* 0 goal *)
+Goal forall (mytt: unit) (H: unit -> False), False.
+  i. hexpl H.
+Qed.
+
+(* 1 goal *)
+Goal forall (H: nat -> False), False.
+  i. hexpl H.
+Abort.
+
+Goal forall (H: nat -> nat -> False), False.
+  i. Fail hexpl H.
+Abort.
+
+(* name *)
+Goal forall (mytt: unit) (HH: unit -> (True -> True /\ True)), False.
+  i. hexpl HH ABC. hexpl HH.
+Abort.
+
+Hint Extern 997 => extlia : extlia.
+
+Hint Rewrite
+     Z.add_0_l Z.add_0_r Z.add_assoc Z.add_simpl_l Z.add_simpl_r Z.add_opp_r Z.add_opp_l
+     Z.mul_0_l Z.mul_0_r Z.mul_assoc
+     Z.sub_0_r Z.sub_diag Z.sub_simpl_l Z.sub_simpl_r Z.sub_0_l
+     Z.div_0_l Zdiv_0_r Z.div_1_r
+     Z.mod_1_r Z.mod_0_l Z.mod_same Z.mod_mul Z.mod_mod
+     Z.sub_add
+  : zsimpl.
+
+Ltac zsimpl := repeat autorewrite with zsimpl in *.
+
+Ltac rp := first [erewrite f_equal8|
+                  erewrite f_equal7|
+                  erewrite f_equal6|
+                  erewrite f_equal5|
+                  erewrite f_equal4|
+                  erewrite f_equal3|
+                  erewrite f_equal2|
+                  erewrite f_equal|
+                  fail].
+
+Ltac align_bool :=
+  (repeat match goal with
+          | [ H: true <> true |- _ ] => tauto
+          | [ H: false <> false |- _ ] => tauto
+          | [ H: true <> _ |- _ ] => symmetry in H
+          | [ H: false <> _ |- _ ] => symmetry in H
+          | [ H: _ <> true |- _ ] => apply not_true_is_false in H
+          | [ H: _ <> false |- _ ] => apply not_false_is_true in H
+          end).
+Ltac simpl_bool := unfold Datatypes.is_true in *; unfold is_true in *; autorewrite with simpl_bool in *.
+Ltac bsimpl := simpl_bool.
+
+Definition range (lo hi: Z): Z -> Prop := fun x => lo <= x < hi. (* TODO: Use Notation instead *)
+Hint Unfold range.
+
+Ltac sym := symmetry.
+Tactic Notation "sym" "in" hyp(H) := symmetry in H.
+
+Ltac eapply_all_once LEMMA :=
+  all_once_fast ltac:(fun H => try eapply LEMMA in H; try eassumption; check_safe).
+
+Ltac Nsimpl := all_once_fast ltac:(fun H => try apply NNPP in H; try apply not_and_or in H; try apply not_or_and in H).
+
+Ltac hexploit1 H :=
+  match goal with
+  | [ H: ?A -> ?B |- _ ] =>
+    apply (@mp B); [apply H|clear H; intro H]
+  end.
+
+Lemma rev_nil
+      X (xs: list X)
+      (NIL: rev xs = []):
+    xs = [].
+Proof.
+  generalize (f_equal (@length _) NIL). i. ss. destruct xs; ss. rewrite app_length in *. ss. extlia.
+Qed.
+
+Fixpoint last_opt X (xs: list X): option X :=
+  match xs with
+  | [] => None
+  | [hd] => Some hd
+  | hd :: tl => last_opt tl
+  end.
+
+Lemma last_none
+      X (xs: list X)
+      (NONE: last_opt xs = None):
+    xs = [].
+Proof. ginduction xs; ii; ss. des_ifs. spc IHxs. ss. Qed.
+
+Lemma last_some
+      X (xs: list X) x
+      (SOME: last_opt xs = Some x):
+    exists hds, xs = hds ++ [x].
+Proof.
+  ginduction xs; ii; ss. des_ifs.
+  { exists nil. ss. }
+  exploit IHxs; eauto. i; des. rewrite H. exists (a :: hds). ss.
+Qed.
+
+Lemma forall2_eq
+      X Y (P: X -> Y -> Prop) xs ys:
+    list_forall2 P xs ys <-> Forall2 P xs ys.
+Proof. split; i; ginduction xs; ii; ss; inv H; ss; econs; eauto. Qed.
+
+(* Fixpoint zip X Y Z (f: option X -> option Y -> Z) (xs: list X) (ys: list Y): list Z := *)
+(*   match xs, ys with *)
+(*   | [], [] => [] *)
+(*   | xhd :: xtl, [] => f (Some xhd) None :: zip f xtl [] *)
+(*   | [], yhd :: ytl => f None (Some yhd) :: zip f [] ytl *)
+(*   | xhd :: xtl, yhd :: ytl => f (Some xhd) (Some yhd) :: zip f xtl ytl *)
+(*   end *)
+(* . *)
+
+Fixpoint zip X Y Z (f: X -> Y -> Z) (xs: list X) (ys: list Y): list Z :=
+  match xs, ys with
+  | xhd :: xtl, yhd :: ytl => f xhd yhd :: zip f xtl ytl
+  | _, _ => []
+  end.
+
+(* Set Printing All. *)
+
+(* Lemma zip_length
+    y X Y Z (f: X -> Y -> Z) xs ys:
+    length (zip f xs ys) = min xs.(length) ys.(length).
+Proof. 
+  ginduction xs; ii; ss. des_ifs. ss. rewrite IHxs. extlia. Qed. *)
+
+Lemma in_zip_iff
+      X Y Z (f: X -> Y -> Z) xs ys z:
+    (<<ZIP: In z (zip f xs ys)>>)
+    <-> (exists x y, <<F: f x y = z>> /\ exists n, <<X: nth_error xs n = Some x>> /\ <<Y: nth_error ys n = Some y>>).
+Proof.
+  split; ii.
+  - ginduction xs; ii; ss. des_ifs. ss. des; ss.
+    + esplits; eauto; try instantiate (1 := 0%nat); ss.
+    + exploit IHxs; eauto. i; des. esplits; eauto; try instantiate (1:= (1+n)%nat); ss.
+  - des. ginduction n; ii; ss.
+    { des_ifs. ss. left; ss. }
+    des_ifs. ss. exploit (@IHn _ _ _ f); eauto.
+Qed.
+
+Global Opaque Z.mul.
+
+Lemma unit_ord_wf: well_founded (bot2: unit -> unit -> Prop).
+Proof. ii. induction a; ii; ss. Qed.
+
+Ltac et:= eauto.
+
+Require Import Program.
+
+Lemma f_equal_h
+      X1 X2 Y1 Y2 (f1: X1 -> Y1) (f2: X2 -> Y2) x1 x2
+      (TYPX: X1 = X2)
+      (FUNC: f1 ~= f2)
+      (ARG: x1 ~= x2)
+      (TYPY: Y1 = Y2): (* Do we need this? *)
+    f1 x1 ~= f2 x2.
+Proof. subst. rewrite FUNC. ss. Qed.
+
+Lemma f_equal_hr
+      X1 X2 Y (f1: X1 -> Y) (f2: X2 -> Y) x1 x2
+      (FUNC: f1 ~= f2)
+      (TYP: X1 = X2)
+      (ARG: x1 ~= x2):
+    f1 x1 = f2 x2.
+Proof. eapply JMeq_eq. eapply f_equal_h; eauto. Qed.
+
+Lemma f_equal_rh
+      X Y1 Y2 (f1: X -> Y1) (f2: X -> Y2) x
+      (FUNC: f1 ~= f2)
+      (TYP: Y1 = Y2):
+    f1 x ~= f2 x.
+Proof. eapply f_equal_h; eauto. Qed.
+
+Lemma cons_app
+      X xhd (xtl: list X):
+    xhd :: xtl = [xhd] ++ xtl.
+Proof. ss. Qed.
+
+Lemma list_map_injective A B (f: A -> B)
+      (INJECTIVE: forall a0 a1 (EQ: f a0 = f a1), a0 = a1)
+      l0 l1
+      (LEQ: map f l0 = map f l1):
+    l0 = l1.
+Proof.
+  revert l1 LEQ. induction l0; i; ss; destruct l1; ss. inv LEQ. f_equal; eauto.
+Qed.
+
+Lemma Forall_in_map A B al (R: B -> Prop) (f: A -> B)
+      (RMAP: forall a (IN: In a al), R (f a)):
+    Forall R (map f al).
+Proof. induction al; econs; ss; eauto. Qed.
+
+Lemma Forall2_in_map A B al (R: B -> A -> Prop) (f: A -> B)
+      (RMAP: forall a (IN: In a al), R (f a) a):
+    list_forall2 R (map f al) al.
+Proof. induction al; econs; ss; eauto. Qed.
+
+Lemma eq_Forall2_eq A (al0 al1 : list A):
+    list_forall2 eq al0 al1 <-> al0 = al1.
+Proof.
+  revert al1. induction al0; ss; i; split; i; eauto; inv H; try econs; eauto.
+  - f_equal. eapply IHal0. eauto.
+  - eapply IHal0. eauto.
+Qed.
+
+Lemma list_forall2_lift A B (R0 R1: A -> B -> Prop) al bl
+      (SAME: forall a (IN: In a al) b, R0 a b -> R1 a b)
+      (FORALL: list_forall2 R0 al bl):
+    list_forall2 R1 al bl.
+Proof.
+  generalize dependent bl. revert SAME. induction al; ss; i; inv FORALL; econs; eauto.
+Qed.
+
+Lemma Forall_map A B la (R: B -> Prop) (f: A -> B)
+      (RMAP: forall a, R (f a)):
+    Forall R (map f la).
+Proof. induction la; econs; ss. Qed.
+
+Lemma f_hequal A (B : A -> Type) (f : forall a, B a)
+      a1 a2 (EQ : a1 = a2):
+    f a1 ~= f a2.
+Proof. destruct EQ. econs. Qed.
+
+Lemma list_forall2_rev A B R (la: list A) (lb: list B)
+      (FORALL: list_forall2 R la lb):
+    list_forall2 (flip R) lb la.
+Proof.
+  generalize dependent lb. induction la; i; eauto; inv FORALL; econs; eauto.
+Qed.
+
+Ltac uo := unfold o_bind, o_map, o_join in *.
+
+Lemma some_injective
+      X (x0 x1: X)
+      (EQ: Some x0 = Some x1):
+    x0 = x1.
+Proof. injection EQ. auto. Qed.
+
+Ltac align_opt :=
+  repeat
+    match goal with
+    (* remove trivial things *)
+    | H: Some ?x = Some ?y |- _ => rewrite some_injective in H
+    | H: Some _ = None |- _ => by (inversion H)
+    | H: None = Some _ |- _ => by (inversion H)
+    | H: None = None |- _ => clear H
+    (* align *)
+    | H: Some _ = ?x |- _ => symmetry in H
+    | H: None = ?x |- _ => symmetry in H
+    end.
+(* Ltac clarify0 := repeat (align_opt; progress clarify). *)
+
+Fixpoint list_diff X (dec: (forall x0 x1, {x0 = x1} + {x0 <> x1})) (xs0 xs1: list X): list X :=
+  match xs0 with
+  | [] => []
+  | hd :: tl =>
+    if in_dec dec hd xs1
+    then list_diff dec tl xs1
+    else hd :: list_diff dec tl xs1
+  end.
+
+Lemma list_diff_spec
+      X dec (xs0 xs1 xs2: list X)
+      (DIFF: list_diff dec xs0 xs1 = xs2):
+    <<SPEC: forall x0, In x0 xs2 <-> (In x0 xs0 /\ ~ In x0 xs1)>>.
+Proof.
+  subst. split; i.
+  - ginduction xs0; ii; des; ss. des_ifs.
+    { exploit IHxs0; et. i; des. esplits; et. }
+    ss. des; clarify.
+    { tauto. }
+    exploit IHxs0; et. i; des. esplits; et.
+  - ginduction xs0; ii; des; ss. des; clarify; des_ifs; ss; try tauto; exploit IHxs0; et.
+Qed.
+
+Fixpoint last_option X (xs: list X): option X :=
+  match xs with
+  | [] => None
+  | hd :: nil => Some hd
+  | hd :: tl => last_option tl
+  end.
+Lemma not_ex_all_not
+      U (P: U -> Prop)
+      (NEX: ~ (exists n : U, P n)):
+    <<NALL: forall n : U, ~ P n>>.
+Proof. eauto. Qed.
+
+(* Remark: if econs/econsr gives different goal, at least 2 econs is possible *)
+Ltac econsr :=
+  first
+    [ econstructor 16
+     |econstructor 15
+     |econstructor 14
+     |econstructor 13
+     |econstructor 12
+     |econstructor 11
+     |econstructor 10
+     |econstructor  9
+     |econstructor  8
+     |econstructor  7
+     |econstructor  6
+     |econstructor  5
+     |econstructor  4
+     |econstructor  3
+     |econstructor  2
+     |econstructor  1].
+
+Ltac it TERM := instantiate (1:=TERM).
+Ltac itl TERM :=
+  first[ instantiate (10:=TERM)|
+         instantiate (9:=TERM)|
+         instantiate (8:=TERM)|
+         instantiate (7:=TERM)|
+         instantiate (6:=TERM)|
+         instantiate (5:=TERM)|
+         instantiate (4:=TERM)|
+         instantiate (3:=TERM)|
+         instantiate (2:=TERM)|
+         instantiate (1:=TERM)|
+         fail].
+
+Lemma NoDup_norepet
+      X (xs: list X):
+    NoDup xs <-> list_norepet xs.
+Proof. split; induction 1; econs; ss. Qed.
+
+Ltac swapname NAME1 NAME2 :=
+  let tmp := fresh "TMP" in
+  rename NAME1 into tmp; rename NAME2 into NAME1; idtac NAME1; rename tmp into NAME2
+.
+
+Global Program Instance top2_PreOrder X: PreOrder (top2: X -> X -> Prop).
+
+(* Lemma app_eq_inv
+      A (x0 x1 y0 y1: list A)
+      (EQ: x0 ++ x1 = y0 ++ y1)
+      (LEN: x0.(length) = y0.(length)):
+    x0 = y0 /\ x1 = y1.
+Proof.
+  ginduction x0; ii; ss.
+  { destruct y0; ss. }
+  destruct y0; ss. clarify. exploit IHx0; eauto. i; des. clarify.
+Qed. *)
+
+Lemma pos_elim_succ: forall p,
+    <<ONE: p = 1%positive>> \/
+    <<SUCC: exists q, (Pos.succ q) = p>>.
+Proof. i. hexploit (Pos.succ_pred_or p); eauto. i; des; ss; eauto. Qed.
+
+Lemma ple_elim_succ
+      p q
+      (PLE: Ple p q):
+    <<EQ: p = q>> \/
+    <<SUCC: Ple (Pos.succ p) q>>.
+Proof.
+  revert_until p. pattern p. apply Pos.peano_ind; clear p; i.
+  { hexploit (pos_elim_succ q); eauto. i. des; clarify; eauto. right. r. extlia. }
+  hexploit (pos_elim_succ q); eauto. i. des; clarify.
+  { left. extlia. }
+  exploit H; eauto.
+  { it q0. extlia. }
+  i; des; clarify.
+  - left. r. extlia.
+  - right. r. extlia.
+Qed.
+
+Section FLIPS.
+
+Definition flip2 A B C D: (A -> B -> C -> D) -> A -> C -> B -> D. intros; eauto. Defined.
+Definition flip3 A B C D E: (A -> B -> C -> D -> E) -> A -> B -> D -> C -> E. intros; eauto. Defined.
+Definition flip4 A B C D E F: (A -> B -> C -> D -> E -> F) -> A -> B -> C -> E -> D -> F. intros; eauto. Defined.
+
+Variable A B C D: Type.
+Variable f: A -> B -> C -> D.
+
+Let put_dummy_arg_without_filp A DUMMY B: (A -> B) -> (A -> DUMMY -> B) := fun f => (fun a _ => f a).
+Let put_dummy_arg1 A DUMMY B: (A -> B) -> (A -> DUMMY -> B) := fun f => (flip (fun _ => f)).
+Let put_dummy_arg21 A DUMMY B C: (A -> B -> C) -> (A -> DUMMY -> B -> C) := fun f => (flip (fun _ => f)).
+Let put_dummy_arg22 A B DUMMY C: (A -> B -> C) -> (A -> B -> DUMMY -> C) :=
+  fun f => (flip2 (flip (fun _ => f))).
+
+End FLIPS.
+Hint Unfold flip2 flip3 flip4.
+
+Definition DUMMY_PROP := True.
+Hint Unfold DUMMY_PROP.
+
+Inductive my_eq {A: Type} (x: A): A -> Prop :=
+| my_eq_refl: my_eq x x.
+
+Notation "a m= b" := (my_eq a b) (at level 10).
+
+Ltac clarify_meq :=
+  repeat
+    match goal with
+    | [ H0: ?A m= ?B |- _ ] => inv H0
+    | [ H0: ?A = ?A -> _ |- _ ] => exploit H0; eauto; check_safe; intro; des; clear H0
+    end;
+    clarify.
+
+Local Transparent list_nth_z.
+Lemma list_nth_z_eq
+      A (l: list A) z
+      (POS: 0 <= z):
+    list_nth_z l z = List.nth_error l (Z.to_nat z).
+Proof.
+  ginduction l; ii; ss.
+  - destruct ((Z.to_nat z)); ss.
+  - des_ifs. destruct (Z.to_nat) eqn:T; ss.
+    + destruct z; ss. destruct p; ss. extlia.
+    + rewrite IHl; ss; eauto; try extlia. rewrite Z2Nat.inj_pred. rewrite T. ss.
+Qed.
+Local Opaque list_nth_z.
+
+Lemma list_nth_z_firstn
+      (A:Type) (l: list A) n x
+      (T:list_nth_z l n = Some x):
+      list_nth_z (firstn (Z.to_nat (n + 1)) l) n = Some x.
+Proof.
+  exploit list_nth_z_range; eauto. intro RANGE; des.
+  rewrite list_nth_z_eq in *; try extlia. rewrite Z2Nat.inj_add; ss. rewrite Pos2Nat.inj_1. rewrite Nat.add_comm.
+  exploit nth_error_Some; et. intro X. rewrite T in X. des.
+  exploit X; eauto. { ss. } intro Y.
+  erewrite <- (firstn_skipn (1 + (Z.to_nat n)) l) in T.
+  rewrite nth_error_app1 in T; eauto. rewrite firstn_length. extlia.
+Qed.
+
+Lemma firstn_S
+      (A: Type) (l: list A) n:
+      (le (Datatypes.length l) n /\ firstn (n + 1) l = firstn n l)
+    \/ (lt n (Datatypes.length l) /\ exists x, firstn (n + 1) l = (firstn n l) ++ [x]).
+Proof.
+  ginduction l; i; try by (left; do 2 rewrite firstn_nil; split; ss; lia). destruct n.
+  { right. ss. split; try lia. eauto. }
+  specialize (IHl n). ss. des.
+  - left. split; try lia. rewrite IHl0. ss.
+  - right. split; try lia. rewrite IHl0. eauto.
+Qed.
+
+Lemma map_firstn
+      (A B: Type) (l: list A) (f: A -> B) n:
+    map f (firstn n l) = firstn n (map f l).
+Proof.
+  ginduction l; ss; i.
+  { ss. do 2 rewrite firstn_nil. ss. }
+  destruct n; ss. rewrite IHl. ss.
+Qed.
+
+Lemma list_nth_z_map
+      (A B: Type) (l: list A) n x (f: A -> B)
+      (NTH: list_nth_z l n = Some x):
+    list_nth_z (map f l) n = Some (f x).
+Proof.
+  exploit list_nth_z_range; eauto. intro RANGE; des.
+  rewrite list_nth_z_eq in *; try extlia. rewrite list_map_nth in *. rewrite NTH. ss.
+Qed.
+
+Lemma tail_In A l0 l1 (a: A)
+      (IN: In a l0)
+      (TAIL: is_tail l0 l1):
+    In a l1.
+Proof. induction TAIL; auto. econs 2; eauto. Qed.
+
+Lemma Forall2_apply_Forall2 A B C D (f: A -> C) (g : B -> D)
+      (P: A -> B -> Prop) (Q: C -> D -> Prop)
+      la lb
+      (FORALL: Forall2 P la lb)
+      (IMPLY: forall a b (INA: In a la) (INB: In b lb),
+          P a b -> Q (f a) (g b)):
+    Forall2 Q (map f la) (map g lb).
+Proof.
+  ginduction la; ss; i; inv FORALL; ss. econs; eauto.
+Qed.
+
+Lemma forall2_in_exists A B (P: A -> B -> Prop) la lb
+      (ALL: list_forall2 P la lb)
+      a
+      (IN: In a la):
+    exists b, (<<IN: In b lb>>) /\ (<<SAT: P a b>>).
+Proof.
+  revert la lb ALL a IN. induction la; ss.
+  i. inv ALL. des.
+  - clarify. esplits; eauto. econs. auto.
+  - eapply IHla in H3; eauto. des. esplits; eauto. econs 2. auto.
+Qed.
+
+Lemma negb_eq
+  b1 b2
+  (NEG: negb b1 = negb b2)
+  :
+  <<EQ: b1 = b2>>.
+Proof. destruct b1; destruct b2; ss. Qed.
+
diff --git a/lib/Lattice.v b/lib/Lattice.v
index 6fed3f21..3003cfb2 100644
--- a/lib/Lattice.v
+++ b/lib/Lattice.v
@@ -212,6 +212,7 @@ Lemma tree_eq_node:
   tree_eq (PTree.Node l1 o1 r1) (PTree.Node l2 o2 r2).
 Proof.
   intros; red; intros. destruct i; simpl; auto.
+  (* eauto. eauto. *)
 Qed.
 
 Lemma tree_eq_node':
diff --git a/lib/Maps.v b/lib/Maps.v
index 6bc6e14b..8f53e257 100644
--- a/lib/Maps.v
+++ b/lib/Maps.v
@@ -959,6 +959,95 @@ Module PTree <: TREE.
     intros. apply fold1_xelements with (l := @nil (positive * A)).
   Qed.
 
+  Definition select {A B:Type}
+             (pred:positive -> A -> option B)
+             (m: t A): option B :=
+    fold
+      (fun acc i a =>
+         match acc with
+         | Some _ => acc
+         | None => pred i a
+         end)
+      m
+      None.
+
+  (* From Coq Require Import ssreflect ssrfun ssrbool. *)
+  Require Import sflib.
+
+  Lemma gselectf {A B:Type}
+        (pred:positive -> A -> option B)
+        (m:t A) b (H: select pred m = Some b):
+    exists i a, get i m = Some a /\ pred i a = Some b.
+  Proof.
+    unfold select in H.
+    rewrite fold_spec in H. rewrite <- fold_left_rev_right in H.
+    assert (J: exists i a, In (i, a) (rev (elements m)) /\ pred i a = Some b).
+    - generalize dependent H.
+      generalize (rev (elements m)).
+      induction l; simpl; ss.
+      generalize dependent IHl.
+      match goal with
+        | [|- (?c = _ -> _) -> _] =>
+          destruct c
+      end.
+      + intros X Y. inv Y.
+        exploit X; eauto. clear X. intros [i [a' [Hin Hpred]]]. subst.
+        eexists. eexists. split; eauto.
+      + intros _ X. destruct a. simpl in *.
+        destruct (pred p a) eqn:Hpred; [|ss]. inv X.
+        eexists. eexists. split; [by left; eauto|ss].
+    - destruct J as [i [a [Hin Hpred]]]. subst.
+      eexists. eexists. split; eauto.
+      apply elements_complete. by apply in_rev.
+  Qed.
+
+  Lemma gselectnf {A B:Type}
+        (pred:positive -> A -> option B)
+        (m:t A) (H: select pred m = None):
+    ~ exists i a, get i m = Some a /\ pred i a <> None.
+  Proof.
+    unfold select in H.
+    rewrite fold_spec in H. rewrite <- fold_left_rev_right in H.
+    assert (J: ~ exists i a, In (i, a) (rev (elements m)) /\ pred i a <> None).
+    - generalize dependent H.
+      generalize (rev (elements m)).
+      induction l; simpl.
+      + by intros _ [? [? [? ?]]].
+      + generalize dependent IHl.
+        match goal with
+          | [|- (?c = _ -> _) -> _] =>
+            destruct c
+        end.
+        * by intros _ ?.
+        * intros H1 H2 [i [b [[H3|H3] H4]]]; subst; simpl in *.
+          { by rewrite H2 in H4. }
+          { apply H1; auto. eexists. eexists. split; eauto. }
+    - intros [i [a [H1 H2]]]. apply J.
+      eexists. eexists. split; eauto.
+      rewrite <- in_rev.
+      by apply elements_correct.
+  Qed.
+
+  Lemma gselectspec {A B:Type}
+        (pred:positive -> A -> option B)
+        (m:t A):
+    match select pred m with
+      | Some b =>
+        exists i a, get i m = Some a /\ pred i a = Some b
+      | None =>
+        ~ exists i a, get i m = Some a /\ pred i a <> None
+    end.
+  Proof.
+    destruct (select pred m) eqn:H.
+    - by apply gselectf.
+    - by apply gselectnf.
+  Qed.
+
+  (* Arguments empty A : simpl never. *)
+  (* Arguments get {A} i m : simpl never. *)
+  (* Arguments set {A} i v m : simpl never. *)
+  (* Arguments remove {A} i m : simpl never. *)
+
 End PTree.
 
 (** * An implementation of maps over type [positive] *)
diff --git a/lib/sflib.v b/lib/sflib.v
new file mode 100644
index 00000000..5954cecd
--- /dev/null
+++ b/lib/sflib.v
@@ -0,0 +1,1382 @@
+(* *********************************************************************)
+(*                                                                     *)
+(*           Software Foundations Laboratory's Lemmas & Tactic         *)
+(*               based on Viktor and Gil's lemmas & tactic             *)
+(*                                                                     *)
+(* *********************************************************************)
+
+(** This file collects a number of basic lemmas and tactics for better
+    proof automation, structuring large proofs, or rewriting.  Most of 
+    the rewriting support is ported from ssreflect. *)
+
+(** Symbols starting with [sflib__] are internal. *)
+
+Require Import Bool List Arith ZArith String Program.
+(* Require Export paconotation newtac. *)
+
+Set Implicit Arguments.
+
+Hint Unfold not iff id.
+
+Export ListNotations.
+
+(* Notation "~ x" := (forall (FH: x), False) : type_scope. *)
+
+(* Function composition *)
+Notation "f <*> g" := (compose f g) (at level 49, left associativity).
+
+(* ************************************************************************** *)
+(** * Coersion of [bool] into [Prop] *)
+(* ************************************************************************** *)
+
+(** Coersion of bools into Prop *)
+Coercion is_true (b : bool) : Prop := b = true.
+
+(** Hints for auto *)
+Lemma sflib__true_is_true : true.
+Proof. reflexivity. Qed.
+
+Lemma sflib__not_false_is_true : ~ false.
+Proof. discriminate. Qed.
+
+Lemma sflib__negb_rewrite: forall {b}, negb b -> b = false.
+Proof. intros []; (reflexivity || discriminate). Qed.
+
+Lemma sflib__andb_split: forall {b1 b2}, b1 && b2 -> b1 /\ b2.
+Proof. intros [] []; try discriminate; auto. Qed.
+
+Hint Resolve sflib__true_is_true sflib__not_false_is_true.
+
+(* ************************************************************************** *)
+(** * Basic automation tactics *)
+(* ************************************************************************** *)
+
+(** Set up for basic simplification *)
+
+Create HintDb sflib discriminated. 
+
+(** Adaptation of the ss-reflect "[done]" tactic. *)
+
+Ltac sflib__basic_done := 
+  solve [trivial with sflib | apply sym_equal; trivial | discriminate | contradiction].
+
+Ltac done := unfold not in *; trivial with sflib; hnf; intros;
+  solve [try sflib__basic_done; split; 
+         try sflib__basic_done; split; 
+         try sflib__basic_done; split; 
+         try sflib__basic_done; split; 
+         try sflib__basic_done; split; sflib__basic_done
+    | match goal with H : _ -> False |- _ => solve [case H; trivial] end].
+
+(** A variant of the ssr "done" tactic that performs "eassumption". *)
+
+Ltac edone := try eassumption; trivial; hnf; intros;
+  solve [try eassumption; try sflib__basic_done; split; 
+         try eassumption; try sflib__basic_done; split; 
+         try eassumption; try sflib__basic_done; split; 
+         try eassumption; try sflib__basic_done; split; 
+         try eassumption; try sflib__basic_done; split;
+         try eassumption; sflib__basic_done
+    | match goal with H : ~ _ |- _ => solve [case H; trivial] end].
+
+Tactic Notation "by"  tactic(tac) := (tac; done).
+Tactic Notation "eby" tactic(tac) := (tac; edone).
+
+Ltac sflib__complaining_inj f H :=
+  let X := fresh in
+  (match goal with | [|- ?P ] => set (X := P) end);
+  injection H;
+  (lazymatch goal with | [ |- f _ = f _ -> _] => fail | _ => idtac end);
+  clear H; intros;
+  subst X;
+  try subst.
+
+Ltac sflib__clarify1 :=
+  try subst;
+  repeat match goal with
+  | [H: is_true (andb _ _) |- _] => case (sflib__andb_split H); clear H; intros ? H
+  | [H: is_true (negb ?x) |- _] => rewrite (sflib__negb_rewrite H) in *
+  | [H: is_true ?x        |- _] => rewrite H in *
+  | [H: ?x = true         |- _] => rewrite H in *
+  | [H: ?x = false        |- _] => rewrite H in *
+  | [H: ?f _             = ?f _             |- _] => sflib__complaining_inj f H
+  | [H: ?f _ _           = ?f _ _           |- _] => sflib__complaining_inj f H
+  | [H: ?f _ _ _         = ?f _ _ _         |- _] => sflib__complaining_inj f H
+  | [H: ?f _ _ _ _       = ?f _ _ _ _       |- _] => sflib__complaining_inj f H
+  | [H: ?f _ _ _ _ _     = ?f _ _ _ _ _     |- _] => sflib__complaining_inj f H
+  | [H: ?f _ _ _ _ _ _   = ?f _ _ _ _ _ _   |- _] => sflib__complaining_inj f H
+  | [H: ?f _ _ _ _ _ _ _ = ?f _ _ _ _ _ _ _ |- _] => sflib__complaining_inj f H
+  end; try done.
+
+(** Perform injections & discriminations on all hypotheses *)
+
+Ltac clarify :=
+  sflib__clarify1;
+  repeat match goal with
+    | H1: ?x = Some _, H2: ?x = None   |- _ => rewrite H2 in H1; sflib__clarify1
+    | H1: ?x = Some _, H2: ?x = Some _ |- _ => rewrite H2 in H1; sflib__clarify1
+  end.
+
+(** Kill simple goals that require up to two econstructor calls. *)
+
+(* from CompCert-2.4/lib/Coqlib.v *)
+Ltac inv H := inversion H; clear H; subst.
+
+Ltac hinv x := move x at bottom; inversion x; clarify.
+
+Tactic Notation "hinv" ident(a) :=
+  (hinv a).
+Tactic Notation "hinv" ident(a) ident(b) :=
+  (hinv a; hinv b).
+Tactic Notation "hinv" ident(a) ident(b) ident(c) :=
+  (hinv a; hinv b c).
+Tactic Notation "hinv" ident(a) ident(b) ident(c) ident(d) := 
+  (hinv a b; hinv c d).
+
+Ltac hinvc x := hinv x; clear x.
+
+Tactic Notation "hinvc" ident(a) :=
+  (hinvc a).
+Tactic Notation "hinvc" ident(a) ident(b) :=
+  (hinvc a; hinvc b).
+Tactic Notation "hinvc" ident(a) ident(b) ident(c) :=
+  (hinvc a; hinvc b c).
+Tactic Notation "hinvc" ident(a) ident(b) ident(c) ident(d) := 
+  (hinvc a b; hinvc c d).
+Tactic Notation "hinvc" ident(a) ident(b) ident(c) ident(d) ident(e) := 
+  (hinvc a b c; hinvc d e).
+
+Ltac simpls  := simpl in *; try done.
+Ltac ins := simpl in *; try done; intros.
+
+Tactic Notation "case_eq" constr(x) := case_eq (x).
+
+Tactic Notation "case_eq" constr(x) "as" simple_intropattern(H) :=
+  destruct x as [] eqn: H; try done.
+
+
+(* ************************************************************************** *)
+(** * Basic simplication tactics *)
+(* ************************************************************************** *)
+
+Ltac sflib__clarsimp1 :=
+  clarify; (autorewrite with sflib in * ); try done;
+  match goal with
+  | [H: is_true ?x |- _] => rewrite H in *; sflib__clarsimp1
+  | [H: ?x = true |- _] => rewrite H in *; sflib__clarsimp1
+  | [H: ?x = false |- _] => rewrite H in *; sflib__clarsimp1
+  | _ => clarify; auto 1 with sflib
+  end.
+
+Ltac clarsimp := intros; simpl in *; sflib__clarsimp1.
+
+Ltac autos   := clarsimp; auto with sflib.
+
+(* hdesH, hdes: more general des *)
+
+Definition  NW A (P: () -> A) : A := P ().
+
+(* Notation "<< x : t >>" := (NW (fun x => (t):Prop)) (at level 80, x ident, no associativity). *)
+Notation "<< x : t >>" := (NW (fun x => (t))) (at level 80, x ident, no associativity).
+Notation "<< t >>" := (NW (fun _ => t)) (at level 79, no associativity).
+Notation "<< t >>" := (NW (fun _ => (t):Prop)) (at level 79, no associativity).
+
+Ltac unnw := unfold NW in *.
+Ltac rednw := red; unnw.
+
+Hint Unfold NW.
+
+Ltac get_concl := lazymatch goal with [ |- ?G ] => G end.
+
+Ltac des1 :=
+  match goal with
+    | H : NW _ |- _ => red in H
+    | H : exists x, NW (fun y => _) |- _ => 
+      let x' := fresh x in let y' := fresh y in destruct H as [x' y']; red in y'
+    | H : exists x, ?p |- _ => 
+      let x' := fresh x in destruct H as [x' H]
+    | H : ?p /\ ?q |- _ => 
+      let x' := match p with | NW (fun z => _) => fresh z | _ => H end in
+      let y' := match q with | NW (fun z => _) => fresh z | _ => fresh H end in
+      destruct H as [x' y'];
+      match p with | NW _ => red in x' | _ => idtac end;
+      match q with | NW _ => red in y' | _ => idtac end
+    | H : ?p <-> ?q |- _ => 
+      let x' := match p with | NW (fun z => _) => fresh z | _ => H end in
+      let y' := match q with | NW (fun z => _) => fresh z | _ => fresh H end in
+      destruct H as [x' y'];
+      match p with | NW _ => unfold NW at 1 in x'; red in y' | _ => idtac end;
+      match q with | NW _ => unfold NW at 1 in y'; red in x' | _ => idtac end
+    | H : ?p \/ ?q |- _ =>
+      let x' := match p with | NW (fun z => _) => fresh z | _ => H end in
+      let y' := match q with | NW (fun z => _) => fresh z | _ => H end in
+      destruct H as [x' | y'];
+      [ match p with | NW _ => red in x' | _ => idtac end
+      | match q with | NW _ => red in y' | _ => idtac end]
+  end.
+
+Ltac des := repeat des1.
+
+Ltac desc :=
+  repeat match goal with
+    | H : exists x, NW (fun y => _) |- _ =>
+      let x' := fresh x in let y' := fresh y in destruct H as [x' y']; red in y'
+    | H : exists x, ?p |- _ =>
+      let x' := fresh x in destruct H as [x' H]
+    | H : ?p /\ ?q |- _ =>
+      let x' := match p with | NW (fun z => _) => fresh z | _ => H end in
+      let y' := match q with | NW (fun z => _) => fresh z | _ => fresh H end in
+      destruct H as [x' y'];
+      match p with | NW _ => red in x' | _ => idtac end;
+      match q with | NW _ => red in y' | _ => idtac end
+    | H : is_true (_ && _) |- _ =>
+          let H' := fresh H in case (sflib__andb_split H); clear H; intros H H'
+    | H : ?x = ?x   |- _ => clear H
+  end.
+
+Ltac nbdes1 :=
+  match goal with
+    | H : NW _ |- _ => red in H
+    | H : exists x, NW (fun y => _) |- _ => 
+      let x' := fresh x in let y' := fresh y in destruct H as [x' y']; red in y'
+    | H : exists x, ?p |- _ => 
+      let x' := fresh x in destruct H as [x' H]
+    | H : ?p /\ ?q |- _ => 
+      let x' := match p with | NW (fun z => _) => fresh z | _ => H end in
+      let y' := match q with | NW (fun z => _) => fresh z | _ => fresh H end in
+      destruct H as [x' y'];
+      match p with | NW _ => red in x' | _ => idtac end;
+      match q with | NW _ => red in y' | _ => idtac end
+    | H : ?p <-> ?q |- _ => 
+      let x' := match p with | NW (fun z => _) => fresh z | _ => H end in
+      let y' := match q with | NW (fun z => _) => fresh z | _ => fresh H end in
+      destruct H as [x' y'];
+      match p with | NW _ => unfold NW at 1 in x'; red in y' | _ => idtac end;
+      match q with | NW _ => unfold NW at 1 in y'; red in x' | _ => idtac end
+    (* | H : ?p \/ ?q |- _ => *)
+    (*   let x' := match p with | NW (fun z => _) => fresh z | _ => H end in *)
+    (*   let y' := match q with | NW (fun z => _) => fresh z | _ => H end in *)
+    (*   destruct H as [x' | y']; *)
+    (*   [ match p with | NW _ => red in x' | _ => idtac end *)
+    (*   | match q with | NW _ => red in y' | _ => idtac end] *)
+  end.
+
+Ltac nbdes := repeat nbdes1.
+Ltac rrnbdes H := move H at bottom; repeat red in H; nbdes.
+
+Ltac forall_split :=
+  let H := fresh "__forall_split__" in first [intro; forall_split; match goal with [H:_|-_] => revert H end | split].
+
+Definition _HID_ (A : Type) (a : A) := a.
+
+Ltac hdesHi H P x y :=
+  let FF := fresh "__hdesfalse__" in 
+  let TMP := fresh "__hdesHi__" in 
+  let P1 := fresh "__hdesHi__" in 
+  let P2 := fresh "__hdesHi__" in 
+    evar (P1 : Prop); evar (P2 : Prop);
+    assert (TMP: False -> P) by
+      (intro FF; forall_split;
+         [ let G := get_concl in set (TMP := G); revert P1; instantiate (1:=G)
+         | let G := get_concl in set (TMP := G); revert P2; instantiate (1:=G) ];
+       destruct FF);
+    try clear TMP; 
+    try (try (match goal with [Def := ?G : _ |- _] =>
+              match Def with P1 =>
+              match goal with [_ : G |- _] => fail 4 end end end);
+         assert (x: P1) by (unfold P1; repeat (let x := fresh "__xhj__" in intro x; specialize (H x)); apply H));
+    try unfold P1 in x; try clear P1;
+    try (try (match goal with [Def := ?G : _ |- _] =>
+              match Def with P2 =>
+              match goal with [_ : G |- _] => fail 4 end end end);
+         assert (y: P2) by (unfold P2; repeat (let x := fresh "__xhj__" in intro x; specialize (H x)); apply H)); 
+    try unfold P2 in y; try clear P2;
+    fold (_HID_ P) in H;
+    try clear H.
+
+Ltac hdesHP H P :=
+  let H' := fresh H in let H'' := fresh H in
+  match P with 
+  | context[ NW (fun x => _) /\ NW (fun y => _) ] => 
+    let x' := fresh x in let y' := fresh y in
+    hdesHi H P x' y'; red in x'; red in y'
+  | context[ NW (fun x => _) /\ _ ] => 
+    let x' := fresh x in
+    hdesHi H P x' H'; red in x'
+  | context[ _ /\ NW (fun y => _) ] => 
+    let y' := fresh y in
+    hdesHi H P H' y'; red in y'
+  | context[ _ /\ _ ] => 
+    hdesHi H P H' H''
+  | context[ NW (fun x => _) <-> NW (fun y => _) ] =>
+    let x' := fresh x in let y' := fresh y in
+    hdesHi H P x' y'; red in x'; red in y'
+  | context[ NW (fun x => _) <-> _ ] => 
+    let x' := fresh x in
+    hdesHi H P x' H'; red in x'
+  | context[ _ <-> NW (fun y => _) ] => 
+    let y' := fresh y in
+    hdesHi H P H' y'; red in y'
+  | context[ _ <-> _ ] => 
+    hdesHi H P H' H''
+  end.
+
+Ltac hdesH H := let P := type of H in hdesHP H P; unfold _HID_ in *.
+
+(*
+(* It works, but too slows *)
+Ltac hdesF P :=
+  match P with
+  | fun _ => _ /\ _ => idtac
+  | fun _ => _ <-> _ => idtac
+  | fun x => forall y : @?ty x, @?f x y =>
+    let P' := eval cbv beta in (fun p : sigT ty => f (projT1 p) (projT2 p)) in
+      hdesF P'
+  end.
+
+Ltac hdes := 
+  repeat match goal with | H : ?P |- _ => hdesF (fun _ : unit => P); hdesHP H P end; 
+  unfold _HID_ in *.
+*)
+
+Ltac hdesF P :=
+  match P with | _ /\ _ => idtac | _ <-> _ => idtac | forall _, _ => 
+  match P with | forall _, _ /\ _ => idtac | forall _, _ <-> _ => idtac | forall _ _, _ => 
+  match P with | forall _ _, _ /\ _ => idtac | forall _ _, _ <-> _ => idtac | forall _ _ _, _ =>
+  match P with | forall _ _ _, _ /\ _ => idtac | forall _ _ _, _ <-> _ => idtac | forall _ _ _ _, _ => 
+  match P with | forall _ _ _ _, _ /\ _ => idtac | forall _ _ _ _, _ <-> _ => idtac | forall _ _ _ _ _, _ =>
+  match P with | forall _ _ _ _ _, _ /\ _ => idtac | forall _ _ _ _ _, _ <-> _ => idtac | forall _ _ _ _ _ _, _ => 
+  match P with | forall _ _ _ _ _ _, _ /\ _ => idtac | forall _ _ _ _ _ _, _ <-> _ => idtac | forall _ _ _ _ _ _ _, _ => 
+  match P with | forall _ _ _ _ _ _ _, _ /\ _ => idtac | forall _ _ _ _ _ _ _, _ <-> _ => idtac | forall _ _ _ _ _ _ _ _, _ => 
+  match P with | forall _ _ _ _ _ _ _ _, _ /\ _ => idtac | forall _ _ _ _ _ _ _ _, _ <-> _ => idtac | forall _ _ _ _ _ _ _ _ _, _ =>
+  match P with | forall _ _ _ _ _ _ _ _ _, _ /\ _ => idtac | forall _ _ _ _ _ _ _ _ _, _ <-> _ => idtac | forall _ _ _ _ _ _ _ _ _ _, _ => 
+  match P with | forall _ _ _ _ _ _ _ _ _ _, _ /\ _ => idtac | forall _ _ _ _ _ _ _ _ _ _, _ <-> _ => idtac | forall _ _ _ _ _ _ _ _ _ _ _, _ => 
+  match P with | forall _ _ _ _ _ _ _ _ _ _ _, _ /\ _ => idtac | forall _ _ _ _ _ _ _ _ _ _ _, _ <-> _ => idtac | forall _ _ _ _ _ _ _ _ _ _ _ _, _ => 
+  match P with | forall _ _ _ _ _ _ _ _ _ _ _ _, _ /\ _ => idtac | forall _ _ _ _ _ _ _ _ _ _ _ _, _ <-> _ => idtac | forall _ _ _ _ _ _ _ _ _ _ _ _ _, _ => 
+  match P with | forall _ _ _ _ _ _ _ _ _ _ _ _ _, _ /\ _ => idtac | forall _ _ _ _ _ _ _ _ _ _ _ _ _, _ <-> _ => idtac | forall _ _ _ _ _ _ _ _ _ _ _ _ _ _, _ => 
+  match P with | forall _ _ _ _ _ _ _ _ _ _ _ _ _ _, _ /\ _ => idtac | forall _ _ _ _ _ _ _ _ _ _ _ _ _ _, _ <-> _ => idtac | forall _ _ _ _ _ _ _ _ _ _ _ _ _ _ _, _ => 
+  match P with | forall _ _ _ _ _ _ _ _ _ _ _ _ _ _ _, _ /\ _ => idtac | forall _ _ _ _ _ _ _ _ _ _ _ _ _ _ _, _ <-> _ => idtac | forall _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _, _ => 
+  match P with | forall _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _, _ /\ _ => idtac | forall _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _, _ <-> _ => idtac | forall _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _, _ => 
+  match P with | forall _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _, _ /\ _ => idtac | forall _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _, _ <-> _ => idtac | forall _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _, _ => 
+  match P with | forall _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _, _ /\ _ => idtac | forall _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _, _ <-> _ => idtac | forall _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _, _ => 
+  match P with | forall _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _, _ /\ _ => idtac | forall _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _, _ <-> _ => idtac | forall _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _, _ => 
+  match P with | forall _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _, _ /\ _ => idtac | forall _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _, _ <-> _ => idtac
+  end end end end end end end end end end end end end end end end end end end end end.
+
+(** Fail if hypothesis [H] doesn't exist. *)
+Ltac check_hyp H := match H with _ => idtac end.
+
+(** Fail if hypothesis [H1] is not [H2]. *)
+Ltac check_equal H1 H2 := match H1 with H2 => idtac end.
+
+Ltac hdes := 
+  repeat match goal with | H : ?P |- _ => hdesF P; hdesHP H P end; 
+  unfold _HID_ in *.
+Ltac rdes H := red in H; des.
+Ltac rrdes H := move H at bottom; repeat red in H; des.
+Ltac rhdes H := red in H; hdes.
+Ltac rrhdes H := check_hyp H; repeat red in H; hdes.
+
+Tactic Notation "rrdes" ident(a) :=
+  (rrdes a).
+Tactic Notation "rrdes" ident(a) ident(b) :=
+  (rrdes a; rrdes b).
+Tactic Notation "rrdes" ident(a) ident(b) ident(c) :=
+  (rrdes a; rrdes b c).
+Tactic Notation "rrdes" ident(a) ident(b) ident(c) ident(d) := 
+  (rrdes a b; rrdes c d).
+
+(** Destruct the condition of an [if] expression occuring in the goal. *)
+Ltac des_if :=
+  match goal with
+    | [ |- context[if ?X then _ else _] ] => destruct X
+  end.
+(* Ltac desE_if := *)
+(*   match goal with *)
+(*     | [ |- context[if ?X then _ else _] ] => let E := fresh X in destruct X eqn:E *)
+(*   end. *)
+
+(** Destruct the condition of an [if] expression occuring in the given hypothesis. *)
+Ltac des_ifH H :=
+  match goal with
+    | [ H' : context[if ?X then _ else _] |- _ ] => check_equal H' H; destruct X
+  end.
+
+(* TODO tactics such as these should always do clean at the end to remove junk like [H : x = x] *)
+Ltac des_ifs :=
+ clarify;
+  repeat 
+    match goal with 
+      | |- context[match ?x with _ => _ end] => 
+        match (type of x) with
+          | { _ } + { _ } => destruct x; clarify
+          | _ => let Heq := fresh "Heq" in destruct x as [] eqn: Heq; clarify
+        end 
+      | H: context[ match ?x with _ => _ end ] |- _ => 
+        match (type of x) with
+          | { _ } + { _ } => destruct x; clarify
+          | _ => let Heq := fresh "Heq" in destruct x as [] eqn: Heq; clarify
+        end 
+    end.
+
+Ltac desf := clarify; des; des_ifs.
+Ltac isd := ins; desf.
+
+(** Create a copy of hypothesis [H]. *)
+Tactic Notation "dup" hyp(H) :=
+  let H' := fresh H in assert (H' := H).
+
+(* (** Call tactic [tac] on a copy of [H]. *) *)
+(* Tactic Notation "dup" hyp(H) tactic(tac) := *)
+(*   let H' := fresh H in assert (H' := H); tac H'. *)
+
+Ltac clarassoc := clarsimp; autorewrite with sflib sflibA in *; try done. 
+
+Ltac sflib__hacksimp1 :=
+   clarsimp;
+   match goal with
+     | H: _ |- _ => solve [rewrite H; clear H; clarsimp
+                         |rewrite <- H; clear H; clarsimp]
+     | _ => solve [f_equal; clarsimp]
+   end.
+
+Ltac hacksimp :=
+   clarsimp;
+   try match goal with
+   | H: _ |- _ => solve [rewrite H; clear H; clarsimp
+                              |rewrite <- H; clear H; clarsimp]
+   | |- context[if ?p then _ else _] => solve [destruct p; sflib__hacksimp1]
+   | _ => solve [f_equal; clarsimp]
+   end.
+
+(* ************************************************************************** *)
+(** * Delineating cases in proofs *)
+(* ************************************************************************** *)
+
+(** Named case tactics (taken from Libtactics) *)
+
+Tactic Notation "assert_eq" ident(x) constr(v) :=
+  let H := fresh in
+  assert (x = v) as H by reflexivity;
+  clear H.
+
+Tactic Notation "Case_aux" ident(x) constr(name) :=
+  first [
+    set (x := name); move x at top
+  | assert_eq x name
+  | fail 1 "because we are working on a different case." ].
+
+Ltac Case name := Case_aux case name.
+Ltac SCase name := Case_aux subcase name.
+Ltac SSCase name := Case_aux subsubcase name.
+Ltac SSSCase name := Case_aux subsubsubcase name.
+Ltac SSSSCase name := Case_aux subsubsubsubcase name.
+
+(** Lightweight case tactics (without names) *)
+
+Tactic Notation "-" tactic(c) :=
+  first [
+    assert (WithinCaseM := True); move WithinCaseM at top
+  | fail 1 "because we are working on a different case." ]; c.
+
+Tactic Notation "+" tactic(c) :=
+  first [
+    assert (WithinCaseP := True); move WithinCaseP at top
+  | fail 1 "because we are working on a different case." ]; c.
+
+Tactic Notation "*" tactic(c) :=
+  first [
+    assert (WithinCaseS := True); move WithinCaseS at top
+  | fail 1 "because we are working on a different case." ]; c.
+
+Tactic Notation ":" tactic(c) :=
+  first [
+    assert (WithinCaseC := True); move WithinCaseC at top
+  | fail 1 "because we are working on a different case." ]; c.
+
+(* ************************************************************************** *)
+(** * Exploiting a hypothesis *)
+(* ************************************************************************** *)
+
+(** Exploit an assumption (adapted from CompCert). *)
+
+(* commented because of connflict with compcert's exploit *)
+(* Ltac exploit x := *)
+(*     refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _ _) _) *)
+(*  || refine ((fun x y => y x) (x _ _) _) *)
+(*  || refine ((fun x y => y x) (x _) _). *)
+
+(* When 'exploit x' generates too many sub goals, try 'hexploit x' *)
+
+Lemma mp: forall P Q: Type, P -> (P -> Q) -> Q.
+Proof. intuition. Defined.
+
+Lemma mp': forall P Q : Type, (P -> Q) -> P -> Q.
+Proof. intuition. Qed.
+
+Ltac hexploit x := eapply mp; [eapply x|].
+Ltac hexploit' x := let H := fresh in set (H := x); clear H; eapply mp; [eapply x|].
+
+(* set_prop N T A performs 'assert (A : P); [|set (N := T A)]' when T is a term of type (P -> _) *)
+
+Ltac set_prop N T A := 
+  let b := fresh in let ty := type of T in
+  match ty with (forall (_:?P), _) => assert (A: P); [|set (N := T A)] end.
+
+(* ************************************************************************** *)
+(** * Induction tactics *)
+(* ************************************************************************** *)
+
+Tactic Notation "induction" "[" ident_list(y) "]" ident(x)  :=
+  first [ try (intros until x); revert y; induction x
+        | red; try (intros until x); revert y; induction x ].
+
+Tactic Notation "induction" "[" ident_list(y) "]" ident(x) "[" ident(z) "]"  :=
+  first [ try (intros until x); revert y; induction x; destruct z
+        | red; try (intros until x); revert y; induction x; destruct z ].
+
+(** Versions with hacksimp *)
+
+Tactic Notation "induct" ident(x) := induction x; hacksimp.
+
+Tactic Notation "induct" ident(x) "[" ident(z) "]" := 
+  induction x; destruct z; hacksimp.
+
+Tactic Notation "induct" "[" ident_list(y) "]" ident(x)  :=
+  first [ try (intros until x); revert y; induction x; hacksimp
+        | red; try (intros until x); revert y; induction x; hacksimp ].
+
+Tactic Notation "induct" "[" ident_list(y) "]" ident(x) "[" ident(z) "]"  :=
+  first [ try (intros until x); revert y; induction x; destruct z; hacksimp
+        | red; try (intros until x); revert y; induction x; destruct z; hacksimp ].
+
+Tactic Notation "edestructs" ident(a) := 
+  (edestruct a).
+Tactic Notation "edestructs" ident(a) ident(b) := 
+  (edestruct a; edestruct b).
+Tactic Notation "edestructs" ident(a) ident(b) ident(c) := 
+  (edestruct a; edestructs b c).
+Tactic Notation "edestructs" ident(a) ident(b) ident(c) ident(d) := 
+  (edestruct a; edestructs b c d).
+Tactic Notation "edestructs" ident(a) ident(b) ident(c) ident(d) ident(e) := 
+  (edestruct a; edestructs b c d e).
+Tactic Notation "edestructs" ident(a) ident(b) ident(c) ident(d) ident(e) ident(f) :=
+  (edestruct a; edestructs b c d e f).
+Tactic Notation "edestructs" ident(a) ident(b) ident(c) ident(d) ident(e) ident(f) ident(g) := 
+  (edestruct a; edestructs b c d e f g).
+Tactic Notation "edestructs" ident(a) ident(b) ident(c) ident(d) ident(e) ident(f) ident(g) ident(h) :=
+  (edestruct a; edestructs b c d e f g h).
+Tactic Notation "edestructs" ident(a) ident(b) ident(c) ident(d) ident(e) ident(f) ident(g) ident(h) ident(i) := 
+  (edestruct a; edestructs b c d e f g h i).
+Tactic Notation "edestructs" ident(a) ident(b) ident(c) ident(d) ident(e) ident(f) ident(g) ident(h) ident(i) ident(j) := 
+  (edestruct a; edestructs b c d e f g h i j).
+
+Tactic Notation "destructs" ident(a) :=
+  (destruct a).
+Tactic Notation "destructs" ident(a) ident(b) := 
+  (destruct a; destruct b).
+Tactic Notation "destructs" ident(a) ident(b) ident(c) := 
+  (destruct a; destructs b c).
+Tactic Notation "destructs" ident(a) ident(b) ident(c) ident(d) :=
+  (destruct a; destructs b c d).
+Tactic Notation "destructs" ident(a) ident(b) ident(c) ident(d) ident(e) :=
+  (destruct a; destructs b c d e).
+Tactic Notation "destructs" ident(a) ident(b) ident(c) ident(d) ident(e) ident(f) :=
+  (destruct a; destructs b c d e f).
+Tactic Notation "destructs" ident(a) ident(b) ident(c) ident(d) ident(e) ident(f) ident(g) :=
+  (destruct a; destructs b c d e f g).
+Tactic Notation "destructs" ident(a) ident(b) ident(c) ident(d) ident(e) ident(f) ident(g) ident(h) := 
+  (destruct a; destructs b c d e f g h).
+Tactic Notation "destructs" ident(a) ident(b) ident(c) ident(d) ident(e) ident(f) ident(g) ident(h) ident(i) := 
+  (destruct a; destructs b c d e f g h i).
+Tactic Notation "destructs" ident(a) ident(b) ident(c) ident(d) ident(e) ident(f) ident(g) ident(h) ident(i) ident(j) := 
+  (destruct a; destructs b c d e f g h i j).
+
+Tactic Notation "depdes" ident(_something_which_shold_not_occur_in_the_goal_) :=
+  (let _x_ := type of _something_which_shold_not_occur_in_the_goal_ 
+   in dependent destruction _something_which_shold_not_occur_in_the_goal_).
+Tactic Notation "depdes" ident(a) ident(b) := 
+  (depdes a; depdes b).
+Tactic Notation "depdes" ident(a) ident(b) ident(c) := 
+  (depdes a; depdes b c).
+Tactic Notation "depdes" ident(a) ident(b) ident(c) ident(d) :=
+  (depdes a; depdes b c d).
+Tactic Notation "depdes" ident(a) ident(b) ident(c) ident(d) ident(e) :=
+  (depdes a; depdes b c d e).
+Tactic Notation "depdes" ident(a) ident(b) ident(c) ident(d) ident(e) ident(f) :=
+  (depdes a; depdes b c d e f).
+Tactic Notation "depdes" ident(a) ident(b) ident(c) ident(d) ident(e) ident(f) ident(g) :=
+  (depdes a; depdes b c d e f g).
+Tactic Notation "depdes" ident(a) ident(b) ident(c) ident(d) ident(e) ident(f) ident(g) ident(h) := 
+  (depdes a; depdes b c d e f g h).
+Tactic Notation "depdes" ident(a) ident(b) ident(c) ident(d) ident(e) ident(f) ident(g) ident(h) ident(i) := 
+  (depdes a; depdes b c d e f g h i).
+Tactic Notation "depdes" ident(a) ident(b) ident(c) ident(d) ident(e) ident(f) ident(g) ident(h) ident(i) ident(j) := 
+  (depdes a; depdes b c d e f g h i j).
+
+Tactic Notation "depgen" ident(x) := generalize dependent x.
+
+(* eappleft, eappright *)
+
+Ltac eappleft H :=
+  let X := fresh "__lem__" in let X1 := fresh "__lem__" in let X2 := fresh "__lem__" in
+  assert (X:= H); let P := type of X in hdesHi X P X1 X2;
+  eapply X1; clear X1 X2.
+
+Ltac eappright H :=
+  let X := fresh "__lem__" in let X1 := fresh "__lem__" in let X2 := fresh "__lem__" in
+  assert (X:= H); let P := type of X in hdesHi X P X1 X2;
+  eapply X2; clear X1 X2.
+
+(* guard for simpl *)
+
+(* for Coq8.4 *)
+
+Definition __guard__ A (a : A) : A := a.
+Definition __GUARD__ A (a : A) : A := a.
+Arguments __guard__ A a : simpl never.
+Arguments __GUARD__ A a : simpl never.
+
+Tactic Notation "guard" constr(t) "in" hyp(H) := fold (__guard__ t) in H.
+Tactic Notation "guardH" hyp(H) := let t := type of H in guard t in H.
+Tactic Notation "guard" :=  
+  repeat match goal with [H: ?P |- _] =>
+    try (match P with __guard__ _ => fail 2 end); guardH H
+  end.
+Tactic Notation "sguard" constr(t) "in" hyp(H) := fold (__GUARD__ t) in H.
+Tactic Notation "sguard" "in" hyp(H) := let t := type of H in sguard t in H.
+
+Ltac unguard := unfold __guard__ in *.
+Ltac unguardH H := unfold __guard__ in H.
+Ltac unsguard H := unfold __GUARD__ in H.
+
+Ltac desH H := guard; unguardH H; des; unguard.
+
+Ltac splits :=
+  intros; unfold NW;
+  repeat match goal with 
+  | [ |- _ /\ _ ] => split
+  end.
+Ltac esplits :=
+  intros; unfold NW;
+  repeat match goal with 
+  | [ |- @ex _ _ ] => eexists
+  | [ |- _ /\ _ ] => split
+  | [ |- @sig _ _ ] => eexists
+  | [ |- @sigT _ _ ] => eexists
+  | [ |- @prod _  _ ] => split
+  end.
+
+Tactic Notation "replace_all" constr(e) := repeat (
+  let X := fresh in assert (X: e) by (clarify; eauto; done); 
+  first [rewrite !X | setoid_rewrite X]; clear X).
+
+Lemma all_conj_dist: forall A (P Q: A -> Prop), 
+  (forall a, P a /\ Q a) -> (forall a, P a) /\ (forall a, Q a).
+Proof. intros; hdes; eauto. Qed.
+
+(* extensionalities *)
+
+Tactic Notation "extensionalities" :=
+  repeat let x := fresh in extensionality x.
+Tactic Notation "extensionalities" ident(a) :=
+  (extensionality a).
+Tactic Notation "extensionalities" ident(a) ident(b) :=
+  (extensionality a; extensionality b).
+Tactic Notation "extensionalities" ident(a) ident(b) ident(c) :=
+  (extensionality a; extensionalities b c).
+Tactic Notation "extensionalities" ident(a) ident(b) ident(c) ident(d) :=
+  (extensionality a; extensionalities b c d).
+Tactic Notation "extensionalities" ident(a) ident(b) ident(c) ident(d) ident(e) :=
+  (extensionality a; extensionalities b c d e).
+Tactic Notation "extensionalities" ident(a) ident(b) ident(c) ident(d) ident(e) ident(f) :=
+  (extensionality a; extensionalities b c d e f).
+
+(* short for common tactics *)
+
+Tactic Notation "inst" := instantiate.
+Tactic Notation "econs" := econstructor.
+Tactic Notation "econs" int_or_var(x) := econstructor x.
+Tactic Notation "i" := intros.
+Tactic Notation "ii" := repeat intro.
+Tactic Notation "s" := simpl.
+Tactic Notation "s" ident(a) := simpl a.
+Tactic Notation "s" constr(t) := simpl t.
+Tactic Notation "s" "in" hyp(H) := simpl in H.
+Tactic Notation "ss" := simpls.
+Tactic Notation "r" := red.
+Tactic Notation "r" "in" hyp(H) := red in H.
+Tactic Notation "rr" := repeat red.
+Tactic Notation "rr" "in" hyp(H) := repeat red in H.
+
+(* running a tactic selectively on subgoals *)
+
+Definition __mark__ A (a : A) : A := a.
+
+Tactic Notation "M" := 
+  match goal with [|-?G] => fold (__mark__ G) end.
+
+Tactic Notation "Mdo" tactic(tac) :=
+  first [ try match goal with [|- __mark__ _ ] => fail 2 end | unfold __mark__; tac ].
+
+Tactic Notation "Mskip" tactic(tac) :=
+  first [ match goal with [|- __mark__ _ ] => unfold __mark__ end | tac ].
+
+Tactic Notation "Mfirst" tactic(main) ";;" tactic(post) := 
+   main; (Mdo (post; M)); (Mskip post).
+
+(* revert until *)
+
+Ltac on_last_hyp tac :=
+  match goal with [ H : _ |- _ ] => first [ tac H | fail 1 ] end.
+
+Ltac revert_until id :=
+  on_last_hyp ltac:(fun id' =>
+    match id' with
+      | id => idtac
+      | _ => revert id' ; revert_until id
+    end).
+
+Open Scope string_scope.
+Open Scope list_scope.
+
+Fixpoint beq_str (s1 s2: string) : bool := 
+  match s1, s2 with
+  | "", "" => true
+  | String a s1', String b s2' => if Ascii.ascii_dec a b then beq_str s1' s2' else false
+  | _, _ => false
+  end.
+
+Ltac uf := (autounfold with * in *).
+
+Tactic Notation "patout" constr(z) "in" hyp(a) :=
+  pattern z in a; match goal with [a:=?f z|-_] => unfold a; clear a; set (a:=f) end.
+
+Ltac clear_upto H :=
+  repeat (match goal with [Hcrr : _ |- _ ] => first [ check_equal Hcrr H; fail 2
+ | clear Hcrr ] end).
+
+Definition _Evar_sflib_ (A:Type) (x:A) := x.
+
+Tactic Notation "hide_evar" int_or_var(n) := let QQ := fresh "QQ" in
+  hget_evar n; intro;
+  lazymatch goal with [ H := ?X |- _] => 
+    set (QQ := X) in *; fold (_Evar_sflib_ X) in QQ; clear H 
+  end.
+
+Ltac hide_evars := repeat (hide_evar 1).
+
+Ltac show_evars := repeat (match goal with [ H := @_Evar_sflib_ _ _ |- _ ] => unfold
+ _Evar_sflib_ in H; unfold H in *; clear H end).
+
+Ltac revert1 := match goal with [H: _|-_] => revert H end.
+
+Lemma eqimpl: forall P Q : Prop, P = Q -> P -> Q. 
+Proof. by i; subst; auto. Qed.
+
+Ltac ginduction H :=
+  move H at top; revert_until H; induction H.
+
+Tactic Notation "greflgen" constr(t) "as" ident(g)  := 
+  let EQ := fresh "XEQ" in
+  generalize (eq_refl t); generalize t at -2 as g
+  ; intros ? EQ ?; revert EQ.
+
+
+Ltac special H :=
+  (* eapply mp; refine (H _). *)
+  match type of H with
+    | ?A -> ?B =>
+      let a := fresh in assert (a: A); [|specialize (H a)]
+  end.
+
+(** Useful for e.g. [ex @nil]. *)
+Ltac ex x := eapply (ex_intro _ (x _)).
+
+Ltac inst_pairs :=
+  repeat first
+    [instantiate (9 := (_, _))
+    |instantiate (8 := (_, _))
+    |instantiate (7 := (_, _))
+    |instantiate (6 := (_, _))
+    |instantiate (5 := (_, _))
+    |instantiate (4 := (_, _))
+    |instantiate (3 := (_, _))
+    |instantiate (2 := (_, _))
+    |instantiate (1 := (_, _))].
+
+(* Problem: unfold fst doesn't always result in a lambda *)
+(* Ltac fold_proj := *)
+(*   try match goal with |- context[fun _ : ?A * ?B => _] => *)
+(*     first [fold (@fst A B) | fold (@snd A B)]; fail *)
+(*   end. *)
+(* Ltac fold_projH H := *)
+(*   match type of H with | context[fun _ : ?A * ?B => _] => *)
+(*     first [fold (@fst A B) in H | fold (@snd A B) in H]; fail *)
+(*   end. *)
+(* Ltac simpl_proj := *)
+(*   unfold fst in *; Hdo fold_projH; fold_proj. *)
+
+(* Lemma simpl_fst: forall A (a: A) B (b: B), *)
+(*   fst (a, b) = a. *)
+(* Proof. *)
+(*   auto. *)
+(* Qed. *)
+
+(* Lemma simpl_snd: forall B (b: B) A (a: A), *)
+(*   snd (a, b) = b. *)
+(* Proof. *)
+(*   auto. *)
+(* Qed. *)
+
+Ltac simpl_proj :=
+  do 5 (simpl (fst (_, _)) in *; simpl (snd (_, _)) in *).
+  (* ; repeat first [rewrite !simpl_fst | rewrite !simpl_snd] *)
+  (* ; Hdo (fun H => repeat first [rewrite !simpl_fst in H | rewrite !simpl_snd in H]). *)
+
+Ltac clean :=
+  repeat match goal with
+    | H: True |- _
+      => clear H
+    | H: ?x = ?y |- _
+      => try (has_evar x; fail 2); try (has_evar y; fail 2);
+         change x with y in H; clear H
+  end
+  ; simpl_proj.
+  (* without the evar check, clean removes equations such as the following:
+     X : length (getVal ?28711 ?28712 ?28713 ?28714) = S n *)
+
+
+Tactic Notation "lhs" tactic(tac) :=
+  match goal with |- ?op ?lhs ?rhs =>
+    let tmp := fresh in set (tmp := rhs); tac; unfold tmp; clear tmp
+  end.
+
+(* Variant of lhs that allows prover to combine lhs/rhs tactics in
+ * tacticals. For example:
+ * lhs (rewrite blah); rhs (rewrite blah).
+ * is allowed. lhs fails because the precedence for the tactic
+ * was higher than the ";" and so tac = rewrite blah; rhs (rewrite blah).
+ * TODO: Check whether it's safe to override the definition of lhs/rhs.
+ *)
+Tactic Notation "lhs3" tactic3(tac) :=
+  match goal with |- ?op ?lhs ?rhs =>
+    let tmp := fresh in set (tmp := rhs); tac; unfold tmp; clear tmp
+  end.
+
+Tactic Notation "rhs" tactic(tac) :=
+  match goal with |- ?op ?lhs ?rhs =>
+    let tmp := fresh in set (tmp := lhs); tac; unfold tmp; clear tmp
+  end.
+
+(* See the comment for lhs3. *)
+Tactic Notation "rhs3" tactic3(tac) :=
+  match goal with |- ?op ?lhs ?rhs =>
+    let tmp := fresh in set (tmp := lhs); tac; unfold tmp; clear tmp
+  end.
+
+
+(* TODO generalize to hyps *)
+
+
+(** Execute a tactic only if the goal contains no evars. *)
+Tactic Notation "safe" tactic(tac) :=
+  try match goal with |- ?G => try (has_evar G; fail 2); tac end.
+
+
+(** Rename a hypothesis to a fresh name. *)
+Ltac ren H :=
+  let X := fresh H in rename H into X.
+
+(* (** Instantiate consecutive evars. *) *)
+(* Tactic Notation "insts" constr(terms) := *)
+(*   Hdo (fun x => instantiate (1 := x)) terms. *)
+(* (* TODO this is not very useful after all *) *)
+
+
+
+(** Automation using econstructor.
+    What it does is clear from the definition below. *)
+Tactic Notation "econsby" tactic(tac) :=
+  first [econstructor  1; (by tac)
+        |econstructor  2; (by tac)
+        |econstructor  3; (by tac)
+        |econstructor  4; (by tac)
+        |econstructor  5; (by tac)
+        |econstructor  6; (by tac)
+        |econstructor  7; (by tac)
+        |econstructor  8; (by tac)
+        |econstructor  9; (by tac)
+        |econstructor 10; (by tac)
+        |econstructor 11; (by tac)
+        |econstructor 12; (by tac)
+        |econstructor 13; (by tac)
+        |econstructor 14; (by tac)
+        |econstructor 15; (by tac)
+        |econstructor 16; (by tac)
+        |econstructor 17; (by tac)
+        |econstructor 18; (by tac)
+        |econstructor 19; (by tac)
+        |econstructor 20; (by tac)
+  ].
+
+
+
+Lemma f_equal6 (A1 A2 A3 A4 A5 A6 B: Type) (f: A1 -> A2 -> A3 -> A4 -> A5 -> A6 -> B)
+      (x1 y1: A1) (EQ1: x1 = y1)
+      (x2 y2: A2) (EQ2: x2 = y2)
+      (x3 y3: A3) (EQ3: x3 = y3)
+      (x4 y4: A4) (EQ4: x4 = y4)
+      (x5 y5: A5) (EQ5: x5 = y5)
+      (x6 y6: A6) (EQ6: x6 = y6)
+  :
+    <<EQ: f x1 x2 x3 x4 x5 x6 = f y1 y2 y3 y4 y5 y6>>
+.
+Proof. subst. reflexivity. Qed.
+
+Lemma f_equal7 (A1 A2 A3 A4 A5 A6 A7 B: Type) (f: A1 -> A2 -> A3 -> A4 -> A5 -> A6 -> A7 -> B)
+      (x1 y1: A1) (EQ1: x1 = y1)
+      (x2 y2: A2) (EQ2: x2 = y2)
+      (x3 y3: A3) (EQ3: x3 = y3)
+      (x4 y4: A4) (EQ4: x4 = y4)
+      (x5 y5: A5) (EQ5: x5 = y5)
+      (x6 y6: A6) (EQ6: x6 = y6)
+      (x7 y7: A7) (EQ7: x7 = y7)
+  :
+    <<EQ: f x1 x2 x3 x4 x5 x6 x7 = f y1 y2 y3 y4 y5 y6 y7>>
+.
+Proof. subst. reflexivity. Qed.
+
+Lemma f_equal8 (A1 A2 A3 A4 A5 A6 A7 A8 B: Type) (f: A1 -> A2 -> A3 -> A4 -> A5 -> A6 -> A7 -> A8 -> B)
+      (x1 y1: A1) (EQ1: x1 = y1)
+      (x2 y2: A2) (EQ2: x2 = y2)
+      (x3 y3: A3) (EQ3: x3 = y3)
+      (x4 y4: A4) (EQ4: x4 = y4)
+      (x5 y5: A5) (EQ5: x5 = y5)
+      (x6 y6: A6) (EQ6: x6 = y6)
+      (x7 y7: A7) (EQ7: x7 = y7)
+      (x8 y8: A8) (EQ8: x8 = y8)
+  :
+    <<EQ: f x1 x2 x3 x4 x5 x6 x7 x8 = f y1 y2 y3 y4 y5 y6 y7 y8>>
+.
+Proof. subst. reflexivity. Qed.
+
+Ltac rpapply_raw H :=
+  first[erewrite f_equal8 | erewrite f_equal7 | erewrite f_equal6 | erewrite f_equal5 |
+        erewrite f_equal4 | erewrite f_equal3 | erewrite f_equal2 | erewrite f_equal];
+  [eapply H|..]; try reflexivity.
+
+Ltac is_applied_function TARGET :=
+  match TARGET with
+  | ?f ?x =>
+    idtac
+  | _ => fail
+  end
+.
+
+Ltac has_inside_strict A B :=
+  match A with
+  | context[B] => tryif (check_equal A B) then fail else idtac
+  | _ => fail
+  end
+.
+
+Ltac is_inside_others_body TARGET :=
+  tryif (repeat multimatch goal with
+                | [ |- context[?f ?x] ] =>
+                  (* idtac f; idtac x; *)
+                  tryif (has_inside_strict x TARGET)
+                  then fail 2
+                  else fail
+                end)
+  then fail
+  else idtac
+.
+
+Ltac on_leftest_function TAC :=
+  (* repeat *)
+  multimatch goal with
+  | [ |- context[?f ?x] ] =>
+    tryif (is_applied_function f)
+    then fail
+    else
+      tryif (is_inside_others_body f)
+      then fail
+      else TAC f
+  (* else TAC constr:(f) *)
+  (* TODO: What is the difference? *)
+  end
+.
+(* TODO: more cannonical way to get leftest function? *)
+(* I tried match reverse but it was not good *)
+(* TODO: I want to define "get_leftest_function" *)
+(* TODO: try tactic notation ? *)
+
+Ltac leftest_rpapply H :=
+  on_leftest_function ltac:(fun f =>
+     (idtac f; first
+                 (* TODO: why rewrite "with" doesn't work? *)
+                 [ erewrite (f_equal8 f)
+                 | erewrite (f_equal7 f)
+                 | erewrite (f_equal6 f)
+                 | erewrite (f_equal5 f)
+                 | erewrite (f_equal4 f)
+                 | erewrite (f_equal3 f)
+                 | erewrite (f_equal2 f)
+                 | erewrite (f_equal  f) | fail]); [ eapply H | .. ]; try reflexivity)
+.
+
+
+
+
+
+Ltac is_type x :=
+     match type of x with
+     | Type => idtac
+     | Set => idtac
+     | Prop => idtac (* TODO: needed? *)
+     | _ => fail
+     end.
+
+Ltac is_term_applied_function TARGET :=
+  match TARGET with
+  | ?f ?x =>
+    tryif (is_type x) then fail else idtac
+  | _ => fail
+  end
+.
+
+Ltac on_leftest_function_with_type TAC :=
+  (* repeat *)
+  multimatch goal with
+  | [ |- context[?f ?x] ] =>
+    tryif (is_term_applied_function f)
+    then fail
+    else
+      tryif (is_inside_others_body f)
+      then fail
+      else TAC f
+  end
+.
+
+Ltac rpapply H :=
+  on_leftest_function_with_type ltac:(fun f =>
+     (idtac f; first
+                 (* TODO: why rewrite "with" doesn't work? *)
+                 [ erewrite (f_equal8 f)
+                 | erewrite (f_equal7 f)
+                 | erewrite (f_equal6 f)
+                 | erewrite (f_equal5 f)
+                 | erewrite (f_equal4 f)
+                 | erewrite (f_equal3 f)
+                 | erewrite (f_equal2 f)
+                 | erewrite (f_equal  f) | fail]); [ eapply H | .. ]; try reflexivity)
+.
+
+
+
+(* it may run infinite loop *)
+Ltac all TAC :=
+  repeat multimatch goal with
+         | H: _ |- _ => TAC H
+         end;
+  try TAC
+.
+
+Ltac fold_in x H := fold x in H; fold x.
+
+Ltac fold_all x := all ltac:(fold_in x).
+
+Ltac clears x :=
+  repeat match goal with
+         | H: context[x] |- _ => clear H
+         | |- context[x] => fail 2 "It appears in the goal!"
+         end
+.
+
+
+
+Ltac hide_goal :=
+  match goal with
+  | [ |- ?G ] => let name := fresh "HIDDEN_GOAL" in
+                 set (name := G); replace G with name by reflexivity
+  (* ; move name at top <---- it breaks "unhide (hide X) = X". User may do it manually *)
+  end.
+Ltac unhide_goal :=
+  match goal with
+  | [ |- ?G ] => subst G
+  end.
+Ltac is_local_definition X :=
+  hide_goal;
+  tryif (unfold X)
+  then (unhide_goal)
+  else (unhide_goal; fail)
+.
+Ltac negate TAC := tryif TAC then fail else idtac.
+Ltac clear_unused :=
+  repeat multimatch goal with
+         | [H: ?T |- _] =>
+           negate ltac:(is_local_definition H);
+           match (type of T) with
+           | Prop => idtac
+           | _ => try clear H
+           end
+         end
+.
+Goal let x := 0 in forall n: nat, False.
+Proof.
+  intros.
+  clear_unused.
+Abort.
+
+(* TODO: Currently I use "is_local_definition" filter, but it may replaced with checking if it is Prop *)
+Ltac clear_tautology :=
+  repeat multimatch goal with
+         | [H: ?A = ?B, H2: ?B = ?A |- _] => clear H2
+         (* | [H: True |- _] => clear H *) (* clear_universal_truth takes care of this now *)
+         | [H: ?X, H2: ?X |- _] =>
+           negate ltac:(is_local_definition H2);
+           clear H2
+         (* | [H: ?A = ?A |- _] => clear H *) (* clear_universal_truth takes care of this now *)
+         end
+.
+
+Ltac clear_reducible_truth :=
+  let smart_tac := ss in
+  repeat multimatch goal with
+         | [H: ?P |- _ ] =>
+           match (type of P) with
+           | Prop =>
+             let temp := fresh "temp" in
+             tryif assert(temp: P) by (clear H; smart_tac)
+             (* check if it is reducible from other premises *)
+             then clear temp; clear H
+             else idtac
+           | _ => idtac
+           end
+         end
+.
+
+Ltac clear_universal_truth :=
+  let smart_tac := ss in
+  repeat multimatch goal with
+         | [H: ?P |- _ ] =>
+           match (type of P) with
+           | Prop =>
+             let temp := fresh "temp" in
+             tryif assert(temp: P) by (all clear; smart_tac)
+             (* check if it is reducible without any premise *)
+             then clear temp; clear H
+             else idtac
+           | _ => idtac
+           end
+         end
+.
+
+Ltac clear_tac := repeat (clear_unused; clear_tautology; clear_universal_truth).
+
+Ltac des_ifs_safe_aux TAC :=
+  TAC;
+  repeat
+    multimatch goal with
+    | |- context[match ?x with _ => _ end] =>
+      match (type of x) with
+      | { _ } + { _ } => destruct x; TAC; []
+      | _ => let Heq := fresh "Heq" in destruct x as [] eqn: Heq; TAC; []
+      end
+    | H: context[ match ?x with _ => _ end ] |- _ =>
+      match (type of x) with
+      | { _ } + { _ } => destruct x; TAC; []
+      | _ => let Heq := fresh "Heq" in destruct x as [] eqn: Heq; TAC; []
+      end
+    end.
+Tactic Notation "des_ifs_safe" := des_ifs_safe_aux clarify.
+Tactic Notation "des_ifs_safe" tactic(TAC) := des_ifs_safe_aux TAC.
+
+Ltac abstr_aux x var_name :=
+  let hyp_name := fresh "abstr_hyp_name" in
+  remember x as var_name eqn:hyp_name; clear hyp_name
+.
+
+Tactic Notation "abstr" constr(H) := let var_name := fresh "abstr_var_name" in abstr_aux H var_name.
+Tactic Notation "abstr" constr(H) ident(var_name) := abstr_aux H var_name.
+
+Hint Rewrite
+     andb_true_iff andb_false_iff
+     orb_true_iff orb_false_iff
+     negb_true_iff negb_false_iff
+
+     andb_true_r andb_true_l andb_false_r andb_false_l
+     orb_true_r orb_true_l orb_false_r orb_false_l
+     negb_andb negb_orb negb_involutive
+  : simpl_bool.
+
+Ltac simpl_bool := unfold Datatypes.is_true; unfold is_true;  autorewrite with simpl_bool in *.
+
+Ltac des_safe_aux TAC :=
+  TAC;
+  repeat (des1; TAC; [])
+.
+
+Tactic Notation "des_safe" := des_safe_aux clarify.
+Tactic Notation "des_safe" tactic(TAC) := des_safe_aux TAC.
+
+
+(* Copied from SoftwareFoundations - LibTactics.v *)
+(* ---------------------------------------------------------------------- *)
+(** ** Generalization *)
+
+(** [gen X1 .. XN] is a shorthand for calling [generalize dependent]
+    successively on variables [XN]...[X1]. Note that the variables
+    are generalized in reverse order, following the convention of
+    the [generalize] tactic: it means that [X1] will be the first
+    quantified variable in the resulting goal. *)
+
+Tactic Notation "gen" ident(X1) :=
+  generalize dependent X1.
+Tactic Notation "gen" ident(X1) ident(X2) :=
+  gen X2; gen X1.
+Tactic Notation "gen" ident(X1) ident(X2) ident(X3) :=
+  gen X3; gen X2; gen X1.
+Tactic Notation "gen" ident(X1) ident(X2) ident(X3) ident(X4)  :=
+  gen X4; gen X3; gen X2; gen X1.
+Tactic Notation "gen" ident(X1) ident(X2) ident(X3) ident(X4) ident(X5) :=
+  gen X5; gen X4; gen X3; gen X2; gen X1.
+Tactic Notation "gen" ident(X1) ident(X2) ident(X3) ident(X4) ident(X5)
+ ident(X6) :=
+  gen X6; gen X5; gen X4; gen X3; gen X2; gen X1.
+Tactic Notation "gen" ident(X1) ident(X2) ident(X3) ident(X4) ident(X5)
+ ident(X6) ident(X7) :=
+  gen X7; gen X6; gen X5; gen X4; gen X3; gen X2; gen X1.
+Tactic Notation "gen" ident(X1) ident(X2) ident(X3) ident(X4) ident(X5)
+ ident(X6) ident(X7) ident(X8) :=
+  gen X8; gen X7; gen X6; gen X5; gen X4; gen X3; gen X2; gen X1.
+Tactic Notation "gen" ident(X1) ident(X2) ident(X3) ident(X4) ident(X5)
+ ident(X6) ident(X7) ident(X8) ident(X9) :=
+  gen X9; gen X8; gen X7; gen X6; gen X5; gen X4; gen X3; gen X2; gen X1.
+Tactic Notation "gen" ident(X1) ident(X2) ident(X3) ident(X4) ident(X5)
+ ident(X6) ident(X7) ident(X8) ident(X9) ident(X10) :=
+  gen X10; gen X9; gen X8; gen X7; gen X6; gen X5; gen X4; gen X3; gen X2; gen X1.
+
+(* ---------------------------------------------------------------------- *)
+
+Ltac exists_prop PROP :=
+  tryif
+    (repeat multimatch goal with
+            | [H: PROP |- _ ] => (* idtac "Found!"; idtac H; *) fail 2
+            end)
+  then fail
+  else idtac
+.
+
+Ltac propagate_eq :=
+  repeat (multimatch goal with
+          | [H1: ?A = ?B, H2: ?B = ?C |- _ ] =>
+            tryif (check_equal A C)
+            then fail
+            else
+              tryif (exists_prop (A = C) + exists_prop (C = A))
+              then idtac
+              else
+                let name := fresh "EQ_CLOSURE_TAC" in
+                hexploit eq_trans; [exact H1|exact H2|]; intro name
+          | [H1: ?B = ?A, H2: ?B = ?C |- _ ] =>
+            tryif (check_equal A C)
+            then fail
+            else
+              tryif (exists_prop (A = C) + exists_prop (C = A))
+              then idtac
+              else
+                let name := fresh "EQ_CLOSURE_TAC" in
+                hexploit eq_trans; [exact (eq_sym H1)|exact H2|]; intro name
+          end)
+.
+
+(* get equality's transitive closure *)
+(* TODO: it checks equality too naive way; "(0, 1).fst != 0" here. *)
+Ltac eq_closure_tac :=
+  repeat (propagate_eq; clarify); clear_tac
+.
+
+Ltac rev_all TAC :=
+  repeat multimatch reverse goal with
+         | H: _ |- _ => TAC H
+         end;
+  try TAC
+.
+
+Require Import Coqlib.
+
+
+Lemma proj_sumbool_false: forall (P Q : Prop) (a : {P} + {Q}),
+    proj_sumbool a = false -> Q.
+Proof. intros. destruct a; auto. inv H. Qed.
+
+Lemma proj_sumbool_is_false
+      P
+      (a: {P} + {~ P})
+      (FALSE: ~ P)
+  :
+    proj_sumbool a = false
+.
+Proof. unfold proj_sumbool. case a; tauto. Qed.
+
+Ltac des_sumbool :=
+  repeat
+    (unfold Datatypes.is_true, is_true in *;
+     match goal with
+     | [ H: proj_sumbool ?x = true |- _ ] => apply proj_sumbool_true in H
+     | [ H: proj_sumbool ?x = false |- _ ] => apply proj_sumbool_false in H
+     | [ H: true = proj_sumbool ?x |- _ ] => symmetry in H; apply proj_sumbool_true in H
+     | [ H: false = proj_sumbool ?x |- _ ] => symmetry in H; apply proj_sumbool_false in H
+
+     | [ |- proj_sumbool ?x = true ] => apply proj_sumbool_is_true
+     | [ |- proj_sumbool ?x = false ] => apply proj_sumbool_is_false
+     | [ |- true = proj_sumbool ?x ] => symmetry; apply proj_sumbool_is_true
+     | [ |- false = proj_sumbool ?x ] => symmetry; apply proj_sumbool_is_false
+     end)
+.
+
+
+Lemma forallb_false_forall {A} f (l: list A) :
+  forallb f l = false <-> ~ (forall x, In x l -> f x = true).
+Proof.
+  split; ii.
+  - clear - H H0. ginduction l; ss; i. rewrite andb_false_iff in H. des.
+    { exploit H0; eauto. i. clarify. }
+    exploit IHl; eauto.
+  - destruct (forallb f l) eqn:FA; auto.
+    rewrite forallb_forall in FA. clarify.
+Qed.
+
diff --git a/midend/CSSA.v b/midend/CSSA.v
index 71bf76a1..ce90bab0 100644
--- a/midend/CSSA.v
+++ b/midend/CSSA.v
@@ -22,6 +22,7 @@ Require Import Relations.Relation_Definitions.
 Require Import DLib.
 Require Import SSA.
 Require Import Dom.
+Require Import PointerOp.
 
 Unset Allow StrictProp.
 
@@ -480,14 +481,34 @@ Variant state : Type :=
              (m: mem),                (**r memory state *)
       state.
 
+Definition ros_to_vos (m: Mem.mem) (ros: reg + ident) (rs: regset) : val + ident :=
+  match ros with
+  | inl r => match rs#r with
+            | Vint n => if negb Archi.ptr64
+                       then (match Mem.to_ptr (Vint n) m with
+                             | Some v' => inl v'
+                             | None => inl rs#r
+                             end)
+                       else inl rs#r
+            | Vlong n => if Archi.ptr64
+                        then (match Mem.to_ptr (Vlong n) m with
+                              | Some v' => inl v'
+                              | None => inl rs#r
+                              end)
+                        else inl rs#r
+            | _ => inl rs#r
+            end
+  | inr symb => inr symb
+  end.
+
 Section RELSEM.
 
 Variable ge: genv.
 
 Definition find_function
-  (ros: reg + ident) (rs: regset) : option fundef :=
+  (ros: val + ident) (rs: regset) : option fundef :=
   match ros with
-  | inl r => Genv.find_funct ge (rs # r)
+  | inl r => Genv.find_funct ge r
   | inr symb =>
       match Genv.find_symbol ge symb with
       | None => None
@@ -531,7 +552,7 @@ Inductive step: state -> trace -> state -> Prop :=
 | exec_Iop:
     forall s f sp pc rs m op args res pc' v,
     (fn_code f)!pc = Some(SSA.Iop op args res pc') ->
-    eval_operation ge sp op rs## args m = Some v ->
+    eval_operation_wrapper ge sp op rs## args m = Some v ->
     step (State s f sp pc rs m)
       E0 (State s f sp pc' (rs# res <- v) m)
 | exec_Iload:
@@ -551,14 +572,14 @@ Inductive step: state -> trace -> state -> Prop :=
 | exec_Icall:
     forall s f sp pc rs m sig ros args res pc' fd,
     (fn_code f)!pc = Some(SSA.Icall sig ros args res pc') ->
-    find_function ros rs = Some fd ->
+    find_function (ros_to_vos m ros rs) rs = Some fd ->
     funsig fd = sig ->
     step (State s f sp pc rs m)
       E0 (Callstate (Stackframe res f sp pc' rs :: s) fd rs## args m)
 | exec_Itailcall:
     forall s f stk pc rs m sig ros args fd m',
     (fn_code f)!pc = Some(SSA.Itailcall sig ros args) ->
-    find_function ros rs = Some fd ->
+    find_function (ros_to_vos m ros rs) rs = Some fd ->
     funsig fd = sig ->
     Mem.free m stk 0 f.(fn_stacksize) = Some m' ->
     step (State s f (Vptr stk Ptrofs.zero) pc rs m)
@@ -573,13 +594,13 @@ Inductive step: state -> trace -> state -> Prop :=
 | exec_Icond_true:
     forall s f sp pc rs m cond args ifso ifnot,
     (fn_code f)!pc = Some(SSA.Icond cond args ifso ifnot) ->
-    eval_condition cond rs## args m = Some true ->
+    eval_condition_wrapper cond rs## args m = Some true ->
     step (State s f sp pc rs m)
       E0 (State s f sp ifso rs m)
 | exec_Icond_false:
     forall s f sp pc rs m cond args ifso ifnot,
     (fn_code f)!pc = Some(SSA.Icond cond args ifso ifnot) ->
-    eval_condition cond rs## args m = Some false ->
+    eval_condition_wrapper cond rs## args m = Some false ->
     step (State s f sp pc rs m)
       E0 (State s f sp ifnot rs m)
 | exec_Ijumptable:
@@ -632,13 +653,53 @@ Variant initial_state (p: program): state -> Prop :=
       funsig f = signature_main ->
       initial_state p (Callstate nil f nil m0).
 
+Inductive glob_capture (p: program) : state -> state -> Prop :=
+  | glob_capture_intro
+      f m pbs m'
+      (* (INIT: initial_state p (Callstate nil f nil m)) *)
+      (NONSTATIC: Genv.non_static_glob (Genv.globalenv p) (Genv.genv_public (Genv.globalenv p)) = pbs)
+      (CAPTURE: Genv.capture_init_mem m pbs m') :
+    glob_capture p (Callstate nil f nil m) (Callstate nil f nil m').
+
+Definition state_mem (st: state) : mem :=
+  match st with
+  | State _ _ _ _ _ m => m
+  | Callstate _ _ _ m => m
+  | Returnstate _ _ m => m
+  end.
+
+Definition concrete_snapshot (ge: Senv.t) (st: state) (id: ident) : option Z :=
+  if Senv.public_symbol ge id
+  then (match Senv.find_symbol ge id with
+        | Some b => Maps.PTree.get b (state_mem st).(Mem.mem_concrete)
+        | None => None
+        end
+    )
+  else None.
+
 (** A final state is a [Returnstate] with an empty call stack. *)
 Variant final_state: state -> int -> Prop :=
   | final_state_intro: forall r m, final_state (Returnstate nil (Vint r) m) r.
 
+(** Non-deterministic external state *)
+Definition is_external (ge:genv) (s:state) : Prop :=
+  match s with
+  | Callstate stk fd vargs m =>
+    match fd with
+    | External ef => is_external_ef ef
+    | _ => False
+    end
+  | State cs f sp pc rs m =>
+    match (fn_code f)!pc with
+    | Some (Ibuiltin ef args res pc') => is_external_ef ef
+    | _ => False
+    end
+  | _ => False
+  end.
+
 (** The small-step semantics for a program. *)
 Definition semantics (p: program) :=
-  Semantics step (initial_state p) final_state (Genv.globalenv p).
+  Semantics step (initial_state p) (glob_capture p) (concrete_snapshot (Genv.globalenv p)) final_state is_external (Genv.globalenv p).
 
 Definition parc_dst (pcopy : parcopy) :=
   match pcopy with
diff --git a/midend/CSSAD.v b/midend/CSSAD.v
new file mode 100644
index 00000000..1813b00d
--- /dev/null
+++ b/midend/CSSAD.v
@@ -0,0 +1,63 @@
+Require Import Coqlib CoqlibC Events.
+Require Import Globalenvs Smallstep Simulation.
+Require Import sflib CSSA.
+
+(** Determinacy *)
+
+Lemma semantics_single_events p s (INT: ~ is_external (Genv.globalenv p) s): single_events_at (CSSA.semantics p) s.
+Proof.
+  red. intros. inv H; (try (exploit external_call_trace_length; eauto; intro T)); simpl; try lia. ss. des_ifs.
+Qed.
+
+Lemma semantics_receptive_at:
+  forall (p: program) s (INT: ~ is_external (Genv.globalenv p) s), receptive_at (semantics p) s.
+Proof.
+  intros. constructor; simpl; intros.
+(* receptiveness *)
+- assert (t1 = E0 -> exists s2, step (Genv.globalenv p) s t2 s2).
+    intros. subst. inv H0. exists s1; auto.
+  inversion H; subst; auto.
++ ss. des_ifs.
+  exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
+  esplits; eauto. eapply exec_Ibuiltin; eauto.
++ exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
+  esplits; eauto. econstructor; eauto.
+(* trace length *)
+- red; intros; inv H; simpl; try lia; ss; des_ifs.
+  eapply external_call_trace_length; eauto.
+  eapply external_call_trace_length; eauto.
+Qed.
+
+Lemma semantics_determinate_at:
+  forall (p: program) s (INT: ~ is_external (Genv.globalenv p) s), deterministic_at (semantics p) s.
+Proof.
+  intros. constructor; simpl; intros.
+  - (* determinacy *)
+    inv STEP0; inv STEP1; Eq;
+      try (split; [apply match_traces_E0| intro;auto]);
+      try (elim H; simpl; try rewrite H2; auto);ss.
+    + ss. des_ifs.
+      determ_tac eval_builtin_args_determ.
+      determ_tac external_call_determ.
+    + ss. determ_tac external_call_determ.
+  - inv FINAL; inv STEP.
+  - ii. eapply semantics_single_events; eauto.
+Qed.
+
+Lemma initial_state_determ: forall p st0 st1,
+    Smallstep.initial_state (semantics p) st0 ->
+    Smallstep.initial_state (semantics p) st1 -> st0 = st1.
+Proof.
+  intros. inv H; inv H0. subst ge0 ge. Eq.
+Qed.
+
+Theorem final_state_determ: forall p st0 retv,
+    Smallstep.final_state (semantics p) st0 retv ->
+    Dfinal_state (semantics p) st0 retv.
+Proof.
+  econstructor; eauto.
+  - intros. inv FINAL0; inv FINAL1. auto.
+  - red. unfold not. intros. inv FINAL; inv H0.
+Qed.
+
+Ltac DStep_tac := esplit; [(eapply semantics_determinate_at; simpl in *; eauto; des_ifs)|].
diff --git a/midend/CSSAproof.v b/midend/CSSAproof.v
index 994733f9..17c61eeb 100644
--- a/midend/CSSAproof.v
+++ b/midend/CSSAproof.v
@@ -12,6 +12,7 @@ Require Import Values.
 Require Import Globalenvs.
 Require Import Op.
 Require Import Registers.
+Require Import PointerOp Simulation SSAD CSSAD sflib.
 Require Import Smallstep.
 Require Import CSSA.
 Require Import SSA.
@@ -27,6 +28,9 @@ Require Import KildallComp.
 Require Import DLib.
 Require Import CSSAgenspec.
 Require Import CSSAutils.
+Require Import Classical.
+From Paco Require Import paco.
+
 Unset Allow StrictProp.
 
 Ltac sz := unfold Plt, Ple in * ; (zify; lia).
@@ -3042,6 +3046,9 @@ Section PRESERVATION.
     
     Let ge := Genv.globalenv prog.
     Let tge := Genv.globalenv tprog.
+
+    Let sem := SSA.semantics prog.
+    Let tsem := CSSA.semantics tprog.
     
     Lemma symbols_preserved:
       forall (s: ident), Genv.find_symbol tge s = Genv.find_symbol ge s.
@@ -3219,22 +3226,24 @@ Proof.
   apply (Genv.find_funct_transf_partial); eauto.
 Qed.
 
-Lemma spec_ros_r_find_function: forall rs rs' f r,
+Lemma spec_ros_r_find_function: forall rs rs' f r m,
   rs # r = rs' # r ->
-  SSA.find_function ge (inl _ r) rs = Some f ->
+  SSA.find_function ge (SSA.ros_to_vos m (inl _ r) rs) rs = Some f ->
   exists tf,
-     CSSA.find_function tge (inl _ r) rs' = Some tf
+     CSSA.find_function tge (CSSA.ros_to_vos m (inl _ r) rs') rs' = Some tf
   /\ transl_fundef f = Errors.OK tf.
 Proof.
-  intros.
-  eapply functions_translated; eauto. inv H0.
-  rewrite H; auto.
+  intros. simpl in H0. des_ifs.
+- ss. rewrite <- H. des_ifs.
+  exploit (functions_translated (Vptr b (Ptrofs.repr z))); eauto. ss. des_ifs.
+- ss. rewrite <- H. des_ifs.
+  exploit (functions_translated (Vptr b (Ptrofs.zero))); eauto.
 Qed.
 
-Lemma spec_ros_id_find_function: forall rs rs' f id,
-  SSA.find_function ge (inr _ id) rs = Some f ->
+Lemma spec_ros_id_find_function: forall rs rs' f id m,
+  SSA.find_function ge (SSA.ros_to_vos m (inr _ id) rs) rs = Some f ->
   exists tf,
-     CSSA.find_function tge (inr _ id) rs' = Some tf
+     CSSA.find_function tge (SSA.ros_to_vos m (inr _ id) rs') rs' = Some tf
   /\ transl_fundef f = Errors.OK tf.
 Proof.
   intros.
@@ -3713,14 +3722,19 @@ Proof.
   apply (Genv.senv_transf_partial TRANSF_PROG).
 Qed.
 
+Lemma same_public:
+  prog_public prog = prog_public tprog.
+Proof. inv TRANSF_PROG. des; eauto. Qed.
+
 (** ** Proving the transformation *)
 Lemma transl_step_correct:
   forall s1 t s2,
-  step ge s1 t s2 ->
+  IStep sem s1 t s2 ->
   forall s1' (MS: match_states s1 s1'),
   exists s2',
-  CSSA.step tge s1' t s2' /\ match_states s2 s2'.
+  DStep tsem s1' t s2' /\ match_states s2 s2'.
 Proof.
+  destruct 1. generalize dependent s2. rename H into INT.
   induction 1; intros; inv MS; auto;
   match goal with
   | [H : transl_fundef (Internal ?f) = _ |- _ ] => idtac
@@ -3743,6 +3757,8 @@ Proof.
   end.
   (* inop without block *)
   { exists (CSSA.State ts tf sp pc' rs' m). split; auto.
+    DStep_tac.
+    { exploit instructions_preserved; eauto. i. rewrite H2 in Heq. clarify. }
     econstructor 1 ; eauto.
     - erewrite instructions_preserved; eauto.
     - intuition.
@@ -3783,6 +3799,8 @@ Proof.
     + assert (EQ_PC_PRED: pc = pred).
       eapply index_preds_pc_inj; eauto.
       rewrite EQ_PC_PRED in *.
+      DStep_tac.
+      { exploit instructions_preserved; eauto. i. rewrite H1 in Heq. clarify. }
       eapply CSSA.exec_Inop_jp; eauto.
       - erewrite instructions_preserved; eauto.
       - eapply join_points_preserved; eauto.
@@ -3799,7 +3817,9 @@ Proof.
   (* iop *)
   { exists (CSSA.State ts tf sp pc' (rs' # res <- v) m).
     split.
-    + econstructor; eauto.
+    + DStep_tac.
+      { exploit instructions_preserved; eauto. i. rewrite H2 in Heq. clarify. }
+      econstructor; eauto.
       assert ((CSSA.fn_code tf) ! pc =
         Some (Iop op args res pc')).
       erewrite instructions_preserved; eauto; simpl; eauto.
@@ -3816,7 +3836,7 @@ Proof.
         apply max_reg_correct_code.
       }
       rewrite REGS_EQ.
-      erewrite eval_operation_preserved; eauto.
+      erewrite eval_operation_wrapper_preserved; eauto.
       eapply symbols_preserved.
     + constructor; eauto.  constructor.
       inv MREG.  intros.
@@ -3825,7 +3845,9 @@ Proof.
   (* iload *)
   { exists (CSSA.State ts tf sp pc' (rs' # dst <- v) m).
     split.
-    + eapply CSSA.exec_Iload; eauto.
+    + DStep_tac.
+      { exploit instructions_preserved; eauto. i. rewrite H3 in Heq. clarify. }
+      eapply CSSA.exec_Iload; eauto.
       assert ((CSSA.fn_code tf) ! pc =
         Some (Iload chunk addr args dst pc')).
       erewrite instructions_preserved; eauto; simpl; eauto.
@@ -3851,7 +3873,9 @@ Proof.
   (* istore *)
   { exists (CSSA.State ts tf sp pc' rs' m').
     split.
-    + eapply CSSA.exec_Istore; eauto.
+    + DStep_tac.
+      { exploit instructions_preserved; eauto. i. rewrite H3 in Heq. clarify. }
+      eapply CSSA.exec_Istore; eauto.
       assert ((CSSA.fn_code tf) ! pc =
         Some (Istore chunk addr args src pc')).
       { erewrite instructions_preserved; eauto; simpl; eauto. }
@@ -3912,7 +3936,7 @@ Proof.
 
     destruct ros.
     - assert(Htfd: exists tfd,
-        CSSA.find_function tge (inl _ r) rs' = Some tfd
+        CSSA.find_function tge (CSSA.ros_to_vos m (inl _ r) rs') rs' = Some tfd
         /\ transl_fundef fd = Errors.OK tfd).
       apply spec_ros_r_find_function
         with (rs := rs); auto.
@@ -3935,7 +3959,8 @@ Proof.
         (CSSA.Stackframe res tf sp pc' rs' :: ts)
         tfd (rs'## args) m).
       split.
-      + apply CSSA.exec_Icall
+      + DStep_tac;
+        try by (exploit instructions_preserved; eauto; i; rewrite H2 in Heq; clarify).      apply CSSA.exec_Icall
           with (sig := CSSA.funsig tfd)
             (ros := inl r); eauto.
         { erewrite instructions_preserved; eauto; simpl;
@@ -3952,7 +3977,7 @@ Proof.
         go.
         auto.
     - assert(Htfd: exists tfd,
-        CSSA.find_function tge (inr i) rs' = Some tfd
+        CSSA.find_function tge (CSSA.ros_to_vos m (inr i) rs') rs' = Some tfd
         /\ transl_fundef fd = Errors.OK tfd).
       apply spec_ros_id_find_function
         with (rs := rs); auto.
@@ -3961,7 +3986,10 @@ Proof.
         (CSSA.Stackframe res tf sp pc' rs' :: ts)
         tfd (rs'## args) m).
       split.
-      + apply CSSA.exec_Icall
+      + DStep_tac.
+        { exploit instructions_preserved; eauto. i. rewrite H2 in Heq. clarify. }
+        { exploit instructions_preserved; eauto. i. rewrite H2 in Heq. clarify. }
+        apply CSSA.exec_Icall
           with (sig := CSSA.funsig tfd)
             (ros := inr i); eauto.
         erewrite instructions_preserved; eauto.
@@ -4009,7 +4037,7 @@ Proof.
 
     destruct ros.
     - assert(Htfd: exists tfd,
-        CSSA.find_function tge (inl _ r) rs' = Some tfd
+        CSSA.find_function tge (CSSA.ros_to_vos m (inl _ r) rs') rs' = Some tfd
         /\ transl_fundef fd = Errors.OK tfd).
       apply spec_ros_r_find_function
         with (rs := rs); auto.
@@ -4031,7 +4059,8 @@ Proof.
       exists (CSSA.Callstate
         ts tfd rs'## args m').
       split.
-      + apply CSSA.exec_Itailcall
+      + DStep_tac; try by (exploit instructions_preserved; eauto; i; rewrite H3 in Heq; clarify).
+        apply CSSA.exec_Itailcall
           with (sig := CSSA.funsig tfd)
             (ros := inl r); eauto.
         { erewrite instructions_preserved; eauto; simpl;
@@ -4050,7 +4079,7 @@ Proof.
         go.
         auto.
     - assert(Htfd: exists tfd,
-        CSSA.find_function tge (inr i) rs' = Some tfd
+        CSSA.find_function tge (CSSA.ros_to_vos m (inr i) rs') rs' = Some tfd
         /\ transl_fundef fd = Errors.OK tfd).
       apply spec_ros_id_find_function
         with (rs := rs); auto.
@@ -4058,7 +4087,10 @@ Proof.
       exists (CSSA.Callstate
         ts tfd (rs'## args) m').
       split.
-      + apply CSSA.exec_Itailcall
+      + DStep_tac.
+        { exploit instructions_preserved; eauto. i. rewrite H3 in Heq. clarify. }
+        { exploit instructions_preserved; eauto. i. rewrite H3 in Heq. clarify. }
+        apply CSSA.exec_Itailcall
           with (sig := CSSA.funsig tfd)
             (ros := inr i); eauto.
         erewrite instructions_preserved; eauto.
@@ -4079,7 +4111,10 @@ Proof.
   (* ibuiltin *)
   { exists (CSSA.State ts tf sp pc' (regmap_setres res vres rs') m').
     split.
-    + eapply CSSA.exec_Ibuiltin with (vargs:= vargs); eauto.
+    + DStep_tac.
+      { unfold is_internal in INT. ss. des_ifs.
+        exploit instructions_preserved; eauto. i. rewrite H in Heq. clarify. }
+      eapply CSSA.exec_Ibuiltin with (vargs:= vargs); eauto.
       * assert ((CSSA.fn_code tf) ! pc =  Some (Ibuiltin ef args res pc')).
         { erewrite instructions_preserved; eauto; simpl; eauto. }
         eauto.
@@ -4143,7 +4178,9 @@ Proof.
   (* ifso *)
   { exists (CSSA.State ts tf sp ifso rs' m).
     split.
-    + eapply CSSA.exec_Icond_true; eauto.
+    + DStep_tac.
+      { exploit instructions_preserved; eauto. i. rewrite H2 in Heq. clarify. }
+      eapply CSSA.exec_Icond_true; eauto.
       assert ((CSSA.fn_code tf) ! pc =
         Some (Icond cond args ifso ifnot)).
       { erewrite instructions_preserved; eauto; simpl;
@@ -4166,7 +4203,9 @@ Proof.
   (* ifnot *)
   { exists (CSSA.State ts tf sp ifnot rs' m).
     split.
-    + eapply CSSA.exec_Icond_false; eauto.
+    + DStep_tac.
+      { exploit instructions_preserved; eauto. i. rewrite H2 in Heq. clarify. }
+      eapply CSSA.exec_Icond_false; eauto.
       assert ((CSSA.fn_code tf) ! pc =
         Some (Icond cond args ifso ifnot)).
       { erewrite instructions_preserved; eauto; simpl;
@@ -4190,7 +4229,9 @@ Proof.
   (* ijumptable *)
   { exists (CSSA.State ts tf sp pc' rs' m).
     split.
-    + eapply CSSA.exec_Ijumptable; eauto.
+    + DStep_tac.
+      { exploit instructions_preserved; eauto. i. rewrite H3 in Heq. clarify. }
+      eapply CSSA.exec_Ijumptable; eauto.
       assert ((CSSA.fn_code tf) ! pc =
         Some (Ijumptable arg tbl)).
       { erewrite instructions_preserved; eauto; simpl;
@@ -4210,7 +4251,9 @@ Proof.
   { exists (CSSA.Returnstate ts
       (regmap_optget or Vundef rs') m').
     split.
-    + eapply CSSA.exec_Ireturn; eauto.
+    + DStep_tac.
+      { exploit instructions_preserved; eauto. i. rewrite H2 in Heq. clarify. }
+      eapply CSSA.exec_Ireturn; eauto.
       assert ((CSSA.fn_code tf) ! pc =
         Some (Ireturn or)).
       { erewrite instructions_preserved; eauto; simpl; eauto. }
@@ -4235,7 +4278,8 @@ Proof.
       (init_regs args (CSSA.fn_params tf))
       m').
     split.
-    + eapply CSSA.exec_function_internal.
+    + DStep_tac.
+      eapply CSSA.exec_function_internal.
       erewrite <- stacksize_preserved; eauto.
       simpl in SPEC.
       unfold Errors.bind in SPEC.
@@ -4262,7 +4306,8 @@ Proof.
   { inv SPEC.
     exists (CSSA.Returnstate ts res m').
     split.
-    + eapply CSSA.exec_function_external.
+    + DStep_tac.
+      eapply CSSA.exec_function_external.
       eapply external_call_symbols_preserved; eauto.
       apply senv_preserved. 
     + econstructor; eauto.
@@ -4273,7 +4318,8 @@ Proof.
     exists (CSSA.State ts0 tf sp pc
       (rs' # res <- vres) m).
     split.
-    + eapply CSSA.exec_return.
+    + DStep_tac.
+      eapply CSSA.exec_return.
     + econstructor; eauto.
       econstructor; intros.
       inv MREG.
@@ -4286,16 +4332,229 @@ Proof.
   }
 Qed.
 
-Theorem transf_program_correct:
-  forward_simulation (SSA.semantics prog) (CSSA.semantics tprog).
-Proof.
-  eapply forward_simulation_step with (match_states := match_states).
-  eapply senv_preserved. 
-  eexact transf_initial_states.
-  eexact transf_final_states.
-  exact transl_step_correct.
+Lemma match_states_bsim
+      s1
+      (EXT: is_external ge s1)
+      s2 t s2'
+      (STEPTGT: Step tsem s2 t s2')
+      (MATCH: match_states s1 s2)
+      (SAFESRC: safe sem s1)
+  :
+    (exists s1', Step sem s1 t s1' /\ match_states s1' s2').
+Proof.
+  assert (SEQUIV: Senv.equiv tge ge) by (symmetry; apply senv_preserved).
+  unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+  { inv SAFESRC. inv MATCH. ss. }
+  unfold is_external in *. des_ifs.
+  (* builtin *)
+  - i. inv MATCH; clarify.
+    exploit instructions_preserved; eauto. i.
+    inv STEPTGT; rewrite H in *; clarify. inv SAFESRC; clarify.
+    esplits; eauto.
+    + eapply SSA.exec_Ibuiltin.
+      { eauto. }
+      2:{ eapply external_call_symbols_preserved; eauto. }
+      assert (forall r, In r (params_of_builtin_args l) -> rs' !! r = rs !! r).
+      { symmetry.
+        inv MREG.
+        intros.
+        eapply max_reg_in_code in H11; eauto.
+        apply H1.
+        apply Ple_trans with
+          (get_max_reg_in_ins
+             (Ibuiltin e l b n)).
+        apply max_reg_in_Ibuiltin_args; auto.
+        apply Ple_trans with
+          (get_max_reg_in_code (fn_code f)); auto.
+        apply max_reg_correct_code. }
+      eapply eval_builtin_args_preserved with (ge1:=tge).
+      { i. symmetry. eapply senv_preserved. }
+      revert H9 H0. clear.
+      { induction 1; i; go.
+        constructor.
+        - revert H H0. clear.
+          induction 1; i; go.
+          + rewrite H0; go.
+          + constructor.
+            * eapply IHeval_builtin_arg1; eauto.
+              intros. eapply H1; eauto. simpl in *.
+              rewrite app_ass.
+              eapply in_app_or in H2.
+              eapply in_or_app. intuition.
+            * eapply IHeval_builtin_arg2; eauto.
+              intros. eapply H1; eauto. simpl in *.
+              rewrite app_ass.
+              eapply in_app_or in H2.
+              eapply in_or_app. intuition.
+          + constructor.
+            * eapply IHeval_builtin_arg1; eauto.
+              intros. eapply H1; eauto. simpl in *.
+              rewrite app_ass.
+              eapply in_app_or in H2.
+              eapply in_or_app. intuition.
+            * eapply IHeval_builtin_arg2; eauto.
+              intros. eapply H1; eauto. simpl in *.
+              rewrite app_ass.
+              eapply in_app_or in H2.
+              eapply in_or_app. intuition.
+        - eapply IHlist_forall2; eauto.
+          intros. eapply H0; eauto.
+          simpl. eapply in_or_app. intuition. }
+    + constructor; eauto.
+      constructor. inv MREG. intros.
+      destruct b; auto.
+      simpl.
+      rewrite PMap.gsspec. rewrite PMap.gsspec.
+      destruct peq; eauto.
+  (* external call *)
+  - i. inv MATCH; clarify. inv SPEC.
+    inv STEPTGT; clarify. inv SAFESRC; clarify.
+    ss. exists (SSA.Returnstate stack res m').
+    split.
+    + eapply SSA.exec_function_external.
+      eapply external_call_symbols_preserved; eauto.
+    + econstructor; eauto.
 Qed.
 
-  End CORRECTNESS.
+Lemma match_states_xsim
+    st_src0 st_tgt0 gmtgt
+    (MATCH: match_states st_src0 st_tgt0) :
+  xsim (SSA.semantics prog) (CSSA.semantics tprog) gmtgt lt 0%nat st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold.
+  destruct (classic (is_external ge st_src0)); cycle 1.
+  (* not external *)
+  - left. econs. econs.
+    + i. exploit transl_step_correct; eauto. i. des.
+      * esplits; eauto.
+        { eapply tr_rel_refl. eapply ev_rel_refl. }
+        left. split.
+        { eapply plus_one; eauto. }
+        { eapply SSAD.semantics_receptive_at; auto. }
+    + ii. eapply final_state_determ; eauto.
+      inv FINALSRC. inv MATCH. ss. inv STACK. econs.
+  (* external *)
+  - right. econs. i. econs.
+    + i. exploit match_states_bsim; eauto. i. des.
+      left. esplits; eauto.
+      { eapply tr_rel_refl. eapply ev_rel_refl. }
+      left. eapply plus_one. eauto.
+    + i. unfold is_external in *.
+      des_ifs; inv FINALTGT; inv MATCH; ss.
+    (* progress *)
+    + i.
+      specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+      { inv SAFESRC; ss. }
+      right. inv MATCH; ss; des_ifs; inv SAFESRC; unfold ge in *; clarify.
+      * exploit instructions_preserved; eauto. i.
+        esplits. eapply CSSA.exec_Ibuiltin; eauto.
+        { rewrite H0; eauto. }
+        2:{ eapply external_call_symbols_preserved. apply senv_preserved. eauto. }
+        eapply eval_builtin_args_preserved with (ge1:= ge); eauto.
+        eapply symbols_preserved.
+        assert (forall r, In r (params_of_builtin_args l) -> rs !! r = rs' !! r).
+        { inv MREG.
+          intros.
+          eapply max_reg_in_code in H8; eauto.
+          apply H1.
+          apply Ple_trans with
+              (get_max_reg_in_ins
+                 (Ibuiltin e l b n)).
+          apply max_reg_in_Ibuiltin_args; auto.
+          apply Ple_trans with
+              (get_max_reg_in_code (fn_code f)); auto.
+          apply max_reg_correct_code.
+        }
+        revert H9 H1. clear.
+        { induction 1 ; intros; go.
+          constructor.
+          - revert H H1. clear.
+            induction 1 ; intros ; go.
+            + rewrite H1; go.
+            + constructor.
+              * eapply IHeval_builtin_arg1; eauto.
+                intros. eapply H1; eauto. simpl in *.
+                rewrite app_ass.
+                eapply in_app_or in H2.
+                eapply in_or_app. intuition.
+              * eapply IHeval_builtin_arg2; eauto.
+                intros. eapply H1; eauto. simpl in *.
+                rewrite app_ass.
+                eapply in_app_or in H2.
+                eapply in_or_app. intuition.
+            + constructor.
+              * eapply IHeval_builtin_arg1; eauto.
+                intros. eapply H1; eauto. simpl in *.
+                rewrite app_ass.
+                eapply in_app_or in H2.
+                eapply in_or_app. intuition.
+              * eapply IHeval_builtin_arg2; eauto.
+                intros. eapply H1; eauto. simpl in *.
+                rewrite app_ass.
+                eapply in_app_or in H2.
+                eapply in_or_app. intuition.
+          - eapply IHlist_forall2; eauto.
+            intros. eapply H1; eauto.
+            simpl. eapply in_or_app. intuition. }
+      * i. inv SPEC.
+        esplits. eapply CSSA.exec_function_external.
+        eapply external_call_symbols_preserved with (ge1:=ge); eauto.
+        unfold ge. eapply senv_preserved.
+Qed.
+
+Lemma non_static_equiv l:
+  Genv.non_static_glob (Genv.globalenv prog) l = Genv.non_static_glob (Genv.globalenv tprog) l.
+Proof.
+  induction l; ss.
+  specialize senv_preserved. i. unfold ge, tge in H. r in H. des.
+  specialize (H0 a).
+  unfold Senv.public_symbol in H0. ss. rewrite <- H0.
+  specialize (H a). rewrite <- H. erewrite IHl; eauto.
+Qed.
+
+Lemma transf_initial_capture
+    S1 S2 S2'
+    (INITSRC: SSA.initial_state prog S1)
+    (INITTGT: CSSA.initial_state tprog S2)
+    (MATCH: match_states S1 S2)
+    (CAPTGT: CSSA.glob_capture tprog S2 S2'):
+  exists S1',
+    SSA.glob_capture prog S1 S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (SSA.concrete_snapshot ge S1') (CSSA.concrete_snapshot tge S2').
+Proof.
+  specialize senv_preserved. intros SENVEQ. inv CAPTGT. ss.
+  rewrite Genv.globalenv_public in CAPTURE.
+  rewrite <- same_public in CAPTURE. erewrite <- non_static_equiv in CAPTURE.
+  inv MATCH. inv STACK.
+  esplits.
+  - econs; eauto. rewrite Genv.globalenv_public. eauto.
+  - econs; eauto.
+  - ii. unfold CSSA.concrete_snapshot, SSA.concrete_snapshot in *.
+    inv SENVEQ. des. erewrite H1, H0. des_ifs; ss.
+Qed.
+
+Theorem transf_program_correct:
+  mixed_simulation (SSA.semantics prog) (CSSA.semantics tprog).
+Proof.
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (S a). lia.
+  - econs. i. exploit transf_initial_states; eauto. i. des.
+    exists st2. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. inversion INITSRC; subst. inversion H0; subst.
+      inv STACK.
+      exploit transf_initial_capture; eauto.
+      i. des.
+      exists 0%nat. exists S1'. esplits; eauto.
+      apply match_states_xsim; auto.
+  - i. apply senv_preserved.
+Qed.
+
+End CORRECTNESS.
   
 End PRESERVATION.
diff --git a/midend/CSSAval.v b/midend/CSSAval.v
index 9375e86d..72014fac 100644
--- a/midend/CSSAval.v
+++ b/midend/CSSAval.v
@@ -301,9 +301,10 @@ Qed.
 (* Utility lemmas about CSSA-value *)
 
 Definition reachable (prog:program) (s:state) :=
-  exists s0, exists t,
-      initial_state prog s0 
-      /\  star step (Genv.globalenv prog) s0 t s.
+  exists s0, exists t, exists s0',
+    initial_state prog s0 /\
+      glob_capture prog s0 s0'              
+      /\  star step (Genv.globalenv prog) s0' t s.
 
 Section PATH.
 
@@ -982,7 +983,16 @@ Proof.
   eapply Genv.find_funct_ptr_prop ; eauto.
   econstructor; eauto.
 Qed.
-  
+
+Lemma s_inv_initial_capture : forall s s',
+  initial_state prog s ->
+  glob_capture prog s s' -> 
+  s_inv ge_prog s'.
+Proof.
+  intros. exploit s_inv_initial; eauto. intros.
+  inv H. inv H0. inv H1. econstructor; eauto.
+Qed.
+
 Lemma subj_red : forall s s' t,
   s_inv ge_prog s ->
   step ge_prog s t s' ->
@@ -1260,14 +1270,15 @@ Proof.
   eapply subj_red ; eauto.
 Qed.
 
-Theorem ssa_inv1 : forall s s' t,
+Theorem ssa_inv1 : forall s s0 s' t,
   initial_state prog s ->
-  star step ge_prog s t s' ->
+  glob_capture prog s s0 ->  
+  star step ge_prog s0 t s' ->
   s_inv ge_prog s'.
 Proof.
   intros.
   eapply ssa_inv1_aux ; eauto.
-  eapply s_inv_initial ; eauto.
+  eapply s_inv_initial_capture ; eauto.
 Qed.
 
 Lemma cssaval_spec_correct :
@@ -1278,6 +1289,7 @@ Lemma cssaval_spec_correct :
 Proof.
   intros.
   destruct H as [s0 [t [IS Hstar]]].
+  destruct Hstar as [s0' [ICAP Hstar]].
   eapply ssa_inv1 in Hstar; eauto.
   invh s_inv; go.
 Qed.
diff --git a/midend/Captureprop.v b/midend/Captureprop.v
new file mode 100644
index 00000000..3be55ce0
--- /dev/null
+++ b/midend/Captureprop.v
@@ -0,0 +1,160 @@
+Require Import Classical.
+Require Import Coqlib.
+Require Import Maps.
+Require Import AST.
+Require Import Integers.
+Require Import Values.
+Require Import Memory.
+Require Import Globalenvs.
+Require Import Smallstep.
+Require Import Op.
+Require Import Events.
+Require Import Registers.
+Require Import Floats.
+Require Import Utils.
+Require Import SSA. 
+Require Import SSAutils. 
+Require Import Utilsvalidproof.
+Require Import DomCompute.
+Require Import Axioms.
+Require Import KildallComp.
+Require Import OrderedType.
+Require Import Ordered.
+Require Import FSets.
+Require FSetAVL.
+(* Require Import Opt. *)
+(* Require Import OptInv. *)
+Require Import DLib.
+Require Import Errors.
+Require Import sflib.
+
+(** * Domtree traversal functions *)
+
+Definition is_capture (i: instruction) :=
+  match i with
+  | (Ibuiltin EF_capture ((BA p)::nil) (BR res) pc') => Some (res, p)
+  | _ => None
+  end.
+
+Definition _find_capture (result: list node) (pc: node) (i: instruction) :=
+  match (is_capture i) with
+  | None => result
+  | Some _ => pc::result
+  end.
+
+Definition find_capture_all (c: code) :=
+  PTree.fold _find_capture c [].
+
+Fixpoint find_parent (nl: list node) (parents: L.t) :=
+  match nl with
+  | [] => None
+  | hd::tl => if (in_set hd parents)
+            then Some hd
+            else (find_parent tl parents)
+  end.
+
+Section CAPTUREPROP.
+
+Variable domtree: PMap.t L.t.
+
+Fixpoint find_capture_root_fuel (fuel:nat) (i: node) (il: list node) : node :=
+  match fuel with
+  | O => i
+  | S fuel' =>
+      let parents := (PMap.get i domtree) in
+      match (find_parent il parents) with
+      | None => i
+      | Some i' => find_capture_root_fuel fuel' i' (filter (fun x => (negb (Pos.eqb i' x))) il)
+      end
+  end.
+
+Definition find_capture_root (i: node) (il: list node) : node :=
+  find_capture_root_fuel (Datatypes.length il + 1) i il.
+
+Definition rename_reg (d s: reg) (r: reg) : reg :=
+  if (Pos.eqb r s) then d else r.
+
+Fixpoint rename_barg (d s: reg) (b: builtin_arg reg) : builtin_arg reg :=
+  match b with
+  | BA r => BA (rename_reg d s r)
+  | BA_splitlong b1 b2 => BA_splitlong (rename_barg d s b1) (rename_barg d s b2)
+  | BA_addptr b1 b2 => BA_addptr (rename_barg d s b1) (rename_barg d s b2)
+  | _ => b
+  end.
+
+Fixpoint rename_bres (d s: reg) (b: builtin_res reg) : builtin_res reg :=
+  match b with
+  | BR r => BR (rename_reg d s r)
+  | BR_splitlong b1 b2 => BR_splitlong (rename_bres d s b1) (rename_bres d s b2)
+  | _ => b
+  end.  
+
+Definition subst_instr (d s: reg) (instr: instruction) :=
+  let rn := rename_reg d s in
+  let rnba := rename_barg d s in
+  let rnbr := rename_bres d s in
+  match instr with
+  | Inop pc' => Inop pc'
+  | Iop op args dst pc' => Iop op (map rn args) dst pc'
+  | Iload chunk addr args dst pc' => Iload chunk addr (map rn args) dst pc'
+  | Istore chunk addr args src pc' => Istore chunk addr (map rn args) (rn src) pc'
+  | Icall sig fn args dst pc' => Icall sig fn (map rn args) dst pc'
+  | Itailcall sig fn args => Itailcall sig fn (map rn args)
+  | Ibuiltin ef args dst pc' => Ibuiltin ef (map rnba args) dst pc'
+  | Icond cond args ifso ifnot => Icond cond (map rn args) ifso ifnot
+  | Ijumptable arg tbl => Ijumptable (rn arg) tbl
+  | Ireturn ret => Ireturn (option_map rn ret)
+  end.
+
+Definition subst_capture_code (d s: reg) (cpt:node) (c: code) : code :=
+  PTree.map (fun pc instr =>
+            if andb (in_set cpt (domtree!!pc)) (negb (Pos.eqb cpt pc))
+            then subst_instr d s instr else instr) c.
+
+(* il is list of capture pc *)
+Fixpoint propagate_capture_fuel (fuel: nat) (c: code) (il: list node) :=
+  match fuel with
+  | O => c
+  | S fuel' => match il with
+              | [] => c
+              | hd::tl =>
+                  let pc := (find_capture_root hd tl) in (* find most dominate capture *)
+                  match (PTree.get pc c) with
+                  | None => c
+                  | Some i => match (is_capture i) with
+                             | None => c (* unreachable *)
+                             | Some (d, s) =>
+                                 let c' := (subst_capture_code d s pc c) in
+                                 propagate_capture_fuel fuel' c' (filter (fun x => negb (Pos.eqb pc x)) il)
+                             end
+                  end
+              end
+  end.
+
+Definition propagate_capture (c: code) (il: list node) :=
+  propagate_capture_fuel (Datatypes.length il + 1) c il.
+
+End CAPTUREPROP.
+
+Definition transf_function (f: function) : res function :=
+  match compute_dom f with
+  | Some domtree =>
+      let il := find_capture_all f.(fn_code) in
+      let code' := propagate_capture domtree f.(fn_code) il in
+      OK(mkfunction
+         f.(fn_sig)
+         f.(fn_params)
+         f.(fn_stacksize)
+         code'
+         f.(fn_phicode)
+         f.(fn_entrypoint)
+         f.(fn_ext_params)
+         f.(fn_dom_test))
+  | None => Error (msg "Captureprop failure: domtree gen fail")
+  end.
+
+Definition transf_fundef (f: fundef) : res fundef :=
+  AST.transf_partial_fundef transf_function f.
+
+Definition transf_program (p: program) : res program :=
+  transform_partial_program transf_fundef p.
\ No newline at end of file
diff --git a/midend/Capturepropproof.v b/midend/Capturepropproof.v
new file mode 100644
index 00000000..bfc38255
--- /dev/null
+++ b/midend/Capturepropproof.v
@@ -0,0 +1,2452 @@
+Require Import Classical.
+Require Import Coqlib.
+Require Import Maps.
+Require Import AST.
+Require Import Integers.
+Require Import Values.
+Require Import Memory.
+Require Import Globalenvs.
+Require Import Smallstep.
+Require Import Op.
+Require Import Events.
+Require Import Registers.
+Require Import Floats.
+Require Import Utils.
+Require Import SSA. 
+Require Import SSAutils. 
+Require Import SSAinv. 
+Require Import Utilsvalidproof.
+Require Import DomCompute.
+Require Import Axioms.
+Require Import KildallComp.
+Require Import OrderedType.
+Require Import Ordered.
+Require Import FSets.
+Require FSetAVL.
+Require Import Dsd.
+(* Require Import OptInv. *)
+Require Import Captureprop.
+Require Import Copypropproof.
+Require Import IntPtrRel.
+(* Require Import GVNoptProp. *)
+Require Import DLib.
+
+Require Import Linking.
+
+(* Require Opt. *)
+(* Require OptInv. *)
+Require Import Errors.
+From Paco Require Import paco.
+Require Import sflib.
+Require Import SSAD.
+Require Import IntPtrRef.
+
+Unset Allow StrictProp.
+
+Definition match_prog (p: SSA.program) (tp: SSA.program) :=
+  match_program (fun cu f tf => transf_fundef f = OK tf) eq p tp.
+
+Lemma transf_program_match:
+  forall prog tprog, transf_program prog = OK tprog -> match_prog prog tprog.
+Proof.
+  intros. eapply match_transform_partial_program_contextual; eauto.
+Qed.
+
+(* Step optimization definitions which correspond to one substitution *)
+Definition propagate_capture_step domtree (cl : code * list node) :=
+  let (c, il) := cl in
+  match il with
+    | nil => (c, nil)
+    | cpt :: tl =>
+      let root := (find_capture_root domtree cpt tl) in
+      match c ! root with
+      | Some i => match (is_capture i) with
+                  | Some (d, s) => (subst_capture_code domtree d s root c,
+                    filter (fun x => negb (Pos.eqb root x)) il)
+                  | None => (c, nil)
+                  end
+      | None => (c, nil)
+      end
+    end.
+
+Definition transf_function_step (fl : function * list node) :=
+  let (f, il) := fl in
+    match compute_dom f with
+    | Some domtree =>
+        let (c', il') := propagate_capture_step domtree (f.(fn_code), il) in
+        OK ((mkfunction (fn_sig f) (fn_params f) (fn_stacksize f) c' (fn_phicode f)
+        (fn_entrypoint f) (fn_ext_params f) (fn_dom_test f)), il')
+    | None => Error (msg "Captureprop failure: domtree gen fail")
+    end.
+
+Local Open Scope error_monad_scope.
+
+Definition transf_fundef_step (fdl : fundef * list node) :
+  res (fundef * list node) :=
+  let (fd, il) := fdl in
+    match fd with
+    | Internal f =>
+      do (tf, il') <- transf_function_step (f, il); OK ((Internal tf), il')
+    | External f =>
+      OK ((External f), il)
+    end.
+
+Definition transf_globdef_step (idgil: (ident * globdef fundef unit) * list node) :=
+  match idgil with
+  | (id, Gfun f, il) =>
+    do (tf, il') <- transf_fundef_step (f, il); OK ((id, Gfun tf), il')
+  | (id, Gvar v, il) => OK ((id, Gvar v), il)
+  end.
+
+Fixpoint transf_globdefs_step (l: list (ident * globdef fundef unit)) (ll: list (list node)) :=
+  match l, ll with
+  | idg :: l', il :: ll' =>
+      do (idg', il') <- transf_globdef_step (idg, il);
+      do (l'', ll'') <- transf_globdefs_step l' ll';
+      OK (idg' :: l'', il' :: ll'')
+  | _, _ => OK (l, ll)
+  end.
+
+Definition transf_program_step (pill : SSA.program * (list (list node))) :
+  res (SSA.program * list (list node)) :=
+  let (p, ill) := pill in
+  do (gl', ill') <- transf_globdefs_step p.(prog_defs) ill;
+  OK (mkprogram gl' p.(prog_public) p.(prog_main), ill').
+
+Fixpoint repeatn_monad {A} (f : A -> res A) (n : nat) a :=
+  match n with
+  | O => OK a
+  | S n' => do fa <- f a; repeatn_monad f n' fa
+  end.
+
+Definition root_capture (root : node) (l : list node) domtree :=
+  match l with
+  | nil => False
+  | hd :: tl => root = find_capture_root domtree hd tl
+  end.
+
+Definition change_code (f : function) (c : code) :=
+  mkfunction (fn_sig f) (fn_params f) (fn_stacksize f) c
+    (fn_phicode f) (fn_entrypoint f) (fn_ext_params f) (fn_dom_test f).
+
+Lemma subst_capture_code_spec : forall c pc i t d s hd tl,
+  c ! pc = Some i ->
+  (subst_capture_code t d s (find_capture_root t hd tl) c) ! pc =
+  match (in_set (find_capture_root t hd tl) t # pc) with
+  | true => if Pos.eqb pc (find_capture_root t hd tl) then Some i else Some (subst_instr d s i)
+  | false => Some i
+  end.
+Proof.
+  ii. unfold subst_capture_code. rewrite PTree.gmap. rewrite H. ss. flatten; ss.
+  rewrite Pos.eqb_eq in Eq1; clarify. rewrite negb_true_iff in Eq.
+  rewrite Pos.eqb_neq in Eq; clarify.
+  rewrite negb_false_iff in Eq. rewrite Pos.eqb_eq in Eq; clarify.
+  rewrite Pos.eqb_neq in Eq1; clarify.
+Qed.
+
+Lemma subst_capture_code_spec' : forall f f' tree d s pc i root,
+  (fn_code f) ! pc = Some i ->
+  f' = change_code f ((subst_capture_code tree d s root) (fn_code f)) ->
+  (fn_code f') ! pc = Some i \/
+  (fn_code f') ! pc = Some (subst_instr d s i) /\ in_set root (tree # pc) /\ root <> pc.
+Proof.
+  ii. destruct f; ss. unfold subst_capture_code in H0. inv H0. ss.
+  rewrite PTree.gmap. rewrite H. ss. flatten; ss. eapply andb_true_iff in Eq. des.
+  eapply negb_true_iff in Eq0. eapply Pos.eqb_neq in Eq0; clarify. right; eauto.
+  left; eauto.
+Qed.
+
+Lemma transf_program_step_len_preserved : forall defs1 pub1 main1 ll1 defs2 pub2 main2 ll2,
+  transf_program_step (mkprogram defs1 pub1 main1, ll1) =
+    OK (mkprogram defs2 pub2 main2, ll2) ->
+  Datatypes.length defs1 = Datatypes.length defs2 /\ Datatypes.length ll1 = Datatypes.length ll2.
+Proof.
+  assert (GLOBDEFS : forall l ll l' ll', transf_globdefs_step l ll = OK (l', ll') ->
+    Datatypes.length l = Datatypes.length l' /\ Datatypes.length ll = Datatypes.length ll').
+  { induction l; ii. simpl in H. inv H; eauto.
+    destruct ll. inv H. eauto. unfold transf_globdefs_step in H. monadInv H.
+    fold transf_globdefs_step in EQ1. eapply IHl in EQ1; eauto. des; simpl; eauto. }
+  induction defs1; i.
+  - ss. inv H. eauto.
+  - induction ll1.
+    + simpl in H. inv H; eauto.
+    + monadInv H. monadInv EQ. destruct a. destruct g.
+      * flatten EQ0; monadInv EQ0; monadInv EQ1; try inv EQ0;
+          eapply GLOBDEFS in EQ; des; split; simpl; eauto.
+      * split; simpl; eapply GLOBDEFS in EQ; simpl; des; eauto.
+Qed.
+
+Lemma repeatn_monad_def_dist : forall n a l, repeatn_monad transf_globdef_step (S n) (a, l) =
+  do (ta, tl) <- transf_globdef_step (a, l); repeatn_monad transf_globdef_step n (ta, tl).
+Proof.
+  i. unfold repeatn_monad. unfold bind. flatten.
+  - destruct p. simpl bind2. eauto.
+  - ss.
+Qed.
+
+Lemma repeatn_monad_dist : forall n a1 defs1 l1 ll1 pub1 main1,
+  Datatypes.length defs1 = Datatypes.length ll1 ->
+  repeatn_monad transf_program_step n (mkprogram (a1 :: defs1) pub1 main1, l1 :: ll1)
+  = do (a2, l2) <- repeatn_monad transf_globdef_step n (a1, l1);
+    do (p2, ll2) <- repeatn_monad transf_program_step n (mkprogram defs1 pub1 main1, ll1);
+    OK ((mkprogram (a2 :: (prog_defs p2)) (prog_public p2) (prog_main p2)), l2 :: ll2).
+Proof.
+  assert (REPEATN : forall n p l, repeatn_monad transf_program_step (S n) (p, l) =
+    do (tp, tl) <- transf_program_step (p, l); repeatn_monad transf_program_step n (tp, tl)).
+  { unfold repeatn_monad. i. destruct (transf_program_step (p, l)) eqn:STEP.
+    - simpl bind. destruct p0. ss.
+    - ss. }
+  assert (ONEDEF : forall d1 pub1 main1 l1 ll1,
+    transf_program_step (mkprogram (d1 :: nil) pub1 main1, l1 :: ll1) =
+      do (d2, l2) <- transf_globdef_step (d1, l1);
+      OK (mkprogram (d2 :: nil) pub1 main1, l2 :: ll1)).
+  { i. unfold transf_program_step. simpl prog_defs.
+    destruct (transf_globdefs_step (d1 :: nil) (l1 :: ll1)) eqn:D1. destruct p.
+    unfold transf_globdefs_step in D1. monadInv D1. inv EQ1. ss; rewrite EQ. ss.
+    unfold transf_globdefs_step in D1. unfold bind2 in D1. flatten D1. unfold bind2.
+    flatten; unfold fundef in *; rewrite Eq in Eq0; inv Eq0. }
+  assert (GLOBDEFS_LEN : forall l1 l2 l3 l4, transf_globdefs_step l1 l2 = OK (l3, l4) ->
+    Datatypes.length l1 = Datatypes.length l3 /\ Datatypes.length l2 = Datatypes.length l4).
+  { induction l1; i. inv H. eauto. destruct l2. inv H. eauto.
+    unfold transf_globdefs_step in H. fold transf_globdefs_step in H. monadInv H.
+    exploit IHl1; eauto. i; des; split; s; eauto. }
+  assert (ERRMSG : forall e1 e2 defs ll def l,
+    transf_globdefs_step defs ll = Error e1 -> transf_globdef_step (def, l) = Error e2 -> e1 = e2).
+  { induction defs; i. inv H. destruct ll. inv H.
+    unfold transf_globdefs_step in H. fold transf_globdefs_step in H. unfold bind2 in H. flatten H.
+    eapply IHdefs; eauto. unfold transf_globdef_step in Eq, H0. flatten Eq.
+    unfold bind2 in Eq, H0. flatten Eq. unfold transf_fundef_step in Eq5, Eq4. flatten Eq5.
+    unfold bind2 in Eq5, Eq4. flatten Eq5. unfold transf_function_step in Eq2, Eq1. flatten Eq2. }
+  intros n a1 defs1. revert n a1. remember (Datatypes.length defs1) as len.
+  symmetry in Heqlen. assert (Datatypes.length defs1 <= len) by lia. rewrite <- Heqlen. clear Heqlen.
+  generalize dependent defs1. induction len.
+  - i. inv H. rewrite H2 in H0. symmetry in H0; apply length_zero_iff_nil in H0, H2; clarify.
+    assert (repeatn_monad transf_program_step n (mkprogram nil pub1 main1, nil) =
+      OK ((mkprogram nil pub1 main1), nil)).
+    { generalize n as n0; induction n0; ss. } rewrite H. simpl. clear H.
+    induction n; i.
+    + s. eauto.
+    + rewrite REPEATN. rewrite ONEDEF. rewrite repeatn_monad_def_dist.
+      destruct (transf_globdef_step (a1, l1)) eqn:A1; cycle 1. eauto.
+      destruct p. unfold bind2 at 2 4. simpl bind2. rewrite IHn. eauto.
+  - i. destruct defs1.
+    + assert (repeatn_monad transf_program_step n (mkprogram nil pub1 main1, ll1) =
+        OK ((mkprogram nil pub1 main1), ll1)).
+      { generalize n as n0; induction n0; ss. } rewrite H1. clear H1.
+      simpl.
+      induction n; i. simpl. eauto. rewrite REPEATN. rewrite ONEDEF. rewrite repeatn_monad_def_dist.
+      destruct (transf_globdef_step (a1, l1)) eqn:A1; cycle 1. eauto.
+      destruct p. unfold bind2 at 2 4. simpl bind2. rewrite IHn. eauto. eauto.
+    + simpl in H. generalize dependent defs1. generalize dependent p. induction n.
+      * i. simpl. eauto.
+      * i. rewrite REPEATN. destruct ll1. inv H0. rewrite IHlen; eauto; try lia.
+        unfold transf_program_step at 1. simpl prog_defs; simpl prog_public; simpl prog_main.
+        unfold transf_globdefs_step. fold transf_globdefs_step. rewrite repeatn_monad_def_dist.
+        destruct (transf_globdef_step (a1, l1)) eqn:A1; cycle 1. ss.
+        destruct p0. unfold bind2 at 3. unfold bind2 at 7.
+        rewrite repeatn_monad_def_dist. destruct (transf_globdef_step (p, l)) eqn:PTRANS; cycle 1.
+        s. unfold bind2. flatten; eauto. revert PTRANS Eq. generalize p l p0 l0 e e0.
+        generalize n. induction n0; i. simpl in Eq. inv Eq. rewrite repeatn_monad_def_dist in Eq.
+        unfold bind2 in Eq. flatten Eq. exploit IHn0; eauto. unfold transf_globdef_step in Eq0, PTRANS.
+        unfold bind2 in PTRANS, Eq0. flatten PTRANS. unfold transf_fundef_step in Eq5, Eq2.
+        flatten Eq2. unfold bind2 in Eq5, Eq2. flatten Eq5. unfold transf_function_step in Eq3, Eq1.
+        flatten Eq1. eauto. destruct p1. unfold bind2 at 4. unfold bind2 at 8.
+        rewrite REPEATN. unfold transf_program_step at 2.
+        simpl prog_defs; simpl prog_public; simpl prog_main.
+        destruct (transf_globdefs_step defs1 ll1) eqn:DEFSTRANS. destruct p2.
+        unfold bind2 at 4. unfold bind2 at 3. unfold bind2 at 2. unfold bind2 at 1.
+        unfold bind2 at 6. unfold bind2 at 5. eapply GLOBDEFS_LEN in DEFSTRANS as LEN. des.
+        rewrite (IHn p0 l0 (l2 :: l4)). rewrite IHlen; eauto. lia. inv H0. lia. lia. s. inv H0. lia.
+        s. unfold bind2 at 3. flatten; s. unfold bind2; flatten; eauto.
+        revert Eq0. revert DEFSTRANS. generalize n p0 l0. induction n0; i; eauto. inv Eq0.
+        rewrite repeatn_monad_def_dist in Eq0. symmetry in Eq0. unfold bind2 in Eq0; flatten Eq0.
+        { exploit IHn0; eauto.  } exploit ERRMSG; eauto. i; eauto. clarify.
+        unfold bind2. flatten; cycle 1. revert DEFSTRANS Eq0. generalize n ll1 p0 l0. induction n0.
+        i. inv Eq0. i. rewrite repeatn_monad_def_dist in Eq0. unfold bind2 in Eq0. flatten Eq0.
+        eapply IHn0; eauto. exploit ERRMSG; eauto; i; clarify.
+        revert DEFSTRANS Eq. generalize n ll1 p1 l2. induction n0.
+        i. inv Eq. i. rewrite repeatn_monad_def_dist in Eq. unfold bind2 in Eq. flatten Eq.
+        eapply IHn0; eauto. exploit ERRMSG; eauto; i; clarify.
+Qed.
+
+Lemma find_capture_all_NoDup : forall c clist, clist = find_capture_all c ->
+  list_norepet clist.
+Proof.
+  i. unfold find_capture_all in H. rewrite PTree.fold_spec in H. unfold _find_capture in H.
+  exploit PTree.elements_keys_norepet. instantiate (1 := c). i.
+  remember (PTree.elements c) as celems. clear Heqcelems. generalize dependent clist.
+  induction celems.
+  - i. clarify.
+  - i. destruct a. ss. flatten H.
+    + remember (fun a p => _) as f. enough (forall l1 l2, fold_left f l1 l2 = fold_left f l1 nil ++ l2).
+      rewrite H1 in H. rewrite H. eapply list_norepet_append_commut. ss. econs.
+      ii. rewrite Heqf in H2. inv H0. revert H2 H5. generalize celems. induction celems0.
+      { ss. }
+      { ss. i. rewrite H1 in H2. eapply in_app in H2. des.
+        - exploit IHcelems0; eauto.
+        - destruct a. ss. flatten H2. inv H2; eauto. inv H2; eauto. }
+      inv H0. revert H5. generalize celems as l. induction l.
+      { i; ss. }
+      { i; ss. rewrite H1. eapply list_norepet_append_commut. destruct a; ss. flatten.
+        - ss. econs. inv H5. revert H2. generalize l. induction l0; ss; ii.
+          rewrite H1 in H. rewrite in_app_iff in H; des.
+          + exploit IHl0; eauto.
+          + destruct a; ss. flatten H; inv H; eauto.
+          + inv H5; eauto.
+        - ss. exploit IHl; inv H5; eauto. }
+      induction l1; ss. i. rewrite IHl1. remember (f nil a) as res.
+      rewrite Heqf in Heqres. flatten Heqres.
+      * rewrite (IHl1 res). remember (f l2 a) as res'. rewrite Heqf in Heqres'. rewrite Eq0 in Heqres'.
+        rewrite Heqres'. rewrite Heqres. remember (fold_left f l1 nil). rewrite <- app_assoc. eauto.
+      * rewrite (IHl1 res). remember (f l2 a) as res'. rewrite Heqf in Heqres'. rewrite Eq0 in Heqres'.
+        rewrite Heqres'. rewrite Heqres. remember (fold_left f l1 nil). rewrite <- app_assoc. eauto.
+    + inv H0; eauto.
+Qed.
+
+Lemma filter_preserved : forall l r, ~ In r l -> filter (fun x => negb (Pos.eqb r x)) l = l.
+Proof.
+  induction l; ss; ii. flatten.
+  - rewrite IHl; eauto.
+  - rewrite negb_false_iff in Eq. rewrite Pos.eqb_eq in Eq. exploit H; eauto; ss.
+Qed.
+
+Lemma root_capture_in : forall root l t, list_norepet l -> root_capture root l t -> In root l.
+Proof.
+  assert (forall l d t n, find_parent l (t # d) = Some n -> In n l).
+  { induction l; ss; ii. flatten H; eauto. }
+  i. destruct l as [ | hd tl]; ss.
+  unfold find_capture_root in H1. remember (Datatypes.length tl) as len. generalize dependent tl.
+  revert hd root t. induction len.
+  - i. symmetry in Heqlen; eapply length_zero_iff_nil in Heqlen; clarify. left; ss.
+  - i. ss. flatten H; clarify; eauto. eapply H in Eq as IN.
+    eapply in_split in IN; des. clarify. rewrite filter_app.
+    rewrite (filter_preserved l1); cycle 1.
+    { rewrite app_comm_cons in H0. eapply list_norepet_append_commut in H0. inv H0.
+      ii; eapply H3; eapply in_app_iff; right; eauto. }
+    ss. rewrite Pos.eqb_refl; ss. rewrite filter_preserved; cycle 1.
+    { rewrite app_comm_cons in H0. eapply list_norepet_append_commut in H0. inv H0.
+      ii; eapply H3; eapply in_app_iff; left; eauto. }
+    destruct l1. ss.
+    + destruct l2.
+      * right. left. destruct len; ss.
+      * exploit (IHlen n); eauto. inv H0; eauto.
+    + repeat rewrite <- app_comm_cons in *.
+      assert (len = Datatypes.length (n0 :: l1 ++ l2)).
+      { ss. rewrite app_length in *; ss. lia. }
+      eapply (IHlen n) in H1. des.
+      * right. constructor 2. eapply in_app_iff; right; left. eapply H1.
+      * right. inv H1.
+        { econs; eauto. }
+        { eapply in_app_iff in H2; des.
+          - constructor 2; eapply in_app_iff; left; eauto.
+          - constructor 2; eapply in_app_iff; right; eauto. }
+      * inv H0. inv H5. eapply list_norepet_append_commut in H3. inv H3.
+        econs; eauto.
+        { ii. inv H0.
+          - eapply H2; eapply in_app_iff; right; eauto.
+          - eapply H5; eapply in_app_iff in H1; des; eapply in_app_iff; eauto. }
+        econs; eauto.
+        { ii. eapply in_app_iff in H0; des; eapply H2; eapply in_app_iff; eauto. }
+        eapply list_norepet_append_commut; eauto.
+      * eauto.
+Qed.
+
+Lemma propagate_capture_step_spec : forall t c1 hd1 tl1 c2 l2 root i d s,
+  list_norepet (hd1 :: tl1) ->
+  propagate_capture_step t (c1, hd1 :: tl1) = (c2, l2) ->
+  root = find_capture_root t hd1 tl1 ->
+  c1 ! root = Some i -> is_capture i = Some (d, s) ->
+  Datatypes.length l2 = Datatypes.length tl1 /\ list_norepet l2.
+Proof.
+  i. unfold propagate_capture_step in H0. clarify. rewrite H2 in H0. rewrite H3 in H0.
+  inv H0. remember (find_capture_root t hd1 tl1) as root.
+  assert (In root (hd1 :: tl1)).
+  { exploit root_capture_in; eauto. }
+  apply in_split in H0. des.
+  flatten.
+  - rewrite negb_true_iff in Eq. eapply Pos.eqb_neq in Eq.
+    destruct l1.
+    + inv H0. rewrite <- H4 in Eq; clarify.
+    + inv H0. rewrite H5 in H. rewrite app_comm_cons in H. eapply list_norepet_append_commut in H.
+      inv H. rewrite filter_app. ss. repeat rewrite filter_preserved; cycle 1.
+      ii; eapply H4; eapply in_app_iff; left; eauto.
+      ii; eapply H4; eapply in_app_iff; right; eauto.
+      rewrite Pos.eqb_refl. ss.
+      repeat rewrite app_length. ss. split.
+      * lia.
+      * exploit list_norepet_append_commut; eauto.
+  - rewrite negb_false_iff in Eq. eapply Pos.eqb_eq in Eq; subst hd1.
+    destruct l1; cycle 1.
+    + inv H0. inv H. exfalso; eapply H4; eapply in_app_iff; right; eauto.
+    + inv H0. rewrite filter_preserved; inv H; eauto.
+Qed.
+
+Lemma compute_dom_preserved : forall f t d s root,
+  compute_dom f = Some t ->
+  compute_dom (change_code f (subst_capture_code t d s root (fn_code f))) = Some t.
+Proof.
+  i. unfold compute_dom in *. ss. unfold DS.fixpoint, DS.fixpoint_from in *.
+  remember (subst_capture_code t d s root (fn_code f)) as c'.
+  enough (DS.step (fn_code f) successors_instr (transfer f) =
+    DS.step c' successors_instr (transfer (change_code f c'))).
+  rewrite <- H0. eauto.
+  unfold transfer. fold (transfer f). apply extensionality.
+  i. unfold DS.step. flatten; ss.
+  - clarify. unfold subst_capture_code in Eq2. rewrite PTree.gmap in Eq2.
+    rewrite Eq1 in Eq2. ss. inv Eq2. destruct i; flatten; ss.
+  - clarify. unfold subst_capture_code in Eq2. rewrite PTree.gmap in Eq2.
+    rewrite Eq1 in Eq2. ss.
+  - clarify. unfold subst_capture_code in Eq2. rewrite PTree.gmap in Eq2.
+    rewrite Eq1 in Eq2. ss.
+Qed.
+
+Lemma repeatn_monad_transf_globdef_step : forall f i t n,
+  compute_dom f = Some t ->
+  n >= Datatypes.length (find_capture_all (fn_code f)) ->
+  repeatn_monad transf_globdef_step n (i, Gfun (Internal f), find_capture_all (fn_code f))
+  = OK (i, Gfun (Internal (change_code f (propagate_capture t (fn_code f) (find_capture_all (fn_code f))))), nil).
+Proof.
+  i. remember (find_capture_all (fn_code f)) as caplist.
+  eapply find_capture_all_NoDup in Heqcaplist as HNOREPET.
+  (* rewrite Heqcaplist at 2. *)
+  clear Heqcaplist.
+  (* remember (Datatypes.length caplist) as len. assert (len >= Datatypes.length caplist) by lia. clear Heqlen. *)
+  generalize dependent caplist. generalize dependent f. induction n.
+  - i. assert (caplist = nil). eapply length_zero_iff_nil; eauto; try lia. clarify.
+    ss. unfold propagate_capture. ss. destruct f; ss.
+  - i. rewrite repeatn_monad_def_dist. unfold bind2; flatten; cycle 1.
+    { simpl in Eq. rewrite H in Eq. destruct caplist. simpl in Eq. inv Eq.
+      flatten Eq; simpl in Eq; inv Eq. }
+    unfold transf_globdef_step in Eq. unfold bind2 in Eq. flatten Eq.
+    unfold transf_fundef_step in Eq1. unfold bind2 in Eq1. flatten Eq1.
+    unfold transf_function_step in Eq. rewrite H in Eq. flatten Eq.
+    destruct caplist. inv Eq0. rewrite IHn; eauto. s. lia.
+    rewrite IHn; eauto. simpl. unfold change_code. simpl.
+    enough (forall t c1 c2 hd tl l,
+      list_norepet (hd :: tl) -> propagate_capture_step t (c1, hd :: tl) = (c2, l) ->
+      propagate_capture t c2 l = propagate_capture t c1 (hd :: tl)).
+    erewrite H1; eauto.
+    i. pose proof H2 as H2'. unfold propagate_capture_step in H2. flatten H2.
+    + unfold propagate_capture at 2. simpl propagate_capture_fuel.
+      rewrite Eq. rewrite Eq1. remember (if (negb _) then _ else _) as l'.
+      eapply propagate_capture_step_spec in H2'; eauto.
+      unfold propagate_capture. des. rewrite <- H2'. eauto.
+    + unfold propagate_capture at 2. simpl. rewrite Eq; rewrite Eq1.
+      unfold propagate_capture. ss.
+    + unfold propagate_capture. ss. rewrite Eq. ss.
+    + unfold propagate_capture_step in Eq0. flatten Eq0; try (destruct f; eauto; fail).
+      eapply compute_dom_preserved; eauto.
+    + pose proof Eq0 as Eq0'. unfold propagate_capture_step in Eq0. flatten Eq0; try (ss; lia; fail).
+      eapply propagate_capture_step_spec in Eq0'; eauto. des; eauto. unfold node in *. rewrite Eq0'.
+      ss; lia.
+    + pose proof Eq0 as Eq0'. unfold propagate_capture_step in Eq0. flatten Eq0; try econs.
+      eapply propagate_capture_step_spec in Eq0'; eauto. des; eauto.
+Qed.
+
+(* match_prog definitions for step optimization *)
+Definition match_prog_step (p: program) (tp: program) :=
+  match_program (fun cu f tf => exists l l', transf_fundef_step (f, l) = OK (tf, l')) eq p tp.
+
+Lemma transf_program_step_match p tp l tl :
+  Datatypes.length l = Datatypes.length (prog_defs p) ->
+  transf_program_step (p, l) = OK (tp, tl) -> match_prog_step p tp.
+Proof.
+  unfold transf_program_step; i. monadInv H0.
+  red. unfold match_program, match_program_gen. split; auto.
+  revert x EQ H. generalize l tl. clear l tl. generalize (prog_defs p).
+  induction l; intros.
+  - monadInv EQ. constructor.
+  - destruct a. destruct g as [f | v].
+    + destruct l0.
+      * inv H.
+      * pose proof EQ as EQ'. monadInv EQ. monadInv EQ0.
+        constructor; auto. split; auto. econstructor 1. eapply linkorder_refl.
+        exists l0, x1. unfold transf_globdefs_step in EQ'. fold transf_globdefs_step in EQ'.
+        monadInv EQ'. unfold transf_globdef_step in EQ0. monadInv EQ0. eauto.
+        eapply IHl; eauto.
+    + destruct l0.
+      * inv H.
+      * monadInv EQ. constructor; auto. split; auto. constructor; auto. destruct v.
+        econs; auto.
+        eapply IHl; eauto.
+Qed.
+
+Section PRESERVATION.
+  Lemma assigned_code_spec_subst_capture_code : forall c pc r t d s hd tl,
+    assigned_code_spec (subst_capture_code t d s (find_capture_root t hd tl) c) pc r ->
+    assigned_code_spec c pc r.
+  Proof.
+    ii. inv H; unfold subst_capture_code in H0; rewrite PTree.gmap in H0;
+      destruct (c ! pc) eqn:EPC; ss; inv H0; destruct i; flatten H1; clarify; ss;
+      try inv H1; eauto.
+  Qed.
+
+  Lemma cfg_subst_capture_code : forall f f' t d s hd tl,
+    wf_ssa_function f -> 
+    f' = change_code f (subst_capture_code t d s (find_capture_root t hd tl) (fn_code f)) ->
+    (forall i j, cfg f i j <-> cfg f' i j).
+  Proof.
+    split; i; clarify.
+    - inv H1. econstructor. ss. unfold subst_capture_code.
+      rewrite PTree.gmap. rewrite HCFG_ins. ss. destruct (in_set _ _ && _).
+      + destruct ins; auto.
+      + auto.
+    - inv H1; ss. unfold subst_capture_code in HCFG_ins.
+      rewrite PTree.gmap in HCFG_ins. destruct (fn_code f) ! i eqn:EI.
+      + ss. inv HCFG_ins. destruct (in_set _ _ && _).
+        econstructor; eauto. destruct i0; auto.
+        econstructor; eauto.
+      + inv HCFG_ins.
+  Qed.
+
+  Lemma reached_subst_capture_code : forall f f' t d s hd tl,
+    wf_ssa_function f ->
+    f' = change_code f (subst_capture_code t d s (find_capture_root t hd tl) (fn_code f)) ->
+    (forall i, Dom.reached (cfg f) (fn_entrypoint f) i
+      <-> Dom.reached (cfg f') (fn_entrypoint f') i).
+  Proof.
+    split; i.
+    - rewrite H0; ss. apply star_eq with (cfg f); eauto. ii.
+      rewrite cfg_subst_capture_code in H2; eauto.
+    - ss. apply star_eq with (cfg f'). ii.
+      rewrite cfg_subst_capture_code; eauto. clarify; eauto.
+  Qed.
+
+  Lemma exit_subst_capture_code : forall f f' t d s hd tl,
+    wf_ssa_function f -> 
+    f' = change_code f (subst_capture_code t d s (find_capture_root t hd tl) (fn_code f)) ->
+    (forall i, exit f i <-> exit f' i).
+  Proof.
+    split; i.
+    - unfold exit in *. flatten H1; ss; clarify; ss; unfold subst_capture_code;
+        rewrite PTree.gmap; rewrite Eq; ss; destruct (in_set _ _ && _); eauto.
+    - unfold exit in *. flatten H1; ss; clarify; ss; unfold subst_capture_code in Eq;
+        rewrite PTree.gmap in Eq; destruct (fn_code f) ! i eqn:EFI; clarify; ss;
+        inv Eq; flatten H2; destruct i0; ss; inv H1; auto.
+  Qed.
+
+  Lemma path_subst_capture_code : forall f f' t d s hd tl,
+    wf_ssa_function f -> 
+    f' = change_code f (subst_capture_code t d s (find_capture_root t hd tl) (fn_code f)) ->
+    (forall i j p, SSApath f i p j <-> SSApath f' i p j).
+  Proof.
+    split.
+    - induction 1; go. econstructor 2 with s2; auto. inversion STEP.
+      + econstructor; eauto. rewrite <- reached_subst_capture_code; eauto.
+        rewrite <- cfg_subst_capture_code; eauto.
+      + econstructor; eauto.
+        * rewrite reached_subst_capture_code in CFG; eauto.
+        * rewrite <- exit_subst_capture_code; eauto.
+    - induction 1; eauto.
+      + constructor.
+      + inv STEP; ss.
+        * econstructor; eauto. econstructor; eauto.
+          exploit reached_subst_capture_code; eauto. ii. rewrite H0; eauto.
+          rewrite cfg_subst_capture_code; eauto.
+        * econstructor; eauto. econstructor; eauto.
+          exploit reached_subst_capture_code; eauto. ii. rewrite H0; eauto.
+          rewrite exit_subst_capture_code; eauto.
+  Qed.
+
+  Lemma dom_subst_capture_code : forall f f' t d s hd tl,
+    wf_ssa_function f ->
+    f' = change_code f (subst_capture_code t d s (find_capture_root t hd tl) (fn_code f)) ->
+    (forall i j, dom f i j <-> dom f' i j).
+  Proof.
+    split; i.
+    - inversion H1. constructor. constructor.
+      + rewrite <- reached_subst_capture_code; eauto.
+      + ii. exploit path_subst_capture_code; eauto. ii. rewrite <- H5 in H4.
+        clarify; ss. auto.
+    - inv H1. constructor. ss. constructor.
+      + exploit reached_subst_capture_code; eauto. ii. ss. rewrite H0. eapply RPC'.
+      + ii. exploit path_subst_capture_code; eauto. ii. ss.
+        apply PATH; auto. rewrite <- H1; eauto.
+  Qed.
+
+  Lemma make_predecessors_subst_capture_code : forall f t d s hd tl,
+    wf_ssa_function f ->
+    (Kildall.make_predecessors (fn_code f) successors_instr) =
+    (Kildall.make_predecessors
+      (subst_capture_code t d s (find_capture_root t hd tl) (fn_code f)) successors_instr).
+  Proof.
+    ii.
+    eapply same_successors_same_predecessors. i. repeat rewrite PTree.gmap1.
+    destruct (fn_code f) ! i eqn:EI; destruct (subst_capture_code _ _ _ _ _) ! i eqn:EI';
+    s; unfold subst_capture_code in EI'; rewrite PTree.gmap in EI'; rewrite EI in EI'; ss.
+    inv EI'. flatten. destruct i0; ss.
+  Qed.
+
+  Lemma successors_subst_capture_code : forall f f' t d s hd tl pc,
+    wf_ssa_function f ->
+    f' = change_code f (subst_capture_code t d s (find_capture_root t hd tl) (fn_code f)) ->
+    (successors f) ! pc = (successors f') ! pc.
+  Proof.
+    intros f0 f'0 t d s hd tl pc Hwf Hf'. unfold successors. clarify.
+    repeat rewrite PTree.gmap1. destruct (fn_code f0) ! pc eqn:EPC.
+    eapply subst_capture_code_spec in EPC as EPC'. flatten EPC'; ss;
+    rewrite EPC'; ss; destruct i; ss. ss.
+    unfold subst_capture_code; rewrite PTree.gmap; rewrite EPC; ss.
+  Qed.
+  
+  Lemma use_code_subst_capture_code : forall f f' t d s hd tl pc x i,
+    wf_ssa_function f ->
+    f' = change_code f (subst_capture_code t d s (find_capture_root t hd tl) (fn_code f)) ->
+    (fn_code f) ! (find_capture_root t hd tl) = Some i -> is_capture i = Some (d, s) ->
+    (forall n d, reached f n -> in_set d t # n = true -> dom f d n) ->
+    (* (forall pc' pc'', in_set pc' t # pc'' = true -> pc' <> pc'') -> *)
+    use_code f' x pc -> use_code f x pc \/ (x = d /\ use_code f s pc /\ sdom f (find_capture_root t hd tl) pc).
+  Proof.
+    assert (Hrn: forall x a s d, rename_reg d s a = x -> a = x \/ x = d /\ a = s).
+    { ii. unfold rename_reg in H. flatten H; auto. rewrite Pos.eqb_eq in Eq; clarify; auto. }
+    assert (Hin: forall x d s l, In x (map (rename_reg d s) l) -> In x l \/ x = d /\ In s l).
+    { induction l; auto. ii. ss. des. apply Hrn in H; des; clarify; auto. intuition. }
+    assert (Hbin: forall x d s a, In x (params_of_builtin_arg (rename_barg d s a)) ->
+            In x (params_of_builtin_arg a) \/ x = d /\ In s (params_of_builtin_arg a)).
+    { induction a; ss; ii. des; auto. apply Hrn in H; des; auto.
+      all: apply in_app_iff in H; des;
+      [ exploit IHa1; eauto; i; des; [left; apply in_app_iff; left; auto | right; auto;
+      split; auto; apply in_app_iff; left; auto] |
+      exploit IHa2; eauto; i; des; [left; apply in_app_iff; right; auto | right; split; auto;
+      apply in_app_iff; right; auto ]]. }
+    assert (Hbins: forall x d s l, In x (params_of_builtin_args (map (rename_barg d s) l))
+            -> In x (params_of_builtin_args l) \/ x = d /\ In s (params_of_builtin_args l)).
+    { induction l; auto. ii. ss. apply in_app_iff in H; des.
+      - apply Hbin in H; des. left; apply in_app_iff; left; auto. right; split; auto.
+        apply in_app_iff; left; auto.
+      - exploit IHl; eauto. i; des; intuition; auto. }
+    (* assert (Hrnf: forall x d s f, rename_fn d s f = inl x ->
+            f = inl x \/ x = d /\ f = inl s).
+    { ii. destruct f; ss; inv H. destruct (Pos.eq_dec r s); clarify; auto.
+      right; unfold rename_reg; split; flatten; auto. apply Pos.eqb_neq in Eq; clarify.
+      left; unfold rename_reg; flatten; clarify. apply Pos.eqb_eq in Eq; clarify. } *)
+    ii. clarify. pose proof H4 as H'.
+
+    inv H4; unfold subst_capture_code in H0; ss; rewrite PTree.gmap in H0;
+    destruct (fn_code f) ! pc eqn:EPC; try discriminate; ss; inv H0;
+    destruct (in_set _ _ && _ _) eqn:Eq; try (clarify; left; eauto using use_code; fail);
+    try destruct i0; clarify;
+    apply andb_true_iff in Eq; destruct Eq as [Eq Eq']; apply H3 in Eq as DOM; eauto;
+    try (inv H6; try apply Hin in H5; try apply Hbins in H5; des;
+        [left; eauto using use_code |
+        clarify; right; split; auto; split; auto; eauto using use_code; constructor; auto;
+        ii; clarify; rewrite negb_true_iff in Eq'; rewrite Pos.eqb_neq in Eq'; clarify]; fail).
+    + inv H6. des.
+      * apply Hrn in H5.
+        des; clarify; [left; eauto using use_code | right; split; auto; split; auto].
+        eauto using use_code. econs; eauto. ii; subst pc; rewrite H1 in EPC; inv EPC; ss.
+      * apply Hin in H5. des;
+        [ left; eauto using use_code | clarify; right; split; auto; split; auto ].
+        eauto using use_code. econs; eauto. ii; subst pc; rewrite H1 in EPC; inv EPC; ss.
+    + inv H6. des.
+      * clarify. 
+        (* apply Hrnf in H7. des. destruct s2; inv H7. *)
+        left; eauto using use_code.
+        (* clarify. right; split; auto; split; auto.
+        eauto using use_code. econs; eauto. ii; subst pc; rewrite H1 in EPC; inv EPC; ss. *)
+      * apply Hin in H5; des.
+        (* destruct s2; inv H7. *)
+        left; eauto using use_code. clarify.
+        (* destruct s2; inv H7. *)
+        right; split; auto; split; auto; eauto using use_code.
+        econs; eauto. ii; subst pc; rewrite H1 in EPC; inv EPC; ss.
+    + inv H6. des; clarify.
+      * left; eauto using use_code.
+      * apply Hin in H5; des. eauto using use_code.
+        clarify. right; splits; auto; auto. eauto using use_code.
+        econs; eauto. ii; subst pc; rewrite H1 in EPC; inv EPC; ss.
+    (* + inv H5. des. apply Hin in H5. des. destruct s2; inv H7.
+      left; eauto using use_code. destruct s2; inv H7.
+      clarify; right; split; auto; split; auto; eauto using use_code.
+      econs; eauto. ii; subst pc; rewrite H1 in EPC; inv EPC; ss. *)
+    (* + inv H6. apply Hin in H5. des. destruct s1; inv H7; left; eauto using use_code.
+      destruct s1; inv H7; right; split; auto; split; auto; eauto using use_code.
+      econs; eauto. ii; subst pc; rewrite H1 in EPC; inv EPC; ss. *)
+    + inv H5. destruct (Pos.eq_dec r s). clarify. unfold rename_reg. flatten.
+      right; split; auto; split; auto; eauto using use_code.
+      econs; eauto. ii; subst pc; rewrite H1 in EPC; inv EPC; ss.
+      apply Pos.eqb_neq in Eq0; clarify. left; unfold rename_reg; flatten; clarify.
+      apply Pos.eqb_eq in Eq0; clarify. eauto using use_code.
+    + inv H5. destruct o; ss. inv H4. destruct (Pos.eq_dec r s). clarify.
+      unfold rename_reg. flatten. right; split; auto; split; auto; eauto using use_code.
+      econs; eauto. ii; subst pc; rewrite H1 in EPC; inv EPC; ss.
+      apply Pos.eqb_neq in Eq0; clarify. left; unfold rename_reg; flatten; clarify.
+      apply Pos.eqb_eq in Eq0; clarify. eauto using use_code.
+  Qed.
+
+  Lemma use_subst_capture_code : forall f f' t d s hd tl pc x i,
+    wf_ssa_function f ->
+    f' = change_code f (subst_capture_code t d s (find_capture_root t hd tl) (fn_code f)) ->
+    (fn_code f) ! (find_capture_root t hd tl) = Some i -> is_capture i = Some (d, s) ->
+    (forall n d, reached f n -> in_set d t # n = true -> dom f d n) ->
+    (* (forall pc' pc'', in_set pc' t # pc'' = true -> pc' <> pc'') -> *)
+    use f' x pc -> use f x pc \/ (x = d /\ use f s pc /\ sdom f (find_capture_root t hd tl) pc).
+  Proof.
+    ii. inv H4.
+    eapply use_code_subst_capture_code in H5; des; eauto using use.
+    inv H5; ss. rewrite <- make_predecessors_subst_capture_code in KPRED; ss.
+    left; econstructor 2. econstructor; eauto.
+  Qed.
+
+  Lemma def_subst_capture_code : forall f f' t d s hd tl pc x i,
+    wf_ssa_function f ->
+    f' = change_code f (subst_capture_code t d s (find_capture_root t hd tl) (fn_code f)) ->
+    (fn_code f) ! (find_capture_root t hd tl) = Some i -> is_capture i = Some (d, s) ->
+    (forall n d, reached f n -> in_set d t # n = true -> dom f d n) ->
+    (* (forall pc' pc'', in_set pc' t # pc'' = true -> pc' <> pc'') -> *)
+    def f' x pc -> def f x pc.
+  Proof.
+    ii. inv H4.
+    - ss. inv H5. ss. constructor; auto. ss. constructor. constructor 2.
+      des. eapply use_subst_capture_code in H0; eauto. des; ss.
+      + exists pc; eauto.
+      + clarify. destruct i; ss. destruct e; ss. destruct l; ss. destruct b0; ss.
+        destruct l; ss. destruct b; ss. inv H2. eapply subst_capture_code_spec in H1 as Hs.
+        flatten Hs; exploit H6; ss; econstructor 4; eauto.
+      + auto.
+      + ii. inv H5;
+        eapply subst_capture_code_spec in H7 as Hs; flatten Hs; exploit H6; ss;
+        eauto using assigned_code_spec.
+    - ss. apply assigned_code_spec_subst_capture_code in H5. constructor; eauto.
+    - ss. eauto using def.
+  Qed.
+
+  Lemma subst_capture_code_preserve_wf_ssa_function : forall f t d s hd tl i,
+    wf_ssa_function f ->
+    (forall n d, reached f n -> in_set d t # n = true -> dom f d n) ->
+    (* (forall pc' pc'', in_set pc' t # pc'' = true -> pc' <> pc'') -> *)
+    (fn_code f) ! (find_capture_root t hd tl) = Some i -> is_capture i = Some (d, s) ->
+    wf_ssa_function 
+      (change_code f (subst_capture_code t d s (find_capture_root t hd tl) (fn_code f))).
+  Proof.
+    intros f0 t d s hd tl i Hwf Hdom Hcpt. constructor.
+    - econstructor; eauto. repeat split; ii; ss.
+      + eapply assigned_code_spec_subst_capture_code in H0, H1.
+        exploit assigned_code_unique. eauto. eauto. eapply H0. eauto.
+      + exploit def_def_eq. eauto. eauto. econstructor 3; eapply H0. eauto.
+      + eapply assigned_code_spec_subst_capture_code in H0. 
+        exploit assigned_code_and_phi; eauto.
+      + eapply assigned_code_spec_subst_capture_code in H1.
+        exploit assigned_code_and_phi; eauto.
+      + ii; ss. inv Hwf. inv fn_ssa; eauto. 
+    - ii; ss. split.
+      + ii. apply assigned_code_spec_subst_capture_code in H1; eauto.
+        inv Hwf. exploit fn_ssa_params; eauto. ii. des. eapply H2; eauto.
+      + ii. exploit fn_ssa_params; eauto. ii; intuition. eapply H4; eauto.
+    - ii. rewrite <- dom_subst_capture_code; eauto.
+      eapply def_subst_capture_code in H1 as HDEF; eauto.
+      eapply use_subst_capture_code in H0; eauto. des.
+      + exploit fn_strict; eauto.
+      + clarify. remember (find_capture_root t hd tl) as root.
+        destruct i; ss. destruct e, l; ss. destruct b0, l, b; ss. inv H.
+        exploit def_def_eq. eauto. eauto. econstructor 2. econstructor 4; eauto.
+        ii; clarify. inv H3; ss.
+    - ii. apply assigned_code_spec_subst_capture_code in H1.
+      eapply use_code_subst_capture_code in H0; eauto; des.
+      exploit fn_use_def_code; eauto. clarify. inv H3. exploit NEQ; ii; ss.
+      destruct i; inv H. flatten H3; eapply def_def_eq; eauto.
+    - unfold block_nb_args. ss. ii. rewrite <- make_predecessors_subst_capture_code; eauto.
+      exploit fn_wf_block; eauto.
+    - ii; ss. inv H0. ss.
+      erewrite <- make_predecessors_subst_capture_code in Hpreds; eauto.
+      unfold Kildall.successors_list in H1.
+      erewrite <- successors_subst_capture_code in H1; eauto.
+      destruct (successors f0) ! pc eqn:FPC. exploit (fn_normalized f0); eauto.
+      econstructor; eauto. unfold Kildall.successors_list; rewrite FPC; eauto.
+      i. unfold subst_capture_code; rewrite PTree.gmap; rewrite H0; flatten; ss. inv H1.
+    - split; ss. ii.
+      inv H0; ss. rewrite <- make_predecessors_subst_capture_code in Hpreds; eauto.
+      exploit fn_phicode_inv; eauto; ii. des. elim H0; eauto. econstructor; eauto.
+      ii. exploit fn_phicode_inv; eauto; ii. des. elim H2; eauto. ii.
+      econstructor; eauto. ss. erewrite <-make_predecessors_subst_capture_code; eauto.
+    - ss. ii. exploit reached_subst_capture_code; eauto. ii; ss. rewrite <- H1.
+      destruct (fn_code f0) ! pc eqn:EPC; eauto. exploit wf_ssa_reached; eauto.
+      unfold subst_capture_code in H0; rewrite PTree.gmap in H0; rewrite EPC in H0; ss.
+    - ss. ii. unfold subst_capture_code in *. rewrite PTree.gmap in *; ss.
+      destruct (fn_code f0) ! pc eqn:EPC; ss; inv H0; destruct i0; flatten H1;
+      exploit fn_code_closed; eauto; ii; des; eexists; rewrite H0; ss.
+    - ss. exploit fn_entry; eauto. ii. des. unfold subst_capture_code.
+      rewrite PTree.gmap. rewrite H0. ss. exists s0; flatten; eauto.
+    - ii; ss. rewrite <- cfg_subst_capture_code in H0; eauto.
+      exploit fn_entry_pred; eauto.
+    - ii. inv H0; ss. exploit fn_ext_params_complete; eauto. des.
+      eapply use_subst_capture_code in H1; des; eauto.
+      + exploit fn_ext_params_complete; eauto. econstructor 2; eauto.
+        ii. eelim H3; eauto. inv H0; eapply subst_capture_code_spec in H4; flatten H4;
+        ss; eauto using assigned_code_spec.
+      + clarify. destruct i; inv H. flatten H4; eapply subst_capture_code_spec in Hcpt;
+        flatten Hcpt; eelim H3; eauto.
+    - ii; ss. exploit dom_subst_capture_code; eauto. ii. rewrite <- H2.
+      exploit reached_subst_capture_code; eauto. ii. rewrite <- H3 in H0.
+      exploit fn_dom_test_correct; eauto; ss.
+  Qed.
+
+End PRESERVATION.
+
+(** * Correctness of the optimization *)
+Section FUNCTION_STEP.
+
+  Variables f f' : function.
+  Variables il il' : list node.
+  Hypothesis WF : wf_ssa_function f.
+  Hypothesis STEP : OK (f', il') = transf_function_step (f, il).
+
+  Lemma transf_function_step_phicode :
+    fn_phicode f' = fn_phicode f.
+  Proof.
+    unfold transf_function_step in STEP. flatten STEP. destruct f; ss.
+  Qed.
+
+  Lemma transf_function_step_spec :
+    f = f' /\ il' = nil \/
+    exists domtree root d s pc' hd tl,
+    compute_dom f = Some domtree /\
+    il = hd :: tl /\
+    find_capture_root domtree hd tl = root /\
+    il' = filter (fun x => negb (Pos.eqb root x)) il /\
+    (fn_code f) ! root = Some (Ibuiltin EF_capture ((BA s) :: nil) (BR d) pc') /\
+    f' = change_code f (subst_capture_code domtree d s root (fn_code f)).
+  Proof.
+    unfold transf_function_step in STEP. flatten STEP. destruct il.
+    - left; destruct f; ss. inv Eq0; ss.
+    - unfold propagate_capture_step in Eq0. flatten Eq0.
+      + destruct i; inv Eq2. flatten H0. right.
+        exists t, (find_capture_root t n l0), r, r0, n0, n, l0; ss.
+      + left; destruct f; ss.
+      + left; destruct f; ss.
+  Qed.
+
+  Lemma transf_function_step_instr_spec : forall i pc,
+    (fn_code f) ! pc = Some i ->
+    (fn_code f') ! pc = Some i \/
+    exists root d s pc' domtree,
+      compute_dom f = Some domtree /\
+      root <> pc /\
+      root_capture root il domtree /\
+      in_set root (domtree !! pc) /\
+      (fn_code f) ! root = Some (Ibuiltin EF_capture ((BA s) :: nil) (BR d) pc') /\
+      (fn_code f') ! pc = Some (subst_instr d s i).
+  Proof.
+    pose proof transf_function_step_spec; des; clarify; eauto. i.
+    remember (find_capture_root domtree hd tl) as root.
+    destruct (fn_code (change_code f (subst_capture_code domtree d s root (fn_code f)))) ! pc
+      eqn : PC; unfold change_code, subst_capture_code in PC; simpl in PC;
+      rewrite PTree.gmap in PC; rewrite H0 in PC; simpl in PC. inv PC. flatten; eauto.
+    right. exists (find_capture_root domtree hd tl), d, s, pc', domtree; s. 
+    rewrite andb_true_iff in Eq; des. rewrite negb_true_iff in Eq0.
+    splits; eauto. ii; clarify; rewrite Pos.eqb_neq in Eq0; clarify. inv PC.
+  Qed.
+
+  Lemma transf_function_step_make_predecessors :
+    (Kildall.make_predecessors (fn_code f) successors_instr) =
+    (Kildall.make_predecessors (fn_code f') successors_instr).
+  Proof.
+    eapply same_successors_same_predecessors. i. repeat rewrite PTree.gmap1.
+    destruct (fn_code f) ! i eqn:EI.
+    - pose proof transf_function_step_instr_spec; des; clarify.
+      ss. exploit H; eauto; i; des. rewrite H0; ss. rewrite H5. destruct i0; ss.
+    - pose proof transf_function_step_spec; des; clarify. rewrite EI; ss.
+      unfold change_code; ss. unfold subst_capture_code; flatten.
+      rewrite PTree.gmap. rewrite EI; ss.
+  Qed.
+
+  Lemma transf_function_step_join_point : forall pc,
+    join_point pc f <-> join_point pc f'.
+  Proof.
+    split; i.
+    - inv H. econs. rewrite <- transf_function_step_make_predecessors; eauto. ss.
+    - inv H. econs. rewrite transf_function_step_make_predecessors; eauto. ss.
+  Qed.
+
+  Lemma transf_function_preserve_wf_ssa_function :
+    wf_ssa_function f'.
+  Proof.
+    unfold transf_function_step in STEP.
+    destruct (compute_dom f) eqn:DOMTREE; try inv STEP. flatten H0; try destruct f; ss.
+    exploit subst_capture_code_preserve_wf_ssa_function; eauto. i.
+    exploit compute_dom_correct; eauto.
+  Qed.
+
+End FUNCTION_STEP.
+
+Section CORRECTNESS_STEP.
+
+  Variables prog tprog: program.
+  Variable ll tll: list (list node).
+  Let ge := Genv.globalenv prog.
+  Let tge := Genv.globalenv tprog.
+  (* Let ev_rel2 := ev_rel tprog. *)
+  Hypothesis WF: wf_ssa_program prog.
+  Hypothesis STEP: match_prog_step prog tprog.
+
+  Lemma transf_program_step_wf_ssa: wf_ssa_program tprog.
+  Proof.
+    red. intros.
+    red in WF.
+    (* inv STEP. monadInv H1. ss. remember (prog_defs prog) as defs. clear Heqdefs. *)
+    (* generalize dependent ll. generalize dependent tll. clear ge tge. generalize dependent x. *)
+    (* induction defs; i. *)
+    (* - simpl in EQ. inv EQ. inv H. *)
+    (* - destruct a. destruct g. *)
+      (* + unfold transf_globdefs_step in EQ. fold transf_globdefs_step in EQ. flatten EQ. *)
+        (* * inv H; eauto. clarify; eauto. *)
+        (* * monadInv EQ. destruct f; eauto using wf_ssa_fundef. *)
+          (* unfold transf_globdef_step in EQ0. monadInv EQ0. inv H. *)
+          (* { inv H0. exploit WF; eauto. } *)
+          (* { exploit IHdefs; eauto. } *)
+      (* + destruct x. inv H. destruct p. destruct ll0; inv EQ. inv H. *)
+        (* clarify. exploit WF; eauto. monadInv H1. inv H. clarify. eauto. *)
+    (* Qed. *)
+    inv STEP. intuition. revert H0 H WF.
+    induction 1; intros.
+    - inv H.
+    - inv H1.
+      + inv H. inv H4. des.
+        destruct f1.
+        * unfold transf_fundef_step in H7. monadInv H7. constructor.
+          destruct a1, g. simpl in H. simpl in H1. clarify. exploit WF; eauto. i.
+          inv H. eapply transf_function_preserve_wf_ssa_function; eauto. inv H.
+        * monadInv H7. constructor.
+      + eapply IHlist_forall2; eauto.
+  Qed.
+
+  Lemma function_ptr_translated: forall v f,
+    Genv.find_funct_ptr ge v = Some f ->
+    exists tf l l', transf_fundef_step (f, l) = OK (tf, l') /\
+      Genv.find_funct_ptr tge v = Some tf.
+  Proof.
+    i. eapply @Genv.find_funct_ptr_match in H; eauto. des. eexists; eexists; eauto.
+  Qed.
+
+  Lemma symbols_preserved:
+    forall id,
+    Genv.find_symbol tge id = Genv.find_symbol ge id.
+  Proof (Genv.find_symbol_match STEP).
+
+  Lemma sig_preserved : forall f tf l l',
+    transf_fundef_step (f, l) = OK (tf, l') -> funsig f = funsig tf.
+  Proof.
+    i. destruct f; destruct tf; ss; monadInv H.
+    - flatten EQ; eauto.
+    - destruct e0; eauto.
+  Qed.
+
+  Lemma stacksize_preserved : forall f tf l l',
+    transf_function_step (f, l) = OK (tf, l') -> fn_stacksize f = fn_stacksize tf.
+  Proof.
+    i. destruct f; destruct tf; ss; flatten H.
+  Qed.
+
+  Lemma find_function_translated:
+    forall ros rs rs' f m m' (MEMCHAR: mem_char prog m),
+      concrete_extends m m' -> (forall arg, val_intptr m' (rs # arg) (rs' # arg)) ->
+      find_function ge (ros_to_vos m ros rs) rs = Some f ->
+    exists tf l l', transf_fundef_step (f, l) = OK (tf, l') /\
+      find_function tge (ros_to_vos m' ros rs') rs = Some tf.
+  Proof.
+    unfold find_function. i. destruct ros; simpl ros_to_vos in H1.
+    - specialize (H0 r). flatten H1; try (inv H1; fail).
+      + eapply @Genv.find_funct_match in H1; eauto; des.
+        inv H0; clarify.
+      + eapply @Genv.find_funct_match in H1; eauto; des. simpl ros_to_vos.
+        inv H0; clarify. exploit denormalize_concrete_extends; eauto; i.
+        rewrite H0; eauto.
+      + exploit MEMCHAR; eauto.
+        { ss. des_ifs. eauto. }
+        intros (NE & NE').
+        eapply @Genv.find_funct_match in H1; eauto; des. simpl ros_to_vos.
+        inv H0.
+        * ss; clarify; eauto.
+        * ss; clarify; eauto.
+        (* * flatten; eauto. exfalso; eapply n. rewrite <- concrete_extends_same_perm; eauto. *)
+        * flatten; eauto; flatten Eq.
+          { unfold Genv.find_funct in H1. flatten H1. clarify.
+            exploit Int64.eq_spec; i. rewrite Eq3 in H0. clarify. clear Eq3.
+            (* rewrite Ptrofs.unsigned_zero in p. *)
+            simpl in H8. unfold Mem.ptr2int_v in H8. rewrite Ptrofs.unsigned_zero in H8.
+            destruct (Mem.ptr2int b 0 m') eqn:BINT; cycle 1; try by clarify.
+            rewrite Eq1 in H8.
+            exploit Mem.ptr2int_not_nullptr64_max; eauto.
+            { unfold Mem._weak_valid_pointer. eapply concrete_extends_perm_implies in NE; eauto. }
+            - split. lia. unfold Ptrofs.max_unsigned, Ptrofs.modulus.
+              unfold Ptrofs.wordsize, Wordsize_Ptrofs.wordsize; flatten; ss.
+            - i. exploit Int64.eq_spec; i. rewrite H0 in H4.
+              inv H8. flatten H9; clarify. exploit proof_irr. i.
+              rewrite H5 in H4. exfalso; eapply H4; eauto. }
+          { simpl in H8. unfold Mem.ptr2int_v in H8. flatten H8.
+            eapply Mem.ptr2int_to_denormalize_max in Eq; eauto; cycle 1.
+            { exploit Ptrofs.unsigned_range_2; eauto. }
+            { ss. des_ifs_safe. rewrite Ptrofs.unsigned_zero.
+              eapply concrete_extends_perm_implies; eauto. }
+            eapply Mem.denormalize_info in Eq as INFO; des. rewrite Int64.unsigned_repr in Eq4.
+            2:{ unfold Int64.max_unsigned, Ptrofs.max_unsigned in *.
+                erewrite <- Ptrofs.modulus_eq64; eauto. lia. }
+            rewrite Eq4 in Eq; clarify. rewrite Ptrofs.repr_unsigned; eauto. }
+          unfold Genv.find_funct in H1; flatten H1; clarify.
+          simpl in H8. unfold Mem.ptr2int_v in H8. flatten H8. rewrite Ptrofs.unsigned_zero in Eq.
+          eapply Mem.ptr2int_to_denormalize_max in Eq as DENOM; eauto.
+          2:{ rewrite <- Ptrofs.unsigned_zero at 2 3. eapply Ptrofs.unsigned_range_2. }
+          2:{ eapply concrete_extends_perm_implies; eauto. }
+          des_safe. rewrite Int64.unsigned_repr in Eq4; clarify.
+          eapply Mem.denormalize_info in DENOM. des.
+          unfold Ptrofs.max_unsigned, Int64.max_unsigned in *.
+          erewrite <- Ptrofs.modulus_eq64; eauto. lia.
+    - flatten H1. eapply function_ptr_translated in H1; eauto; des.
+      esplits; eauto. simpl. rewrite symbols_preserved. rewrite Eq0. eauto.
+  Qed.
+
+  Lemma senv_preserved:
+    Senv.equiv ge tge.
+  Proof (Genv.senv_match STEP).
+
+  Lemma val_intptr_same_concrete m m' v v'
+    (SME: (Mem.mem_concrete m) = (Mem.mem_concrete m')):
+    val_intptr m v v' <-> val_intptr m' v v'.
+  Proof.
+    split; i.
+    { inv H; eauto using val_intptr; unfold Mem.to_int, Mem.ptr2int_v, Mem.ptr2int in *.
+      - econs; eauto. rewrite SME in H1. eauto.
+      - econs; eauto. rewrite SME in H1. eauto. }
+    inv H; eauto using val_intptr; unfold Mem.to_int, Mem.ptr2int_v, Mem.ptr2int in *.
+    - econs; eauto. rewrite <- SME in H1. eauto.
+    - econs; eauto. rewrite <- SME in H1. eauto.
+  Qed.
+  
+  Lemma val_intptr_extended_concrete m m' v v'
+    (EXT: forall b addr, (Mem.mem_concrete m) !b = Some addr -> (Mem.mem_concrete m') ! b = Some addr):
+    val_intptr m v v' -> val_intptr m' v v'.
+  Proof.
+    i. inv H; eauto using val_intptr; unfold Mem.to_int, Mem.ptr2int_v, Mem.ptr2int in H1.
+    - econs; eauto. destruct ((Mem.mem_concrete m) ! b) eqn: CONC.
+      2:{ inv H1. }
+      rewrite H0 in H1. inv H1. simpl. unfold Mem.ptr2int. eapply EXT in CONC.
+      rewrite CONC, H0. eauto.
+    - econs; eauto. destruct ((Mem.mem_concrete m) ! b) eqn: CONC.
+      2:{ inv H1. }
+      rewrite H0 in H1. inv H1. simpl. unfold Mem.ptr2int. eapply EXT in CONC.
+      rewrite CONC, H0. eauto.
+  Qed.
+
+  Lemma concrete_extends_val_intptr : forall m m',
+    concrete_extends m m' -> (forall v v', val_intptr m v v' -> val_intptr m' v v').
+  Proof.
+    i; inv H; exploit val_intptr_extended_concrete; eauto.
+  Qed.
+    
+  Inductive match_registers : regset -> regset -> mem -> Prop :=
+  | mr_reg: forall rs rs' m
+      (ARG : forall arg, val_intptr m (rs # arg) (rs' # arg)),
+    match_registers rs rs' m.
+
+  (* Inductive match_functions : function -> regset -> function -> regset -> mem -> node -> Prop :=
+  | mf_same f rs rs' m pc : match_functions f rs f rs' m pc
+  | mf_subst f f' l l' domtree root d s rs rs' pc' m pc
+    (DOMTREE : compute_dom f = Some domtree)
+    (STEP : transf_function_step (f, l) = OK (f', l'))
+    (* (ROOTCPT : find_capture_root domtree hd tl = root) *)
+    (* (FILTER : l' = filter (fun x => negb (Pos.eqb root x)) l) *)
+    (SUBST : f' = change_code f (subst_capture_code domtree d s root (fn_code f)))
+    (CAPT : (fn_code f) ! root = Some (Ibuiltin EF_capture (BA s :: nil) (BR d) pc'))
+    (INSTR : forall i, (fn_code f) ! pc = Some i ->
+              (fn_code f') ! pc = Some i
+              \/ (fn_code f') ! pc = Some (subst_instr d s i) /\ pc <> root /\ dom f root pc)
+    (DSEQUIV : in_set root (domtree !! pc) -> pc <> root ->
+               val_intptr m (rs # d) (rs # s) /\ val_intptr m (rs' # d) (rs' # s)) :
+    match_functions f rs f' rs' m pc. *)
+  (* Lemma transf_function_step_inv : forall f1 l1 f2 l2 domtree d s,
+    compute_dom f1 = Some domtree ->
+    transf_function_step (f1, l1) = OK (f2, l2) ->
+  Inductive capture_in : node -> list node -> Prop :=
+  | capin root l :  *)
+
+  Inductive match_stackframes :
+    list stackframe -> list stackframe -> mem -> node -> reg -> reg -> Prop :=
+  | match_stackframes_nil: forall m' root d s, match_stackframes nil nil m' root d s
+  | match_stackframes_same : forall f domtree st st' rs rs' m' res sp pc root d s root' d' s'
+      (WFF : wf_ssa_function f)
+      (DOMTREE : compute_dom f = Some domtree)
+      (STACK : match_stackframes st st' m' root' d' s')
+      (REGS : match_registers rs rs' m'),
+      match_stackframes
+        ((Stackframe res f sp pc rs) :: st) ((Stackframe res f sp pc rs') :: st') m' root d s
+  | match_stackframes_cons:
+    forall f f' l l' st st' m' res sp pc rs rs'
+      pred sig fn args root root' d s domtree root'' d' s'
+      (WFF : wf_ssa_function f)
+      (STEP : transf_function_step (f, l) = OK (f', l'))
+      (DOMTREE : compute_dom f = Some domtree)
+      (ROOT : root_capture root l domtree)
+      (* (FILTER : l' = filter (fun x => negb (Pos.eqb root x)) l) *)
+      (* (ROOT : l = hd :: tl /\ root = find_capture_root domtree hd tl) *)
+      (CAPT : (fn_code f) ! root = Some (Ibuiltin EF_capture (BA s :: nil) (BR d) root'))
+      (DSEQUIV :
+          sdom f root pc ->
+        val_intptr m' (rs # s) (rs # d) /\ val_intptr m' (rs' # s) (rs' # d))
+      (STACK: match_stackframes st st' m' root'' d' s')
+      (MATCHREGS : match_registers rs rs' m')
+      (PREDINFO : (fn_code f) ! pred = Some (Icall sig fn args res pc)),
+      match_stackframes
+        ((Stackframe res f sp pc rs) :: st)
+        ((Stackframe res f' sp pc rs') :: st') m' root d s.
+
+  Variant match_states: SSA.state -> SSA.state -> Prop :=
+  | match_states_same :
+    forall f st st' sp pc rs rs' m m' domtree root d s
+      (WF : wf_ssa_function f)
+      (DOMTREE : compute_dom f = Some domtree)
+      (STACK : match_stackframes st st' m' root d s)
+      (REGS : forall arg, val_intptr m' (rs # arg) (rs' # arg))
+      (EXTENDS : concrete_extends m m'),
+    match_states (State st f sp pc rs m) (State st' f sp pc rs' m')
+  | match_states_rename :  
+    forall f f' st st' sp pc rs rs' m m' domtree l l' (root : node) s d root'
+      root'' d'' s''
+      (WF : wf_ssa_function f)
+      (STACK : match_stackframes st st' m' root'' d'' s'')
+      (REGS : forall arg, val_intptr m' (rs # arg) (rs' # arg))
+      (DOMTREE : compute_dom f = Some domtree)
+      (STEP : OK (f', l') = transf_function_step (f, l))
+      (ROOT : root_capture root l domtree)
+      (FINFO : f' = change_code f (subst_capture_code domtree d s root (fn_code f)))
+      (CAPT : (fn_code f) ! root = Some (Ibuiltin EF_capture (BA s :: nil) (BR d) root'))
+      (DSEQUIV : sdom f root pc ->
+                val_intptr m' (rs # s) (rs # d) /\ val_intptr m' (rs' # s) (rs' # d))
+      (EXTENDS : concrete_extends m m'),
+      match_states (State st f sp pc rs m) (State st' f' sp pc rs' m')
+  | match_state_call:
+    forall f f' l l' st st' args args' m m' root d s
+      (WF: wf_ssa_fundef f)
+      (STACK: match_stackframes st st' m' root d s)
+      (STEP: OK (f', l') = transf_fundef_step (f, l))
+      (EXTENDS: concrete_extends m m')
+      (BIND: val_intptrist m' args args'),
+    match_states (Callstate st f args m)
+                (Callstate st' f' args' m')
+  | match_states_return:
+    forall st st' m m' v v' root d s
+      (STACK : match_stackframes st st' m' root d s)
+      (EXTENDS : concrete_extends m m')
+      (BIND : val_intptr m' v v'),
+    match_states (Returnstate st v m) (Returnstate st' v' m').
+
+  Lemma transf_initial_states:
+    forall S1, initial_state prog S1 ->
+    exists S2, initial_state tprog S2 /\ match_states S1 S2.
+  Proof.
+    intros. inv H.
+    eapply function_ptr_translated in H2 as TF; des. 
+    econstructor; split.
+    econstructor.
+    - eapply (Genv.init_mem_match STEP); eauto.
+    - rewrite symbols_preserved. rewrite (match_program_main STEP). eauto.
+    - subst tge. eauto.
+    - exploit sig_preserved; eauto; i; clarify. rewrite <- H; ss.
+    - econs; eauto. destruct f; eauto. red in WF.
+      eapply Genv.find_funct_ptr_inversion in H2; des; eauto. econs.
+      econs; eauto. eapply concrete_ext_refl; eauto. econs; eauto.
+    Unshelve. eauto. all: eapply 1%positive.
+  Qed.
+
+  Require Import Simulation.
+
+  (* TODO: Prove these lemmas *)
+  Lemma val_intptr_phi_store : forall m rs rs' k phib arg,
+    (forall arg, val_intptr m (rs # arg) (rs' # arg)) ->
+    val_intptr m (phi_store k phib rs) # arg (phi_store k phib rs') # arg.
+  Proof.
+    intros m rs rs' k phib; revert m rs rs' k; induction phib; eauto. i. ss. flatten; eauto. 
+    destruct (peq arg r).
+    - clarify. repeat rewrite PMap.gss. eauto.
+    - repeat rewrite PMap.gso; eauto.
+  Qed.
+
+  Lemma phi_store_irrelevant : forall f pc phib r rs k,
+    wf_ssa_function f ->
+    (fn_phicode f) ! pc = Some phib ->
+    ~ assigned_phi_spec (fn_phicode f) pc r ->
+    (phi_store k phib rs) # r = rs # r.
+  Proof.
+    ii. assert (forall args, ~ In (Iphi args r) phib). { ii. eapply H1. econs; eauto. }
+    revert H2. generalize phib as b. induction b; ss. i.
+    flatten. rewrite PMap.gso; eauto. ii; clarify. eapply H2; eauto.
+    eapply IHb; eauto.
+  Qed.
+
+  Lemma val_intptr_match_stackframes : forall m m' st st' root d s,
+    match_stackframes st st' m root d s ->
+    (forall v v', val_intptr m v v' -> val_intptr m' v v') ->
+    match_stackframes st st' m' root d s.
+  Proof.
+    i. induction st.
+    - inv H. econs.
+    - inv H.
+      + econs 2; eauto. inv REGS; econs; i; eauto.
+      + econs; eauto. i; des.
+        exploit DSEQUIV; i; des; eauto.
+        econs; eauto. i. inv MATCHREGS. eauto.
+  Qed.
+
+  (* TODO: Consult about these lemmas *)
+  Lemma val_intptr_trans : forall m v1 v2 v3,
+    val_intptr m v1 v2 -> val_intptr m v2 v3 -> val_intptr m v1 v3.
+  Proof.
+    i. inv H; inv H0; try econs; eauto.
+  Qed.
+
+  Lemma val_intptrist_trans : forall m l1 l2 l3,
+    val_intptrist m l1 l2 -> val_intptrist m l2 l3 -> val_intptrist m l1 l3.
+  Proof.
+    i. induction l1.
+    - inv H. inv H0. econs.
+    - inv H. inv H0. econs. eapply val_intptr_trans; eauto. eauto.
+  Qed.
+
+  Lemma eval_operation_wrapper_binded
+    m m' vl vl' sp op v (genv : Genv.t fundef unit)
+    (CONCEXT: concrete_extends m m')
+    (BIND: val_intptrist m' vl vl')
+    (EVAL: PointerOp.eval_operation_wrapper genv sp op vl m = Some v)
+    :
+    exists v',
+      <<EVAL2: PointerOp.eval_operation_wrapper genv sp op vl' m' = Some v'>>
+    /\ <<VIND': val_intptr m' v v'>>.
+  Proof. exploit IntPtrRef.eval_operation_wrapper_binded; eauto. Qed.
+
+  Lemma eval_condition_wrapper_binded
+    m m' vl vl' cond b
+    (CONCEXT: concrete_extends m m')
+    (BIND: val_intptrist m' vl vl')
+    (COND: PointerOp.eval_condition_wrapper cond vl m = Some b):
+    PointerOp.eval_condition_wrapper cond vl' m' = Some b.
+  Proof.
+    unfold PointerOp.eval_condition_wrapper in *. des_ifs.
+    - eapply eval_condition_join_binded; eauto.
+    - eapply eval_condition_binded_no_ptr_binary; eauto.
+  Qed.
+
+  Lemma eval_addressing_binded
+    addr sp vl1 vl2 m1 v1 (genv : Genv.t fundef unit)
+    (* (CONCEXT: concrete_extends m1 m2) *)
+    (BIND: val_intptrist m1 vl1 vl2)
+    (EVAL: eval_addressing genv sp addr vl1 = Some v1)
+    :
+    exists v2, <<EVAL: eval_addressing genv sp addr vl2 = Some v2>>
+        /\ <<BIND: val_intptr m1 v1 v2>>.
+  Proof. eapply IntPtrRef.eval_addressing_binded; eauto. Qed.
+  
+  (* move to IntPtrRel.v *)
+  Lemma loadv_concrete_extends :
+    forall chunk m1 m2 addr1 addr2 v1,
+    concrete_extends m1 m2 ->
+    Mem.loadv chunk m1 addr1 = Some v1 ->
+    val_intptr m2 addr1 addr2 ->
+    exists v2, Mem.loadv chunk m2 addr2 = Some v2 /\ val_intptr m2 v1 v2.
+  Proof.
+    i. Local Transparent Mem.loadv. unfold Mem.loadv in H0. destruct addr1; ss; des_ifs.
+    - inv H1. exploit denormalize_concrete_extends; eauto. i. des.
+      unfold Mem.loadv. ss. des_ifs. eapply load_concrete_extends; eauto.
+    - inv H1; ss.
+      + ss. eapply load_concrete_extends; eauto.
+      + unfold Mem.loadv. ss. des_ifs_safe. exploit Mem.load_valid_access; eauto. i. inv H1.
+        r in H2. specialize (H2 (Ptrofs.unsigned i)). exploit H2.
+        { destruct chunk; ss; lia. }
+        i. eapply Mem.perm_implies in H1. 2:{ eapply perm_any_N. }
+        rewrite <- Mem.valid_pointer_nonempty_perm in H1.
+        exploit Mem.ptr2int_to_denormalize; eauto.
+        { eapply Ptrofs.unsigned_range_2. }
+        { rewrite Mem.valid_pointer_nonempty_perm in *. eapply concrete_extends_perm_implies; eauto. }
+        i. exploit Mem.denormalize_info; eauto. i. des. rewrite Int64.unsigned_repr; cycle 1.
+        { unfold Ptrofs.max_unsigned, Int64.max_unsigned in *. rewrite <- Ptrofs.modulus_eq64; eauto. lia. }
+        rewrite H5. des_ifs.
+        { exfalso. unfold Int64.eq in Heq1. des_ifs. unfold Ptrofs.max_unsigned in CRANGE0.
+          rewrite Ptrofs.modulus_eq64 in CRANGE0; eauto. rewrite Int64.unsigned_repr in e; cycle 1.
+          { unfold Int64.max_unsigned. lia. }
+          rewrite Int64.unsigned_zero in e. subst. lia. }
+        eapply load_concrete_extends; eauto.
+        erewrite Ptrofs.unsigned_repr; eauto.
+  Qed.
+
+  (* move to IntPtrRel.v *)
+  Theorem storev_concrete_extends:
+    forall chunk m1 m2 addr1 v1 m1' addr2 v2, concrete_extends m1 m2 ->
+    Mem.storev chunk m1 addr1 v1 = Some m1' ->
+    val_intptr m2 addr1 addr2 ->
+    val_intptr m2 v1 v2 ->
+    exists m2',
+      Mem.storev chunk m2 addr2 v2 = Some m2'
+      /\ concrete_extends m1' m2'.
+  Proof.
+    i. Local Transparent Mem.storev. unfold Mem.storev in H0. des_ifs.
+    - inv H1. exploit denormalize_concrete_extends; eauto. i. des.
+      unfold Mem.storev. des_ifs. eapply store_concrete_extends; eauto.
+    - inv H1; ss.
+      + ss. eapply store_concrete_extends; eauto.
+      + des_ifs_safe. exploit Mem.store_valid_access_3; eauto. i. inv H1.
+        r in H3. specialize (H3 (Ptrofs.unsigned i)). exploit H3.
+        { destruct chunk; ss; lia. }
+        i. eapply Mem.perm_implies in H1. 2:{ eapply perm_any_N. }
+        rewrite <- Mem.valid_pointer_nonempty_perm in H1.
+        exploit Mem.ptr2int_to_denormalize; eauto.
+        { eapply Ptrofs.unsigned_range_2. }
+        { rewrite Mem.valid_pointer_nonempty_perm in *. eapply concrete_extends_perm_implies; eauto. }
+        i. exploit Mem.denormalize_info; eauto. i. des. rewrite Int64.unsigned_repr; cycle 1.
+        { unfold Ptrofs.max_unsigned, Int64.max_unsigned in *. rewrite <- Ptrofs.modulus_eq64; eauto. lia. }
+        rewrite H6. eapply store_concrete_extends; eauto.
+  Qed.
+
+  Lemma free_concrete_extends:
+    forall m1 m2 b lo hi m1', concrete_extends m1 m2 -> Mem.free m1 b lo hi = Some m1' ->
+    exists m2',
+      Mem.free m2 b lo hi = Some m2'
+      /\ concrete_extends m1' m2'.
+  Proof. i. eapply IntPtrRel.free_concrete_extends; eauto. Qed.
+
+  Lemma alloc_concrete_extends:
+    forall m1 m2 b lo hi m1', concrete_extends m1 m2 -> Mem.alloc m1 lo hi = (m1', b) ->
+    exists m2',
+      Mem.alloc m2 lo hi = (m2', b)
+      /\ concrete_extends m1' m2'.
+  Proof. i. eapply IntPtrRel.alloc_concrete_extends; eauto. Qed.
+  
+  Lemma free_val_intptr: forall m1 m2 b lo hi v1 v2,
+    Mem.free m1 b lo hi = Some m2 -> val_intptr m1 v1 v2 -> val_intptr m2 v1 v2.
+  Proof. i. eapply IntPtrRel.free_val_intptr; eauto. Qed.
+  
+  Lemma storev_val_intptr : forall m1 m2 chunk addr v v1 v2,
+    Mem.storev chunk m1 addr v = Some m2 -> val_intptr m1 v1 v2 <-> val_intptr m2 v1 v2.
+  Proof.
+    i. exploit Mem.storev_concrete; eauto. i. exploit val_intptr_same_concrete; eauto.
+  Qed.
+
+  Lemma alloc_val_intptr :
+    forall m1 m2 b lo hi v1 v2, Mem.alloc m1 lo hi = (m2, b) ->
+      val_intptr m1 v1 v2 -> val_intptr m2 v1 v2.
+  Proof. i. eapply IntPtrRel.alloc_val_intptr; eauto. Qed.
+
+  (* Lemma find_function_binded : forall m rs rs' genv ros, *)
+  (*   (forall arg, val_intptr m (rs # arg) (rs' # arg)) -> *)
+  (*   find_function genv ros rs = find_function genv ros rs'. *)
+
+  Lemma eval_builtin_arg_val_intptr :
+    forall (a :(builtin_arg reg)) v1 (ge : Genv.t fundef unit) e1 e2 sp m1 m2,
+      (forall a, val_intptr m2 (e1 a) (e2 a)) -> concrete_extends m1 m2 ->
+      eval_builtin_arg ge e1 sp m1 a v1 ->
+    exists v2, eval_builtin_arg ge e2 sp m2 a v2 /\ val_intptr m2 v1 v2.
+  Proof.
+    i. ginduction H1; ii; try by (esplits; eauto; econs).
+    - exploit loadv_concrete_extends; eauto.
+      { eapply val_intptr_refl. }
+      i. des. esplits; eauto. econs; eauto.
+    - esplits; eauto; [econs|]. eapply val_intptr_refl.
+    - exploit loadv_concrete_extends; eauto.
+      { eapply val_intptr_refl. }
+      i. des. esplits; eauto. econs; eauto.
+    - esplits; eauto; [econs|]. eapply val_intptr_refl.
+    - exploit IHeval_builtin_arg1; try eapply H1_; eauto. i. des.
+      exploit IHeval_builtin_arg2; try eapply H1_0; eauto. i. des.
+      esplits; eauto. econs; eauto. unfold Val.longofwords. des_ifs_safe.
+      destruct vhi; try by econs. destruct vlo; try by econs.
+      inv H2; inv H4. eapply val_intptr_refl.
+    - des_ifs_safe.
+      exploit IHeval_builtin_arg1; try eapply H1_; eauto. i. des.
+      exploit IHeval_builtin_arg2; try eapply H1_0; eauto. i. des.
+      esplits; eauto; [econs; eauto|]. des_ifs_safe. eapply addl_bind; eauto.
+  Qed.
+
+  Lemma eval_builtin_args_val_intptr :
+    forall (al : list (builtin_arg reg)) vl1 (ge : Genv.t fundef unit) e1 e2 sp m1 m2,
+      (forall a, val_intptr m2 (e1 a) (e2 a)) -> concrete_extends m1 m2 ->
+      eval_builtin_args ge e1 sp m1 al vl1 ->
+    exists vl2, eval_builtin_args ge e2 sp m2 al vl2 /\ val_intptrist m2 vl1 vl2.
+  Proof.
+    i. ginduction H1; ss; ii.
+    - esplits; eauto; econs.
+    - exploit IHlist_forall2; try eapply H2; eauto. i. des.
+      exploit eval_builtin_arg_val_intptr; eauto. i. des.
+      esplits; eauto.
+      + econs; eauto.
+      + econs; eauto.
+  Qed.
+
+  Lemma external_call_concrete_extends :
+    forall ef ge vargs m1 t vres m2 m1' vargs' (INT: ~ is_external_ef ef) gmtgt (TINIT: ge_binded ge m1' gmtgt),
+    external_call ef ge vargs m1 t vres m2 ->
+    concrete_extends m1 m1' ->
+    val_intptrist m1' vargs vargs' ->
+    exists vres', exists t', exists m2',
+      tr_rel (ev_rel gmtgt) t t'
+    /\ external_call ef ge vargs' m1' t' vres' m2'
+    /\ val_intptr m2' vres vres'
+    /\ concrete_extends m2 m2'.
+  Proof.
+    i. exploit external_call_spec; eauto. i.
+    exploit (ec_mem_concrete_extends); eauto. i. des. esplits; eauto.
+  Qed.
+
+  Lemma external_call_concrete_extends_backward :
+    forall ef ge vargs m1 t' vres' m2' m1' vargs' (EXT: is_external_ef ef) gmtgt (TINIT: ge_binded ge m1' gmtgt),
+    external_call ef ge vargs' m1' t' vres' m2' -> concrete_extends m1 m1' ->
+    val_intptrist m1' vargs vargs' ->
+    (exists t vres m2,
+      <<TRREL: tr_rel (ev_rel gmtgt) t t'>>
+    /\ <<CALLSRC: external_call ef ge vargs m1 t vres m2>>
+    /\ <<RETV: val_intptr m2' vres vres'>>
+    /\ <<MEM: concrete_extends m2 m2'>>
+    /\ <<PRIV: Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'>>)
+    \/ <<UBSRC: (forall t vres m2, ~ external_call ef ge vargs m1 t vres m2)>>
+    \/ (<<PTERM: ~trace_intact t'>> /\
+       exists t vres1 m21,
+         <<CALLSRC: external_call ef ge vargs m1 t vres1 m21>> /\
+         <<SUB: exists tl, tr_rel (ev_rel gmtgt) t (Eapp (trace_cut_pterm t') tl)>>).
+  Proof.
+    i. eapply external_call_spec_backward in EXT. exploit ec_concrete_extends_backward; eauto.
+  Qed.
+
+  Lemma external_call_binds :
+    forall ef ge vargs m1 t vres m2,
+    external_call ef ge vargs m1 t vres m2 ->
+    (forall b caddr, m1.(Mem.mem_concrete) ! b = Some caddr -> m2.(Mem.mem_concrete) ! b = Some caddr).
+  Proof. i. eapply ec_binds; eauto. eapply external_call_common_spec. Qed.
+
+  Lemma external_call_binds' :
+    forall ef ge vargs m1 t vres m2,
+    external_call ef ge vargs m1 t vres m2 ->
+    forall v1 v2, val_intptr m1 v1 v2 -> val_intptr m2 v1 v2.
+  Proof.
+    i. inv H0; econs; eauto; unfold Mem.to_int, Mem.ptr2int_v, Mem.ptr2int in *; flatten H2; 
+    exploit external_call_binds; eauto; i; rewrite H0; eauto.
+  Qed.
+
+  Lemma eval_builtin_arg_rename_barg' : forall ge rs sp m a v d s,
+    val_intptr m (rs # s) (rs # d) ->
+    eval_builtin_arg ge (fun r => rs # r) sp m a v ->
+    exists v',
+      eval_builtin_arg ge (fun r => rs # r) sp m (rename_barg d s a) v' /\
+      val_intptr m v v'.
+  Proof.
+    induction a; ss; i; try (inv H0; eexists; split; try econs; eauto using val_intptr_refl; fail).
+    - destruct (peq x s).
+      + clarify. unfold rename_reg. rewrite Pos.eqb_refl.
+        inv H0. eexists; split; eauto. econs.
+      + unfold rename_reg. rewrite <- Pos.eqb_neq in n. rewrite n.
+        eexists; split; eauto; try econs. eapply val_intptr_refl.
+    - inv H0. exploit IHa1; eauto; i; des. exploit IHa2; eauto; i; des.
+      eexists. split. econs; eauto. unfold Val.longofwords.
+      inv H1; inv H4; eauto using val_intptr_refl; try econs.
+    - inv H0. exploit IHa1; eauto; i; des. exploit IHa2; eauto; i; des.
+      eexists. split. econs; eauto. flatten; [ eapply addl_bind | eapply add_bind ]; eauto.
+      all : eapply concrete_ext_refl.
+  Qed.
+  
+  Lemma init_regs_val_intptr : forall m args args' vl arg,
+    val_intptrist m args args' ->
+    val_intptr m (init_regs args vl) # arg (init_regs args' vl) # arg.
+  Proof.
+    intros m args args' vl; revert m args args'; induction vl; ss; i.
+    - repeat rewrite PMap.gi; econs.
+    - flatten.
+      + repeat rewrite PMap.gi; econs.
+      + inv H.
+      + inv H.
+      + destruct (peq a arg); clarify.
+        { repeat rewrite PMap.gss. inv H; eauto. }
+        { repeat rewrite PMap.gso; eauto. eapply IHvl; inv H; eauto. }
+  Qed.
+
+  Lemma senv_preserved_ge_bind
+      g tg m gm
+      (IBIND : ge_binded tg m gm)
+      (SEQ : Senv.equiv g tg):
+    ge_binded g m gm.
+  Proof.
+    unfold ge_binded in *. i. destruct SEQ. des.
+    rewrite <- H1 in H0. rewrite <- H2 in H. eapply IBIND; eauto.
+  Qed.
+
+  Section STEPSIM.
+
+  Variables st_init_tgt st_init_tgt1: (SSA.semantics tprog).(state).
+  Hypothesis INIT1: (SSA.semantics tprog).(initial_state) st_init_tgt.
+  Hypothesis ICAP1: (SSA.semantics tprog).(initial_capture) st_init_tgt st_init_tgt1.
+  Definition gmtgt : ident -> option Z := (SSA.semantics tprog).(initial_pimap) st_init_tgt1.
+  
+  Lemma step_simulation:
+    forall S1 t S2 (STC: state_char prog S1), IStep (SSA.semantics prog) S1 t S2 ->
+    forall S1' (IBIND: ge_binded_state tge S1' gmtgt), match_states S1 S1' ->
+    exists t' S2', tr_rel (ev_rel gmtgt) t t' /\ DStep (SSA.semantics tprog) S1' t' S2' /\ match_states S2 S2'.
+  Proof.
+    assert (VALIST : forall rs rs' m, (forall arg, val_intptr m rs # arg rs' # arg) ->
+            forall args, val_intptrist m (rs ## args) (rs' ## args)).
+    { i. induction args; eauto. econs. econs; eauto. }
+    assert (RENAME : forall d s, rename_reg d s s = d).
+    { i. unfold rename_reg. flatten; eauto. rewrite Pos.eqb_neq in Eq; clarify. }
+    assert (RENAMEN : forall r r' r'', r <> r' -> rename_reg r'' r' r = r).
+    { i. unfold rename_reg. flatten; eauto. rewrite Pos.eqb_eq in Eq; clarify. }
+    assert (VALIST' : forall m rs d s args, val_intptr m (rs # s) (rs # d) ->
+            val_intptrist m rs ## args rs ## (map (rename_reg d s) args)).
+    { i. induction args; ss; i. econs. econs; eauto. destruct (peq a s).
+      clarify. rewrite RENAME; eauto. rewrite RENAMEN; eauto. eapply val_intptr_refl. }
+    destruct 2. generalize dependent S2. rename H into INT. unfold is_internal in INT.
+    induction 1; intros S1' IBIND MS.
+    - (* Inop njp *)
+      inv MS.
+      + eexists. eexists. splits;[econs | |]. DStep_tac2. econs; eauto. econs; eauto.
+      + eexists. eexists; splits;[econs | |]. eapply (transf_function_step_instr_spec _ _ _ _ _ STEP0) in H as H'. des.
+        * DStep_tac2. econs; eauto. ii. eapply transf_function_step_join_point in H1; eauto.
+        * DStep_tac2. econs; eauto. ii. eapply transf_function_step_join_point in H1; eauto.
+        * econs; eauto. i; des; eauto. eapply DSEQUIV. econs.
+          eapply (@Dom.sdom_dom_pred node peq). eapply H1. eauto. econs; eauto. ii; clarify.
+    - (* Inop jp *)
+      inv MS.
+      + eexists. eexists; splits;[econs | |]. DStep_tac2. econstructor 2; eauto. econs; eauto.
+        i; eapply val_intptr_phi_store; eauto.
+      + eexists. eexists; splits;[econs | |]. eapply (transf_function_step_instr_spec _ _ _ _ _ STEP0) in H as H'. des.
+        * DStep_tac2. econstructor 2; eauto.
+          rewrite <- transf_function_step_join_point; eauto.
+          exploit transf_function_step_make_predecessors; eauto. i. rewrite <- H3. eauto.
+        * DStep_tac2. econstructor 2; eauto.
+          rewrite <- transf_function_step_join_point; eauto.
+          exploit transf_function_step_make_predecessors; eauto. i. rewrite <- H3. eauto.
+        * econs; eauto. i. exploit val_intptr_phi_store; eauto.
+          i. exploit DSEQUIV; i. econs. eapply (@Dom.sdom_dom_pred node peq); eauto.
+          econs; eauto. ii; clarify. des. split.
+          { repeat erewrite phi_store_irrelevant; eauto.
+            ii. exploit unique_def_elim1; eauto. inv WF0; eauto. ii.
+            eapply (@Dom.sdom_not_dom node peq); eauto. exploit fn_strict; eauto.
+            econs. eapply UIbuiltin; eauto. ss; eauto. }
+          { repeat erewrite phi_store_irrelevant; eauto.
+            ii. exploit unique_def_elim1; eauto. inv WF0; eauto.
+            ii. eapply (@Dom.sdom_not_dom node peq); eauto. exploit fn_strict; eauto.
+            econs. eapply UIbuiltin; eauto. ss; eauto. }
+    - (* Iop *)
+      inv MS.
+      + erewrite PointerOp.eval_operation_wrapper_preserved in H0.
+        eapply eval_operation_wrapper_binded in H0 as EXISTS; eauto; des.
+        eexists. eexists. splits;[econs | |]. DStep_tac2. econstructor 3; eauto.
+        econs; eauto. i. destruct (peq arg res); clarify.
+        { repeat rewrite PMap.gss; eauto. } { repeat rewrite PMap.gso; eauto. }
+        i. exploit symbols_preserved; eauto.
+      + erewrite PointerOp.eval_operation_wrapper_preserved in H0.
+        eapply eval_operation_wrapper_binded in H0 as EXISTS; eauto; des.
+        eapply subst_capture_code_spec' in H as H'; eauto. des.
+        * eexists. eexists. splits;[econs | |]. DStep_tac2; try rewrite Heq in H'; inv H'.
+          econstructor 3. eapply H2. eapply EVAL2.
+          econs; eauto. i. destruct (peq arg res); clarify.
+          { repeat rewrite PMap.gss; eauto. } { repeat rewrite PMap.gso; eauto. }
+          i. exploit DSEQUIV; i. econs. eapply (@Dom.sdom_dom_pred node peq); eauto.
+          econs; eauto. ii; clarify. des. split.
+          { replace (rs # res <- v) # d with rs # d; eauto. destruct (peq res s0).
+            - clarify. assert (sdom f root pc).
+              { econs. eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto.
+                ii; clarify. }
+              assert (def f s0 pc). econs; eauto. exploit (@Dom.sdom_not_dom node peq).
+              eapply H4. exploit fn_strict; eauto. econs. eapply UIbuiltin; eauto. ss. eauto.
+              i; ss.
+            - rewrite PMap.gso; eauto.
+            - rewrite PMap.gso; eauto. ii; clarify. def_def f res root pc; i; clarify. }
+          { rewrite (@PMap.gso _ d). destruct (peq res s0).
+            - clarify. assert (sdom f root pc).
+              { econs. eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto.
+                ii; clarify. }
+              assert (def f s0 pc). econs; eauto. exploit (@Dom.sdom_not_dom node peq).
+              eapply H4. exploit fn_strict; eauto. econs. eapply UIbuiltin; eauto. ss. eauto.
+              i; ss.
+            - rewrite PMap.gso; eauto.
+            - ii; clarify. def_def f res root pc; i; clarify. }
+        * eapply eval_operation_wrapper_binded in EVAL2 as EXISTS'; eauto; des.
+          ss. eexists. eexists. splits;[econs | |]. DStep_tac2. econstructor 3. eapply H'. ss. eapply EVAL0.
+          econs; eauto. i. destruct (peq arg res); clarify.
+          { repeat rewrite PMap.gss; eauto. eapply val_intptr_trans; eauto. }
+          { repeat rewrite PMap.gso; eauto. }
+          i. exploit DSEQUIV; i. econs. eapply (@Dom.sdom_dom_pred node peq); eauto.
+          econs; eauto. ii; clarify. des; split.
+          { rewrite (@PMap.gso _ d); eauto. destruct (peq res s0).
+            - clarify. assert (sdom f root pc).
+              { econs. eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto.
+                ii; clarify. }
+              assert (def f s0 pc). econs; eauto. exploit (@Dom.sdom_not_dom node peq).
+              eapply H4. exploit fn_strict; eauto. econs. eapply UIbuiltin; eauto. ss. eauto.
+              i; ss.
+            - rewrite PMap.gso; eauto.
+            - ii; clarify. def_def f res root pc; i; clarify. }
+          { rewrite (@PMap.gso _ d); eauto. destruct (peq res s0).
+            - clarify. assert (sdom f root pc).
+              { econs. eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto.
+                ii; clarify. }
+              assert (def f s0 pc). econs; eauto. exploit (@Dom.sdom_not_dom node peq).
+              eapply H4. exploit fn_strict; eauto. econs. eapply UIbuiltin; eauto. ss. eauto.
+              i; ss.
+            - rewrite PMap.gso; eauto.
+            - ii; clarify. def_def f res root pc; i; clarify. }
+          exploit concrete_ext_refl; eauto. destruct (classic (use_code f s0 pc)).
+          { eapply VALIST'. eapply DSEQUIV; eauto. econs; eauto.
+            eapply compute_dom_correct in H'0; eauto. }
+          { assert (~ In s0 args). ii; eapply H1; econs; eauto. revert H2; generalize args.
+            induction args0; ss; i. econs; eauto. econs; eauto. destruct (peq a s0).
+            clarify. exfalso; eapply H2; eauto. rewrite RENAMEN; eauto. eapply val_intptr_refl. }
+        * i; exploit symbols_preserved; eauto.
+    - (* Iload *)
+      inv MS.
+      + eapply eval_addressing_binded in H0 as EVAL'; des; eauto.
+        eapply loadv_concrete_extends in EXTENDS as LOAD; des; eauto.
+        eexists. eexists. splits;[econs | |]. DStep_tac2. econstructor 4; eauto.
+        erewrite eval_addressing_preserved. eapply EVAL. eapply symbols_preserved.
+        econs; eauto. i. destruct (peq arg dst); clarify.
+        { repeat rewrite PMap.gss; eauto. } { repeat rewrite PMap.gso; eauto. }
+      + eapply subst_capture_code_spec' in H as INSTR'; des; eauto.
+        * eapply eval_addressing_binded in H0 as EVAL'; des; eauto.
+          eapply loadv_concrete_extends in EXTENDS as LOAD; des; eauto.
+          eexists. eexists. splits;[econs | |]. DStep_tac2; try rewrite Heq in INSTR'; inv INSTR'.
+          econstructor 4; eauto.
+          erewrite eval_addressing_preserved. eapply EVAL. eapply symbols_preserved.
+          econs; eauto. i. destruct (peq arg dst); clarify.
+          { repeat rewrite PMap.gss; eauto. } { repeat rewrite PMap.gso; eauto. }
+          i. exploit DSEQUIV; i. econs. eapply (@Dom.sdom_dom_pred node peq); eauto.
+          econs; eauto. ii; clarify. des. split.
+          { rewrite (@PMap.gso _ d). destruct (peq dst s0).
+            - clarify. assert (sdom f root pc).
+              { econs. eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto. ii; clarify. }
+              assert (def f s0 pc). econs; eauto. exploit (@Dom.sdom_not_dom node peq).
+              eapply H2. exploit fn_strict; eauto. econs. eapply UIbuiltin; eauto. ss. eauto.
+              i; ss. inv H5. exploit (@Dom.dom_antisym node peq); eauto. i; clarify. ss.
+            - rewrite PMap.gso; eauto.
+            - ii; clarify. def_def f dst root pc; i; clarify. }
+          { rewrite (@PMap.gso _ d). destruct (peq dst s0).
+            - clarify. assert (sdom f root pc).
+              { econs. eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto. ii; clarify. }
+              assert (def f s0 pc). econs; eauto. exploit (@Dom.sdom_not_dom node peq).
+              eapply H2. exploit fn_strict; eauto. econs. eapply UIbuiltin; eauto. ss. eauto.
+              i; ss. inv H5. exploit (@Dom.dom_antisym node peq); eauto. i; clarify. ss.
+            - rewrite PMap.gso; eauto.
+            - ii; clarify. def_def f dst root pc; i; clarify. }
+        * eapply eval_addressing_binded in H0 as EVAL'; des; eauto.
+          eapply eval_addressing_binded in EVAL; des.
+          eapply loadv_concrete_extends in EXTENDS as LOAD; des; eauto.
+          eapply loadv_concrete_extends in LOAD; des; eauto.
+          eexists. eexists. splits;[econs | |]. DStep_tac2; try rewrite Heq in INSTR'; inv INSTR'.
+          econstructor 4. eapply H3. erewrite eval_addressing_preserved.
+          eapply EVAL0. eapply symbols_preserved. eapply LOAD.
+          econs; eauto. i. destruct (peq arg dst); clarify.
+          { repeat rewrite PMap.gss; eauto. eapply val_intptr_trans; eauto. }
+          { repeat rewrite PMap.gso; eauto. }
+          i. exploit DSEQUIV; i. econs. eapply (@Dom.sdom_dom_pred node peq); eauto.
+          econs; eauto. ii; clarify. des. split.
+          { rewrite (@PMap.gso _ d). destruct (peq dst s0).
+            - clarify. assert (sdom f root pc).
+              { econs. eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto. ii; clarify. }
+              assert (def f s0 pc). econs; eauto. exploit (@Dom.sdom_not_dom node peq).
+              eapply H2. exploit fn_strict; eauto. econs. eapply UIbuiltin; eauto. ss. eauto.
+              i; ss. inv H5. exploit (@Dom.dom_antisym node peq); eauto. i; clarify. ss.
+            - rewrite PMap.gso; eauto.
+            - ii; clarify. def_def f dst root pc; i; clarify. }
+          { rewrite (@PMap.gso _ d). destruct (peq dst s0).
+            - clarify. assert (sdom f root pc).
+              { econs. eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto. ii; clarify. }
+              assert (def f s0 pc). econs; eauto. exploit (@Dom.sdom_not_dom node peq).
+              eapply H2. exploit fn_strict; eauto. econs. eapply UIbuiltin; eauto. ss. eauto.
+              i; ss. inv H5. exploit (@Dom.dom_antisym node peq); eauto. i; clarify. ss.
+            - rewrite PMap.gso; eauto.
+            - ii; clarify. def_def f dst root pc; i; clarify. }
+          eapply concrete_ext_refl.
+          destruct (classic (use_code f s0 pc)).
+          { eapply VALIST'. eapply DSEQUIV; eauto. econs; eauto.
+            eapply compute_dom_correct; eauto. }
+          { assert (~ In s0 args). ii. eapply H2. econstructor 2; eauto.
+            revert H3; generalize args.
+            induction args0; ss; i. econs; eauto. econs; eauto. destruct (peq a0 s0).
+            clarify. exfalso; eapply H3; eauto. rewrite RENAMEN; eauto. eapply val_intptr_refl. }
+    - (* Istore *)
+      inv MS.
+      + eapply eval_addressing_binded in H0 as EVAL'; des; eauto.
+        eapply storev_concrete_extends in H1; des; eauto.
+        eexists. eexists. splits;[econs | |]. DStep_tac2. econstructor 5; eauto.
+        erewrite eval_addressing_preserved. eapply EVAL. eapply symbols_preserved.
+        econs; eauto. eapply val_intptr_match_stackframes. eapply STACK. i.
+        erewrite <- storev_val_intptr; eauto. i. erewrite <- storev_val_intptr; eauto. 
+      + remember (change_code f (subst_capture_code domtree d s0 root (fn_code f))) as f'.
+        eapply subst_capture_code_spec' in H as INSTR'; eauto; des.
+        * eapply eval_addressing_binded in H0 as EVAL'; des; eauto.
+          eapply storev_concrete_extends in H1; des; eauto.
+          eexists. eexists. splits;[econs | |]. DStep_tac2; try rewrite Heq in INSTR'; inv INSTR'.
+          econstructor 5; eauto.
+          erewrite eval_addressing_preserved. eapply EVAL. eapply symbols_preserved.
+          econs; eauto. eapply val_intptr_match_stackframes. eapply STACK.
+          i. erewrite <- storev_val_intptr; eauto. i. erewrite <- storev_val_intptr; eauto. 
+          clarify; eauto.
+          i. exploit DSEQUIV; eauto. econs.
+          eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto. ii; clarify. i; des. split;
+          eapply val_intptr_same_concrete with m'0; eauto; exploit Mem.storev_concrete; eauto.
+        * assert (exists a', eval_addressing (globalenv (SSA.semantics tprog)) sp
+                  addr (rs' ## (map (rename_reg d s0) args)) = Some a' /\ val_intptr m'0 a a').
+          { exploit eval_addressing_binded; eauto. i; des.
+            rewrite (eval_addressing_preserved (globalenv (SSA.semantics tprog))) in EVAL.
+            exploit eval_addressing_binded; i; des. 3:{ exists v0; eauto. }
+            2:{ erewrite <- eval_addressing_preserved in H0. eapply H0. 
+                i; exploit symbols_preserved; eauto. }
+            eapply val_intptrist_trans. eapply VALIST; eauto.
+            eapply VALIST'. exploit DSEQUIV; i; des; eauto. econs.
+            eapply compute_dom_correct; eauto. ii; clarify. i; exploit symbols_preserved; eauto. }
+          des. eapply storev_concrete_extends in H1; i; des.
+          eexists. eexists. splits;[econs | |]. DStep_tac2. econstructor 5; eauto.
+          econs; eauto. eapply val_intptr_match_stackframes. eapply STACK.
+          i; erewrite <- storev_val_intptr; eauto. i; erewrite <- storev_val_intptr; eauto.
+          i. exploit DSEQUIV; i. econs. eapply (@Dom.sdom_dom_pred node peq); eauto.
+          econs; eauto. ii; clarify. des.
+          split; erewrite <- storev_val_intptr; i; eauto. eauto. eauto.
+          destruct (peq src s0). 
+          { clarify. rewrite RENAME. exploit DSEQUIV. econs. eapply compute_dom_correct; eauto.
+            ii; clarify. i; des; eauto. eapply val_intptr_trans; eauto. }
+          { rewrite RENAMEN; eauto.  }
+    - (* Icall *)
+      inv MS.
+      + eapply find_function_translated in H0 as FIND; des; cycle 1; eauto.
+        erewrite sig_preserved in H; eauto.
+        eexists. eexists. splits;[econs | |].
+        { DStep_tac2. econstructor 6; eauto. }
+        econs; eauto. eapply find_function_prop; eauto.
+        exploit match_stackframes_same; i; eauto. econs; eauto.
+      + remember (change_code f (subst_capture_code domtree d s0 root (fn_code f))) as f'.
+        eapply subst_capture_code_spec' in H as INSTR'; eauto; des.
+        * eapply find_function_translated in H0 as FIND; des; cycle 1; eauto.
+          erewrite sig_preserved in INSTR'; simpl in INSTR'; eauto.
+          eexists. eexists. splits;[econs | |].
+          { DStep_tac2. econstructor 6; eauto. }
+          econs; eauto. eapply find_function_prop; eauto.
+          (* eapply transf_function_step_spec in STEP0 as HS. des; eauto.
+          { clarify. rewrite <- HS. econs; eauto. econs; eauto. } *)
+          econs; eauto.
+          i; des. exploit DSEQUIV; i; eauto. econs.
+          eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto. ii; clarify.
+          econs; eauto.
+        * eapply find_function_translated in H0 as FIND; des; cycle 1; eauto.
+          erewrite sig_preserved in INSTR'; simpl in INSTR'; eauto.
+          eexists. eexists. splits;[econs | |].
+          { DStep_tac2. econstructor 6; eauto. }
+          econs; eauto. eapply find_function_prop; eauto.
+          (* eapply transf_function_step_spec in STEP0 as HS; eauto. des; eauto.
+          { clarify. rewrite <- HS. econs; eauto. econs; eauto. } *)
+          econs; eauto. i. exploit DSEQUIV; i; eauto. econs.
+          eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto. ii; clarify.
+          econs; eauto.
+          eapply val_intptrist_trans. eapply VALIST. i; eauto. eapply VALIST'.
+          exploit DSEQUIV; i; des; eauto. econs.
+          eapply compute_dom_correct; eauto. ii; clarify.
+    - (* Itailcall *)
+      inv MS.
+      + eapply find_function_translated in H0 as FIND; cycle 1; eauto. des.
+        eapply free_concrete_extends in H2 as EXISTS; des; eauto.
+        eexists. eexists. splits;[econs | |].
+        { DStep_tac2. econstructor 7; eauto. exploit sig_preserved; eauto. }
+        econs; eauto. eapply find_function_prop; eauto.
+        eapply val_intptr_match_stackframes; eauto.
+        i; exploit free_val_intptr; eauto. eapply VALIST; eauto using free_val_intptr.
+      + remember (change_code f (subst_capture_code domtree d s0 root (fn_code f))) as f'.
+        eapply subst_capture_code_spec' in H as INSTR'; des; eauto.
+        * eapply find_function_translated in H0 as FIND; cycle 1; eauto. des.
+          erewrite sig_preserved in INSTR'; eauto.
+          eapply free_concrete_extends in H2; des; eauto.
+          eexists. eexists. splits;[econs | |].
+          { DStep_tac2. econstructor 7; eauto.
+          erewrite <- stacksize_preserved; eauto. }
+          econs; eauto. eapply find_function_prop; eauto.
+          eapply val_intptr_match_stackframes; eauto using free_val_intptr.
+          eapply VALIST; eauto using free_val_intptr.
+        * eapply find_function_translated in H0 as FIND; cycle 1; eauto. des.
+          simpl in INSTR'. erewrite sig_preserved in INSTR'; eauto.
+          eapply free_concrete_extends in H2; des; eauto.
+          eexists. eexists. splits;[econs | |].
+          { DStep_tac2. econstructor 7; eauto.
+            erewrite <- stacksize_preserved; eauto. }
+          econs; eauto. eapply find_function_prop; eauto.
+          eapply val_intptr_match_stackframes; eauto using free_val_intptr.
+          eapply val_intptrist_trans. eapply VALIST; eauto using free_val_intptr.
+          eapply VALIST'; eauto. exploit DSEQUIV; i; des; eauto using free_val_intptr.
+          econs. eapply compute_dom_correct; eauto. ii; clarify.
+    - (* Ibuiltin *)
+      inv MS.
+      + exploit eval_builtin_args_val_intptr; eauto; i; des. eapply REGS.
+        eapply external_call_concrete_extends in H1 as TFEX; eauto; des.
+        eexists; eexists. esplits.
+        { eapply TFEX. }
+        DStep_tac2; try (unfold is_internal in INT; ss; des_ifs; fail).
+        econstructor 8; eauto. eapply eval_builtin_args_preserved in H2; eauto.
+        i; exploit symbols_preserved; eauto.
+        eapply external_call_symbols_preserved in TFEX0; eauto. 
+        eapply (Genv.senv_match STEP); eauto.
+        econs; eauto. eapply val_intptr_match_stackframes; eauto. i.
+        exploit external_call_binds'; eauto; i.
+        i. induction res; ss; exploit external_call_binds'; eauto. i.
+        destruct (peq arg x). { clarify; repeat rewrite PMap.gss; eauto. }
+        { repeat rewrite PMap.gso; eauto. }
+        { ss. des_ifs. }
+        { unfold ge_binded_state in IBIND. ss. ss. fold ge.
+          ii. destruct senv_preserved.  des.
+          erewrite <- H7 in H4. erewrite <- H6 in H5.
+          eapply IBIND; eauto. }
+      + remember (change_code f (subst_capture_code domtree d s0 root (fn_code f))) as f'.
+        eapply subst_capture_code_spec' in H as INSTR'; eauto; des.
+        * exploit eval_builtin_args_val_intptr; eauto; i; des. eapply REGS.
+          eapply external_call_concrete_extends in H1 as TFEX; eauto; des.
+          eexists; eexists. esplits.
+          { eapply TFEX. }
+          DStep_tac2; try (unfold is_internal in INT; ss; des_ifs; fail).
+          econstructor 8; eauto. eapply eval_builtin_args_preserved in H2; eauto.
+          i; exploit symbols_preserved; eauto.
+          eapply external_call_symbols_preserved in TFEX0; eauto. 
+          eapply (Genv.senv_match STEP); eauto.
+          econs; eauto. eapply val_intptr_match_stackframes; eauto; i;
+            exploit external_call_binds'; eauto.
+          i. induction res; ss; exploit external_call_binds'; eauto. i.
+          destruct (peq arg x). { clarify; repeat rewrite PMap.gss; eauto. }
+          { repeat rewrite PMap.gso; eauto. }
+          i. exploit DSEQUIV. econs. eapply (@Dom.sdom_dom_pred node peq); eauto.
+          econs; eauto. ii; clarify; ss. rewrite CAPT in INT; exploit INT; eauto. econs; eauto.
+          i; des. induction res; ss; eapply external_call_binds' in TFEX0 as T'; eauto;
+            eapply external_call_binds' in H5 as T''; eauto.
+          destruct (peq s0 x).
+          { clarify. assert (use f x root). econs; econstructor 4; eauto; ss. eauto.
+            assert (def f x pc). econs. econs 4; eauto.
+            assert (dom f pc root). exploit fn_strict; eauto.
+            assert (dom f root pc). eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto.
+            exploit (@Dom.dom_antisym node peq); eauto. i; clarify.
+            rewrite CAPT in INT; exploit INT; ss. }
+          { repeat rewrite PMap.gso; eauto; ii; clarify; def_def f x root pc; i; clarify;
+              rewrite CAPT in INT; exploit INT; ss. }
+          { ss. des_ifs. }
+          { unfold ge_binded_state in IBIND. ss. ss.
+            eapply ge_binded_senv_equiv; eauto. eapply senv_preserved. }
+        * assert (exists vargs',
+                  eval_builtin_args tge (fun r => rs' # r) sp m'0
+                  (map (rename_barg d s0) args) vargs' /\ val_intptrist m'0 vargs vargs').
+          { exploit eval_builtin_args_val_intptr; i; des; eauto. eapply REGS.
+            eapply eval_builtin_args_preserved in H0 as H0'.
+            2:{ i; eapply symbols_preserved. }
+            eapply eval_builtin_args_preserved in H2; try eapply symbols_preserved.
+            revert H2 H3. generalize args vl2 vargs. induction args0; ss; i. 
+            inv H2. exists nil; split; try econs; eauto.
+            destruct vl0. inv H2. inv H2. destruct vargs0. inv H3.
+            eapply eval_builtin_arg_rename_barg' in H7 as H'. des.
+            exploit IHargs0; eauto; i; des. inv H3; eauto.
+            exists (v' :: vargs'). split; eauto.
+            - econs; eauto.
+            - econs; eauto. inv H3. eapply val_intptr_trans. eapply H10. eauto.
+            - exploit DSEQUIV; i; des; eauto. econs; eauto.
+              eapply compute_dom_correct; eauto. }
+          des. ss. des_ifs_safe. exploit external_call_concrete_extends; try eapply H1; eauto.
+          { unfold ge_binded_state in IBIND. ss. ss.
+            eapply ge_binded_senv_equiv; eauto. eapply senv_preserved. }
+          i. des.
+          eexists; eexists. splits.
+          { eapply H. }
+          DStep_tac2. econs; eauto.
+          eapply external_call_symbols_preserved in H4; eauto. eapply senv_preserved.
+          
+          econs; eauto.
+          { eapply val_intptr_match_stackframes; eauto.
+            i; eapply external_call_binds'; eauto. }
+          { i. induction res; ss; eauto using external_call_binds'.
+            destruct (peq arg x). clarify; repeat rewrite PMap.gss; eauto.
+            repeat rewrite PMap.gso; eauto using external_call_binds'. }
+          { ss. des_ifs. }
+          i. exploit DSEQUIV; i; des; eauto. econs.
+          eapply (@Dom.sdom_dom_pred node peq); eauto.
+          econs; eauto. ii; clarify; ss.
+          induction res; ss; eauto using external_call_binds'.
+          destruct (peq s0 x).
+          { assert (use f x root). econs; econstructor 4; eauto; ss. eauto.
+            assert (def f x pc). econs. econs 4; eauto.
+            assert (dom f pc root). exploit fn_strict; eauto.
+            assert (dom f root pc). clarify. eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto.
+            clarify.
+            exploit (@Dom.dom_antisym node peq); eauto. i; clarify.  }
+          { assert (ROOT': root_capture root (n :: l1) domtree) by ss. clear ROOT.
+            repeat rewrite PMap.gso; eauto; ii; clarify; eauto using external_call_binds'.
+            def_def f x root pc; i; clarify. def_def f x root pc; i; clarify. }
+    - (* Icond true *)
+      inv MS.
+      + eexists. eexists. splits; [econs| |]. DStep_tac2. econstructor 9; eauto.
+        erewrite <- eval_condition_wrapper_binded; eauto. econs; eauto.
+      + remember (change_code f (subst_capture_code domtree d s0 root (fn_code f))) as f'.
+        eapply subst_capture_code_spec' in H as INSTR'; des; eauto.
+        * eexists. eexists. splits; [econs| |]. DStep_tac2. econstructor 9; eauto.
+          erewrite <- eval_condition_wrapper_binded; eauto.
+          econs; eauto. i. exploit DSEQUIV; eauto.
+          econs. eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto. ii; clarify.
+        * eexists. eexists. splits; [econs| |]. DStep_tac2. econstructor 9; eauto.
+          eapply eval_condition_wrapper_binded. eauto.
+          (* eapply eval_condition_wrapper_binded; eauto. *)
+          eapply val_intptrist_trans. eapply VALIST. i; eauto.
+          eapply VALIST'; eauto. exploit DSEQUIV; i; des; eauto.
+          econs; eauto. eapply compute_dom_correct; eauto.
+          eauto.
+          econs; eauto. i.  exploit DSEQUIV; eauto.
+          econs. eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto. ii; clarify.
+    - (* Icond false *)
+      inv MS.
+      + eexists. eexists. splits; [econs| |]. DStep_tac2. econstructor 10; eauto.
+        eapply eval_condition_wrapper_binded; eauto. eauto. econs; eauto.
+      + remember (change_code f (subst_capture_code domtree d s0 root (fn_code f))) as f'.
+        eapply subst_capture_code_spec' in H as INSTR'; des; eauto.
+        * eexists. eexists. splits; [econs| |]. DStep_tac2. econstructor 10; eauto.
+          eapply eval_condition_wrapper_binded; eauto.
+          econs; eauto. i. exploit DSEQUIV; eauto.
+          econs. eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto. ii; clarify.
+        * eexists. eexists. splits; [econs| |]. DStep_tac2. econstructor 10; eauto.
+          eapply eval_condition_wrapper_binded. eauto.
+          (* erewrite <- eval_condition_wrapper_binded; eauto. *)
+          eapply val_intptrist_trans. eapply VALIST. i; eauto.
+          eapply VALIST'; eauto. exploit DSEQUIV; i; des; eauto.
+          econs; eauto. eapply compute_dom_correct; eauto.
+          eauto.
+          econs; eauto. i.  exploit DSEQUIV; eauto.
+          econs. eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto. ii; clarify.
+    - (* Ijumptbl *)
+      inv MS.
+      + eexists. eexists. splits; [econs| |]. DStep_tac2. econstructor 11; eauto.
+        specialize (REGS arg); inv REGS;
+          try rewrite H0 in *; inv H3; try inv H2; eauto. econs; eauto.
+      + remember (change_code f (subst_capture_code domtree d s0 root (fn_code f))) as f'.
+        eapply subst_capture_code_spec' in H as INSTR'; des; eauto.
+        * eexists. eexists. splits; [econs| |]. DStep_tac2. econstructor 11; eauto.
+          specialize (REGS arg); inv REGS;
+            try rewrite H0 in *; inv H3; try inv H2; eauto. econs; eauto.
+          i. exploit DSEQUIV; i; des; split; eauto.
+          eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto. ss.
+          eapply list_nth_z_in; eauto. ii; clarify.
+        * eexists. eexists. splits; [econs| |]. DStep_tac2. econstructor 11; eauto.
+          specialize (REGS arg); inv REGS;
+            try rewrite H0 in *; inv H3; try inv H2; eauto.
+          destruct (peq arg s0).
+          { clarify. rewrite RENAME. exploit DSEQUIV; i; des; eauto.
+            econs. eapply compute_dom_correct; eauto. ii; clarify.
+            rewrite <- H4 in H3. inv H3. eauto. }
+          { rewrite RENAMEN; eauto. }
+          econs; eauto. i. exploit DSEQUIV; i; des; eauto. econs.
+          eapply compute_dom_correct; eauto. ii; clarify.
+    - (* Ireturn *)
+      inv MS.
+      + eapply free_concrete_extends in H0 as FREE; des; eauto.
+        eexists. eexists. splits; [econs| |]. DStep_tac2. econstructor 12; eauto. econs; eauto.
+        eapply val_intptr_match_stackframes; eauto. i. eapply free_val_intptr; eauto.
+        destruct or; ss; eauto using val_intptr.
+        eapply free_val_intptr; eauto.
+      + remember (change_code f (subst_capture_code domtree d s0 root (fn_code f))) as f'.
+        eapply subst_capture_code_spec' in H as INSTR'; des; eauto.
+        * eapply free_concrete_extends in H0 as FREE; des; eauto.
+          eexists. eexists. splits; [econs| |]. DStep_tac2. econstructor 12; eauto.
+          erewrite <- stacksize_preserved; eauto.
+          econs; eauto. eapply val_intptr_match_stackframes; eauto.
+          i. eapply free_val_intptr; eauto. destruct or; ss; eauto using val_intptr.
+          eapply free_val_intptr; eauto.
+        * eapply free_concrete_extends in H0 as FREE; des; eauto.
+          eexists. eexists. splits; [econs| |]. DStep_tac2. econstructor 12; eauto.
+          erewrite <- stacksize_preserved; eauto.
+          econs; eauto. eapply val_intptr_match_stackframes; eauto.
+          i. eapply free_val_intptr; eauto. destruct or; ss; eauto using val_intptr.
+          destruct (peq r s0).
+          { clarify. rewrite RENAME. exploit DSEQUIV; i; des; eauto.
+            econs; eauto. eapply compute_dom_correct; eauto.
+            eapply free_val_intptr; eauto. eapply val_intptr_trans; eauto. }
+          { rewrite RENAMEN; eauto. eapply free_val_intptr; eauto. }
+    - (* Callstate internal *)
+      inv MS. eapply alloc_concrete_extends in EXTENDS; des; eauto.
+      pose proof STEP0 as STEP0'. inv STEP0; symmetry in H1; monadInv H1.
+      eexists; eexists. splits; [econs| |]. DStep_tac2. econstructor 13. erewrite <- stacksize_preserved; eauto.
+      unfold transf_fundef_step in STEP0'. symmetry in STEP0'. monadInv STEP0'.
+      symmetry in EQ0. eapply transf_function_step_spec in EQ0; eauto. des.
+      + clarify. destruct (compute_dom x) eqn:COMX; ss. econs 1; eauto. inv WF0; eauto.
+        eapply val_intptr_match_stackframes; eauto.
+        i. eapply alloc_val_intptr; eauto.
+        i. exploit init_regs_val_intptr; i; eauto. eapply alloc_val_intptr; eauto.
+      + enough (SSA.fn_params x = SSA.fn_params f). rewrite H0.
+        enough (SSA.fn_entrypoint x = SSA.fn_entrypoint f). rewrite H1. econs 2; eauto.
+        inv WF0; eauto.
+        eapply val_intptr_match_stackframes; eauto. i; eapply alloc_val_intptr; eauto.
+        i. exploit init_regs_val_intptr; i; eauto. eapply alloc_val_intptr; eauto.
+        destruct l; ss. inv EQ1. eauto.
+        i. exploit (@Dom.entry_sdom node peq); eauto. ss.
+        clarify. destruct f; ss. inv EQ3; ss.
+      + inv WF0; eauto.
+    - (* Callstate external *)
+      inv MS. destruct f'. inv STEP0. inv STEP0.
+      exploit external_call_concrete_extends; i; des.
+      { ss. eauto. }
+      5:{ eexists; eexists. splits; cycle 1.
+          - DStep_tac2. econs; eauto.
+          - econs; eauto. eapply val_intptr_match_stackframes; eauto. i.
+            eapply external_call_binds'; eauto.
+          - revert H0. instantiate (1:= t). i. eapply H0. }
+      { ss. }
+      eapply external_call_symbols_preserved in H; eauto. eapply senv_preserved.
+      eauto. eauto.
+    - (* Returnstate *) 
+      inv MS. inv STACK.
+      + clarify. eexists; eexists. splits;[econs| |]. DStep_tac2. econs.
+        econs; eauto. i. destruct (peq arg res); clarify.
+        repeat rewrite PMap.gss; eauto. repeat rewrite PMap.gso; eauto.
+        inv REGS; eauto.
+      + exploit transf_function_step_spec; i; des; eauto.
+        * clarify. eexists; eexists. splits;[econs| |]. DStep_tac2. econs. econs; eauto. 
+          i. destruct (peq arg res); clarify.
+          repeat rewrite PMap.gss; eauto.
+          repeat rewrite PMap.gso; eauto. inv MATCHREGS; eauto.
+          (* inv STEP0. rewrite COMF' in H0; inv H0. *)
+        * clarify. eexists; eexists. splits; [econs| |]. DStep_tac2. econs. econs; eauto.
+          i. destruct (peq arg res); clarify.
+          repeat rewrite PMap.gss; eauto. repeat rewrite PMap.gso; eauto.
+          inv MATCHREGS; eauto. inv ROOT. rewrite CAPT in H3; inv H3. ss.
+          i. inv ROOT. rewrite CAPT in H3. inv H3. destruct (peq s1 res).
+          { clarify. assert (def f res pred); eauto.
+            assert (use f res (find_capture_root domtree hd tl)). econs.
+            exploit UIbuiltin; eauto. ss. eauto.
+            exploit (@Dom.dom_antisym node peq). exploit fn_strict; eauto.
+            eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto.
+            ii; subst pred. rewrite CAPT in PREDINFO. inv PREDINFO. }
+          { repeat rewrite PMap.gso; eauto; ii; clarify;
+              def_def f res (find_capture_root domtree hd tl) pred; i; clarify. }
+    Unshelve. all: auto.
+  Qed.
+
+  Lemma extcall_capture_sem_val_intptr : forall ge v m1 t vr m2,
+    extcall_capture_sem ge (v :: nil) m1 t vr m2 -> trace_intact t ->
+    val_intptr m2 v vr.
+  Proof.
+    i. inv H; try (exploit H0; ss; eauto; ss; fail).
+    - inv CAPTURE. flatten.
+      + econs; eauto. unfold Mem.to_int, Mem.ptr2int_v, Mem.ptr2int. flatten.
+        flatten Eq0. destruct (Mem.mem_concrete m1) ! b eqn:M1B.
+        * exploit PREVADDR; eauto. i; des; clarify. rewrite <- H1 in Eq2.
+          rewrite M1B in Eq2. inv Eq2. eauto.
+        * exploit CAPTURED; eauto; i. rewrite H in Eq2. rewrite PTree.gss in Eq2. inv Eq2.
+          eauto.
+        * flatten Eq0. destruct (Mem.mem_concrete m1) ! b eqn:M1B.
+          { exploit PREVADDR; i; des; clarify. rewrite <- H1 in Eq1. rewrite M1B in Eq1.
+            inv Eq1. }
+          { exploit CAPTURED; i; clarify. rewrite H in Eq1; rewrite PTree.gss in Eq1.
+            inv Eq1. }
+      + econs; eauto. unfold Mem.to_int, Mem.ptr2int_v, Mem.ptr2int. flatten.
+        flatten Eq0. destruct (Mem.mem_concrete m1) ! b eqn:M1B.
+        * exploit PREVADDR; eauto. i; des; clarify.
+        * exploit CAPTURED; eauto; i. rewrite H in Eq2. rewrite PTree.gss in Eq2. inv Eq2.
+          eauto.
+        * flatten Eq0. destruct (Mem.mem_concrete m1) ! b eqn:M1B.
+          { exploit PREVADDR; i; des; clarify. }
+          { exploit CAPTURED; i; clarify. }
+    - econs.
+  Qed.
+
+  Lemma match_states_bsim
+      s1
+      (EXT: SSA.is_external ge s1)
+      (STC: state_char prog s1)
+      s2 t' s2'
+      (IBIND: ge_binded_state tge s2 gmtgt)
+      (STEPTGT: Step (SSA.semantics tprog) s2 t' s2')
+      (MATCH: match_states s1 s2)
+      (SAFESRC: safe (SSA.semantics prog) s1) :
+    (exists t s1', tr_rel (ev_rel gmtgt) t t' /\ Step (SSA.semantics prog) s1 t s1' /\ match_states s1' s2')
+     \/
+    (~ trace_intact t'
+       /\ exists s1'' t, Step (SSA.semantics prog) s1 t s1''
+       /\ exists tl, tr_rel (ev_rel gmtgt) t (Eapp (trace_cut_pterm t') tl)).
+  Proof.
+    assert (SEQUIV: Senv.equiv tge ge) by (symmetry; eapply senv_preserved).
+    unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+    { inv SAFESRC; ss. }
+    unfold SSA.is_external in *. des_ifs.
+    - inv MATCH.
+      + inv SAFESRC; des; des_ifs. inv STEPTGT; des; des_ifs; clarify.
+        exploit external_call_concrete_extends_backward; i; des; try eapply EXTENDS; eauto; cycle 1.
+        * eapply external_call_symbols_preserved in CALLSRC; eauto using symbols_preserved.
+          left; esplits; eauto.
+          econs; eauto.
+          econs; eauto. eapply val_intptr_match_stackframes; eauto.
+          i; eauto using external_call_binds'.
+          i. induction b; ss; eauto using external_call_binds'.
+          destruct (peq x arg). clarify. repeat rewrite PMap.gss; eauto.
+          repeat rewrite PMap.gso; eauto using external_call_binds'.
+        * eapply external_call_symbols_preserved in H9; eauto using senv_preserved.
+          eapply UBSRC in H9; ss.
+        * right. esplits; eauto.
+          eapply exec_Ibuiltin. eauto. eapply H8.
+          eapply external_call_symbols_preserved; eauto.
+        * exploit eval_builtin_args_val_intptr; eauto. eapply REGS. i. des.
+          exploit eval_builtin_args_preserved. eapply symbols_preserved. eapply H. i.
+          exploit eval_builtin_args_determ. eapply H1. eapply H11. i; clarify.
+      + inv SAFESRC; des; des_ifs.
+        eapply transf_function_step_instr_spec in H7 as INS; eauto. des.
+        * inv STEPTGT; des; des_ifs.
+          exploit external_call_concrete_extends_backward; i; des; eauto; cycle 1.
+          { eapply external_call_symbols_preserved in CALLSRC; eauto using symbols_preserved.
+            destruct (classic (trace_intact t')).
+            - assert (INTACT: trace_intact t0).
+              { ii. eapply H. clear - H0 TRREL. ginduction TRREL; ss. i. des; subst.
+                - inv H. eauto.
+                - right. eauto. }
+              left; esplits; eauto. econs; eauto.
+              econs; eauto. eapply val_intptr_match_stackframes; eauto.
+              i; eauto using external_call_binds'.
+              i. induction b; ss; eauto using external_call_binds'.
+              destruct (peq x arg). clarify. repeat rewrite PMap.gss; eauto.
+              repeat rewrite PMap.gso; eauto using external_call_binds'.
+              i. destruct (peq root pc).
+              { clarify. ss. repeat rewrite (@PMap.gss _ d).
+                repeat rewrite PMap.gso; ii; clarify;
+                  try (exploit fn_use_def_code; eauto;
+                    exploit UIbuiltin; eauto; ss; eauto; fail).
+                inv H8. inv H3. inv H5. inv H11. inv H5. inv H3.
+                split; exploit extcall_capture_sem_val_intptr; i; try eapply INTACT; eauto.
+                eapply concrete_extends_val_intptr. eapply MEM. eauto.
+                eapply extcall_capture_sem_val_intptr in H12; eauto. }
+              { exploit DSEQUIV; eauto; i; des.
+                econs; eauto. eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto.
+                induction b ; ss; eauto using external_call_binds'.
+                destruct (peq x s); clarify.
+                { exploit (@Dom.dom_antisym node peq).
+                  eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto.
+                  exploit fn_strict; eauto. econs. exploit UIbuiltin. eapply CAPT.
+                  ss. left; eauto. eauto. i; clarify. }
+                { assert (d <> x). { ii; clarify. def_def f x root pc. }
+                  repeat rewrite PMap.gso; eauto using external_call_binds'. } }
+            - right. split; eauto.
+              specialize (trace_cut_pterm_split t0). i. des.
+              esplits.
+              + eapply exec_Ibuiltin. eapply H7. eapply H8. eapply CALLSRC.
+              + instantiate (1:=t1). rewrite H0. eapply tr_rel_app.
+                { eapply tr_rel_cut_pterm; eauto. ii. destruct ev1, ev2; ss. }
+                eapply tr_rel_refl. eapply ev_rel_refl. }
+          { eapply external_call_symbols_preserved in H9; eauto using senv_preserved.
+            eapply UBSRC in H9; ss. }
+          { right. esplits; eauto. eapply exec_Ibuiltin. eauto. eapply H8.
+            eapply external_call_symbols_preserved; eauto. }
+          exploit eval_builtin_args_val_intptr; eauto; i; des. eapply REGS.
+          exploit eval_builtin_args_determ. eapply H.
+          eapply eval_builtin_args_preserved in H11; eauto.
+          i; exploit symbols_preserved; eauto. i; clarify.
+        * inv STEPTGT; des; des_ifs. destruct l0; simpl in INS1, ROOT. ss.
+          rewrite <- INS1 in ROOT; subst root0.
+          exploit external_call_concrete_extends_backward; i; des; eauto; cycle 1.
+          { eapply external_call_symbols_preserved in CALLSRC; eauto using symbols_preserved.
+            destruct (classic (trace_intact t')).
+            - left; esplits; eauto. econs; eauto.
+              econs; eauto. eapply val_intptr_match_stackframes; eauto.
+              i; eauto using external_call_binds'.
+              i. induction b; ss; eauto using external_call_binds'.
+              destruct (peq x arg). clarify. repeat rewrite PMap.gss; eauto.
+              repeat rewrite PMap.gso; eauto using external_call_binds'.
+              i. destruct (peq root pc).
+              { clarify. }
+              { exploit DSEQUIV; eauto; i; des.
+                econs; eauto. eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto.
+                induction b ; ss; eauto using external_call_binds'.
+                destruct (peq x s); try subst s.
+                { rewrite CAPT in INS3; inv INS3. exploit (@Dom.dom_antisym node peq).
+                  eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto.
+                  exploit fn_strict; eauto. econs. exploit UIbuiltin. eapply CAPT.
+                  ss. left; eauto. eauto. i; clarify. }
+                { assert (d <> x). { ii; subst d. def_def f x root pc. }
+                  repeat rewrite PMap.gso; eauto using external_call_binds'. } }
+            - right. split; eauto.
+              specialize (trace_cut_pterm_split t0). i. des.
+              esplits.
+              + eapply exec_Ibuiltin. eapply H7. eapply H8. eapply CALLSRC.
+              + instantiate (1:=t1). rewrite H0. eapply tr_rel_app.
+                { eapply tr_rel_cut_pterm; eauto. ii. destruct ev1, ev2; ss. }
+                eapply tr_rel_refl. eapply ev_rel_refl. }
+          { eapply external_call_symbols_preserved in H9; eauto using senv_preserved.
+            eapply UBSRC in H9; ss. }
+          { right. esplits; eauto. eapply exec_Ibuiltin. eauto. eapply H8.
+            eapply external_call_symbols_preserved; eauto. }
+          (* exploit eval_builtin_arg_rename_barg'; eauto. *)
+          exploit eval_builtin_args_val_intptr; eauto; i; des. eapply REGS.
+          eapply eval_builtin_args_preserved in H11; cycle 1.
+          i; exploit symbols_preserved; intros P; rewrite <- P; eauto.
+          eapply val_intptrist_trans; eauto.
+          revert H H11. generalize l vargs0 vl2. induction l1; ss; i. 
+          inv H11. inv H. econs.
+          destruct vl0. inv H. inv H. destruct vargs1. inv H11. inv H11.
+          eapply eval_builtin_arg_rename_barg' in H4 as H'. des.
+          exploit eval_builtin_arg_determ. eauto. subst ge. eapply H3.
+          i; clarify. econs; eauto. exploit DSEQUIV; i; des; eauto.
+          econs; eauto. eapply compute_dom_correct; eauto.
+          rewrite CAPT in INS3; inv INS3. eauto.
+    - inv MATCH. inv SAFESRC; des; des_ifs. inv STEPTGT; des; des_ifs; clarify. inv STEP0.
+      exploit external_call_concrete_extends_backward; i; des; eauto.
+      + eapply external_call_symbols_preserved in CALLSRC; eauto using symbols_preserved.
+        left; esplits; eauto. econs; eauto.
+        econs; eauto. eapply val_intptr_match_stackframes; eauto.
+        i; eauto using external_call_binds'.
+      + eapply external_call_symbols_preserved in H5; eauto using senv_preserved.
+        exploit UBSRC; eauto. ss.
+      + right. esplits; eauto.
+        exploit external_call_symbols_preserved; eauto.
+        eapply exec_function_external; eauto.
+        (* Unshelve. all: eauto. *)
+  Qed.
+  
+  Opaque transf_function_step.
+
+  Lemma match_states_xsim st_src0 st_tgt0 (STC: state_char prog st_src0) (IBIND: ge_binded_state tge st_tgt0 gmtgt) (MATCH: match_states st_src0 st_tgt0) :
+    xsim (SSA.semantics prog) (SSA.semantics tprog) gmtgt lt 0%nat st_src0 st_tgt0.
+  Proof.
+    generalize dependent st_src0. generalize dependent st_tgt0.
+    pcofix CIH. i. pfold.
+    destruct (classic (SSA.is_external ge st_src0)); cycle 1.
+    (* not external *)
+    - left. econs. econs.
+      + i. exploit step_simulation; eauto. i. des. esplits. 
+        { instantiate (1:=t'). ss. }
+        { left. split.
+          - eapply plus_one; eauto.
+          - eapply semantics_receptive_at; auto. }
+        right. eapply CIH.
+        {  inv H1. eapply ge_binded_state_step; eauto. }
+        { eapply state_char_preservation; eauto. }
+        eauto.
+      + ii. eapply final_state_determ; eauto.
+        inv FINALSRC. inv MATCH. inv STACK. inv BIND. econs.
+      (* + eauto. *)
+    (* external *)
+    - right. econs; eauto. i. econs; eauto.
+      + i. exploit match_states_bsim; try eapply STEPTGT; eauto.
+        i. des.
+        * left. esplits; eauto. left.
+          eapply plus_one. eauto.
+          right. eapply CIH; eauto.
+          { eapply ge_binded_state_step; eauto. }
+          { eapply state_char_preservation; eauto. }
+        * right. esplits; eauto. eapply star_one; eauto.
+      + ii. inv FINALTGT. inv MATCH. unfold SSA.is_external in H. ss.
+      + i. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+        { inv SAFESRC; ss. }
+        right. inv MATCH; ss; des_ifs; inv SAFESRC; unfold ge in *; clarify.
+        * exploit eval_builtin_args_val_intptr; i; des; eauto. eapply REGS.
+          eapply eval_builtin_args_preserved in H0; i; cycle 1.
+          exploit symbols_preserved; eauto.
+          eapply external_call_symbols_preserved in H10; try eapply senv_preserved.
+          exploit ec_concrete_extends_backward_progress.
+          { eapply external_call_spec_backward; eauto. }
+          eauto. eauto. eauto. eauto. i. des.
+          esplits. eapply exec_Ibuiltin; eauto.
+        * eapply transf_function_step_instr_spec in STEP0 as INSTR'; des; eauto.
+          { eapply eval_builtin_args_preserved in H9; cycle 1.
+            i; exploit symbols_preserved; eauto.
+            exploit eval_builtin_args_val_intptr; i; des; eauto. eapply REGS.
+            exploit ec_concrete_extends_backward_progress.
+            { eapply external_call_spec_backward; eauto. }
+            2:{ eauto. }
+            2:{ eauto. }
+            2:{ eauto. }
+            erewrite <- ge_binded_senv_equiv.
+            2:{ symmetry. eapply senv_preserved. }
+            unfold ge_binded_state in IBIND. ss. eauto. i. des.
+            esplits. eapply exec_Ibuiltin; eauto.
+            eapply external_call_symbols_preserved. eapply senv_preserved.
+            eapply CALLTGT. }
+          { destruct l. simpl in INSTR'1; ss. simpl in INSTR'1, ROOT.
+            rewrite DOMTREE in INSTR'. inversion INSTR'; subst domtree0.
+            rewrite <- ROOT in INSTR'1. subst root0.
+            rewrite CAPT in INSTR'3. inversion INSTR'3. subst s0 d0 pc'.
+            eapply eval_builtin_args_preserved in H9; cycle 1.
+            i; exploit symbols_preserved; eauto.
+            exploit eval_builtin_args_val_intptr; i; des; eauto. eapply REGS.
+            enough (exists vl2',
+              eval_builtin_args tge (fun r => rs' # r) sp m' (map (rename_barg d s) l0) vl2'
+              /\ val_intptrist m' vl2 vl2'). des.
+            exploit ec_concrete_extends_backward_progress; i; des.
+            { eapply external_call_spec_backward; eauto. }
+            5:{ esplits. eapply exec_Ibuiltin; eauto. }
+            { unfold ge_binded_state in IBIND. ss. eauto. }
+            eapply external_call_symbols_preserved; eauto. eapply senv_preserved.
+            eauto.
+            eapply val_intptrist_trans; eauto.
+            revert H0. generalize l0 vl2. induction l1; ss; i.
+            - inv H0. eexists; split; try econs.
+            - destruct vl0; inv H0. eapply eval_builtin_arg_rename_barg' in H5; des.
+              exploit IHl1; eauto; i; des.
+              exists (v' :: vl2'). split; econs; eauto.
+              exploit DSEQUIV; i; des; eauto. econs; eauto.
+              eapply compute_dom_correct; eauto. }
+        * exploit ec_concrete_extends_backward_progress; i; des.
+          6:{ esplits. econs. eapply CALLTGT. }
+          { eapply external_call_spec_backward; eauto. }
+          { unfold ge_binded_state in IBIND. ss. eauto. }
+          { eapply external_call_symbols_preserved; eauto using senv_preserved. }
+          { eauto. }
+          eauto.
+      (* + ii. inv FINALTGT. inv MATCH. unfold SSA.is_external in H. ss. *)
+      (* + ss. *)
+  Qed.
+
+  End STEPSIM.
+  
+  Lemma same_public:
+    prog_public prog = prog_public tprog.
+  Proof. inv STEP. des; eauto. Qed.
+
+  Lemma non_static_equiv l:
+    Genv.non_static_glob (Genv.globalenv prog) l = Genv.non_static_glob (Genv.globalenv tprog) l.
+  Proof.
+    induction l; ss.
+    unfold Genv.public_symbol. rewrite symbols_preserved. unfold ge.
+    des_ifs.
+    - rewrite IHl. eauto.
+    - rewrite Genv.globalenv_public in *. rewrite same_public in Heq. clarify.
+    - rewrite Genv.globalenv_public in *. rewrite same_public in Heq. clarify.
+  Qed.
+
+  (* move to Memory.v *)
+  (* Lemma capture_list_bind *)
+          
+  Lemma transf_initial_capture
+    S1 S2 S2'
+    (INITSRC: SSA.initial_state prog S1)
+    (INITTGT: SSA.initial_state tprog S2)
+    (MATCH: match_states S1 S2)
+    (CAPTGT: SSA.glob_capture tprog S2 S2'):
+  exists S1',
+    SSA.glob_capture prog S1 S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (concrete_snapshot ge S1') (concrete_snapshot tge S2').
+  Proof.
+    inv CAPTGT. ss.
+    rewrite Genv.globalenv_public in CAPTURE.
+    rewrite <- same_public in CAPTURE. erewrite <- non_static_equiv in CAPTURE.
+    inv MATCH. inv STACK. inv BIND. inv CAPTURE.
+    assert (exists m0', Genv.capture_init_mem m0 (Genv.non_static_glob (Genv.globalenv prog) (prog_public prog)) m0'
+                 /\ concrete_extends m0' m').
+    { remember (prog_public prog) as lst. clear Heqlst. clear - EXTENDS CAP.
+      ginduction lst; ss; i.
+      - inv CAP. esplits; eauto. econs; eauto. econs; eauto.
+      - destruct (Genv.public_symbol (Genv.globalenv prog) a) eqn:PSYMB.
+        2:{ exploit IHlst; eauto. }
+        destruct (Genv.find_symbol (Genv.globalenv prog) a) eqn:PFIND.
+        2:{ exploit IHlst; eauto. }
+        i. inv CAP.
+        exploit capture_concrete_extends; eauto. i. des. exploit IHlst; eauto. i. des.
+        inv H. esplits; eauto. econs; eauto. econs; eauto. }
+    des. esplits.
+    - econs; eauto. rewrite Genv.globalenv_public. eauto.
+    - econs; eauto; econs.
+    - unfold concrete_snapshot. ii.
+      specialize senv_preserved. intros SENVEQ.
+      inv SENVEQ. des. erewrite H3, H2. des_ifs; ss. inv H0.
+      eapply extended_concrete; eauto.
+    Unshelve. all: eauto.
+  Qed.
+
+  Theorem transf_program_step_correct : 
+    mixed_simulation (SSA.semantics prog) (SSA.semantics tprog).
+  Proof.
+    econs. econs.
+    - apply lt_wf.
+    - rr. i. exists (S a). lia.
+    - econs. i. exploit transf_initial_states; eauto. i. des.
+      exists S2. split.
+      (* initial state *)
+      + econs; eauto. eapply initial_state_determ.
+      (* mixed sim *) 
+      + r. ii. exploit transf_initial_capture; eauto. i. des. esplits; eauto.
+        { ss. subst. ss. }
+        subst. eapply match_states_xsim; eauto.
+        { eapply glob_capture_char; eauto. eapply initial_state_char; eauto. }
+        r. r. i. unfold gmtgt. ss. unfold concrete_snapshot. ss. split.
+        { fold tge. rewrite H4, H5. ss. }
+        inv CAPTGT. fold tge in CAPTURE.
+        assert (In b (Genv.non_static_glob tge (Genv.genv_public tge))).
+        { assert (In id (Genv.genv_public tge)).
+          { unfold Genv.public_symbol in H4. rewrite H5 in H4.
+            destruct in_dec in H4; ss. }
+          remember (Genv.genv_public tge) as l.
+          clear - H6 H4 H5. ginduction l; ss; i; des; subst; eauto.
+          - rewrite H4, H5. ss. eauto.
+          - exploit IHl; eauto. i. des_ifs. des_ifs; eauto. }
+        inv CAPTURE. ss.
+        exploit Mem.capture_list_concrete; eauto. i. des. exists addr.
+        fold tge. rewrite H4, H5. eauto.
+    - i. apply senv_preserved.
+  Qed.
+
+End CORRECTNESS_STEP.
+
+(* Note: behavioral refinement proof of the whole optimization is in Complements.v *)
+Section CORRECTNESS.
+
+  Variable prog: program.
+  Variable tprog: program.
+  Hypothesis MATCH : match_prog prog tprog.
+  Hypothesis HWF : wf_ssa_program prog.
+  Let ge := Genv.globalenv prog.
+  Let tge := Genv.globalenv tprog.
+
+  (* Showing that the whole optimization process is equivalent to multiple steps *)
+  Fixpoint empty_node_list {A} (l : list A) : list (list node) :=
+    match l with
+    | nil => nil
+    | hd :: tl => nil :: empty_node_list tl
+    end.
+
+  Fixpoint capture_node_list (l : list (ident * globdef fundef unit)) :=
+    match l with
+    | (id, Gfun (Internal f)) :: l'=>
+      match compute_dom f with
+      | Some domtree => find_capture_all f.(fn_code) :: capture_node_list l'
+      | None => nil :: capture_node_list l'
+      end
+    | _ :: l' => nil :: capture_node_list l'
+    | nil => nil
+    end.
+
+  Definition max_capt_len (p: program) : nat :=
+    list_max (map (@Datatypes.length node) (capture_node_list (prog_defs p))).
+
+  Lemma match_prog_repeatn : 
+    exists n, OK (tprog, empty_node_list (prog_defs tprog)) =
+      repeatn_monad transf_program_step n (prog, capture_node_list (prog_defs prog)).
+  Proof.
+    ii. exists (max_capt_len prog). unfold max_capt_len.
+    remember (list_max _). assert (n <= n) by lia. rewrite Heqn in H at 1.
+    apply list_max_le in H. clear Heqn. rename H into HLE. inv MATCH. des.
+    destruct prog; destruct tprog; ss. rewrite H0. rewrite H1. clear H0 H1.
+    remember (mkprogram prog_defs prog_public prog_main) as p. rewrite Heqp.
+    revert n HLE. revert H. clear Heqp. generalize prog_defs0 as l'. generalize prog_defs as l.
+    induction l; ss; i. inv H. induction n; ss; eauto.
+    destruct l' as [ | a' l']. inv H. inv H. destruct a. destruct a' as [i' g'].
+    inv H3. simpl in H; subst i'. simpl in H0; inv H0.
+    destruct f1.
+    - unfold transf_fundef, transf_function, transf_partial_fundef in H1.
+      monadInv H1. flatten E. rewrite repeatn_monad_dist. erewrite <- IHl; eauto; cycle 1.
+      inv HLE; eauto. unfold fundef in *. simpl.
+      inv HLE. exploit repeatn_monad_transf_globdef_step; eauto. i. rewrite H0. ss.
+      generalize l as l0; induction l0; ss; i. flatten; ss; try lia.
+    - inv H1. rewrite repeatn_monad_dist. erewrite <- IHl; eauto; cycle 1. inv HLE; eauto.
+      ss. generalize n. induction n0; ss; eauto.
+      generalize l as l0; induction l0; ss; i. flatten; ss; try lia.
+    - inv H. ss. rewrite repeatn_monad_dist. erewrite <- IHl; eauto; cycle 1. inv HLE; eauto.
+      ss. generalize n. induction n0; ss; eauto.
+      generalize l as l0; induction l0; ss; i. flatten; ss; try lia.
+  Qed.
+  
+  Lemma match_prog_wf_ssa : wf_ssa_program tprog.
+  Proof.
+    pose proof match_prog_repeatn; des.
+    remember (capture_node_list (prog_defs prog)) as l.
+    assert (Datatypes.length l = Datatypes.length (prog_defs prog)).
+    { rewrite Heql. generalize (prog_defs prog). induction l0; ss; i. flatten; ss; try lia. }
+    clear Heql. clear MATCH.
+    generalize dependent prog. generalize tprog, l.
+    induction n.
+    - ss. i. monadInv H; auto.
+    - i. unfold repeatn_monad in H. symmetry in H. monadInv H.
+      fold (repeatn_monad transf_program_step n x) in EQ0. destruct x.
+      symmetry in EQ0. eapply IHn in EQ0; eauto.
+      eapply transf_program_step_wf_ssa; eauto.
+      eapply transf_program_step_match; eauto.
+      unfold transf_program_step in EQ. monadInv EQ. simpl. revert H0 EQ1.
+      generalize (prog_defs prog0) l0 l1 x. induction l2; ss; i.
+      + inv EQ1. exploit length_zero_iff_nil; eauto.
+      + destruct l3; try inv H0. monadInv EQ1. exploit IHl2; eauto. i; simpl; lia.
+  Unshelve. all: eauto.
+  Qed.
+
+End CORRECTNESS.
diff --git a/midend/Copyprop.v b/midend/Copyprop.v
new file mode 100644
index 00000000..3e44b943
--- /dev/null
+++ b/midend/Copyprop.v
@@ -0,0 +1,203 @@
+Require Import Classical.
+Require Import Coqlib.
+Require Import Maps.
+Require Import AST.
+Require Import Integers.
+Require Import Values.
+Require Import Memory.
+Require Import Globalenvs.
+Require Import Smallstep.
+Require Import Op.
+Require Import Events.
+Require Import Registers.
+Require Import Floats.
+Require Import Utils.
+Require Import SSA. 
+Require Import SSAutils. 
+Require Import Utilsvalidproof.
+Require Import DomCompute.
+Require Import Axioms.
+Require Import KildallComp.
+Require Import OrderedType.
+Require Import Ordered.
+Require Import FSets.
+Require FSetAVL.
+(* Require Import Opt. *)
+(* Require Import OptInv. *)
+Require Import DLib.
+
+Require Import sflib.
+
+
+(** * CSE optimisation based on GVN *)
+
+(* Definition get_repr (f:function) (c:certif):= *)
+(*   match check_GVN f c with *)
+(*     | Some repr => repr *)
+(*     | None => (fun x => (x,xH)) *)
+(*   end. *)
+
+(* Definition get_extern_gvn (f:function): (reg -> (reg* node)) := *)
+(*   get_repr f (extern_gvn f). *)
+
+(* Definition analysis (f: function) := ((get_extern_gvn f, f),P2Map.init true). *)
+
+(* Definition res := ((reg -> reg*node)  (* repr(x) = (r, r_def) *) *)
+(*                     * function        (* function *)                            *)
+(*                    )%type. *)
+
+(* Definition check_def (code:code) (pc:node) (x:reg) : bool := *)
+(*   match code!pc with *)
+(*     | Some (Iop op args dst succ) => if peq x dst then true else false *)
+(*     | Some (Iload chunk addr args dst succ) => if peq x dst then true else false *)
+(*     | Some (Icall sig fn args dst succ) => if peq x dst then true else false *)
+(*     | Some (Ibuiltin fn args (BR dst) succ) => if peq x dst then true else false *)
+(*     | _ => false *)
+(*   end. *)
+
+
+Definition find_mv_instr (result: option (reg*reg)) (pc: node) ins : option (reg * reg) :=
+  match result with
+  | None => match ins with
+            | Iop Omove (src :: nil) dst _ => Some (dst,src)
+            | _ => result
+            end
+  | _ => result
+  end.
+
+Definition find_mv_code (c: code) : option (reg * reg) :=
+  PTree.fold find_mv_instr c None.
+
+Definition remove_mv_instr (d: reg) (instr: instruction) :=
+  match instr with
+  | Iop Omove _ dst pc' =>
+      if Pos.eqb dst d then Inop pc' else instr
+  | _ => instr
+  end.
+
+Definition rename_reg (d s: reg) (r: reg) : reg :=
+  if (Pos.eqb r d) then s else r.
+
+Definition rename_fn (d s: reg) (fn: reg + ident) : reg + ident :=
+  match fn with inl r => inl (rename_reg d s r) | _ => fn end.
+
+Fixpoint rename_barg (d s: reg) (b: builtin_arg reg) : builtin_arg reg :=
+  match b with
+  | BA r => BA (rename_reg d s r)
+  | BA_splitlong b1 b2 => BA_splitlong (rename_barg d s b1) (rename_barg d s b2)
+  | BA_addptr b1 b2 => BA_addptr (rename_barg d s b1) (rename_barg d s b2)
+  | _ => b
+  end.
+
+Fixpoint rename_bres (d s: reg) (b: builtin_res reg) : builtin_res reg :=
+  match b with
+  | BR r => BR (rename_reg d s r)
+  | BR_splitlong b1 b2 => BR_splitlong (rename_bres d s b1) (rename_bres d s b2)
+  | _ => b
+  end.  
+
+Definition subst_instr (d s: reg) (instr: instruction) :=
+  let rn := rename_reg d s in
+  let rnf := rename_fn d s in
+  let rnba := rename_barg d s in
+  let rnbr := rename_bres d s in
+  match instr with
+  | Inop pc' => Inop pc'
+  | Iop op args dst pc' => Iop op (map rn args) dst pc'
+  | Iload chunk addr args dst pc' => Iload chunk addr (map rn args) dst pc'
+  | Istore chunk addr args src pc' => Istore chunk addr (map rn args) (rn src) pc'
+  | Icall sig fn args dst pc' => Icall sig (rnf fn) (map rn args) dst pc'
+  | Itailcall sig fn args => Itailcall sig (rnf fn) (map rn args)
+  | Ibuiltin ef args dst pc' => Ibuiltin ef (map rnba args) dst pc'
+  | Icond cond args ifso ifnot => Icond cond (map rn args) ifso ifnot
+  | Ijumptable arg tbl => Ijumptable (rn arg) tbl
+  | Ireturn ret => Ireturn (option_map rn ret)
+  end.
+
+Definition elim_mv_code (d s: reg) (c: code) : code :=
+  PTree.map (fun pc instr => subst_instr d s (remove_mv_instr d instr)) c.
+
+Fixpoint find_mv_phiblock (blk: phiblock) : option (reg * reg) :=
+  match blk with
+  | nil => None
+  | (Iphi (src::args) dst) :: blk' =>
+      if forallb (Pos.eqb src) args
+      then Some (dst,src)
+      else find_mv_phiblock blk'
+  | _ :: blk' => find_mv_phiblock blk'
+  end.
+
+Definition _find_mv_phiblock result (pc: node) blk : option (reg * reg) :=
+  match result with
+  | None => find_mv_phiblock blk
+  | _ => result
+  end.
+
+Definition find_mv_phicode (p: phicode) : option (reg * reg) :=
+  PTree.fold _find_mv_phiblock p None.
+
+Fixpoint remove_mv_phiblock (d: reg) (blk: phiblock) :=
+  match blk with
+  | nil => nil  
+  | (Iphi args dst) :: blk' =>
+      if Pos.eqb dst d
+      then remove_mv_phiblock d blk'
+      else (Iphi args dst) :: remove_mv_phiblock d blk'
+  end.
+
+Definition subst_phi (d s: reg) (pins: phiinstruction) :=
+  match pins with
+  | Iphi args dst => Iphi (map (rename_reg d s) args) dst
+  end.
+
+Definition elim_mv_phicode (d s: reg) (p: phicode) : phicode :=
+  PTree.map (fun pc blk => map (subst_phi d s) (remove_mv_phiblock d blk)) p.
+
+Fixpoint simplify_mv (fuel: nat) (c: code) (p: phicode) : code * phicode :=
+  match fuel with
+  | 0 => (c, p)
+  | S fuel' =>
+      match find_mv_code c with
+      | Some (d, s) =>
+          simplify_mv fuel' (elim_mv_code d s c) (elim_mv_phicode d s p)
+      | None => match find_mv_phicode p with
+                | Some (d, s) =>
+                    simplify_mv fuel' (elim_mv_code d s c) (elim_mv_phicode d s p)
+                | None => (c,p)
+                end
+      end
+  end.
+
+Definition transf_function_fuel (fuel: nat) (f: function) : function :=
+  let '(code', phicode') := simplify_mv fuel f.(fn_code) f.(fn_phicode) in
+  mkfunction
+    f.(fn_sig)
+    f.(fn_params)
+    f.(fn_stacksize)
+    code'
+    phicode'
+    f.(fn_entrypoint)
+    f.(fn_ext_params)
+    f.(fn_dom_test).
+
+Definition code_size (f: function) : nat :=
+  PTree.fold (fun m _ blk => length blk + m) f.(fn_phicode)
+  (PTree.fold (fun m _ _ => 1+m) f.(fn_code) 1%nat).
+
+Definition transf_function (f: function) : function :=
+  transf_function_fuel (code_size f) f.
+
+Definition transf_fundef (f: fundef) : fundef :=
+  AST.transf_fundef transf_function f.
+
+Definition transf_program (p: program) : program :=
+  AST.transform_program transf_fundef p.
+
+Definition transf_function_step (f: function) : function :=
+  transf_function_fuel 1 f.
+
+Definition transf_fundef_step (f: fundef) : fundef :=
+  AST.transf_fundef transf_function_step f.
+
+Definition transf_program_step (p: program) : program :=
+  AST.transform_program transf_fundef_step p.
diff --git a/midend/Copypropproof.v b/midend/Copypropproof.v
new file mode 100644
index 00000000..d5bb7782
--- /dev/null
+++ b/midend/Copypropproof.v
@@ -0,0 +1,5139 @@
+Require Import Classical.
+Require Import Coqlib.
+Require Import Maps.
+Require Import AST.
+Require Import Integers.
+Require Import Values.
+Require Import Memory.
+Require Import Globalenvs.
+Require Import PointerOp Simulation SSAD sflib.
+Require Import Smallstep.
+Require Import Op.
+Require Import Events.
+Require Import Registers.
+Require Import Floats.
+Require Import Utils.
+Require Import SSA. 
+Require Import SSAutils. 
+Require Import SSAinv. 
+Require Import Utilsvalidproof.
+Require Import DomCompute.
+Require Import Axioms.
+Require Import KildallComp.
+Require Import OrderedType.
+Require Import Ordered.
+Require Import FSets.
+Require FSetAVL.
+Require Import Dsd.
+(* Require Import OptInv. *)
+Require Import Copyprop.
+(* Require Import GVNoptProp. *)
+Require Import DLib.
+
+Require Import Linking.
+Require Import Classical.
+From Paco Require Import paco.
+
+(* Require Opt. *)
+(* Require OptInv. *)
+
+Require Import sflib.
+(* Require Import Simulation. *)
+
+Unset Allow StrictProp.
+
+(** * Correctness of the optimization *)
+Section PRESERVATION.
+
+  Definition match_prog (p: SSA.program) (tp: SSA.program) :=
+    match_program (fun cu f tf => tf = transf_fundef f) eq p tp.
+
+  Lemma transf_program_match:
+   forall p, match_prog p (transf_program p).
+  Proof.
+   intros; subst.
+   eapply match_transform_program_contextual; auto.
+  Qed.
+
+  Lemma fold_find_mv_instr_some: forall l d s,
+    fold_left (fun a p => find_mv_instr a (fst p) (snd p)) l None = Some (d, s) ->
+    exists pc pc', In (pc, (Iop Omove (s :: nil) d pc')) l.
+  Proof.
+    induction l; ss. i. destruct a eqn:Ea; ss.
+    destruct i; ss; try (apply IHl in H; des; exists pc, pc'; eauto; fail).
+    destruct o; ss; try (apply IHl in H; des; exists pc, pc'; eauto; fail).
+    destruct l0.
+    - apply IHl in H. des. exists pc, pc'; eauto.
+    - destruct l0; ss.
+      + assert (forall l, fold_left (fun a p => find_mv_instr a (fst p) (snd p))
+                          l (Some (r, r0)) = Some (r, r0)).
+        { induction l0; ss. }
+        rewrite H0 in H. inv H. eauto.
+      + apply IHl in H. des; eauto.
+  Qed.
+
+  Lemma fold_find_mv_instr_none: forall l d s,
+    fold_left (fun a p => find_mv_instr a (fst p) (snd p)) l None = None ->
+    forall pc pc', ~ In (pc, (Iop Omove (s :: nil) d pc')) l.
+  Proof.
+    assert (forall l d s, fold_left
+                            (fun a p => find_mv_instr a (fst p) (snd p))
+                            l (Some (d, s)) = None -> False).
+    { induction l; ss. }
+    induction l; ss. ii. des.
+    - destruct a; ss. clarify.
+      apply H in H0; eauto.
+    - destruct a; ss. destruct i; ss; try eapply IHl in H0; eauto.
+      destruct o; ss; try eapply IHl in H0; eauto.
+      destruct l0; ss; try eapply IHl in H0; eauto.
+      destruct l0; ss; try eapply IHl in H0; eauto.
+  Qed.
+
+  Lemma find_mv_exists: forall c d s,
+    find_mv_code c = Some (d, s) ->
+    exists pc pc', c ! pc = Some (Iop Omove (s :: nil) d pc').
+  Proof.
+    unfold find_mv_code. i. rewrite PTree.fold_spec in H.
+    apply fold_find_mv_instr_some in H. des.
+    apply PTree.elements_complete in H. eauto.
+  Qed.
+
+  Lemma fold_find_mv_phiinstr_some: forall l d s,
+    fold_left (fun a p => _find_mv_phiblock a (fst p) (snd p)) l None = Some (d, s) ->
+    exists pc phib, (In (pc, phib) l /\
+                     exists args, In (Iphi (s :: args) d) phib
+                                  /\ forall a, In a args -> a = s).
+  Proof.
+    induction l; ss. i. destruct a eqn:Ea; ss.
+    destruct (find_mv_phiblock p) eqn:PFIND.
+    - assert (forall l d s,
+              fold_left (fun a p => _find_mv_phiblock a (fst p) (snd p)) l (Some (d, s))
+                = Some (d, s)).
+      { induction l0; ss. } destruct p0. rewrite H0 in H. clarify.
+      assert (forall p d s, find_mv_phiblock p = Some (d, s) ->
+                            exists args, In (Iphi (s :: args) d) p /\
+                                         forall a, In a args -> a = s).
+      { induction p0; ss. i. flatten H.
+        - apply IHp0 in H. des. exists args; split; eauto.
+        - exists l1; split; eauto. i. rewrite forallb_forall in Eq1. apply Eq1 in H.
+          apply Pos.eqb_eq in H. auto.
+        - apply IHp0 in H. des. exists args; split; eauto.  }
+      apply H in PFIND. des. exists n, p; eauto.
+    - apply IHl in H. des. exists pc, phib; eauto.
+  Qed.
+
+  Lemma fold_find_mv_phiinstr_none: forall l d s,
+    fold_left (fun a p => _find_mv_phiblock a (fst p) (snd p)) l None = None ->
+    forall pc phib, ~ (In (pc, phib) l /\
+                       exists args, (In (Iphi (s :: args) d)) phib
+                                     /\ forall a, In a args -> a = s).
+  Proof.
+    assert (FOLDSN: forall l d s, fold_left
+                    (fun a p => _find_mv_phiblock a (fst p) (snd p))
+                    l (Some (d, s)) = None -> False).
+    { induction l; ss. }
+    assert (FORALLF: forall l s,
+                     forallb (Pos.eqb s) l = false -> exists t, In t l /\ t <> s).
+    { induction l; ss. i. apply andb_false_elim in H. destruct H.
+      exists a; split; eauto. apply Pos.eqb_neq in e. ii.
+      symmetry in H. apply e in H; ss.
+      apply IHl in e. des. exists t; split; eauto. }
+    assert (FINDCORR: forall phib s d args,
+                      In (Iphi (s :: args) d) phib ->
+                      forallb (Pos.eqb s) args = true ->
+                      exists s' d', find_mv_phiblock phib = Some (s', d')).
+      { induction phib; ss. i. des.
+        - rewrite H. rewrite H0. eauto.
+        - apply IHphib in H. des. destruct a; ss. destruct l; ss.
+          + eauto.
+          + flatten. eauto. eauto.
+          + auto. }
+    induction l; ss.
+    - ii. des; auto.
+    - ii. destruct a; ss. des.
+      + clarify.
+        eapply FINDCORR in H1; eauto. des; ss. rewrite H1 in H.
+        apply FOLDSN in H; auto. rewrite forallb_forall. i.
+        apply H2 in H0. clarify. rewrite Pos.eqb_eq; ss.
+      + destruct (find_mv_phiblock p) eqn:FINDP; ss.
+        * destruct p0. apply FOLDSN in H. destruct H.
+        * eapply IHl in H. apply H. split.
+          eauto. eauto.
+  Qed.
+
+  Lemma find_mv_phicode_exists: forall p d s,
+    find_mv_phicode p = Some (d, s) ->
+    exists pc phib args, p ! pc = Some phib /\
+    In (Iphi (s :: args) d) phib /\
+    forallb (Pos.eqb s) args = true.
+  Proof.
+  assert (forall l d s,
+          fold_left (fun a p => _find_mv_phiblock a (fst p) (snd p))
+          l None = Some (d, s) ->
+          exists pc phib args, In (pc, phib) l /\
+          In (Iphi (s :: args) d) phib /\
+          forallb (Pos.eqb s) args).
+  { induction l; ss. i. destruct a eqn:Ea; ss.
+    destruct (find_mv_phiblock p) eqn:Epfind.
+    - destruct p0; ss.
+      assert (forall l, fold_left (fun a p => _find_mv_phiblock a (fst p) (snd p))
+              l (Some (r, r0)) = Some (d, s) -> r = d /\ r0 = s).
+      { induction l0; ss. i; clarify; ss. }
+      specialize (H0 _ H); des; clarify.
+      revert p Epfind. induction p; ss. i.
+      destruct a. destruct l0.
+      + apply IHp in Epfind. des; clarify; repeat eexists; eauto.
+      + flatten Epfind.
+        * repeat eexists; eauto.
+        * apply IHp in Epfind. des; clarify; repeat eexists; eauto.
+    - apply IHl in H. des. exists pc, phib, args; eauto.
+  }
+  unfold find_mv_phicode. i. rewrite PTree.fold_spec in H0. apply H in H0. des.
+  apply PTree.elements_complete in H0. repeat eexists; eauto.
+  Qed.
+
+  Lemma find_mv_not_same: forall f d s,
+    wf_ssa_function f ->
+    find_mv_code (fn_code f) = Some (d, s) ->
+    d <> s.
+  Proof.
+    ii. apply find_mv_exists in H0. des. inversion H.
+    assert (use_code f s pc). econstructor; eauto.
+    assert (assigned_code_spec (fn_code f) pc s). subst. econstructor; eauto.
+    eauto.
+  Qed.
+
+  Lemma elim_mv_code_spec : forall c c' pc ins d s,
+    c ! pc = Some ins ->
+    c' = elim_mv_code d s c ->
+    c' ! pc = Some ins \/
+    match ins with
+    | Inop pc' => c' ! pc = Some (Inop pc')
+    | Iop Omove _ dst pc' =>
+      (dst = d /\ c' ! pc = Some (Inop pc')) \/
+      exists args', c' ! pc = Some (Iop Omove args' dst pc')
+    | Iop op _ dst pc' =>
+      exists args', c' ! pc = Some (Iop op args' dst pc')
+    | Iload chunk addr args dst pc' =>
+      exists args', c' ! pc =
+      Some (Iload chunk addr args' dst pc')
+    | Istore chunk addr args src pc' =>
+      exists args' src', c' ! pc =
+      Some (Istore chunk addr args' src' pc')
+    | Icall sig ros args res pc' =>
+      exists ros' args', c' ! pc =
+      Some (Icall sig ros' args' res pc')
+    | Itailcall sig ros args =>
+      exists ros' args', c' ! pc = Some (Itailcall sig ros' args')
+    | Ibuiltin ef args res pc' =>
+      exists args', c' ! pc = Some (Ibuiltin ef args' res pc')
+    | Icond cond args ifso ifnot =>
+      exists args', c' ! pc = Some (Icond cond args' ifso ifnot)
+    | Ijumptable arg tbl =>
+      exists arg', c' ! pc = Some (Ijumptable arg' tbl)
+    | Ireturn optarg => exists optarg', c' ! pc = Some (Ireturn optarg')
+  end.
+  Proof.
+    unfold elim_mv_code. i. subst. rewrite PTree.gmap. rewrite H; ss.
+    destruct ins; ss; eauto.
+    destruct o; ss; eauto. destruct (r =? d)%positive eqn:Erd.
+    pose proof Erd as Erd'. rewrite Pos.eqb_eq in Erd'. ss; auto.
+    ss. right. right. eauto.
+  Qed.
+
+  Lemma fn_code_elim_mv: forall c c' pc ins' d s,
+    c' = elim_mv_code d s c ->
+    c' ! pc = Some ins' ->
+    exists ins, c ! pc = Some ins.
+  Proof.
+    i. destruct (c ! pc) eqn:Ec; eauto.
+    subst. unfold elim_mv_code in H0. rewrite PTree.gmap in H0.
+    rewrite Ec in H0. ss.
+  Qed.
+
+  Lemma elim_mv_code_spec' : forall c c' pc ins' d s,
+    c' = elim_mv_code d s c ->
+    c' ! pc = Some ins' ->
+    c ! pc = Some ins' \/
+    match ins' with
+    | Inop pc' =>
+      c ! pc = Some (Inop pc') \/
+      exists args', c ! pc = Some (Iop Omove args' d pc')
+    | Iop op args dst pc' =>
+      exists args', c ! pc = Some (Iop op args' dst pc')
+    | Iload chunk addr args dst pc' =>
+      exists args', c ! pc = Some (Iload chunk addr args' dst pc')
+    | Istore chunk addr args src pc' =>
+      exists args' src', c ! pc = Some (Istore chunk addr args' src' pc')
+    | Icall sig ros args res pc' =>
+      exists ros' args', c ! pc = Some (Icall sig ros' args' res pc')
+    | Itailcall sig ros args =>
+      exists ros' args', c ! pc = Some (Itailcall sig ros' args')
+    | Ibuiltin ef args res pc' =>
+      exists args', c ! pc = Some (Ibuiltin ef args' res pc')
+    | Icond cond args ifso ifnot =>
+      exists args', c ! pc = Some (Icond cond args' ifso ifnot)
+    | Ijumptable arg tbl =>
+      exists arg', c ! pc = Some (Ijumptable arg' tbl)
+    | Ireturn optarg => exists optarg', c ! pc = Some (Ireturn optarg')
+  end.
+  Proof.
+    i. eapply fn_code_elim_mv in H0 as Hcins; eauto. des.
+    eapply elim_mv_code_spec in Hcins as Hc'; eauto. des.
+    - clarify. auto.
+    - destruct ins; des; ss; clarify; eauto.
+    destruct o; des; ss; clarify; eauto.
+  Qed.
+
+  Lemma assigned_code_spec_elim_mv: forall f d s pc r,
+    wf_ssa_function f ->
+    assigned_code_spec (elim_mv_code d s (fn_code f)) pc r ->
+    assigned_code_spec (fn_code f) pc r.
+  Proof.
+    i. inv H0; edestruct elim_mv_code_spec'; eauto; ss; des;
+    assert (assigned_code_spec (fn_code f) pc r) by eauto; eauto.
+  Qed.
+
+  Lemma assigned_code_spec_elim_mv': forall f d s pc r,
+    wf_ssa_function f ->
+    r <> d ->
+    assigned_code_spec (fn_code f) pc r ->
+    assigned_code_spec (elim_mv_code d s (fn_code f)) pc r.
+  Proof.
+    i. inv H1; edestruct elim_mv_code_spec; eauto; ss; des;
+    eauto using assigned_code_spec.
+    destruct op; des; eauto using assigned_code_spec. congruence.
+  Qed.
+
+  Lemma assigned_phi_spec_elim_mv: forall f d s pc r,
+    wf_ssa_function f ->
+    assigned_phi_spec (elim_mv_phicode d s (fn_phicode f)) pc r ->
+    assigned_phi_spec (fn_phicode f) pc r.
+  Proof.
+    unfold elim_mv_phicode. i. inv H0. rewrite PTree.gmap in H1.
+    destruct ((fn_phicode f) ! pc) eqn:Ephiblock; ss.
+    inv H1. destruct H2 as [args H3].
+    econstructor; eauto. remember (map _ _). apply in_split in H3.
+    des. clarify. apply map_eq_app in H3. des; clarify.
+    apply map_eq_cons in H1. des; clarify. destruct a. ss. inv H0.
+    assert (Hin: forall r p ins, In ins (remove_mv_phiblock r p) -> In ins p).
+    { induction p0; ss. destruct a; ss. i. flatten H0; ss; auto. intuition. }
+    exists l. eapply Hin. rewrite H3. rewrite in_app. right; auto.
+  Qed.
+
+  Lemma assigned_phi_spec_elim_mv': forall f d s pc r,
+    wf_ssa_function f ->
+    r <> d ->
+    assigned_phi_spec (fn_phicode f) pc r ->
+    assigned_phi_spec (elim_mv_phicode d s (fn_phicode f)) pc r.
+  Proof.
+    i. inv H1; ss. des; ss. econstructor.
+    unfold elim_mv_phicode. rewrite PTree.gmap. rewrite H2. ss.
+    exists (map (rename_reg d s) args).
+    apply in_split in H3. des. clarify.
+    assert (forall l1 l2 d, remove_mv_phiblock d (l1 ++ l2) =
+    remove_mv_phiblock d l1 ++ remove_mv_phiblock d l2).
+    { induction l0; ss. i. destruct a; ss. flatten. rewrite IHl0. reflexivity. }
+    rewrite H1. rewrite in_map_iff. exists (Iphi args r). split.
+    reflexivity. apply in_app_iff. right.
+    unfold remove_mv_phiblock. flatten; eauto.
+    rewrite Pos.eqb_eq in Eq; congruence.
+  Qed.
+
+  Lemma phi_prop_elim_mv: forall f d s pc p',
+    wf_ssa_function f ->
+    (elim_mv_phicode d s (fn_phicode f)) ! pc = Some p' ->
+    NoDup p' /\
+    forall r args args', In (Iphi args r) p' ->
+    In (Iphi args' r) p' -> args = args'.
+  Proof.
+    i. inv H. inv fn_ssa.
+    clear fn_ssa_params fn_strict fn_use_def_code fn_wf_block fn_normalized
+    fn_phicode_inv fn_code_reached fn_code_closed fn_entry fn_entry_pred
+    fn_ext_params_complete fn_dom_test_correct H.
+    assert (Hphib: exists phib, (fn_phicode f) ! pc = Some phib).
+    { unfold elim_mv_phicode in H0. rewrite PTree.gmap in H0.
+    destruct (fn_phicode f) ! pc; eauto. }
+    des. eapply H1 in Hphib as Hphibnodup; eauto.
+    assert (Hpreserve: forall p p', NoDup p /\
+    (forall r args args', In (Iphi args r) p ->
+    In (Iphi args' r) p ->
+    args = args') ->
+    p' = map (subst_phi d s) (remove_mv_phiblock d p) ->
+    NoDup p' /\
+    (forall r args args', In (Iphi args r) p' ->
+    In (Iphi args' r) p' ->
+    args = args')).
+    { induction p; ss.
+    - i. clarify.
+    - i. destruct a; ss. flatten H2.
+    + eapply IHp; eauto. des. inv H. split; auto. i. eauto.
+    + assert (forall pb l0 l l',
+    remove_mv_phiblock d pb = l ++ Iphi l0 r :: l' ->
+    In (Iphi l0 r) pb).
+    { induction pb; ss; i. destruct l1; ss. destruct a; ss.
+    flatten H0. apply IHpb in H3. right; auto.
+    destruct l1.
+    - simpl in H3. inv H3. left; auto.
+    - inv H3. apply IHpb in H6. right; auto. }
+    ss; des; split.
+    * clarify. constructor.
+    intros contra. rewrite in_map_iff in contra. des.
+    destruct x. ss. inv contra. inv H. apply in_split in contra0. des.
+    specialize (H3 _ _ _ _ contra0). specialize (H4 r l l0).
+    assert (l = l0); auto. subst. auto.
+    exploit IHp. split. inv H; auto. i. eauto. reflexivity.
+    i. des. auto.
+    * assert (Hpres: forall d s r phiblock args,
+    (r =? d)%positive = false ->
+    In (Iphi args r)
+    (map (subst_phi d s) (remove_mv_phiblock d phiblock)) ->
+    exists args', In (Iphi args' r) phiblock).
+    { intros d0 s0 r2 phiblock; revert d0 s0.
+    induction phiblock; ss. i. destruct a; ss. flatten H6.
+    - destruct (IHphiblock _ _ _ H5 H6). exists x. right; eauto.
+    - ss. des.
+    + inv H6. exists l0. left. auto.
+    + destruct (IHphiblock _ _ _ H5 H6). exists x. right. eauto. }
+    i. clarify; ss. des.
+    inv H5. inv H6. reflexivity.
+    inv H5. inv H. specialize (Hpres _ _ _ _ _ Eq H6). des.
+    exploit H4. left; reflexivity. right; apply Hpres. i. subst. intuition.
+    inv H6. inv H. specialize (Hpres _ _ _ _ _ Eq H5). des.
+    exploit H4. left; reflexivity. right; apply Hpres. i. subst. intuition.
+    eapply IHp. inv H. split. auto. i. eapply H4; eauto.
+    reflexivity. apply H5. apply H6. }
+    unfold elim_mv_phicode in H0. rewrite PTree.gmap in H0. rewrite Hphib in H0.
+    ss. inv H0. eapply Hpreserve; eauto.
+  Qed.
+
+  Lemma elim_mv_preserve_unique_def_spec: forall f f' c p d s,
+    wf_ssa_function f ->
+    (fn_code f) = c ->
+    (fn_phicode f) = p ->
+    find_mv_code c = Some (d, s) \/ find_mv_phicode p = Some (d, s) ->
+    f' = mkfunction
+    (fn_sig f)
+    (fn_params f)
+    (fn_stacksize f)
+    (elim_mv_code d s c)
+    (elim_mv_phicode d s p)
+    (fn_entrypoint f)
+    (fn_ext_params f)
+    (fn_dom_test f) ->
+    unique_def_spec f'.
+  Proof.
+    i. repeat split.
+    - i. clarify; ss. eapply assigned_code_spec_elim_mv in H4, H5; eauto.
+    inv H. inv fn_ssa. specialize (H r pc pc'). des; eauto.
+    - i. clarify; ss. eapply assigned_phi_spec_elim_mv in H4, H5; eauto.
+    inv H. inv fn_ssa. specialize (H r pc pc'). des; eauto.
+    - ii. clarify; ss. eapply assigned_code_spec_elim_mv in H4; eauto.
+    eapply assigned_phi_spec_elim_mv in H5; eauto.
+    inv H. inv fn_ssa. specialize (H r pc pc').
+    des; eapply H3 in H5; eauto.
+    - ii. clarify; ss. eapply assigned_phi_spec_elim_mv in H4; eauto.
+    eapply assigned_code_spec_elim_mv in H5; eauto.
+    inv H. inv fn_ssa. specialize (H r pc pc').
+    des; eapply H6 in H4; eauto.
+    - eapply phi_prop_elim_mv; eauto. clarify; eauto.
+    - eapply phi_prop_elim_mv; eauto. clarify; eauto.
+  Qed.
+
+  Lemma cfg_elim_mv: forall f f' c p d s,
+    (fn_code f) = c ->
+    (fn_phicode f) = p ->
+    f' = mkfunction
+    (fn_sig f)
+    (fn_params f)
+    (fn_stacksize f)
+    (elim_mv_code d s c)
+    (elim_mv_phicode d s p)
+    (fn_entrypoint f)
+    (fn_ext_params f)
+    (fn_dom_test f) ->
+    (forall i j, cfg f i j <-> cfg f' i j).
+  Proof.
+    split; i; clarify.
+    - inv H2. exploit elim_mv_code_spec; eauto; i; des;
+    try (econstructor; eauto; fail);
+    destruct ins; eauto; des; try (econstructor; eauto; fail).
+    destruct o; des; econstructor; eauto.
+    - inv H2. exploit elim_mv_code_spec'; eauto; i; des;
+    try (econstructor; eauto; fail);
+    destruct ins; eauto; des; try (econstructor; eauto; fail).
+  Qed.
+
+  Lemma fn_entrypoint_elim_mv: forall f f' c p d s,
+    (fn_code f) = c ->
+    (fn_phicode f) = p ->
+    f' = mkfunction
+    (fn_sig f)
+    (fn_params f)
+    (fn_stacksize f)
+    (elim_mv_code d s c)
+    (elim_mv_phicode d s p)
+    (fn_entrypoint f)
+    (fn_ext_params f)
+    (fn_dom_test f) ->
+    (fn_entrypoint f) = (fn_entrypoint f').
+  Proof.
+    i; ss; clarify; eauto.
+  Qed.
+
+  Lemma reached_elim_mv: forall f f' c p d s,
+    (fn_code f) = c ->
+    (fn_phicode f) = p ->
+    f' = mkfunction
+    (fn_sig f)
+    (fn_params f)
+    (fn_stacksize f)
+    (elim_mv_code d s c)
+    (elim_mv_phicode d s p)
+    (fn_entrypoint f)
+    (fn_ext_params f)
+    (fn_dom_test f) ->
+    (forall i, reached f i <-> reached f' i).
+  Proof.
+    split; intros.
+    erewrite <- (fn_entrypoint_elim_mv f); eauto.
+    apply star_eq with (cfg f); eauto.
+    intros; erewrite <- cfg_elim_mv; eauto.
+    apply star_eq with (cfg f'); auto.
+    intros a b; erewrite <- cfg_elim_mv; eauto.
+    erewrite <- (fn_entrypoint_elim_mv f) in *; eauto.
+  Qed. 
+
+  Lemma exit_exit : forall f f' c p d s pc,
+    (fn_code f) = c ->
+    (fn_phicode f) = p ->
+    f' = mkfunction
+    (fn_sig f)
+    (fn_params f)
+    (fn_stacksize f)
+    (elim_mv_code d s c)
+    (elim_mv_phicode d s p)
+    (fn_entrypoint f)
+    (fn_ext_params f)
+    (fn_dom_test f) ->
+    exit f pc <-> exit f' pc.
+  Proof.
+    split.
+    - intros.
+    assert (Hins: exists ins, (fn_code f) ! pc = Some ins).
+    { unfold exit in *.
+    flatten NOSTEP; eauto.
+    inv H2; go. } 
+    destruct Hins as [ins0 Hins0].
+    assert (exists ins, (fn_code f') ! pc = Some ins).
+    { clarify; ss. unfold elim_mv_code. rewrite PTree.gmap. rewrite Hins0.
+    ss. eauto. }
+    destruct H3 as [ins Hins].
+    unfold exit in *; rewrite Hins in *; rewrite Hins0 in *. clarify; ss.
+    exploit elim_mv_code_spec. apply Hins0. auto. i; des.
+    + rewrite H in Hins; inv Hins. auto.
+    + destruct ins0; ss; des; clarify.
+    - intros.
+    assert (Hins: exists ins, (fn_code f') ! pc = Some ins).
+    { unfold exit in *.
+    flatten NOSTEP; eauto.
+    inv H; go. }
+    destruct Hins as [ins0 Hins0].
+    unfold exit in *; rewrite Hins0 in *. clarify; ss.
+    exploit elim_mv_code_spec'; eauto. i; des.
+    + rewrite H; ss.
+    + destruct ins0; des; ss; clarify; rewrite H; eauto.
+  Qed.
+
+  Lemma ssapath_elim_mv: forall f f' c p d s,
+    (fn_code f) = c ->
+    (fn_phicode f) = p ->
+    f' = mkfunction
+    (fn_sig f)
+    (fn_params f)
+    (fn_stacksize f)
+    (elim_mv_code d s c)
+    (elim_mv_phicode d s p)
+    (fn_entrypoint f)
+    (fn_ext_params f)
+    (fn_dom_test f) ->
+    (forall i j p, SSApath f i p j <-> SSApath f' i p j).
+  Proof.
+    split.
+    - induction 1; go.
+      econstructor 2 with s2; auto.
+      inversion STEP.
+      + assert (cfg f' pc pc')
+        by (rewrite <- cfg_elim_mv; eauto; econstructor; eauto).
+        inv H0.
+        econstructor; eauto.
+        rewrite <- reached_elim_mv; auto.
+        go.
+      + assert (Hins: exists ins, (fn_code f) ! pc = Some ins).
+        { unfold exit in *.
+        flatten NOSTEP; eauto.
+        inv H; go. }
+        destruct Hins as [ins0 Hins0].
+        assert (exists ins, (fn_code f') ! pc = Some ins).
+        { clarify. ss. unfold elim_mv_code. rewrite PTree.gmap. rewrite Hins0.
+        ss. eauto. }
+        des. econstructor; eauto.
+      * rewrite reached_elim_mv in CFG; eauto.
+      * eapply (exit_exit f); eauto.
+    - induction 1; go.
+      econstructor 2 with s2; auto.
+      inversion STEP.
+      + assert (cfg f pc pc') by (rewrite cfg_elim_mv; eauto; econstructor; eauto).
+        inv H. econstructor; eauto; ss.
+        rewrite reached_elim_mv; eauto. ss; eauto.
+      + assert (Hins: exists ins, (fn_code f') ! pc = Some ins).
+        { unfold exit in *.
+        flatten NOSTEP; eauto.
+        inv H; go. } 
+        destruct Hins as [ins0 Hins0].
+        assert (exists ins, (fn_code f) ! pc = Some ins).
+        { clarify; ss. unfold elim_mv_code in Hins0. rewrite PTree.gmap in Hins0.
+        destruct ((fn_code f) ! pc); ss. eauto. }
+        des. econstructor; eauto. rewrite reached_elim_mv; eauto.
+        eapply exit_exit; eauto.
+  Qed.
+
+  Lemma dom_elim_mv: forall f f' c p d s,
+    (fn_code f) = c ->
+    (fn_phicode f) = p ->
+    f' = mkfunction
+    (fn_sig f)
+    (fn_params f)
+    (fn_stacksize f)
+    (elim_mv_code d s c)
+    (elim_mv_phicode d s p)
+    (fn_entrypoint f)
+    (fn_ext_params f)
+    (fn_dom_test f) ->
+    (forall n m, dom f n m <-> dom f' n m).
+  Proof.
+    split; i.
+    - inv H2. constructor. constructor.
+      + apply star_eq with (cfg f); auto. intros i j.
+        erewrite cfg_elim_mv; eauto.
+      + i. apply PATH. rewrite ssapath_elim_mv; eauto.
+    - inversion H2. constructor. constructor.
+      + apply star_eq with (cfg f'); auto. intros i j.
+        erewrite <- cfg_elim_mv; eauto.
+        clarify.
+      + i. apply PATH. clarify. rewrite <- ssapath_elim_mv; eauto.
+  Qed.
+
+  Lemma successors_elim_mv: forall f f' d s pc,
+    f' = mkfunction
+    (fn_sig f)
+    (fn_params f)
+    (fn_stacksize f)
+    (elim_mv_code d s (fn_code f))
+    (elim_mv_phicode d s (fn_phicode f))
+    (fn_entrypoint f)
+    (fn_ext_params f)
+    (fn_dom_test f) ->
+    (successors f) ! pc = (successors f') ! pc.
+  Proof.
+    i. unfold successors. repeat rewrite PTree.gmap1. unfold option_map.
+    destruct (fn_code f) ! pc eqn:Efpc.
+    - clarify; ss. eapply elim_mv_code_spec in Efpc as Ef'pc; eauto; des; clarify.
+      + rewrite Ef'pc; ss.
+      + destruct i; des; ss; try rewrite Ef'pc; ss.
+        destruct o; des; ss; try rewrite Ef'pc; ss. rewrite Ef'pc0; ss.
+    - destruct (fn_code f') ! pc eqn:Ef'pc; ss.
+      eapply elim_mv_code_spec' in Ef'pc; ss; eauto; des.
+      rewrite Efpc in Ef'pc; ss. destruct i; des; rewrite Efpc in *; discriminate.
+      clarify.
+  Qed. 
+
+  Lemma make_predecessors_elim_mv: forall f f' d s,
+    f' = mkfunction
+    (fn_sig f)
+    (fn_params f)
+    (fn_stacksize f)
+    (elim_mv_code d s (fn_code f))
+    (elim_mv_phicode d s (fn_phicode f))
+    (fn_entrypoint f)
+    (fn_ext_params f)
+    (fn_dom_test f) ->
+    (Kildall.make_predecessors (fn_code f') successors_instr) =
+    (Kildall.make_predecessors (fn_code f) successors_instr).
+  Proof.
+    intros.
+    eapply same_successors_same_predecessors. i.
+    eapply successors_elim_mv in H. unfold successors in *; eauto.
+  Qed.
+
+  Lemma join_point_elim_mv: forall f f' d s j,
+    f' = mkfunction
+    (fn_sig f)
+    (fn_params f)
+    (fn_stacksize f)
+    (elim_mv_code d s (fn_code f))
+    (elim_mv_phicode d s (fn_phicode f))
+    (fn_entrypoint f)
+    (fn_ext_params f)
+    (fn_dom_test f) ->
+    join_point j f <-> join_point j f'.
+  Proof.
+    split; intros.
+    - inversion H0.
+      erewrite @same_successors_same_predecessors with 
+          (m2:= (fn_code f'))
+          (f2:= successors_instr) in Hpreds; eauto.
+      + econstructor; eauto.
+      + i; eapply successors_elim_mv in H; unfold successors in *; eauto.
+    - inversion H0.
+      erewrite @same_successors_same_predecessors with 
+          (m2:= (fn_code f))
+          (f2:= successors_instr) in Hpreds; eauto.
+      + econstructor; eauto.
+      + generalize (successors_elim_mv f).
+        unfold successors. intros Hsuccs i. 
+        rewrite <- Hsuccs at 1; eauto.
+  Qed.
+
+  Lemma successors_list_elim_mv: forall f f' d s pc,
+    f' = mkfunction
+    (fn_sig f)
+    (fn_params f)
+    (fn_stacksize f)
+    (elim_mv_code d s (fn_code f))
+    (elim_mv_phicode d s (fn_phicode f))
+    (fn_entrypoint f)
+    (fn_ext_params f)
+    (fn_dom_test f) ->
+    (Kildall.successors_list (successors f) pc) =
+    (Kildall.successors_list (successors f') pc).
+  Proof.
+    unfold Kildall.successors_list. i. erewrite successors_elim_mv; eauto.
+  Qed.
+
+  Lemma use_exists_def : forall f x u,
+    use f x u -> exists d, def f x d.
+  Proof.
+    intros.
+    destruct (classic (exists pc, assigned_code_spec (fn_code f) pc x)).
+    destruct H0 ; eauto.
+    destruct (classic (exists pc, assigned_phi_spec (fn_phicode f) pc x)).
+    destruct H1 ; eauto.
+    exists (fn_entrypoint f) ; eauto.
+    econstructor ; eauto.
+    econstructor 2 ; eauto.
+  Qed.  
+  
+  Lemma path_first : forall f p pc pc',
+    SSApath f (Dom.PState pc) p (Dom.PState pc') ->
+    pc <> pc' ->
+    exists pc'', exists p', exists p'',
+      SSApath f (Dom.PState pc) p' (Dom.PState pc'') /\
+      ~ In pc' p' /\
+      pc'' <> pc' /\
+      Dom.path_step (cfg f) (exit f) (fn_entrypoint f)
+                    (Dom.PState pc'') pc'' (Dom.PState pc') /\
+      p = p'++(pc''::p'').
+  Proof.
+    induction p ; intros; inv H. 
+    congruence.
+    assert (a = pc) by (inv STEP; auto). inv H.
+    destruct s2.
+    destruct (peq pc0 pc').
+    (* peq *)
+    inv e.  exists pc. exists nil. exists p.
+    split; eauto.  econstructor ; eauto.
+    (* diff *)
+    exploit IHp ; eauto. intros [pc'' [p'  [p'' [Hp' [Hpc'' [Hdiff [Hnotin Happ]]]]]]].
+    exists pc''. exists (pc::p'). exists p''.
+    split ; auto.
+    econstructor ; eauto. 
+    split ; auto.
+    intro Hcont. inv Hcont. congruence. elim Hpc'' ; auto.
+    split. intro Hcont. inv Hcont. congruence.
+    split ; eauto. simpl. rewrite Happ ; auto.
+    exploit (@Dom.path_from_ret_nil node); eauto. intros Heq ; subst. 
+    inv PATH.
+  Qed.
+
+  Lemma no_infinite_loop: forall f pc,
+    wf_ssa_function f ->
+    reached f pc ->
+    join_point pc f ->
+    (forall pc', In pc' (Kildall.successors_list
+                (Kildall.make_predecessors (fn_code f) successors_instr) pc) ->
+    dom f pc pc') ->
+    False.
+  Proof.
+    i. apply (Dom.reached_path _ (exit f)) in H0 as HPATH. des.
+    remember (Datatypes.length p) as len. revert f pc H H0 p HPATH H1 H2 Heqlen.
+    induction len; ss.
+    - i. symmetry in Heqlen. apply length_zero_iff_nil in Heqlen. clarify.
+      inv HPATH. eapply fn_entrypoint_inv; eauto.
+    - i. eapply path_first in HPATH as Hf; eauto. des. inv Hf2. inv STEP.
+      assert (dom f pc pc''). apply H2.
+      eapply Kildall.make_predecessors_correct_1; eauto.
+      inv H4. congruence. apply PATH in Hf as Hi. auto.
+      ii; clarify. eapply fn_entrypoint_inv; eauto.
+  Qed.
+
+  Lemma no_phi_use_def: forall f s,
+    wf_ssa_function f ->
+    find_mv_phicode (fn_phicode f) = Some (s, s) ->
+    False.
+  Proof.
+    i. eapply find_mv_phicode_exists in H0. des.
+    eapply no_infinite_loop; eauto.
+    - apply fn_phicode_code in H0; auto. des; eauto.
+    - eapply assigned_phi_spec_join_point; eauto.
+    - i. eapply assigned_phi_spec_join_point in H as Hjoin; eauto.
+      eapply make_predecessors_some in H3 as Hsome; eauto.
+      2:{ unfold make_preds. unfold Kildall.successors_list in *.
+          destruct (Kildall.make_predecessors (fn_code f) successors_instr) ! pc
+            eqn:PREDS.
+          ss. rewrite PREDS. auto. inv H3. }
+      des.
+      assert (Hu: use_phicode f s pc').
+      { eapply index_pred_instr_some in Hsome as Hin; eauto.
+        2:{ eapply make_predecessors_correct2; eauto. }
+        des. econstructor; eauto.
+        eapply index_pred_some_nth in Hin as Hnth; eauto.
+        inv H. eapply fn_wf_block in H1; eauto.
+        eapply nth_error_some_same_length in H1; eauto. des. rewrite H1.
+        apply nth_error_some_in in H1. inv H1; clarify; ss.
+        rewrite forallb_forall in H2. apply H2 in H. rewrite Pos.eqb_eq in H.
+        clarify. }
+      assert (Hu': use f s pc') by eauto using use. inv H; eauto.
+  Qed.
+
+  Lemma no_phi_use_def' : forall f pc pc' phib args src dst,
+    wf_ssa_function f ->
+    (fn_phicode f) ! pc = Some phib ->
+    In (Iphi args dst) phib ->
+    (forall r, In r args -> r = src) ->
+    def f src pc' ->
+    dom f pc pc' ->
+    False.
+  Proof.
+    i. pose proof fn_phicode_code; eauto. eapply H5 in H as PCCODE; eauto.
+    clear H5. des. eapply no_infinite_loop; eauto.
+    eapply phicode_joinpoint; eauto.
+    i. eapply make_predecessors_some in H5 as PC'CODE; eauto.
+    2:{ unfold make_preds. unfold Kildall.successors_list in *.
+        destruct (Kildall.make_predecessors _ _) ! pc eqn:PREDSPC; ss.
+        eauto. } des.
+    eapply make_predecessors_correct2 in H5 as HIN; eauto.
+    eapply index_pred_instr_some in HIN as PC'SOME; eauto. des.
+    eapply (Dom.dom_trans peq). eauto.
+    eapply fn_strict; eauto. econstructor 2; eauto. econstructor; eauto.
+    eapply index_pred_some_nth in PC'SOME.
+    eapply nth_error_some_same_length in PC'SOME. des. rewrite PC'SOME.
+    eapply nth_error_in in PC'SOME. eapply H2 in PC'SOME; inv PC'SOME; clarify.
+    exploit fn_wf_block; eauto.
+  Qed.
+
+
+  Lemma use_code_d_elim_mv: forall f f' d s pc,
+    d <> s ->
+    f' = mkfunction
+    (fn_sig f)
+    (fn_params f)
+    (fn_stacksize f)
+    (elim_mv_code d s (fn_code f))
+    (elim_mv_phicode d s (fn_phicode f))
+    (fn_entrypoint f)
+    (fn_ext_params f)
+    (fn_dom_test f) ->
+    use_code f' d pc -> False.
+  Proof.
+    assert (Hnotin: forall l d s, d <> s -> ~ In d (map (rename_reg d s) l)).
+    { induction l; ss. ii. destruct H0. unfold rename_reg in *. flatten H0.
+      clarify. rewrite Pos.eqb_neq in Eq; eauto. eapply IHl; eauto. }
+    assert (Hnotinbarg: forall a d s, d <> s ->
+                        ~ In d (params_of_builtin_arg (rename_barg d s a))).
+    { induction a; ss.
+      - ii. des; eauto. unfold rename_reg in H0; flatten H0.
+        rewrite Pos.eqb_neq in Eq; congruence.
+      - ii. rewrite in_app_iff in H0; des.
+        + eapply IHa1; eauto.
+        + eapply IHa2; eauto.
+      - ii. rewrite in_app_iff in H0; des.
+        + eapply IHa1; eauto.
+        + eapply IHa2; eauto. }
+    assert (Hnotin': forall l d s, d <> s ->
+                     ~ In d (params_of_builtin_args (map (rename_barg d s) l))).
+    { induction l; ss. ii. rewrite in_app_iff in H0; des.
+      - apply Hnotinbarg in H0; eauto.
+      - eapply IHl; eauto. }
+    i. clarify; ss.
+    inv H1; ss; eapply elim_mv_code_spec' in H0 as Hf; des; eauto;
+    unfold elim_mv_code in *; rewrite PTree.gmap in *; rewrite Hf in *; ss;
+    try (apply in_split in H2; des; clarify;
+        unfold subst_instr in *; clarify; try destruct op; clarify; flatten H0;
+        eapply Hnotin; eauto; try rewrite H3; try rewrite H0;
+        rewrite in_app_iff; eauto);
+    try (clarify; try rewrite <- H0 in *; eapply Hnotin' in H2; eauto).
+    unfold rename_reg in H0; flatten H0. rewrite Pos.eqb_neq in Eq; eauto.
+    clarify. rewrite <- H3 in H2; eapply Hnotin in H2; eauto.
+    clarify. unfold rename_reg in H0; flatten H0. rewrite Pos.eqb_neq in Eq; eauto.
+    clarify. eapply Hnotin in H2; eauto.
+    clarify. unfold rename_reg in H2; flatten H2. rewrite Pos.eqb_neq in Eq; eauto.
+    clarify. destruct ros'; ss; clarify. unfold rename_reg in H1.
+    flatten H1; ss; rewrite Pos.eqb_neq in Eq; eauto.
+    clarify. unfold rename_reg in H2; flatten H2. rewrite Pos.eqb_neq in Eq; eauto.
+    clarify. destruct ros'; ss; clarify. unfold rename_reg in H1.
+    flatten H1; ss; rewrite Pos.eqb_neq in Eq; eauto.
+    clarify. unfold rename_reg in H0; flatten H0. rewrite Pos.eqb_neq in Eq; eauto.
+    clarify. unfold rename_reg in H0; flatten H0. rewrite Pos.eqb_neq in Eq; eauto.
+    clarify. unfold rename_reg in H0; flatten H0. rewrite Pos.eqb_neq in Eq; eauto.
+    clarify. unfold rename_reg in H0; flatten H0.
+    destruct optarg'; clarify. ss. flatten H0; clarify.
+    rewrite Pos.eqb_neq in Eq; eauto.
+  Qed.
+
+  Lemma use_reg_elim_mv: forall f f' d s pc,
+    d <> s ->
+    f' = mkfunction
+    (fn_sig f)
+    (fn_params f)
+    (fn_stacksize f)
+    (elim_mv_code d s (fn_code f))
+    (elim_mv_phicode d s (fn_phicode f))
+    (fn_entrypoint f)
+    (fn_ext_params f)
+    (fn_dom_test f) ->
+    use f' d pc -> False.
+  Proof.
+    i. inv H1.
+    - eapply use_code_d_elim_mv in H2; eauto.
+    - inv H2; ss.
+      unfold elim_mv_phicode in PHIB; rewrite PTree.gmap in PHIB.
+      destruct (fn_phicode f) ! pc0 eqn:Efpc; ss. inv PHIB.
+      assert (forall phib args dst, In (Iphi args dst) (map (subst_phi d s) phib) ->
+                                    nth_error args k = Some d ->
+                                    False).
+      { induction phib; ss. i. des.
+        - destruct a. ss. inv H0. apply nth_error_split in H1. des.
+          assert (forall l, In d (map (rename_reg d s) l) -> False).
+          { induction l0; ss. i; des.
+            - unfold rename_reg in H2. flatten H2.
+              rewrite Pos.eqb_neq in Eq; congruence.
+            - eauto. }
+          eapply H2. rewrite H1; eauto. rewrite in_app_iff. right; eauto.
+        - eauto. }
+      eauto.
+  Qed.
+
+  Lemma use_code_indep_elim_mv: forall f f' c p d s,
+    wf_ssa_function f ->
+    (fn_code f) = c ->
+    (fn_phicode f) = p ->
+    find_mv_code c = Some (d, s) \/ find_mv_phicode p = Some (d, s) ->
+    f' = mkfunction
+    (fn_sig f)
+    (fn_params f)
+    (fn_stacksize f)
+    (elim_mv_code d s c)
+    (elim_mv_phicode d s p)
+    (fn_entrypoint f)
+    (fn_ext_params f)
+    (fn_dom_test f) ->
+    (forall x u, use_code f' x u ->
+     x <> d /\ x <> s ->
+     use_code f x u).
+  Proof.
+    assert (Hin: forall l d s x, x <> s -> In x (map (rename_reg d s) l) -> In x l).
+    { induction l; ss. ii. des; clarify. left. unfold rename_reg in *. flatten.
+      right; eauto. }
+    assert (Hinb: forall l d s x, x <> s ->
+                  In x (params_of_builtin_args (map (rename_barg d s) l)) ->
+                  In x (params_of_builtin_args l)).
+    { 
+      assert (forall a d s x, x <> s ->
+                              In x (params_of_builtin_arg (rename_barg d s a)) ->
+                              In x (params_of_builtin_arg a)).
+      { induction a; ss; i.
+        - des; eauto. unfold rename_reg in H0. flatten H0; eauto.
+        - apply in_app_iff. apply in_app_iff in H0; des; eauto.
+        - apply in_app_iff. apply in_app_iff in H0; des; eauto. }
+      induction l; ss. ii. apply in_app_iff. apply in_app_iff in H1. des; eauto. }
+    i; clarify; destruct H5.
+    inv H4; ss; eapply elim_mv_code_spec' in H3 as Hf; eauto;
+    destruct Hf as [Hf | [args' Hf]];
+      try (unfold elim_mv_code in *; rewrite PTree.gmap in *; rewrite Hf in *;
+           ss; inv H3); try eauto using use_code.
+    - destruct op; flatten H6; inv H6; econstructor; eauto.
+    - destruct Hf. eapply elim_mv_code_spec' in H3 as Hf; eauto.
+      eapply UIstore; eauto. destruct Hf. clarify.
+      unfold elim_mv_code in H3; rewrite PTree.gmap in *; rewrite H4 in *; ss.
+      inv H3. destruct H5. unfold rename_reg in H3. flatten H3; clarify.
+      left; auto. right; eauto.
+    - destruct Hf. eapply elim_mv_code_spec' in H3 as Hf; eauto. destruct Hf.
+      + clarify. eapply UIcall; eauto.
+      + unfold elim_mv_code in H3; rewrite PTree.gmap in *; rewrite H4 in H3; ss;
+          inv H3.
+        destruct args'; ss. inv H8. eapply UIcall; eauto.
+        destruct H5. constructor 1. unfold rename_reg in H3. flatten H3; eauto.
+        constructor 2; eauto.
+    - destruct Hf as [args'' Hf]. unfold elim_mv_code in H3.
+      rewrite PTree.gmap in H3; rewrite Hf in H3; ss; inv H3. destruct args'; ss.
+      inv H6. eapply UItailcall; eauto.
+      destruct H5. unfold rename_reg in *. flatten H3; eauto. constructor 1; eauto.
+      constructor 2; eauto.
+    - destruct Hf. eapply elim_mv_code_spec' in H3 as Hf; eauto. destruct Hf.
+      + clarify. eapply UIcall2; eauto.
+      + unfold elim_mv_code in H3; rewrite PTree.gmap in *; rewrite H4 in H3; ss;
+          inv H3.
+        destruct args'; ss. inv H8. eapply UIcall2; eauto.
+    - destruct Hf as [args'' Hf]. unfold elim_mv_code in H3.
+      rewrite PTree.gmap in H3; rewrite Hf in H3; ss; inv H3. destruct args'; ss.
+      inv H6. eapply UItailcall2; eauto.
+    - eapply UIjump; eauto. rewrite H5; eauto.
+    - eapply UIjump; eauto. assert (rename_reg d s args' = args').
+      { unfold rename_reg. flatten; eauto. rewrite Pos.eqb_eq in Eq; clarify.
+        unfold rename_reg in *; eauto. flatten H1. }
+      rewrite H3; eauto.
+    - rewrite H5. eauto using use_code.
+    - destruct args'; ss. inv H5. unfold rename_reg in *. flatten; ss.
+      eauto using use_code.
+  Qed.
+
+  Lemma use_indep_elim_mv: forall f f' c p d s,
+    wf_ssa_function f ->
+    (fn_code f) = c ->
+    (fn_phicode f) = p ->
+    find_mv_code c = Some (d, s) \/ find_mv_phicode p = Some (d, s) ->
+    f' = mkfunction
+    (fn_sig f)
+    (fn_params f)
+    (fn_stacksize f)
+    (elim_mv_code d s c)
+    (elim_mv_phicode d s p)
+    (fn_entrypoint f)
+    (fn_ext_params f)
+    (fn_dom_test f) ->
+    (forall x u, x <> d -> x <> s -> use f' x u -> use f x u).
+  Proof.
+    i. inv H6.
+    - eapply use_code_indep_elim_mv in H7; eauto. econstructor; eauto.
+    - inv H7; ss.
+      unfold elim_mv_phicode in PHIB. rewrite PTree.gmap in PHIB.
+      destruct (fn_phicode f) ! pc eqn:EFPHI; ss. inv PHIB.
+      assert (forall p' args dst,
+              In (Iphi args dst) (map (subst_phi d s) (remove_mv_phiblock d p')) ->
+              nth_error args k = Some x ->
+              exists args',
+              args = map (rename_reg d s) args' /\
+              In (Iphi args' dst) p' /\
+              nth_error args' k = Some x).
+      { induction p'; ss. i. destruct a; ss. flatten H0.
+        - eapply IHp' in H0; eauto. destruct H0. exists x0. des; eauto.
+        - ss. destruct H0.
+          + inv H0. exists l. split; ss. split. left; ss.
+            assert (forall l k, nth_error (map (rename_reg d s) l) k = Some x ->
+                                nth_error l k = Some x).
+            { induction l0; ss. i. destruct k0; ss.
+              - inv H0. unfold rename_reg in *. flatten.
+              - eauto. }
+            eauto.
+          + eapply IHp' in H0; eauto. des; eauto.  }
+      eapply H0 in KARG as KARG'; eauto.
+      destruct KARG' as [args' [Hargs' [Hin Hn]]].
+      econstructor 2. econstructor.
+      apply EFPHI. apply Hin. apply Hn.
+      erewrite <- make_predecessors_elim_mv; eauto. ss. apply KPRED.
+  Qed.
+
+  Lemma def_indep_elim_mv: forall f f' c p d s,
+    wf_ssa_function f ->
+    (fn_code f) = c ->
+    (fn_phicode f) = p ->
+    find_mv_code c = Some (d, s) \/ find_mv_phicode p = Some (d, s) ->
+    f' = mkfunction
+        (fn_sig f)
+        (fn_params f)
+        (fn_stacksize f)
+        (elim_mv_code d s c)
+        (elim_mv_phicode d s p)
+        (fn_entrypoint f)
+        (fn_ext_params f)
+        (fn_dom_test f) ->
+    (forall x u, x <> d -> x <> s -> def f' x u -> def f x u).
+  Proof.
+  i. inv H6.
+  - ss. inversion H7; ss.
+    + econstructor. econstructor. auto.
+    + destruct H0 as [pc Huse].
+      eapply use_indep_elim_mv in Huse; eauto.
+      econstructor. econstructor 2; eauto.
+      ii. eapply assigned_phi_spec_elim_mv' in H0. apply H1 in H0; eauto.
+      eauto. eauto.
+      ii. eapply assigned_code_spec_elim_mv' in H0. apply H3 in H0; eauto.
+      eauto. eauto.
+  - eapply assigned_code_spec_elim_mv in H7; eauto.
+  - eapply assigned_phi_spec_elim_mv in H7; eauto.
+  Qed.
+
+  Lemma elim_mv_same_reg: forall f c p pc phib s args,
+    wf_ssa_function f ->
+    c = fn_code f ->
+    p = fn_phicode f ->
+    p ! pc = Some phib ->
+    In (Iphi (s :: args) s) phib ->
+    forallb (Pos.eqb s) args = true ->
+    forall pc', c ! pc' = (elim_mv_code s s c) ! pc' /\
+    forall pc'', pc'' <> pc -> p ! pc'' = (elim_mv_phicode s s p) ! pc''.
+  Proof.
+    assert (Hrrss: forall s r, rename_reg s s r = r).
+    { unfold rename_reg; i; flatten; ss. rewrite Pos.eqb_eq in Eq; eauto. }
+    assert (Hrrss': forall l s, map (rename_reg s s) l = l).
+    { induction l; ss. i. rewrite Hrrss. rewrite IHl; eauto. }
+    assert (Hrfss: forall s r, rename_fn s s r = r).
+    { unfold rename_fn. destruct r; ss. rewrite Hrrss; eauto. }
+    assert (Hrbss: forall barg s, rename_barg s s barg = barg).
+    { induction barg; ss.
+      - i; rewrite Hrrss; auto.
+      - i; rewrite IHbarg1; rewrite IHbarg2; auto.
+      - i; rewrite IHbarg1; rewrite IHbarg2; auto. }
+    assert (Hrbss': forall l s, map (rename_barg s s) l = l).
+    { induction l; ss. i; rewrite IHl. rewrite Hrbss; eauto. }
+    assert (Hss: forall i s, subst_instr s s i = i).
+    { i. unfold subst_instr.
+      destruct i; ss; try rewrite Hrrss'; eauto; try rewrite Hrrss; eauto;
+        try rewrite Hrfss; eauto; try rewrite Hrbss'; eauto.
+      destruct o; ss. rewrite Hrrss; eauto.  }
+    assert (Hspss: forall phib s, map (subst_phi s s) phib = phib).
+    { induction phib; ss. i; rewrite IHphib. unfold subst_phi.
+      destruct a; rewrite Hrrss'; ss. }
+    i. split.
+    - clarify. unfold elim_mv_code. rewrite PTree.gmap.
+      destruct (fn_code f) ! pc' eqn:FPC'; ss.
+      rewrite Hss.
+      destruct i; ss. destruct o; ss. flatten; ss.
+      rewrite Pos.eqb_eq in Eq; clarify.
+      assert (Ha: assigned_code_spec (fn_code f) pc' s) by eauto.
+      eapply assigned_code_and_phi in Ha; eauto. destruct Ha.
+    - i. unfold elim_mv_phicode. rewrite PTree.gmap.
+      destruct (p ! pc'') eqn:PPC''; ss. rewrite Hspss.
+      assert (forall phib s, (forall args, ~ In (Iphi args s) phib) ->
+              remove_mv_phiblock s phib = phib).
+      { induction phib0; ss. i. destruct a; ss. flatten.
+        - rewrite Pos.eqb_eq in Eq; clarify. exfalso; eapply H6; left; auto.
+        - erewrite IHphib0; eauto. }
+      rewrite H6; auto. ii. clarify.
+      assert (def f s pc'') by eauto using def.
+      assert (def f s pc) by eauto using def. eapply ssa_def_unique in H0; eauto.
+  Qed.
+
+  Lemma use_phicode_exists: forall f pc phib args s d,
+    wf_ssa_function f ->
+    (fn_phicode f) ! pc = Some phib ->
+    In (Iphi (s :: args) d) phib ->
+    forallb (Pos.eqb s) args = true ->
+    exists pc', use f s pc'.
+  Proof.
+    i. assert (join_point pc f). { eapply assigned_phi_spec_join_point; eauto. }
+    inv H3. destruct l; ss; try lia. destruct l; ss; try lia.
+    exists p; econstructor 2. econstructor; eauto. instantiate (1 := 0); ss.
+    unfold index_pred. unfold Kildall.successors_list.
+    rewrite Hpreds. unfold Utils.get_index; ss. flatten; ss.
+  Qed.
+
+  Lemma def_s_elim_mv: forall f f' c p d s,
+    wf_ssa_function f ->
+    (fn_code f) = c ->
+    (fn_phicode f) = p ->
+    find_mv_code c = Some (d, s) \/ find_mv_phicode p = Some (d, s) ->
+    f' = mkfunction
+    (fn_sig f)
+    (fn_params f)
+    (fn_stacksize f)
+    (elim_mv_code d s c)
+    (elim_mv_phicode d s p)
+    (fn_entrypoint f)
+    (fn_ext_params f)
+    (fn_dom_test f) ->
+    d <> s ->
+    forall pc, def f' s pc -> def f s pc.
+  Proof.
+    i. inv H5.
+    - inv H6; ss.
+      + econstructor. econstructor. auto.
+      + des.
+        * eapply find_mv_exists in H2; eauto. des.
+          assert (use f s pc0) by (econstructor; eauto using use_code).
+          econstructor. econstructor 2; eauto.
+          ii. eapply assigned_phi_spec_elim_mv' in H6; eauto. eapply H1; eauto.
+          ii. eapply assigned_code_spec_elim_mv' in H6; eauto. eapply H3; eauto.
+        * eapply find_mv_phicode_exists in H2; eauto. des.
+          eapply use_phicode_exists in H5; eauto. des.
+          econstructor. econstructor 2; eauto.
+          ii. eapply assigned_phi_spec_elim_mv' in H7; eauto. eapply H1; eauto.
+          ii. eapply assigned_code_spec_elim_mv' in H7; eauto. eapply H3; eauto.
+    - ss. inv H6; eapply elim_mv_code_spec' in H0; ss; des; eauto using def.
+    - ss. inv H6.
+      unfold elim_mv_phicode in H0. rewrite PTree.gmap in H0; ss.
+      destruct (fn_phicode f) ! pc eqn:FPHI; ss. destruct H1.
+      econstructor 3. econstructor; eauto. inv H0.
+      apply map_in_some in H1 as Hi; auto. destruct Hi as [ins [Hi Hs]].
+      destruct ins; ss. inv Hs.
+      assert (Hr: forall l args, In (Iphi args s) (remove_mv_phiblock d l) ->
+                  exists args', In (Iphi args' s) l).
+      { induction l0; ss. destruct a; ss. i. flatten H0; ss.
+        - apply IHl0 in H0; des; eauto.
+        - destruct H0; ss. inv H0. eauto. apply IHl0 in H0; des; eauto. }
+      apply Hr in Hi. destruct Hi. eauto.
+  Qed.
+
+  Lemma use_code_s_elim_mv: forall f f' c p d s,
+    wf_ssa_function f ->
+    (fn_code f) = c ->
+    (fn_phicode f) = p ->
+    find_mv_code c = Some (d, s) \/ find_mv_phicode p = Some (d, s) ->
+    f' = mkfunction
+        (fn_sig f)
+        (fn_params f)
+        (fn_stacksize f)
+        (elim_mv_code d s c)
+        (elim_mv_phicode d s p)
+        (fn_entrypoint f)
+        (fn_ext_params f)
+        (fn_dom_test f) ->
+    d <> s ->
+    forall pc, use_code f' s pc -> use_code f s pc \/ use_code f d pc.
+  Proof.
+    assert (Hds: forall d s x, rename_reg d s x = s -> x = s \/ x = d).
+    { unfold rename_reg. i; flatten. flatten H. rewrite Pos.eqb_eq in Eq; clarify.
+      right; auto. rewrite Pos.eqb_neq in Eq; clarify; left; auto. }
+    assert (Hds': forall l d s, In s (map (rename_reg d s) l) ->
+                                In s l \/ In d l).
+    { induction l; ss. i. des. apply Hds in H; des; clarify; auto.
+      apply IHl in H; eauto. des; eauto. }
+    assert (Hbds: forall ba d s,
+            In s (params_of_builtin_arg (rename_barg d s ba)) ->
+            In s (params_of_builtin_arg ba) \/ In d (params_of_builtin_arg ba)).
+    { induction ba; ss. i. des; eauto. apply Hds in H; des; clarify; eauto.
+      i. apply in_app_iff in H; des.
+      apply IHba1 in H; des; ss; repeat rewrite in_app_iff; eauto.
+      apply IHba2 in H; des; ss; repeat rewrite in_app_iff; eauto.
+      i. apply in_app_iff in H; des.
+      apply IHba1 in H; des; ss; repeat rewrite in_app_iff; eauto.
+      apply IHba2 in H; des; ss; repeat rewrite in_app_iff; eauto. }
+    assert (Hbds': forall l d s,
+            In s (params_of_builtin_args (map (rename_barg d s) l)) ->
+            In s (params_of_builtin_args l) \/ In d (params_of_builtin_args l)).
+    { induction l; ss. i. apply in_app_iff in H; des.
+      - apply Hbds in H; des; eauto.
+        left; apply in_app_iff; eauto. right; apply in_app_iff; eauto.
+      - apply IHl in H; des.
+        left; apply in_app_iff; eauto. right; apply in_app_iff; eauto. }
+    assert (Hfds: forall f d s, rename_fn d s f = inl s ->
+                                f = inl s \/ f = inl d).
+    { i; destruct f; ss. inv H; eauto. apply Hds in H1; des; clarify; eauto.
+      left; unfold rename_reg; flatten. }
+    i; clarify; ss.
+    inv H5; ss; eapply elim_mv_code_spec' in H0 as F'PC; try destruct F'PC; eauto;
+        try (left; econstructor; eauto using use_code; fail);
+        try destruct H3 as [args' FPC];
+        unfold elim_mv_code in *; rewrite PTree.gmap in *;
+          try rewrite FPC in *; ss; inv H0;
+          try (apply Hds' in H1; des; 
+            try (left; eauto using use_code; fail);
+            try (right; eauto using use_code; fail));
+          try (apply Hbds' in H1; des;
+            try (right; eauto using use_code; fail);
+            try (left; eauto using use_code; fail)).
+    - destruct op; ss; inv H5; try (apply Hds' in H1; des; 
+        try (right; eauto using use_code; fail);
+        try (left; eauto using use_code)).
+      flatten H3; ss. inv H3. apply Hds' in H1; destruct H1.
+      left; eauto using use_code.
+      right; eauto using use_code.
+    - destruct FPC as [src' FPC]. rewrite FPC in *; ss. inv H5.
+      destruct H1. apply Hds in H0; destruct H0; clarify.
+      left; eauto using use_code. right; eauto using use_code.
+      apply Hds' in H0; destruct H0.
+      left; eauto using use_code. right; eauto using use_code.
+    - destruct FPC as [src' FPC]. rewrite FPC in *; ss. inv H5.
+      destruct H1. clarify. apply Hfds in H3; destruct H3; clarify.
+      left; eauto using use_code. right; eauto using use_code. destruct args'.
+      apply Hds' in H0; destruct H0.
+      left; eauto using use_code. right; eauto using use_code.
+      unfold rename_fn in H3. inv H3.
+    - destruct FPC as [src' FPC]. rewrite FPC in *; ss. inv H5.
+      destruct H1. clarify. apply Hfds in H3; destruct H3; clarify.
+      left; eauto using use_code. right; eauto using use_code. destruct args'.
+      apply Hds' in H0; destruct H0.
+      left; eauto using use_code. right; eauto using use_code.
+      unfold rename_fn in H3. inv H3.
+    - destruct FPC as [src' FPC]. rewrite FPC in *; ss. inv H5.
+      apply Hds' in H1; destruct H1; clarify. destruct args'.
+      left; eauto using use_code. left; eauto using use_code. destruct args'.
+      right; eauto using use_code. right; eauto using use_code.
+    - destruct FPC as [src' FPC]. rewrite FPC in *; ss. inv H5.
+      apply Hds' in H1; destruct H1; clarify. destruct args'.
+      left; eauto using use_code. left; eauto using use_code. destruct args'.
+      right; eauto using use_code. right; eauto using use_code.
+    - destruct H1. rewrite H0 in *. ss. inv H5.
+      rewrite H3. apply Hds in H3; des;
+      try (left; clarify; eauto using use_code; fail);
+      try (right; clarify; eauto using use_code).
+    - destruct H1 as [args' H1]. unfold option_map in H5.
+      destruct args'; ss. rewrite H1 in H5. inv H5. rewrite H3.
+      apply Hds in H3; destruct H3; clarify.
+      left; eauto using use_code.
+      right; eauto using use_code.
+      rewrite H1 in H5; inv H5.
+  Qed.
+
+  Lemma use_s_elim_mv: forall f f' c p d s,
+    wf_ssa_function f ->
+    (fn_code f) = c ->
+    (fn_phicode f) = p ->
+    find_mv_code c = Some (d, s) \/ find_mv_phicode p = Some (d, s) ->
+    f' = mkfunction
+        (fn_sig f)
+        (fn_params f)
+        (fn_stacksize f)
+        (elim_mv_code d s c)
+        (elim_mv_phicode d s p)
+        (fn_entrypoint f)
+        (fn_ext_params f)
+        (fn_dom_test f) ->
+    d <> s ->
+    forall pc, use f' s pc -> use f s pc \/ use f d pc.
+  Proof.
+    assert (Hds: forall d s x, rename_reg d s x = s -> x = s \/ x = d).
+    { unfold rename_reg. i; flatten. flatten H. rewrite Pos.eqb_eq in Eq; clarify.
+      right; auto. rewrite Pos.eqb_neq in Eq; clarify; left; auto. }
+    assert (Hds': forall l d s, In s (map (rename_reg d s) l) ->
+                                In s l \/ In d l).
+    { induction l; ss. i. des. apply Hds in H; des; clarify; auto.
+      apply IHl in H; eauto. des; eauto. }
+    assert (Hbds: forall ba d s,
+            In s (params_of_builtin_arg (rename_barg d s ba)) ->
+            In s (params_of_builtin_arg ba) \/ In d (params_of_builtin_arg ba)).
+    { induction ba; ss. i. des; eauto. apply Hds in H; des; clarify; eauto.
+      i. apply in_app_iff in H; des.
+      apply IHba1 in H; des; ss; repeat rewrite in_app_iff; eauto.
+      apply IHba2 in H; des; ss; repeat rewrite in_app_iff; eauto.
+      i. apply in_app_iff in H; des.
+      apply IHba1 in H; des; ss; repeat rewrite in_app_iff; eauto.
+      apply IHba2 in H; des; ss; repeat rewrite in_app_iff; eauto. }
+    assert (Hbds': forall l d s,
+            In s (params_of_builtin_args (map (rename_barg d s) l)) ->
+            In s (params_of_builtin_args l) \/ In d (params_of_builtin_args l)).
+    { induction l; ss. i. apply in_app_iff in H; des.
+      - apply Hbds in H; des; eauto.
+        left; apply in_app_iff; eauto. right; apply in_app_iff; eauto.
+      - apply IHl in H; des.
+        left; apply in_app_iff; eauto. right; apply in_app_iff; eauto. }
+    assert (Hfds: forall f d s, rename_fn d s f = inl s ->
+                                f = inl s \/ f = inl d).
+    { i; destruct f; ss. inv H; eauto. apply Hds in H1; des; clarify; eauto.
+      left; unfold rename_reg; flatten. }
+    i; clarify; ss.
+    inv H5.
+    - eapply use_code_s_elim_mv in H0; eauto.
+      des; try (left; econstructor; eauto; fail); right; econstructor; eauto.
+    - remember (mkfunction
+                (fn_sig f)
+                (fn_params f)
+                (fn_stacksize f)
+                (elim_mv_code d s (fn_code f))
+                (elim_mv_phicode d s (fn_phicode f))
+                (fn_entrypoint f)
+                (fn_ext_params f)
+                (fn_dom_test f)) as f'.
+      inv H0; ss. destruct (fn_phicode f) ! pc0 eqn:FPC0; ss.
+      unfold elim_mv_phicode in PHIB; rewrite PTree.gmap in PHIB;
+      rewrite FPC0 in PHIB; ss; inv PHIB.
+      assert (Hpds: forall phib d s args dst,
+                    In (Iphi args dst)
+                    (map (subst_phi d s) (remove_mv_phiblock d phib)) ->
+                    nth_error args k = Some s ->
+                    exists args', In (Iphi args' dst) phib /\
+                    (nth_error args' k = Some s \/ nth_error args' k = Some d)).
+      { induction phib; ss; i. destruct a. flatten H0; ss.
+        - rewrite Pos.eqb_eq in Eq; clarify. apply IHphib in H0; eauto.
+          destruct H0; eauto. destruct H0 as [Hi [Hs | Hd]];
+            exists x; split; eauto.
+        - destruct H0.
+          + inv H0.
+            assert (forall l k, nth_error (map (rename_reg d0 s0) l) k = Some s0 ->
+                    nth_error l k = Some s0 \/ nth_error l k = Some d0).
+            { induction l0; ss; i. destruct k0; ss.
+              destruct k0; ss. inv H0.
+              apply Hds in H5; des; clarify; eauto;
+                unfold rename_reg; flatten; auto.
+              apply IHl0 in H0; des; eauto. }
+            apply H0 in H1. destruct H1; exists l; eauto.
+          + apply IHphib in H0; eauto. destruct H0; eauto.
+            destruct H0 as [Hi [Hs | Hd]]; exists x; split; eauto. }
+      eapply Hpds in ASSIG; eauto. destruct ASSIG as [args' [Hi [Hs | Hd]]].
+      left; econstructor 2; econstructor; eauto.
+      erewrite <- make_predecessors_elim_mv; eauto. ss. apply KPRED.
+      right; econstructor 2; econstructor; eauto.
+      erewrite <- make_predecessors_elim_mv; eauto. ss. apply KPRED.
+      unfold elim_mv_phicode in PHIB; rewrite PTree.gmap in PHIB;
+        rewrite FPC0 in *; ss; congruence.
+  Qed.
+
+  Lemma all_dom: forall f pc pc'' phib s d args,
+    wf_ssa_function f ->
+    (fn_phicode f) ! pc = Some phib ->
+    In (Iphi (s :: args) d) phib ->
+    (forall pc',
+    In pc' (Kildall.successors_list
+            (Kildall.make_predecessors (fn_code f) successors_instr) pc) ->
+    dom f pc'' pc') ->
+    dom f pc'' pc.
+  Proof.
+    i.
+    assert (reached f pc).
+    { apply fn_phicode_code in H0; auto. des. apply fn_code_reached in H0; auto. }
+    econstructor; eauto. i.
+    assert (exists pc',
+            In pc' (Kildall.successors_list
+                    (Kildall.make_predecessors (fn_code f) successors_instr) pc) /\
+            In pc' p).
+    { apply path_first in H4. des. clarify. inv H7. inv STEP. exists pc''0.
+      split. eapply Kildall.make_predecessors_correct_1 in HCFG_ins; eauto.
+      apply in_app_iff. right; auto.
+      ii. eapply no_assigned_phi_spec_fn_entrypoint; eauto. econstructor; eauto.
+      clarify. }
+    des. apply H2 in H5. inv H5; auto.
+    eapply Dom.in_path_split_app in H6; eauto; try apply Pos.eq_dec. des.
+    apply PATH in H6. clarify. apply in_app_iff. left; auto.
+  Qed.
+
+  Lemma all_phi_dom: forall f pc phib s d args pc',
+    wf_ssa_function f ->
+    (fn_phicode f) ! pc = Some phib ->
+    In (Iphi (s :: args) d) phib ->
+    forallb (Pos.eqb s) args = true ->
+    def f s pc' ->
+    dom f pc' pc.
+  Proof.
+    i. assert (reached f pc).
+    { apply fn_phicode_code in H0; auto. des. apply fn_code_reached in H0; auto. }
+    eapply all_dom; eauto. i.
+    assert (use f s pc'0).
+    { econstructor 2.
+      unfold Kildall.successors_list in H5.
+      remember (Kildall.make_predecessors (fn_code f) successors_instr) ! pc.
+      destruct o; ss.
+      apply in_get_index_some in H5. des.
+      econstructor; eauto.
+      2:{ unfold index_pred. unfold Kildall.successors_list. rewrite <- Heqo.
+          apply H5. }
+      assert (index_pred (Kildall.make_predecessors (fn_code f) successors_instr)
+              pc'0 pc = Some k).
+      { unfold index_pred. unfold Kildall.successors_list. rewrite <- Heqo. auto. }
+      apply index_pred_some in H6. inv H. unfold block_nb_args in fn_wf_block.
+      eapply fn_wf_block in H0; eauto. rewrite H0 in H6.
+      apply nth_error_Some in H6. destruct (nth_error (s :: args) k) eqn:NTH; ss.
+      assert (forall l k r, forallb (Pos.eqb s) l = true ->
+                            nth_error (s :: l) k = Some r ->
+                            r = s).
+      { induction l0; ss. i. destruct k0; ss. inv H7. auto.
+        destruct k0; ss. i. destruct k0; ss. inv H7. auto.
+        apply andb_prop in H. des. eapply IHl0 in H8; eauto.
+        rewrite Pos.eqb_eq in H; clarify; apply H7. }
+      apply H in NTH; eauto. clarify. }
+    inv H; eauto.
+  Qed.
+
+  Lemma elim_mv_preserve_fn_strict: forall f f' c p d s,
+    wf_ssa_function f ->
+    (fn_code f) = c ->
+    (fn_phicode f) = p ->
+    find_mv_code c = Some (d, s) \/ find_mv_phicode p = Some (d, s) ->
+    f' = mkfunction
+    (fn_sig f)
+    (fn_params f)
+    (fn_stacksize f)
+    (elim_mv_code d s c)
+    (elim_mv_phicode d s p)
+    (fn_entrypoint f)
+    (fn_ext_params f)
+    (fn_dom_test f) ->
+    forall x u d, use f' x u -> def f' x d -> dom f' d u.
+  Proof.
+    i. rewrite <- dom_elim_mv; eauto.
+    case_eq (d =? s)%positive; i.
+    - rewrite Pos.eqb_eq in H6; clarify. des.
+      apply find_mv_not_same in H2; congruence.
+      apply no_phi_use_def in H2; destruct H2; auto.
+    - case_eq (x =? d)%positive; i.
+      + rewrite Pos.eqb_eq in H7; clarify. rewrite Pos.eqb_neq in H6.
+        eapply use_reg_elim_mv in H4; eauto. inv H4.
+      + case_eq (x =? s)%positive; i.
+        * rewrite Pos.eqb_eq in H8; clarify.
+          rewrite Pos.eqb_neq in H6; ss. clear H7.
+          assert (def f s d0). { eapply def_s_elim_mv; eauto. }
+          eapply use_s_elim_mv in H4; eauto. destruct H4 as [Hus | Hus].
+          inv H; eauto.
+          des.
+          eapply find_mv_exists in H2; eauto. des.
+          assert (def f d pc) by eauto using def.
+          assert (use f s pc). { econstructor. econstructor; eauto. }
+          eapply Dom.dom_trans. apply Pos.eq_dec.
+          inv H. eapply fn_strict in H0; eauto.
+          inv H. eapply fn_strict in H1; eauto.
+          eapply find_mv_phicode_exists in H2; eauto. des.
+          assert (def f d pc) by eauto.
+          assert (dom f d0 pc).
+          { eapply all_phi_dom; eauto. }
+          inv H; eapply Dom.dom_trans; eauto.
+          apply Pos.eq_dec. eapply fn_strict; eauto.
+        * rewrite Pos.eqb_neq in H8, H7.
+          eapply use_indep_elim_mv in H4; eauto.
+          eapply def_indep_elim_mv in H5; eauto. inv H; eauto.
+  Qed.
+
+  Lemma elim_mv_preserve_wf_ssa_function: forall f f' c p d s,
+    wf_ssa_function f ->
+    (fn_code f) = c ->
+    (fn_phicode f) = p ->
+    find_mv_code c = Some (d, s) \/ find_mv_phicode p = Some (d, s) ->
+    f' = mkfunction
+        (fn_sig f)
+        (fn_params f)
+        (fn_stacksize f)
+        (elim_mv_code d s c)
+        (elim_mv_phicode d s p)
+        (fn_entrypoint f)
+        (fn_ext_params f)
+        (fn_dom_test f) ->
+    wf_ssa_function f'.
+  Proof.
+  i. constructor.
+  - eapply elim_mv_preserve_unique_def_spec; eauto.
+  - split.
+    + ii. clarify. eapply assigned_code_spec_elim_mv in H5; eauto.
+      inv H. apply fn_ssa_params in H4. apply H4 in H5. auto.
+    + ii. clarify. eapply assigned_phi_spec_elim_mv in H5; eauto.
+      inv H. apply fn_ssa_params in H4. apply H4 in H5. auto.
+  - eapply elim_mv_preserve_fn_strict; eauto.
+  - i. clarify. apply assigned_code_spec_elim_mv in H5; auto.
+    destruct (classic (d = s)).
+    + clarify. des. apply find_mv_not_same in H2; auto.
+      destruct (classic (x = s)).
+      * apply no_phi_use_def in H2; destruct H2; auto.
+      * eapply use_code_indep_elim_mv in H4; eauto. inv H; eauto.
+    + destruct (classic (x = d)).
+      * clarify. eapply use_reg_elim_mv; eauto. econstructor; eauto.
+      * destruct (classic (x = s)).
+        clarify. eapply use_code_s_elim_mv in H4; eauto.
+        destruct H4 as [Hs | Hd].
+        inv H; eauto. des.
+        { eapply find_mv_exists in H2. des.
+          assert (def f d pc0) by eauto.
+          assert (dom f pc0 pc).
+          inv H. eapply fn_strict; eauto. econstructor; eauto.
+          assert (use f s pc0). econstructor; eauto using use_code.
+          assert (def f s pc) by eauto. assert (dom f pc pc0) by (inv H; eauto).
+          apply Dom.dom_antisym in H8; eauto. clarify. inv H; eauto.
+          apply Pos.eq_dec. }
+        { eapply find_mv_phicode_exists in H2; eauto. des.
+          assert (def f d pc0) by eauto.
+          assert (dom f pc0 pc).
+          inv H. eapply fn_strict; eauto. econstructor; eauto.
+          assert (def f s pc) by eauto.
+          eapply all_phi_dom in H8; eauto.
+          apply Dom.dom_antisym in H8; eauto; try apply Pos.eq_dec. clarify.
+          assert (join_point pc f). eapply assigned_phi_spec_join_point; eauto.
+          inversion H8. destruct l; ss. lia.
+          destruct (classic (p = pc)).
+          - clarify. assert (exists ins, (fn_code f) ! pc = Some ins).
+            { inv H5; eauto. }
+            des. assert (NINOP: forall n, ins <> (Inop n)).
+            { i. inv H5; rewrite H10 in H9; inv H9; eauto; ii; inv H5. }
+            eapply ssa_not_Inop_not_phi in NINOP; eauto.
+            eapply make_predecessors_correct2; eauto. unfold make_preds.
+            unfold Kildall.successors_list. rewrite Hpreds. eauto.
+          - assert (use_phicode f s p). econstructor; eauto.
+            2:{ unfold index_pred. unfold Kildall.successors_list.
+                rewrite Hpreds. unfold Utils.get_index. ss. flatten. auto. } ss.
+            assert (use f s p). econstructor 2. eauto.
+            assert (dom f pc p). inv H; eauto. eapply no_infinite_loop; eauto.
+            inv H5; eapply wf_ssa_reached; eauto.
+            i. assert (use_phicode f s pc').
+            { eapply make_predecessors_some in H13 as Hs; eauto. des.
+              edestruct index_pred_instr_some. apply Hs.
+              eapply make_predecessors_correct2; eauto.
+              econstructor; eauto. apply index_pred_some_nth in H14.
+              inv H. unfold block_nb_args in fn_wf_block.
+              eapply fn_wf_block in H2; eauto.
+              eapply nth_error_some_same_length in H2; eauto. des.
+              rewrite H2. apply nth_error_in in H2.
+              rewrite forallb_forall in H4. inv H2; eauto.
+              apply H4 in H. rewrite Pos.eqb_eq in H. clarify.
+              unfold make_preds. unfold Kildall.successors_list.
+              destruct (Kildall.make_predecessors _ _) ! pc eqn:KPC; ss.
+              inv Hpreds. rewrite KPC. eauto. }
+            assert (use f s pc'). econstructor 2; eauto.
+            assert (def f s pc) by eauto. inv H; eauto. }
+          eapply use_code_indep_elim_mv in H4; eauto. inv H; eauto.
+  - unfold block_nb_args. i. erewrite make_predecessors_elim_mv; clarify. ss.
+    unfold elim_mv_phicode in H4; rewrite PTree.gmap in H4.
+    destruct (fn_phicode f) ! pc eqn:Efphi; ss. inv H4.
+    assert (forall phib,
+            In (Iphi args x) (map (subst_phi d s) (remove_mv_phiblock d phib)) ->
+            exists args',
+            In (Iphi args' x) phib /\ args = map (rename_reg d s) args').
+    { induction phib; ss. destruct a; ss. flatten; i.
+      - eapply IHphib in H0. des; eauto.
+      - ss. destruct H0.
+        + inv H0. exists l; eauto.
+        + apply IHphib in H0. des; eauto. }
+    apply H0 in H5. destruct H5 as [args' Hargs'].
+    assert (forall l, Datatypes.length l = Datatypes.length (map (rename_reg d s) l)).
+    { induction l; ss. rewrite IHl; eauto. }
+    destruct Hargs'. clarify. rewrite <- H1 at 1.
+    inv H. unfold block_nb_args in fn_wf_block.
+    eapply fn_wf_block; eauto.
+  - i. inv H. rewrite <- join_point_elim_mv in H4; eauto. ss.
+    eapply fn_normalized in H4; eauto.
+    + eapply elim_mv_code_spec in H4; eauto; des; eauto.
+    + erewrite successors_list_elim_mv; eauto.
+  - inv H. i. erewrite <- join_point_elim_mv; eauto. ss. split.
+    + i. apply fn_phicode_inv in H.
+      unfold elim_mv_phicode; rewrite PTree.gmap; destruct (fn_phicode f) ! jp; ss.
+    + i. apply fn_phicode_inv.
+      unfold elim_mv_phicode in H; rewrite PTree.gmap in H;
+      destruct (fn_phicode f) ! jp eqn:Efjp; ss.
+  - i.
+    rewrite <- reached_elim_mv; eauto. clarify; ss.
+    eelim elim_mv_code_spec'; eauto. destruct ins; i; des; eauto.
+  - intros pc pc' instr Hi Hj.
+    assert (cfg f pc pc')
+    by (rewrite cfg_elim_mv; eauto; econstructor; eauto).
+    inv H4.
+    exploit fn_code_closed; eauto.
+    intros [ii HH]; ss.
+    eapply elim_mv_code_spec in HH; des; destruct ii; eauto;
+    try destruct o; des; ss; eauto.
+  - exploit fn_entry; eauto.
+    intros [s' Hs].
+    exists s'; erewrite fn_entrypoint_elim_mv; eauto.
+    exploit (elim_mv_code_spec); eauto; ss. i. clarify. des; eauto.
+  - clarify; intros pc; rewrite <- cfg_elim_mv; auto;
+    erewrite fn_entrypoint_elim_mv; eauto; ss.
+    apply fn_entry_pred; auto.
+  - i. inv H4.
+    + ss. inv H; eauto.
+    + ss.
+      destruct (classic (d = s)).
+      * clarify. des. eapply find_mv_not_same in H2; congruence.
+        apply no_phi_use_def in H2; destruct H2; eauto.
+      * destruct H5 as [pc Hu].
+        destruct (classic (r = d)).
+        clarify. eapply use_reg_elim_mv in Hu; eauto. destruct Hu.
+        destruct (classic (r = s)).
+        clarify. assert (exists pc', use f s pc').
+        { des. eapply find_mv_exists in H2. des.
+          exists pc0; econstructor. eauto using use_code.
+          eapply find_mv_phicode_exists in H2. des.
+          assert (join_point pc0 f). inversion H. apply fn_phicode_inv.
+          intros contra. rewrite contra in *; discriminate.
+          inv H5. destruct l; ss; try lia. destruct l; ss; try lia.
+          exists p. econstructor 2. econstructor; eauto.
+          2:{ unfold index_pred. unfold Kildall.successors_list. rewrite Hpreds.
+              unfold Utils.get_index. ss. flatten; eauto. } ss. }
+        destruct H3 as [pc' Hus].
+        inversion H. apply fn_ext_params_complete.
+        econstructor 2; eauto.
+        ii. eapply assigned_phi_spec_elim_mv' in H. eapply H6; eauto.
+        eauto. eauto.
+        ii. eapply assigned_code_spec_elim_mv' in H. eapply H7; eauto.
+        eauto. eauto.
+        eapply use_indep_elim_mv in Hu; eauto.
+        inversion H. apply fn_ext_params_complete.
+        econstructor 2; eauto.
+        ii. eapply assigned_phi_spec_elim_mv' in H. eapply H6; eauto.
+        eauto. eauto.
+        ii. eapply assigned_code_spec_elim_mv' in H. eapply H7; eauto.
+        eauto. eauto.
+  - clarify; i; ss. erewrite <- dom_elim_mv; eauto; ss.
+    eapply fn_dom_test_correct; eauto. eapply reached_elim_mv; eauto.
+    Unshelve. eauto. eauto. eauto. eauto.
+  Qed.
+
+  Lemma simplify_mv_preserve_wf_ssa_function: forall fuel f f' c' p',
+    wf_ssa_function f ->
+    simplify_mv fuel (fn_code f) (fn_phicode f) = (c', p') ->
+    f' = mkfunction
+         f.(fn_sig)
+         f.(fn_params)
+         f.(fn_stacksize)
+         c'
+         p'
+         f.(fn_entrypoint)
+         f.(fn_ext_params)
+         f.(fn_dom_test) ->
+    wf_ssa_function f'.
+  Proof.
+  induction fuel; ss.
+  - i. clarify. destruct f; eauto.
+  - i. destruct (find_mv_code (fn_code f)) eqn:Efind.
+  + destruct p.
+  remember (mkfunction (fn_sig f)
+  (fn_params f)
+  (fn_stacksize f)
+  (elim_mv_code r r0 (fn_code f))
+  (elim_mv_phicode r r0 (fn_phicode f))
+  (fn_entrypoint f)
+  (fn_ext_params f)
+  (fn_dom_test f)) as f0.
+  eapply elim_mv_preserve_wf_ssa_function in Heqf0 as Hf0wf; eauto.
+  eapply IHfuel; eauto. subst; ss. apply H0. subst; ss.
+  + destruct (find_mv_phicode (fn_phicode f)) eqn:Ephifind.
+  * destruct p.
+  remember (mkfunction (fn_sig f)
+  (fn_params f)
+  (fn_stacksize f)
+  (elim_mv_code r r0 (fn_code f))
+  (elim_mv_phicode r r0 (fn_phicode f))
+  (fn_entrypoint f)
+  (fn_ext_params f)
+  (fn_dom_test f)) as f0.
+  eapply elim_mv_preserve_wf_ssa_function in Heqf0 as Hf0wf; eauto.
+  eapply IHfuel; eauto. subst; ss. apply H0. subst; ss.
+  * clarify; eauto. destruct f; eauto.
+  Qed.
+
+  Lemma transf_function_preserve_wf_ssa_function : forall (f:function),
+  wf_ssa_function f -> wf_ssa_function (transf_function f).
+  Proof.
+  unfold transf_function. i. unfold transf_function_fuel.
+  destruct (simplify_mv _ _ _) eqn:Esim.
+  eapply simplify_mv_preserve_wf_ssa_function; eauto.
+  Qed.
+
+End PRESERVATION.
+
+Section CORRECTNESS_STEP.
+
+  Definition match_prog_step (p: SSA.program) (tp: SSA.program) :=
+    match_program (fun cu f tf => tf = transf_fundef_step f) eq p tp.
+
+  Lemma transf_program_step_match:
+   forall p, match_prog_step p (transf_program_step p).
+  Proof.
+   intros; subst.
+   eapply match_transform_program_contextual; auto.
+  Qed.
+
+  Variable prog: program.
+  Variable tprog: program.
+  Hypothesis TRANSL : match_prog_step prog tprog.
+  Hypothesis HWF : wf_ssa_program prog.
+
+  Fixpoint repeatn {A} (f: A -> A) (n: nat) a :=
+    match n with
+    | 0 => a
+    | S n' => f (repeatn f n' a)
+    end.
+
+  Lemma repeatn_distributive: forall A (f: A -> A) n m a,
+    repeatn f (m + n) a = repeatn f m (repeatn f n a).
+  Proof.
+    induction m; ss. i. rewrite IHm. eauto.
+  Qed.
+  
+  Lemma fold_find_mv_instr_xelements: forall c p1 p2 o,
+    fold_left (fun a (p: positive * instruction) => find_mv_instr a (fst p) (snd p))
+    (PTree.xelements c p1 nil) o =
+    fold_left (fun a (p: positive * instruction) => find_mv_instr a (fst p) (snd p))
+    (PTree.xelements c p2 nil) o.
+  Proof.
+    induction c.
+    - ss.
+    - i. destruct o0.
+      + destruct p. rewrite 2 PTree.xelements_node. destruct o; s.
+        * rewrite 2 fold_left_app. erewrite IHc1; eauto. ss.
+          erewrite (IHc2 c2 _ _ p1~1%positive). eauto.
+        * rewrite 2 fold_left_app.
+          erewrite (IHc1 c1 _ _ p1~0%positive); eauto.
+      + rewrite 2 PTree.xelements_node. destruct o; s.
+        * rewrite 2 fold_left_app. erewrite IHc1; eauto. ss.
+          erewrite (IHc2 c2 _ _ p1~1%positive). eauto.
+        * rewrite 2 fold_left_app.
+          erewrite (IHc1 c1 _ _ p1~0%positive); eauto.
+    Unshelve. eauto. eauto. eauto. eauto. eauto. eauto. eauto. eauto. eauto. eauto.
+  Qed.
+
+  Lemma find_mv_code_spec: forall c1 o c2,
+    find_mv_code (PTree.Node c1 o c2) =
+      let findc1 := find_mv_code c1 in
+      match findc1 with
+      | Some (d, s) => Some (d, s)
+      | None => match o with
+                | Some ins => match ins with
+                              | Iop Omove (src :: nil) dst _ => Some (dst, src)
+                              | _ => find_mv_code c2
+                              end
+                | None => find_mv_code c2
+                end
+      end.
+  Proof.
+    assert (forall l d s,
+            fold_left (fun a p => find_mv_instr a (fst p) (snd p)) l (Some (d, s))
+              = Some (d, s)).
+    { induction l; ss. }
+    i. destruct (find_mv_code c1) eqn:FINDC1.
+    - ss. destruct p. unfold find_mv_code in *. rewrite PTree.fold_spec in *.
+      unfold PTree.elements in *. rewrite PTree.xelements_node.
+      destruct o.
+      + ss. rewrite fold_left_app. erewrite fold_find_mv_instr_xelements.
+        rewrite FINDC1. ss.
+      + ss. rewrite fold_left_app. erewrite (fold_find_mv_instr_xelements c1).
+        rewrite FINDC1. ss.
+    - ss. unfold find_mv_code in *. repeat rewrite PTree.fold_spec in *.
+      unfold PTree.elements in *. rewrite PTree.xelements_node. destruct o; ss.
+      + rewrite fold_left_app; s. erewrite (fold_find_mv_instr_xelements c1).
+        rewrite FINDC1. ss. destruct i; ss; try eapply fold_find_mv_instr_xelements.
+        destruct o; ss; try eapply fold_find_mv_instr_xelements.
+        destruct l; ss; try eapply fold_find_mv_instr_xelements.
+        destruct l; ss; try eapply fold_find_mv_instr_xelements.
+      + rewrite fold_left_app; s. erewrite (fold_find_mv_instr_xelements c1).
+        rewrite FINDC1. eapply fold_find_mv_instr_xelements.
+  Qed.
+
+  Lemma transf_function_fuel_repeatn: forall f n,
+    transf_function_fuel n f = repeatn (transf_function_fuel 1) n f.
+  Proof.
+    i. induction n.
+    - destruct f; ss.
+    - ss. rewrite <- IHn. unfold transf_function_fuel.
+      destruct (simplify_mv n (fn_code f) (fn_phicode f)) eqn:ESIMPLN.
+      assert (forall f n,
+              simplify_mv (S n) (fn_code f) (fn_phicode f) =
+              let (cn, pn) := simplify_mv n (fn_code f) (fn_phicode f) in
+              simplify_mv 1 cn pn).
+      { i. revert f0. induction n0.
+        - i; ss.
+        - i. s.
+          destruct (find_mv_code (fn_code f0)) eqn:EFINDC.
+          + destruct p0.
+            specialize (IHn0 (mkfunction
+                              (fn_sig f0)
+                              (fn_params f0)
+                              (fn_stacksize f0)
+                              (elim_mv_code r r0 (fn_code f0))
+                              (elim_mv_phicode r r0 (fn_phicode f0))
+                              (fn_entrypoint f0)
+                              (fn_ext_params f0)
+                              (fn_dom_test f0))). ss.
+          + destruct (find_mv_phicode (fn_phicode f0)) eqn:EFINDP.
+            destruct p0. specialize (IHn0 (mkfunction
+                                    (fn_sig f0)
+                                    (fn_params f0)
+                                    (fn_stacksize f0)
+                                    (elim_mv_code r r0 (fn_code f0))
+                                    (elim_mv_phicode r r0 (fn_phicode f0))
+                                    (fn_entrypoint f0)
+                                    (fn_ext_params f0)
+                                    (fn_dom_test f0))). ss.
+            rewrite EFINDC, EFINDP. ss. }
+      rewrite H. s. rewrite ESIMPLN. ss.
+  Qed.
+
+  Lemma transf_function_fuel_commute: forall m n f,
+    transf_function_fuel n (transf_function_fuel m f) =
+      transf_function_fuel m (transf_function_fuel n f).
+  Proof.
+    induction n; ss.
+    - i. unfold transf_function_fuel. ss. destruct (simplify_mv m _ _). ss.
+    - i. rewrite transf_function_fuel_repeatn. ss.
+      rewrite <- transf_function_fuel_repeatn. rewrite IHn.
+      rewrite (transf_function_fuel_repeatn _ (S n)). ss.
+      rewrite <- transf_function_fuel_repeatn.
+      assert (forall o f, transf_function_fuel 1 (transf_function_fuel o f)
+                          = transf_function_fuel o (transf_function_fuel 1 f)).
+      { induction o; ss. i. unfold transf_function_fuel; flatten; ss. clarify.
+        flatten Eq; flatten Eq2; ss. i.
+        rewrite (transf_function_fuel_repeatn _ (S o)). ss.
+        rewrite <- transf_function_fuel_repeatn.
+        rewrite (transf_function_fuel_repeatn _ (S o)). ss.
+        rewrite <- transf_function_fuel_repeatn. rewrite IHo; ss. }
+      rewrite H. auto.
+  Qed.
+
+  Definition count_mv_instrs (n: nat) (pc: positive) ins : nat :=
+    match ins with
+    | Iop Omove (src :: nil) dst _ => S n
+    | _ => n
+    end.
+
+  Definition num_mv_instrs (c: code) :=
+    PTree.fold count_mv_instrs c 0.
+  
+  Lemma fold_left_accumulator: forall l n,
+    fold_left (fun a p => count_mv_instrs a (fst p) (snd p)) l n 
+    = fold_left (fun a p => count_mv_instrs a (fst p) (snd p)) l 0 + n.
+  Proof.
+    induction l; ss. destruct a. ss.
+    unfold count_mv_instrs at 2; ss. unfold count_mv_instrs at 3; ss.
+    destruct i; ss. destruct o; ss. destruct l0; ss. destruct l0; ss.
+    i. rewrite IHl. rewrite (IHl 1). lia.
+  Qed.
+
+  Lemma num_mv_instrs_bounded: forall c,
+    num_mv_instrs c < PTree.fold (fun m _ _ => 1 + m) c 1.
+  Proof.
+    assert (forall l n, fold_left (fun a (_: positive * instruction) => S a) l (S n)
+                        = fold_left (fun a (_: positive * instruction) => S a) l 1 + n).
+    { induction l; ss. rewrite IHl. i. rewrite (IHl (S n)). lia. }
+    i. unfold num_mv_instrs. rewrite 2 PTree.fold_spec.
+    generalize (PTree.elements c).
+    induction l; ss. rewrite H. destruct a. destruct i; ss; try lia.
+    destruct o; try lia. destruct l0; try lia. destruct l0; try lia.
+    rewrite fold_left_accumulator. lia.
+  Qed.
+
+  Lemma elim_mv_code_none: forall c d s,
+    find_mv_code c = None ->
+    find_mv_code (elim_mv_code d s c) = None.
+  Proof.
+    unfold find_mv_code. i. rewrite PTree.fold_spec in *.
+    destruct (fold_left _ (PTree.elements (elim_mv_code d s c)) None)
+      eqn:FOLD; auto. destruct p.
+    apply fold_find_mv_instr_some in FOLD. des.
+    apply PTree.elements_complete in FOLD. unfold elim_mv_code in FOLD.
+    rewrite PTree.gmap in FOLD. destruct (c ! pc) eqn:CPC; ss.
+    inv FOLD. destruct i; ss. destruct o; ss. flatten H2; ss. inv H1.
+    destruct l; ss. inv H2. destruct l; ss. clear H3.
+    apply PTree.elements_correct in CPC.
+    eapply fold_find_mv_instr_none in H. apply H in CPC. destruct CPC.
+  Qed.
+
+  Lemma num_mv_instrs_correct: forall c, num_mv_instrs c = 0 <-> find_mv_code c = None.
+  Proof.
+    induction c; ss. split.
+    - unfold num_mv_instrs, find_mv_code. rewrite 2 PTree.fold_spec.
+      generalize (PTree.elements (PTree.Node c1 o c2)). induction l; ss.
+      destruct a. destruct i; ss. destruct o0; ss. destruct l0; ss.
+      destruct l0; ss. i. rewrite fold_left_accumulator in H. lia.
+    - unfold num_mv_instrs, find_mv_code. rewrite 2 PTree.fold_spec.
+      generalize (PTree.elements (PTree.Node c1 o c2)). induction l; ss.
+      destruct a. destruct i; ss. destruct o0; ss. destruct l0; ss.
+      destruct l0; ss. i.
+      assert (forall l d s,
+              fold_left (fun a p => find_mv_instr a (fst p) (snd p)) l (Some (d, s))
+              = Some (d, s)).
+      { induction l0; ss. }
+      rewrite H0 in H. inv H.
+  Qed.
+
+  Lemma xelements_comm: forall A (m: PTree.t A) i k,
+    PTree.xelements m i k = PTree.xelements m i nil ++ k.
+  Proof.
+    induction m; ss. destruct o; ss. i. rewrite IHm1. rewrite (IHm1 _ (_ :: _)).
+    rewrite <- List.app_assoc. rewrite (IHm2 _ k). rewrite List.app_comm_cons. ss.
+    i. rewrite IHm2. rewrite PTree.xelements_append. ss.
+  Qed.
+
+  Lemma num_mv_instrs_dec: forall c f,
+    c = fn_code f ->
+    match (num_mv_instrs c) with
+    | 0 => num_mv_instrs (fn_code (transf_function_fuel 1 f)) = 0
+    | S n => num_mv_instrs (fn_code (transf_function_fuel 1 f)) <= n
+    end.
+  Proof.
+    i. flatten.
+    - unfold transf_function_fuel, simplify_mv. pose proof num_mv_instrs_correct as H0.
+      edestruct H0 as [H1 H2]. rewrite H1; ss.
+      destruct (find_mv_phicode (fn_phicode f)).
+      + destruct p; ss. rewrite H0. apply elim_mv_code_none. apply H1. clarify.
+      + ss. clarify.
+      + clarify.
+    - unfold transf_function_fuel. unfold simplify_mv.
+      destruct (find_mv_code (fn_code f)) eqn:FIND.
+      + destruct p; ss. apply find_mv_exists in FIND. des. rewrite <- H in *.
+        unfold num_mv_instrs. rewrite PTree.fold_spec.
+        unfold elim_mv_code. unfold PTree.map.
+        assert (forall c d s p p' p'' n,
+                let f := (fun (p: positive) ins =>
+                subst_instr d s (remove_mv_instr d ins)) in
+                let f' := (fun (pi : positive * instruction) =>
+                ((fst pi), subst_instr d s (remove_mv_instr d (snd pi)))) in
+                let f'' := (fun a p => count_mv_instrs a (fst p) (snd p)) in
+                fold_left f'' ((PTree.xelements (PTree.xmap f c p) p' nil)) n
+                  = fold_left f'' (List.map f' (PTree.xelements c p'' nil)) n).
+        { induction c0. ss. destruct o; ss.
+          - i. rewrite xelements_comm. rewrite fold_left_app.
+            rewrite IHc0_1 with (p'' := p''~0%positive); eauto.
+            rewrite (xelements_comm _ c0_1 p''~0%positive ((_ :: _))).
+            rewrite list_append_map. ss. rewrite fold_left_app.
+            rewrite IHc0_2 with (p'' := p''~1%positive); eauto.
+          - i. rewrite xelements_comm. rewrite fold_left_app.
+            erewrite (IHc0_1 c0_1); eauto. erewrite (IHc0_2 c0_2); eauto.
+            rewrite (xelements_comm _ c0_1 p''~0%positive (PTree.xelements _ _ nil)).
+            rewrite list_append_map. rewrite fold_left_app. ss. }
+        unfold PTree.elements. erewrite H0. eapply PTree.xelements_correct in FIND.
+        apply in_split in FIND. des. rewrite FIND. rewrite map_app. ss.
+        flatten; ss. 2: { rewrite Pos.eqb_neq in Eq0; ss. }
+        rewrite fold_left_app. ss. unfold num_mv_instrs in Eq.
+        rewrite PTree.fold_spec in Eq. unfold PTree.elements in Eq. rewrite FIND in Eq.
+        rewrite fold_left_app in Eq. ss.
+        remember (fold_left _ l1 0) as l1c. rewrite fold_left_accumulator in Eq.
+        rewrite fold_left_accumulator.
+        assert (forall l2,
+                let f := (fun a p => count_mv_instrs a (fst p) (snd p)) in
+                let f' :=
+                  (fun (pi: positive * instruction) =>
+                    (fst pi, subst_instr r r0 (remove_mv_instr r (snd pi)))) in
+                fold_left f (map f' l2) 0 <= fold_left f l2 0).
+        { induction l0; ss. rewrite fold_left_accumulator.
+          destruct a; s. destruct i; ss; try lia. destruct o; ss; try lia.
+          flatten; ss; try lia. rewrite (fold_left_accumulator _ 1). lia.
+          rewrite (fold_left_accumulator _ 1). lia. }
+        ss. specialize (H1 l1) as Hl1. specialize (H1 l2) as Hl2. lia.
+      + apply num_mv_instrs_correct in FIND. clarify. lia.
+  Qed.
+
+  Lemma find_elim_mv_code: forall c d s, find_mv_code c = None ->
+    find_mv_code (elim_mv_code d s c) = None.
+  Proof.
+    unfold find_mv_code. i. rewrite PTree.fold_spec in *.
+    destruct (fold_left _ (PTree.elements (elim_mv_code d s c)) None)
+      eqn:FOLD; auto. destruct p.
+    apply fold_find_mv_instr_some in FOLD. des.
+    apply PTree.elements_complete in FOLD. unfold elim_mv_code in FOLD.
+    rewrite PTree.gmap in FOLD. destruct (c ! pc) eqn:CPC; ss.
+    inv FOLD. destruct i; ss. destruct o; ss. flatten H2; ss.
+    inv H1. destruct l; ss. inv H2. destruct l; ss. clear H3.
+    apply PTree.elements_correct in CPC.
+    eapply fold_find_mv_instr_none in H. apply H in CPC. destruct CPC.
+  Qed.
+
+  Lemma find_transf_function_fuel_repeatn: forall f n,
+    find_mv_code (fn_code f) = None ->
+    find_mv_code (fn_code (transf_function_fuel n f)) = None.
+  Proof.
+    intros f n; revert f; induction n; ss.
+    i. rewrite transf_function_fuel_repeatn. ss.
+    rewrite <- transf_function_fuel_repeatn. unfold transf_function_fuel at 1.
+    flatten. unfold simplify_mv in Eq. flatten Eq.
+    - rewrite IHn in Eq0; eauto. discriminate.
+    - ss. apply find_elim_mv_code. eauto.
+    - ss.
+  Qed.
+
+  Lemma transf_function_fuel_code_idempotent: forall f n,
+    (PTree.fold (fun m _ _ => 1+m) f.(fn_code) 1%nat) <= n ->
+    find_mv_code (fn_code (transf_function_fuel n f)) = None.
+  Proof.
+    i. assert (num_mv_instrs (fn_code f) <= n).
+    { pose proof num_mv_instrs_bounded. specialize (H0 (fn_code f)). lia. }
+    clear H. revert f H0. induction n; ss. i. inv H0.
+    apply num_mv_instrs_correct; ss. i. inv H0.
+    - rewrite H1. rewrite transf_function_fuel_repeatn. ss.
+      rewrite <- transf_function_fuel_repeatn.
+      rewrite transf_function_fuel_commute. apply IHn.
+      pose proof num_mv_instrs_dec. specialize (H (fn_code f) f).
+      rewrite H1 in H. auto.
+    - rewrite transf_function_fuel_repeatn. ss.
+      rewrite <- transf_function_fuel_repeatn.
+      unfold transf_function_fuel at 1. unfold simplify_mv. flatten.
+      flatten Eq; ss. apply find_elim_mv_code; auto. apply find_elim_mv_code; auto.
+  Qed.
+
+  Definition phisize (p: phicode) :=
+    PTree.fold (fun m _ (blk: phiblock) => Datatypes.length blk + m) p 0.
+  
+  Lemma fold_left_accumulator_phi: forall l n,
+    let f := (fun a (p: positive * phiblock) => Datatypes.length (snd p) + a) in
+    fold_left f l n = fold_left f l 0 + n.
+  Proof.
+    induction l; ss. destruct a; ss. i. rewrite IHl.
+    rewrite (IHl (Datatypes.length p0 + 0)). lia.
+  Qed.
+
+  Lemma phisize_0: forall p,
+    phisize p = 0 -> find_mv_phicode p = None.
+  Proof.
+    unfold find_mv_phicode, phisize. i. rewrite PTree.fold_spec in *. revert H.
+    generalize (PTree.elements p). induction l; ss. destruct a; ss. i.
+    rewrite fold_left_accumulator_phi in H. destruct (Datatypes.length p1) eqn:LP1; ss.
+    - destruct p1; ss. apply IHl. lia.
+    - lia.
+  Qed.
+
+  Lemma find_mv_phicode_repeatn: forall f n,
+    find_mv_code (fn_code f) = None ->
+    find_mv_phicode (fn_phicode f) = None ->
+    transf_function_fuel n f = f.
+  Proof.
+    induction n; ss.
+    - i. unfold transf_function_fuel. ss. destruct f; ss.
+    - i. rewrite transf_function_fuel_repeatn. ss.
+      rewrite <- transf_function_fuel_repeatn. rewrite IHn; ss.
+      unfold transf_function_fuel. ss. rewrite H, H0. destruct f; ss.
+  Qed.
+
+  Lemma phisize_spec: forall (p: phicode),
+    phisize p =
+    match p with
+    | (PTree.Node p1 o p2) => match o with
+                              | Some l => Datatypes.length l + phisize p1 + phisize p2
+                              | None => phisize p1 + phisize p2
+                              end
+    | PTree.Leaf => 0
+    end.
+  Proof.
+    induction p; ss.
+    remember (fun m (p: positive) (blk: phiblock) => Datatypes.length blk + m) as f.
+    assert (forall m pos l, f m pos l = f 0 pos l + m).
+    { induction l; ss. clarify; ss. clarify; ss. rewrite IHl; lia. }
+    assert (forall p pos n, PTree.xfold f pos p n = PTree.xfold f pos p 0 + n).
+    { induction p; ss. destruct o0; ss. i. rewrite (IHp3 p3); eauto.
+      rewrite IHp4; eauto. erewrite (IHp4 p4 _ _ _ (f _ _ _)).
+      rewrite H. rewrite (H (PTree.xfold _ _ _ _)). rewrite 2 Nat.add_assoc.
+      apply f_equal2_plus; ss. rewrite Nat.add_assoc. apply f_equal2_plus; ss.
+      i. erewrite IHp4; eauto. erewrite (IHp4 p4 _ _ _ (PTree.xfold _ _ _ _)).
+      rewrite <- Nat.add_assoc. apply f_equal2_plus; ss. eauto. }
+    assert (forall pos p, PTree.xfold f pos p 0 = phisize p).
+    { intros pos p0; revert pos; induction p0; ss. unfold phisize. unfold PTree.fold.
+      ss. destruct o0; ss.
+      - i. rewrite H0. rewrite <- Heqf. rewrite H. rewrite IHp0_2; ss.
+        rewrite IHp0_1; ss. rewrite H0. rewrite IHp0_2; ss. rewrite H0.
+        rewrite IHp0_1; ss. clarify; ss. lia.
+      - i. rewrite H0. rewrite <- Heqf. rewrite IHp0_2; ss.
+        rewrite IHp0_1; ss. rewrite H0. rewrite IHp0_2; ss.
+        rewrite IHp0_1; ss. }
+    destruct o; ss.
+    - unfold phisize at 1. unfold PTree.fold. ss. clarify.
+      rewrite H0. rewrite H1. rewrite H0. rewrite H1. lia.
+    - unfold phisize at 1. unfold PTree.fold. ss. clarify.
+      rewrite H0. rewrite H1. rewrite H0. rewrite H1. lia.
+  Unshelve. auto. auto. auto. auto.  
+  Qed.
+
+  Lemma phisize_list: forall p,
+    phisize p = fold_left (fun acc elem => acc + Datatypes.length (snd elem))
+                          (PTree.elements p) 0.
+  Proof.
+    unfold phisize. i. rewrite PTree.fold_spec.
+    generalize (PTree.elements p); ss. induction l; ss.
+    destruct a; ss.
+    remember (fun a (p2: positive * phiblock) => Datatypes.length (snd p2) + a) as f.
+    remember (fun acc elem => acc + Datatypes.length (snd elem)) as f'.
+    enough (forall l n, fold_left f l n = fold_left f l 0 + n).
+    enough (forall l n, fold_left f' l n = fold_left f' l 0 + n).
+    rewrite H. rewrite (H0 l (Datatypes.length p1)). lia.
+    induction l0; ss. i. rewrite IHl0. rewrite (IHl0 (f' 0 a)).
+    destruct a; ss. clarify. ss. lia.
+    induction l0; ss. i. rewrite (IHl0 (f n a)). rewrite (IHl0 (f 0 a)).
+    destruct a; ss. clarify; ss. lia.
+  Qed.
+
+  Lemma phisize_elim_mv_phicode: forall d s p,
+    phisize (elim_mv_phicode d s p) =
+      fold_left (fun acc elem => acc + Datatypes.length elem)
+                (map (fun elem => map (subst_phi d s) (remove_mv_phiblock d (snd elem)))
+                     (PTree.elements p)) 0.
+  Proof.
+    unfold elim_mv_phicode. i. unfold phisize. rewrite PTree.fold_spec.
+    remember (fun a (p0: positive * phiblock) => Datatypes.length (snd p0) + a) as f.
+    remember (fun _ blk => map (subst_phi d s) (remove_mv_phiblock d blk)) as f'.
+    remember (fun acc elem => acc + Datatypes.length elem) as f''.
+    remember (fun elem => map (subst_phi d s) (remove_mv_phiblock d (snd elem))) as f'''.
+    unfold PTree.elements. generalize 1%positive at 1. generalize 1%positive.
+    unfold PTree.map. generalize 1%positive. generalize p.
+    induction p0. ss.
+    assert (forall l n, fold_left f l n = fold_left f l 0 + n).
+    { induction l; ss. i. rewrite IHl. rewrite (IHl (f 0 a)). destruct a; ss.
+      clarify; ss. lia. }
+    assert (forall l n, fold_left f'' l n = fold_left f'' l 0 + n).
+    { induction l; ss. i. rewrite IHl. rewrite (IHl (f'' 0 a)). destruct a; ss.
+      clarify; ss. lia. clarify; ss. lia. }
+    i. rewrite PTree.xelements_node. s. destruct o; ss.
+    - rewrite map_app. rewrite fold_left_app.
+      rewrite xelements_comm. rewrite fold_left_app. rewrite H. rewrite H0. ss.
+      rewrite H. rewrite H0. rewrite (IHp0_2 _ p1~1%positive).
+      rewrite (IHp0_1 _ p1~0%positive). clarify; ss. lia.
+    - rewrite map_app. rewrite fold_left_app.
+      rewrite xelements_comm. rewrite fold_left_app. rewrite H. rewrite H0. ss.
+      rewrite (IHp0_2 _ p1~1%positive).
+      rewrite (IHp0_1 _ p1~0%positive). clarify; ss.
+  Qed.
+  
+  Lemma phisize_dec: forall c p p' f,
+    c = fn_code f ->
+    p = fn_phicode f ->
+    p' = fn_phicode (transf_function_fuel 1 f) ->
+    match (find_mv_code c) with
+    | Some (d, s) => phisize p' <= phisize p
+    | None => match (find_mv_phicode p) with
+              | Some (d, s) => phisize p' < phisize p
+              | None => phisize p = phisize p'
+              end
+    end.
+  Proof.
+    remember (fun acc (elem: list phiinstruction)
+              => acc + Datatypes.length elem) as f'.
+    remember (fun acc (elem: positive * list phiinstruction)
+              => acc + Datatypes.length (snd elem)) as f''.
+    assert (forall l n, fold_left f' l n = fold_left f' l 0 + n).
+    { induction l; ss. i. clarify. rewrite IHl. rewrite (IHl (0 + _)). lia. }
+    assert (forall l n, fold_left f'' l n = fold_left f'' l 0 + n).
+    { induction l; ss. i. clarify. rewrite IHl. rewrite (IHl (0 + _)). lia. }
+    i. unfold transf_function_fuel in H3. ss. clarify. flatten.
+    - ss. rewrite phisize_elim_mv_phicode. rewrite phisize_list.
+      generalize (PTree.elements (fn_phicode f)).
+      induction l; ss. clarify.
+      rewrite H. rewrite H0. destruct a; ss. clarify. ss.
+      assert (forall pb,
+              Datatypes.length (map (subst_phi r r0) (remove_mv_phiblock r pb))
+              <= Datatypes.length pb).
+      { induction pb; ss. destruct a; ss. flatten; ss; try lia. }
+      specialize (H1 p0). lia.
+    - ss. rewrite phisize_elim_mv_phicode. rewrite phisize_list.
+      unfold find_mv_phicode in Eq0. rewrite PTree.fold_spec in Eq0.
+      remember (PTree.elements (fn_phicode f)). clear Heql. revert Eq0.
+      induction l; ss. i. destruct a; ss.
+      destruct (find_mv_phiblock p1) eqn:FINDP1.
+      + destruct p2; ss.
+        remember (fun acc elem => acc + Datatypes.length elem) as f'.
+        remember (fun acc elem => acc + Datatypes.length (snd elem)) as f''.
+        remember (fun elem => map (subst_phi _ _) (remove_mv_phiblock _ _)) as fr.
+        assert (forall l, fold_left f' (map fr l) 0 <= fold_left f'' l 0).
+        { induction l0; ss. destruct a; ss. rewrite H. rewrite H0.
+          enough (f' 0 (fr (p2, p3)) <= f'' 0 (p2, p3)). lia.
+          clarify; ss. generalize p3. induction p4; ss. flatten; ss. lia. lia. }
+        rewrite H. rewrite H0.
+        enough (Datatypes.length (map (subst_phi r r0) (remove_mv_phiblock r p1))
+                < Datatypes.length p1). specialize (H1 l); lia.
+        remember (fun a p => _find_mv_phiblock a _ _) as ffind.
+        assert (forall l, fold_left ffind l (Some (r1, r2)) = Some (r, r0) ->
+                (r1, r2) = (r, r0)).
+        { induction l0; ss. i. clarify; ss. destruct a; ss. clarify. }
+        apply H2 in Eq0; ss. clear H2. clarify.
+        revert FINDP1. generalize p1. induction p2; ss. destruct a; ss.
+        destruct l0; ss.
+        * flatten. i. apply IHp2 in FINDP1. lia. ss. i.
+          apply IHp2 in FINDP1. lia.
+        * flatten. i. clarify. generalize p2. induction p3; ss. flatten; ss. lia.
+          lia. i. clarify. rewrite Pos.eqb_neq in Eq1. exfalso; apply Eq1; ss.
+          i. apply IHp2 in FINDP1; ss. lia.
+          i. ss. apply IHp2 in FINDP1. lia.
+      + apply IHl in Eq0. rewrite H. rewrite (H0 l).
+        enough (Datatypes.length (map (subst_phi r r0) (remove_mv_phiblock r p1))
+                <= Datatypes.length p1). lia.
+        generalize p1. induction p2; ss. flatten; ss. lia. lia.
+    - ss.
+  Qed.
+
+  Lemma phisize_dec': forall c p p' f n m d s d' s',
+    c = fn_code f ->
+    p = fn_phicode f ->
+    phisize p = n + m ->
+    find_mv_code (fn_code f) = None ->
+    find_mv_phicode (fn_phicode f) = Some (d, s) ->
+    p' = fn_phicode (transf_function_fuel m f) ->
+    find_mv_phicode p' = Some (d', s') ->
+    phisize p' <= n.
+  Proof.
+    intros c p p' f n m; revert c p p' f n; induction m; ss.
+    - i. clarify. lia.
+    - i. rewrite transf_function_fuel_repeatn in H4. ss.
+      rewrite <- transf_function_fuel_repeatn in H4.
+      pose proof phisize_dec as DEC. eapply DEC in H4 as DEC'; eauto.
+      rewrite find_transf_function_fuel_repeatn in DEC'; eauto. flatten DEC'.
+      + assert (phisize (fn_phicode (transf_function_fuel m f)) <= S n).
+        { replace (n + S m) with (S n + m) in H1 by lia. eapply IHm in H1; eauto. }
+        lia.
+      + unfold transf_function_fuel at 1 in H4. unfold simplify_mv in H4.
+        rewrite find_transf_function_fuel_repeatn in H4; ss. rewrite Eq in H4.
+        ss. clarify.
+  Qed.
+
+  Lemma strong_ind: forall (P: nat -> Prop),
+                    (forall m, (forall k, k < m -> P k) -> P m) -> 
+                    forall n, P n.
+  Proof.
+    i. enough (H0: forall p, p <= n -> P p). apply H0. lia.
+    induction n; ss. i. inv H0. apply H; try lia. i. inv H0.
+    apply H. i. apply IHn; lia. apply IHn; lia.
+  Qed.
+
+  Lemma transf_function_fuel_phicode_idempotent: forall f m,
+    find_mv_code (fn_code f) = None ->
+    phisize (fn_phicode f) <= m ->
+    find_mv_phicode (fn_phicode (transf_function_fuel m f)) = None.
+  Proof.
+    intros f. remember (phisize (fn_phicode f)).
+    assert (phisize (fn_phicode f) <= n) by lia. clear Heqn.
+    revert f H. induction n; ss.
+    - i. inv H. apply phisize_0 in H3.
+      rewrite find_mv_phicode_repeatn; ss.
+    - i. destruct (find_mv_phicode (fn_phicode f)) eqn:FINDPF.
+      + destruct p; ss. destruct m; try lia. assert (n <= m) by lia.
+        rewrite transf_function_fuel_repeatn. ss.
+        rewrite <- transf_function_fuel_repeatn. rewrite transf_function_fuel_commute.
+        unfold transf_function_fuel at 2. ss. rewrite H0, FINDPF.
+        remember (mkfunction _ _ _ _ _ _ _ _) as f'. eapply IHn; eauto.
+        enough (phisize (fn_phicode f') < phisize (fn_phicode f)). lia.
+        pose proof (phisize_dec).
+        specialize (H3 (fn_code f) (fn_phicode f) (fn_phicode f') f).
+        rewrite H0, FINDPF in H3. apply H3; auto. unfold transf_function_fuel.
+        ss. rewrite H0, FINDPF. clarify. clarify. apply find_elim_mv_code. auto.
+      + rewrite find_mv_phicode_repeatn; auto.
+  Qed.
+
+  Lemma transf_function_commute: forall f fuel,
+    code_size f <= fuel ->
+    transf_function f = repeatn (transf_function_fuel 1) fuel f.
+  Proof.
+    i. revert f H. induction fuel.
+    - i. ss. unfold transf_function. inv H. rewrite H1.
+      unfold transf_function_fuel. ss. destruct f; ss.
+    - i. inv H.
+      + unfold transf_function.
+        apply transf_function_fuel_repeatn.
+      + ss. rewrite <- IHfuel; auto.
+        assert (forall f, find_mv_code (fn_code (transf_function f)) = None).
+        { unfold transf_function. i. eapply transf_function_fuel_code_idempotent.
+          unfold code_size. repeat rewrite PTree.fold_spec.
+          assert (forall (l: list (positive * list phiinstruction)) n,
+                  n <= fold_left (fun a p => Datatypes.length (snd p) + a) l n).
+          { induction l; ss. destruct a. ss. i.
+            specialize (IHl (Datatypes.length l0 + n)). lia. }
+          apply H. }
+        assert (forall f, find_mv_phicode (fn_phicode (transf_function f)) = None).
+        { i. unfold transf_function. unfold code_size.
+          assert (COMM: forall p n,
+                        let f := (fun m (p: positive) (blk: list phiinstruction) =>
+                                    Datatypes.length blk + m) in
+                        (PTree.fold f p n) = (PTree.fold f p 0) + n).
+          { ss. i. rewrite 2 PTree.fold_spec. unfold PTree.elements.
+            generalize 1%positive. revert n. induction p; ss.
+            destruct o; ss.
+            - i. rewrite xelements_comm. rewrite 2 fold_left_app.
+              rewrite IHp1; auto. ss. rewrite IHp2; auto.
+              erewrite (IHp2 p2 _ _ (Datatypes.length l + _)). lia.
+            - i. rewrite xelements_comm. rewrite 2 fold_left_app.
+              erewrite IHp2; auto. erewrite (IHp2 p2 _ _ (fold_left _ _ 0)).
+              rewrite (IHp1 p1); auto. lia. }
+          rewrite COMM. remember (PTree.fold _ _ 1).
+          remember (PTree.fold (fun m (p: positive) (blk: list phiinstruction) =>
+                                Datatypes.length blk + m) (fn_phicode f0) 0) as m.
+          rewrite transf_function_fuel_repeatn. rewrite repeatn_distributive.
+          rewrite <- 2 transf_function_fuel_repeatn.
+          apply transf_function_fuel_phicode_idempotent.
+          apply transf_function_fuel_code_idempotent. rewrite Heqn. lia.
+          rewrite Heqm. replace (PTree.fold _ _ 0) with (phisize (fn_phicode f0)).
+          assert (forall f n,
+                  (phisize (fn_phicode (transf_function_fuel n f))) <= 
+                  phisize (fn_phicode f)).
+          { intros f1 n0; revert f1; induction n0; ss.
+            i. rewrite transf_function_fuel_repeatn. ss.
+            rewrite <- transf_function_fuel_repeatn. pose proof phisize_dec as DEC.
+            remember (transf_function_fuel n0 f1) as NF.
+            assert (phisize (fn_phicode (transf_function_fuel 1 NF)) <=
+                    phisize (fn_phicode NF)).
+            specialize (DEC (fn_code NF)
+                            (fn_phicode NF)
+                            (fn_phicode (transf_function_fuel 1 NF)) NF). flatten DEC.
+            eapply DEC; eauto. exploit DEC; eauto. i; lia. exploit DEC; eauto.
+            i; lia. clarify. specialize (IHn0 f1); lia. }
+          eapply H0; eauto.
+          unfold phisize; ss. }
+        unfold transf_function_fuel. unfold simplify_mv. rewrite H. rewrite H0.
+        destruct (transf_function f); ss.
+    Unshelve. auto. auto. auto. auto.
+  Qed.
+
+  Let ge := Genv.globalenv prog.
+  Let tge := Genv.globalenv tprog.
+
+  (* Let ev_rel2 := ev_rel_eq. *)
+
+  Lemma match_prog_step_wf_ssa : wf_ssa_program tprog.
+  Proof. 
+    red. intros.
+    red in HWF.
+    inv TRANSL.
+    intuition. revert H0 H HWF.
+    induction 1; intros.
+    - inv H.
+    - inv H1.      
+      + inv H. inv H4.
+        destruct f1 ; simpl in * ; try constructor; auto.
+        exploit (HWF (Internal f) id); eauto.
+        destruct a1, g; simpl in * ; try congruence. 
+        left. inv H; simpl in *; auto. 
+        intros. inv H4; auto.
+        unfold transf_function_step. unfold transf_function_fuel. ss.
+        flatten. flatten Eq.
+        * eapply elim_mv_preserve_wf_ssa_function; eauto.
+        * eapply elim_mv_preserve_wf_ssa_function; eauto.
+        * destruct f; eauto.
+      + eapply IHlist_forall2; eauto.
+  Qed.
+
+  Lemma symbols_preserved:
+    forall (s: ident), Genv.find_symbol tge s = Genv.find_symbol ge s.
+  Proof.
+    eapply (Genv.find_symbol_transf TRANSL).
+  Qed. 
+
+  Lemma funct_ptr_translated:
+    forall (b: Values.block) (f: fundef),
+      Genv.find_funct_ptr ge b = Some f ->
+      Genv.find_funct_ptr tge b = Some (transf_fundef_step f).
+  Proof.
+    apply (Genv.find_funct_ptr_transf TRANSL).
+  Qed. 
+
+  Lemma functions_translated:
+    forall (v: val) (f: fundef),
+      Genv.find_funct ge v = Some f ->
+      Genv.find_funct tge v = Some (transf_fundef_step f).
+  Proof.
+    apply (Genv.find_funct_transf TRANSL).
+  Qed. 
+
+  Lemma sig_preserved:
+    forall f, funsig (transf_fundef_step f) = funsig f.
+  Proof.
+    destruct f; simpl; auto. unfold transf_function_step; ss.
+    destruct f. unfold transf_function_fuel. ss. flatten; ss.
+  Qed.
+
+  Lemma find_function_translated:
+    forall m ros rs f,
+      find_function ge (ros_to_vos m ros rs) rs = Some f ->
+      find_function tge (ros_to_vos m ros rs) rs = Some (transf_fundef_step f).
+  Proof.
+    intros until f; destruct ros; simpl. des_ifs.
+    { apply functions_translated; auto. }
+    { apply functions_translated; auto. }
+    rewrite symbols_preserved. destruct (Genv.find_symbol ge i); intro.
+    { apply funct_ptr_translated; auto. }
+    discriminate.
+  Qed.
+
+  Lemma fn_params_translated : forall (f:function), 
+    fn_params f = fn_params (transf_function_step f).
+  Proof.
+    intros ; unfold transf_function_step, transf_function_fuel ; simpl; auto.
+    flatten. ss.
+  Qed.
+
+  Lemma fn_entrypoint_translated : forall (f:function),
+    fn_entrypoint f = fn_entrypoint (transf_function_step f).
+  Proof.
+    intros ; unfold transf_function_step, transf_function_fuel ; simpl; auto.
+    flatten; ss.
+  Qed.
+
+  Lemma senv_equiv : Senv.equiv ge tge.
+  Proof.
+    apply (Genv.senv_transf TRANSL).
+  Qed.
+
+  Lemma join_point_transf_function_step: forall j f,
+    join_point j f <-> join_point j (transf_function_step f).
+  Proof.
+    i. unfold transf_function_step. unfold transf_function_fuel. ss.
+    flatten. flatten Eq; ss.
+    - split; ss. rewrite join_point_elim_mv; ss; eauto.
+      rewrite <- join_point_elim_mv; ss; eauto. 
+    - split; ss. rewrite join_point_elim_mv; ss; eauto.
+      rewrite <- join_point_elim_mv; ss; eauto.
+    - destruct f; ss.
+  Qed.
+
+  Lemma make_predecessors_transf_function_step: forall f,
+    Kildall.make_predecessors (fn_code f) successors_instr =
+      Kildall.make_predecessors (fn_code (transf_function_step f)) successors_instr.
+  Proof.
+    i. unfold transf_function_step, transf_function_fuel. ss.
+    flatten. flatten Eq; ss.
+    erewrite <- make_predecessors_elim_mv; ss. ss.
+    erewrite <- make_predecessors_elim_mv; ss. ss.
+  Qed.
+
+  Definition equiv_regset_except_d (rs rs': regset) (d: reg) :=
+    forall r, r <> d -> rs # r = rs' # r.
+
+  Variant match_functions:
+    function -> regset -> function -> regset -> node -> Prop :=
+  | match_id (f: function) (rs: regset) (pc: node)
+             (NOTFOUND: find_mv_code (fn_code f) = None)
+             (NOTFOUND': find_mv_phicode (fn_phicode f) = None) :
+      match_functions f rs f rs pc
+  | match_code (f: function) (rs rs': regset) (d s: reg) (pc: node)
+               (FOUND: find_mv_code (fn_code f) = Some (d, s))
+               (EQUIV: equiv_regset_except_d rs rs' d) :
+      match_functions f rs (transf_function_step f) rs' pc
+  | match_phicode (f: function) (rs rs': regset) (d s: reg) (pc: node)
+                  (NOTFOUND: find_mv_code (fn_code f) = None)
+                  (FOUND: find_mv_phicode (fn_phicode f) = Some (d, s))
+                  (EQUIV: equiv_regset_except_d rs rs' d)
+                  (PHIINV: forall pc' phib args,
+                           (fn_phicode f) ! pc' = Some phib ->
+                           In (Iphi args d) phib ->
+                           (forall r, In r args -> r = s) ->
+                           dom f pc' pc ->
+                           d <> s ->
+                           rs # d = rs # s) :
+      match_functions f rs (transf_function_step f) rs' pc.
+
+  Inductive match_stackframes : list stackframe -> list stackframe -> Prop :=
+  | match_stackframes_nil: match_stackframes nil nil
+  | match_stackframes_cons: 
+    forall res (f:function) sp pc rs rs' st st' pred sig fn args
+      (STACK: (match_stackframes st st'))
+      (WFF: wf_ssa_function f)
+      (MATCH: match_functions f rs (transf_function_step f) rs' pc)
+      (PREDINFO: (fn_code f) ! pred = Some (Icall sig fn args res pc)),
+      match_stackframes
+      ((Stackframe res f sp pc rs) :: st)
+      ((Stackframe res (transf_function_step f) sp pc rs') :: st').
+      
+  Variant match_states: state -> state -> Prop :=
+  | match_states_intro:
+      forall st st' sp pc rs rs' m f
+        (SINV:s_inv ge (State st f sp pc rs m))
+        (STACK: match_stackframes st st')
+        (MATCH: match_functions f rs (transf_function_step f) rs' pc),
+        match_states (State st f sp pc rs m)
+                     (State st' (transf_function_step f) sp pc rs' m)
+  | match_states_call:
+      forall s st f args m
+        (SINV:s_inv ge (Callstate s f args m))
+        (STACK: match_stackframes s st),
+        match_states (Callstate s f args m)
+                     (Callstate st (transf_fundef_step f) args m)
+  | match_states_return:
+    forall s st v m 
+        (SINV:s_inv ge (Returnstate s v m))
+        (STACK: match_stackframes s st),
+        match_states (Returnstate s v m) (Returnstate st v m).
+
+  Lemma transf_initial_states:
+    forall st1, initial_state prog st1 ->
+                exists st2, initial_state tprog st2 /\ match_states st1 st2.
+  Proof.
+    intros. inversion H.
+    exploit @funct_ptr_translated ; eauto. intros. 
+    econstructor; split.
+    - econstructor.
+      assert (MEM: (Genv.init_mem tprog) = Some m0)
+        by (eapply (Genv.init_mem_transf TRANSL); eauto).
+      + apply MEM ; auto.
+      + replace (prog_main tprog) with (prog_main prog).
+        rewrite symbols_preserved; eauto.
+        symmetry; eapply match_program_main; eauto.
+      + eauto.
+      + rewrite <- H3. apply sig_preserved; auto.
+    - eapply match_states_call; eauto.
+      + constructor.
+        eapply Genv.find_funct_ptr_prop; eauto.
+        constructor.
+      + constructor.
+  Qed.
+
+  Lemma transf_final_states:
+    forall st1 st2 r,
+      match_states st1 st2 -> final_state st1 r -> final_state st2 r.
+  Proof.
+    intros. inv H0. inv H. 
+    inv STACK.
+    constructor.
+  Qed.
+
+  Lemma transf_function_step_phicode_phicode: forall f pc phib,
+    (fn_phicode f) ! pc = Some phib ->
+    exists phib', (fn_phicode (transf_function_step f)) ! pc = Some phib' /\
+                  phib' = match (find_mv_code (fn_code f)) with
+                          | Some (d, s) =>
+                              map (subst_phi d s) (remove_mv_phiblock d phib)
+                          | None =>
+                              match (find_mv_phicode (fn_phicode f)) with
+                              | Some (d, s) =>
+                                  map (subst_phi d s) (remove_mv_phiblock d phib)
+                              | None => phib
+                              end
+                          end.
+  Proof.
+    i. unfold transf_function_step, transf_function_fuel; ss.
+    flatten; ss.
+    - unfold elim_mv_phicode. rewrite PTree.gmap. rewrite H. ss.
+      eexists; eauto.
+    - unfold elim_mv_phicode. rewrite PTree.gmap. rewrite H. ss.
+      eexists; eauto.
+    - eauto.
+  Qed.
+
+  Lemma transf_function_step_spec : forall f pc ins,
+    (fn_code f) ! pc = Some ins ->
+    let c' := fn_code (transf_function_step f) in
+    c' ! pc = Some ins \/
+    match ins with
+    | Inop pc' => c' ! pc = Some (Inop pc')
+    | Iop Omove _ dst pc' =>
+      c' ! pc = Some (Inop pc') \/
+      exists args', c' ! pc = Some (Iop Omove args' dst pc')
+    | Iop op _ dst pc' =>
+      exists args', c' ! pc = Some (Iop op args' dst pc')
+    | Iload chunk addr args dst pc' =>
+      exists args', c' ! pc = Some (Iload chunk addr args' dst pc')
+    | Istore chunk addr args src pc' =>
+      exists args' src', c' ! pc = Some (Istore chunk addr args' src' pc')
+    | Icall sig ros args res pc' =>
+      exists ros' args', c' ! pc = Some (Icall sig ros' args' res pc')
+    | Itailcall sig ros args =>
+      exists ros' args', c' ! pc = Some (Itailcall sig ros' args')
+    | Ibuiltin ef args res pc' =>
+      exists args', c' ! pc = Some (Ibuiltin ef args' res pc')
+    | Icond cond args ifso ifnot =>
+      exists args', c' ! pc = Some (Icond cond args' ifso ifnot)
+    | Ijumptable arg tbl =>
+      exists arg', c' ! pc = Some (Ijumptable arg' tbl)
+    | Ireturn optarg => exists optarg', c' ! pc = Some (Ireturn optarg')
+    end.
+  Proof.
+    i. unfold transf_function_step, transf_function_fuel in c'. ss.
+    destruct (find_mv_code (fn_code f)) eqn:FINDC.
+    - destruct p; ss. subst c'. eapply elim_mv_code_spec in H; eauto. des.
+      + left; eauto.
+      + right. destruct ins; ss. destruct o; ss. des. left; eauto. right; eauto.
+    - destruct (find_mv_phicode (fn_phicode f)) eqn:FINDPC.
+      + destruct p; ss. subst c'. eapply elim_mv_code_spec in H; eauto. des.
+        * left; eauto.
+        * right. destruct ins; ss. destruct o; ss. des. left; eauto. right; eauto.
+      + ss. subst c'; left; ss.
+  Qed.
+
+  Lemma transf_function_step_spec_simple : forall f pc ins d s,
+    (fn_code f) ! pc = Some ins ->
+    (find_mv_code (fn_code f) = None ->
+      find_mv_phicode (fn_phicode f) = None ->
+      (fn_code (transf_function_step f)) ! pc = Some ins) /\
+    (find_mv_code (fn_code f) = Some (d, s) \/
+      find_mv_code (fn_code f) = None /\
+      find_mv_phicode (fn_phicode f) = Some (d, s) ->
+      (fn_code (transf_function_step f)) ! pc = 
+    Some (subst_instr d s (remove_mv_instr d ins))).
+  Proof.
+    unfold transf_function_step, transf_function_fuel; ss. split.
+    - i. rewrite H0, H1. ss.
+    - i. des.
+      + rewrite H0. ss. unfold elim_mv_code. rewrite PTree.gmap. rewrite H; ss.
+      + rewrite H0, H1; ss. unfold elim_mv_code. rewrite PTree.gmap. rewrite H; ss.
+  Qed.
+
+  Lemma phi_store_spec_for_moves : forall f pc pc' phib k rs args d s,
+    wf_ssa_function f ->
+    (fn_phicode f) ! pc = Some phib ->
+    In (Iphi args d) phib ->
+    (forall r, In r args -> r = s) ->
+    index_pred (Kildall.make_predecessors (fn_code f) successors_instr) pc' pc
+      = Some k ->
+    d <> s ->
+    (phi_store k phib rs) # d = rs # s.
+  Proof.
+    i. eapply (fn_ssa f H) in H0 as PHI. revert PHI.
+    assert (forall args r, In (Iphi args r) phib
+            -> exists a, nth_error args k = Some a).
+    { i. eapply nth_error_some_same_length.
+      eapply index_pred_some_nth; eauto. eapply (fn_wf_block f H); eauto. }
+    revert H5. revert H1 H2. generalize phib. induction phib0.
+    - i. inv H1.
+    - i. destruct a eqn:EA; ss. des.
+      + clarify. exploit H5. left; eauto. i. des. rewrite H1.
+        apply nth_error_in in H1. apply H2 in H1; clarify.
+        rewrite PMap.gss. eauto.
+      + clarify. exploit H5. left; eauto. i; des. rewrite H6.
+        rewrite PMap.gso. eapply IHphib0; eauto. split.
+        inv PHI; eauto.
+        i. eapply PHI0; eauto.
+        ii. clarify. inv PHI.
+        enough (l = args). clarify; intuition.
+        eapply PHI0; eauto.
+  Qed.
+  
+  Lemma phi_store_spec_for_irrelevant : forall f pc phib r rs k,
+    wf_ssa_function f ->
+    (fn_phicode f) ! pc = Some phib ->
+    ~ def f r pc ->
+    (phi_store k phib rs) # r = rs # r.
+  Proof.
+    i. assert (forall args, ~ In (Iphi args r) phib).
+    { ii. eapply H1; eauto. }
+    revert H2. generalize phib as phib'. induction phib'; ss.
+    flatten.
+    i. rewrite PMap.gso; eauto. ii; clarify; ss. eapply H2; eauto.
+    i. eauto.
+  Qed.
+
+  Lemma phi_store_eq_ds: forall f pc phib k rs rs' r d s,
+    wf_ssa_function f ->
+    (fn_phicode f) ! pc = Some phib ->
+    (forall r, r <> d -> rs # r = rs' # r) ->
+    r <> d ->
+    d <> s ->
+    rs # d = rs # s ->
+    (phi_store k phib rs) # r 
+    = (phi_store k (map (subst_phi d s) (remove_mv_phiblock d phib)) rs') # r.
+  Proof.
+    i. eapply (fn_ssa f H) in H0. induction phib; ss.
+    - eauto.
+    - destruct a as [args1 dst1].
+      flatten.
+      + rewrite Pos.eqb_eq in Eq0; clarify.
+        rewrite PMap.gso; eauto. eapply IHphib; eauto. des. inv H0. split; eauto.
+      + ss. assert (nth_error (map (rename_reg d s) args1) k
+                    = Some (rename_reg d s r0)).
+        { revert Eq. revert k. generalize args1 as l. induction l; ss.
+          - i. destruct k; ss.
+          - i. destruct k; ss.
+            + inv Eq. ss.
+            + eauto. }
+        rewrite H5. destruct (peq dst1 r).
+        * clarify. repeat rewrite PMap.gss; eauto.
+          destruct (peq r0 s).
+          clarify. unfold rename_reg. flatten; ss.
+          rewrite Pos.eqb_eq in Eq1; clarify. eapply H1; eauto.
+          destruct (peq r0 d).
+          clarify. rewrite H4. unfold rename_reg. flatten; ss. eapply H1; eauto.
+          rewrite Pos.eqb_neq in Eq1; clarify.
+          unfold rename_reg; flatten; ss. rewrite Pos.eqb_eq in Eq1; clarify.
+          eapply H1; eauto.
+        * repeat rewrite PMap.gso; eauto.
+          eapply IHphib; eauto. des. inv H0. split; eauto.
+      + rewrite Pos.eqb_eq in Eq0; clarify. eapply IHphib; eauto.
+        des. inv H0; eauto.
+      + rewrite Pos.eqb_neq in Eq0. ss.
+        assert (nth_error (map (rename_reg d s) args1) k = None).
+        { revert k Eq. generalize args1 as l. induction l; ss.
+          destruct k; ss. destruct l; ss. eauto. }
+        rewrite H5. eapply IHphib; eauto. des. inv H0. eauto.
+  Qed.
+
+  Lemma phi_store_irrelevant : forall f pc pc' phib k rs rs' r d s,
+    wf_ssa_function f ->
+    (fn_phicode f) ! pc' = Some phib ->
+    (fn_code f) ! pc = Some (Inop pc') ->
+    index_pred (Kildall.make_predecessors (fn_code f) successors_instr) pc pc'
+      = Some k ->
+    (forall r, r <> d -> rs # r = rs' # r) ->
+    d <> s ->
+    r <> d ->
+    ~ use_phicode f d pc ->
+    (phi_store k phib rs) # r =
+      (phi_store k (map (subst_phi d s) (remove_mv_phiblock d phib)) rs') # r.
+  Proof.
+    i. eapply (fn_ssa f) in H0 as PHIINV; eauto. des.
+    pose proof fn_phiargs.
+    assert (forall args x,
+              In (Iphi args x) phib -> exists arg, nth_error args k = Some arg).
+    { i. exploit fn_phiargs; eauto. }
+    assert (forall args r, ~ (In (Iphi args r) phib /\ nth_error args k = Some d)).
+    { ii. des. eapply H6; eauto. econstructor; eauto. }
+    clear H7 H0 H6.
+    induction phib; ss.
+    - eauto.
+    - destruct a as [args dst].
+      exploit H8; eauto. i; des. rewrite H0.
+      flatten.
+      + rewrite Pos.eqb_eq in Eq; clarify.
+        rewrite PMap.gso; eauto. eapply IHphib; eauto. inv PHIINV; eauto.
+        ii. des. eapply H9; eauto.
+      + ss. assert (nth_error (map (rename_reg d s) args) k
+                    = Some (rename_reg d s arg)).
+        { revert H0; generalize k; generalize args as l. induction l; ss.
+          - destruct k0; ss.
+          - i. destruct k0; ss. inv H0; ss. eauto. }
+        rewrite H6. destruct (peq r dst).
+        { clarify. repeat rewrite PMap.gss. unfold rename_reg.
+          flatten. rewrite Pos.eqb_eq in Eq0; clarify. exfalso; eapply H9; eauto.
+          eapply H3; eauto. ii; clarify. rewrite Pos.eqb_neq in Eq0; clarify. }
+        { repeat rewrite PMap.gso; eauto. eapply IHphib; eauto.
+          inv PHIINV; eauto. ii; des. eapply H9; eauto. }
+  Qed.
+
+  Lemma code_preserved_irrelevant: forall f pc d s ins,
+    wf_ssa_function f ->
+    ~ use_code f d pc ->
+    ~ assigned_code_spec (fn_code f) pc d ->
+    (fn_code f) ! pc = Some ins ->
+    ins = subst_instr d s (remove_mv_instr d ins).
+  Proof.
+    i. assert ((remove_mv_instr d ins) = ins).
+    { destruct ins; ss. destruct o; ss. flatten; ss.
+      rewrite Pos.eqb_eq in Eq; clarify; exfalso; eapply H1; eauto. }
+    rewrite H3.
+    assert (forall l, ~ In d l -> map (rename_reg d s) l = l).
+    { induction l; ss. i. rewrite IHl; eauto. unfold rename_reg.
+      flatten; ss. rewrite Pos.eqb_eq in Eq; clarify; ss. exfalso; eauto. }
+    destruct ins; ss; try (rewrite H4; ss; ii; eapply H0; eauto using use_code).
+    rewrite H4. unfold rename_reg; flatten. rewrite Pos.eqb_eq in Eq; clarify.
+    exfalso; eapply H0; eauto using use_code.
+    ii; eapply H0; eauto using use_code.
+    unfold rename_fn. flatten.
+    unfold rename_reg at 1. flatten; ss.
+    rewrite Pos.eqb_eq in Eq0; clarify.
+    exfalso; eapply H0; eauto using use_code.
+    rewrite H4; eauto. ii; eapply H0; eauto using use_code.
+    rewrite H4; eauto. ii; eapply H0; eauto using use_code.
+    unfold rename_fn. flatten; ss.
+    unfold rename_reg at 1. flatten; ss. rewrite Pos.eqb_eq in Eq0; clarify.
+    exfalso; eapply H0; eauto using use_code.
+    rewrite H4; eauto. ii; eapply H0; eauto using use_code.
+    rewrite H4; eauto. ii; eapply H0; eauto using use_code.
+    assert (forall l, ~ In d (params_of_builtin_args l)
+                      -> map (rename_barg d s) l = l).
+    { induction l0; ss. i. rewrite IHl0; ss.
+      assert (forall a, ~ In d (params_of_builtin_arg a) -> rename_barg d s a = a).
+      { induction a0; ss. unfold rename_reg. flatten; ss.
+        rewrite Pos.eqb_eq in Eq; clarify. i; exfalso; eauto.
+        i. rewrite IHa0_1, IHa0_2; ss; ii; eapply H6; rewrite in_app_iff; eauto.
+        i. rewrite IHa0_1, IHa0_2; ss; ii; eapply H6; rewrite in_app_iff; eauto. }
+      rewrite H6; eauto. ii. eapply H5; rewrite in_app_iff; eauto.
+      ii; eapply H5; rewrite in_app_iff; eauto. }
+    rewrite H5; ss. ii; eapply H0; eauto using use_code.
+    unfold rename_reg; flatten; ss. rewrite Pos.eqb_eq in Eq; clarify.
+    exfalso; eapply H0; eauto using use_code.
+    destruct o; ss. unfold rename_reg; flatten; ss; rewrite Pos.eqb_eq in *; clarify.
+    exfalso; eapply H0; eauto using use_code.
+  Qed.
+
+  Lemma value_list_preserved_for_equiv_regsets: forall args rs rs' d,
+    equiv_regset_except_d rs rs' d ->
+    ~ In d args ->
+    rs ## args = rs' ## args.
+  Proof.
+    induction args; ss.
+    i. erewrite IHargs; eauto. enough (rs # a = rs' # a); eauto.
+    rewrite H1; eauto.
+  Qed.
+
+  Lemma value_list_preserved_for_ds_eq: forall args (rs rs': regset) d s,
+    equiv_regset_except_d rs rs' d ->
+    rs # d = rs # s ->
+    d <> s ->
+    rs' ## (map (rename_reg d s) args) = rs ## args.
+  Proof.
+    induction args; ss. i.
+    erewrite IHargs; eauto. destruct (peq a d).
+    - clarify. unfold rename_reg. flatten; ss.
+      enough (rs' # s = rs # d). rewrite H2; eauto.
+      erewrite <- H; eauto. rewrite Pos.eqb_neq in Eq; clarify.
+    - unfold rename_reg; flatten; ss. rewrite Pos.eqb_eq in Eq; clarify.
+      rewrite H; eauto.
+  Qed.
+
+  Lemma eval_builtin_args_preserved_for_equiv_regset:
+    forall args rs rs' d s vargs m sp,
+    equiv_regset_except_d rs rs' d ->
+    ~ In d (params_of_builtin_args args) ->
+    d <> s ->
+    eval_builtin_args ge (fun r => rs # r) sp m args vargs <->
+    eval_builtin_args tge (fun r => rs' # r) sp m (map (rename_barg d s) args) vargs.
+  Proof.
+    assert (RNBAPRES: forall arg d s, ~ In d (params_of_builtin_arg arg) ->
+                                      rename_barg d s arg = arg).
+    { induction arg; ss.
+      - i. destruct (peq x d).
+        + clarify; exfalso; eauto.
+        + unfold rename_reg; flatten; ss. rewrite Pos.eqb_eq in Eq; clarify.
+      - i. rewrite IHarg1, IHarg2; ss.
+        ii. exploit H. rewrite in_app_iff. right; eauto. ss.
+        ii. exploit H. rewrite in_app_iff. left; eauto. ss.
+      - i. rewrite IHarg1, IHarg2; ss.
+        ii. exploit H. rewrite in_app_iff. right; eauto. ss.
+        ii. exploit H. rewrite in_app_iff. left; eauto. ss. }
+    assert (EQUIVBARG: forall arg d sp m barg rs rs',
+                              equiv_regset_except_d rs rs' d ->
+                              ~ In d (params_of_builtin_arg arg) ->
+                              eval_builtin_arg ge (fun r => rs # r) sp m arg barg <->
+                              eval_builtin_arg ge (fun r => rs' # r) sp m arg barg).
+    { induction arg; ss; split; ii; try (inv H1; econstructor; eauto).
+      - destruct (peq d x); clarify. exfalso; eauto.
+        inv H1. rewrite H; eauto. econstructor; eauto.
+      - destruct (peq d x); clarify. exfalso; eauto.
+        inv H1. rewrite <- H; eauto. econstructor; eauto.
+      - eapply IHarg1 in H4; eauto. ii; exploit H; eauto.
+        ii; eapply H0; rewrite in_app_iff; left; eauto.
+      - eapply IHarg2 in H6; eauto. ii; exploit H; eauto.
+        ii; eapply H0; rewrite in_app_iff; right; eauto.
+      - eapply IHarg1 in H4; eauto. ii; eapply H0; rewrite in_app_iff; left; eauto.
+      - eapply IHarg2 in H6; eauto. ii; eapply H0; rewrite in_app_iff; right; eauto.
+      - eapply IHarg1 in H4; eauto. ii; exploit H; eauto.
+        ii; eapply H0; rewrite in_app_iff; left; eauto.
+      - eapply IHarg2 in H6; eauto. ii; exploit H; eauto.
+        ii; eapply H0; rewrite in_app_iff; right; eauto.
+      - eapply IHarg1 in H4; eauto. ii; eapply H0; rewrite in_app_iff; left; eauto.
+      - eapply IHarg2 in H6; eauto. ii; eapply H0; rewrite in_app_iff; right; eauto. }
+    induction args; ss.
+    - split; i; inv H2; econstructor; eauto.
+    - split.
+      + i. inv H2. econstructor; eauto.
+        * eapply eval_builtin_arg_preserved. eapply symbols_preserved.
+          rewrite RNBAPRES. eapply EQUIVBARG; eauto. ii; exploit H; eauto.
+          ii; eapply H0; rewrite in_app_iff; left; eauto.
+          ii; eapply H0; rewrite in_app_iff; left; eauto.
+        * eapply IHargs; eauto. ii; eapply H0; rewrite in_app_iff; right; eauto.
+      + i. inv H2. econs; eauto.
+        * eapply eval_builtin_arg_preserved in H5.
+          revert H5. rewrite RNBAPRES. i. 
+          rewrite EQUIVBARG in H5; eauto. ii; exploit H; eauto.
+          ii; eapply H0; rewrite in_app_iff; left; eauto.
+          ii; eapply H0; rewrite in_app_iff; left; eauto.
+          i. exploit symbols_preserved; eauto.
+        * eapply IHargs; eauto. ii; eapply H0; rewrite in_app_iff; right; eauto.
+  Qed.
+  
+  Lemma eval_builtin_args_preserved_for_ds_eq:
+    forall args rs rs' d s vargs m sp,
+    equiv_regset_except_d rs rs' d ->
+    d <> s ->
+    rs # d = rs # s ->
+    eval_builtin_args ge (fun r => rs # r) sp m args vargs <->
+    eval_builtin_args tge (fun r => rs' # r) sp m (map (rename_barg d s) args) vargs.
+  Proof.
+    assert (EQUIVBARG:
+            forall arg d s sp m barg rs rs',
+            equiv_regset_except_d rs rs' d ->
+            d <> s ->
+            rs # d = rs # s ->
+            eval_builtin_arg ge (fun r => rs # r) sp m arg barg <->
+            eval_builtin_arg tge (fun r => rs' # r) sp m (rename_barg d s arg) barg).
+    { induction arg; ss; split; ii; try (inv H2; econstructor; eauto; fail).
+      - destruct (peq d x).
+        + clarify. unfold rename_reg; flatten; ss. inv H2.
+          rewrite H1. rewrite H; eauto. econstructor; eauto.
+          rewrite Pos.eqb_neq in Eq; clarify.
+        + unfold rename_reg; flatten; ss. rewrite Pos.eqb_eq in Eq; clarify.
+          inv H2. rewrite H; eauto. econstructor; eauto.
+      - destruct (peq d x).
+        + clarify. unfold rename_reg in H2; flatten H2; ss. inv H2.
+          rewrite <- H; eauto. rewrite <- H1. econstructor; eauto.
+          rewrite Pos.eqb_neq in Eq; clarify.
+        + unfold rename_reg in H2; flatten H2; ss. rewrite Pos.eqb_eq in Eq; clarify.
+          inv H2. rewrite <- H; eauto. econstructor; eauto.
+      - inv H2. econstructor; eauto. unfold Senv.symbol_address in *.
+        flatten H7; ss. rewrite symbols_preserved; rewrite Eq; ss.
+      - inv H2. econstructor; eauto. unfold Senv.symbol_address in *.
+        flatten H7; ss. rewrite <- symbols_preserved; rewrite Eq; ss.
+      - eapply eval_builtin_arg_preserved. eapply symbols_preserved.
+        inv H2. econstructor; eauto.
+      - eapply eval_builtin_arg_preserved. symmetry. eapply symbols_preserved.
+        inv H2. econstructor; eauto.
+      - inv H2; econs; eauto; try eapply IHarg1; eauto; eapply IHarg2; eauto.
+      - inv H2; econs; eauto; try eapply IHarg1; eauto; eapply IHarg2; eauto.
+      - inv H2; econs; eauto; try eapply IHarg1; eauto; eapply IHarg2; eauto.
+      - inv H2; econs; eauto; try eapply IHarg1; eauto; eapply IHarg2; eauto. }
+    induction args; ss.
+    - split; i; inv H2; econstructor; eauto.
+    - split; i.
+      + inv H2; econstructor; eauto. eapply EQUIVBARG; eauto. eapply IHargs; eauto.
+      + inv H2; econs; eauto. eapply EQUIVBARG; eauto. eapply IHargs; eauto.
+  Qed.
+
+  Lemma s_inv_eq_ds: forall f d s st sp pc rs m pc' pc'0,
+    (fn_code f) ! pc' = Some (Iop Omove (s :: nil) d pc'0) ->
+    s_inv ge (State st f sp pc rs m) ->
+    dom f pc' pc ->
+    pc' <> pc ->
+    rs # d = rs # s.
+  Proof.
+    i. inv H0. exploit SINV; eauto.
+    econstructor; eauto.
+    i. inv H0. inv H5. ss. inv EVAL. ss.
+  Qed.
+
+  Require Import Simulation.
+  
+  Section STEPSIM.
+
+  Definition tsem := SSA.semantics tprog.
+
+  Variables st_init_tgt st_init_tgt1: tsem.(Smallstep.state).
+  Hypothesis INIT1: tsem.(Smallstep.initial_state) st_init_tgt.
+  Hypothesis ICAP1: tsem.(Smallstep.initial_capture) st_init_tgt st_init_tgt1.
+  Definition gmtgt : ident -> option Z := tsem.(initial_pimap) st_init_tgt1.
+
+  Lemma step_simulation:
+    forall S1 t S2, IStep (SSA.semantics prog) S1 t S2 ->
+    forall S1' (IBIND: ge_binded_state tge S1' gmtgt), match_states S1 S1' ->
+    exists S2', DStep (SSA.semantics tprog) S1' t S2' /\ match_states S2 S2'.
+  Proof.
+    assert (Hwf1: forall s f sp pc rs m, s_inv ge (State s f sp pc rs m) ->
+                  wf_ssa_function f) by (intros s f sp pc rs m H; inv H; auto).
+    destruct 1. generalize dependent S2. rename H into INT. unfold is_internal in INT.
+    induction 1; intros S1' IBIND MS.
+    - inv MS. exists (State st' (transf_function_step f) sp pc' rs' m); split.
+      + apply transf_function_step_spec in H as Hstep.
+        des; eauto; DStep_tac.
+        all : eapply exec_Inop_njp; eauto; rewrite <- join_point_transf_function_step; ss.
+      + econstructor; eauto. eapply SSAinv.subj_red; eauto. econs; eauto.
+        inv MATCH.
+        rewrite <- 2 H3 in *. econstructor 1; eauto.
+        econstructor; eauto.
+        econstructor 3; eauto. i.
+        eapply PHIINV; eauto. eapply (@Dom.sdom_dom_pred node peq); eauto.
+        econstructor; eauto. ii; clarify. eapply H0. eapply (fn_phicode_inv); eauto.
+        intros contra; rewrite contra in *; discriminate.
+        econstructor; eauto.
+    
+    - (* Inop jnp *)
+      inv MS. eapply transf_function_step_phicode_phicode in H1 as HTFPHI. des.
+      exists (State st' (transf_function_step f) sp pc' (phi_store k phib' rs') m).
+      split.
+      + apply transf_function_step_spec in H; des; eauto.
+        all: DStep_tac; eapply exec_Inop_jp; eauto;
+          try (rewrite <- join_point_transf_function_step; eauto);
+          rewrite <- make_predecessors_transf_function_step; eauto.
+      + inv MATCH.
+        * rewrite <- H5 in *. rewrite NOTFOUND in *. rewrite NOTFOUND' in *.
+          econstructor; eauto. eapply SSAinv.subj_red; eauto. econs; eauto.
+          rewrite <- H5. econstructor; eauto.
+        * rewrite FOUND in *. econstructor; eauto. eapply SSAinv.subj_red; eauto.
+          econstructor 2; eauto. econs; eauto. i.
+          destruct (classic (use_phicode f d pc)).
+          { ii. eapply phi_store_eq_ds; eauto.
+            ii; clarify; apply find_mv_not_same in FOUND; eauto.
+            eapply find_mv_exists in FOUND. des.
+            eapply s_inv_eq_ds; eauto.
+            exploit fn_strict; eauto. econstructor 2; eauto.
+            ii; clarify. }
+          { ii. eapply phi_store_irrelevant; eauto. ii; clarify.
+            eapply find_mv_not_same; eauto. }
+        * rewrite NOTFOUND in *; rewrite FOUND in *.
+          econstructor; eauto. eapply SSAinv.subj_red; eauto. econs; eauto.
+          econstructor 3; eauto.
+          destruct (classic (use_phicode f d pc)).
+          { ii. eapply phi_store_eq_ds; eauto. ii; clarify.
+            eapply no_phi_use_def; eauto.
+            eapply find_mv_phicode_exists in FOUND as FOUND'; des.
+            eapply PHIINV; eauto. i. inv H5; eauto.
+            rewrite forallb_forall in FOUND'1. eapply FOUND'1 in H6.
+            rewrite Pos.eqb_eq in H6; eauto.
+            eapply fn_strict; eauto. econstructor 2; eauto.
+            ii; clarify; eapply no_phi_use_def; eauto. }
+          { ii. eapply phi_store_irrelevant; eauto.
+            ii; clarify; eapply no_phi_use_def; eauto. }
+          i. destruct (peq pc'0 pc').
+          { clarify. erewrite phi_store_spec_for_moves; eauto.
+            erewrite phi_store_spec_for_irrelevant; eauto. ii.
+            eapply no_phi_use_def'; eauto. }
+          { erewrite phi_store_spec_for_irrelevant; eauto.
+            erewrite phi_store_spec_for_irrelevant; eauto.
+            eapply PHIINV; eauto. eapply (@Dom.sdom_dom_pred node peq); eauto.
+            econstructor; eauto. econstructor; eauto.
+            ii. eapply no_phi_use_def'; eauto.
+            ii. eapply unique_def_spec_def. eauto. eauto.
+            econstructor 3; eauto. ii; clarify. }
+
+    - (* Iop *)
+      inv MS. inv MATCH.
+      + exists (State st' (transf_function_step f) sp pc' rs' # res <- v m).
+        split. rewrite <- 2 H3. DStep_tac. eapply exec_Iop; eauto.
+        erewrite eval_operation_wrapper_preserved; eauto.
+        eapply symbols_preserved; eauto. rewrite <- H3 at 1.
+        econstructor 1; eauto. eapply SSAinv.subj_red; eauto.
+        rewrite <- H3 in *. econstructor; eauto. rewrite <- H3 in *. econstructor 1; eauto.
+      + exploit transf_function_step_spec_simple; eauto. i. des.
+        exploit H2; eauto. i. clear H1 H2.
+        destruct (classic (use_code f d pc)).
+        { eapply find_mv_exists in FOUND as PCDEFD. des.
+          assert (dom f pc0 pc). eapply fn_strict; eauto. econstructor; eauto.
+          exists (State st' (transf_function_step f) sp pc' rs' # res <- v m).
+          split.
+          - DStep_tac.
+            assert (remove_mv_instr d (Iop op args res pc') = Iop op args res pc').
+            unfold remove_mv_instr. destruct op; ss. flatten; ss.
+            rewrite Pos.eqb_eq in Eq; clarify; ss.
+            exfalso; eapply fn_use_def_code; eauto. rewrite H4 in H3.
+            eapply exec_Iop; eauto. unfold subst_instr in H3.
+            assert (pc0 <> pc). ii; clarify.
+            inv H4; try rewrite PCDEFD in *; clarify. ss.
+            flatten H5; clarify. rewrite Pos.eqb_neq in Eq; clarify.
+            erewrite value_list_preserved_for_ds_eq.
+            erewrite eval_operation_wrapper_preserved; eauto.
+            eapply symbols_preserved; eauto. eauto.
+            eapply s_inv_eq_ds; eauto.
+            ii; clarify; exploit find_mv_not_same; eauto.
+          - econstructor; eauto. eapply SSAinv.subj_red; eauto. econs; eauto.
+            econstructor; eauto. ii. destruct (peq r res).
+            clarify. rewrite 2 PMap.gss; eauto. rewrite 2 PMap.gso; eauto. }
+        { destruct (classic (def f d pc)).
+          { exists (State st' (transf_function_step f) sp pc' rs' m).
+            eapply find_mv_exists in FOUND as FOUND'; eauto. des.
+            assert (def f d pc0). econstructor; eauto.
+            eapply def_def_eq in H4 as EQ. 3:{ eapply H2. } clarify; ss. split.
+            DStep_tac. eapply exec_Inop_njp; eauto.
+            flatten H3; ss. rewrite Pos.eqb_neq in Eq; clarify.
+            rewrite <- join_point_transf_function_step. ii.
+            eapply fn_normalized in H; eauto. rewrite FOUND' in H; discriminate.
+            eapply successors_instr_succs in FOUND'. des; eauto.
+            unfold Kildall.successors_list; rewrite FOUND'. eauto. ss; eauto.
+            econstructor; eauto. eapply SSAinv.subj_red; eauto. econs; eauto.
+            econstructor 2; eauto. ii.
+            rewrite PMap.gso; eauto. eauto. }
+          { exploit code_preserved_irrelevant; eauto. i. rewrite <- H4 in H3.
+            exists (State st' (transf_function_step f) sp pc' rs' # res <- v m).
+            split. DStep_tac. eapply exec_Iop; eauto.
+            erewrite eval_operation_wrapper_preserved.
+            erewrite <- value_list_preserved_for_equiv_regsets; eauto.
+            ii; eapply H1; econstructor; eauto.
+            eapply symbols_preserved; eauto.
+            econstructor; eauto. eapply SSAinv.subj_red; eauto. econs; eauto.
+            econstructor; eauto. ii. destruct (peq r res).
+            clarify; rewrite 2 PMap.gss; eauto.
+            rewrite 2 PMap.gso; eauto. } }
+      + exists (State st' (transf_function_step f) sp pc' rs' # res <- v m).
+        exploit transf_function_step_spec_simple; eauto. i. des.
+        exploit H2; eauto. i; clear H1 H2. split.
+        destruct (classic (use_code f d pc)).
+        { assert (remove_mv_instr d (Iop op args res pc') = Iop op args res pc').
+          { unfold remove_mv_instr. flatten; ss. rewrite Pos.eqb_eq in Eq0; clarify.
+            eapply find_mv_phicode_exists in FOUND; des.
+            exfalso; eapply assigned_code_and_phi; eauto. } rewrite H2 in H3. clear H2.
+          eapply find_mv_phicode_exists in FOUND as PHIMOVE; des.
+          DStep_tac. eapply exec_Iop; eauto.
+          unfold subst_instr in H3.
+          erewrite value_list_preserved_for_ds_eq.
+          erewrite eval_operation_wrapper_preserved; eauto.
+          eapply symbols_preserved; eauto. eauto.
+          eapply PHIINV; eauto. rewrite forallb_forall in PHIMOVE1; i; eauto.
+          inv H2; eauto. eapply PHIMOVE1 in H4; rewrite Pos.eqb_eq in H4; eauto.
+          eapply fn_strict; eauto. econstructor; eauto.
+          all: ii; clarify; eapply no_phi_use_def; eauto. }
+        { eapply find_mv_phicode_exists in FOUND; eauto; des.
+          exploit code_preserved_irrelevant; eauto. ii.
+          exploit assigned_code_and_phi; eauto. i. rewrite <- H2 in H3.
+          DStep_tac; eapply exec_Iop; eauto.
+          erewrite value_list_preserved_for_equiv_regsets.
+          erewrite eval_operation_wrapper_preserved; eauto.
+          eapply symbols_preserved; eauto. ii; erewrite EQUIV; eauto.
+          ii; eapply H1; eauto. econstructor; eauto. }
+        econstructor; eauto. eapply SSAinv.subj_red; eauto. econs; eauto.
+        econstructor 3; eauto. ii.
+        destruct (peq r res);
+          clarify; [erewrite 2 PMap.gss | erewrite 2 PMap.gso]; eauto.
+        ii. destruct (peq d res); clarify.
+        exploit assigned_code_and_phi; eauto. i; ss.
+        destruct (peq s0 res); clarify.
+        exploit no_phi_use_def'; eauto; ss.
+        eapply (@Dom.sdom_dom_pred node peq); eauto. econstructor; eauto.
+        ii; clarify. exploit fn_normalized; eauto.
+        eapply fn_phicode_inv; eauto. ii; rewrite H1 in *; clarify.
+        unfold Kildall.successors_list, successors. rewrite PTree.gmap1.
+        rewrite H; ss; eauto. i; rewrite H in *; eauto; clarify.
+        econstructor; eauto. rewrite 2 PMap.gso; ss.
+        exploit PHIINV; eauto.
+        eapply (@Dom.sdom_dom_pred node peq); eauto. econstructor; eauto.
+        ii; clarify. exploit fn_normalized; eauto.
+        eapply fn_phicode_inv; eauto. ii; rewrite H1 in *; clarify.
+        unfold Kildall.successors_list, successors. rewrite PTree.gmap1.
+        rewrite H; ss; eauto. i; rewrite H in *; eauto; clarify.
+        econstructor; eauto.
+    
+    - (* Iload *)
+      inv MS. exists (State st' (transf_function_step f) sp pc' rs' # dst <- v m).
+      inv MATCH.
+      + rewrite <- H4 in *. exploit transf_function_step_spec_simple; eauto.
+        i; des. exploit H2; eauto. clear H2 H3. i. split.
+        DStep_tac. eapply exec_Iload; eauto. erewrite eval_addressing_preserved; eauto.
+        eapply symbols_preserved.
+        econstructor 1; eauto. eapply SSAinv.subj_red; eauto. econs 4; eauto.
+        rewrite <- H4; econstructor; eauto.
+      + exploit transf_function_step_spec_simple; eauto.
+        i; des. exploit H3; eauto. clear H2 H3. i.
+        eapply find_mv_exists in FOUND as TFCODE; des.
+        split. ss.
+        DStep_tac. eapply exec_Iload; eauto. erewrite eval_addressing_preserved.
+        destruct (classic (use_code f d pc)).
+        { erewrite value_list_preserved_for_ds_eq; eauto. inv SINV.
+          eapply s_inv_eq_ds; eauto.
+          exploit fn_strict; eauto. econstructor; eauto. ii. subst pc0.
+          rewrite H in *; clarify.
+          ii. exploit find_mv_not_same; eauto. }
+        { exploit code_preserved_irrelevant; eauto. ii.
+          exploit assigned_code_unique. eauto. eauto. econstructor. eapply TFCODE.
+          i; subst pc. rewrite TFCODE in *; clarify. i. ss. rewrite <- H4 in H2.
+          inv H4. rewrite <- 2 H6. erewrite value_list_preserved_for_equiv_regsets.
+          eauto. ii; rewrite EQUIV; eauto. ii; eapply H3; eauto using use_code. }
+        eapply symbols_preserved.
+        econstructor; eauto. eapply SSAinv.subj_red; eauto. econs 4; eauto.
+        econstructor 2; eauto. ii.
+        destruct (peq r dst);
+          clarify; [erewrite 2 PMap.gss | erewrite 2 PMap.gso]; eauto.
+      + exploit transf_function_step_spec_simple; eauto.
+        i; des. exploit H3; eauto. clear H2 H3. i.
+        eapply find_mv_phicode_exists in FOUND as PHIMOVE; des.
+        split. destruct (classic (use_code f d pc)).
+        { ss. DStep_tac. eapply exec_Iload; eauto.
+          erewrite value_list_preserved_for_ds_eq.
+          erewrite eval_addressing_preserved; eauto.
+          eapply symbols_preserved; eauto. eauto.
+          eapply PHIINV; eauto. rewrite forallb_forall in PHIMOVE1; i; eauto.
+          inv H4; eauto. eapply PHIMOVE1 in H5; rewrite Pos.eqb_eq in H5; eauto.
+          eapply fn_strict; eauto. econstructor; eauto.
+          ii; clarify; eapply no_phi_use_def; eauto.
+          ii; clarify; eapply no_phi_use_def; eauto. }
+        { exploit code_preserved_irrelevant; eauto. ii.
+          exploit assigned_code_and_phi; eauto. i. rewrite <- H4 in H2.
+          DStep_tac; eapply exec_Iload; eauto.
+          erewrite value_list_preserved_for_equiv_regsets.
+          erewrite eval_addressing_preserved; eauto.
+          eapply symbols_preserved; eauto. ii; erewrite EQUIV; eauto.
+          ii; eapply H3; eauto using use_code. }
+        econstructor; eauto. eapply SSAinv.subj_red; eauto. econs 4; eauto.
+        econstructor 3; eauto. ii.
+        destruct (peq r dst);
+          clarify; [erewrite 2 PMap.gss | erewrite 2 PMap.gso]; eauto.
+        ii. destruct (peq d dst); clarify.
+        exploit assigned_code_and_phi; eauto. i; ss.
+        assert (pc' <> pc'0).
+        { ii; clarify. exploit fn_normalized; eauto.
+          eapply fn_phicode_inv; eauto. ii; rewrite H3 in *; clarify.
+          unfold Kildall.successors_list, successors. rewrite PTree.gmap1.
+          rewrite H; ss; eauto. i; rewrite H in *; eauto; clarify. }
+        destruct (peq s0 dst); clarify.
+        exploit no_phi_use_def'; eauto; ss.
+        eapply (@Dom.sdom_dom_pred node peq); eauto.
+        econstructor; eauto. econstructor; eauto.
+        rewrite 2 PMap.gso; eauto.
+        exploit PHIINV; eauto. eapply (@Dom.sdom_dom_pred node peq); eauto.
+        econstructor; eauto. econstructor; eauto.
+    
+    - (* Istore *)
+      inv MS. exists (State st' (transf_function_step f) sp pc' rs' m').
+      inv MATCH.
+      + rewrite <- H4 in *. split. rewrite H4 in H.
+        DStep_tac; eapply exec_Istore; eauto.
+        erewrite eval_addressing_preserved; eauto. eapply symbols_preserved.
+        econstructor; eauto. eapply SSAinv.subj_red; eauto. econs; eauto.
+        rewrite <- H4. econstructor; eauto.
+      + exploit transf_function_step_spec_simple; eauto.
+        i; des. exploit H3; eauto. clear H2 H3. i.
+        eapply find_mv_exists in FOUND as TFCODE; des.
+        destruct (classic (use_code f d pc)).
+        { split. ss.
+          DStep_tac; eapply exec_Istore; eauto. erewrite eval_addressing_preserved.
+          erewrite value_list_preserved_for_ds_eq; eauto.
+          eapply s_inv_eq_ds; eauto.
+          exploit fn_strict; eauto. econstructor; eauto. ii. subst pc0.
+          rewrite H in *; clarify.
+          ii. exploit find_mv_not_same; eauto. eapply symbols_preserved.
+          destruct (peq src d); ss.
+          - clarify. unfold rename_reg; flatten. rewrite <- EQUIV.
+            erewrite <- s_inv_eq_ds; eauto.
+            exploit fn_strict; eauto. econstructor; eauto.
+            ii; subst pc. rewrite H in *; clarify.
+            ii; exploit find_mv_not_same; eauto.
+            rewrite Pos.eqb_neq in Eq; clarify.
+          - unfold rename_reg; flatten; ss. rewrite Pos.eqb_eq in Eq; clarify.
+            rewrite <- EQUIV; ss.
+          - econstructor; eauto. eapply SSAinv.subj_red; eauto. econs; eauto.
+            econstructor; eauto. }
+        { exploit code_preserved_irrelevant; eauto. ii.
+          exploit assigned_code_unique. eauto. eauto. econstructor. eapply TFCODE.
+          i; subst pc. rewrite TFCODE in *; clarify. i. ss. rewrite <- H4 in H2.
+          split. DStep_tac; eapply exec_Istore; eauto. erewrite eval_addressing_preserved.
+          erewrite value_list_preserved_for_equiv_regsets; eauto.
+          ii; rewrite EQUIV; eauto. ii; eapply H3; eauto using use_code.
+          eapply symbols_preserved. rewrite <- EQUIV; eauto. ii; clarify.
+          eapply H3; eauto using use_code.
+          econstructor; eauto. eapply SSAinv.subj_red; eauto. econs; eauto.
+          econstructor 2; eauto. }
+      + exploit transf_function_step_spec_simple; eauto.
+        i; des. exploit H3; eauto. clear H2 H3. i.
+        eapply find_mv_phicode_exists in FOUND as PHIMOVE; des.
+        split. destruct (classic (use_code f d pc)).
+        { ss. DStep_tac. eapply exec_Istore; eauto.
+          erewrite value_list_preserved_for_ds_eq.
+          erewrite eval_addressing_preserved; eauto.
+          eapply symbols_preserved; eauto. eauto.
+          eapply PHIINV; eauto. rewrite forallb_forall in PHIMOVE1; i; eauto.
+          inv H4; eauto. eapply PHIMOVE1 in H5; rewrite Pos.eqb_eq in H5; eauto.
+          eapply fn_strict; eauto. econstructor; eauto.
+          ii; clarify; eapply no_phi_use_def; eauto.
+          ii; clarify; eapply no_phi_use_def; eauto.
+          destruct (peq src d).
+          { clarify. unfold rename_reg. flatten; ss. rewrite <- EQUIV; eauto.
+            exploit PHIINV; eauto. i. inv H4; ss. rewrite forallb_forall in PHIMOVE1.
+            eapply PHIMOVE1 in H5; rewrite Pos.eqb_eq in H5; eauto.
+            exploit fn_strict; eauto. econstructor; eauto.
+            ii; clarify; exploit no_phi_use_def; eauto.
+            intros ds; rewrite <- ds; eauto.
+            ii; clarify; exploit no_phi_use_def; eauto.
+            rewrite Pos.eqb_neq in Eq; clarify. }
+          { unfold rename_reg. flatten; ss. rewrite Pos.eqb_eq in Eq; clarify.
+            rewrite <- EQUIV; eauto. } }
+        { exploit code_preserved_irrelevant; eauto. ii.
+          exploit assigned_code_and_phi; eauto. i. rewrite <- H4 in H2. clear H4.
+          DStep_tac; eapply exec_Istore; eauto.
+          erewrite value_list_preserved_for_equiv_regsets.
+          erewrite eval_addressing_preserved; eauto.
+          eapply symbols_preserved; eauto. ii; erewrite EQUIV; eauto.
+          ii; eapply H3; eauto using use_code.
+          rewrite <- EQUIV; eauto. ii; clarify; eapply H3; eauto using use_code. }
+        econstructor; eauto. eapply SSAinv.subj_red; eauto. econs; eauto.
+        econstructor 3; eauto. ii.
+        assert (pc' <> pc'0).
+        { ii; clarify. exploit fn_normalized; eauto.
+          eapply fn_phicode_inv; eauto. ii; rewrite H3 in *; clarify.
+          unfold Kildall.successors_list, successors. rewrite PTree.gmap1.
+          rewrite H; ss; eauto. i; rewrite H in *; eauto; clarify. }
+        exploit PHIINV; eauto. eapply (@Dom.sdom_dom_pred node peq); eauto.
+        econstructor; eauto. econstructor; eauto.
+
+    - (* Icall *)
+      inv MS. inv MATCH.
+      + exists (Callstate (Stackframe res (transf_function_step f) sp pc' rs' :: st')
+                        (transf_fundef_step fd) rs' ## args m).
+        rewrite <- H3 in *. split.
+        * rewrite <- H3. DStep_tac. eapply exec_Icall; eauto.
+          erewrite find_function_translated; eauto. eapply sig_preserved.
+        * econstructor; eauto. eapply SSAinv.subj_red; eauto. econs; eauto.
+          rewrite H3 at 2. econstructor; eauto. rewrite <- H3 in *; econstructor; eauto.
+      + exploit transf_function_step_spec_simple; eauto.
+        i; des. exploit H2; eauto. clear H1 H2. i.
+        eapply find_mv_exists in FOUND as TFCODE; des. ss.
+        exists (Callstate (Stackframe res (transf_function_step f) sp pc' rs' :: st')
+                          (transf_fundef_step fd)
+                          rs' ## (map (rename_reg d s0) args) m). 
+        destruct (classic (use_code f d pc)).
+        { split.
+          - DStep_tac. eapply exec_Icall; eauto.
+            + erewrite find_function_translated; eauto.
+              { destruct ros.
+                - destruct (peq d r).
+                  + clarify. unfold rename_fn, rename_reg in *. rewrite Pos.eqb_refl in *.
+                    ss.
+                    repeat rewrite <- EQUIV; eauto.
+                    erewrite <- s_inv_eq_ds; eauto.
+                    exploit fn_strict; eauto. econstructor; eauto.
+                    ii; subst pc0. rewrite H in *; clarify.
+                    ii; clarify; exploit find_mv_not_same; eauto.
+                    ii; clarify; exploit find_mv_not_same; eauto.
+                  + unfold rename_fn, rename_reg. flatten.
+                    * eapply Pos.eqb_eq in Eq; clarify.
+                    * ss. repeat rewrite <- EQUIV; eauto.
+                - ss. }
+            + eapply sig_preserved.
+          - erewrite value_list_preserved_for_ds_eq. econstructor 2; eauto.
+            eapply SSAinv.subj_red; eauto. econs; eauto.
+            econstructor; eauto. econstructor 2; eauto. eauto. eapply s_inv_eq_ds; eauto.
+            exploit fn_strict; eauto. econstructor; eauto.
+            ii; subst pc0; clarify. ii; exploit find_mv_not_same; eauto. }
+        { split. DStep_tac. eapply exec_Icall; eauto.
+          erewrite find_function_translated; eauto.
+          { destruct ros.
+            - destruct (peq d r).
+              + clarify. exploit H2; eauto using use_code; ss.
+              + unfold rename_fn, rename_reg. flatten.
+                * eapply Pos.eqb_eq in Eq; clarify.
+                * ss. repeat rewrite <- EQUIV; eauto.
+            - ss. }
+          eapply sig_preserved.
+          exploit code_preserved_irrelevant; eauto. ii.
+          exploit assigned_code_unique. eauto. eauto. econstructor. eauto.
+          ii; subst pc0. clarify. i. ss. inv H3. rewrite <- 2 H6.
+          exploit value_list_preserved_for_equiv_regsets; eauto.
+          2:{ i. rewrite <- H3. econstructor 2; eauto.
+              eapply SSAinv.subj_red; eauto. econs; eauto.
+              econstructor; eauto. econstructor 2; eauto. }
+          ii. destruct ros; eapply H2; eauto using use_code. }
+      + exploit transf_function_step_spec_simple; eauto; i; des.
+        exploit H2; eauto; i. clear H1 H2. ss.
+        exists (Callstate (Stackframe res (transf_function_step f) sp pc' rs' :: st')
+                          (transf_fundef_step fd)
+                          rs' ## (map (rename_reg d s0) args) m).
+        eapply find_mv_phicode_exists in FOUND as MVPHI; des.
+        destruct (classic (use_code f d pc)).
+        * split. DStep_tac. eapply exec_Icall; eauto.
+          erewrite find_function_translated; eauto.
+          destruct ros.
+          { destruct (peq d r).
+            - clarify. unfold rename_fn, rename_reg in *. rewrite Pos.eqb_refl in *. ss.
+              repeat rewrite <- EQUIV; eauto.
+              erewrite <- PHIINV; eauto. i. inv H2; eauto.
+              rewrite forallb_forall in MVPHI1; eapply MVPHI1 in H4.
+              rewrite Pos.eqb_eq in H4; clarify.
+              exploit fn_strict; eauto. econstructor; eauto.
+              all : ii; clarify; exploit no_phi_use_def; eauto.
+            - unfold rename_fn, rename_reg. flatten.
+              + eapply Pos.eqb_eq in Eq; clarify.
+              + ss. repeat rewrite <- EQUIV; eauto. }
+            { ss. }
+            eapply sig_preserved.
+            assert (rs # d = rs # s0).
+            { eapply PHIINV; eauto. ii. inv H2; ss. rewrite forallb_forall in MVPHI1.
+              eapply MVPHI1 in H4; rewrite Pos.eqb_eq in H4; clarify.
+              exploit fn_strict; eauto. econstructor; eauto.
+              ii; clarify; exploit no_phi_use_def; eauto. }
+            erewrite value_list_preserved_for_ds_eq; eauto.
+            econstructor; eauto. eapply SSAinv.subj_red; eauto. econs; eauto.
+            econstructor; eauto. econstructor 3; eauto.
+            ii; clarify; exploit no_phi_use_def; eauto.
+        * split.
+          { DStep_tac. eapply exec_Icall; eauto. erewrite find_function_translated; eauto.
+            destruct ros.
+            - destruct (peq d r).
+              + clarify. exploit H1; eauto using use_code; ss.
+              + unfold rename_fn, rename_reg. flatten.
+                * eapply Pos.eqb_eq in Eq; clarify.
+                * ss.
+                  repeat rewrite <- EQUIV; eauto.
+            - ss.
+            - eapply sig_preserved. }
+          { exploit code_preserved_irrelevant; eauto. ii.
+            exploit assigned_code_and_phi; eauto. ii. inv H2; ss. rewrite <- 2 H6.
+            exploit value_list_preserved_for_equiv_regsets; eauto.
+            2:{ i. rewrite <- H2. econstructor; eauto.
+                eapply SSAinv.subj_red; eauto. econs; eauto. econstructor; eauto.
+                econstructor 3; eauto. ii. exploit PHIINV; eauto.
+                eapply (@Dom.sdom_dom_pred node peq); eauto.
+                econstructor; eauto. ii; subst pc'0.
+                exploit fn_normalized; eauto. exploit fn_phicode_inv; eauto.
+                i. rewrite H11. ii. rewrite H12 in H4; clarify.
+                unfold Kildall.successors_list, successors. rewrite PTree.gmap1.
+                rewrite H; ss. left; ss. i; clarify. econstructor; eauto. }
+            ii; eapply H1. destruct ros; eauto using use_code. }
+    
+    - (* Itailcall *)
+      inv MS. inv MATCH.
+      + exists (Callstate st' (transf_fundef_step fd) rs' ## args m').
+        rewrite <- H4 in *. split.
+        * rewrite <- H4. DStep_tac. eapply exec_Itailcall; eauto.
+          erewrite find_function_translated; eauto. eapply sig_preserved.
+        * econstructor; eauto. eapply SSAinv.subj_red; eauto. econs; eauto.
+      + exploit transf_function_step_spec_simple; eauto.
+        i; des. exploit H3; eauto. clear H1 H3. i.
+        eapply find_mv_exists in FOUND as TFCODE; des. ss.
+        exists (Callstate st' (transf_fundef_step fd)
+                          rs' ## (map (rename_reg d s0) args) m').
+        destruct (classic (use_code f d pc)).
+        { split. DStep_tac. eapply exec_Itailcall; eauto.
+          erewrite find_function_translated; eauto.
+          { destruct ros.
+            - destruct (peq d r).
+              + clarify. unfold rename_fn, rename_reg in *. rewrite Pos.eqb_refl in *. ss.
+                repeat rewrite <- EQUIV; eauto.
+                erewrite <- s_inv_eq_ds; eauto.
+                exploit fn_strict; eauto. econstructor; eauto.
+                ii; subst pc0. rewrite H in *; clarify.
+                all: ii; clarify; exploit find_mv_not_same; eauto.
+              + unfold rename_fn, rename_reg. flatten.
+                * eapply Pos.eqb_eq in Eq; clarify.
+                * ss. repeat rewrite <- EQUIV; eauto.
+            - ss. }
+          eapply sig_preserved.
+          unfold transf_function_step, transf_function_fuel. flatten; ss.
+          erewrite value_list_preserved_for_ds_eq; eauto. econstructor 2; eauto.
+          eapply SSAinv.subj_red; eauto. econs; eauto. eapply s_inv_eq_ds; eauto.
+          exploit fn_strict; eauto. econstructor; eauto.
+          ii; subst pc0; clarify. ii; exploit find_mv_not_same; eauto. }
+        { split. DStep_tac. eapply exec_Itailcall; eauto.
+          erewrite find_function_translated; eauto.
+          { destruct ros.
+            - destruct (peq d r).
+              + clarify. exploit H3; eauto using use_code; ss.
+              + unfold rename_fn, rename_reg. flatten.
+                * eapply Pos.eqb_eq in Eq; clarify.
+                * ss. repeat rewrite <- EQUIV; eauto.
+            - ss. }
+          eapply sig_preserved.
+          unfold transf_function_step, transf_function_fuel; flatten; ss.
+          exploit code_preserved_irrelevant; eauto. ii.
+          exploit assigned_code_unique. eauto. eauto. econstructor. eauto.
+          ii; subst pc0. clarify. i. ss. inv H4. rewrite <- 2 H7.
+          erewrite value_list_preserved_for_equiv_regsets; eauto. econstructor 2; eauto.
+          eapply SSAinv.subj_red; eauto.
+          erewrite <- value_list_preserved_for_equiv_regsets; eauto.
+          econs; eauto.
+          all: ii; destruct ros; eapply H3; eauto using use_code. }
+      + exploit transf_function_step_spec_simple; eauto; i; des.
+        exploit H3; eauto; i. clear H1 H3. ss.
+        exists (Callstate st' (transf_fundef_step fd)
+                          rs' ## (map (rename_reg d s0) args) m').
+        eapply find_mv_phicode_exists in FOUND as MVPHI; des.
+        destruct (classic (use_code f d pc)).
+        * split. DStep_tac. eapply exec_Itailcall; eauto.
+          erewrite find_function_translated; eauto.
+          { destruct ros.
+            - destruct (peq d r).
+              + clarify. unfold rename_fn, rename_reg in *. rewrite Pos.eqb_refl in *. ss.
+                repeat rewrite <- EQUIV; eauto.
+                erewrite <- PHIINV; eauto. i. inv H3; eauto.
+                rewrite forallb_forall in MVPHI1; eapply MVPHI1 in H5.
+                rewrite Pos.eqb_eq in H5; clarify.
+                exploit fn_strict; eauto. econstructor; eauto.
+                all : ii; clarify; exploit no_phi_use_def; eauto.
+              + unfold rename_fn, rename_reg. flatten.
+                * eapply Pos.eqb_eq in Eq; clarify.
+                * ss. repeat rewrite <- EQUIV; eauto.
+            - ss. }
+          eapply sig_preserved.
+          unfold transf_function_step, transf_function_fuel. flatten; ss.
+          erewrite value_list_preserved_for_ds_eq; eauto. econstructor 2; eauto.
+          eapply SSAinv.subj_red; eauto. econs; eauto.
+          eapply PHIINV; eauto. ii. inv H3; ss. rewrite forallb_forall in MVPHI1.
+          eapply MVPHI1 in H5; rewrite Pos.eqb_eq in H5; clarify.
+          exploit fn_strict; eauto. econstructor; eauto.
+          all : ii; clarify; exploit no_phi_use_def; eauto.
+        * split.
+          { DStep_tac. eapply exec_Itailcall; eauto.
+            erewrite find_function_translated; eauto.
+            destruct ros.
+            - destruct (peq d r).
+              + clarify. exploit H1; eauto using use_code; ss.
+              + unfold rename_fn, rename_reg. flatten.
+                * eapply Pos.eqb_eq in Eq; clarify.
+                * ss. repeat rewrite <- EQUIV; eauto.
+            - ss.
+            - eapply sig_preserved.
+            - unfold transf_function_step, transf_function_fuel; flatten; ss. }
+          { exploit code_preserved_irrelevant; eauto. ii.
+            exploit assigned_code_and_phi; eauto. ii. inv H3; ss. rewrite <- 2 H7.
+            exploit value_list_preserved_for_equiv_regsets; eauto.
+            2:{ i. rewrite <- H3. econstructor; eauto.
+                eapply SSAinv.subj_red; eauto. econs; eauto. }
+            ii; eapply H1. destruct ros; eauto using use_code. }
+      
+    - (* Ibuiltin *)
+      inv MS. 
+      exists (State st' (transf_function_step f) sp pc'
+                    (regmap_setres res vres rs') m').
+      inv MATCH.
+      + rewrite <- H4 in *. split.
+        * rewrite <- H4. DStep_tac. eapply exec_Ibuiltin; eauto.
+          eapply eval_builtin_args_preserved. eapply symbols_preserved.
+          eapply H0. eapply external_call_symbols_preserved; eauto.
+          eapply senv_equiv.
+        * econstructor; eauto. eapply SSAinv.subj_red; eauto. econs; eauto.
+          rewrite <- H4. econstructor; eauto.
+      + exploit transf_function_step_spec_simple; eauto; i; des.
+        exploit H3; eauto; i. clear H2 H3. ss.
+        eapply find_mv_exists in FOUND as MVCODE; des. split.
+        * DStep_tac. eapply exec_Ibuiltin; eauto.
+          2:{ eapply external_call_symbols_preserved. eapply senv_equiv.
+              eapply H1. }
+          destruct (classic (use_code f d pc)).
+          { eapply eval_builtin_args_preserved_for_ds_eq; eauto.
+            ii; exploit find_mv_not_same; eauto. exploit s_inv_eq_ds; eauto.
+            exploit fn_strict; eauto. econstructor; eauto.
+            ii; subst pc0; ss. clarify. }
+          { eapply eval_builtin_args_preserved_for_equiv_regset; eauto.
+            ii; eapply H2; eauto using use_code.
+            ii; exploit find_mv_not_same; eauto. }
+        * econstructor; eauto. eapply SSAinv.subj_red; eauto. econs; eauto.
+          econstructor 2; eauto. destruct res; ss. ii.
+          destruct (peq r x).
+          { clarify. rewrite 2 PMap.gss; eauto. }
+          { rewrite 2 PMap.gso; eauto. }
+      + exploit transf_function_step_spec_simple; eauto; i; des.
+        exploit H3; eauto; i. clear H2 H3. ss.
+        eapply find_mv_phicode_exists in FOUND as MVPHI; des. split.
+        * destruct (classic (use_code f d pc)).
+          { DStep_tac. eapply exec_Ibuiltin; eauto.
+            eapply eval_builtin_args_preserved_for_ds_eq; eauto.
+            ii; clarify; exploit no_phi_use_def; eauto.
+            exploit PHIINV; eauto. ii. inv H3; ss. rewrite forallb_forall in MVPHI1.
+            eapply MVPHI1 in H5; rewrite Pos.eqb_eq in H5; clarify; ss.
+            exploit fn_strict; eauto. econstructor; eauto.
+            ii; clarify; exploit no_phi_use_def; eauto.
+            eapply external_call_symbols_preserved; eauto. eapply senv_equiv; eauto. }
+          { DStep_tac. eapply exec_Ibuiltin; eauto.
+            eapply eval_builtin_args_preserved_for_equiv_regset; eauto.
+            ii; eapply H2; eauto using use_code.
+            ii; clarify; exploit no_phi_use_def; eauto.
+            eapply external_call_symbols_preserved; eauto. eapply senv_equiv; eauto. }
+        * econstructor; eauto. eapply SSAinv.subj_red; eauto. econs; eauto.
+          econstructor 3; eauto. destruct res; ss. ii.
+          destruct (peq r x).
+          { clarify. rewrite 2 PMap.gss; eauto. } { rewrite 2 PMap.gso; eauto. }
+          ii. assert (dom f pc'0 pc).
+          { eapply (@Dom.sdom_dom_pred node peq); eauto. econstructor; eauto.
+            ii; subst pc'0. exploit fn_normalized; eauto. exploit fn_phicode_inv; eauto.
+            intros JF; rewrite JF. ii. rewrite H8 in H2; clarify.
+            unfold Kildall.successors_list, successors. rewrite PTree.gmap1.
+            rewrite H; ss. eauto. i; clarify. econstructor; eauto. }
+          ii. destruct res; ss. destruct (peq x d).
+          { clarify. exploit assigned_code_and_phi; eauto; ss. }
+          destruct (peq x s0).
+          { clarify. exploit no_phi_use_def'; eauto. ss. }
+          rewrite 2 PMap.gso; eauto.
+          exploit PHIINV; eauto. exploit PHIINV; eauto.
+
+    - (* Icond, true *)
+      inv MS. exists (State st' (transf_function_step f) sp ifso rs' m).
+      split.
+      + inv MATCH.
+        * rewrite <- H3 in *. rewrite H3 in H. DStep_tac.
+          eapply exec_Icond_true; eauto.
+        * exploit transf_function_step_spec_simple; eauto.
+          i; des. exploit H2; eauto; i; ss. clear H1 H2.
+          eapply find_mv_exists in FOUND as MVCODE; des.
+          assert (pc <> pc0).
+          { ii; subst pc0. clarify. }
+          DStep_tac. eapply exec_Icond_true; eauto.
+          destruct (classic (use_code f d pc)).
+          { erewrite value_list_preserved_for_ds_eq; eauto.
+            exploit s_inv_eq_ds; eauto. exploit fn_strict; eauto. econstructor; eauto.
+            ii; exploit find_mv_not_same; eauto. }
+          { exploit code_preserved_irrelevant; eauto. ii. exploit assigned_code_unique.
+            eauto. eauto. econstructor; eauto. ss.
+            i. inv H4. rewrite <- 2 H6.
+            erewrite value_list_preserved_for_equiv_regsets; eauto.
+            ii; rewrite EQUIV; eauto.
+            ii; eapply H2; eauto using use_code. }
+        * exploit transf_function_step_spec_simple; eauto.
+          i; des; exploit H2; eauto; i; ss; clear H1 H2.
+          eapply find_mv_phicode_exists in FOUND as MVPHI; des.
+          DStep_tac. eapply exec_Icond_true; eauto.
+          destruct (classic (use_code f d pc)).
+          { erewrite value_list_preserved_for_ds_eq; eauto.
+            exploit PHIINV; eauto. i. inv H2; ss. rewrite forallb_forall in MVPHI1.
+            eapply MVPHI1 in H4; rewrite Pos.eqb_eq in H4; clarify.
+            exploit fn_strict; eauto. econstructor; eauto.
+            ii; clarify; exploit no_phi_use_def; eauto. 
+            ii; clarify; exploit no_phi_use_def; eauto. }
+          { exploit code_preserved_irrelevant; eauto. ii.
+            exploit assigned_code_and_phi; eauto.
+            i. inv H2. rewrite <- 2 H5.
+            erewrite value_list_preserved_for_equiv_regsets; eauto.
+            ii; rewrite EQUIV; eauto.
+            ii; eapply H1; eauto using use_code. }
+      + inv MATCH.
+        * econstructor; eauto.
+          eapply SSAinv.subj_red; eauto. rewrite <- H3 in *. eapply exec_Icond_true; eauto.
+          rewrite <- 2 H3 in *. econs; eauto.
+        * econs; eauto.
+          eapply SSAinv.subj_red; eauto. eapply exec_Icond_true; eauto.
+          econs; eauto.
+        * econs; eauto.
+          eapply SSAinv.subj_red; eauto. eapply exec_Icond_true; eauto.
+          econs 3; eauto. ii.
+          exploit PHIINV; eauto. eapply (@Dom.sdom_dom_pred node peq); eauto.
+          econstructor; eauto. ii; subst ifso. exploit fn_normalized; eauto.
+          exploit fn_phicode_inv; eauto.
+          intros JF; rewrite JF; intros PHI; rewrite PHI in *; clarify.
+          unfold Kildall.successors_list, successors. rewrite PTree.gmap1.
+          rewrite H; ss. eauto. i; clarify. econstructor; eauto.
+      
+    - (* Icond, false *)
+      inv MS. exists (State st' (transf_function_step f) sp ifnot rs' m).
+      split.
+      + inv MATCH.
+        * rewrite <- H3 in *. rewrite H3 in H. DStep_tac.
+          eapply exec_Icond_false; eauto.
+        * exploit transf_function_step_spec_simple; eauto.
+          i; des. exploit H2; eauto; i; ss. clear H1 H2.
+          eapply find_mv_exists in FOUND as MVCODE; des.
+          assert (pc <> pc0).
+          { ii; subst pc0. clarify. }
+          DStep_tac. eapply exec_Icond_false; eauto.
+          destruct (classic (use_code f d pc)).
+          { erewrite value_list_preserved_for_ds_eq; eauto.
+            exploit s_inv_eq_ds; eauto. exploit fn_strict; eauto. econstructor; eauto.
+            ii; exploit find_mv_not_same; eauto. }
+          { exploit code_preserved_irrelevant; eauto. ii. exploit assigned_code_unique.
+            eauto. eauto. econstructor; eauto. ss.
+            i. inv H4. rewrite <- 2 H6.
+            erewrite value_list_preserved_for_equiv_regsets; eauto.
+            ii; rewrite EQUIV; eauto.
+            ii; eapply H2; eauto using use_code. }
+        * exploit transf_function_step_spec_simple; eauto.
+          i; des; exploit H2; eauto; i; ss; clear H1 H2.
+          eapply find_mv_phicode_exists in FOUND as MVPHI; des.
+          DStep_tac. eapply exec_Icond_false; eauto.
+          destruct (classic (use_code f d pc)).
+          { erewrite value_list_preserved_for_ds_eq; eauto.
+            exploit PHIINV; eauto. i. inv H2; ss. rewrite forallb_forall in MVPHI1.
+            eapply MVPHI1 in H4; rewrite Pos.eqb_eq in H4; clarify.
+            exploit fn_strict; eauto. econstructor; eauto.
+            ii; clarify; exploit no_phi_use_def; eauto. 
+            ii; clarify; exploit no_phi_use_def; eauto. }
+          { exploit code_preserved_irrelevant; eauto. ii.
+            exploit assigned_code_and_phi; eauto.
+            i. inv H2. rewrite <- 2 H5.
+            erewrite value_list_preserved_for_equiv_regsets; eauto.
+            ii; rewrite EQUIV; eauto.
+            ii; eapply H1; eauto using use_code. }
+      + inv MATCH.
+        * econstructor; eauto.
+          eapply SSAinv.subj_red; eauto. rewrite <- H3 in *. eapply exec_Icond_false; eauto.
+          rewrite <- 2 H3 in *. econs; eauto.
+        * econs; eauto.
+          eapply SSAinv.subj_red; eauto. eapply exec_Icond_false; eauto.
+          econs; eauto.
+        * econs; eauto.
+          eapply SSAinv.subj_red; eauto. eapply exec_Icond_false; eauto.
+          econs 3; eauto. ii.
+          exploit PHIINV; eauto. eapply (@Dom.sdom_dom_pred node peq); eauto.
+          econstructor; eauto. ii; subst ifnot. exploit fn_normalized; eauto.
+          exploit fn_phicode_inv; eauto.
+          intros JF; rewrite JF; intros PHI; rewrite PHI in *; clarify.
+          unfold Kildall.successors_list, successors. rewrite PTree.gmap1.
+          rewrite H; ss. eauto. i; clarify. econstructor; eauto.  
+
+    - (* Ijumptable *)
+      inv MS. exists (State st' (transf_function_step f) sp pc' rs' m).
+      split.
+      + inv MATCH.
+        * rewrite <- 2 H4 in *. DStep_tac. eapply exec_Ijumptable; eauto.
+        * eapply find_mv_exists in FOUND as MVCODE; des.
+          exploit transf_function_step_spec_simple. eapply H. i; des.
+          exploit H3; eauto; i; ss; clear H2 H3.
+          destruct (classic (use_code f d pc)).
+          { DStep_tac. eapply exec_Ijumptable; eauto. destruct (peq d arg).
+            { clarify. unfold rename_reg; flatten; ss.
+              - rewrite <- EQUIV; eauto.
+                exploit s_inv_eq_ds; eauto. exploit fn_strict; eauto.
+                econstructor; eauto.
+                ii; subst pc0; clarify. i. rewrite <- H3; ss.
+                ii; exploit find_mv_not_same; eauto.
+              - rewrite Pos.eqb_neq in Eq; clarify. }
+            { unfold rename_reg; flatten.
+              - rewrite Pos.eqb_eq in Eq; clarify.
+              - rewrite <- EQUIV; eauto. } }
+          { DStep_tac. eapply exec_Ijumptable; eauto. unfold rename_reg; flatten.
+            - rewrite Pos.eqb_eq in Eq; clarify. exfalso; eapply H2; eauto using use_code.
+            - rewrite Pos.eqb_neq in Eq. rewrite <- EQUIV; eauto. }
+        * exploit transf_function_step_spec_simple; eauto.
+          i; des; exploit H3; eauto; i; ss; clear H2 H3.
+          eapply find_mv_phicode_exists in FOUND as MVPHI; des.
+          DStep_tac. eapply exec_Ijumptable; eauto.
+          destruct (classic (use_code f d pc)).
+          { destruct (peq d arg).
+            { clarify. unfold rename_reg; flatten; ss.
+              - rewrite <- EQUIV; eauto.
+                exploit PHIINV; eauto. i. inv H3; ss. rewrite forallb_forall in MVPHI1.
+                eapply MVPHI1 in H5; rewrite Pos.eqb_eq in H5; clarify.
+                exploit fn_strict; eauto. econstructor; eauto.
+                ii; clarify; exploit no_phi_use_def; eauto. i; rewrite <- H3; ss.
+                ii; clarify; exploit no_phi_use_def; eauto.
+              - rewrite Pos.eqb_neq in Eq; clarify.  }
+            { unfold rename_reg; flatten.
+              - rewrite Pos.eqb_eq in Eq; clarify.
+              - rewrite <- EQUIV; eauto. } }
+          { exploit code_preserved_irrelevant; eauto. ii.
+            exploit assigned_code_and_phi; eauto.
+            i. inv H3. rewrite <- 2 H6. rewrite <- EQUIV; eauto.
+            ii; clarify; eapply H2; eauto using use_code. }
+      + inv MATCH.
+        * econs; eauto. eapply SSAinv.subj_red; eauto.
+          rewrite <- H4 in *. econs 11; eauto. rewrite <- 2 H4 in *. econs; eauto.
+        * econs; eauto. eapply SSAinv.subj_red; eauto. econs 11; eauto.
+          econstructor 2; eauto.
+        * econs; eauto. eapply SSAinv.subj_red; eauto. econs 11; eauto.
+          econstructor 3; eauto. ii.
+          exploit PHIINV; eauto. eapply (@Dom.sdom_dom_pred node peq); eauto.
+          econstructor; eauto. ii; subst pc'0. exploit fn_normalized; eauto.
+          exploit fn_phicode_inv; eauto.
+          intros JF; rewrite JF; intros PHI; rewrite PHI in *; clarify.
+          unfold Kildall.successors_list, successors. rewrite PTree.gmap1.
+          rewrite H; ss. eapply list_nth_z_in; eauto. i; clarify. econstructor; eauto.
+          ss. eapply list_nth_z_in; eauto.
+          
+    - (* Ireturn *)
+      inv MS. inv MATCH.
+      + exists (Returnstate st' (regmap_optget or Vundef rs') m').
+        rewrite <- 2 H3 in *. split.
+        * DStep_tac. eapply exec_Ireturn; eauto.
+        * econstructor; eauto. eapply SSAinv.subj_red; eauto. econs; eauto.
+      + eapply find_mv_exists in FOUND as MVCODE; des.
+        exploit transf_function_step_spec_simple. eapply H. eauto; i; des.
+        exploit H2; eauto; i; ss; clear H1 H2.
+        exists (Returnstate st'
+                            (regmap_optget (option_map (rename_reg d s0) or) Vundef rs')
+                            m').
+        split.
+        * DStep_tac. eapply exec_Ireturn; eauto.
+          unfold transf_function_step, transf_function_fuel; flatten; ss.
+        * destruct (classic (use_code f d pc)).
+          { inv H1; clarify. unfold rename_reg; flatten; ss.
+            exploit s_inv_eq_ds; eauto. exploit fn_strict; eauto.
+            econstructor; eauto using use_code.
+            ii; subst pc0; clarify. i. rewrite Pos.eqb_refl.
+            rewrite <- EQUIV. rewrite <- H.
+            econstructor; eauto. eapply SSAinv.subj_red; eauto.
+            exploit exec_Ireturn; eauto.
+            ii; clarify; exploit find_mv_not_same; eauto. }
+          { destruct or; ss. unfold rename_reg; flatten; ss.
+            - rewrite Pos.eqb_eq in Eq; clarify; exfalso;
+                eapply H1; eauto using use_code.
+            - rewrite Pos.eqb_neq in Eq. rewrite <- EQUIV; eauto.
+              econstructor; eauto. eapply SSAinv.subj_red; eauto.
+              exploit exec_Ireturn. eapply H. all: eauto.
+            - econs; eauto. eapply SSAinv.subj_red; eauto.
+              exploit exec_Ireturn. eapply H. all: eauto. }
+      + eapply find_mv_phicode_exists in FOUND as MVPHI; des.
+        exploit transf_function_step_spec_simple. eapply H. eauto; i; des.
+        exploit H2; eauto; i; ss; clear H1 H2.
+        exists (Returnstate st'
+                            (regmap_optget (option_map (rename_reg d s0) or) Vundef rs')
+                            m').
+        split.
+        * DStep_tac. eapply exec_Ireturn; eauto.
+          unfold transf_function_step, transf_function_fuel; flatten; ss.
+        * destruct or; ss.
+          { destruct (classic (use_code f d pc)).
+            { inv H1; clarify. unfold rename_reg; flatten; ss.
+              exploit PHIINV; eauto. i. inv H; ss. rewrite forallb_forall in MVPHI1.
+              eapply MVPHI1 in H1; rewrite Pos.eqb_eq in H1; clarify.
+              exploit fn_strict; eauto. econstructor; eauto using use_code.
+              ii; clarify; exploit no_phi_use_def; eauto.
+              i. rewrite <- EQUIV. rewrite <- H. econstructor; eauto.
+              eapply SSAinv.subj_red; eauto. exploit exec_Ireturn.
+              eapply H2. all: eauto.
+              ii; clarify; exploit no_phi_use_def; eauto.
+              rewrite Pos.eqb_neq in Eq; clarify. }
+            { unfold rename_reg; flatten; ss.
+              - rewrite Pos.eqb_eq in Eq; clarify; exfalso;
+                  eapply H1; eauto using use_code.
+              - rewrite Pos.eqb_neq in Eq. rewrite <- EQUIV; eauto.
+                econstructor; eauto. eapply SSAinv.subj_red; eauto.
+                exploit exec_Ireturn. eapply H. all: eauto. } }
+          { econstructor; eauto. eapply SSAinv.subj_red; eauto.
+            clear H3. exploit exec_Ireturn; eauto. }
+
+    - (* internal *)
+      ss. inv MS.
+      exists (State st (transf_function_step f) (Vptr stk Ptrofs.zero)
+                    (fn_entrypoint (transf_function_step f))
+                    (init_regs args (fn_params (transf_function_step f))) m').
+      split.
+      + DStep_tac. eapply exec_function_internal; eauto.
+        unfold transf_function_step, transf_function_fuel; flatten; ss.
+      + assert (fn_entrypoint (transf_function_step f) = fn_entrypoint f).
+        { unfold transf_function_step, transf_function_fuel; flatten; ss. }
+        assert (fn_params (transf_function_step f) = fn_params f).
+        { unfold transf_function_step, transf_function_fuel; flatten; ss. }
+        rewrite H0, H1. clear H0 H1. econstructor; eauto.
+        eapply SSAinv.subj_red; eauto. econs; eauto.
+        assert (transf_function_step f = transf_function_step f) by auto.
+        unfold transf_function_step at 2 in H0.
+        unfold transf_function_fuel in H0. ss. flatten H0.
+        * econstructor 2; eauto. ii; ss.
+        * econstructor 3; eauto. ii; ss.
+          ii. eapply Dom.dom_entry in H4. clarify.
+          exploit no_assigned_phi_spec_fn_entrypoint; eauto. inv SINV; inv WFF; ss.
+          i; ss. eapply Pos.eq_dec.
+        * rewrite H0. destruct f; ss. econstructor 1; eauto.
+        
+    - (* external *)
+      inv MS. exists (Returnstate st res m'). split.
+      DStep_tac. eapply exec_function_external; eauto.
+      eapply external_call_symbols_preserved; eauto. eapply senv_equiv.
+      econstructor; eauto. eapply SSAinv.subj_red; eauto. econs; eauto. 
+
+    - (* return *)
+      inv MS. inv STACK. eexists. split.
+      DStep_tac. eapply exec_return.
+      econstructor; eauto. eapply SSAinv.subj_red; eauto. econs; eauto.
+      inv MATCH.
+      + rewrite <- 2 H1 in *. econstructor; eauto.
+      + econstructor 2; eauto. ii. destruct (peq r res).
+        clarify. rewrite 2 PMap.gss; eauto.
+        rewrite 2 PMap.gso; eauto.
+      + econstructor 3; eauto.
+        * ii. destruct (peq r res).
+          clarify. rewrite 2 PMap.gss; eauto. rewrite 2 PMap.gso; eauto.
+        * ii. eapply find_mv_phicode_exists in FOUND as MVPHI; des; eauto.
+          assert (pc' = pc0). { eapply def_def_eq; eauto. } clarify.
+          destruct (peq res d).
+          { clarify. exploit assigned_code_and_phi; eauto. ss. }
+          destruct (peq res s0).
+          { clarify. exploit no_phi_use_def'. eauto. eapply MVPHI. eauto.
+            i. inv H; ss. rewrite forallb_forall in MVPHI1. eapply MVPHI1 in H4.
+            rewrite Pos.eqb_eq in H4; ss. eauto.
+            eapply (@Dom.sdom_dom_pred node peq); eauto.
+            econstructor; eauto. ii; subst pc0; clarify.
+            exploit fn_normalized; eauto. exploit fn_phicode_inv; eauto.
+            intros JP; rewrite JP; ii. rewrite H in MVPHI; clarify.
+            unfold Kildall.successors_list, successors. rewrite PTree.gmap1.
+            rewrite PREDINFO; ss. eauto. i; clarify. econstructor; eauto. ss. }
+          rewrite 2 PMap.gso; eauto.
+    Unshelve. all: eauto.
+  Qed.
+
+
+  (* Lemma transl_step_correct:
+    forall s1 t s2,
+      step ge s1 t s2 ->
+      step ge s1 t s2 ->
+      forall s1' (MS: match_states s1 s1'),
+      exists s2', step tge s1' t s2' /\ match_states s2 s2'.
+  Proof.
+    assert (Hwf1: forall s f sp pc rs m, s_inv ge (State s f sp pc rs m) ->
+                  wf_ssa_function f) by (intros s f sp pc rs m H; inv H; auto).
+    
+    induction 1; intros; inv MS; auto.
+    - (* Inop not jnp *)
+      exists (State st' (transf_function_step f) sp pc' rs' m); split.
+      + eapply exec_Inop_njp; eauto. apply transf_function_step_spec in H as Hstep.
+        des; eauto. rewrite <- join_point_transf_function_step; ss.
+      + econstructor; eauto. eapply SSAinv.subj_red; eauto.
+        inv MATCH.
+        rewrite <- 2 H4 in *. econstructor 1; eauto.
+        econstructor; eauto.
+        econstructor 3; eauto. i.
+        eapply PHIINV; eauto. eapply (@Dom.sdom_dom_pred node peq); eauto.
+        econstructor; eauto. ii; clarify. eapply H0. eapply (fn_phicode_inv); eauto.
+        intros contra; rewrite contra in *; discriminate.
+        econstructor; eauto.
+
+    - (* Inop jnp *)
+      eapply transf_function_step_phicode_phicode in H1 as HTFPHI. des.
+      exists (State st' (transf_function_step f) sp pc' (phi_store k phib' rs') m).
+      split.
+      + eapply exec_Inop_jp; eauto.
+        apply transf_function_step_spec in H; des; eauto.
+        rewrite <- join_point_transf_function_step; eauto.
+        rewrite <- make_predecessors_transf_function_step; eauto.
+      + inv MATCH.
+        * rewrite <- H6 in *. rewrite NOTFOUND in *. rewrite NOTFOUND' in *.
+          econstructor; eauto. eapply SSAinv.subj_red; eauto.
+          rewrite <- H6. econstructor; eauto.
+        * rewrite FOUND in *. econstructor; eauto. eapply SSAinv.subj_red; eauto.
+          econstructor 2; eauto. i.
+          destruct (classic (use_phicode f d pc)).
+          { ii. eapply phi_store_eq_ds; eauto.
+            ii; clarify; apply find_mv_not_same in FOUND; eauto.
+            eapply find_mv_exists in FOUND. des.
+            eapply s_inv_eq_ds; eauto.
+            exploit fn_strict; eauto. econstructor 2; eauto.
+            ii; clarify. }
+          { ii. eapply phi_store_irrelevant; eauto. ii; clarify.
+            eapply find_mv_not_same; eauto. }
+        * rewrite NOTFOUND in *; rewrite FOUND in *.
+          econstructor; eauto. eapply SSAinv.subj_red; eauto.
+          econstructor 3; eauto.
+          destruct (classic (use_phicode f d pc)).
+          { ii. eapply phi_store_eq_ds; eauto. ii; clarify.
+            eapply no_phi_use_def; eauto.
+            eapply find_mv_phicode_exists in FOUND as FOUND'; des.
+            eapply PHIINV; eauto. i. inv H6; eauto.
+            rewrite forallb_forall in FOUND'1. eapply FOUND'1 in H7.
+            rewrite Pos.eqb_eq in H7; eauto.
+            eapply fn_strict; eauto. econstructor 2; eauto.
+            ii; clarify; eapply no_phi_use_def; eauto. }
+          { ii. eapply phi_store_irrelevant; eauto.
+            ii; clarify; eapply no_phi_use_def; eauto. }
+          i. destruct (peq pc'0 pc').
+          { clarify. erewrite phi_store_spec_for_moves; eauto.
+            erewrite phi_store_spec_for_irrelevant; eauto. ii.
+            eapply no_phi_use_def'; eauto. }
+          { erewrite phi_store_spec_for_irrelevant; eauto.
+            erewrite phi_store_spec_for_irrelevant; eauto.
+            eapply PHIINV; eauto. eapply (@Dom.sdom_dom_pred node peq); eauto.
+            econstructor; eauto. econstructor; eauto.
+            ii. eapply no_phi_use_def'; eauto.
+            ii. eapply unique_def_spec_def. eauto. eauto.
+            econstructor 3; eauto. ii; clarify. }
+
+    - (* Iop *)
+      inv MATCH.
+      + exists (State st' (transf_function_step f) sp pc' rs' # res <- v m).
+        split. rewrite <- 2 H4. eapply exec_Iop; eauto.
+        erewrite eval_operation_wrapper_preserved; eauto.
+        eapply symbols_preserved; eauto. rewrite <- H4 at 1.
+        econstructor 1; eauto. eapply SSAinv.subj_red; eauto.
+        rewrite <-  H4 in *. econstructor; eauto.
+      + exploit transf_function_step_spec_simple; eauto. i. des.
+        exploit H3; eauto. i. clear H2 H3. 
+        destruct (classic (use_code f d pc)).
+        { eapply find_mv_exists in FOUND as PCDEFD. des.
+          assert (dom f pc0 pc). eapply fn_strict; eauto. econstructor; eauto.
+          exists (State st' (transf_function_step f) sp pc' rs' # res <- v m).
+          split.
+          - assert (remove_mv_instr d (Iop op args res pc') = Iop op args res pc').
+            unfold remove_mv_instr. destruct op; ss. flatten; ss.
+            rewrite Pos.eqb_eq in Eq; clarify; ss.
+            exfalso; eapply fn_use_def_code; eauto. rewrite H5 in H4. 
+            eapply exec_Iop; eauto. unfold subst_instr in H4.
+            assert (pc0 <> pc). ii; clarify.
+            inv H2; try rewrite PCDEFD in *; clarify. ss.
+            flatten H5; clarify. rewrite Pos.eqb_neq in Eq; clarify.
+            erewrite value_list_preserved_for_ds_eq.
+            erewrite eval_operation_wrapper_preserved; eauto.
+            eapply symbols_preserved; eauto. eauto.
+            eapply s_inv_eq_ds; eauto.
+            ii; clarify; exploit find_mv_not_same; eauto.
+          - econstructor; eauto. eapply SSAinv.subj_red; eauto.
+            econstructor; eauto. ii. destruct (peq r res).
+            clarify. rewrite 2 PMap.gss; eauto. rewrite 2 PMap.gso; eauto.  }
+        { destruct (classic (def f d pc)).
+          { exists (State st' (transf_function_step f) sp pc' rs' m).
+            eapply find_mv_exists in FOUND as FOUND'; eauto. des.
+            assert (def f d pc0). econstructor; eauto.
+            eapply def_def_eq in H5 as EQ. 3:{ eapply H3. } clarify; ss. split.
+            eapply exec_Inop_njp; eauto.
+            flatten H4; ss. rewrite Pos.eqb_neq in Eq; clarify.
+            rewrite <- join_point_transf_function_step. ii.
+            eapply fn_normalized in H; eauto. rewrite FOUND' in H; discriminate.
+            eapply successors_instr_succs in FOUND'. des; eauto.
+            unfold Kildall.successors_list; rewrite FOUND'. eauto. ss; eauto.
+            econstructor; eauto. eapply SSAinv.subj_red; eauto.
+            econstructor 2; eauto. ii.
+            rewrite PMap.gso; eauto. eauto. }
+          { exploit code_preserved_irrelevant; eauto. i. rewrite <- H5 in H4.
+            exists (State st' (transf_function_step f) sp pc' rs' # res <- v m).
+            split. eapply exec_Iop; eauto. erewrite eval_operation_wrapper_preserved.
+            erewrite <- value_list_preserved_for_equiv_regsets; eauto.
+            ii; eapply H2; econstructor; eauto.
+            eapply symbols_preserved; eauto.
+            econstructor; eauto. eapply SSAinv.subj_red; eauto.
+            econstructor; eauto. ii. destruct (peq r res).
+            clarify; rewrite 2 PMap.gss; eauto.
+            rewrite 2 PMap.gso; eauto. } }
+      + exists (State st' (transf_function_step f) sp pc' rs' # res <- v m).
+        exploit transf_function_step_spec_simple; eauto. i. des.
+        exploit H3; eauto. i; clear H2 H3. split.
+        destruct (classic (use_code f d pc)).
+        { assert (remove_mv_instr d (Iop op args res pc') = Iop op args res pc').
+          { unfold remove_mv_instr. flatten; ss. rewrite Pos.eqb_eq in Eq0; clarify.
+            eapply find_mv_phicode_exists in FOUND; des.
+            exfalso; eapply assigned_code_and_phi; eauto. } rewrite H3 in H4. clear H3.
+          eapply find_mv_phicode_exists in FOUND as PHIMOVE; des.
+          eapply exec_Iop; eauto. unfold subst_instr in H4.
+          erewrite value_list_preserved_for_ds_eq.
+          erewrite eval_operation_wrapper_preserved; eauto.
+          eapply symbols_preserved; eauto. eauto.
+          eapply PHIINV; eauto. rewrite forallb_forall in PHIMOVE1; i; eauto.
+          inv H3; eauto. eapply PHIMOVE1 in H5; rewrite Pos.eqb_eq in H5; eauto.
+          eapply fn_strict; eauto. econstructor; eauto.
+          ii; clarify; eapply no_phi_use_def; eauto.
+          ii; clarify; eapply no_phi_use_def; eauto. }
+        { eapply find_mv_phicode_exists in FOUND; eauto; des.
+          exploit code_preserved_irrelevant; eauto. ii.
+          exploit assigned_code_and_phi; eauto. i. rewrite <- H3 in H4.
+          eapply exec_Iop; eauto.
+          erewrite value_list_preserved_for_equiv_regsets.
+          erewrite eval_operation_wrapper_preserved; eauto.
+          eapply symbols_preserved; eauto. ii; erewrite EQUIV; eauto.
+          ii; eapply H2; eauto. econstructor; eauto. }
+        econstructor; eauto. eapply SSAinv.subj_red; eauto.
+        econstructor 3; eauto. ii.
+        destruct (peq r res);
+          clarify; [erewrite 2 PMap.gss | erewrite 2 PMap.gso]; eauto.
+        ii. destruct (peq d res); clarify.
+        exploit assigned_code_and_phi; eauto. i; ss.
+        destruct (peq s0 res); clarify.
+        exploit no_phi_use_def'; eauto; ss.
+        eapply (@Dom.sdom_dom_pred node peq); eauto. econstructor; eauto.
+        ii; clarify. exploit fn_normalized; eauto.
+        eapply fn_phicode_inv; eauto. ii; rewrite H2 in *; clarify.
+        unfold Kildall.successors_list, successors. rewrite PTree.gmap1.
+        rewrite H; ss; eauto. i; rewrite H in *; eauto; clarify.
+        econstructor; eauto. rewrite 2 PMap.gso; ss.
+        exploit PHIINV; eauto.
+        eapply (@Dom.sdom_dom_pred node peq); eauto. econstructor; eauto.
+        ii; clarify. exploit fn_normalized; eauto.
+        eapply fn_phicode_inv; eauto. ii; rewrite H2 in *; clarify.
+        unfold Kildall.successors_list, successors. rewrite PTree.gmap1.
+        rewrite H; ss; eauto. i; rewrite H in *; eauto; clarify.
+        econstructor; eauto.
+
+    - (* Iload *)
+      exists (State st' (transf_function_step f) sp pc' rs' # dst <- v m).
+      inv MATCH.
+      + rewrite <- H5 in *. exploit transf_function_step_spec_simple; eauto.
+        i; des. exploit H3; eauto. clear H3 H4. i. split.
+        eapply exec_Iload; eauto. erewrite eval_addressing_preserved; eauto.
+        eapply symbols_preserved.
+        econstructor 1; eauto. eapply SSAinv.subj_red; eauto.
+        rewrite <- H5; econstructor; eauto.
+      + exploit transf_function_step_spec_simple; eauto.
+        i; des. exploit H4; eauto. clear H3 H4. i.
+        eapply find_mv_exists in FOUND as TFCODE; des.
+        split. ss. eapply exec_Iload; eauto. erewrite eval_addressing_preserved.
+        destruct (classic (use_code f d pc)).
+        { erewrite value_list_preserved_for_ds_eq; eauto. inv SINV.
+          eapply s_inv_eq_ds; eauto.
+          exploit fn_strict; eauto. econstructor; eauto. ii. subst pc0.
+          rewrite H in *; clarify.
+          ii. exploit find_mv_not_same; eauto. }
+        { exploit code_preserved_irrelevant; eauto. ii.
+          exploit assigned_code_unique. eauto. eauto. econstructor. eapply TFCODE.
+          i; subst pc. rewrite TFCODE in *; clarify. i. ss. rewrite <- H5 in H3.
+          inv H5. rewrite <- 2 H7. erewrite value_list_preserved_for_equiv_regsets.
+          eauto. ii; rewrite EQUIV; eauto. ii; eapply H4; eauto using use_code. }
+        eapply symbols_preserved.
+        econstructor; eauto. eapply SSAinv.subj_red; eauto.
+        econstructor 2; eauto. ii.
+        destruct (peq r dst);
+          clarify; [erewrite 2 PMap.gss | erewrite 2 PMap.gso]; eauto.
+      + exploit transf_function_step_spec_simple; eauto.
+        i; des. exploit H4; eauto. clear H3 H4. i.
+        eapply find_mv_phicode_exists in FOUND as PHIMOVE; des.
+        split. destruct (classic (use_code f d pc)).
+        { ss. eapply exec_Iload; eauto.
+          erewrite value_list_preserved_for_ds_eq.
+          erewrite eval_addressing_preserved; eauto.
+          eapply symbols_preserved; eauto. eauto.
+          eapply PHIINV; eauto. rewrite forallb_forall in PHIMOVE1; i; eauto.
+          inv H5; eauto. eapply PHIMOVE1 in H6; rewrite Pos.eqb_eq in H6; eauto.
+          eapply fn_strict; eauto. econstructor; eauto.
+          ii; clarify; eapply no_phi_use_def; eauto.
+          ii; clarify; eapply no_phi_use_def; eauto. }
+        { exploit code_preserved_irrelevant; eauto. ii.
+          exploit assigned_code_and_phi; eauto. i. rewrite <- H5 in H3.
+          eapply exec_Iload; eauto.
+          erewrite value_list_preserved_for_equiv_regsets.
+          erewrite eval_addressing_preserved; eauto.
+          eapply symbols_preserved; eauto. ii; erewrite EQUIV; eauto.
+          ii; eapply H4; eauto using use_code. }
+        econstructor; eauto. eapply SSAinv.subj_red; eauto.
+        econstructor 3; eauto. ii.
+        destruct (peq r dst);
+          clarify; [erewrite 2 PMap.gss | erewrite 2 PMap.gso]; eauto.
+        ii. destruct (peq d dst); clarify.
+        exploit assigned_code_and_phi; eauto. i; ss.
+        assert (pc' <> pc'0).
+        { ii; clarify. exploit fn_normalized; eauto.
+          eapply fn_phicode_inv; eauto. ii; rewrite H4 in *; clarify.
+          unfold Kildall.successors_list, successors. rewrite PTree.gmap1.
+          rewrite H; ss; eauto. i; rewrite H in *; eauto; clarify. }
+        destruct (peq s0 dst); clarify.
+        exploit no_phi_use_def'; eauto; ss.
+        eapply (@Dom.sdom_dom_pred node peq); eauto.
+        econstructor; eauto. econstructor; eauto.
+        rewrite 2 PMap.gso; eauto.
+        exploit PHIINV; eauto. eapply (@Dom.sdom_dom_pred node peq); eauto.
+        econstructor; eauto. econstructor; eauto.
+    
+    - (* Istore *)
+      exists (State st' (transf_function_step f) sp pc' rs' m').
+      inv MATCH.
+      + rewrite <- H5 in *. split.
+        eapply exec_Istore; eauto. rewrite <- H5; eauto.
+        erewrite eval_addressing_preserved; eauto. eapply symbols_preserved.
+        econstructor; eauto. eapply SSAinv.subj_red; eauto.
+        rewrite <- H5. econstructor; eauto.
+      + exploit transf_function_step_spec_simple; eauto.
+        i; des. exploit H4; eauto. clear H3 H4. i.
+        eapply find_mv_exists in FOUND as TFCODE; des.
+        destruct (classic (use_code f d pc)).
+        { split. ss. eapply exec_Istore; eauto. erewrite eval_addressing_preserved.
+          erewrite value_list_preserved_for_ds_eq; eauto.
+          eapply s_inv_eq_ds; eauto.
+          exploit fn_strict; eauto. econstructor; eauto. ii. subst pc0.
+          rewrite H in *; clarify.
+          ii. exploit find_mv_not_same; eauto. eapply symbols_preserved.
+          destruct (peq src d); ss.
+          - clarify. unfold rename_reg; flatten. rewrite <- EQUIV.
+            erewrite <- s_inv_eq_ds; eauto.
+            exploit fn_strict; eauto. econstructor; eauto.
+            ii; subst pc. rewrite H in *; clarify.
+            ii; exploit find_mv_not_same; eauto.
+            rewrite Pos.eqb_neq in Eq; clarify.
+          - unfold rename_reg; flatten; ss. rewrite Pos.eqb_eq in Eq; clarify.
+            rewrite <- EQUIV; ss.
+          - econstructor; eauto. eapply SSAinv.subj_red; eauto. econstructor; eauto. }
+        { exploit code_preserved_irrelevant; eauto. ii.
+          exploit assigned_code_unique. eauto. eauto. econstructor. eapply TFCODE.
+          i; subst pc. rewrite TFCODE in *; clarify. i. ss. rewrite <- H5 in H3.
+          split. eapply exec_Istore; eauto. erewrite eval_addressing_preserved.
+          erewrite value_list_preserved_for_equiv_regsets; eauto.
+          ii; rewrite EQUIV; eauto. ii; eapply H4; eauto using use_code.
+          eapply symbols_preserved. rewrite <- EQUIV; eauto. ii; clarify.
+          eapply H4; eauto using use_code.
+          econstructor; eauto. eapply SSAinv.subj_red; eauto.
+          econstructor 2; eauto. }
+      + exploit transf_function_step_spec_simple; eauto.
+        i; des. exploit H4; eauto. clear H3 H4. i.
+        eapply find_mv_phicode_exists in FOUND as PHIMOVE; des.
+        split. destruct (classic (use_code f d pc)).
+        { ss. eapply exec_Istore; eauto.
+          erewrite value_list_preserved_for_ds_eq.
+          erewrite eval_addressing_preserved; eauto.
+          eapply symbols_preserved; eauto. eauto.
+          eapply PHIINV; eauto. rewrite forallb_forall in PHIMOVE1; i; eauto.
+          inv H5; eauto. eapply PHIMOVE1 in H6; rewrite Pos.eqb_eq in H6; eauto.
+          eapply fn_strict; eauto. econstructor; eauto.
+          ii; clarify; eapply no_phi_use_def; eauto.
+          ii; clarify; eapply no_phi_use_def; eauto.
+          destruct (peq src d).
+          { clarify. unfold rename_reg. flatten; ss. rewrite <- EQUIV; eauto.
+            exploit PHIINV; eauto. i. inv H5; ss. rewrite forallb_forall in PHIMOVE1.
+            eapply PHIMOVE1 in H6; rewrite Pos.eqb_eq in H6; eauto.
+            exploit fn_strict; eauto. econstructor; eauto.
+            ii; clarify; exploit no_phi_use_def; eauto.
+            intros ds; rewrite <- ds; eauto.
+            ii; clarify; exploit no_phi_use_def; eauto.
+            rewrite Pos.eqb_neq in Eq; clarify. }
+          { unfold rename_reg. flatten; ss. rewrite Pos.eqb_eq in Eq; clarify.
+            rewrite <- EQUIV; eauto. } }
+        { exploit code_preserved_irrelevant; eauto. ii.
+          exploit assigned_code_and_phi; eauto. i. rewrite <- H5 in H3. clear H5.
+          eapply exec_Istore; eauto.
+          erewrite value_list_preserved_for_equiv_regsets.
+          erewrite eval_addressing_preserved; eauto.
+          eapply symbols_preserved; eauto. ii; erewrite EQUIV; eauto.
+          ii; eapply H4; eauto using use_code.
+          rewrite <- EQUIV; eauto. ii; clarify; eapply H4; eauto using use_code. }
+        econstructor; eauto. eapply SSAinv.subj_red; eauto.
+        econstructor 3; eauto. ii.
+        assert (pc' <> pc'0).
+        { ii; clarify. exploit fn_normalized; eauto.
+          eapply fn_phicode_inv; eauto. ii; rewrite H4 in *; clarify.
+          unfold Kildall.successors_list, successors. rewrite PTree.gmap1.
+          rewrite H; ss; eauto. i; rewrite H in *; eauto; clarify. }
+        exploit PHIINV; eauto. eapply (@Dom.sdom_dom_pred node peq); eauto.
+        econstructor; eauto. econstructor; eauto.
+
+    - (* Icall *)
+      inv MATCH.
+      + exists (Callstate (Stackframe res (transf_function_step f) sp pc' rs' :: st')
+                        (transf_fundef_step fd) rs' ## args m).
+        rewrite <- H4 in *. split.
+        * rewrite <- H4. eapply exec_Icall; eauto.
+          erewrite find_function_translated; eauto. eapply sig_preserved.
+        * econstructor; eauto. eapply SSAinv.subj_red; eauto. rewrite H4 at 2.
+          econstructor; eauto. rewrite <- H4 in *; econstructor; eauto.
+      + exploit transf_function_step_spec_simple; eauto.
+        i; des. exploit H3; eauto. clear H1 H3. i.
+        eapply find_mv_exists in FOUND as TFCODE; des. ss.
+        exists (Callstate (Stackframe res (transf_function_step f) sp pc' rs' :: st')
+                          (transf_fundef_step fd)
+                          rs' ## (map (rename_reg d s0) args) m). 
+        destruct (classic (use_code f d pc)).
+        { split. eapply exec_Icall; eauto.
+          erewrite find_function_translated; eauto.
+          { destruct ros.
+            - destruct (peq d r).
+              + clarify. unfold rename_fn, rename_reg in *. rewrite Pos.eqb_refl in *.
+                simpl ros_to_vos in *.
+                repeat rewrite <- EQUIV; eauto.
+                erewrite <- s_inv_eq_ds; eauto.
+                exploit fn_strict; eauto. econstructor; eauto.
+                ii; subst pc0. rewrite H in *; clarify.
+                ii; clarify; exploit find_mv_not_same; eauto.
+                ii; clarify; exploit find_mv_not_same; eauto.
+              + unfold rename_fn, rename_reg. flatten.
+                * eapply Pos.eqb_eq in Eq; clarify.
+                * simpl ros_to_vos in *.
+                  repeat rewrite <- EQUIV; eauto.
+            - ss. }
+          eapply sig_preserved.
+          erewrite value_list_preserved_for_ds_eq. econstructor 2; eauto.
+          eapply SSAinv.subj_red; eauto. econstructor; eauto.
+          econstructor 2; eauto. eauto. eapply s_inv_eq_ds; eauto.
+          exploit fn_strict; eauto. econstructor; eauto.
+          ii; subst pc0; clarify. ii; exploit find_mv_not_same; eauto. }
+        { split. eapply exec_Icall; eauto.
+          erewrite find_function_translated; eauto.
+          { destruct ros.
+            - destruct (peq d r).
+              + clarify. exploit H3; eauto using use_code; ss.
+              + unfold rename_fn, rename_reg. flatten.
+                * eapply Pos.eqb_eq in Eq; clarify.
+                * simpl ros_to_vos in *.
+                  repeat rewrite <- EQUIV; eauto.
+            - ss. }
+          eapply sig_preserved.
+          exploit code_preserved_irrelevant; eauto. ii.
+          exploit assigned_code_unique. eauto. eauto. econstructor. eauto.
+          ii; subst pc0. clarify. i. ss. inv H4. rewrite <- 2 H7.
+          exploit value_list_preserved_for_equiv_regsets; eauto.
+          2:{ i. rewrite <- H4. econstructor 2; eauto.
+              eapply SSAinv.subj_red; eauto. econstructor; eauto.
+              econstructor 2; eauto. }
+          ii. destruct ros; eapply H3; eauto using use_code. }
+      + exploit transf_function_step_spec_simple; eauto; i; des.
+        exploit H3; eauto; i. clear H1 H3. ss.
+        exists (Callstate (Stackframe res (transf_function_step f) sp pc' rs' :: st')
+                          (transf_fundef_step fd)
+                          rs' ## (map (rename_reg d s0) args) m).
+        eapply find_mv_phicode_exists in FOUND as MVPHI; des.
+        destruct (classic (use_code f d pc)).
+        * split. eapply exec_Icall; eauto. erewrite find_function_translated; eauto.
+          destruct ros.
+          { destruct (peq d r).
+            - clarify. unfold rename_fn, rename_reg in *. rewrite Pos.eqb_refl in *.
+              simpl ros_to_vos in *.
+              repeat rewrite <- EQUIV; eauto.
+              erewrite <- PHIINV; eauto. i. inv H3; eauto.
+              rewrite forallb_forall in MVPHI1; eapply MVPHI1 in H5.
+              rewrite Pos.eqb_eq in H5; clarify.
+              exploit fn_strict; eauto. econstructor; eauto.
+              all : ii; clarify; exploit no_phi_use_def; eauto.
+            - unfold rename_fn, rename_reg. flatten.
+              + eapply Pos.eqb_eq in Eq; clarify.
+              + simpl ros_to_vos in *. repeat rewrite <- EQUIV; eauto. }
+            { ss. }
+            eapply sig_preserved.
+            assert (rs # d = rs # s0).
+            { eapply PHIINV; eauto. ii. inv H3; ss. rewrite forallb_forall in MVPHI1.
+              eapply MVPHI1 in H5; rewrite Pos.eqb_eq in H5; clarify.
+              exploit fn_strict; eauto. econstructor; eauto.
+              ii; clarify; exploit no_phi_use_def; eauto. }
+            erewrite value_list_preserved_for_ds_eq; eauto.
+            econstructor; eauto. eapply SSAinv.subj_red; eauto.
+            econstructor; eauto. econstructor 3; eauto.
+            ii; clarify; exploit no_phi_use_def; eauto.
+        * split.
+          { eapply exec_Icall; eauto. erewrite find_function_translated; eauto.
+            destruct ros.
+            - destruct (peq d r).
+              + clarify. exploit H1; eauto using use_code; ss.
+              + unfold rename_fn, rename_reg. flatten.
+                * eapply Pos.eqb_eq in Eq; clarify.
+                * simpl ros_to_vos in *.
+                  repeat rewrite <- EQUIV; eauto.
+            - ss.
+            - eapply sig_preserved. }
+          { exploit code_preserved_irrelevant; eauto. ii.
+            exploit assigned_code_and_phi; eauto. ii. inv H3; ss. rewrite <- 2 H7.
+            exploit value_list_preserved_for_equiv_regsets; eauto.
+            2:{ i. rewrite <- H3. econstructor; eauto.
+                eapply SSAinv.subj_red; eauto. econstructor; eauto.
+                econstructor 3; eauto. ii. exploit PHIINV; eauto.
+                eapply (@Dom.sdom_dom_pred node peq); eauto.
+                econstructor; eauto. ii; subst pc'0.
+                exploit fn_normalized; eauto. exploit fn_phicode_inv; eauto.
+                i. rewrite H12. ii. rewrite H13 in H5; clarify.
+                unfold Kildall.successors_list, successors. rewrite PTree.gmap1.
+                rewrite H; ss. left; ss. i; clarify. econstructor; eauto. }
+            ii; eapply H1. destruct ros; eauto using use_code. }
+    
+    - (* Itailcall *)
+      inv MATCH.
+      + exists (Callstate st' (transf_fundef_step fd) rs' ## args m').
+        rewrite <- H5 in *. split.
+        * rewrite <- H5. eapply exec_Itailcall; eauto.
+          erewrite find_function_translated; eauto. eapply sig_preserved.
+        * econstructor; eauto. eapply SSAinv.subj_red; eauto.
+      + exploit transf_function_step_spec_simple; eauto.
+        i; des. exploit H4; eauto. clear H1 H4. i.
+        eapply find_mv_exists in FOUND as TFCODE; des. ss.
+        exists (Callstate st' (transf_fundef_step fd)
+                          rs' ## (map (rename_reg d s0) args) m').
+        destruct (classic (use_code f d pc)).
+        { split. eapply exec_Itailcall; eauto.
+          erewrite find_function_translated; eauto.
+          { destruct ros.
+            - destruct (peq d r).
+              + clarify. unfold rename_fn, rename_reg in *. rewrite Pos.eqb_refl in *.
+                simpl ros_to_vos in *.
+                repeat rewrite <- EQUIV; eauto.
+                erewrite <- s_inv_eq_ds; eauto.
+                exploit fn_strict; eauto. econstructor; eauto.
+                ii; subst pc0. rewrite H in *; clarify.
+                all: ii; clarify; exploit find_mv_not_same; eauto.
+              + unfold rename_fn, rename_reg. flatten.
+                * eapply Pos.eqb_eq in Eq; clarify.
+                * simpl ros_to_vos in *.
+                  repeat rewrite <- EQUIV; eauto.
+            - ss. }
+          eapply sig_preserved.
+          unfold transf_function_step, transf_function_fuel. flatten; ss.
+          erewrite value_list_preserved_for_ds_eq; eauto. econstructor 2; eauto.
+          eapply SSAinv.subj_red; eauto. eapply s_inv_eq_ds; eauto.
+          exploit fn_strict; eauto. econstructor; eauto.
+          ii; subst pc0; clarify. ii; exploit find_mv_not_same; eauto. }
+        { split. eapply exec_Itailcall; eauto.
+          erewrite find_function_translated; eauto.
+          { destruct ros.
+            - destruct (peq d r).
+              + clarify. exploit H4; eauto using use_code; ss.
+              + unfold rename_fn, rename_reg. flatten.
+                * eapply Pos.eqb_eq in Eq; clarify.
+                * simpl ros_to_vos in *.
+                  repeat rewrite <- EQUIV; eauto.
+            - ss. }
+          eapply sig_preserved.
+          unfold transf_function_step, transf_function_fuel; flatten; ss.
+          exploit code_preserved_irrelevant; eauto. ii.
+          exploit assigned_code_unique. eauto. eauto. econstructor. eauto.
+          ii; subst pc0. clarify. i. ss. inv H5. rewrite <- 2 H8.
+          erewrite value_list_preserved_for_equiv_regsets; eauto. econstructor 2; eauto.
+          eapply SSAinv.subj_red; eauto.
+          erewrite <- value_list_preserved_for_equiv_regsets; eauto.
+          all: ii; destruct ros; eapply H4; eauto using use_code. }
+      + exploit transf_function_step_spec_simple; eauto; i; des.
+        exploit H4; eauto; i. clear H1 H4. ss.
+        exists (Callstate st' (transf_fundef_step fd)
+                          rs' ## (map (rename_reg d s0) args) m').
+        eapply find_mv_phicode_exists in FOUND as MVPHI; des.
+        destruct (classic (use_code f d pc)).
+        * split. eapply exec_Itailcall; eauto.
+          erewrite find_function_translated; eauto.
+          { destruct ros.
+            - destruct (peq d r).
+              + clarify. unfold rename_fn, rename_reg in *. rewrite Pos.eqb_refl in *.
+                simpl ros_to_vos in *.
+                repeat rewrite <- EQUIV; eauto.
+                erewrite <- PHIINV; eauto. i. inv H4; eauto.
+                rewrite forallb_forall in MVPHI1; eapply MVPHI1 in H6.
+                rewrite Pos.eqb_eq in H6; clarify.
+                exploit fn_strict; eauto. econstructor; eauto.
+                all : ii; clarify; exploit no_phi_use_def; eauto.
+              + unfold rename_fn, rename_reg. flatten.
+                * eapply Pos.eqb_eq in Eq; clarify.
+                * simpl ros_to_vos in *. repeat rewrite <- EQUIV; eauto.
+            - ss. }
+          eapply sig_preserved.
+          unfold transf_function_step, transf_function_fuel. flatten; ss.
+          erewrite value_list_preserved_for_ds_eq; eauto. econstructor 2; eauto.
+          eapply SSAinv.subj_red; eauto.
+          
+          eapply PHIINV; eauto. ii. inv H4; ss. rewrite forallb_forall in MVPHI1.
+          eapply MVPHI1 in H6; rewrite Pos.eqb_eq in H6; clarify.
+          exploit fn_strict; eauto. econstructor; eauto.
+          all : ii; clarify; exploit no_phi_use_def; eauto.
+        * split.
+          { eapply exec_Itailcall; eauto. erewrite find_function_translated; eauto.
+            destruct ros.
+            - destruct (peq d r).
+              + clarify. exploit H1; eauto using use_code; ss.
+              + unfold rename_fn, rename_reg. flatten.
+                * eapply Pos.eqb_eq in Eq; clarify.
+                * simpl ros_to_vos in *.
+                  repeat rewrite <- EQUIV; eauto.
+            - ss.
+            - eapply sig_preserved.
+            - unfold transf_function_step, transf_function_fuel; flatten; ss. }
+          { exploit code_preserved_irrelevant; eauto. ii.
+            exploit assigned_code_and_phi; eauto. ii. inv H4; ss. rewrite <- 2 H8.
+            exploit value_list_preserved_for_equiv_regsets; eauto.
+            2:{ i. rewrite <- H4. econstructor; eauto.
+                eapply SSAinv.subj_red; eauto. }
+            ii; eapply H1. destruct ros; eauto using use_code. }
+      
+    - (* Ibuiltin *)
+      exists (State st' (transf_function_step f) sp pc'
+                    (regmap_setres res vres rs') m').
+      inv MATCH.
+      + rewrite <- H5 in *. split.
+        * rewrite <- H5. eapply exec_Ibuiltin; eauto.
+          eapply eval_builtin_args_preserved. eapply symbols_preserved.
+          eapply H0. eapply external_call_symbols_preserved; eauto.
+          eapply senv_equiv.
+        * econstructor; eauto. eapply SSAinv.subj_red; eauto.
+          rewrite <- H5. econstructor; eauto.
+      + exploit transf_function_step_spec_simple; eauto; i; des.
+        exploit H4; eauto; i. clear H3 H4. ss.
+        eapply find_mv_exists in FOUND as MVCODE; des. split.
+        * eapply exec_Ibuiltin; eauto.
+          2:{ eapply external_call_symbols_preserved. eapply senv_equiv.
+              eapply H1. }
+          destruct (classic (use_code f d pc)).
+          { eapply eval_builtin_args_preserved_for_ds_eq; eauto.
+            ii; exploit find_mv_not_same; eauto. exploit s_inv_eq_ds; eauto.
+            exploit fn_strict; eauto. econstructor; eauto.
+            ii; subst pc0; ss. clarify. }
+          { eapply eval_builtin_args_preserved_for_equiv_regset; eauto.
+            ii; eapply H3; eauto using use_code.
+            ii; exploit find_mv_not_same; eauto. }
+        * econstructor; eauto. eapply SSAinv.subj_red; eauto.
+          econstructor 2; eauto. destruct res; ss. ii.
+          destruct (peq r x).
+          { clarify. rewrite 2 PMap.gss; eauto. }
+          { rewrite 2 PMap.gso; eauto. }
+      + exploit transf_function_step_spec_simple; eauto; i; des.
+        exploit H4; eauto; i. clear H3 H4. ss.
+        eapply find_mv_phicode_exists in FOUND as MVPHI; des. split.
+        * destruct (classic (use_code f d pc)).
+          { eapply exec_Ibuiltin; eauto.
+            eapply eval_builtin_args_preserved_for_ds_eq; eauto.
+            ii; clarify; exploit no_phi_use_def; eauto.
+            exploit PHIINV; eauto. ii. inv H4; ss. rewrite forallb_forall in MVPHI1.
+            eapply MVPHI1 in H6; rewrite Pos.eqb_eq in H6; clarify; ss.
+            exploit fn_strict; eauto. econstructor; eauto.
+            ii; clarify; exploit no_phi_use_def; eauto.
+            eapply external_call_symbols_preserved; eauto. eapply senv_equiv; eauto. }
+          { eapply exec_Ibuiltin; eauto.
+            eapply eval_builtin_args_preserved_for_equiv_regset; eauto.
+            ii; eapply H3; eauto using use_code.
+            ii; clarify; exploit no_phi_use_def; eauto.
+            eapply external_call_symbols_preserved; eauto. eapply senv_equiv; eauto. }
+        * econstructor; eauto. eapply SSAinv.subj_red; eauto.
+          econstructor 3; eauto. destruct res; ss. ii.
+          destruct (peq r x).
+          { clarify. rewrite 2 PMap.gss; eauto. } { rewrite 2 PMap.gso; eauto. }
+          ii. assert (dom f pc'0 pc).
+          { eapply (@Dom.sdom_dom_pred node peq); eauto. econstructor; eauto.
+            ii; subst pc'0. exploit fn_normalized; eauto. exploit fn_phicode_inv; eauto.
+            intros JF; rewrite JF. ii. rewrite H9 in H3; clarify.
+            unfold Kildall.successors_list, successors. rewrite PTree.gmap1.
+            rewrite H; ss. eauto. i; clarify. econstructor; eauto. }
+          ii. destruct res; ss. destruct (peq x d).
+          { clarify. exploit assigned_code_and_phi; eauto; ss. }
+          destruct (peq x s0).
+          { clarify. exploit no_phi_use_def'; eauto. ss. }
+          rewrite 2 PMap.gso; eauto.
+          exploit PHIINV; eauto. exploit PHIINV; eauto.
+
+    - (* Icond, true *)
+      exists (State st' (transf_function_step f) sp ifso rs' m).
+      split.
+      + inv MATCH.
+        * rewrite <- H4 in *. eapply exec_Icond_true; eauto. rewrite <- H4; eauto.
+        * exploit transf_function_step_spec_simple; eauto.
+          i; des. exploit H3; eauto; i; ss. clear H2 H3.
+          eapply find_mv_exists in FOUND as MVCODE; des.
+          assert (pc <> pc0).
+          { ii; subst pc0. clarify. }
+          eapply exec_Icond_true; eauto.
+          destruct (classic (use_code f d pc)).
+          { erewrite value_list_preserved_for_ds_eq; eauto.
+            exploit s_inv_eq_ds; eauto. exploit fn_strict; eauto. econstructor; eauto.
+            ii; exploit find_mv_not_same; eauto. }
+          { exploit code_preserved_irrelevant; eauto. ii. exploit assigned_code_unique.
+            eauto. eauto. econstructor; eauto. ss.
+            i. inv H5. rewrite <- 2 H7.
+            erewrite value_list_preserved_for_equiv_regsets; eauto.
+            ii; rewrite EQUIV; eauto.
+            ii; eapply H3; eauto using use_code. }
+        * exploit transf_function_step_spec_simple; eauto.
+          i; des; exploit H3; eauto; i; ss; clear H2 H3.
+          eapply find_mv_phicode_exists in FOUND as MVPHI; des.
+          eapply exec_Icond_true; eauto.
+          destruct (classic (use_code f d pc)).
+          { erewrite value_list_preserved_for_ds_eq; eauto.
+            exploit PHIINV; eauto. i. inv H3; ss. rewrite forallb_forall in MVPHI1.
+            eapply MVPHI1 in H5; rewrite Pos.eqb_eq in H5; clarify.
+            exploit fn_strict; eauto. econstructor; eauto.
+            ii; clarify; exploit no_phi_use_def; eauto. 
+            ii; clarify; exploit no_phi_use_def; eauto. }
+          { exploit code_preserved_irrelevant; eauto. ii.
+            exploit assigned_code_and_phi; eauto.
+            i. inv H3. rewrite <- 2 H6.
+            erewrite value_list_preserved_for_equiv_regsets; eauto.
+            ii; rewrite EQUIV; eauto.
+            ii; eapply H2; eauto using use_code. }
+      + econstructor; eauto. eapply SSAinv.subj_red; eauto.
+        inv MATCH.
+        * rewrite <- 2 H4 in *. econstructor; eauto.
+        * econstructor 2; eauto.
+        * econstructor 3; eauto. ii.
+          exploit PHIINV; eauto. eapply (@Dom.sdom_dom_pred node peq); eauto.
+          econstructor; eauto. ii; subst ifso. exploit fn_normalized; eauto.
+          exploit fn_phicode_inv; eauto.
+          intros JF; rewrite JF; intros PHI; rewrite PHI in *; clarify.
+          unfold Kildall.successors_list, successors. rewrite PTree.gmap1.
+          rewrite H; ss. eauto. i; clarify. econstructor; eauto.
+      
+    - (* Icond, false *)
+      exists (State st' (transf_function_step f) sp ifnot rs' m).
+      split.
+      + inv MATCH.
+        * rewrite <- H4 in *. eapply exec_Icond_false; eauto. rewrite <- H4; eauto.
+        * exploit transf_function_step_spec_simple; eauto.
+          i; des. exploit H3; eauto; i; ss. clear H2 H3.
+          eapply find_mv_exists in FOUND as MVCODE; des.
+          assert (pc <> pc0).
+          { ii; subst pc0. clarify. }
+          eapply exec_Icond_false; eauto.
+          destruct (classic (use_code f d pc)).
+          { erewrite value_list_preserved_for_ds_eq; eauto.
+            exploit s_inv_eq_ds; eauto. exploit fn_strict; eauto. econstructor; eauto.
+            ii; exploit find_mv_not_same; eauto. }
+          { exploit code_preserved_irrelevant; eauto. ii. exploit assigned_code_unique.
+            eauto. eauto. econstructor; eauto. ss.
+            i. inv H5. rewrite <- 2 H7.
+            erewrite value_list_preserved_for_equiv_regsets; eauto.
+            ii; rewrite EQUIV; eauto.
+            ii; eapply H3; eauto using use_code. }
+        * exploit transf_function_step_spec_simple; eauto.
+          i; des; exploit H3; eauto; i; ss; clear H2 H3.
+          eapply find_mv_phicode_exists in FOUND as MVPHI; des.
+          eapply exec_Icond_false; eauto.
+          destruct (classic (use_code f d pc)).
+          { erewrite value_list_preserved_for_ds_eq; eauto.
+            exploit PHIINV; eauto. i. inv H3; ss. rewrite forallb_forall in MVPHI1.
+            eapply MVPHI1 in H5; rewrite Pos.eqb_eq in H5; clarify.
+            exploit fn_strict; eauto. econstructor; eauto.
+            ii; clarify; exploit no_phi_use_def; eauto. 
+            ii; clarify; exploit no_phi_use_def; eauto. }
+          { exploit code_preserved_irrelevant; eauto. ii.
+            exploit assigned_code_and_phi; eauto.
+            i. inv H3. rewrite <- 2 H6.
+            erewrite value_list_preserved_for_equiv_regsets; eauto.
+            ii; rewrite EQUIV; eauto.
+            ii; eapply H2; eauto using use_code. }
+      + econstructor; eauto. eapply SSAinv.subj_red; eauto.
+        inv MATCH.
+        * rewrite <- 2 H4 in *. econstructor; eauto.
+        * econstructor 2; eauto.
+        * econstructor 3; eauto. ii.
+          exploit PHIINV; eauto. eapply (@Dom.sdom_dom_pred node peq); eauto.
+          econstructor; eauto. ii; subst ifnot. exploit fn_normalized; eauto.
+          exploit fn_phicode_inv; eauto.
+          intros JF; rewrite JF; intros PHI; rewrite PHI in *; clarify.
+          unfold Kildall.successors_list, successors. rewrite PTree.gmap1.
+          rewrite H; ss. eauto. i; clarify. econstructor; eauto.
+
+    - (* Ijumptable *)
+      exists (State st' (transf_function_step f) sp pc' rs' m).
+      split.
+      + inv MATCH.
+        * rewrite <- 2 H5 in *. eapply exec_Ijumptable; eauto.
+        * eapply find_mv_exists in FOUND as MVCODE; des.
+          exploit transf_function_step_spec_simple. eapply H. i; des.
+          exploit H4; eauto; i; ss; clear H3 H4.
+          destruct (classic (use_code f d pc)).
+          { eapply exec_Ijumptable; eauto. destruct (peq d arg).
+            { clarify. unfold rename_reg; flatten; ss.
+              - rewrite <- EQUIV; eauto.
+                exploit s_inv_eq_ds; eauto. exploit fn_strict; eauto.
+                econstructor; eauto.
+                ii; subst pc0; clarify. i. rewrite <- H4; ss.
+                ii; exploit find_mv_not_same; eauto.
+              - rewrite Pos.eqb_neq in Eq; clarify.  }
+            { unfold rename_reg; flatten.
+              - rewrite Pos.eqb_eq in Eq; clarify.
+              - rewrite <- EQUIV; eauto. } }
+          { eapply exec_Ijumptable; eauto. unfold rename_reg; flatten.
+            - rewrite Pos.eqb_eq in Eq; clarify. exfalso; eapply H3; eauto using use_code.
+            - rewrite Pos.eqb_neq in Eq. rewrite <- EQUIV; eauto. }
+        * exploit transf_function_step_spec_simple; eauto.
+          i; des; exploit H4; eauto; i; ss; clear H3 H4.
+          eapply find_mv_phicode_exists in FOUND as MVPHI; des.
+          eapply exec_Ijumptable; eauto.
+          destruct (classic (use_code f d pc)).
+          { destruct (peq d arg).
+            { clarify. unfold rename_reg; flatten; ss.
+              - rewrite <- EQUIV; eauto.
+                exploit PHIINV; eauto. i. inv H4; ss. rewrite forallb_forall in MVPHI1.
+                eapply MVPHI1 in H6; rewrite Pos.eqb_eq in H6; clarify.
+                exploit fn_strict; eauto. econstructor; eauto.
+                ii; clarify; exploit no_phi_use_def; eauto. i; rewrite <- H4; ss.
+                ii; clarify; exploit no_phi_use_def; eauto.
+              - rewrite Pos.eqb_neq in Eq; clarify.  }
+            { unfold rename_reg; flatten.
+              - rewrite Pos.eqb_eq in Eq; clarify.
+              - rewrite <- EQUIV; eauto. } }
+          { exploit code_preserved_irrelevant; eauto. ii.
+            exploit assigned_code_and_phi; eauto.
+            i. inv H4. rewrite <- 2 H7. rewrite <- EQUIV; eauto.
+            ii; clarify; eapply H3; eauto using use_code. }
+      + econstructor; eauto. eapply SSAinv.subj_red; eauto.
+        inv MATCH.
+        * rewrite <- 2 H5 in *. econstructor; eauto.
+        * econstructor 2; eauto.
+        * econstructor 3; eauto. ii.
+          exploit PHIINV; eauto. eapply (@Dom.sdom_dom_pred node peq); eauto.
+          econstructor; eauto. ii; subst pc'0. exploit fn_normalized; eauto.
+          exploit fn_phicode_inv; eauto.
+          intros JF; rewrite JF; intros PHI; rewrite PHI in *; clarify.
+          unfold Kildall.successors_list, successors. rewrite PTree.gmap1.
+          rewrite H; ss. eapply list_nth_z_in; eauto. i; clarify. econstructor; eauto.
+          ss. eapply list_nth_z_in; eauto.
+          
+    - (* Ireturn *)
+      inv MATCH.
+      + exists (Returnstate st' (regmap_optget or Vundef rs') m').
+        rewrite <- 2 H4 in *. split.
+        * eapply exec_Ireturn; eauto.
+        * econstructor; eauto. eapply SSAinv.subj_red; eauto.
+      + eapply find_mv_exists in FOUND as MVCODE; des.
+        exploit transf_function_step_spec_simple. eapply H. eauto; i; des.
+        exploit H3; eauto; i; ss; clear H2 H3.
+        exists (Returnstate st'
+                            (regmap_optget (option_map (rename_reg d s0) or) Vundef rs')
+                            m').
+        split.
+        * eapply exec_Ireturn; eauto.
+          unfold transf_function_step, transf_function_fuel; flatten; ss.
+        * destruct or; ss.
+          { destruct (classic (use_code f d pc)).
+            { inv H2; clarify. unfold rename_reg; flatten; ss.
+              exploit s_inv_eq_ds; eauto. exploit fn_strict; eauto.
+              econstructor; eauto using use_code.
+              ii; subst pc0; clarify. i. rewrite <- EQUIV. rewrite <- H.
+              econstructor; eauto. eapply SSAinv.subj_red; eauto.
+              ii; clarify; exploit find_mv_not_same; eauto.
+              rewrite Pos.eqb_neq in Eq; clarify. }
+            { unfold rename_reg; flatten; ss.
+              - rewrite Pos.eqb_eq in Eq; clarify; exfalso;
+                  eapply H2; eauto using use_code.
+              - rewrite Pos.eqb_neq in Eq. rewrite <- EQUIV; eauto.
+                econstructor; eauto. eapply SSAinv.subj_red; eauto. } }
+          { econstructor; eauto. eapply SSAinv.subj_red; eauto. }
+      + eapply find_mv_phicode_exists in FOUND as MVPHI; des.
+        exploit transf_function_step_spec_simple. eapply H. eauto; i; des.
+        exploit H3; eauto; i; ss; clear H2 H3.
+        exists (Returnstate st'
+                            (regmap_optget (option_map (rename_reg d s0) or) Vundef rs')
+                            m').
+        split.
+        * eapply exec_Ireturn; eauto.
+          unfold transf_function_step, transf_function_fuel; flatten; ss.
+        * destruct or; ss.
+          { destruct (classic (use_code f d pc)).
+            { inv H2; clarify. unfold rename_reg; flatten; ss.
+              exploit PHIINV; eauto. i. inv H; ss. rewrite forallb_forall in MVPHI1.
+              eapply MVPHI1 in H2; rewrite Pos.eqb_eq in H2; clarify.
+              exploit fn_strict; eauto. econstructor; eauto using use_code.
+              ii; clarify; exploit no_phi_use_def; eauto.
+              i. rewrite <- EQUIV. rewrite <- H. econstructor; eauto.
+              eapply SSAinv.subj_red; eauto. ii; clarify; exploit no_phi_use_def; eauto.
+              rewrite Pos.eqb_neq in Eq; clarify. }
+            { unfold rename_reg; flatten; ss.
+              - rewrite Pos.eqb_eq in Eq; clarify; exfalso;
+                  eapply H2; eauto using use_code.
+              - rewrite Pos.eqb_neq in Eq. rewrite <- EQUIV; eauto.
+                econstructor; eauto. eapply SSAinv.subj_red; eauto. } }
+          { econstructor; eauto. eapply SSAinv.subj_red; eauto. }
+
+    - (* internal *)
+      ss.
+      exists (State st (transf_function_step f) (Vptr stk Ptrofs.zero)
+                    (fn_entrypoint (transf_function_step f))
+                    (init_regs args (fn_params (transf_function_step f))) m').
+      split.
+      + eapply exec_function_internal; eauto.
+        unfold transf_function_step, transf_function_fuel; flatten; ss.
+      + assert (fn_entrypoint (transf_function_step f) = fn_entrypoint f).
+        { unfold transf_function_step, transf_function_fuel; flatten; ss. }
+        assert (fn_params (transf_function_step f) = fn_params f).
+        { unfold transf_function_step, transf_function_fuel; flatten; ss. }
+        rewrite H1, H2. clear H1 H2. econstructor; eauto.
+        eapply SSAinv.subj_red; eauto.
+        assert (transf_function_step f = transf_function_step f) by auto.
+        unfold transf_function_step at 2 in H1.
+        unfold transf_function_fuel in H1. ss. flatten H1.
+        * econstructor 2; eauto. ii; ss.
+        * econstructor 3; eauto. ii; ss.
+          ii. eapply Dom.dom_entry in H5. clarify.
+          exploit no_assigned_phi_spec_fn_entrypoint; eauto. inv SINV; inv WFF; ss.
+          i; ss. eapply Pos.eq_dec.
+        * rewrite H1. destruct f; ss. econstructor 1; eauto.
+        
+    - (* external *)
+      exists (Returnstate st res m'). split.
+      eapply exec_function_external; eauto.
+      eapply external_call_symbols_preserved; eauto. eapply senv_equiv.
+      econstructor; eauto. eapply SSAinv.subj_red; eauto. 
+
+    - (* return *)
+      inv STACK. eexists. split.
+      eapply exec_return.
+      econstructor; eauto. eapply SSAinv.subj_red; eauto.
+      inv MATCH.
+      + rewrite <- 2 H2 in *. econstructor; eauto.
+      + econstructor 2; eauto. ii. destruct (peq r res).
+        clarify. rewrite 2 PMap.gss; eauto.
+        rewrite 2 PMap.gso; eauto.
+      + econstructor 3; eauto.
+        * ii. destruct (peq r res).
+          clarify. rewrite 2 PMap.gss; eauto. rewrite 2 PMap.gso; eauto.
+        * ii. eapply find_mv_phicode_exists in FOUND as MVPHI; des; eauto.
+          assert (pc' = pc0). { eapply def_def_eq; eauto. } clarify.
+          destruct (peq res d).
+          { clarify. exploit assigned_code_and_phi; eauto. ss. }
+          destruct (peq res s0).
+          { clarify. exploit no_phi_use_def'. eauto. eapply MVPHI. eauto.
+            i. inv H0; ss. rewrite forallb_forall in MVPHI1. eapply MVPHI1 in H5.
+            rewrite Pos.eqb_eq in H5; ss. eauto.
+            eapply (@Dom.sdom_dom_pred node peq); eauto.
+            econstructor; eauto. ii; subst pc0; clarify.
+            exploit fn_normalized; eauto. exploit fn_phicode_inv; eauto.
+            intros JP; rewrite JP; ii. rewrite H0 in MVPHI; clarify.
+            unfold Kildall.successors_list, successors. rewrite PTree.gmap1.
+            rewrite PREDINFO; ss. eauto. i; clarify. econstructor; eauto. ss. }
+          rewrite 2 PMap.gso; eauto.
+    Unshelve. eauto. eauto. eauto.
+  Qed. *)
+
+
+  Lemma match_states_bsim
+      s1
+      (EXT: SSA.is_external ge s1)
+      s2 t s2'
+      (IBIND: ge_binded_state tge s2 gmtgt)
+      (STEPTGT: Step (SSA.semantics tprog) s2 t s2')
+      (MATCH: match_states s1 s2)
+      (SAFESRC: safe (SSA.semantics prog) s1)
+  :
+    (exists s1', Step (SSA.semantics prog) s1 t s1' /\ match_states s1' s2')
+    \/ (~ trace_intact t /\ exists s1'' t', Step (SSA.semantics prog) s1 t' s1''
+       /\ exists tl, t' = Eapp (trace_cut_pterm t) tl).
+  Proof.
+    assert (Hwf1: forall s f sp pc rs m, s_inv ge (State s f sp pc rs m) ->
+      wf_ssa_function f) by (intros s f sp pc rs m H; inv H; auto).
+    assert (SEQUIV: Senv.equiv tge ge) by (symmetry; eapply senv_equiv).
+    unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+    { inv SAFESRC; ss. }
+    unfold SSA.is_external in *. inv MATCH; des_ifs.
+    - inv MATCH0.
+      + inv STEPTGT; rewrite <- H1 in *; clarify.
+        left. esplits; eauto. econs; eauto.
+        eapply eval_builtin_args_preserved in H9 as HT; eauto using symbols_preserved.
+        eapply external_call_symbols_preserved in H10 as HTC; eauto.
+        rewrite H1 at 2. econs; eauto.
+        eapply SSAinv.subj_red; eauto. econs; eauto.
+        eapply eval_builtin_args_preserved. i. rewrite symbols_preserved; eauto.
+        unfold tge. ss. eapply H9.
+        eapply external_call_symbols_preserved; eauto.
+        rewrite <- H1. econs; eauto.
+      + exploit transf_function_step_spec_simple; i; des; eauto.
+        exploit H0; i; des; eauto. clear H H0.
+        eapply find_mv_exists in FOUND as FOUND'; des. inv STEPTGT; clarify.
+        left.
+        destruct (classic (use_code f d pc)).
+        * assert (eval_builtin_args ge (fun r => rs # r) sp m l vargs).
+          { exploit eval_builtin_args_preserved_for_ds_eq.
+            eauto. ii; exploit find_mv_not_same; eauto.
+            eapply s_inv_eq_ds; eauto. exploit fn_strict; eauto. econs; eauto.
+            ii; clarify. i. rewrite H0. eauto. }
+          assert (external_call e ge vargs m t vres m').
+          { exploit external_call_symbols_preserved; eauto. }
+          esplits; eauto. econs; eauto. econs; eauto.
+          eapply SSAinv.subj_red; eauto. econs; eauto. econs; eauto.
+          ii. induction b; ss; eauto.
+          destruct (peq r x); clarify.
+          repeat rewrite PMap.gss; eauto. repeat rewrite PMap.gso; eauto.
+        * assert (eval_builtin_args ge (fun r => rs # r) sp m l vargs).
+          { exploit eval_builtin_args_preserved_for_equiv_regset; eauto.
+            ii; eapply H; eauto using use_code. ii; exploit find_mv_not_same; eauto.
+            i. rewrite H0. eauto. }
+          assert (external_call e ge vargs m t vres m').
+          { exploit external_call_symbols_preserved; eauto. }
+          esplits; eauto. econs; eauto. econs; eauto.
+          eapply SSAinv.subj_red; eauto. econs; eauto. econs; eauto.
+          ii. induction b; ss; eauto.
+          destruct (peq r x); clarify.
+          repeat rewrite PMap.gss; eauto. repeat rewrite PMap.gso; eauto.
+      + exploit transf_function_step_spec_simple; i; des; eauto.
+        exploit H0; i; des; eauto. clear H H0.
+        eapply find_mv_phicode_exists in FOUND as FOUND'; des. inv STEPTGT; clarify.
+        left. destruct (classic (use_code f d pc)).
+        * assert (eval_builtin_args ge (fun r => rs # r) sp m l vargs).
+          { exploit eval_builtin_args_preserved_for_ds_eq.
+            eauto. ii; clarify; exploit no_phi_use_def; eauto.
+            rewrite H0 in FOUND; eauto.
+            exploit PHIINV; eauto. i. inv H0; eauto.
+            eapply forallb_forall in FOUND'1; eauto. eapply Pos.eqb_eq in FOUND'1; clarify.
+            exploit fn_strict; eauto. econs; eauto.
+            ii; clarify. exploit no_phi_use_def; eauto. i. rewrite H0. eauto. }
+          assert (external_call e ge vargs m t vres m').
+          { exploit external_call_symbols_preserved; eauto. }
+          esplits; eauto. econs; eauto. econs; eauto.
+          eapply SSAinv.subj_red; eauto. econs; eauto.
+          econs 3; eauto.
+          { induction b; ss. ii. destruct (peq x r).
+            - clarify. repeat rewrite PMap.gss; eauto.
+            - repeat rewrite PMap.gso; eauto. }
+          ii. assert (dom f pc' pc).
+          { eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto.
+            ii; clarify. exploit fn_normalized; eauto. exploit fn_phicode_inv; eauto.
+            intros JF; rewrite JF. ii. rewrite H7 in H2; clarify.
+            unfold Kildall.successors_list, successors. rewrite PTree.gmap1.
+            rewrite Heq; ss. eauto. i; clarify. econstructor; eauto. }
+          induction b; exploit PHIINV; i; eauto. ss.
+          destruct (peq x d).
+          { clarify. exploit assigned_code_and_phi; eauto; ss. }
+          destruct (peq x s).
+          { clarify. exploit no_phi_use_def'; eauto. ss. }
+          rewrite 2 PMap.gso; eauto.
+        * assert (eval_builtin_args ge (fun r => rs # r) sp m l vargs).
+          { exploit eval_builtin_args_preserved_for_equiv_regset; eauto.
+            ii; eapply H; eauto using use_code.
+            ii; clarify; exploit no_phi_use_def; eauto.
+            rewrite H0 in FOUND; eauto. i. rewrite H0. eauto. }
+          assert (external_call e ge vargs m t vres m').
+          { exploit external_call_symbols_preserved; eauto. }
+          esplits; eauto. econs; eauto. econs; eauto.
+          eapply SSAinv.subj_red; eauto. econs; eauto.
+          econs 3; eauto.
+          { induction b; ss. ii. destruct (peq x r).
+            - clarify. repeat rewrite PMap.gss; eauto.
+            - repeat rewrite PMap.gso; eauto. }
+          ii. assert (dom f pc' pc).
+          { eapply (@Dom.sdom_dom_pred node peq); eauto. econs; eauto.
+            ii; clarify. exploit fn_normalized; eauto. exploit fn_phicode_inv; eauto.
+            intros JF; rewrite JF. ii. rewrite H7 in H2; clarify.
+            unfold Kildall.successors_list, successors. rewrite PTree.gmap1.
+            rewrite Heq; ss. eauto. i; clarify. econstructor; eauto. }
+          induction b; exploit PHIINV; i; eauto. ss.
+          destruct (peq x d).
+          { clarify. exploit assigned_code_and_phi; eauto; ss. }
+          destruct (peq x s).
+          { clarify. exploit no_phi_use_def'; eauto. ss. }
+          rewrite 2 PMap.gso; eauto.
+    - inv SAFESRC; des; des_ifs. inv STEPTGT; des; des_ifs; clarify.
+      left; esplits; eauto. econs; eauto.
+      eapply external_call_symbols_preserved in H6; eauto.
+      econs; eauto. eapply SSAinv.subj_red; eauto.
+      econs. eapply external_call_symbols_preserved; eauto.
+  Qed.
+
+  Lemma match_states_xsim
+      st_src0 st_tgt0 (IBIND: ge_binded_state tge st_tgt0 gmtgt) (MATCH: match_states st_src0 st_tgt0):
+    xsim (SSA.semantics prog) (SSA.semantics tprog) (fun _ => None) lt 0%nat st_src0 st_tgt0.
+  Proof.
+    assert (Hwf1: forall s f sp pc rs m, s_inv ge (State s f sp pc rs m) ->
+    wf_ssa_function f) by (intros s f sp pc rs m H; inv H; auto).
+    generalize dependent st_src0. generalize dependent st_tgt0.
+    pcofix CIH. i. pfold.
+    destruct (classic (SSA.is_external ge st_src0)); cycle 1.
+    (* not external *)
+    - left. econs. econs.
+      + i. exploit step_simulation; eauto. i. des; esplits; eauto.
+        { eapply tr_rel_eq. }
+        left. split.
+        { eapply plus_one; eauto. }
+        { eapply semantics_receptive_at; auto. }
+        right. eapply CIH; eauto.
+        { inv H0. ss. eapply ge_binded_state_step; eauto. }
+      + ii. eapply final_state_determ; eauto.
+        inv FINALSRC. inv MATCH. inv STACK. econs.
+      (* + eauto. *)
+    (* external *)
+    - right. econs; eauto. i. econs; eauto.
+      + i. exploit match_states_bsim; eauto. i. des.
+        * left. esplits; eauto.
+          { eapply tr_rel_eq. }
+          left. eapply plus_one. eauto.
+          right. eapply CIH; eauto.
+          { ss. eapply ge_binded_state_step; eauto. }
+        * right. esplits; eauto.
+          { eapply star_one. eauto. }
+          { subst. eapply tr_rel_eq. }
+      + ii. inv FINALTGT. inv MATCH. unfold SSA.is_external in H. ss.
+      + i. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+        { inv SAFESRC; ss. }
+        right. inv MATCH; ss; des_ifs; inv SAFESRC; unfold ge in *; clarify.
+        * inv MATCH0.
+          { esplits. rewrite <- 2 H2. eapply exec_Ibuiltin; eauto.
+            eapply eval_builtin_args_preserved in H9; eauto.
+            i; exploit symbols_preserved; eauto.
+            eapply external_call_symbols_preserved in H10; eauto.
+            eapply senv_equiv. }
+          { exploit transf_function_step_spec_simple; eauto; i; des.
+            exploit H1; eauto; i; des. clear H0 H1.
+            eapply find_mv_exists in FOUND as FOUND'; des. ss. esplits; eauto.
+            destruct (classic (use_code f d pc)).
+            - eapply exec_Ibuiltin; eauto.
+              eapply eval_builtin_args_preserved_for_ds_eq; eauto.
+              ii; clarify; exploit find_mv_not_same; eauto.
+              eapply s_inv_eq_ds; eauto. exploit fn_strict; eauto. econs; eauto.
+              ii; clarify.
+              eapply external_call_symbols_preserved; eauto.
+              eapply senv_equiv; eauto.
+            - eapply exec_Ibuiltin; eauto.
+              eapply eval_builtin_args_preserved_for_equiv_regset; eauto.
+              ii; eapply H0; eauto using use_code.
+              ii; clarify; exploit find_mv_not_same; eauto.
+              eapply external_call_symbols_preserved; eauto. eapply senv_equiv. }
+          { exploit transf_function_step_spec_simple; eauto; i; des.
+            exploit H1; eauto; i; des. clear H0 H1.
+            eapply find_mv_phicode_exists in FOUND as FOUND'; des. ss. esplits; eauto.
+            destruct (classic (use_code f d pc)).
+            - eapply exec_Ibuiltin; eauto.
+              eapply eval_builtin_args_preserved_for_ds_eq; eauto.
+              ii; clarify; exploit no_phi_use_def; eauto.
+              eapply PHIINV; eauto. i. inv H1; eauto.
+              eapply forallb_forall in FOUND'1; eauto. rewrite Pos.eqb_eq in FOUND'1; eauto.
+              exploit fn_strict; eauto. econs; eauto.
+              ii; clarify; exploit no_phi_use_def; eauto.
+              eapply external_call_symbols_preserved; eauto.
+              eapply senv_equiv; eauto.
+            - eapply exec_Ibuiltin; eauto.
+              eapply eval_builtin_args_preserved_for_equiv_regset; eauto.
+              ii; eapply H0; eauto using use_code.
+              ii; clarify; exploit no_phi_use_def; eauto.
+              eapply external_call_symbols_preserved; eauto. eapply senv_equiv. }
+        * esplits; econs. eapply external_call_symbols_preserved; eauto. eapply senv_equiv.
+          (* Unshelve. econs. *)
+  Qed.
+
+  End STEPSIM.
+  
+  Lemma same_public:
+    prog_public prog = prog_public tprog.
+  Proof. inv TRANSL. des; eauto. Qed.
+
+  Lemma non_static_equiv l:
+    Genv.non_static_glob (Genv.globalenv prog) l = Genv.non_static_glob (Genv.globalenv tprog) l.
+  Proof.
+    induction l; ss.
+    unfold Genv.public_symbol. rewrite symbols_preserved. unfold ge.
+    des_ifs.
+    - rewrite IHl. eauto.
+    - rewrite Genv.globalenv_public in *. rewrite same_public in Heq. clarify.
+    - rewrite Genv.globalenv_public in *. rewrite same_public in Heq. clarify.
+Qed.
+
+  Lemma transf_initial_capture
+    S1 S2 S2'
+    (INITSRC: SSA.initial_state prog S1)
+    (INITTGT: SSA.initial_state tprog S2)
+    (MATCH: match_states S1 S2)
+    (CAPTGT: SSA.glob_capture tprog S2 S2'):
+  exists S1',
+    SSA.glob_capture prog S1 S1' /\ match_states S1' S2'.
+  Proof.
+    inv CAPTGT. ss.
+    rewrite Genv.globalenv_public in CAPTURE.
+    rewrite <- same_public in CAPTURE. erewrite <- non_static_equiv in CAPTURE.
+    inv MATCH. inv STACK.
+    esplits.
+    - econs; eauto. rewrite Genv.globalenv_public. eauto.
+    - econs; eauto.
+      + inv SINV. econs; eauto.
+      + econs.
+  Qed.
+
+  Lemma match_states_concrete
+      s1 s2
+      (MATCH: match_states s1 s2):
+    (Mem.mem_concrete (state_mem s1)) = (Mem.mem_concrete (state_mem s2)).
+  Proof. inv MATCH; ss. Qed.
+  
+  Theorem transf_program_step_correct:
+    mixed_simulation (SSA.semantics prog) (SSA.semantics tprog).
+  Proof.
+    econs. econs.
+    - apply lt_wf.
+    - rr. i. exists (S a). lia.
+    - econs. i. exploit transf_initial_states; eauto. i. des.
+      exists st2. split.
+      (* initial state *)
+      + econs; eauto. eapply initial_state_determ.
+      (* mixed sim *) 
+      + r. ii. exploit transf_initial_capture; eauto. i. des. esplits; eauto.
+        { subst. ss. rr. i. unfold SSA.concrete_snapshot in *.
+          destruct senv_equiv. des. erewrite H5, H4; eauto.
+          erewrite <- match_states_concrete; eauto. }
+        exploit match_states_xsim; eauto.
+        { eapply initial_capture_binded; eauto. }
+        i. instantiate (1:=0).
+        eapply xsim_mon_rel in H3; eauto; cycle 1.
+        { instantiate (1:=gmtgt0). ii. clarify. }
+        { instantiate (1:= fun x => x). ii. eauto. }
+        ss.
+    - i. apply senv_equiv.
+  Qed.
+
+End CORRECTNESS_STEP.
+
+Section CORRECTNESS.
+
+  Variable prog: program.
+  Variable tprog: program.
+  Hypothesis TRANSL : match_prog prog tprog.
+  Hypothesis HWF : wf_ssa_program prog.
+
+  Lemma match_prog_wf_ssa : wf_ssa_program tprog.
+  Proof. 
+    red. intros.
+    red in HWF.
+    inv TRANSL.
+    intuition. revert H0 H HWF.
+    induction 1; intros.
+    - inv H.
+    - inv H1.      
+      + inv H. inv H4.
+        destruct f1 ; simpl in * ; try constructor; auto.
+        exploit (HWF (Internal f) id); eauto.
+        destruct a1, g; simpl in * ; try congruence. 
+        left. inv H; simpl in *; auto. 
+        intros. inv H4; auto.
+        apply transf_function_preserve_wf_ssa_function; auto.
+      + eapply IHlist_forall2; eauto.
+  Qed.
+
+  Lemma tprog_transf: tprog = transf_program prog.
+  Proof.
+    assert (FORALL2_MAP: forall prog l l',
+            list_forall2
+              (match_ident_globdef
+                (fun (_: AST.program fundef unit) (f tf: fundef) =>
+                  tf = transf_fundef f) eq prog) l l' ->
+            l' = map (fun (idg: ident * globdef fundef unit) => 
+                      let (id, g) := idg in
+                      match g with
+                      | Gfun f => (id, Gfun (transf_fundef f))
+                      | Gvar v => (id, Gvar v)
+                      end) l).
+    { induction l; ss.
+      - i. inv H. auto.
+      - i. destruct l'; ss.
+        + inv H.
+        + inv H. destruct a; ss. destruct g; ss.
+          * destruct p; ss. destruct g; ss.
+            -- inv H3; ss. clarify. inv H0. apply IHl in H5. rewrite H5. clarify.
+            -- inv H3; ss. inv H0.
+          * destruct p; ss. destruct g; ss.
+            -- inv H3; ss. inv H0; ss.
+            -- inv H3; ss. clarify. inv H0; ss. apply IHl in H5. rewrite H5.
+               inv H2. auto. }
+    inv TRANSL. apply FORALL2_MAP in H as H'.
+    destruct prog; ss. destruct tprog; ss. destruct H0; clarify.
+  Qed.
+  
+  Definition program_length (p: program) :=
+    List.list_max (map (code_size)
+                       (fold_left (fun m ig => match (snd ig) with
+                                               | Gfun (Internal f) => f :: m
+                                               | _ => m
+                                               end) (prog_defs p) nil)).
+
+  Lemma transf_program_repeatn:
+    exists n, transf_program prog = repeatn transf_program_step n prog.
+  Proof.
+    exists (program_length prog). unfold transf_program, transf_program_step.
+    unfold transform_program; ss.
+    assert (forall n p,
+            repeatn transf_program_step n p =
+            mkprogram ((repeatn (map (transform_program_globdef transf_fundef_step))
+                        n (prog_defs p))) (prog_public p) (prog_main p)).
+    { induction n; ss. i; destruct p; ss. i. rewrite IHn. ss. }
+    rewrite H.
+    assert (forall fuel, (program_length prog) <= fuel ->
+            map (transform_program_globdef transf_fundef) (prog_defs prog)
+            = repeatn (map (transform_program_globdef (transf_fundef_step)))
+              fuel (prog_defs prog)).
+    { assert (forall f n (l: list (ident * globdef fundef unit)),
+              repeatn (map f) n l = (map (repeatn f n) l)).
+      { induction n; ss. i. induction l; ss. rewrite <- IHl; ss.
+        induction l; ss. rewrite IHn. ss.
+        rewrite IHn. ss. rewrite <- IHn. rewrite IHl. ss. }
+      intros fuel. rewrite H0. unfold program_length.
+      generalize (prog_defs prog). induction l; ss.
+      destruct a; ss. destruct g; ss.
+      - (* Gfun *)
+        destruct f; ss.
+        + i. remember (fun m ig => _) as f'.
+          assert (forall l l', fold_left f' l l' = fold_left f' l nil ++ l').
+          { induction l0; ss. i. rewrite IHl0. rewrite (IHl0 (f' nil a)).
+            destruct a; ss. enough (f' l' (i0, g) = f' nil (i0, g) ++ l').
+            rewrite H2. rewrite List.app_assoc. ss. destruct g; ss.
+            - destruct f0; clarify; ss.
+            - clarify; ss. }
+          rewrite H2 in H1. rewrite map_app in H1. ss.
+          rewrite list_max_le in H1.
+          rewrite Forall_app in H1. des. inversion H3.
+          rewrite IHl. remember (transform_program_globdef transf_fundef_step).
+          assert (forall n, repeatn p n (i, Gfun (Internal f)) =
+                            (i, Gfun (Internal (repeatn (transf_function_fuel 1) n f)))).
+          { induction n; ss. rewrite IHn. clarify; ss. }
+          rewrite H8. erewrite transf_function_commute; ss. rewrite list_max_le. ss.
+        + i. rewrite <- IHl. remember (transform_program_globdef transf_fundef_step).
+          enough (forall n,
+                  repeatn p n (i, (Gfun (External e))) = (i, (Gfun (External e)))).
+          rewrite H2. ss.
+          induction n; ss. rewrite IHn. clarify; ss. ss.
+      - (* Gvar *)
+        i. rewrite <- IHl.
+        enough (forall n,
+                (repeatn (transform_program_globdef transf_fundef_step) n (i, Gvar v))
+                = (i, Gvar v)).
+        rewrite H2. ss.
+        induction n; ss. rewrite IHn. unfold transform_program_globdef. ss. ss. }
+    erewrite H0; ss.
+  Qed.
+
+(** * Semantics preservation *)
+
+End CORRECTNESS.
diff --git a/midend/GVNopt.v b/midend/GVNopt.v
deleted file mode 100644
index 890e5638..00000000
--- a/midend/GVNopt.v
+++ /dev/null
@@ -1,307 +0,0 @@
-Require Import Classical.
-Require Import Coqlib.
-Require Import Maps.
-Require Import AST.
-Require Import Integers.
-Require Import Values.
-Require Import Memory.
-Require Import Globalenvs.
-Require Import Smallstep.
-Require Import Op.
-Require Import Events.
-Require Import Registers.
-Require Import Floats.
-Require Import Utils.
-Require Import SSA. 
-Require Import SSAutils. 
-Require Import Utilsvalidproof.
-Require Import DomCompute.
-Require Import Axioms.
-Require Import KildallComp.
-Require Import OrderedType.
-Require Import Ordered.
-Require Import FSets.
-Require FSetAVL.
-Require Import Opt.
-Require Import OptInv.
-Require Import DLib.
-
-(** Common Subexpression Elimination based on Global Value Numbering *)
-
-(** * Validation algorithm *)
-Section Checker.  
-  
-  Variable f : function.
-  
-  Notation code := (fn_code f).
-  Notation phicode := (fn_phicode f).
-
-  Definition certif := PTree.t ssa_def.
-  Variable certificate : certif.
-  
-  Definition ssa_def_to_node (d:ssa_def) : node := 
-    match d with
-      | SDIop pc => pc
-      | SDPhi pc _ => pc
-    end.
-  
-  Definition top_set l : PTree.t unit :=
-    fold_left (fun p s => PTree.set s tt p) l (PTree.empty _).
-  
-  Lemma in_top_set : forall l x, In x l -> PTree.get x (top_set l) = Some tt.
-  Proof.
-    assert (forall l s x,
-              s ! x = Some tt ->
-              (fold_left (fun (p : PTree.t unit) (s : PTree.elt) => PTree.set s tt p)
-                         l s) ! x = Some tt).
-    induction l; simpl; intros; go.
-    apply IHl.
-    rewrite PTree.gsspec; flatten.
-    assert (forall l s x,
-              In x l ->
-              (fold_left (fun (p : PTree.t unit) (s : PTree.elt) => PTree.set s tt p)
-                         l s) ! x = Some tt).
-    induction l; simpl; intros; go.
-    destruct H0; auto.
-    apply H.
-    subst; rewrite PTree.gss; auto.
-    intros; apply H0; auto.
-  Qed.
-  
-  Definition test_param_no_repr (s:PTree.t unit) : bool :=
-    forall_ptree (fun r d =>
-                     match get_ssa_eq f d with
-                       | None => false
-                       | Some e => 
-                         let dst := ssa_eq_to_dst e in
-                         match PTree.get dst s with
-                           | Some _ => false
-                           | None => 
-                             match certificate ! dst with
-                               | None => true
-                               | Some _ => false
-                             end
-                         end
-                     end) certificate.
-
-  Definition make_repr (l:list reg) : reg -> (reg * node) :=    
-    let s := top_set l in
-    if test_param_no_repr s then
-      let map := PTree.map (fun r d => match get_ssa_eq f d with
-                                          | None => (r, xH)
-                                          | Some e => (ssa_eq_to_dst e, ssa_def_to_node d)
-                                        end) certificate in
-      (fun r => match PTree.get r map with
-                | Some r' => r'
-                | None => (r, xH)
-                end)
-    else (fun r => (r,xH)).
-
-  Lemma make_repr_not_id : forall l r r',
-    In r l ->  fst (make_repr l r') = r -> r = r'.
-  Proof.
-    unfold make_repr; intros r r' Hi.
-    flatten; simpl; auto.
-    destruct p as (r0 & n0); intro; subst; simpl in *.
-    unfold test_param_no_repr in Eq.
-    rewrite PTree.gmap in Eq0.
-    unfold option_map in Eq0.
-    flatten Eq0.
-    exploit ptree_forall; eauto.
-    simpl.
-    flatten.
-    exploit in_top_set; eauto.
-    congruence.
-  Qed.
-
-  Lemma test_itempotent s : 
-    test_param_no_repr s = true ->
-    let map := PTree.map (fun r d => match get_ssa_eq f d with
-                                        | None => (r, xH)
-                                        | Some e => (ssa_eq_to_dst e, ssa_def_to_node d)
-                                      end) certificate in    
-    forall r r', PTree.get r map = Some r' -> PTree.get (fst r') map = None.
-  Proof.
-    unfold test_param_no_repr; intros.
-    rewrite PTree.gmap in H0.
-    rewrite PTree.gmap.
-    destruct (certificate ! r) eqn:E; inv H0.
-    exploit ptree_forall; eauto; clear H.
-    simpl.
-    flatten; simpl.
-    rewrite Eq1; auto.
-  Qed.
-
-  Lemma make_repr_itempotent : forall l r,
-    fst (make_repr l (fst (make_repr l r))) = fst (make_repr l r).
-  Proof.
-    intros l r.
-    unfold make_repr.
-    destruct (test_param_no_repr (top_set l)) eqn:E1; simpl; auto.
-    set (map := PTree.map (fun r d => match get_ssa_eq f d with
-                                        | None => (r, xH)
-                                        | Some e => (ssa_eq_to_dst e, ssa_def_to_node d)
-                                      end) certificate).
-    destruct (map ! r) eqn:E2; simpl; auto.
-    - exploit test_itempotent; eauto.
-      intros; assert (T : map ! (fst p) = None) by auto.
-      rewrite T; auto.
-    - rewrite E2; auto.
-  Qed.
-  
-  Definition op_eq (x y:operation) : bool :=
-    if eq_operation x y then true else false.
-
-  Lemma op_eq_true_iff : forall x y, 
-    op_eq x y = true <-> x = y.
-  Proof.
-    unfold op_eq; intros; destruct eq_operation; intuition congruence.
-  Qed.
-
-  
-  Definition check_GVN_instr (f:function)
-             (repr:reg-> (reg*node)) 
-             (pc:node) (ins:instruction) : bool :=
-    match ins with
-      | Iop op args dst _ =>
-        let dst' := fst (repr dst) in
-        (peq dst dst') 
-          ||
-          (match PTree.get dst certificate with
-             | None => false
-             | Some (SDIop pc') =>
-               match get_ssa_eq f (SDIop pc') with
-                 | Some (EqIop op' args' dst0') =>
-                   (peq dst' dst0') &&
-                   (op_eq op op') && 
-                   (fn_dom_test f pc' pc) &&
-                   (negb (op_depends_on_memory op)) &&
-                   (forall_list2 (fun x y => peq (fst (repr x)) (fst (repr y))) args args')
-                 | _ => false
-               end                 
-             | Some _ => false
-           end)
-      | _ => true
-    end.
-
-  Definition check_GVN_phiblock (f:function)
-             (repr:reg-> (reg*node)) (pc:node) (phib:phiblock) : bool :=
-        forallb
-          (fun (phi:phiinstruction) =>
-             let (args,dst) := phi in
-             let dst' := fst (repr dst) in
-             (peq dst dst') 
-               ||
-               (match PTree.get dst certificate with
-                  | None => false
-                  | Some (SDPhi pc' idx) =>
-                    (peq pc pc') 
-                      &&
-                      (match get_ssa_eq f (SDPhi pc' idx) with
-                         | Some (EqPhi dst0' args') =>
-                           (peq dst' dst0') 
-                           &&
-                           (forall_list2 (fun x y => peq (fst (repr x)) (fst (repr y))) args args')
-                         | _ => false
-                       end)                 
-                  | Some _ => false
-                end))
-          phib.
-
-  Definition dst_at_top l (m:PTree.t instruction) : list reg :=
-    PTree.fold (fun l oc ins => 
-                  match ins with 
-                    | Iload _ _ _ r _ 
-                    | Icall _ _ _ r _ => r :: l
-                    | Ibuiltin _ _ (BR r) _ => r :: l
-                    | _ => l
-                  end) m l.
-
-  Lemma dst_at_top_prop1 : forall m l pc,
-    match m!pc with
-      | Some (Iload _ _ _ r _) 
-      | Some (Icall _ _ _ r _) => In r (dst_at_top l m)
-      | Some (Ibuiltin _ _ (BR r) _) => In r (dst_at_top l m)
-      | _ => True
-    end.
-  Proof.
-    intros m l pc.
-    unfold dst_at_top.
-    apply PTree_Properties.fold_rec; intros.
-    - rewrite <- H; flatten; auto.
-    - rewrite PTree.gempty; auto.
-    - rewrite PTree.gsspec.
-      flatten; auto.
-  Qed.
-
-  Lemma dst_at_top_prop0 : forall m l,
-    forall r, In r l -> In r (dst_at_top l m).
-  Proof.
-    intros m l.
-    unfold dst_at_top.
-    apply PTree_Properties.fold_rec; intros; auto.
-    flatten; auto.
-  Qed.
-
-  Definition check_GVN : option (reg-> (reg * node)) :=
-    let top_list := dst_at_top (fn_ext_params f) (fn_code f) in
-    let repr := make_repr top_list in
-    let check_params := forallb (fun r => peq (fst (repr r)) r) top_list in
-    let check_instr := forall_ptree (check_GVN_instr f repr) (fn_code f) in
-    let check_phiblock := forall_ptree (check_GVN_phiblock f repr) (fn_phicode f) in
-    if check_params && check_instr && check_phiblock
-    then Some repr
-    else None.
-
-End Checker.
-
-(** * CSE optimisation based on GVN *)
-
-Axiom extern_gvn: function -> certif.
-
-Definition get_repr (f:function) (c:certif):=
-  match check_GVN f c with
-    | Some repr => repr
-    | None => (fun x => (x,xH))
-  end.
-
-Definition get_extern_gvn (f:function): (reg -> (reg* node)) :=
-  get_repr f (extern_gvn f).
-
-Definition analysis (f: function) := ((get_extern_gvn f, f),P2Map.init true).
-
-Definition res := ((reg -> reg*node)  (* repr(x) = (r, r_def) *)
-                    * function        (* function *)                           
-                   )%type.
-
-Definition check_def (code:code) (pc:node) (x:reg) : bool :=
-  match code!pc with
-    | Some (Iop op args dst succ) => if peq x dst then true else false
-    | Some (Iload chunk addr args dst succ) => if peq x dst then true else false
-    | Some (Icall sig fn args dst succ) => if peq x dst then true else false
-    | Some (Ibuiltin fn args (BR dst) succ) => if peq x dst then true else false
-    | _ => false
-  end.
-
-Definition transf_instr (r:res) (pc:node) (instr:instruction) : instruction :=
-  let '(repr,f) := r in
-  match instr with
-  | Iop op args dst s =>
-    if is_trivial_op op then instr 
-      else
-        let (dst',def') := repr dst in
-        if negb (peq dst dst') (* && is_dom def' pc  *)
-           && check_def (fn_code f) def' dst' && negb (peq def' pc) 
-        then Iop Omove (dst' :: nil) dst s               
-        else instr
-  | _ => instr
-  end.
-
-Definition transf_function (f: function) := 
-  @Opt.transf_function res analysis transf_instr f. 
-     
-Definition transf_fundef (f: fundef) : fundef :=
-  AST.transf_fundef transf_function f.
-
-Definition transf_program (p: program) : program :=
-  AST.transform_program transf_fundef p.
diff --git a/midend/GVNoptProp.v b/midend/GVNoptProp.v
deleted file mode 100644
index 10cf732d..00000000
--- a/midend/GVNoptProp.v
+++ /dev/null
@@ -1,747 +0,0 @@
-Require Import Classical.
-Require Import Coqlib.
-Require Import Maps.
-Require Import AST.
-Require Import Integers.
-Require Import Values.
-Require Import Memory.
-Require Import Globalenvs.
-Require Import Smallstep.
-Require Import Op.
-Require Import Events.
-Require Import Registers.
-Require Import Floats.
-Require Import Utils.
-Require Import Dom.
-Require Import SSA. 
-Require Import SSAutils. 
-Require Import SSAinv. 
-Require Import Utilsvalidproof.
-Require Import DomCompute.
-Require Import Axioms.
-Require Import KildallComp.
-Require Import OrderedType.
-Require Import Ordered.
-Require Import FSets.
-Require FSetAVL.
-Require Import Opt.
-Require Import OptInv.
-Require Import DLib.
-Require Import GVNopt.
-Require Import Dsd.
-
-Unset Allow StrictProp.
-
-(** Instantiating the generic analysis in [Opt] to the GVN-CSE case *)
-
-(** * The dominance based analysis *)
-Section DsdAnalysis. 
-
-  Definition approx := reg.
-  Definition result := reg -> approx.
-
-  Variant G : genv -> val -> regset -> approx -> val -> Prop :=
-  | G_intro : forall ge sp rs r v, 
-              forall (EQ: v = rs# r),
-                G ge sp rs r v.
-
-  Variant is_at_Top : result -> reg -> Prop :=
-  | is_at_Top_intro : forall R r,
-                        R r = r ->
-                        (forall r', R r' = r -> r' = r) ->
-                        is_at_Top R r.
-  
-  Definition A f := ((fun x => fst (get_extern_gvn f x)),
-                     P2Map.init true).
-
-  Let A_r f := fst (A f).
-
-  Lemma list_top_at_Top : 
-    forall (f:function) r, 
-      In r (dst_at_top (fn_ext_params f) (fn_code f)) -> is_at_Top (A_r f) r.
-  Proof.
-    unfold A_r, A; simpl; intros.
-    unfold get_extern_gvn, get_repr, check_GVN.
-    match goal with |- context[if ?b then _ else _] => destruct b eqn:E end.
-    - edestruct andb_prop as (E1 & E2); eauto; clear E.
-      edestruct andb_prop as (E3 & E4); eauto; clear E1.
-      rewrite forallb_forall in E3.
-      set (ep:=(dst_at_top (fn_ext_params f) (fn_code f))) in *.
-      assert (HH: (fst (make_repr f (extern_gvn f) ep r)) = r).
-      + eapply proj_sumbool_true; eauto.
-      + constructor; auto.
-        intros r' H'.
-        symmetry.
-        eapply make_repr_not_id; [idtac|eapply H'].
-        auto.
-    - simpl; go.
-  Qed.
-
- Lemma params_Top : 
-   forall (f:function) r,
-     wf_ssa_function f ->
-     ext_params f r -> is_at_Top (A_r f) r.
- Proof.
-   intros; apply list_top_at_Top; auto.
-   apply dst_at_top_prop0.
-   apply fn_ext_params_complete; auto.
- Qed.
- 
- Lemma G_top : forall f r ge sp rs, is_at_Top (A_r f) r -> G ge sp rs (A_r f r) (rs# r).
- Proof.
-   intros. invh is_at_Top.
-   econstructor; eauto.
-   rewrite H0 at 1; auto.
- Qed.
-
- Lemma is_at_Top_eq_is_at_Top : forall f dst x,
-   is_at_Top (A_r f) dst -> A_r f x = A_r f dst -> is_at_Top (A_r f) x.
-  Proof.
-    induction 1; intros.
-    rewrite H in H1.
-    assert (x = r) by (eapply H0; eauto).  
-    rewrite <- H2 in H1.
-    constructor; auto. 
-    intros. rewrite H2. eapply H0; eauto.
-    congruence.
-  Qed.
-
-  Definition exec : function -> node -> Prop := (fun _ _ => True).
-  Lemma exec_fn_entrypoint : forall f, exec f (fn_entrypoint f).
-  Proof.
-    go.
-  Qed.    
-
-  Definition GVN := 
-    (Build_DsdAnalysis approx G is_at_Top A exec exec_fn_entrypoint 
-                       is_at_Top_eq_is_at_Top params_Top G_top).
-
-
-  (** ** Auxiliary properties about the GVN checker *)  
-  Inductive same_repr (repr : reg -> reg) : list reg -> list reg -> Prop :=
-  | same_repr_nil: same_repr repr nil nil
-  | same_repr_cons: forall x1 l1 x2 l2,
-    same_repr repr l1 l2 -> 
-    repr x1 = repr x2 -> 
-    same_repr repr (x1::l1) (x2::l2).
-  
-  Lemma same_repr_nth_error : forall repr args args',
-    same_repr repr args args' -> 
-    forall  k x x',
-      nth_error args k = Some x ->
-      nth_error args' k = Some x' ->
-      repr x = repr x'.
-  Proof.
-    induction 1; destruct k; simpl; intros; try congruence.
-    inv H1; inv H2; auto.
-    eauto.
-  Qed.
-
-  Lemma same_repr_map : forall R rl rl', same_repr R rl rl' -> map R rl = map R rl'.
-  Proof.
-    induction 1 ; go. 
-  Qed.
-
- Definition repr_spec_code (f: function) (pc: node) (R: reg -> reg) : Prop :=
-   match (fn_code f) ! pc with 
-     | Some i => 
-       match i with 
-         | Iop op args r _ =>
-           R r = r 
-           \/ 
-           (exists pc_r pc_r' args_r, 
-              (fn_code f) ! pc_r = Some (Iop op args_r (R r) pc_r')
-              /\ same_repr R args args_r
-              /\ (r <> R r)
-              /\ sdom f pc_r pc
-              /\ op_depends_on_memory op = false)
-         | Iload _ _ _ r _ 
-         | Icall _ _ _ r _
-         | Ibuiltin _ _ (BR r) _ => is_at_Top R r
-         | _ => True 
-       end
-     | None => True
-   end.
-
- Definition repr_spec_phicode (f: function) (pc: node) (R: reg -> reg) : Prop :=
-   match (fn_phicode f) ! pc with 
-     | None => True 
-     | Some phib =>
-       forall r args, In (Iphi args r) phib ->
-            R r = r 
-             \/ exists args_r, 
-               In (Iphi args_r (R r)) phib /\ same_repr R args args_r
-   end.
-
- Record GVN_spec (f: function) : Prop := {
-   GVN_spec_code : forall pc, repr_spec_code f pc (A_r f);
-   GVN_spec_phicode : forall pc, repr_spec_phicode f pc (A_r f);
-   GVN_spec_idempotence : forall r, A_r  f (A_r f r) = A_r f r
- }.
- 
- Lemma repr_spec_code_id : forall f pc, repr_spec_code f pc (fun x : reg => x).
- Proof.
-   unfold repr_spec_code; intros; flatten; go.
- Qed.
- Hint Resolve repr_spec_code_id: core.
-
- Lemma repr_spec_phicode_id : forall f pc, repr_spec_phicode f pc (fun x : reg => x).
- Proof.
-   unfold repr_spec_phicode; intros; flatten; go.
- Qed.
- Hint Resolve repr_spec_phicode_id: core.
-
-(* Move this *)
-Lemma peq_true_iff : forall x y, 
-  proj_sumbool (peq x y) = true <-> x = y.
-Proof.
-  unfold proj_sumbool.
-  intros; destruct peq; intuition congruence.
-Qed.
-
-(* Move this *) 
-Ltac boolInv :=
-  match goal with
-  | [ H: context[op_eq _ _ = true] |- _ ] => 
-      rewrite op_eq_true_iff in H; boolInv
-  | [ H: context[proj_sumbool (peq _ _) = true] |- _ ] => 
-      rewrite peq_true_iff in H; boolInv
-  | [ H: context[_ || _ = true] |- _ ] => 
-      rewrite orb_true_iff in H; boolInv
-  | [ H: context[_ && _ = true] |- _ ] => 
-      rewrite andb_true_iff in H; boolInv
-  | _ =>
-      idtac
-  end.
-  
-Lemma forall_list2_same_repr :
-  forall R l args,
-    forall_list2 (fun x y : reg => peq (R x) (R y)) l args = true ->
-    same_repr R l args.
-Proof.
-  induction l; destruct args; simpl; go.
-  intros; boolInv. 
-  destruct H; go. 
-Qed.
-
-Lemma repr_idempotent : 
-  forall f,
-    let R:=make_repr f (extern_gvn f) (dst_at_top (fn_ext_params f) (fn_code f)) in
-    forall r, fst (R (fst (R r))) = fst (R r).
-Proof.
-  intros f R r.
-  unfold R.
-  rewrite make_repr_itempotent; auto.
-Qed.
-
-(* Move this *)
-  Lemma G_unique : forall ge sp rs r v v',
-                     G ge sp rs r v ->
-                     G ge sp rs r v' ->
-                     v = v'.
-  Proof.
-    intros until v'.
-    intros HGv HGv'.
-    repeat invh G. auto.
-  Qed.
-      
-  Lemma G_list_eval_op_helper : 
-    forall rs ge sp al vl vl',
-      G_list GVN ge sp rs al vl ->
-      G_list GVN ge sp rs al vl' ->
-      vl = vl'.
-  Proof.
-    induction al ; intros. 
-    - repeat invh G_list; auto.
-    - inv H. inv H0. 
-      assert (v0 = v) by (erewrite G_unique ; eauto); subst.
-      exploit (IHal vl0 vl); eauto. intros Heq; subst.
-      auto. 
-  Qed.
-     
-  Lemma G_list_eval_op : 
-    forall rs ge sp op m al vl vl',
-      G_list GVN ge sp rs al vl ->
-      G_list GVN ge sp rs al vl' ->
-      eval_operation ge sp op vl m = eval_operation ge sp op vl' m.
-  Proof.
-    intros. 
-    erewrite G_list_eval_op_helper with (vl:= vl) (vl':= vl'); eauto. 
-  Qed.  
-
-(* End of Move this *)
- 
-(** * The checker satisfies its specification *)
-  Lemma GVN_spec_True : forall f
-      (WFF: wf_ssa_function f),
-      GVN_spec f.
-Proof.
-  intros f; constructor.
-  - generalize (list_top_at_Top f).
-    unfold A_r.
-    unfold A_r, A, get_extern_gvn, get_repr, check_GVN; simpl.     
-    flatten; simpl; auto.
-    flatten Eq.
-    edestruct andb_prop as (T1 & T2); eauto; clear Eq0.
-    edestruct andb_prop as (T3 & T4); eauto; clear T1.
-    unfold repr_spec_code; flatten; auto.
-    exploit ptree_forall; eauto; clear T4.
-    simpl.
-    set (R:=make_repr f (extern_gvn f) (dst_at_top (fn_ext_params f) (fn_code f))).
-    flatten.
-    + flatten Eq3.
-      boolInv.
-      destruct (peq (fst (R r)) r); auto.
-      destruct H3; [elim n1; auto|right].
-      repeat invh and; subst.
-      do 3 econstructor; split; [eauto|idtac].
-      repeat split; auto.
-      * eapply forall_list2_same_repr; eauto.
-      * eapply fn_dom_test_correct; eauto.
-      * unfold fn_code in *; congruence.
-      * destruct (op_depends_on_memory op); simpl in *; congruence.
-    + flatten Eq3.
-    + intros H; boolInv; destruct H; auto; go.
-    + intros H; boolInv; destruct H; auto; go.
-    + intros H; boolInv; destruct H; auto; go.
-    + apply H0; auto.
-      generalize (dst_at_top_prop1 (fn_code f) (fn_ext_params f) pc).
-      flatten.
-    + apply H0; auto.
-      generalize (dst_at_top_prop1 (fn_code f) (fn_ext_params f) pc).
-      flatten.
-    + apply H0; auto.
-      generalize (dst_at_top_prop1 (fn_code f) (fn_ext_params f) pc).
-      flatten.
-  - unfold A_r, A, get_extern_gvn, get_repr, check_GVN; simpl.     
-    flatten; simpl; auto.
-    flatten Eq.
-    edestruct andb_prop as (T1 & T2); eauto; clear Eq0.
-    edestruct andb_prop as (T3 & T4); eauto; clear T1.
-    unfold repr_spec_phicode; flatten; auto.
-    clear T3 T4.
-    exploit ptree_forall; eauto; clear T2.
-    match goal with
-    | |- ?x => match x with
-               | context [ (make_repr ?f ?p1 ?p2 )] =>
-                         set (R:=make_repr f p1 p2)
-               end
-    end.
-    unfold check_GVN_phiblock.      
-    rewrite forallb_forall.
-    intros.
-    exploit H; eauto; clear H; simpl; intros.
-    boolInv.
-    destruct H; auto.
-    right.
-    flatten H.
-    * boolInv.
-      repeat invh and.
-      assert (p0=p) by congruence; subst.
-      econstructor; split.
-      -- eapply nth_error_in; eauto.
-      -- eapply forall_list2_same_repr; eauto. 
-    * destruct peq; inv H.
-    * destruct peq; inv H.
-  - intros r.
-    unfold A_r, A, get_extern_gvn, get_repr, check_GVN; simpl.
-    flatten; auto.
-    flatten Eq; auto.
-    rewrite repr_idempotent; auto.
-Qed.
-
-End DsdAnalysis.
-
-(** * Proof that GVN preserves the wf_ssa_function predicate *)
-(** This is only provable here, where we have the specification
-[GVN_spec] of the checker *)
-
-Section WFSSA. 
-
-Lemma check_def_correct: forall f pc x,
-  check_def (fn_code f) pc x = true -> def f x pc.
-Proof.
-  intros; constructor 2.
-  unfold check_def in H.
-  case_eq ((fn_code f)!pc); intros; rewrite H0 in *; try congruence.
-  destruct i; try destruct b ; try congruence; try destruct peq; go.
-Qed.
-
-Lemma new_code_same_or_Iop : forall (f:function) (WF:wf_ssa_function f) pc ins,
-    (fn_code f) ! pc = Some ins ->
-    transf_instr (fst (analysis f)) pc ins = ins
-    \/ match ins with
-         | Iop _ _ dst pc' 
-         | Iload _ _ _ dst pc'
-         | Icall _ _ _ dst pc'  
-         | Ibuiltin _ _ (BR dst) pc' => 
-           exists op' args',
-             transf_instr (fst (analysis f)) pc ins = Iop op' args' dst pc'
-             /\ forall x, In x args' -> exists d : node, def f x d /\ sdom f d pc
-         | _ => False
-       end.
-Proof. 
-  destruct ins; simpl; flatten; eauto. 
-  right.
-  edestruct andb_prop; eauto; clear Eq1.
-  edestruct andb_prop; eauto; clear H0.
-  econstructor; econstructor; split; eauto.
-  simpl. 
-  destruct 1 as [HH|HH]; [subst|elim HH].
-  exists n0; split.
-  - eapply check_def_correct; eauto.
-  - split.
-    + generalize (GVN_spec_code f (GVN_spec_True f WF)) ; eauto.
-      intros Hc.
-      specialize Hc with pc.
-      unfold repr_spec_code in Hc; flatten Hc.
-      destruct Hc.
-      * unfold A in *.
-        simpl in H.
-        assert (x=r) by (rewrite Eq0 in H; simpl in H; congruence).
-        subst x.
-        destruct (peq r r); go.
-      * destruct H as (pc0 & pc' & args' & T1 & T2 & T3 & T4 & T5).
-        assert (fst (A f) r = x).
-          unfold A; simpl; rewrite Eq0; auto.
-        rewrite H in *.  
-        apply check_def_correct in H3.
-        assert (def f x pc0) by go.        
-        assert (n0=pc0) by (eapply ssa_def_unique; eauto).
-        subst.
-        destruct T4; auto.
-    + intro; subst.
-      destruct peq in H1; simpl in *; congruence.
-Qed.
-
-End WFSSA.
-
-(** * Local correctness obligation proofs about the analysis *)
-Notation A_r f := (fst (A f)).
-Notation A_e f := (snd (A f)).
-
-Lemma same_fn_code3 : forall (f:function) (WF: wf_ssa_function f) res,
-                        (ext_params f res) ->
-                        forall x dx, def f x dx -> A_r f x = res -> x = res.
-Proof.
-  intros.
-  generalize (GVN_spec_code f (GVN_spec_True f WF)) ; eauto. intros Hcode.
-  generalize (GVN_spec_phicode f (GVN_spec_True f WF)) ; eauto. intros Hphicode.
-  specialize Hcode with dx.
-  specialize Hphicode with dx.
-  subst.
-  invh def.
-  - exploit params_Top; eauto. intros. 
-    invh is_at_Top. congruence. 
-  - unfold repr_spec_code in *.
-    unfold fn_code in *.
-    invh assigned_code_spec;
-      try match goal with 
-        | id : (SSA.fn_code f) ! _ = Some _ |- _ => 
-          rewrite id in *; go
-      end; try solve [invh is_at_Top; congruence]; rewrite H0 in Hcode;
-    repeat invh or ; repeat invh ex ; repeat invh and.
-    + congruence.
-    + inv H. 
-      eelim fn_ssa_params; eauto. 
-      * intros. eelim H; go. 
-      * eelim H8; go.
-    + destruct Hcode; auto.
-    + destruct Hcode; auto.
-    + destruct Hcode; auto.
-  - unfold repr_spec_phicode in *. 
-    invh assigned_phi_spec;
-      try match goal with 
-        | id : (fn_phicode f) ! _ = Some _ |- _ => 
-          rewrite id in *; go
-      end.
-    specialize (Hphicode x).
-    repeat invh or ; repeat invh ex ; repeat invh and.
-    + inv H. 
-      * eelim fn_ssa_params; eauto.
-        intros. 
-        eelim (Hphicode x0); eauto.  
-        intros [args' [Hin Hsame]]. 
-        eelim H3; eauto. 
-      * eelim (Hphicode x0); eauto.  
-        intros [args' [Hin Hsame]]. 
-        eelim H3; eauto. 
-Qed.
-
-Lemma gamma_step_phi: forall (f:function) (WFF: wf_ssa_function f) ge sp pc pc' phib k rs,
-  reached f pc ->
-  exec f pc ->
-  
-  (fn_code f) ! pc = Some (Inop pc') ->
-  (fn_phicode f) ! pc' = Some phib ->
-  index_pred (Kildall.make_predecessors (fn_code f) successors_instr) pc pc' = Some k ->
-  
-  gamma GVN f ge sp pc rs ->
-  gamma GVN f ge sp pc' (phi_store k phib rs).
-Proof.
-  intros f WFF ge sp pc pc' phib k rs Hreached Hexe Hcode Hphi Hpred HGamma. 
-  intros x Hx He; simpl.    
-  destruct (classic (assigned_phi_spec (fn_phicode f) pc' x)) as [HCase | HCase].
-  - invh assigned_phi_spec. invh ex. allinv.
-    exploit fn_phiargs; eauto. intros [arg Harg]. 
-    destruct (GVN_spec_True f WFF) as [_ GSPEC].
-    specialize GSPEC with pc'.
-    unfold repr_spec_phicode in * ; rewrite Hphi in GSPEC.
-    edestruct (GSPEC x) as [CC | CC]; go. 
-    + rewrite CC at 1. 
-      constructor.
-      erewrite phi_store_copy2 ; eauto.
-    + repeat invh ex ; repeat invh and.
-      clear GSPEC.
-      assert (ARG' : exists arg', nth_error x1 k = Some arg'). 
-      { eapply nth_error_some_same_length ; eauto. 
-        generalize H2. clear. 
-        induction 1 ; go. } 
-      invh ex.
-      edestruct wf_ssa_use_phi_dsd; go.
-      * assert (HG2 := HGamma x2 H3 Hexe). 
-        { edestruct wf_ssa_use_phi_dsd with (arg:= arg); go.
-          - eapply upc_intro with (3:= Harg); eauto.
-          - assert (HG2' := HGamma arg H4 Hexe). 
-            inv HG2. inv HG2'.
-            replace (OptInv.A_r GVN f arg) with (OptInv.A_r GVN f x2) 
-              in * by (symmetry ; eapply same_repr_nth_error; eauto).  
-            econstructor; eauto.
-            erewrite phi_store_copy2 ; eauto.
-            erewrite phi_store_copy2 with (dst:= A_r f x) (arg:= x2) ; eauto.
-            congruence.
-          - inv HG2. 
-            econstructor; eauto.
-            erewrite phi_store_copy2 ; eauto.
-            erewrite phi_store_copy2 with (dst:= A_r f x) (arg:= x2) ; eauto.
-            replace (OptInv.A_r GVN f x2) with (A_r f arg) 
-              in * by (eapply same_repr_nth_error; eauto).
-            exploit params_Top; eauto. intros; invh is_at_Top; congruence.
-        } 
-      * exploit params_Top; eauto; intros.
-        econstructor.
-        erewrite phi_store_copy2 ; eauto.
-        erewrite phi_store_copy2 with (dst:= A_r f x) (arg:= x2) ; eauto.
-        inv H4. 
-        exploit (ssa_use_exists_def f WFF arg pc); go.
-        econstructor 2; eauto.
-        eapply upc_intro with (2:= H1); eauto. intros [d Hd].
-        exploit same_fn_code3; eauto.
-        rewrite <- H5. eapply same_repr_nth_error; eauto. 
-        congruence.
-      
-  - destruct (peq pc (fn_entrypoint f)); subst.
-    * exploit dsd_entry_ext_param; eauto. intros Hext_param.
-      exploit params_Top; eauto. intro TOP.
-      eapply G_top; eauto.
-    * exploit (dsd_pred_njp f WFF pc pc' x) ; eauto.
-      go.
-      intros [Hcase1 | [Hcase2 | Hcase3]]; repeat invh and; try congruence.
-    + edestruct (GVN_spec_True f WFF) as [C PC].
-      assert (ext_params f x 
-              \/ (exists pc', assigned_code_spec (fn_code f) pc' x)
-              \/ exists pc', assigned_phi_spec (fn_phicode f) pc' x).
-        { inv Hx; go.
-          inv H1; go.
-        }            
-      { destruct H1 as [ Hparams | [[ dx Hdx] | [dx Hdx]]].
-        - exploit params_Top; eauto. intros. eapply G_top; eauto. 
-        - unfold repr_spec_code in *.
-          specialize PC with pc'.
-          unfold repr_spec_phicode in *.
-          rewrite Hphi in *. clear H0.
-          specialize (C dx). 
-          inv Hdx; flatten C; try solve [eapply G_top; eauto].
-          destruct C.
-          + constructor. 
-            rewrite phi_store_notin_preserved; eauto.
-            rewrite phi_store_notin_preserved; eauto.
-            rewrite <- H0 at 1. 
-            reflexivity.
-            intros args' Hcont. eelim HCase; go.
-            rewrite <- H0. econstructor; eauto.
-          + repeat invh ex; repeat invh and.
-            constructor. 
-            rewrite phi_store_notin_preserved; eauto.
-            rewrite phi_store_notin_preserved; eauto.
-            exploit HGamma ; eauto.
-            intros. inv H4; go.
-            intros args' Hcont.
-            eelim assigned_code_and_phi; eauto.
-        - assert (PCx:= PC dx). 
-          inv Hdx. unfold repr_spec_phicode in *. flatten PC. 
-          constructor. 
-          rewrite phi_store_notin_preserved; eauto.
-          rewrite phi_store_notin_preserved; eauto.
-          exploit HGamma ; eauto.
-          intros. inv H1; go.
-          intros args' Hcont.
-          invh ex.
-          eelim (PCx x x0); eauto.
-          * intros. 
-            eelim HCase; go.
-            rewrite <- H2. econstructor; eauto. 
-          * intros [args_r [Hin HsR]]. 
-            assert (dx = pc').
-            eapply ssa_def_unique; eauto. subst.
-            eelim HCase; go.
-      }          
-    + inv Hx; try congruence. clear H4.
-      assert (def_x = pc) by (eapply ssa_def_unique; eauto); subst. 
-      inv H; try congruence. 
-      unfold fn_code in *.
-      invh assigned_code_spec; try congruence. 
-Qed.      
-
-Lemma same_fn_code1 : forall f (WFF: wf_ssa_function f) pc res,
-    (forall op args res pc', (fn_code f) ! pc <> Some (Iop op args res pc')) ->
-    assigned_code_spec (fn_code f) pc res -> is_at_Top (A_r f) res.
-Proof.
-  intros.
-  destruct (GVN_spec_True f WFF) as [Hcode _ _].
-  specialize Hcode with pc.
-  unfold repr_spec_code in *. 
-  invh assigned_code_spec ; 
-    match goal with 
-      | id : (fn_code f) ! _ = Some _ |- _ => 
-        rewrite id in *; go
-    end.
-Qed.
-
-Lemma def_not_top_dsd : forall f (WFF: wf_ssa_function f) x dx,
-                          assigned_code_spec (fn_code f) dx x ->
-                          x <> A_r f x ->
-                          dsd f (A_r f x) dx.
-Proof.
-  intros f WFF x dx Dx xRx.
-  destruct (GVN_spec_True f WFF) as [Hcode Hpcode _].
-  specialize Hcode with dx.
-  unfold repr_spec_code in *. 
-  invh assigned_code_spec; 
-    match goal with 
-      | id: (fn_code f) ! _ = Some _ |- _ =>
-        rewrite id in *
-    end;
-    try solve [invh is_at_Top; congruence].
-  invh or ; try solve [congruence].
-  repeat invh ex ; repeat invh and.
-  eapply def_sdom_dsd; eauto.
-Qed.
-
-Lemma Iop_correct : forall f (WF: wf_ssa_function f) pc sf op args res pc' v rs ge sp m x,
-                    forall (SINV: s_inv ge (State sf f sp pc rs m)),
-                      (fn_code f) ! pc = Some (Iop op args res pc') ->
-                      eval_operation ge sp op rs ## args m = Some v ->
-                      gamma GVN f ge sp pc rs ->
-                      exec  f pc ->
-                      dsd f x pc' ->
-                      G ge sp rs # res <- v (A_r f x) (rs # res <- v) !! x.
-Proof.
-  intros. 
-  destruct (peq x res).
-  - subst. 
-    rewrite PMap.gss; eauto.
-    destruct (peq res (A_r f res)).
-    * rewrite <- e. econstructor; eauto.
-      rewrite PMap.gss; eauto.
-    * destruct (GVN_spec_True f WF) as [Hcode _]. 
-      specialize Hcode with pc.
-      unfold repr_spec_code in Hcode.
-      rewrite H in Hcode. 
-      { destruct Hcode as [Htop | Hntop].
-        - inv Htop; congruence.
-        - repeat invh ex ; repeat invh and.
-          econstructor; eauto.
-          rewrite PMap.gso; auto.
-          
-          assert (HE:[f,ge,sp,rs]|=(A_r f res)==(Iop op x1 (A_r f res) x0))
-            by (inv SINV; eapply SINV0 ; eauto). 
-          inv HE. invh SSAinv.eval.
-          rewrite op_depends_on_memory_correct with (m2:= m) in EVAL; auto.
-          
-          assert (Heval : eval_operation ge sp op rs ## args m = 
-                          eval_operation ge sp op rs ## x1 m).
-          { eapply G_list_eval_op; eauto.
-            eapply gamma_v_args; eauto.
-            assert (gamma GVN f ge sp x rs) by (eapply  gamma_sdom_gamma; eauto).
-            assert (Heq : map (OptInv.A_r GVN f) args = map (OptInv.A_r GVN f) x1) 
-              by (eapply same_repr_map; eauto).
-            rewrite Heq at 1.
-            eapply gamma_v_args in H5; eauto.
-          }             
-          congruence.
-      }
-  - exploit (dsd_pred_not_join_point f WF pc pc' x); eauto.          
-    go.
-    + intro contra. eapply fn_normalized with (pc := pc) in contra; eauto. 
-      * unfold fn_code in *; congruence. 
-      * unfold successors, Kildall.successors_list. 
-        rewrite PTree.gmap1. unfold option_map.
-        unfold fn_code in *.
-        rewrite H. auto. 
-    + intros [Hcase1 | [ Hcase2 | Hcase3]]; invh and; try congruence.
-      * exploit params_Top; go. intros.
-        eapply G_top; eauto.
-      * assert (HX: exists def_x, def f x def_x) by (invh dsd; go).
-        destruct HX as [dx Dx].
-        exploit (H1 x); eauto. intros HGx.
-        assert ((A_r f x) <> res). 
-        { intro Hcont. subst. 
-          assert (assigned_code_spec (fn_code f) pc (A_r f x)) by go.
-          assert (Hrx: dsd f (A_r f x) dx).
-          { eapply def_not_top_dsd; eauto. 
-            inv Dx; auto.
-            - exploit params_Top; eauto ; intros; invh is_at_Top; congruence.
-            - destruct (GVN_spec_True f WF) as [_ Hpcode].
-              specialize Hpcode with dx.
-              inv H7. unfold repr_spec_phicode in *.
-              rewrite H8 in *.
-              invh ex.
-              eelim (Hpcode x); eauto.
-              + intros. rewrite H9 in *. congruence.
-              + intros.
-                repeat invh ex ; repeat invh and.
-                eelim assigned_code_and_phi; eauto. 
-          }
-          inv Hrx.
-          * ssa_def. inv H4; repeat ssa_def.
-            eelim (elim_sdom_sdom peq); eauto.
-            inv H8. congruence. 
-          * eelim assigned_code_and_phi; eauto.
-        } 
-        econstructor; eauto.
-        repeat rewrite PMap.gso; auto. inv HGx; auto.
-      * unfold fn_code in *.
-        invh assigned_code_spec; try congruence.
-Qed.    
-
-Lemma G_upd_diff_help : forall f ge sp rs dst x v,
-                          x <> dst ->
-                          (G ge sp rs (A_r f x) rs !! x) ->
-                          G ge sp rs # dst <- v (A_r f x) rs !! x \/
-                          ~ is_at_Top (A_r f) x.
-Proof.
-  intros.
-  destruct (peq (A_r f x) dst).
-  - subst. right. intro Hcont. inv Hcont. congruence.
-  - left. econstructor; eauto. 
-    rewrite PMap.gso; auto.
-    invh G; auto.
-Qed.
-        
-Lemma G_upd_diff : forall f (WF: wf_ssa_function f) ge sp rs dst x v,
-                     x <> dst ->
-                     A_r f x <> A_r f dst ->
-                     (G ge sp rs (A_r f x) rs !! x) ->
-                     G ge sp rs # dst <- v (A_r f x) rs !! x.
-Proof.                     
-  intros.
-  edestruct G_upd_diff_help with (1:= H); eauto.
-  destruct (peq (A_r f x) dst).
-  - subst. generalize (GVN_spec_idempotence f (GVN_spec_True f WF)); go.
-  - econstructor; eauto. 
-    rewrite PMap.gso; auto.
-    invh G; auto.
-Qed.
-
-
diff --git a/midend/GVNoptproof.v b/midend/GVNoptproof.v
deleted file mode 100644
index 2c46ba46..00000000
--- a/midend/GVNoptproof.v
+++ /dev/null
@@ -1,513 +0,0 @@
-Require Import Classical.
-Require Import Coqlib.
-Require Import Maps.
-Require Import AST.
-Require Import Integers.
-Require Import Values.
-Require Import Memory.
-Require Import Globalenvs.
-Require Import Smallstep.
-Require Import Op.
-Require Import Events.
-Require Import Registers.
-Require Import Floats.
-Require Import Utils.
-Require Import SSA. 
-Require Import SSAutils. 
-Require Import SSAinv. 
-Require Import Utilsvalidproof.
-Require Import DomCompute.
-Require Import Axioms.
-Require Import KildallComp.
-Require Import OrderedType.
-Require Import Ordered.
-Require Import FSets.
-Require FSetAVL.
-Require Import Dsd.
-Require Import OptInv.
-Require Import GVNopt.
-Require Import GVNoptProp.
-Require Import DLib.
-
-Require Import Linking.
-
-Require Opt.
-Require OptInv.
-
-Unset Allow StrictProp.
-
-(** * Correctness of the optimization *)
-Section PRESERVATION.
-
-  Definition match_prog (p: SSA.program) (tp: SSA.program) :=
-    match_program (fun cu f tf => tf = transf_fundef f) eq p tp.
-
-  Lemma transf_program_match:
-    forall p, match_prog p (transf_program p).
-  Proof.
-    intros; subst.
-    eapply match_transform_program_contextual; auto.
-  Qed.
-
-  Section CORRECTNESS.
-
-    Variable prog: program.
-    Variable tprog: program.
-    Hypothesis TRANSL : match_prog prog tprog.
-    Hypothesis HWF : wf_ssa_program prog.
-    
-    Let ge := Genv.globalenv prog.
-    Let tge := Genv.globalenv tprog.
-
-    Lemma symbols_preserved:
-      forall (s: ident), Genv.find_symbol tge s = Genv.find_symbol ge s.
-    Proof.
-      eapply (Genv.find_symbol_transf TRANSL) ; eauto.
-    Qed. 
-
-    Lemma match_prog_wf_ssa : wf_ssa_program tprog.
-    Proof.
-      red. intros.
-      red in  HWF.
-      inv TRANSL.
-      intuition. revert H0 H HWF.
-      induction 1; intros.
-      - inv H.
-      - inv H1.      
-        + inv H. inv H4.
-          destruct f1 ; simpl in * ; try constructor; auto.
-          eapply Opt.transf_function_preserve_wf_ssa_function; eauto.
-          * eapply new_code_same_or_Iop; eauto.
-          * exploit (HWF (Internal f) id); eauto.
-            destruct a1, g; simpl in * ; try congruence. 
-            left. inv H; simpl in *; auto. 
-            intros. inv H4; auto.
-        + eapply IHlist_forall2; eauto.
-    Qed.
-
-  Lemma funct_ptr_translated:
-    forall (b: Values.block) (f: fundef),
-      Genv.find_funct_ptr ge b = Some f ->
-      Genv.find_funct_ptr tge b = Some (transf_fundef f).
-  Proof.
-    apply (Genv.find_funct_ptr_transf TRANSL).
-  Qed. 
-
-  Lemma functions_translated:
-    forall (v: val) (f: fundef),
-      Genv.find_funct ge v = Some f ->
-      Genv.find_funct tge v = Some (transf_fundef f).
-  Proof.
-    apply (Genv.find_funct_transf TRANSL).
-  Qed. 
-
-  Lemma sig_preserved:
-    forall f, funsig (transf_fundef f) = funsig f.
-  Proof.
-    destruct f;  simpl ; try reflexivity.
-  Qed.
-    
-  Lemma find_function_translated:
-    forall ros rs f,
-      find_function ge ros rs = Some f ->
-      find_function tge ros rs = Some (transf_fundef f).
-  Proof.
-    intros until f; destruct ros; simpl.
-    intro. apply functions_translated; auto.
-    rewrite symbols_preserved. destruct (Genv.find_symbol ge i); intro.
-    apply funct_ptr_translated; auto.
-    discriminate.
-  Qed.
-  
-  Lemma fn_params_translated : forall (f:function), 
-     fn_params f = fn_params (transf_function f).
-  Proof.
-    intros ; unfold transf_function ; simpl; auto.
-  Qed.
-
-  Lemma fn_entrypoint_translated : forall (f:function),
-     fn_entrypoint f = fn_entrypoint (transf_function f).
-  Proof.
-    intros ; unfold transf_function ; simpl; auto.
-  Qed.
-
-  Lemma senv_equiv : Senv.equiv ge tge.
-  Proof.
-    apply (Genv.senv_transf TRANSL).
-  Qed.
-  
-  Inductive match_stackframes : list stackframe -> list stackframe -> Prop :=
-  | match_stackframes_nil: match_stackframes nil nil
-  | match_stackframes_cons: 
-    forall res (f:function) sp b pc rs s st 
-      (STACK: (match_stackframes s st))
-      (SP: sp = (Vptr b Ptrofs.zero))
-      (WFF: wf_ssa_function f)
-      (HG:forall v, gamma GVN f ge sp pc (rs# res <- v))
-      (EXE: exec f pc),
-      match_stackframes
-      ((Stackframe res f sp pc rs) :: s)
-      ((Stackframe res (transf_function f) sp pc rs) :: st).
-
-  Variant match_states: state -> state -> Prop :=
-  | match_states_intro:
-      forall s st sp b pc rs m f
-        (SP: sp = (Vptr b Ptrofs.zero))     
-        (SINV:s_inv ge (State s f sp pc rs m))
-        (HG:gamma GVN f ge sp pc rs)
-        (EXE: exec  f pc)
-        (STACK: match_stackframes s st),
-        match_states (State s f sp pc rs m) (State st (transf_function f) sp pc rs m)
-  | match_states_call:
-      forall s st f args m
-        (SINV:s_inv ge (Callstate s f args m))
-        (STACK: match_stackframes s st),
-        match_states (Callstate s f args m) (Callstate st (transf_fundef f) args m)
-  | match_states_return:
-      forall s st v m 
-        (SINV:s_inv ge (Returnstate s v m))
-        (STACK: match_stackframes s st),
-        match_states (Returnstate s v m) (Returnstate st v m).
-  
-  Lemma transf_initial_states:
-    forall st1, initial_state prog st1 ->
-                exists st2, initial_state tprog st2 /\ match_states st1 st2.
-  Proof.
-    intros. inversion H.
-    exploit @funct_ptr_translated ; eauto. intros. 
-    econstructor; split.
-    - econstructor.
-      assert (MEM: (Genv.init_mem tprog) = Some m0) by (eapply (Genv.init_mem_transf TRANSL); eauto).
-      + apply MEM ; auto.
-      + replace (prog_main tprog) with (prog_main prog). rewrite symbols_preserved; eauto.
-        symmetry; eapply match_program_main; eauto.
-      + eauto.
-      + rewrite <- H3. apply sig_preserved; auto.
-    - eapply match_states_call  ; eauto.
-      + constructor.
-        eapply Genv.find_funct_ptr_prop ; eauto.
-        constructor.
-      + constructor.
-  Qed.
-
-  Lemma transf_final_states:
-    forall st1 st2 r,
-      match_states st1 st2 -> final_state st1 r -> final_state st2 r.
-  Proof.
-    intros. inv H0. inv H. 
-    inv STACK.
-    constructor.
-  Qed.
-
-  Lemma same_fn_code: forall f pc,
-      (forall op args res pc',
-          (fn_code f) ! pc <> Some (Iop op args res pc')) ->
-      (fn_code (transf_function f)) ! pc = (fn_code f) ! pc.
-  Proof.
-    intros.
-    unfold transf_function, Opt.transf_function.
-    case_eq (analysis f); intros; simpl.
-    destruct p; simpl.
-    unfold transf_instr, transf_function; simpl.
-    rewrite PTree.gmap; simpl.
-    destruct ((SSA.fn_code f) ! pc); simpl; auto.
-    destruct i; auto.
-    flatten.
-  Qed.
-
-  Lemma new_fn_code: forall f pc op args res pc',
-      (fn_code f) ! pc = Some (Iop op args res pc') ->
-      ((fn_code (transf_function f)) ! pc = Some (Iop op args res pc'))
-      \/ (exists res',
-             (fn_code (transf_function f)) ! pc = Some (Iop Omove (res' :: nil) res pc')
-             /\ A_r f res = res' 
-             /\ res <> res').
-  Proof. 
-    intros.
-    generalize H ; intros INSTR.
-    unfold transf_function, transf_function.
-    case_eq (analysis f) ; intros lv es ANA; simpl.
-    unfold analysis in *. inv ANA.
-    erewrite PTree.gmap. 
-    unfold transf_instr. rewrite INSTR; simpl.
-    flatten; go.
-    right. exists r. simpl; repeat split; auto.
-    intro Hcont; subst.
-    eapply andb_true_iff in Eq1; eauto; invh and.
-    eapply andb_true_iff in H0; eauto; invh and.
-    destruct (peq r r); intuition.
-  Qed.
-
-  Hint Constructors ext_params dsd: core.
-
-  Lemma join_point_transf_function : forall f (WF: wf_ssa_function f) j,
-      join_point j (transf_function f) <-> join_point j f.
-  Proof.
-    intros. 
-    eapply Opt.join_point_transf_function; eauto.
-    eapply new_code_same_or_Iop; eauto.    
-  Qed.   
-  
-  Lemma make_predecessors_transf_function: forall f (WF: wf_ssa_function f),
-      (Kildall.make_predecessors (fn_code (transf_function f)) successors_instr) =
-      (Kildall.make_predecessors (fn_code f) successors_instr).
-  Proof.
-    intros.
-    eapply Opt.make_predecessors_transf_function; eauto.
-    eapply new_code_same_or_Iop; eauto.
-  Qed. 
-
-  Lemma eval_iop_correct : forall f (WF: wf_ssa_function f) m res rs sp v pc pc' args op s,
-      exec f pc ->
-      gamma GVN f ge sp pc rs ->
-      eval_operation ge sp op rs ## args m = Some v ->
-      s_inv ge (State s f sp pc rs m) ->
-      (fn_code f) ! pc = Some (Iop op args res pc') ->
-      (fn_code (transf_function f)) ! pc = Some (Iop Omove (A_r f res :: nil) res pc') ->
-      res <> A_r f res ->
-      eval_operation tge sp Omove rs ## (A_r f res :: nil) m = Some v.
-  Proof.
-    intros until s. intros EXE HG EVAL SINV CODE TCODE COND. 
-
-    assert (GG:= GVN_spec_True f WF); destruct GG as [Hc Hp  _].
-    specialize Hc with pc.
-    unfold repr_spec_code in *.
-    rewrite CODE in *. repeat invh or ; repeat invh ex ; repeat invh and.
-    - congruence.
-    - assert (HE:[f,ge,sp,rs]|=(A_r f res)==(Iop op x1 (A_r f res) x0))
-        by (inv SINV; eapply SINV0 ; eauto). 
-      inv HE. invh SSAinv.eval.
-      assert (G_list GVN ge sp rs (map (A_r f) args) (rs## args))
-        by (eapply gamma_v_args; eauto).
-      assert (G_list GVN ge sp rs (map (A_r f) x1) (rs## x1)).
-      { assert (gamma GVN f ge sp x rs) by (eapply  gamma_sdom_gamma; eauto).
-        eapply gamma_v_args in H; go.
-        auto. 
-        go.
-      }             
-      assert (map (A_r f) x1 = map (A_r f) args)
-        by (symmetry; eapply same_repr_map; eauto).
-      rewrite <- EVAL.
-      simpl. simpl in EVAL0.
-      rewrite <- EVAL0.
-      rewrite op_depends_on_memory_correct with (m2:= m); auto.
-      rewrite H7 in *. eapply G_list_eval_op; eauto.
-  Qed.
-
-  Lemma match_stackframes_sfg_inv : forall s st, 
-      match_stackframes s st ->
-      sfg_inv GVN prog s.
-  Proof.
-    induction 1 ; go.
-  Qed.
-
-  Hint Resolve match_stackframes_sfg_inv: core.
-
-  Lemma subj_red_gamma : forall prog (WFP: wf_ssa_program prog),
-      forall (f f' : function)
-             (t : trace) (m m' : mem) 
-             (rs rs' : regset) sp sp' (pc pc' : node)
-             (s s' : list stackframe),
-        gamma GVN f (Genv.globalenv prog) (Vptr sp Ptrofs.zero) pc rs ->
-        sfg_inv GVN prog s ->
-        exec f pc ->
-        s_inv (Genv.globalenv prog) (State s f (Vptr sp Ptrofs.zero) pc rs m) ->
-        step (Genv.globalenv prog) (State s f (Vptr sp Ptrofs.zero) pc rs m) t
-             (State s' f' (Vptr sp' Ptrofs.zero) pc' rs' m') ->
-        gamma GVN f' (Genv.globalenv prog) (Vptr sp' Ptrofs.zero) pc' rs'.
-  Proof.
-    intros. 
-    eapply subj_red_gamma; eauto.
-    - intros; eapply same_fn_code1; eauto.
-    - intros; eapply G_upd_diff; eauto.
-    - intros; eapply Iop_correct; eauto.
-    - intros; eapply gamma_step_phi; eauto.    
-    - intros; flatten ; go.
-  Qed. 
-
-  Lemma transl_step_correct:
-    forall s1 t s2,
-      step ge s1 t s2 ->
-      step ge s1 t s2 ->
-      forall s1' (MS: match_states s1 s1'),
-      exists s2', step tge s1' t s2' /\ match_states s2 s2'.
-  Proof.
-    assert (Hwf1: forall s f sp pc rs m, s_inv ge (State s f sp pc rs m) ->
-                                         wf_ssa_function f) by (intros s f sp pc rs m H; inv H; auto).
-
-    induction 1; intros; inv MS; auto.
-
-    -  (* Inop not jnp *)
-      exists (State st (transf_function f) (Vptr b Ptrofs.zero) pc' rs m); split;
-        [idtac  | econstructor; [reflexivity|eapply SSAinv.subj_red; eauto|eauto|eauto|eauto]]; 
-        try solve [eapply subj_red_gamma; eauto].
-      eapply exec_Inop_njp; eauto.
-      rewrite same_fn_code; [auto|congruence].
-      rewrite join_point_transf_function; auto.
-      invh s_inv ; eauto.
-
-    - (* Inop jnp *)
-      exists (State st (transf_function f) (Vptr b Ptrofs.zero) pc' (phi_store k phib rs) m); split;
-        [idtac| econstructor; [reflexivity|eapply SSAinv.subj_red; eauto|eauto|eauto|eauto]];
-        try solve [eapply subj_red_gamma; eauto].
-      eapply exec_Inop_jp; eauto.
-      rewrite same_fn_code; [auto|congruence].
-      rewrite join_point_transf_function; auto.
-      invh s_inv ; eauto.
-      rewrite make_predecessors_transf_function; auto. 
-      invh s_inv ; eauto.
-      
-    - (* Iop *) 
-      exists (State st (transf_function f) (Vptr b Ptrofs.zero) pc' rs# res<-v  m); split;
-        [idtac| econstructor; [reflexivity|eapply SSAinv.subj_red; eauto|eauto|eauto|eauto]];
-        try solve [eapply subj_red_gamma; eauto].
-      exploit new_fn_code; eauto; destruct 1 as [Hi|[res' [d [Hi2 Hi3]]]]. 
-      + eapply exec_Iop; eauto.
-        erewrite eval_operation_preserved; eauto.
-        apply symbols_preserved; auto.
-      + eapply exec_Iop; eauto. subst.
-        eapply eval_iop_correct; eauto.
-
-    - (* Iload *) 
-      exists (State st (transf_function f) (Vptr b Ptrofs.zero) pc' rs# dst<-v m); split;
-        [idtac| econstructor; [reflexivity|eapply SSAinv.subj_red; eauto|eauto|auto|eauto]];
-        try solve [eapply subj_red_gamma; eauto].
-      eapply exec_Iload; eauto;
-        first [ rewrite same_fn_code; [eauto|congruence]
-              | (erewrite eval_addressing_preserved; eauto);  
-                (apply symbols_preserved; auto)].
-      
-    - (* Istore *) 
-      exists (State st (transf_function f) (Vptr b Ptrofs.zero) pc' rs m'); split;
-        [idtac| econstructor; [reflexivity|eapply SSAinv.subj_red; eauto|eauto|eauto|eauto;fail]];
-        try solve [eapply subj_red_gamma; eauto].
-      eapply exec_Istore; eauto;
-        first [ rewrite same_fn_code; [eauto|congruence]
-             | (erewrite eval_addressing_preserved; eauto);
-               (apply symbols_preserved; auto)].
-      
-    - (* Icall *)
-      assert (WF: wf_ssa_function f) by (invh s_inv ; eauto).
-      exists (Callstate (Stackframe res (transf_function f) (Vptr b Ptrofs.zero) pc' rs :: st)
-                        (transf_fundef fd) rs ## args m); split;
-        [idtac| econstructor; [try eapply subj_red_gamma; eauto|econstructor; auto]].
-      + eapply exec_Icall with (ros := ros); eauto.
-        rewrite same_fn_code; [auto | congruence]. 
-        simpl; rewrite sig_preserved; eauto. 
-        eapply find_function_translated; eauto.
-      + eapply SSAinv.subj_red; eauto. 
-      + intros v x Hyp1 Hyp2.
-        { destruct (peq x res).
-          - subst. exploit (same_fn_code1 f WF pc); go. 
-            eapply G_top; eauto. 
-          - rewrite PMap.gso; auto.
-            exploit (HG x); eauto. 
-            * destruct dsd_pred_njp with f pc pc' x as 
-                  [[Dx Dx']|[[Dx [Dx' Dx'']]|[Dx Dx']]]; simplify_dsd; eauto.
-              invh wf_ssa_function ; eauto.
-              intro; subst; edestruct fn_entry; congruence.
-              go.
-              eelim ssa_not_Inop_not_phi; eauto; go. 
-            * intros HG'. inv HG'.
-              econstructor; eauto. 
-              rewrite PMap.gso; auto.
-              intros Hcont.
-              simpl in *. 
-              exploit (same_fn_code1 f WF pc); go.
-              intros; invh is_at_Top; go.
-        }
-
-    - (* Itailcall *)
-      exists (Callstate st (transf_fundef fd) rs ## args m'); split.
-      eapply exec_Itailcall with (ros := ros); eauto.
-      rewrite same_fn_code; [eauto|congruence].
-      simpl; rewrite sig_preserved; eauto. 
-      eapply find_function_translated; eauto.
-      constructor; auto.
-      eapply SSAinv.subj_red; eauto.
-
-    - (* Ibuiltin *)
-      exists (State st (transf_function f) (Vptr b Ptrofs.zero) pc' (regmap_setres res vres rs) m'); split;
-        [idtac| econstructor; [reflexivity|eapply SSAinv.subj_red; eauto|eauto|eauto|eauto]];
-        try solve [eapply subj_red_gamma; eauto].
-      eapply exec_Ibuiltin with (args:= args); eauto.
-      erewrite (same_fn_code f pc) ; eauto; try congruence.
-      eapply eval_builtin_args_preserved in H0; eauto.
-      apply symbols_preserved; auto.
-      eapply external_call_symbols_preserved; eauto.
-      eapply senv_equiv.
-      
-    - (* Icond, true *)
-      exists (State st (transf_function f) (Vptr b Ptrofs.zero) ifso rs m); split;
-        [idtac| econstructor; [reflexivity|eapply SSAinv.subj_red; eauto|auto|eauto|eauto;fail]];
-        try solve [eapply subj_red_gamma; eauto].
-      eapply exec_Icond_true; eauto.
-      rewrite same_fn_code; [eauto|congruence].
-      
-    - (* Icond, false *)
-      exists (State st (transf_function f) (Vptr b Ptrofs.zero) ifnot rs m); split;
-        [idtac| econstructor; [reflexivity|eapply SSAinv.subj_red; eauto|eauto|eauto|eauto;fail]];
-        try solve [eapply subj_red_gamma; eauto].
-      eapply exec_Icond_false; eauto.
-      rewrite same_fn_code; [eauto|congruence].
-
-    - (* Ijumptable *)
-      exists (State st (transf_function f) (Vptr b Ptrofs.zero) pc' rs m); split;
-        [idtac| econstructor; [reflexivity|eapply SSAinv.subj_red; eauto|eauto|eauto|eauto;fail]];
-        try solve [eapply subj_red_gamma; eauto].
-      eapply exec_Ijumptable; eauto. 
-      rewrite same_fn_code; [eauto|congruence].
-      
-    - (* Ireturn *)
-      exists (Returnstate st (regmap_optget or Vundef rs) m'); split;
-        [idtac| econstructor; eauto].  
-      econstructor; eauto.
-      rewrite same_fn_code; [eauto|congruence].
-      eapply SSAinv.subj_red; eauto.
-
-    - (* internal function *)
-      assert (WF: wf_ssa_function f) by (invh s_inv ; invh wf_ssa_fundef ; eauto).
-      exists (State st (transf_function f) (Vptr stk Ptrofs.zero) 
-                    (fn_entrypoint (transf_function f)) 
-                    (init_regs args (fn_params (transf_function f))) m'); split.
-      + econstructor; eauto.
-      + rewrite <- fn_entrypoint_translated; eauto.
-        rewrite <- fn_params_translated; eauto.
-        econstructor; eauto.
-        * eapply SSAinv.subj_red; eauto.
-        * unfold gamma in *; intros x Hyp1.
-          exploit ssa_dsd_entry ; eauto.
-          intros. 
-          exploit gamma_entry; eauto.
-        * go.  
-          
-    - (* external function *)
-      exists (Returnstate st res m'); split.
-      econstructor; eauto.
-      eapply external_call_symbols_preserved; eauto.
-      eapply senv_equiv; eauto.
-      econstructor; eauto.
-      eapply SSAinv.subj_red; eauto.
-
-    - (* return *)
-      inv STACK.
-      exists (State st0 (transf_function f) (Vptr b Ptrofs.zero) pc rs # res <- vres m); split.
-      econstructor; eauto.
-      econstructor; eauto.
-      eapply SSAinv.subj_red; eauto.
-  Qed.
-
-  (** * Semantics preservation *)
-  Theorem transf_program_correct:
-    forward_simulation (SSA.semantics prog) (SSA.semantics tprog).
-  Proof.
-    eapply forward_simulation_step.
-    - eapply senv_equiv; eauto.
-    - eexact transf_initial_states.
-    - eexact transf_final_states.
-    - eauto using transl_step_correct. 
-  Qed.
-
-  End CORRECTNESS.
-  
-End PRESERVATION.
diff --git a/midend/Opt.v b/midend/Opt.v
deleted file mode 100644
index d634009c..00000000
--- a/midend/Opt.v
+++ /dev/null
@@ -1,603 +0,0 @@
-Require Import Coqlib.
-Require Import Maps.
-Require Import AST.
-Require Import Op.
-Require Import Registers.
-Require Import Utils.
-Require Import Integers.
-Require Import Floats.
-Require Import Classical.
-Require Import Lattice.
-Require Import Iteration.
-Require Import DLib.
-Require Import Kildall.
-Require Import KildallComp.
-Require Import Dom.
-Require Import SSA.
-Require Import SSAutils.
-
-(** This file defines a generic program optimization.  In our SSA
- middle-end, we instantiate this to SCCP and GVN-CSE, but in general,
- it could also be instantiated to any intra-procedural, scala
- optimization. *)
-
-(** The optimization can be "conditional", hence we define the type
-[m_exec] for storing executable flag for CFG edges. *)
-
-Definition m_exec := P2Map.t bool.
-
-Section Opt.
-
-(** * Definition of the optimization *)
-Variable res : Type.
-Variable analysis : function -> (res * m_exec).
-Variable transf_instr : res -> node -> instruction -> instruction.
-
-Definition transf_function (f : function) : SSA.function :=
-  let (res,m_ex) := analysis f in
-  mkfunction
-     f.(fn_sig)
-     f.(fn_params)
-     (fn_stacksize f)
-     (PTree.map (transf_instr res) (fn_code f))
-     f.(fn_phicode)
-     f.(fn_entrypoint)
-     f.(fn_ext_params)
-     f.(fn_dom_test)
-.
-
-(** * Proof that it preserves the wf_ssa_function predicate *)
-Hypothesis new_code_same_or_Iop : forall f:function,
-  wf_ssa_function f ->
-  forall pc ins,
-    (fn_code f)!pc = Some ins ->
-    transf_instr (fst (analysis f)) pc ins = ins
-    \/ match ins with
-         | Iop _ _ dst pc' 
-         | Iload _ _ _ dst pc'
-         | Icall _ _ _ dst pc'
-         | Ibuiltin _ _ (BR dst) pc' =>
-           exists op' args',
-           transf_instr (fst (analysis f)) pc ins = Iop op' args' dst pc'
-           /\ forall x, In x args' -> exists d : node, def f x d /\ sdom f d pc
-         | _ => False
-       end.
-
-Lemma fn_params_transf_function : forall f,
-  fn_params (transf_function f) = fn_params f.
-Proof.
-  unfold transf_function; eauto. 
-  intros. destruct (analysis f) ; eauto.
-Qed.
-
-Lemma fn_phicode_transf_function : forall f,
-  fn_phicode (transf_function f) = fn_phicode f.
-Proof.
-  unfold transf_function; auto. 
-  intros. destruct (analysis f) ; eauto.
-Qed.
-
-Lemma fn_entrypoint_transf_function : forall f,
-  fn_entrypoint (transf_function f) = fn_entrypoint f.
-Proof.
-  unfold transf_function; auto. 
-  intros. destruct (analysis f) ; eauto.
-Qed.
-
-Lemma fn_code_transf_function : forall (f:function) pc ins,
- (fn_code f)!pc = Some ins ->
- exists ins, (SSA.fn_code (transf_function f))!pc = Some ins.
-Proof.
-  simpl. intros. 
-  unfold transf_function. 
-  destruct (analysis f); simpl.
-  rewrite PTree.gmap in *.
-  rewrite H. simpl. 
-  eexists; eauto.
-Qed.
-
-Lemma fn_code_transf_function' : forall f pc ins,
-  (SSA.fn_code (transf_function f))!pc = Some ins ->
-  exists ins, (fn_code f)!pc = Some ins.
-Proof.
-  simpl. intros. 
-  unfold transf_function in *. 
-  destruct (analysis f); simpl in *.
-  rewrite PTree.gmap in *.
-  destruct ((fn_code f)!pc); eauto.
-Qed.
-
-Hint Constructors assigned_code_spec: core.
-
-Lemma assigned_phi_spec_same : forall (f:function) pc r,
-  assigned_phi_spec (f.(fn_phicode)) pc r <->
-  assigned_phi_spec ((transf_function f).(fn_phicode)) pc r.
-Proof.
-  intros. 
-  unfold transf_function in *. 
-  destruct (analysis f); simpl in *.
-  reflexivity.
-Qed.
-
-Definition assigned_code_spec2 (code : code) (pc : node) (x:reg) : Prop :=
-  match code!pc with
-    | Some (Iop _ _ dst succ) 
-    | Some (Iload _ _ _ dst succ) 
-    | Some (Icall _ _ _ dst succ) => dst = x
-    | Some (Ibuiltin _ _ (BR dst) succ) => dst = x
-    | _ => False
-  end.
-
-Lemma assigned_code_spec_equiv : forall code pc r,
-  assigned_code_spec code pc r <->
-  assigned_code_spec2 code pc r.
-Proof.
-  split; intros H.
-  - inv H ; unfold assigned_code_spec2; rewrite H0; auto.    
-  - unfold assigned_code_spec2 in *.
-    flatten H; go.
-Qed.
-
-Lemma assigned_code_spec_same : forall (f:function) (Hwf:wf_ssa_function f) pc r,
-  assigned_code_spec (fn_code f) pc r <->
-  assigned_code_spec ((transf_function f).(SSA.fn_code)) pc r.
-Proof.
-  intros f Hwf pc r.
-  repeat rewrite assigned_code_spec_equiv.
-  unfold transf_function, assigned_code_spec2; simpl; intros.
-  case_eq (analysis f) ; intros lv es Ha ;  simpl in *.
-  rewrite PTree.gmap.
-  destruct ((fn_code f)!pc) eqn:E; simpl; try tauto.
-  destruct (new_code_same_or_Iop f Hwf pc i) as [Hi | Hi]; auto.
-  - rewrite Ha in Hi; simpl in * ; rewrite Hi; tauto.
-  - rewrite Ha in Hi; simpl in * .
-    flatten Hi; try (elim Hi; fail); destruct Hi as (op' & args' & Hi & Hi2); rewrite Hi; tauto.
-Qed.
-
-
-Lemma use_code_transf_function: forall f:function,
-  wf_ssa_function f -> forall x u,
-  use_code (transf_function f) x u -> 
-  use_code f x u \/ exists d, def f x d /\ sdom f d u.
-Proof.
-  intros f H x u H0.
-  inv H0;
-  simpl in H1;
-  unfold transf_function in *;
-  case_eq (analysis f) ; intros lv es Ha ; rewrite Ha in * ; simpl in *;
-  rewrite PTree.gmap in H1;
-  destruct ((fn_code f)!u) eqn:E; try (inv H1; fail);
-  simpl in H1;
-  (destruct (new_code_same_or_Iop f H u i) as [Hi | Hi]; auto;
-   [left;
-    rewrite Ha in * ; simpl in * ;
-    rewrite Hi in H1;
-    rewrite <- E in H1;
-    go
-   |idtac]);
-  destruct i; 
-    try (elim Hi; fail); try (destruct b ; try intuition auto) ; try (destruct Hi as (op' & args' & Hi1 & Hi2);
-        try (rewrite Ha in * ; simpl in *) ; 
-        try (rewrite Ha in * ; simpl in * ; congruence);
-        right; apply Hi2; congruence).                              
-Qed.
-
-Lemma new_code: forall pc ins (f:function) (Hwf:wf_ssa_function f),
-  (fn_code f)!pc = Some ins ->                  
-  successors_instr ins = successors_instr (transf_instr (fst (analysis f)) pc ins).
-Proof.
-  intros pc ins f Hwf Hi.
-  destruct (new_code_same_or_Iop f Hwf pc ins); auto.
-  - rewrite H; auto.
-  - destruct ins; try (elim H; fail); try (destruct b ; try intuition auto) ; destruct H as (op' & args' & H1 & H2); rewrite H1; auto.
-Qed.
-
-Hint Constructors use_code: ssa.
-Hint Constructors use: ssa.
-
-Lemma successors_transf_function: forall (f:function) (Hwf:wf_ssa_function f) pc,
-  (successors (transf_function f))!pc = (successors f)!pc.
-Proof.
-  unfold successors; intros.
-  unfold transf_function.
-  case_eq (analysis f) ; intros lv es Ha ; simpl in *.
-  repeat rewrite PTree.gmap1.
-  unfold option_map.
-  rewrite PTree.gmap.
-  unfold option_map.  
-  flatten.
-  replace lv with (fst (analysis f)) by (rewrite Ha ; auto).  
-  erewrite <- new_code; eauto.
-Qed.
-
-Lemma join_point_transf_function : forall (f:function) (Hwf:wf_ssa_function f) j,
-  join_point j (transf_function f) <-> join_point j f.
-Proof.
-  split; intros.
-  - inv H. 
-    erewrite @same_successors_same_predecessors with 
-        (m2:= (fn_code f))
-        (f2:= successors_instr) in Hpreds; eauto.
-    + econstructor; eauto.
-    + eapply successors_transf_function; eauto.
-  - inv H.
-    erewrite @same_successors_same_predecessors with 
-        (m2:= (SSA.fn_code (transf_function f)))
-        (f2:= successors_instr) in Hpreds; eauto.
-    + econstructor; eauto.
-    + generalize (successors_transf_function f).
-      unfold successors. intros Hsuccs i. 
-      rewrite Hsuccs at 1; auto.
-Qed.
-
-Lemma make_predecessors_transf_function: forall (f:function) (Hwf:wf_ssa_function f),
-  (Kildall.make_predecessors (SSA.fn_code (transf_function f)) successors_instr) =
-  (Kildall.make_predecessors (fn_code f) successors_instr).
-Proof.
-  intros.
-  eapply same_successors_same_predecessors.
-  apply successors_transf_function; auto.
-Qed.
-
-Lemma successors_list_transf_function: forall (f:function) (Hwf:wf_ssa_function f) pc,
-  (Kildall.successors_list (successors (transf_function f)) pc) =
-  (Kildall.successors_list (successors f) pc).
-Proof.
-  unfold Kildall.successors_list; intros.
-  rewrite successors_transf_function; auto.
-Qed.
-
-Lemma use_phicode_transf_function: forall f:function,
-  wf_ssa_function f -> forall x u,
-  use_phicode (transf_function f) x u -> 
-  use_phicode f x u.
-Proof.
-  intros f H x u H0.
-  inv H0.
-  simpl in PHIB.
-  replace (Kildall.make_predecessors (SSA.fn_code (transf_function f))
-               successors_instr) with
-          (Kildall.make_predecessors (fn_code f) successors_instr) in KPRED.
-  - unfold transf_function in *  ; destruct analysis ; go.
-  - rewrite make_predecessors_transf_function; auto.
-Qed.
-
-Lemma use_transf_function: forall (f:function) x u, 
-  wf_ssa_function f ->
-  use (transf_function f) x u -> 
-  use f x u \/ exists d, def f x d /\ sdom f d u.
-Proof.
-  intros f x u H H0.
-  inv H0.
-  - edestruct use_code_transf_function; eauto.
-    left; go.
-  - apply use_phicode_transf_function in H1; go.
-Qed.
-
-Lemma def_transf_function: forall (f:function) x d, 
-  wf_ssa_function f ->
-  def (transf_function f) x d -> def f x d.
-Proof.
-  intros f.
-  unfold transf_function in * ;
-  case_eq (analysis f) ; intros lv es Ha.
-  intros x d H H1; inv H1; simpl; go.
-  - inv H0; go.
-    simpl in *.
-    destruct H1 as (pc & Hpc).
-    edestruct use_transf_function; eauto.
-    unfold transf_function ; rewrite Ha ; simpl; eauto.
-    + econstructor 1; eauto.
-      econstructor 2; eauto.
-      replace (SSA.fn_code f) with (fn_code f).
-      intros; rewrite assigned_code_spec_same; auto.
-      unfold transf_function ; rewrite Ha ; simpl; eauto.
-      reflexivity.
-
-    + destruct H0 as (d & Hd & Hs).
-      inv Hd; go.
-      * eelim (H3 d). 
-        simpl. 
-        assert (Has:= (assigned_code_spec_same f H d x)); eauto.
-        unfold transf_function in * ; rewrite Ha in * ; simpl in *; auto.
-        eapply Has; auto.
-      * eelim (H2 d). 
-        assert (Has:= (assigned_phi_spec_same f d x)); eauto.
-  - simpl in *. 
-    assert (Has:= (assigned_code_spec_same f H d x)); eauto.
-    unfold transf_function in * ; rewrite Ha in * ; simpl in *; auto.
-    eapply Has in H0; auto.
-Qed.
-  
-
-Lemma cfg_transf_function : forall (f:function) (Hwf:wf_ssa_function f) i j,
-  cfg f i j <-> cfg (transf_function f) i j.
-Proof.
-  intros f i j.
-  split; intros.
-  - inv H. 
-    exploit fn_code_transf_function ; eauto. 
-    intros [ins' Hins'].
-    intros. unfold transf_function in *.
-    case_eq (analysis f) ; intros lv es Ha ; simpl in *.
-    rewrite Ha in * ; simpl in *.    
-    econstructor; simpl; eauto.
-    rewrite PTree.gmap in *.
-    unfold fn_code in *.
-    unfold option_map in *. rewrite HCFG_ins in *.
-    inv Hins'.
-    replace lv with (fst (analysis f)) in * by (rewrite Ha ; auto). 
-    erewrite <- new_code; eauto.
-  - inv H.
-    exploit fn_code_transf_function' ; eauto.
-    intros [ins' Hins'].
-    unfold transf_function in *; case_eq (analysis f) ; intros lv es Ha ;
-    rewrite Ha in * ; simpl in *.
-    econstructor; simpl; eauto.
-    rewrite PTree.gmap in *.
-    unfold option_map in *. rewrite Hins' in *.
-    inv HCFG_ins.
-    replace lv with (fst (analysis f)) in * by (rewrite Ha ; auto).     
-    erewrite new_code; eauto. 
-Qed.
-
-Lemma reached_transf_function : forall (f:function) (Hwf:wf_ssa_function f) i,
-  reached f i <-> reached (transf_function f) i.
-Proof.
-  split; intros.
-  rewrite fn_entrypoint_transf_function.
-  apply star_eq with (cfg f); auto.
-  intros; rewrite <- cfg_transf_function; auto.
-  apply star_eq with (cfg (transf_function f)); auto.
-  intros a b; rewrite <- cfg_transf_function; auto.
-  rewrite fn_entrypoint_transf_function in *; auto. 
-Qed.
-
-Lemma exit_exit : forall (f:function) (Hwf: wf_ssa_function f) pc, 
-                    exit f pc <-> exit (transf_function f) pc.
-Proof.
-  split.
-  - intros. 
-    assert (Hins: exists ins, (fn_code f) ! pc = Some ins).
-    { unfold exit in *.
-      flatten NOSTEP; eauto.
-      inv H; go.
-    }        
-    destruct Hins as [ins0 Hins0].
-    exploit (fn_code_transf_function f pc); eauto. 
-    intros [ins Hins].
-    unfold transf_function in *; 
-    unfold exit in *; rewrite Hins in *.
-    unfold fn_code in *. rewrite Hins0 in *.
-    case_eq (analysis f) ; intros lv es Ha ; rewrite Ha in *; simpl in *.
-    rewrite PTree.gmap in *.
-    unfold option_map in *.
-    rewrite Hins0 in *.
-    inv Hins.
-    exploit new_code_same_or_Iop; eauto.  
-    flatten; auto; (intros [Heq | Hcont]; [idtac | elim Hcont]);
-    try intuition;
-    try (replace lv with (fst (analysis f)) in * by (rewrite Ha ; auto));
-    try congruence.
-  - intros.
-    assert (Hins: exists ins, (SSA.fn_code (transf_function f)) ! pc = Some ins).
-    { unfold exit in *.
-      flatten NOSTEP; eauto.
-      inv H; go.
-    }
-    destruct Hins as [ins0 Hins0].
-    unfold transf_function in *.
-    unfold exit in *; rewrite Hins0 in *.
-    case_eq (analysis f) ; intros lv es Ha ; rewrite Ha in *; simpl in *.
-    unfold fn_code in *.    
-    rewrite PTree.gmap in *.
-    unfold option_map in *.
-    flatten Hins0; intuition;
-    match goal with
-    | id: analysis ?ff = _ |- _ => set (f:= ff) in *
-    end.
-    + destruct (new_code_same_or_Iop f Hwf pc i); auto.
-      * replace lv with (fst (analysis f)) in * by (rewrite Ha ; auto).
-        rewrite H0 in H1 ; inv H1; auto.
-      * replace lv with (fst (analysis f)) in * by (rewrite Ha ; auto);
-          destruct i; try (elim H1; fail);
-            try (destruct b ; try intuition auto) ;
-            destruct H1 as (op' & args' & H2 & H3);  congruence. 
-    + destruct (new_code_same_or_Iop f Hwf pc i); auto.
-      * replace lv with (fst (analysis f)) in * by (rewrite Ha ; auto).
-        rewrite H0 in H ; inv H; auto.
-      * replace lv with (fst (analysis f)) in * by (rewrite Ha ; auto);
-          destruct i; try (elim H; fail);
-            try (destruct b ; try intuition auto) ;
-            destruct H as (op' & args' & H2 & H3);  congruence.
-    + destruct (new_code_same_or_Iop f Hwf pc i); auto.
-      * replace lv with (fst (analysis f)) in * by (rewrite Ha ; auto).
-        rewrite H0 in H1 ; inv H1; auto.
-      * replace lv with (fst (analysis f)) in * by (rewrite Ha ; auto);
-          destruct i; try (elim H1; fail);
-            try (destruct b ; try intuition auto) ;
-            destruct H1 as (op' & args' & H2 & H3);  congruence.        
-Qed.
-
-Lemma ssa_path_transf_function : forall (f:function) (Hwf:wf_ssa_function f) i p j,
-  SSApath f i p j <-> SSApath (transf_function f) i p j.
-Proof.
-  split.
-  - induction 1; go.
-    econstructor 2 with s2; auto.
-    inv STEP.
-    + assert (cfg (transf_function f) pc pc')
-        by (rewrite <- cfg_transf_function; eauto; econstructor; eauto).
-      inv H0.
-      econstructor; eauto.
-      rewrite <- reached_transf_function; auto.
-      go.
-    + assert (Hins: exists ins, (fn_code f) ! pc = Some ins).
-      { unfold exit in *.
-        flatten NOSTEP; eauto.
-        inv H; go.
-      }        
-      destruct Hins as [ins0 Hins0].
-      exploit (fn_code_transf_function f pc); eauto. intros [ins Hins].
-      econstructor; eauto.
-      * eapply reached_transf_function in CFG; eauto.
-      * eapply (exit_exit f); eauto.
-  - induction 1; go.
-    econstructor 2 with s2; auto.
-    inv STEP.
-    + assert (cfg f pc pc') by (rewrite cfg_transf_function; eauto; econstructor; eauto).
-      inv H0.
-      econstructor; eauto.
-      go.
-    + assert (Hins: exists ins, (SSA.fn_code (transf_function f)) ! pc = Some ins).
-      { unfold exit in *.
-        flatten NOSTEP; eauto.
-        inv H; go.
-      }        
-      destruct Hins as [ins0 Hins0].      
-      eelim fn_code_transf_function' ; eauto. 
-      intros ins' H'.
-      econstructor; eauto.
-      eapply exit_exit; eauto.
-Qed.
-  
-Lemma dom_transf_function : forall (f:function) (Hwf:wf_ssa_function f) i j,
-  dom f i j <-> dom (transf_function f) i j.
-Proof.
-  split; intros.
-  - inv H; constructor.
-    + rewrite <- reached_transf_function; auto.
-    + intros.
-      apply PATH.
-      rewrite ssa_path_transf_function; auto.
-      rewrite fn_entrypoint_transf_function in *.
-      auto.
-  - inv H; constructor.
-    + rewrite reached_transf_function; auto.
-    + intros.
-      apply PATH.
-      rewrite <- ssa_path_transf_function; auto.
-      rewrite fn_entrypoint_transf_function in *.
-      auto. 
-Qed.
-
-Lemma transf_function_Inop : forall (f:function) (Hwf:wf_ssa_function f) pc jp,
-  (fn_code f) ! pc = Some (Inop jp) ->
-  (SSA.fn_code (transf_function f)) ! pc = Some (Inop jp).
-Proof.
-  intros.
-  unfold transf_function; simpl.
-  case_eq (analysis f) ; intros lv es Ha ; try rewrite Ha in * ;  simpl in *.
-  rewrite PTree.gmap.
-  rewrite H; simpl.
-  destruct (new_code_same_or_Iop f Hwf pc (Inop jp)); auto.
-  - replace lv with (fst (analysis f)) by (rewrite Ha ; auto). rewrite H0; auto.
-  - elim H0.
-Qed.
-
-Lemma transf_function_preserve_wf_ssa_function : forall (f:function),
-  wf_ssa_function f -> wf_ssa_function (transf_function f).
-Proof.
-  constructor.
-
-  - generalize (fn_ssa _ H).
-    unfold unique_def_spec; split; intros.
-    repeat rewrite <- assigned_phi_spec_same; auto.
-    repeat rewrite <- assigned_code_spec_same; auto.
-    destruct H0; auto.
-    unfold transf_function in *.
-    destruct (analysis f) in * ; simpl in *; eauto.
-    destruct H0 as [_ H0]; eauto.
-    
-  - intros x; rewrite fn_params_transf_function; intros T.
-    elim fn_ssa_params with (1:=H) (2:=T); split; intros.
-    rewrite <- assigned_code_spec_same; auto.
-    rewrite <- assigned_phi_spec_same; auto.
-
-  - intros x u d Hu Hd.
-    rewrite <- dom_transf_function.
-    apply def_transf_function in Hd; auto.
-    apply use_transf_function in Hu; auto.
-    destruct Hu as [Hu|[y [Hu1 Hu2]]].
-    + apply fn_strict with x; auto.
-    + assert (y=d) by (eapply ssa_def_unique; eauto); subst.
-      inv Hu2; auto.
-    + assumption.
-
-  - intros x pc Hu Ha.
-    rewrite <- assigned_code_spec_same in Ha; auto.
-    apply use_code_transf_function in Hu; auto.
-    destruct Hu.
-    + eelim fn_use_def_code; eauto.
-    + destruct H0 as [d [D1 D2]].
-      assert (def f x pc) by eauto.
-      destruct D2.
-      elim NEQ; eapply ssa_def_unique; eauto.
-
-  - intros pc block args x.
-    rewrite fn_phicode_transf_function.
-    rewrite make_predecessors_transf_function; auto.
-    eapply fn_wf_block; eauto.
-    
-  - intros.
-    rewrite join_point_transf_function in H0; auto.
-    rewrite successors_list_transf_function in H1; auto.
-    exploit fn_normalized; eauto; intros.
-    exploit transf_function_Inop; eauto.
-    
-  - intros.
-    rewrite join_point_transf_function; auto.
-    rewrite fn_phicode_transf_function; auto.
-    eapply fn_phicode_inv; eauto.
-
-  - intros pc ins.
-    rewrite <- reached_transf_function; intros; auto.
-    eelim fn_code_transf_function'; eauto.
-    
-  - intros pc pc' instr Hi Hj.
-    assert (cfg f pc pc') by (rewrite cfg_transf_function; eauto; econstructor; eauto).
-    inv H0.
-    exploit fn_code_closed; eauto.
-    intros [ii HH].
-    eapply fn_code_transf_function; eauto. 
-
-  - exploit fn_entry; eauto.
-    intros [s Hs].
-    exists s; rewrite fn_entrypoint_transf_function.
-    exploit transf_function_Inop; eauto.
-
-  - intros pc; rewrite <- cfg_transf_function; auto; rewrite fn_entrypoint_transf_function.
-    apply fn_entry_pred; auto.
-
-  - intros.
-    inv H0.
-    + unfold transf_function in *; simpl in *.
-      destruct analysis; simpl in *.
-      inv H; go.
-    + destruct H1 as [pc H1].
-      rewrite fn_phicode_transf_function in H2.
-      exploit use_transf_function; eauto. 
-      unfold transf_function.
-      destruct analysis; simpl in *.
-      destruct 1.
-      * inv H.
-          eapply  fn_ext_params_complete; eauto.
-          econstructor 2; eauto.
-          intros.
-          rewrite (assigned_code_spec_same f) ; eauto.
-          constructor; auto.
-      * { destruct H0 as (d & H0 & _).
-          inv H0; go.
-          - inv H ; eauto.
-          - eelim H3; rewrite <- assigned_code_spec_same; eauto.
-          - eelim H2; eauto.
-        }
-     
-  - intros. rewrite <- dom_transf_function; auto.
-    eapply fn_dom_test_correct; eauto.
-    rewrite reached_transf_function; auto.
-    unfold transf_function in H1 ;
-      destruct analysis in H1 ; simpl in * ; auto.
-Qed.
-
-End Opt.
diff --git a/midend/OptInv.v b/midend/OptInv.v
deleted file mode 100644
index 12ff77ae..00000000
--- a/midend/OptInv.v
+++ /dev/null
@@ -1,506 +0,0 @@
-Require Import Classical.
-Require Import Coqlib.
-Require Import Maps.
-Require Import AST.
-Require Import Integers.
-Require Import Values.
-Require Import Memory.
-Require Import Globalenvs.
-Require Import Smallstep.
-Require Import Op.
-Require Import Events.
-Require Import Registers.
-Require Import Floats.
-Require Import Utils.
-Require Import Dom.
-Require Import SSA. 
-Require Import SSAutils. 
-Require Import SSAinv. 
-Require Import Utilsvalidproof.
-Require Import DomCompute.
-Require Import Axioms.
-Require Import KildallComp.
-Require Import OrderedType.
-Require Import Ordered.
-Require Import FSets.
-Require FSetAVL.
-Require Import Dsd.
-Require Import Opt.
-Require Import DLib.
-
-Unset Allow StrictProp.
-
-(** This file defines a generic program optimization.  In our SSA
- middle-end, we instantiate this to SCCP and GVN-CSE, but in general,
- it could also be instantiated to any intra-procedural, scalar
- optimization. *)
-
-Ltac ssa_def := 
-  let eq_pc pc1 pc2 := 
-      assert (pc1 = pc2) by (eapply ssa_def_unique; eauto); subst
-  in
-  unfold node in *;
-    match goal with 
-      | r : reg |- _ =>
-        match goal with 
-            id: def _ r ?x,
-            id': def _ r ?y
-            |- _ => eq_pc x y ; try clear id'
-        end
-      | pc1: positive,
-        pc2: positive |- _ =>
-            match goal with 
-                id : def _ ?r pc1,
-                id': assigned_phi_spec _ pc2 ?r |- _ =>
-                eq_pc pc1 pc2
-            end
-      |  pc1: positive,
-         pc2: positive |- _ =>
-            match goal with 
-                id: assigned_phi_spec _ pc1 ?r,
-                id': assigned_phi_spec _ pc2 ?r |- _ =>
-                eq_pc pc1 pc2
-            end
-      | id : _ ! ?pc1 = Some (Iop _ _ ?r _),
-        id' : _ ! ?pc2 = Some (Iop _ _ ?r _)
-        |- _ => 
-        match pc2 with
-          | pc1 => fail 1
-          | _ => idtac
-        end;
-          eq_pc pc1 pc2
-      | id : _ ! ?pc1 = Some (Iop _ _ ?r _),
-        id': def _ ?r ?pc2 |- _ =>
-        match pc2 with
-          | pc1 => fail 1
-          | _ => idtac
-        end;
-          eq_pc pc1 pc2
-      end.
-
-
-(** * Record for a dominance-based static analysis  *)
-Record DsdAnalysis := {
- (** Flow insensitive analysis *)
-   approx: Type
- ; result := reg -> approx
-
- (** [G ge sp rs a v] : in context ge sp rs, a is a correct approximation of the value v *)
- ; G : genv -> val -> regset -> approx -> val -> Prop
-
- (** [is_at_Top R r] : characterization of registers put at Top *) 
- ; is_at_Top : result -> reg -> Prop
-
- (** The analysis itself *)
- ; A : function -> (result * m_exec)
-
- ; exec : function -> node -> Prop
-
- (** The following are hypotheses we require on the analysis. 
-     To be proved when instantiating the framework *)
- ; exec_fn_entry : forall f, exec f (fn_entrypoint f)
-
- ; is_at_Top_eq_is_at_Top : 
-     forall f dst x, 
-       is_at_Top (fst (A f)) dst -> 
-       fst (A f) x = fst (A f) dst -> 
-       is_at_Top (fst (A f)) x
-
- ; params_Top : 
-     forall (f:function) r,
-       wf_ssa_function f ->
-       ext_params f r -> 
-       is_at_Top (fst (A f)) r
-
- (** A register put to top approximates any concrete value (_any_ context) *)
- ; G_top : 
-     forall f r ge sp rs, 
-       is_at_Top (fst (A f)) r -> 
-       G ge sp rs (fst (A f) r) (rs# r)
-
-}.
-
-Section Opt_ANALYSIS.
-
- Variable AA: DsdAnalysis.
-
- Inductive G_list ge sp rs : list (approx AA) -> list val -> Prop :=
-    vlma_nil : G_list ge sp rs nil nil
-  | vlma_cons : forall a al v vl,
-                G AA ge sp rs a v ->
-                G_list ge sp rs al vl ->
-                G_list ge sp rs (a :: al) (v :: vl).
- 
- Definition A_r f := fst (A AA f).
- Definition A_e f := snd (A AA f).
-                     
- Definition gamma (f:function) ge sp (pc:node) (rs:regset) : Prop :=
-    (forall x, dsd f x pc -> 
-               exec AA f pc -> 
-               G AA ge sp rs (A_r f x) (rs# x)).
-
-  Lemma gamma_entry (f:function) : 
-    wf_ssa_function f -> 
-    forall ge sp rs, gamma f ge sp (fn_entrypoint f) rs.
-  Proof.
-    intros WF ge sp rs r Hr _.
-    eelim ssa_dsd_entry; eauto. 
-  Qed.
-
-  Lemma gamma_sdom_gamma (f: function) : forall pc pc' ge sp rs,
-    wf_ssa_function f -> 
-    gamma f ge sp pc rs ->
-    exec AA f pc ->
-    sdom f pc' pc ->
-    gamma f ge sp pc' rs.
-  Proof.
-    intros pc pc' ge sp rs WF G EXE SDOM r Hr He. 
-    inv Hr. 
-    - eapply G; eauto.
-      econstructor; eauto.
-      eapply (sdom_trans peq); eauto.
-      intro Hcont.
-      ssa_def.
-      eapply (elim_sdom_sdom peq); eauto.
-    - eapply G; eauto.
-      econstructor 1; eauto.
-      intro Hcont.       
-      ssa_def. 
-      eelim SDOM; eauto. 
-  Qed.
-
-  Lemma used_match_approx: forall (f:function) ge sp pc rs r,
-    wf_ssa_function f -> 
-    gamma f ge sp pc rs ->
-    use_code f r pc -> 
-    exec AA f pc ->
-    G AA ge sp rs (A_r f r) (rs# r).
-  Proof.
-    intros f ge sp pc rs r WF GAMMA USE EXE.
-    assert (H3: exists pc', def f r pc') by (eapply ssa_use_exists_def; go).
-    destruct H3 as [x H0].
-    eapply GAMMA; auto.
-    destruct (classic (assigned_phi_spec (fn_phicode f) pc r)) as [H4 | H4].
-      + go. 
-      + econstructor 1; eauto.
-        assert (H5: dom f x pc) by (eapply fn_strict; go). 
-        apply (dom_eq_sdom peq) in H5. inv H5; auto.
-        assert (assigned_code_spec (fn_code f) pc r)
-          by (inv H0; try (destruct (fn_entry f); auto; invh use_code; congruence)).
-        eelim ssa_def_use_code_false; eauto. 
-  Qed.
-
-  Lemma all_used_approx: forall ge f pc sp rs args,
-     exec AA f pc ->                           
-     wf_ssa_function f ->
-     (forall r, In r args -> use_code f r pc) ->
-     gamma f ge sp pc rs -> 
-     G_list ge sp rs (map (A_r f) args) (rs## args). 
-  Proof.
-  induction args; intros.
-  - go. 
-  - simpl. econstructor; eauto. 
-    eapply H2; eauto.
-    assert (use_code f a pc) by go.
-    exploit ssa_use_exists_def; go. intros [dr Hr].
-    exploit fn_strict; go. intros.
-    exploit (dom_eq_sdom peq); eauto. intros [HCase | HCase]. 
-    + subst. inv Hr; try go.
-      * exploit fn_entry; eauto. intros [s Hnop].
-        inv H3; try congruence.  
-      * eelim fn_use_def_code; eauto.
-    + eapply def_sdom_dsd; eauto.
-  Qed.
-
-  Lemma gamma_v_args : forall ge f sp rs res op pc pc' args,
-     exec AA f pc ->
-     wf_ssa_function f ->
-     gamma f ge sp pc rs -> 
-     (fn_code f) ! pc = Some (Iop op args res pc') ->
-     G_list ge sp rs (map (A_r f) args) (rs## args).
-  Proof.
-    intros. 
-    eapply all_used_approx; eauto.
-    intros; go.
-  Qed.
-
-  (** A couple of extra hypotheses.*)
-  Variable A_intra_locals : forall (f:function) (WF: wf_ssa_function f),
-         forall pc res,
-         (forall op args res pc', (fn_code f) ! pc <> Some (Iop op args res pc')) ->
-         exec AA f pc ->
-         assigned_code_spec (fn_code f) pc res -> is_at_Top AA (A_r f) res.
-
-  Variable G_upd_diff : forall (f:function) (Hwf:wf_ssa_function f) ge sp rs dst x v,
-                    x <> dst ->
-                    A_r f x <> A_r f dst ->
-                    G AA ge sp rs (A_r f x) rs !! x ->
-                    G AA ge sp (rs # dst <- v) (A_r f x) rs !! x.
-
-  (** Local soundness of analysis for variable assignment *)
-  Variable Iop_correct : forall (f:function) pc sf op args res pc' v rs ge sp m x,
-                      forall (WFF: wf_ssa_function f)
-                             (SINV: s_inv ge (State sf f (Vptr sp Ptrofs.zero) pc rs m)),
-                        (fn_code f) ! pc = Some (Iop op args res pc') ->
-                        eval_operation ge (Vptr sp Ptrofs.zero) op (rs ## args) m = Some v ->
-                        gamma f ge (Vptr sp Ptrofs.zero) pc rs ->
-                        exec AA f pc ->
-                        dsd f x pc' ->
-                        G AA ge (Vptr sp Ptrofs.zero) (rs # res <- v) (A_r f x) (rs # res <- v) !! x.
-
-  (** Local soundness of analysis for phi-blocks *)
-  Variable gamma_step_phi: forall (f:function) ge sp pc pc' phib k rs,
-   wf_ssa_function f ->
-   reached f pc ->
-   exec AA f pc ->
-   
-   (fn_code f) ! pc = Some (Inop pc') ->
-   (fn_phicode f) ! pc' = Some phib ->
-   index_pred (Kildall.make_predecessors (fn_code f) successors_instr) pc pc' = Some k ->
-   
-   gamma f ge sp pc rs ->
-   gamma f ge sp pc' (phi_store k phib rs).
-
-
-(** * Soundness invariant. Subject-reduction proof *)
-Section subject_reduction.
-
-  Variable prog: program.
-  Let ge := Genv.globalenv prog.
-
-  Hypothesis WELL_FORMED : wf_ssa_program prog.
-
-  Inductive sfg_inv : list stackframe -> Prop :=
-  | sf_inv_nil: sfg_inv nil
-  | sf_inv_cons: 
-    forall res (f:function) sp b pc rs s
-      (SP: sp = (Vptr b Ptrofs.zero))
-      (STACK: sfg_inv s)
-      (HG:forall v, gamma f ge sp pc (rs# res <- v))
-      (EXE: exec AA f pc),
-      sfg_inv ((Stackframe res f sp pc rs) :: s).
-  Hint Constructors sfg_inv: core.
-  
-  Variant sg_inv (ge: genv): state -> Prop :=
-  | si_State:
-      forall s sp b pc rs m f
-        (SP: sp = (Vptr b Ptrofs.zero))
-        (SINV:s_inv ge (State s f sp pc rs m))
-        (HG:gamma f ge sp pc rs)
-        (EXE: exec AA f pc)
-        (STACK: sfg_inv s),
-        sg_inv ge (State s f sp pc rs m)
-  | si_Call:
-      forall s f args m
-        (SINV:s_inv ge (Callstate s f args m))
-        (STACK: sfg_inv s),
-        sg_inv ge (Callstate s f args m)
-  | si_Return:
-      forall s v m 
-        (SINV:s_inv ge (Returnstate s v m))
-        (STACK: sfg_inv s),
-        sg_inv ge (Returnstate s v m).
-  Hint Constructors sg_inv: core.
-  
-  Lemma s_inv_initial : forall s, initial_state prog s -> sg_inv ge s.
-  Proof.
-    intros. inv H.
-    econstructor; eauto.
-    econstructor; eauto.
-    eapply Genv.find_funct_ptr_prop; eauto.
-    go. 
-  Qed.
-
-  Variable exec_step : forall (f:function) (HWF: wf_ssa_function f)
-                              ge t sf sp pc rs m s',
-                   sfg_inv sf ->
-                   gamma f ge sp pc rs ->
-                   exec AA f pc ->
-                   step ge (State sf f sp pc rs m) t s' ->
-                   match s' with 
-                     | (State _ f _ pc' _ _) 
-                     | (Callstate (Stackframe _ f _ pc' _ :: _) _ _ _) => exec AA f pc'
-                     | _ => True
-                   end.
-
-  Lemma subj_red : forall s s' t,
-    sg_inv ge s ->
-    step ge s t s' ->
-    step ge s t s' ->
-    sg_inv ge s'.  
-  Proof.
-  intros s s' t HINV STEP STEP'.
-  inv HINV.
-  
-  - (* from State *)
-    assert (WF : wf_ssa_function f) by (inv SINV; auto).
-    invh step; (econstructor; eauto);
-    try solve [eapply subj_red; eauto];
-    try solve [eapply exec_step in STEP' ; eauto].
-
-    + (* Inop njp *)
-      unfold gamma in *; intros x Hx He.
-      assert (~assigned_code_spec (fn_code f) pc x)
-        by (intros contra; inv contra; congruence).
-      exploit (dsd_pred_not_join_point f WF pc pc' x); eauto. go.
-      intros [Hcase1 | [ Hcase2 | Hcase3]]; invh and; try congruence.
-      * exploit G_top; eauto. 
-        eapply params_Top; eauto. 
-      * eapply HG; eauto.
-
-    + (* Iop *)      
-      unfold gamma in *; intros x Hyp1 Hyp2.
-      eapply Iop_correct; eauto.
-
-    + (* Iload *)
-      unfold gamma in *; intros x Hyp1 Hyp2.
-      { destruct (peq x dst).
-        - subst. 
-          exploit (A_intra_locals f WF pc); go. 
-          eapply G_top; eauto; go.
-        - exploit (A_intra_locals f WF pc); go. 
-          intros. 
-          exploit (HG x); eauto.
-          * destruct dsd_pred_njp with f pc pc' x as 
-                [[Dx Dx']|[[Dx [Dx' Dx'']]|[Dx Dx']]]; simplify_dsd; eauto.
-            inv WF ; eauto.
-            -- intro; subst. edestruct fn_entry. congruence.
-            -- econstructor; eauto.
-            -- eelim ssa_not_Inop_not_phi; eauto; go.               
-          * intros.
-            { destruct (classic ((A_r f x) = (A_r f dst))).
-              - assert (is_at_Top AA (A_r f) x) by (eapply is_at_Top_eq_is_at_Top; eauto). 
-                eapply G_top; eauto. 
-              - rewrite PMap.gso; auto.  
-            }             
-      }
-
-    + (* Istore *) 
-      unfold gamma in *; intros x Hyp1 Hyp2.     
-      destruct dsd_pred_njp with f pc pc' x as
-          [[Dx Dx']|[[Dx [Dx' Dx'']]|[Dx Dx']]]; simplify_dsd; eauto.
-      * inv WF ; auto.
-        intro; subst. edestruct fn_entry. congruence.
-      * go. 
-      * eelim ssa_not_Inop_not_phi; simpl; go; simpl; go. 
-      
-    + (* Icall *)
-      econstructor; eauto.
-      intros v x Hyp1 Hyp2.
-        { destruct (peq x res).
-          - subst. exploit (A_intra_locals f WF pc); go. 
-            eapply G_top; eauto. 
-          - exploit (HG x); eauto. 
-            * destruct dsd_pred_njp with f pc pc' x as 
-                [[Dx Dx']|[[Dx [Dx' Dx'']]|[Dx Dx']]]; simplify_dsd; eauto.
-              -- intro; subst; edestruct fn_entry; eauto; congruence.
-              -- econstructor; eauto.
-              -- eelim ssa_not_Inop_not_phi; eauto; go.
-            * exploit (A_intra_locals f WF pc); go. 
-              intros.
-              { destruct (classic ((A_r f x) = (A_r f res))).
-                - assert (is_at_Top AA (A_r f) x) by (eapply is_at_Top_eq_is_at_Top; eauto). 
-                  eapply G_top; eauto. 
-                - rewrite PMap.gso; auto.  
-              }
-        } 
-       eapply exec_step in STEP'; eauto.
-
-    + (* Itailcall *)
-      unfold gamma in *; intros x Hyp1 Hyp2.
-      { destruct res.
-        - destruct (peq x x0).
-          + subst. exploit (A_intra_locals f WF pc); go. 
-          eapply G_top; eauto. 
-          + exploit (HG x); eauto. 
-          * destruct dsd_pred_njp with f pc pc' x as 
-                [[Dx Dx']|[[Dx [Dx' Dx'']]|[Dx Dx']]]; simplify_dsd; eauto.
-            inv WF ; eauto.
-            -- intro; subst; edestruct fn_entry; eauto; congruence.
-            -- go.
-            -- eelim ssa_not_Inop_not_phi; eauto; go. 
-          * exploit (A_intra_locals f WF pc); go. 
-              intros.
-              { destruct (classic ((A_r f x) = (A_r f x0))).
-                - assert (is_at_Top AA (A_r f) x) 
-                    by (eapply is_at_Top_eq_is_at_Top; eauto). 
-                  eapply G_top; eauto. 
-                - unfold regmap_setres.
-                  rewrite PMap.gso; auto.  
-              }
-        - simpl. eapply HG; eauto.
-          destruct dsd_pred_njp with f pc pc' x as 
-              [[Dx Dx']|[[Dx [Dx' Dx'']]|[Dx Dx']]]; simplify_dsd; eauto.
-          inv WF ; eauto.
-          intro; subst; edestruct fn_entry; eauto; congruence.
-          go.
-          eelim ssa_not_Inop_not_phi; eauto; go. 
-        - simpl. eapply HG; eauto.
-          destruct dsd_pred_njp with f pc pc' x as 
-              [[Dx Dx']|[[Dx [Dx' Dx'']]|[Dx Dx']]]; simplify_dsd; eauto.
-          inv WF ; eauto.
-          intro; subst; edestruct fn_entry; eauto;  congruence.
-          go.
-          eelim ssa_not_Inop_not_phi; eauto; go. 
-      }
-
-    + (* Icond true *)
-      unfold gamma in *; intros x Hyp1 Hyp2.
-      destruct dsd_pred_njp with f pc ifso x as
-          [[Dx Dx']|[[Dx [Dx' Dx'']]|[Dx Dx']]]; simplify_dsd; eauto.
-      * inv WF ; eauto.
-        intro; subst; edestruct fn_entry; eauto; congruence.
-      * go. 
-      * eelim ssa_not_Inop_not_phi; eauto. simpl; auto. congruence.
-        
-    + (* Icond false *)
-      unfold gamma in *; intros x Hyp1 Hyp2.
-      destruct dsd_pred_njp with f pc ifnot x as
-          [[Dx Dx']|[[Dx [Dx' Dx'']]|[Dx Dx']]]; simplify_dsd; eauto.
-      * inv WF ; eauto.
-        intro; subst; edestruct fn_entry; eauto; congruence.
-      * go. 
-      * eelim ssa_not_Inop_not_phi; eauto. simpl; auto. congruence.
-
-    + (* Ijumptable *)
-      unfold gamma in *; intros x Hyp1.
-      destruct dsd_pred_njp with f pc pc' x as
-          [[Dx Dx']|[[Dx [Dx' Dx'']]|[Dx Dx']]]; simplify_dsd; eauto using list_nth_z_in.
-      * inv WF ; eauto.
-        intro; subst; edestruct fn_entry; eauto; congruence.
-      * econstructor; eauto. eauto using list_nth_z_in. 
-      * eelim ssa_not_Inop_not_phi; eauto. simpl; eauto using list_nth_z_in. congruence.
-
-  - (* from CallState *)
-    invh step; econstructor; eauto ; try solve [eapply subj_red; eauto ].
-
-    + (* Internal PO1 *)
-      eapply gamma_entry; eauto.
-      inv SINV. inv WFF; auto.
-    + eapply exec_fn_entry; eauto.
-
-  - (* from ReturnState *)
-    invh step. 
-    invh sfg_inv; eauto.
-    econstructor; eauto. 
-    eapply subj_red; eauto. 
-Qed.
-
-(** * Final correctness lemma. To be used in correctness proof of optimization *)
-Theorem subj_red_gamma : forall (f f':function) t m m' rs rs' sp sp' pc pc' s s', 
-    gamma f ge (Vptr sp Ptrofs.zero) pc rs ->
-    exec AA f pc ->
-    sfg_inv s ->
-    s_inv ge (State s f (Vptr sp Ptrofs.zero) pc rs m) ->
-    step ge (State s f (Vptr sp Ptrofs.zero) pc rs m) t (State s' f' (Vptr sp' Ptrofs.zero) pc' rs' m') ->
-    gamma f' ge (Vptr sp' Ptrofs.zero) pc' rs'.  
-Proof.
-  intros.
-  exploit subj_red; eauto.
-  intros. invh sg_inv; eauto.
-Qed.
-
-End subject_reduction. 
-
-End Opt_ANALYSIS.
-
diff --git a/midend/RTLdfs.v b/midend/RTLdfs.v
index dccd52f1..6ca4ab23 100644
--- a/midend/RTLdfs.v
+++ b/midend/RTLdfs.v
@@ -29,6 +29,7 @@ Require Import AST Integers Values Events Memory Globalenvs Smallstep.
 Require Import Op Registers.
 Require Import RTL.
 Require Import Relation_Operators Utils Dom.
+Require Import PointerOp.
 Unset Allow StrictProp.
 
 (** * Abstract syntax *)
@@ -145,14 +146,34 @@ Variant state : Type :=
              (m: mem),                (**r memory state *)
       state.
 
+Definition ros_to_vos (m: Mem.mem) (ros: reg + ident) (rs: regset) : val + ident :=
+  match ros with
+  | inl r => match rs#r with
+            | Vint n => if negb Archi.ptr64
+                       then (match Mem.to_ptr (Vint n) m with
+                             | Some v' => inl v'
+                             | None => inl rs#r
+                             end)
+                       else inl rs#r
+            | Vlong n => if Archi.ptr64
+                        then (match Mem.to_ptr (Vlong n) m with
+                              | Some v' => inl v'
+                              | None => inl rs#r
+                              end)
+                        else inl rs#r
+            | _ => inl rs#r
+            end
+  | inr symb => inr symb
+  end.
+
 Section RELSEM.
 
 Variable ge: genv.
 
 Definition find_function
-      (ros: reg + ident) (rs: regset) : option fundef :=
+      (ros: val + ident) (rs: regset) : option fundef :=
   match ros with
-  | inl r => Genv.find_funct ge rs#r
+  | inl r => Genv.find_funct ge r
   | inr symb =>
       match Genv.find_symbol ge symb with
       | None => None
@@ -174,7 +195,7 @@ Inductive step: state -> trace -> state -> Prop :=
   | exec_Iop:
       forall s f sp pc rs m op args res pc' v,
       (fn_code f)!pc = Some(Iop op args res pc') ->
-      eval_operation ge sp op rs##args m = Some v ->
+      eval_operation_wrapper ge sp op rs##args m = Some v ->
       step (State s f sp pc rs m)
         E0 (State s f sp pc' (rs#res <- v) m)
   | exec_Iload:
@@ -194,14 +215,14 @@ Inductive step: state -> trace -> state -> Prop :=
   | exec_Icall:
       forall s f sp pc rs m sig ros args res pc' fd,
       (fn_code f)!pc = Some(Icall sig ros args res pc') ->
-      find_function ros rs = Some fd ->
+      find_function (ros_to_vos m ros rs) rs = Some fd ->
       funsig fd = sig ->
       step (State s f sp pc rs m)
         E0 (Callstate (Stackframe res f sp pc' rs :: s) fd rs##args m)
   | exec_Itailcall:
       forall s f stk pc rs m sig ros args fd m',
       (fn_code f)!pc = Some(Itailcall sig ros args) ->
-      find_function ros rs = Some fd ->
+      find_function (ros_to_vos m ros rs) rs = Some fd ->
       funsig fd = sig ->
       Mem.free m stk 0 f.(fn_stacksize) = Some m' ->
       step (State s f (Vptr stk Ptrofs.zero) pc rs m)
@@ -216,7 +237,7 @@ Inductive step: state -> trace -> state -> Prop :=
   | exec_Icond:
       forall s f sp pc rs m cond args ifso ifnot b pc',
       (fn_code f)!pc = Some(Icond cond args ifso ifnot) ->
-      eval_condition cond rs##args m = Some b ->
+      eval_condition_wrapper cond rs##args m = Some b ->
       pc' = (if b then ifso else ifnot) ->
       step (State s f sp pc rs m)
         E0 (State s f sp pc' rs m)
@@ -269,16 +290,57 @@ Variant initial_state (p: program): state -> Prop :=
       funsig f = signature_main ->
       initial_state p (Callstate nil f nil m0).
 
+Inductive glob_capture (p: program) : state -> state -> Prop :=
+  | glob_capture_intro
+      f m pbs m'
+      (* (INIT: initial_state p (Callstate nil f nil m)) *)
+      (NONSTATIC: Genv.non_static_glob (Genv.globalenv p) (Genv.genv_public (Genv.globalenv p)) = pbs)
+      (CAPTURE: Genv.capture_init_mem m pbs m') :
+    glob_capture p (Callstate nil f nil m) (Callstate nil f nil m').
+
 (** A final state is a [Returnstate] with an empty call stack. *)
 
 Variant final_state: state -> int -> Prop :=
   | final_state_intro: forall r m,
       final_state (Returnstate nil (Vint r) m) r.
 
+(** Non-deterministic external state *)
+
+Definition is_external (ge:genv) (s:state) : Prop :=
+  match s with
+  | Callstate stk fd vargs m =>
+    match fd with
+    | External ef => is_external_ef ef
+    | _ => False
+    end
+  | State cs f sp pc rs m =>
+    match (fn_code f)!pc with
+    | Some (Ibuiltin ef args res pc') => is_external_ef ef
+    | _ => False
+    end
+  | _ => False
+  end.
+
+Definition state_mem (st: state) : mem :=
+  match st with
+  | State _ _ _ _ _ m => m
+  | Callstate _ _ _ m => m
+  | Returnstate _ _ m => m
+  end.
+
+Definition concrete_snapshot (ge: Senv.t) (st: state) (id: ident) : option Z :=
+  if Senv.public_symbol ge id
+  then (match Senv.find_symbol ge id with
+        | Some b => Maps.PTree.get b (state_mem st).(Mem.mem_concrete)
+        | None => None
+        end
+    )
+  else None.
+
 (** The small-step semantics for a program. *)
 
 Definition semantics (p: program) :=
-  Semantics step (initial_state p) final_state (Genv.globalenv p).
+  Semantics step (initial_state p) (glob_capture p) (concrete_snapshot (Genv.globalenv p)) final_state is_external (Genv.globalenv p).
 
 (** Computation of the possible successors of an instruction.
   This is used in particular for dataflow analyses. *)
diff --git a/midend/RTLdfsD.v b/midend/RTLdfsD.v
new file mode 100644
index 00000000..5dbcb90e
--- /dev/null
+++ b/midend/RTLdfsD.v
@@ -0,0 +1,64 @@
+Require Import Coqlib CoqlibC Events.
+Require Import Globalenvs Smallstep Simulation.
+Require Import sflib RTLdfs.
+
+(** Determinacy *)
+
+Lemma semantics_single_events p s (INT: ~ is_external (Genv.globalenv p) s): single_events_at (RTLdfs.semantics p) s.
+Proof.
+  red. intros. inv H; (try (exploit external_call_trace_length; eauto; intro T)); simpl; try lia; ss; des_ifs.
+Qed.
+
+Lemma semantics_determinate_at:
+  forall (p: program) s (INT: ~ is_external (Genv.globalenv p) s), deterministic_at (semantics p) s.
+Proof.
+  intros. constructor; simpl; intros.
+  - (* determinacy *)
+    inv STEP0; inv STEP1; Eq;
+      try (split; [apply match_traces_E0| intro;auto]);
+      try (elim H; simpl; try rewrite H2; auto).
+    + ss. des_ifs.
+      determ_tac eval_builtin_args_determ.
+      determ_tac external_call_determ.
+    + ss. determ_tac external_call_determ.
+    + esplits; eauto.
+  - inv FINAL; inv STEP.
+  - ii. eapply semantics_single_events; eauto.
+Qed.
+
+Lemma semantics_receptive_at:
+  forall (p: program) s (INT: ~ is_external (Genv.globalenv p) s), receptive_at (semantics p) s.
+Proof.
+  intros. constructor; simpl; intros.
+(* receptiveness *)
+- assert (t1 = E0 -> exists s2, step (Genv.globalenv p) s t2 s2).
+    intros. subst. inv H0. exists s1; auto.
+  inversion H; subst; auto.
++ ss. des_ifs.
+  exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
+  esplits; eauto. eapply exec_Ibuiltin; eauto.
++ exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
+  esplits; eauto. econstructor; eauto.
+(* trace length *)
+- red; intros; inv H; simpl; try lia; ss; des_ifs.
+  eapply external_call_trace_length; eauto.
+  eapply external_call_trace_length; eauto.
+Qed.
+
+Lemma initial_state_determ: forall p st0 st1,
+    Smallstep.initial_state (semantics p) st0 ->
+    Smallstep.initial_state (semantics p) st1 -> st0 = st1.
+Proof.
+  intros. inv H; inv H0. subst ge0 ge. Eq.
+Qed.
+
+Theorem final_state_determ: forall p st0 retv,
+    Smallstep.final_state (semantics p) st0 retv ->
+    Dfinal_state (semantics p) st0 retv.
+Proof.
+  econstructor; eauto.
+  - intros. inv FINAL0; inv FINAL1. auto.
+  - red. unfold not. intros. inv FINAL; inv H0.
+Qed.
+
+Ltac DStep_tac := esplit; [(eapply semantics_determinate_at; simpl in *; eauto; des_ifs)|].
diff --git a/midend/RTLdfsproof.v b/midend/RTLdfsproof.v
index 53f5e67f..c3ef5627 100644
--- a/midend/RTLdfsproof.v
+++ b/midend/RTLdfsproof.v
@@ -15,6 +15,7 @@ Require Import Values.
 Require Import Globalenvs.
 Require Import Op.
 Require Import Registers.
+Require Import PointerOp Simulation RTLdfsD sflib.
 Require Import Smallstep.
 Require Import RTLdfs.
 Require Import RTL.
@@ -27,6 +28,8 @@ Require Import Floats.
 Require Import Utils.
 Require Import RTLdfsgen.
 Require Import Events.
+Require Import Classical.
+From Paco Require Import paco.
 
 Unset Allow StrictProp.
 
@@ -647,6 +650,9 @@ Hypothesis TRANSF_PROG: match_prog prog tprog.
 
 Let ge := Genv.globalenv prog.
 Let tge := Genv.globalenv tprog.
+
+Let sem := RTL.semantics prog.
+Let tsem := RTLdfs.semantics tprog.
   
 Lemma symbols_preserved:
   forall (s: ident), Genv.find_symbol tge s = Genv.find_symbol ge s.
@@ -697,36 +703,42 @@ Proof.
   inv H. simpl; auto.
 Qed.
 
-Lemma find_function_preserved_same : forall r rs f f', 
-  find_function ge (inl ident r) rs = Some f ->
-  RTLdfs.find_function tge (inl ident r) rs = Some f' ->
+Lemma find_function_preserved_same : forall r rs f f' m, 
+  find_function ge (RTL.ros_to_vos m (inl ident r) rs) rs = Some f ->
+  RTLdfs.find_function tge (RTLdfs.ros_to_vos m (inl ident r) rs) rs = Some f' ->
   funsig f = RTLdfs.funsig f'.
 Proof.
   intros. simpl in *.
-  exploit (functions_translated rs#r) ; eauto.
-  intros.
-  destruct H1 as [tf [Htf Oktf]].
-  symmetry.
-  eapply sig_fundef_translated; eauto.
-  rewrite Htf in H0. inv H0; auto.
+  des_ifs.
+  - ss. exploit (functions_translated (Vptr b (Ptrofs.repr z))) ; eauto.
+    intros. destruct H1 as [tf [Htf Oktf]].
+    symmetry.
+    eapply sig_fundef_translated; eauto.
+    ss. rewrite Htf in H0. inv H0; auto.
+  - ss. exploit (functions_translated (Vptr b i)) ; eauto.
+    intros. destruct H1 as [tf [Htf Oktf]].
+    symmetry.
+    eapply sig_fundef_translated; eauto.
+    ss. rewrite Htf in H0. inv H0; auto.
 Qed.
 
 Lemma spec_ros_r_find_function:
-  forall rs f r,
-  RTL.find_function ge (inl _ r) rs = Some f ->
+  forall rs f r m,
+  RTL.find_function ge (RTL.ros_to_vos m (inl _ r) rs) rs = Some f ->
   exists tf,
-     RTLdfs.find_function tge (inl _ r) rs = Some tf
+     RTLdfs.find_function tge (RTLdfs.ros_to_vos m (inl _ r) rs) rs = Some tf
   /\ transf_fundef f = OK tf.
 Proof.
-  intros.
-  eapply functions_translated; eauto.
+  intros. ss. des_ifs.
+  - ss. exploit (functions_translated (Vptr b (Ptrofs.repr z))); eauto.
+  - ss. exploit (functions_translated (Vptr b i)); eauto.
 Qed.
 
 Lemma spec_ros_id_find_function:
-  forall rs f id,
-  RTL.find_function ge (inr _ id) rs = Some f ->
+  forall rs f id m,
+  RTL.find_function ge (RTL.ros_to_vos m (inr _ id) rs) rs = Some f ->
   exists tf,
-     RTLdfs.find_function tge (inr _ id) rs = Some tf
+     RTLdfs.find_function tge (RTLdfs.ros_to_vos m (inr _ id) rs) rs = Some tf
   /\ transf_fundef f = OK tf.
 Proof.
   intros.
@@ -808,6 +820,10 @@ Proof.
   eapply Genv.senv_transf_partial; eauto.
 Qed.
 
+Lemma same_public:
+  prog_public prog = prog_public tprog.
+Proof. inv TRANSF_PROG. des; eauto. Qed.
+
 Create HintDb valagree.
 Hint Resolve find_function_preserved_same: valagree.
 Hint Resolve symbols_preserved : valagree.
@@ -823,30 +839,32 @@ Ltac try_succ f pc pc' :=
 
 Lemma transl_step_correct:
   forall s1 t s2,
-  step ge s1 t s2 ->
+  IStep sem s1 t s2 ->
   forall s1' (MS: match_states s1 s1'),
-  exists s2', RTLdfs.step tge s1' t s2' /\ match_states s2 s2'.
+  exists s2', DStep tsem s1' t s2' /\ match_states s2 s2'.
 Proof.
+  destruct 1. generalize dependent s2. rename H into INT.
   induction 1; intros; inv MS; auto.
   
   (* inop *)
   exploit instr_at; eauto; intros.
-  exists (RTLdfs.State ts tf sp pc' rs m); split ; eauto. 
+  exists (RTLdfs.State ts tf sp pc' rs m); split; [DStep_tac|]; eauto.
   econstructor; auto. 
   constructor; auto.  
   try_succ f pc pc'.
   
   (* iop *)
   exploit instr_at; eauto; intros.
-  exists (RTLdfs.State ts tf sp pc' (rs#res<- v) m); split ; eauto. 
+  exists (RTLdfs.State ts tf sp pc' (rs#res<- v) m); split ; [DStep_tac|]; eauto. 
   eapply RTLdfs.exec_Iop ; eauto.
-  rewrite <- H0 ; eauto with valagree. 
+  rewrite <- H0 ; eauto with valagree.
+  eapply eval_operation_wrapper_preserved. eapply symbols_preserved.
   constructor; auto.  
   try_succ f pc pc'.
   
   (* iload *)
   exploit instr_at; eauto; intros.
-  exists (RTLdfs.State ts tf sp pc' (rs#dst <- v) m); split ; eauto. 
+  exists (RTLdfs.State ts tf sp pc' (rs#dst <- v) m); split; [DStep_tac|]; eauto. 
   eapply RTLdfs.exec_Iload ; eauto. 
   try solve [rewrite <- H0 ; eauto with valagree].
   econstructor ; eauto.
@@ -854,7 +872,7 @@ Proof.
   
   (* istore *)
   exploit instr_at; eauto; intros.
-  exists (RTLdfs.State ts tf sp pc' rs m'); split ; eauto. 
+  exists (RTLdfs.State ts tf sp pc' rs m'); split; [DStep_tac|]; eauto. 
   eapply RTLdfs.exec_Istore ; eauto. 
   try solve [rewrite <- H0 ; eauto with valagree].
   constructor ; eauto.
@@ -866,7 +884,7 @@ Proof.
   intros. destruct H1 as [tf' [Hfind OKtf']].
 
   exploit instr_at; eauto; intros.
-  exists (RTLdfs.Callstate (RTLdfs.Stackframe res tf sp pc' rs :: ts) tf' rs ## args m) ; split ; eauto. 
+  exists (RTLdfs.Callstate (RTLdfs.Stackframe res tf sp pc' rs :: ts) tf' rs ## args m); split ; [DStep_tac|]; eauto. 
   eapply RTLdfs.exec_Icall ; eauto. 
   eauto with valagree.
   constructor; auto. 
@@ -877,7 +895,7 @@ Proof.
   intros. destruct H1 as [tf' [Hfind OKtf']].
 
   exploit instr_at; eauto; intros.
-  exists (RTLdfs.Callstate (RTLdfs.Stackframe res tf sp pc' rs :: ts) tf' rs ## args m) ; split ; eauto. 
+  exists (RTLdfs.Callstate (RTLdfs.Stackframe res tf sp pc' rs :: ts) tf' rs ## args m); split; [DStep_tac|]; eauto. 
   eapply RTLdfs.exec_Icall ; eauto. 
   eauto with valagree.
   constructor; auto.
@@ -892,7 +910,7 @@ Proof.
   exploit instr_at; eauto; intros.
   exploit find_function_preserved_same ; eauto.
   intros.
-  exists (RTLdfs.Callstate ts tf' rs##args m');  split ; eauto. 
+  exists (RTLdfs.Callstate ts tf' rs##args m'); split; [DStep_tac|]; eauto. 
   eapply RTLdfs.exec_Itailcall ; eauto with valagree.  
   replace (RTLdfs.fn_stacksize tf) with (fn_stacksize f); eauto with valagree.
   
@@ -900,13 +918,14 @@ Proof.
   intros. destruct H1 as [tf' [Hfind OKtf']].
 
   exploit instr_at; eauto; intros.
-  exists (RTLdfs.Callstate ts tf' rs##args m');  split ; eauto. 
+  exists (RTLdfs.Callstate ts tf' rs##args m'); split; [DStep_tac|]; eauto. 
   eapply RTLdfs.exec_Itailcall ; eauto with valagree.
   replace (RTLdfs.fn_stacksize tf) with (fn_stacksize f); eauto with valagree.
 
   (* ibuiltin *)
   exploit instr_at; eauto; intros.
-  exists (RTLdfs.State ts tf sp pc' (regmap_setres res vres rs) m') ; split ; eauto. 
+  exists (RTLdfs.State ts tf sp pc' (regmap_setres res vres rs) m'); split; [DStep_tac|]; eauto.
+  unfold is_internal in INT. ss. des_ifs.
   eapply RTLdfs.exec_Ibuiltin with (vargs:= vargs) ; eauto.
   eapply eval_builtin_args_preserved with (2:= H0); eauto with valagree.
   eapply external_call_symbols_preserved; eauto with valagree.
@@ -917,21 +936,21 @@ Proof.
   
   exploit instr_at; eauto; intros.
   destruct b.
-  exists (RTLdfs.State ts tf sp ifso rs m); split ; eauto. 
-  eapply RTLdfs.exec_Icond ; eauto. 
+  exists (RTLdfs.State ts tf sp ifso rs m); split; [DStep_tac|]; eauto. 
+  eapply RTLdfs.exec_Icond ; eauto.
   constructor; auto.  
   try_succ f pc ifso.
 
   (* ifnot *)
   exploit instr_at; eauto; intros.
-  exists (RTLdfs.State ts tf sp ifnot rs m); split ; eauto. 
-  eapply RTLdfs.exec_Icond ; eauto. 
+  exists (RTLdfs.State ts tf sp ifnot rs m); split; [DStep_tac|]; eauto. 
+  eapply RTLdfs.exec_Icond ; eauto.
   constructor; auto.  
   try_succ f pc ifnot.
   
   (* ijump *)
   exploit instr_at; eauto; intros.
-  exists (RTLdfs.State ts tf sp pc' rs m); split ; eauto. 
+  exists (RTLdfs.State ts tf sp pc' rs m); split; [DStep_tac|]; eauto. 
   eapply RTLdfs.exec_Ijumptable ; eauto. 
   constructor; auto.  
   try_succ f pc pc'.
@@ -939,7 +958,7 @@ Proof.
   
   (* ireturn *)
   exploit instr_at; eauto; intros.
-  exists (RTLdfs.Returnstate ts (regmap_optget or Vundef rs) m'); split ; eauto. 
+  exists (RTLdfs.Returnstate ts (regmap_optget or Vundef rs) m'); split; [DStep_tac|]; eauto. 
   eapply RTLdfs.exec_Ireturn ; eauto.
   rewrite <- H0 ; eauto with valagree.
   rewrite stacksize_preserved with f tf ; eauto.
@@ -952,6 +971,7 @@ Proof.
     (init_regs args x.(RTLdfs.fn_params))
     m').
   split.
+  DStep_tac.
   eapply RTLdfs.exec_function_internal; eauto.
   rewrite stacksize_preserved with f x in H ; auto.
   replace (RTL.fn_entrypoint f) with (RTLdfs.fn_entrypoint x).
@@ -966,7 +986,8 @@ Proof.
 
   (* external *)
   inv SPEC.
-  exists (RTLdfs.Returnstate ts res m'). split. 
+  exists (RTLdfs.Returnstate ts res m'). split.
+  DStep_tac.
   eapply RTLdfs.exec_function_external; eauto.
   eapply external_call_symbols_preserved; eauto with valagree.
   econstructor ; eauto.
@@ -974,17 +995,113 @@ Proof.
   (* return state *)
   inv STACK. 
   exists (RTLdfs.State ts0 tf sp pc (rs# res <- vres) m);
-    split; ( try constructor ; eauto).
+    split; [DStep_tac|]; ( try constructor ; eauto).
 Qed.
-  
+
+Lemma match_states_xsim
+    st_src0 st_tgt0 gmtgt
+    (MATCH: match_states st_src0 st_tgt0) :
+  xsim (RTL.semantics prog) (RTLdfs.semantics tprog) gmtgt lt 0%nat st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold.
+  destruct (classic (RTL.is_external ge st_src0)); cycle 1.
+  (* not external *)
+  - left. econs. econs.
+    + i. exploit transl_step_correct; eauto. i. des; esplits; eauto.
+      { eapply tr_rel_refl. eapply ev_rel_refl. }
+      left. split.
+      { eapply plus_one; eauto. }
+      { eapply semantics_receptive_at; auto. }
+    + ii. eapply final_state_determ; eauto.
+      inv FINALSRC. inv MATCH. ss. inv STACK. econs.
+  (* external *)
+  - assert (SEQUIV: Senv.equiv tge ge) by (symmetry; eapply senv_preserved).
+    right. econs. i. econs.
+    + i. unfold is_external in *. des_ifs; i; inv MATCH.
+      (* builtin *)
+      * exploit instr_at; eauto. i.
+        inv STEPTGT; clarify.
+        left. (* exists O. *) esplits.
+        { eapply tr_rel_refl. eapply ev_rel_refl. }
+        { left. eapply plus_one.
+          eapply RTL.exec_Ibuiltin with (vargs:= vargs) ; eauto.
+          eapply eval_builtin_args_preserved with (2:= H10); eauto with valagree.
+          eapply external_call_symbols_preserved; eauto with valagree. }
+        { right. eapply CIH; eauto.
+          constructor; auto. try_succ f pc n. }
+        (* external call *)
+      * inv SPEC. inv STEPTGT.
+        esplits; eauto.
+        left. esplits; eauto.
+        { eapply tr_rel_refl. eapply ev_rel_refl. }
+        { left. eapply plus_one.
+          eapply RTL.exec_function_external; eauto.
+          eapply external_call_symbols_preserved; eauto with valagree. }
+    + i. ss. inv FINALTGT. ss. inv MATCH. ss.        
+    + i.
+      specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+      { inv SAFESRC; ss. }
+      right. inv MATCH; ss; des_ifs; inv SAFESRC; unfold ge in *; clarify.
+      * exploit instr_at; eauto. i.
+        esplits; eauto. eapply RTLdfs.exec_Ibuiltin; eauto.
+        eapply eval_builtin_args_preserved with (2:= H9); eauto with valagree.
+        eapply external_call_symbols_preserved; eauto with valagree.
+      * inv SPEC.
+        esplits; eauto.  eapply RTLdfs.exec_function_external; eauto.
+        eapply external_call_symbols_preserved; eauto with valagree.
+Qed.
+
+Lemma non_static_equiv l:
+  Genv.non_static_glob (Genv.globalenv prog) l = Genv.non_static_glob (Genv.globalenv tprog) l.
+Proof.
+  induction l; ss.
+  specialize senv_preserved. i. unfold ge, tge in H. r in H. des.
+  specialize (H0 a).
+  unfold Senv.public_symbol in H0. ss. rewrite <- H0.
+  specialize (H a). rewrite <- H. erewrite IHl; eauto.
+Qed.
+
+Lemma transf_initial_capture
+    S1 S2 S2'
+    (INITSRC: RTL.initial_state prog S1)
+    (INITTGT: RTLdfs.initial_state tprog S2)
+    (MATCH: match_states S1 S2)
+    (CAPTGT: RTLdfs.glob_capture tprog S2 S2'):
+  exists S1',
+    RTL.glob_capture prog S1 S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (RTL.concrete_snapshot ge S1') (RTLdfs.concrete_snapshot tge S2').
+Proof.
+  specialize senv_preserved. intros SENVEQ. inv CAPTGT. ss.
+  rewrite Genv.globalenv_public in CAPTURE.
+  rewrite <- same_public in CAPTURE. erewrite <- non_static_equiv in CAPTURE.
+  inv MATCH. inv STACK.
+  esplits.
+  - econs; eauto. rewrite Genv.globalenv_public. eauto.
+  - econs; eauto.
+  - ii. unfold RTL.concrete_snapshot, RTLdfs.concrete_snapshot in *.
+    inv SENVEQ. des. erewrite H1, H0. des_ifs; ss.
+Qed.
+
 Theorem transf_program_correct:
-  forward_simulation (RTL.semantics prog) (RTLdfs.semantics tprog).
+  mixed_simulation (RTL.semantics prog) (RTLdfs.semantics tprog).
 Proof.
-  eapply forward_simulation_step.
-  eapply senv_preserved.
-  eexact transf_initial_states.
-  eexact transf_final_states.
-  exact transl_step_correct. 
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (S a). lia.
+  - econs. i. exploit transf_initial_states; eauto. i. des.
+    exists st2. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. inversion INITSRC; subst. inversion H0; subst.
+      inv STACK.
+      exploit transf_initial_capture; eauto.
+      i. des.
+      exists 0%nat. exists S1'. esplits; eauto.
+      apply match_states_xsim; auto.
+  - i. apply senv_preserved.
 Qed.
 
 End PRESERVATION.
diff --git a/midend/RTLdpar.v b/midend/RTLdpar.v
index e740b156..253c5247 100644
--- a/midend/RTLdpar.v
+++ b/midend/RTLdpar.v
@@ -376,8 +376,8 @@ Proof.
   - destruct (st_wf s pc) as [Hcase1 | [ [Hcase21 Hcase22] | Hcase3]].  
     + left ; auto.
     + right ; left. intuition.
-      apply Ple_Plt_succ ; eauto.
-      apply Plt_Ple ; auto.
+      (* apply Ple_Plt_succ ; eauto. *)
+      (* apply Plt_Ple ; auto. *)
     + right ; right.
       rewrite PTree.gso ; auto.  
 Qed.
diff --git a/midend/RTLdparproof.v b/midend/RTLdparproof.v
index fdef13bd..a6b595aa 100644
--- a/midend/RTLdparproof.v
+++ b/midend/RTLdparproof.v
@@ -10,6 +10,7 @@ Require Import Values.
 Require Import Globalenvs.
 Require Import Op.
 Require Import Registers.
+Require Import PointerOp Simulation RTLparD RTLD sflib.
 Require Import Smallstep.
 Require Import RTL.
 Require Import SSA.
@@ -26,6 +27,8 @@ Require Import DLib.
 Require Import CSSAproof.
 Require Import RTLpar.
 Require Import RTLdpar.
+Require Import Classical.
+From Paco Require Import paco.
 
 Lemma max_reg_correct_code: forall f,
     Ple (CSSAgen.get_max_reg_in_code (RTLpar.fn_code f))
@@ -868,7 +871,10 @@ Section PRESERVATION.
 
     Let ge := Genv.globalenv prog.
     Let tge := Genv.globalenv tprog.
-    
+
+    Let sem := RTLpar.semantics prog.
+    Let tsem := RTL.semantics tprog.
+
     Lemma symbols_preserved:
       forall (s: ident), Genv.find_symbol tge s = Genv.find_symbol ge s.
     Proof.
@@ -915,23 +921,23 @@ Section PRESERVATION.
     Qed. 
 
     Lemma spec_ros_r_find_function:
-      forall  rs rs' f r,
-        find_function ge (inl _ r) rs = Some f ->
+      forall  rs rs' f r m,
+        find_function ge (RTLpar.ros_to_vos m (inl _ r) rs) rs = Some f ->
         rs# r = rs'#r ->
         exists tf,
-          RTL.find_function tge (inl _ r) rs' = Some tf
+          RTL.find_function tge (RTL.ros_to_vos m (inl _ r) rs') rs' = Some tf
           /\ RTLdpar.transl_fundef f = Errors.OK tf.
     Proof.
-      intros.
-      eapply functions_translated; eauto. inv H. 
-      rewrite H0 ; auto.
+      intros. ss. des_ifs.
+      eapply functions_translated; eauto.
+      eapply functions_translated; eauto.
     Qed.
 
     Lemma spec_ros_id_find_function:
-      forall rs rs' f id,
-        find_function ge (inr _ id) rs = Some f ->
+      forall rs rs' f id m,
+        find_function ge (RTLpar.ros_to_vos m (inr _ id) rs) rs = Some f ->
         exists tf,
-          RTL.find_function tge (inr _ id) rs' = Some tf
+          RTL.find_function tge (RTL.ros_to_vos m (inr _ id) rs') rs' = Some tf
           /\ RTLdpar.transl_fundef f = Errors.OK tf.
     Proof.
       intros.
@@ -955,6 +961,10 @@ Section PRESERVATION.
     Proof.
       eapply Genv.senv_transf_partial; eauto.
     Qed.
+    
+    Lemma same_public:
+      prog_public prog = prog_public tprog.
+    Proof. inv TRANSF_PROG. des; eauto. Qed.
 
 Create HintDb valagree.
 Hint Resolve symbols_preserved : valagree.
@@ -974,18 +984,18 @@ Definition parcopy_store_e (parcb: list (reg * reg) ) (rs: regset) : regset :=
     
 Lemma reach_moves_star :  forall mvs fresh ts sp rs  m tf  succ lnew ,
   reach_moves (RTL.fn_code tf) fresh succ mvs lnew ->
-  star RTL.step tge (RTL.State ts tf sp fresh rs m) E0 
+  DStar tsem (RTL.State ts tf sp fresh rs m) E0 
                     (RTL.State ts tf sp succ (parcopy_store_e mvs rs) m).
 Proof.
   induction mvs; intros.
   - simpl in *.  
     invh reach_moves.
-    eapply star_step ; eauto; go.
+    eapply star_step ; try DStep_tac ; eauto; go.
   - invh reach_moves. 
     eapply star_step 
     with  (s2 := (RTL.State ts tf sp succ0 
                             rs # dst <- 
-                            (rs# src)) m) (t2:= E0) (t1:= E0); auto.
+                            (rs# src)) m) (t2:= E0) (t1:= E0); auto; try DStep_tac.
     + eapply RTL.exec_Iop ; eauto. 
     + exploit IHmvs; eauto.
 Qed.
@@ -1003,13 +1013,13 @@ Lemma reach_moves_star_last :  forall mvs l fresh tf succ,
   reach_moves (RTL.fn_code tf) fresh succ mvs l ->
   forall a lnew, rev l = (a::lnew) ->
   forall  ts sp rs  m,               
-  star RTL.step tge (RTL.State ts tf sp fresh rs m) E0 
+  DStar tsem (RTL.State ts tf sp fresh rs m) E0 
                     (RTL.State ts tf sp a (parcopy_store_e mvs rs) m).
 Proof.
   induction 1 ; intros. 
   - simpl in *. inv H0.
     eapply star_refl ; eauto. 
-  - simpl in *. eapply star_step ; eauto.
+  - simpl in *. eapply star_step ; try DStep_tac; eauto.
     + eapply RTL.exec_Iop ; eauto; go.
     + case_eq (rev l) ; intros. 
       * exploit @rev_nil_nil; eauto ; intros. 
@@ -1256,10 +1266,11 @@ Qed.
 (** ** This relation is indeed a simulation *)
 Lemma transl_step_correct:
   forall s1 t s2,
-    step ge s1 t s2 ->
+    IStep sem s1 t s2 ->
     forall s1' (MS: match_states s1 s1'),
-      exists s2', plus RTL.step tge s1' t s2' /\ match_states s2 s2'.
-Proof.    
+      exists s2', DPlus tsem s1' t s2' /\ match_states s2 s2'.
+Proof.
+  destruct 1. generalize dependent s2. rename H into INT.
   induction 1; intros; inv MS; auto;
   match goal with 
     | [H : transl_fundef (Internal ?f) = _ |- _ ] => idtac
@@ -1278,7 +1289,7 @@ Proof.
     
     + rewrite H7.
       exists (RTL.State ts tf sp succ rs' m). split.
-      * eapply plus_one; eauto.
+      * eapply plus_one; DStep_tac; eauto.
         econstructor; eauto.
       * clear H7. subst. 
         
@@ -1296,7 +1307,7 @@ Proof.
       invh join_point; go. 
 
     + exists (RTL.State ts tf sp succ rs' m). split.
-      * eapply plus_one; eauto.
+      * eapply plus_one; DStep_tac; eauto.
         econstructor; eauto.
       * assert (HRsucc: succ = (map_pc (mapping f)) succ). 
         { symmetry. 
@@ -1324,12 +1335,12 @@ Proof.
                    (parcopy_store_e (seq_parmoves (fresh_init f) (parcb_to_moves parcb0))
                                     rs')) m). 
         { split.
-          - eapply plus_left; eauto. 
+          - eapply plus_left; try DStep_tac; eauto. 
             + econstructor; eauto.
             + eapply star_trans; eauto.
               * eapply reach_moves_star in H10; eauto.
               * eapply star_trans; eauto. 
-                eapply star_step; eauto; go.
+                eapply star_step; try DStep_tac; eauto; go.
                 eapply reach_moves_star_last ; eauto using rev_involutive.
             + auto.
           - rewrite H7. econstructor; eauto. 
@@ -1347,11 +1358,13 @@ Proof.
     rewrite H6 in *. clear H6. subst. 
     exists  (RTL.State ts tf sp pc' (rs' # res <- v) m). 
     split.
-    + eapply plus_one ; eauto. 
+    + eapply plus_one ; try DStep_tac; eauto. 
       simpl in *. econstructor 2 ; eauto.
       rewrite <- H0 ; eauto.
       symmetry.
-      erewrite match_regset_args ; eauto with valagree.   
+      erewrite match_regset_args ; eauto with valagree.
+      symmetry. eapply eval_operation_wrapper_preserved.
+      eapply senv_preserved.
       assert (HH:= get_maxreg_is_not_temp_code f pc); flatten HH; eauto.
     + assert (HRpc': map_pc (mapping f) pc' = pc') 
         by (eapply wf_ninop_id_succ; eauto using transl_function_spec_ok; go).
@@ -1368,7 +1381,7 @@ Proof.
     rewrite H7 in * ; clear H7. subst.
     exists  (RTL.State ts tf sp pc' (rs'#dst <- v) m).
     split.
-    + eapply plus_one ; eauto. 
+    + eapply plus_one ; try DStep_tac; eauto. 
       simpl in *. econstructor 3 ; eauto.
       rewrite <- H0 ; eauto.
       symmetry. erewrite match_regset_args ; eauto with valagree. 
@@ -1385,7 +1398,7 @@ Proof.
     normalized pc ; allinv_par.
     rewrite H7 in * ; clear H7 ; subst.
     exists  (RTL.State ts tf sp pc' rs' m'). split.
-    + eapply plus_one ; eauto. 
+    + eapply plus_one ; try DStep_tac; eauto. 
       econstructor 4 with (a:= a) ; eauto. 
       * rewrite <- H0 ; eauto with valagree.
         symmetry. erewrite match_regset_args ; eauto with valagree.
@@ -1408,7 +1421,7 @@ Proof.
          (exists (RTL.Callstate (RTL.Stackframe res tf sp pc' rs' :: ts) 
                                 tf' rs' ## args
                                 m) ; split;
-             [(eapply plus_one ; eauto);
+             [(eapply plus_one; try DStep_tac ; eauto);
                (eapply RTL.exec_Icall  ; eauto); 
                (eauto with valagree)
              | ])).
@@ -1417,15 +1430,17 @@ Proof.
         rewrite <- HRpc' at 2. clear HRpc'.      
         { erewrite match_regset_args ; eauto.
           econstructor ; auto.
-          - eapply Genv.find_funct_prop ; eauto.
-          - eapply Genv.find_funct_prop ; eauto.
+          - unfold ros_to_vos in H0. des_ifs. simpl in H0. eapply Genv.find_funct_prop ; eauto.
+            eapply Genv.find_funct_prop ; eauto. instantiate (1 := Vptr b i). ss.
+          - unfold ros_to_vos in H0. des_ifs. simpl in H0. eapply Genv.find_funct_prop ; eauto.
+            eapply Genv.find_funct_prop ; eauto. instantiate (1 := Vptr b i). ss.
           - assert (HH:= get_maxreg_is_not_temp_code f pc); flatten HH; eauto.
         }
 
     + exploit (spec_ros_id_find_function  rs rs') ; eauto.
       ((intros [tf' [Hfind OKtf']]);
        (exists (RTL.Callstate (RTL.Stackframe res tf sp pc' rs' :: ts) tf' rs' ## args m) ; split;
-               [(eapply plus_one ; eauto);
+               [(eapply plus_one; try DStep_tac ; eauto);
                  (eapply RTL.exec_Icall  ; eauto); 
                  (eauto with valagree)
                | ])).
@@ -1453,15 +1468,19 @@ Proof.
       * (intros [tf' [Hfind OKtf']]);
         (exploit (sig_function_translated f tf) ; eauto ; intros);
         ((exists (RTL.Callstate ts tf' rs'##args m');  split);
-         [  (eapply plus_one ; eauto); 
+         [  (eapply plus_one; try DStep_tac ; eauto); 
            (eapply RTL.exec_Itailcall ; eauto with valagree);
            (replace (RTL.fn_stacksize tf) with (fn_stacksize f); eauto with valagree)
           | ]).
         { replace (rs' ## args) with (rs## args).
           - econstructor ; eauto.
             simpl in H0.
-            eapply Genv.find_funct_prop ; eauto.
-            eapply Genv.find_funct_prop ; eauto.
+            + unfold ros_to_vos in H0. des_ifs.
+              eapply Genv.find_funct_prop ; eauto. instantiate (1 := Vptr b (Ptrofs.repr z)). ss.
+              eapply Genv.find_funct_prop ; eauto. instantiate (1 := Vptr b i). ss.
+            + unfold ros_to_vos in H0. des_ifs.
+              eapply Genv.find_funct_prop ; eauto.
+              eapply Genv.find_funct_prop ; eauto. instantiate (1 := Vptr b i). ss.
           - eapply match_regset_args ; eauto. 
             assert (HH:= get_maxreg_is_not_temp_code f pc); flatten HH; eauto.
         }     
@@ -1469,7 +1488,7 @@ Proof.
       (intros [tf' [Hfind OKtf']]);
         (exploit (sig_function_translated f tf) ; eauto ; intros);
         ((exists (RTL.Callstate ts tf' rs'##args m');  split);
-         [  (eapply plus_one ; eauto); 
+         [  (eapply plus_one; try DStep_tac ; eauto); 
            (eapply RTL.exec_Itailcall ; eauto with valagree);
            (replace (RTL.fn_stacksize tf) with (fn_stacksize f); eauto with valagree)
           | ]).
@@ -1490,7 +1509,8 @@ Proof.
     rewrite H7 in * ; clear H7 ; subst. 
     exists  (RTL.State ts tf sp pc' (regmap_setres res vres rs') m'). 
     split.
-    + eapply plus_one ; eauto. 
+    + eapply plus_one ; eauto.
+      DStep_tac. unfold is_internal in INT. ss. des_ifs.
       eapply RTL.exec_Ibuiltin with (vargs := vargs) ; eauto.
       assert (HH:= get_maxreg_is_not_temp_code f pc); flatten HH; eauto.
       { eapply eval_builtin_args_preserved with (ge1 := ge); eauto.
@@ -1561,35 +1581,38 @@ Proof.
     normalized pc; allinv_par.
     rewrite H6 in * ; clear H6 ; subst.
     exists (RTL.State ts tf sp ifso rs' m); split ; eauto. 
-    eapply plus_one ; eauto.  
-    eapply RTL.exec_Icond ; eauto. 
+    eapply plus_one ; eauto.
+    DStep_tac.
+    eapply RTL.exec_Icond ; eauto.
     erewrite <- match_regset_args ; eauto with valagree.
     assert (HH:= get_maxreg_is_not_temp_code f pc); flatten HH; eauto.
     reflexivity.
     assert (HRpc': map_pc (mapping f) ifso = ifso)
         by (eapply wf_ninop_id_succ; eauto using transl_function_spec_ok; go).
-    rewrite <- HRpc' at 2. clear HRpc'.      
-    econstructor 1 ; eauto. 
+    rewrite <- HRpc' at 2. clear HRpc'.
+    econstructor 1 ; eauto.
       
   - (* ifnot *)
     normalized pc; allinv_par.
     rewrite H6 in * ; clear H6 ; subst.
     exists (RTL.State ts tf sp ifnot rs' m); split ; eauto. 
     eapply plus_one ; eauto.  
+    DStep_tac.
     eapply RTL.exec_Icond ; eauto. 
     erewrite <- match_regset_args ; eauto with valagree.
     assert (HH:= get_maxreg_is_not_temp_code f pc); flatten HH; eauto.
     reflexivity.
     assert (HRpc': map_pc (mapping f) ifnot = ifnot)
         by (eapply wf_ninop_id_succ; eauto using transl_function_spec_ok; go).
-    rewrite <- HRpc' at 2. clear HRpc'.      
-    econstructor 1 ; eauto. 
+    rewrite <- HRpc' at 2. clear HRpc'.
+    econstructor 1 ; eauto.
 
   - (* ijump *)
     normalized pc; allinv_par.
     rewrite H7 in * ; clear H7 ; subst.
     exists (RTL.State ts tf sp pc' rs' m); split ; eauto. 
     + eapply plus_one ; eauto.
+      DStep_tac.
       eapply RTL.exec_Ijumptable ; eauto.
       inv MREG. erewrite <- H3 ; eauto.
       assert (HH:= get_maxreg_is_not_temp_code f pc); flatten HH; eauto.
@@ -1606,6 +1629,7 @@ Proof.
     rewrite H7 in * ; clear H7 ; subst.
     exists (RTL.Returnstate ts (regmap_optget or Vundef rs') m'); split ; eauto. 
     + eapply plus_one ; eauto.
+      DStep_tac.
       eapply RTL.exec_Ireturn ; eauto.
       rewrite <- H0 ; eauto with valagree.
       rewrite stacksize_preserved with f tf ; eauto.
@@ -1626,6 +1650,7 @@ Proof.
     exploit transl_function_spec_ok; eauto. intros SPEC.
     split.
     + eapply plus_one ; eauto.
+      DStep_tac.
       eapply RTL.exec_function_internal; eauto.
       rewrite stacksize_preserved with f x in H ; auto.
     + assert ((RTL.fn_entrypoint x) = (map_pc (mapping f) (fn_entrypoint f))).
@@ -1663,6 +1688,7 @@ Proof.
     inv SPEC.
     exists (RTL.Returnstate ts res m'). split. 
     eapply plus_one ; eauto.
+    DStep_tac.
     eapply RTL.exec_function_external; eauto.
     eapply external_call_symbols_preserved; eauto with valagree.
     econstructor ; eauto.
@@ -1672,6 +1698,7 @@ Proof.
     exists (RTL.State ts0 tf sp (map_pc (mapping f) pc) (rs'# res <- vres) m).
     split. 
     + eapply plus_one ; eauto.
+      DStep_tac.
       econstructor.
     + econstructor; eauto. 
       constructor. intros. 
@@ -1679,20 +1706,265 @@ Proof.
       * inv e. rewrite PMap.gss. rewrite PMap.gss; auto.
       * rewrite PMap.gso; auto. rewrite PMap.gso; auto. 
         inv MREG ; auto.
+        Unshelve. all: eapply true.
 Qed.
 
+Lemma match_states_bsim
+      s1
+      (EXT: is_external ge s1)
+      s2 t s2'
+      (STEPTGT: Step tsem s2 t s2')
+      (MATCH: match_states s1 s2)
+      (SAFESRC: safe sem s1)
+  :
+    (exists s1', Step sem s1 t s1' /\ match_states s1' s2').
+Proof.
+  assert (SEQUIV: Senv.equiv tge ge) by (symmetry; apply senv_preserved).
+  unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+  { inv SAFESRC. inv MATCH. ss. }
+  unfold is_external in *. des_ifs. inv MATCH; ss.
+  (* builtin *)
+  - match goal with 
+    | [H : transl_fundef (Internal ?f) = _ |- _ ] => idtac
+    | [H : transl_fundef (External ?f) = _ |- _ ] => idtac
+    | [  |- context [RTL.Returnstate ?ts ?vres ?m]] => idtac
+    | _ => 
+        ( (exploit transl_function_spec_ok ; eauto; intros))
+    end; 
+    try match goal with 
+      | [SPEC: transl_function_spec ?f ?tf ?R |- _ ] => 
+          generalize SPEC ; inv SPEC ; intros SPEC
+      end; allinv_par.
+    normalized pc; allinv_par.
+    inv STEPTGT; rewrite <- H3, H4 in *; clarify.
+    exists (RTLpar.State stack f sp n (regmap_setres b vres rs) m').
+    split.
+    + eapply exec_Ibuiltin with (vargs := vargs) ; eauto.
+      assert (HH:= get_maxreg_is_not_temp_code f pc); flatten HH; eauto.
+      { eapply eval_builtin_args_preserved. i. symmetry. eapply senv_preserved.
+        inv MREG. 
+        revert H13 HH H0. clear.
+        induction 1 ; intros; go.
+        simpl. constructor.
+        - revert H HH H0. clear. induction 1 ; intros; go.
+          + simpl. rewrite <- H0; go.
+          + simpl. 
+            constructor.
+            * eapply IHeval_builtin_arg1; eauto.
+              simpl. intros. eapply HH; eauto. simpl.
+              eapply in_app_or in H2. 
+              eapply in_or_app.  intuition.
+              right. eapply in_or_app.
+              eapply in_app_or in H3. 
+              intuition.
+            * eapply IHeval_builtin_arg2; eauto.
+              simpl. intros. eapply HH; eauto. simpl.
+              eapply in_app_or in H2. 
+              eapply in_or_app.  intuition.
+              right. eapply in_or_app.
+              eapply in_app_or in H3. 
+              intuition.
+              
+          + simpl. 
+            constructor.
+            * eapply IHeval_builtin_arg1; eauto.
+              simpl. intros. eapply HH; eauto. simpl.
+              eapply in_app_or in H2. 
+              eapply in_or_app.  intuition.
+              right. eapply in_or_app.
+              eapply in_app_or in H3. 
+              intuition.
+              
+            * eapply IHeval_builtin_arg2; eauto.
+              simpl. intros. eapply HH; eauto. simpl.
+              eapply in_app_or in H2. 
+              eapply in_or_app.  intuition.
+              right. eapply in_or_app.
+              eapply in_app_or in H3. 
+              intuition.
+              
+        - eapply IHlist_forall2; eauto.
+          intros. eapply HH; eauto. simpl.
+          eapply in_app_or in H1.
+          intuition.
+      }
+      eapply external_call_symbols_preserved; eauto with valagree.
+    + assert (HRpc': map_pc (mapping f) n = n)
+        by (eapply wf_ninop_id_succ; eauto using transl_function_spec_ok; go).
+      rewrite <- HRpc' at 2. clear HRpc'.      
+      econstructor 1 ; eauto. 
+      constructor. intros.
+      destruct b ; simpl; go.
+      * { destruct (peq x r). 
+          - inv e0. rewrite PMap.gss. rewrite PMap.gss; auto.
+          - rewrite PMap.gso; auto. rewrite PMap.gso; auto.
+            inv MREG ; auto.
+        }
+      * inv MREG ; auto.
+      * inv MREG ; auto.
+  (* external *)
+  - inv MATCH; ss. inv STEPTGT; try by clarify.
+    inv SPEC.
+    exists (Returnstate stack res m'). split.
+    eapply exec_function_external; eauto.
+    eapply external_call_symbols_preserved; eauto with valagree.
+    econstructor ; eauto.
+Qed.
+
+Lemma match_states_xsim
+    st_src0 st_tgt0 gmtgt
+    (MATCH: match_states st_src0 st_tgt0) :
+  xsim (semantics prog) (RTL.semantics tprog) gmtgt lt 0%nat st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold.
+  destruct (classic (is_external ge st_src0)); cycle 1.
+  (* not external *)
+  - left. econs. econs.
+    + i. exploit transl_step_correct; eauto. i. des.
+      * esplits; eauto.
+        { eapply tr_rel_refl. eapply ev_rel_refl. }
+        left. split; eauto.
+        eapply RTLparD.semantics_receptive_at; auto.
+    + ii. eapply final_state_determ; eauto.
+      inv FINALSRC. inv MATCH. ss. inv STACK. econs.
+  (* external *)
+  - right. econs. i. econs.
+    + i. exploit match_states_bsim; eauto. i. des.
+      left. esplits; eauto.
+      { eapply tr_rel_refl. eapply ev_rel_refl. }
+      left. eapply plus_one. eauto.
+    + i. unfold is_external in *.
+      des_ifs; inv FINALTGT; inv MATCH; ss.
+    (* progress *)
+    + i.
+      specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+      { inv SAFESRC; ss. }
+      right. inv MATCH; ss; des_ifs; inv SAFESRC; unfold ge in *; clarify.
+      * match goal with 
+        | [H : transl_fundef (Internal ?f) = _ |- _ ] => idtac
+        | [H : transl_fundef (External ?f) = _ |- _ ] => idtac
+        | [  |- context [RTL.Returnstate ?ts ?vres ?m]] => idtac
+        | _ => 
+            ( (exploit transl_function_spec_ok ; eauto; intros))
+        end; 
+        try match goal with 
+          | [SPEC: transl_function_spec ?f ?tf ?R |- _ ] => 
+              generalize SPEC ; inv SPEC ; intros SPEC
+          end; allinv_par.
+        normalized pc; allinv_par.
+        rewrite H5 in * ; clear H5 ; subst. 
+        esplits. eapply RTL.exec_Ibuiltin with (vargs:=vargs); eauto.
+        assert (HH:= get_maxreg_is_not_temp_code f pc); flatten HH; eauto.
+        { eapply eval_builtin_args_preserved with (ge1 := ge); eauto.
+          apply senv_preserved.
+          inv MREG. 
+          revert H9 HH H1. clear.
+          induction 1 ; intros; go.
+          simpl. constructor.
+          - revert H HH H1. clear. induction 1 ; intros; go.
+            + simpl. rewrite H1; go.
+            + simpl. 
+              constructor.
+              * eapply IHeval_builtin_arg1; eauto.
+                simpl. intros. eapply HH; eauto. simpl.
+                eapply in_app_or in H2. 
+                eapply in_or_app.  intuition.
+                right. eapply in_or_app.
+                eapply in_app_or in H3. 
+                intuition.
+              * eapply IHeval_builtin_arg2; eauto.
+                simpl. intros. eapply HH; eauto. simpl.
+                eapply in_app_or in H2. 
+                eapply in_or_app.  intuition.
+                right. eapply in_or_app.
+                eapply in_app_or in H3. 
+                intuition.
+                
+            + simpl. 
+              constructor.
+              * eapply IHeval_builtin_arg1; eauto.
+                simpl. intros. eapply HH; eauto. simpl.
+                eapply in_app_or in H2. 
+                eapply in_or_app.  intuition.
+                right. eapply in_or_app.
+                eapply in_app_or in H3. 
+                intuition.
+                
+              * eapply IHeval_builtin_arg2; eauto.
+                simpl. intros. eapply HH; eauto. simpl.
+                eapply in_app_or in H2. 
+                eapply in_or_app.  intuition.
+                right. eapply in_or_app.
+                eapply in_app_or in H3. 
+                intuition.
+                
+          - eapply IHlist_forall2; eauto.
+            intros. eapply HH; eauto. simpl.
+            eapply in_app_or in H0.
+            intuition.
+        }
+        eapply external_call_symbols_preserved with (ge1:=ge); eauto.
+        eapply senv_preserved.
+      * i. inv SPEC.
+        esplits. eapply RTL.exec_function_external.
+        eapply external_call_symbols_preserved with (ge1:=ge); eauto.
+        eapply senv_preserved.
+Qed.
+
+Lemma non_static_equiv l:
+  Genv.non_static_glob (Genv.globalenv prog) l = Genv.non_static_glob (Genv.globalenv tprog) l.
+Proof.
+  induction l; ss.
+  specialize senv_preserved. i. unfold ge, tge in H. r in H. des.
+  specialize (H0 a).
+  unfold Senv.public_symbol in H0. ss. rewrite <- H0.
+  specialize (H a). rewrite <- H. erewrite IHl; eauto.
+Qed.
+
+Lemma transf_initial_capture
+    S1 S2 S2'
+    (INITSRC: RTLpar.initial_state prog S1)
+    (INITTGT: RTL.initial_state tprog S2)
+    (MATCH: match_states S1 S2)
+    (CAPTGT: RTL.glob_capture tprog S2 S2'):
+  exists S1',
+    RTLpar.glob_capture prog S1 S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (RTLpar.concrete_snapshot ge S1') (RTL.concrete_snapshot tge S2').
+Proof.
+  specialize senv_preserved. intros SENVEQ. inv CAPTGT. ss.
+  rewrite Genv.globalenv_public in CAPTURE.
+  rewrite <- same_public in CAPTURE. erewrite <- non_static_equiv in CAPTURE.
+  inv MATCH. inv STACK.
+  esplits.
+  - econs; eauto. rewrite Genv.globalenv_public. eauto.
+  - econs; eauto.
+  - ii. unfold RTLpar.concrete_snapshot, RTL.concrete_snapshot in *.
+    inv SENVEQ. des. erewrite H1, H0. des_ifs; ss.
+Qed.
 
 (** * Semantics preservation *)  
 Theorem transf_program_correct:
-  forward_simulation (semantics prog) (RTL.semantics tprog).
+  mixed_simulation (RTLpar.semantics prog) (RTL.semantics tprog).
 Proof.
-  eapply forward_simulation_plus with (match_states := match_states). 
-  eapply senv_preserved.
-  eexact transf_initial_states.
-  eexact transf_final_states.
-  exact transl_step_correct.
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (S a). lia.
+  - econs. i. exploit transf_initial_states; eauto. i. des.
+    exists st2. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. inversion INITSRC; subst. inversion H0; subst.
+      inv STACK.
+      exploit transf_initial_capture; eauto.
+      i. des.
+      exists 0%nat. exists S1'. esplits; eauto.
+      apply match_states_xsim; auto.
+  - i. apply senv_preserved.
 Qed.
 
-  End CORRECTNESS.
+End CORRECTNESS.
   
 End PRESERVATION.
diff --git a/midend/RTLnormproof.v b/midend/RTLnormproof.v
index 6846deb7..45c63c45 100644
--- a/midend/RTLnormproof.v
+++ b/midend/RTLnormproof.v
@@ -12,6 +12,7 @@ Require Import Values.
 Require Import Globalenvs.
 Require Import Op.
 Require Import Registers.
+Require Import PointerOp RTLD sflib Simulation.
 Require Import Smallstep.
 Require Import RTL.
 Require Import RTLnorm.
@@ -21,6 +22,9 @@ Require Import Conventions.
 Require Import Utils.
 Require Import Events.
 Require Import Linking.
+Require Import Classical.
+From Paco Require Import paco.
+
 Unset Allow StrictProp.
 
 Section PRESERVATION.
@@ -42,7 +46,10 @@ Section PRESERVATION.
 
     Let ge := Genv.globalenv prog.
     Let tge := Genv.globalenv tprog.
-  
+
+    Let sem := RTL.semantics prog.
+    Let tsem := RTL.semantics tprog.
+
     Lemma symbols_preserved:
       forall (s: ident), Genv.find_symbol tge s = Genv.find_symbol ge s.
     Proof.
@@ -71,6 +78,10 @@ Section PRESERVATION.
       eapply Genv.senv_transf_partial; eauto.
     Qed.
 
+    Lemma same_public:
+      prog_public prog = prog_public tprog.
+    Proof. inv TRANSF_PROG. des; eauto. Qed.
+
     Lemma sig_fundef_translated:
       forall f tf,
         transl_fundef f = Errors.OK tf ->
@@ -94,21 +105,21 @@ Section PRESERVATION.
     Qed. 
 
     Lemma spec_ros_r_find_function:
-      forall rs f r,
-        RTL.find_function ge (inl _ r) rs = Some f ->
+      forall rs f r m,
+        RTL.find_function ge (ros_to_vos m (inl _ r) rs) rs = Some f ->
         exists tf,
-          RTL.find_function tge (inl _ r) rs = Some tf
+          RTL.find_function tge (ros_to_vos m (inl _ r) rs) rs = Some tf
           /\ transl_fundef f = Errors.OK tf.
     Proof.
-      intros.
+      intros. unfold ros_to_vos; ss. des_ifs;
       eapply functions_translated; eauto.
     Qed.
 
     Lemma spec_ros_id_find_function:
-      forall rs f id,
-        RTL.find_function ge (inr _ id) rs = Some f ->
+      forall rs f id m,
+        RTL.find_function ge (ros_to_vos m (inr _ id) rs) rs = Some f ->
         exists tf,
-          RTL.find_function tge (inr _ id) rs = Some tf
+          RTL.find_function tge (ros_to_vos m (inr _ id) rs) rs = Some tf
           /\ transl_fundef f = Errors.OK tf.
     Proof.
       intros.
@@ -204,13 +215,25 @@ Section PRESERVATION.
 
     Lemma reach_nop_star :  forall ts pt regs m aux x pcx pc,
         reach_nops (fn_code x) pcx pc aux ->
-        star step tge (RTL.State ts x pt pcx regs m) E0 (RTL.State ts x pt pc regs m).
+        star (fun _ : genvtype tsem => DStep tsem) (globalenv tsem) (RTL.State ts x pt pcx regs m) E0 (RTL.State ts x pt pc regs m).
+    Proof.
+      induction aux; intros.
+      - inv H.  eapply star_step. DStep_tac ; eauto ; go. go. traceEq.
+      - inv H.
+        exploit IHaux ; eauto. i. eapply star_left; eauto.
+        DStep_tac. eapply exec_Inop; eauto. traceEq.
+    Qed.
+
+    Lemma reach_nop_star_src :  forall ts pt regs m aux x pcx pc,
+        reach_nops (fn_code x) pcx pc aux ->
+        star (fun _ : genvtype sem => Step sem) (globalenv sem) (RTL.State ts x pt pcx regs m) E0 (RTL.State ts x pt pc regs m).
     Proof.
       induction aux; intros.
-      - inv H.  eapply star_step ; eauto ; go. 
+      - inv H.  eapply star_step.  eauto ; go. go. traceEq.
       - inv H.
-        exploit IHaux ; eauto; go.
-    Qed.  
+        exploit IHaux ; eauto. i. eapply star_left; eauto.
+        eapply exec_Inop; eauto. traceEq.
+    Qed.
 
     Ltac allinv := 
       repeat 
@@ -256,16 +279,27 @@ Ltac succ n s :=
   match goal with 
     | id : forall (k : nat) (succ succ' : node), _ |- _ =>
        specialize (id n); simpl in *;
-       exploit id; eauto; intros [HC1 | [nops HC2]]; subst;
-       exists s ; (split ; go ; (econstructor ; eauto using reach_nop_star ; go))
+       exploit id; eauto; intros [HC1 | [nops [HC2 HC3]]]; subst;
+       exists s ; (split ; go ; (econstructor; try DStep_tac; eauto using reach_nop_star; go))
   end.
 
+(* Ltac succ n s :=  *)
+(*   match goal with  *)
+(*     | id : forall (k : nat) (succ succ' : node), _ |- _ => *)
+(*        specialize (id n); simpl in *; *)
+(*        exploit id; eauto; intros [HC1 | [nops HC2]]; subst; *)
+(*        exists s ; (split ; go ; (econstructor; try DStep_tac; eauto using reach_nop_star; go)) *)
+(*   end. *)
+
+(* try DStep_tac ; *)
+
 Lemma transl_step_correct:
   forall s1 t s2,
-    step ge s1 t s2 ->
+    IStep sem s1 t s2 ->
     forall s1' (MS: match_states s1 s1'),
-      exists s2', plus step tge s1' t s2' /\ match_states s2 s2'.
+    exists s2', DPlus tsem s1' t s2' /\ match_states s2 s2'.
 Proof.
+  destruct 1. generalize dependent s2. rename H into INT.
   induction 1; intros; inv MS; auto; 
   match goal with 
     | [H : transl_fundef (Internal ?f) = _ |- _ ] => idtac
@@ -281,18 +315,20 @@ Proof.
   
   - (* inop *)
     normalized.
-    succ O (RTL.State ts tf sp pc' rs m). 
-
+    succ O (RTL.State ts tf sp pc' rs m).
+    
   - (* iop *)
     normalized. 
     succ O (RTL.State ts tf sp pc' (rs#res <- v) m).
     + econstructor 2 ; eauto.
-      rewrite <- H0 ; eauto with valagree. 
-    + auto. 
+      rewrite <- H0 ; eauto with valagree.
+      eapply eval_operation_wrapper_preserved. eapply senv_preserved.
+    + auto.
     + econstructor 2 ; eauto.
-      rewrite <- H0 ; eauto with valagree. 
-    + auto. 
-  
+      rewrite <- H0 ; eauto with valagree.
+      eapply eval_operation_wrapper_preserved. eapply senv_preserved.
+    + auto.
+
   - (* iload *)
     normalized. 
     succ O (RTL.State ts tf sp pc' (rs#dst <- v) m);
@@ -320,10 +356,10 @@ Proof.
       | exploit spec_ros_id_find_function ; eauto] ; 
       (intros [tf' [Hfind OKtf']]).
     + specialize (H5 O) ; simpl in *.
-      exploit H5 ; eauto ; intros [HC1 | [aux' HC2]]; subst.
+      exploit H5 ; eauto ; intros [HC1 | [aux' [HC2 HC3]]]; subst.
       * exists (Callstate (Stackframe res tf sp pc' rs :: ts) tf' rs ## args m); split;
         [   (eapply plus_one ; eauto);
-          (eapply exec_Icall  ; eauto); 
+          (DStep_tac; eapply exec_Icall  ; eauto); 
           (eauto with valagree)
           |
           (constructor ; auto);
@@ -332,7 +368,7 @@ Proof.
             (symmetry ; eauto with valagree)].
       * exists (Callstate (Stackframe res tf sp s2 rs :: ts) tf' rs ## args m); split.
         { (eapply plus_one ; eauto);
-          (eapply exec_Icall  ; eauto); 
+          (DStep_tac; eapply exec_Icall  ; eauto); 
           (eauto with valagree). }
         { (constructor ; auto);
           (econstructor ; eauto);
@@ -340,10 +376,10 @@ Proof.
           (symmetry ; eauto with valagree). } 
 
     + specialize (H5 O) ; simpl in *.
-      exploit H5 ; eauto ; intros [HC1 | [aux' HC2]]; subst.
+      exploit H5 ; eauto ; intros [HC1 | [aux' [HC2 HC3]]]; subst.
       * exists (Callstate (Stackframe res tf sp pc' rs :: ts) tf' rs ## args m); split;
         [   (eapply plus_one ; eauto);
-          (eapply exec_Icall  ; eauto); 
+          (DStep_tac; eapply exec_Icall  ; eauto); 
           (eauto with valagree)
           |
           (constructor ; auto);
@@ -352,7 +388,7 @@ Proof.
             (symmetry ; eauto with valagree)]. 
       * exists (Callstate (Stackframe res tf sp s2 rs :: ts) tf' rs ## args m); split.
         { (eapply plus_one ; eauto);
-          (eapply exec_Icall  ; eauto); 
+          (DStep_tac; eapply exec_Icall  ; eauto); 
           (eauto with valagree). }
         { (constructor ; auto);
           (econstructor ; eauto);
@@ -370,7 +406,7 @@ Proof.
     
     ((exists (Callstate ts tf' rs##args m');  split);
       [  (eapply plus_one ; eauto); 
-        (eapply exec_Itailcall ; eauto with valagree);
+        (DStep_tac; eapply exec_Itailcall ; eauto with valagree);
         (replace (fn_stacksize tf) with (fn_stacksize f); eauto with valagree)
         | ( (constructor; auto);
           (eapply match_stackframes_change_sig ;eauto with valagree))]);
@@ -378,7 +414,10 @@ Proof.
     
   - (* ibuiltin *)
     normalized.
+    ss.
     succ O (RTL.State ts tf sp pc' (regmap_setres res vres rs) m').
+    { unfold is_internal in *. ss. des_ifs. }
+    3:{ unfold is_internal in *. ss. des_ifs. }
     + econstructor; eauto.
       eapply eval_builtin_args_preserved with (ge1:= ge); eauto with valagree.
       eapply external_call_symbols_preserved; eauto with valagree.
@@ -400,16 +439,18 @@ Proof.
     exploit @list_nth_z_nth_error ; eauto; intros.  
     exploit @nth_error_some_same_length; eauto ; intros [e Hnth].
     (specialize (H6 (Z.to_nat (Int.unsigned n))); simpl in *).
-    exploit H6; eauto; intros [HC1 | [nops HC2]]; subst.
+    exploit H6; eauto; intros [HC1 | [nops [HC2 HC3]]]; subst.
     + exists (RTL.State ts tf sp pc' rs m); split ; eauto. 
-      econstructor; eauto. 
+      econstructor; eauto.
+      DStep_tac.
       eapply exec_Ijumptable ; eauto.
       exploit @nth_error_list_nth_z ; eauto.
       eapply @list_nth_z_ge0 ; eauto.
       go. 
       auto. 
     + exists (RTL.State ts tf sp pc' rs m); split ; eauto. 
-      econstructor; eauto. 
+      econstructor; eauto.
+      DStep_tac.
       eapply exec_Ijumptable ; eauto.
       exploit @nth_error_list_nth_z ; eauto.
       eapply @list_nth_z_ge0 ; eauto.
@@ -425,6 +466,7 @@ Proof.
     exploit ch_succ_dec_spec; eauto ; intros ; invh ch_succ.
     exists (Returnstate ts (regmap_optget or Vundef rs) m'); split ; eauto. 
     eapply plus_one ; eauto.
+    DStep_tac.
     eapply exec_Ireturn ; eauto.
     rewrite <- H0 ; eauto with valagree.
     rewrite stacksize_preserved with f tf ; eauto.
@@ -436,9 +478,10 @@ Proof.
                           m').
     split.
     + exploit transl_function_spec_ok; eauto. intros SPEC.
-      inv SPEC.
+      inv SPEC. destruct ENTRY as [ENTRY HLEN].
       eapply plus_left with (s2:=(RTL.State ts x (Vptr stk Ptrofs.zero) (fn_entrypoint x) 
                                             (init_regs args (fn_params x)) m')) ; eauto. 
+      DStep_tac.
       eapply exec_function_internal; eauto.
       rewrite stacksize_preserved with f x in H ; auto.
       eapply reach_nop_star ; eauto.
@@ -453,6 +496,7 @@ Proof.
     inv SPEC.
     exists (Returnstate ts res m'). split. 
     eapply plus_one ; eauto.
+    DStep_tac.
     eapply exec_function_external; eauto.
     eapply external_call_symbols_preserved; eauto with valagree.
     econstructor ; eauto.
@@ -460,29 +504,271 @@ Proof.
   - (* return state *)
     inv STACK. 
     exists (RTL.State ts0 tf sp pc (rs# res <- vres) m).
-    split. eapply plus_one ; eauto. constructor ; eauto.
+    split. eapply plus_one ; eauto. DStep_tac. constructor ; eauto.
     constructor ; auto.
     
     exists (RTL.State ts0 tf sp pc (rs# res <- vres) m).
     split. 
     eapply plus_left with 
     (s2:= (RTL.State ts0 tf sp pc' (rs# res <- vres) m) )  ; eauto. 
+    DStep_tac.
     constructor ; eauto.
     eapply reach_nop_star; eauto. 
     auto. 
     constructor ; auto.
 Qed.
 
+(* Lemma match_states_bsim *)
+(*       s1 *)
+(*       (EXT: is_external ge s1) *)
+(*       s2 t s2' *)
+(*       (STEPTGT: Step tsem s2 t s2') *)
+(*       (MATCH: match_states s1 s2) *)
+(*       (SAFESRC: safe sem s1) *)
+(*   : *)
+(*     (exists s1', Plus sem s1 t s1' /\ match_states s1' s2'). *)
+(* Proof. *)
+(*   assert (SEQUIV: Senv.equiv tge ge) by (symmetry; apply senv_preserved). *)
+(*   unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify. *)
+(*   { inv SAFESRC. inv MATCH. inv STACK. inv STEPTGT. } *)
+(*   inv MATCH; ss; des_ifs; *)
+(*   match goal with  *)
+(*     | [H : transl_fundef (Internal ?f) = _ |- _ ] => idtac *)
+(*     | [H : transl_fundef (External ?f) = _ |- _ ] => idtac *)
+(*     | [  |- context [Returnstate ?ts ?vres ?m]] => idtac *)
+(*     | _ =>  *)
+(*       ( (exploit transl_function_spec_ok ; eauto; intros)) *)
+(*   end ; *)
+(*   match goal with  *)
+(*     | [SPEC: transl_function_spec ?f ?tf |- _ ] => inv SPEC *)
+(*     | _ => idtac *)
+(*   end. *)
+(*   (* builtin *) *)
+(*   - normalized. *)
+(*     inv STEPTGT; ss; clarify. inv SAFESRC; clarify. *)
+(*     assert (vargs0 = vargs). *)
+(*     { eapply eval_builtin_args_preserved in H11; [| symmetry; eapply senv_preserved]. *)
+(*       eapply eval_builtin_args_determ; eauto. } *)
+(*     subst.     *)
+(*     exists (RTL.State s f sp n (regmap_setres b vres rs) m'). *)
+(*     split. *)
+(*     + exploit (H3 O); simpl in *; eauto. i. des. *)
+(*       * subst. eapply plus_one. econs; eauto. *)
+(*         eapply external_call_symbols_preserved; eauto with valagree. *)
+(*       * econs; eauto. *)
+(*         { eapply exec_Ibuiltin; eauto. } *)
+(*         { exploit reach_nop_star_src; eauto. *)
+(*         eapply external_call_symbols_preserved; eauto with valagree. *)
+(*     + econs. *)
+(*     + *)
+
+Lemma match_states_xsim
+    st_src0 st_tgt0 gmtgt n
+    (MATCH: match_states st_src0 st_tgt0) :
+  xsim (semantics prog) (semantics tprog) gmtgt lt n st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold.
+  destruct (classic (RTL.is_external ge st_src0)); cycle 1.
+  (* not external *)
+  - left. econs. econs.
+    + i. exploit transl_step_correct; eauto. i. des. esplits.
+      { eapply tr_rel_refl. eapply ev_rel_refl. }
+      { left. split; eauto. eapply semantics_receptive_at; auto. }
+      right. eapply CIH; eauto.
+    + ii. eapply final_state_determ; eauto.
+      inv FINALSRC. inv MATCH. inv STACK. econs.
+  (* external *)
+  - right. econs. i. econs.
+    + i. assert (SEQUIV: Senv.equiv tge ge) by (symmetry; apply senv_preserved).
+      unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+      { inv SAFESRC. inv MATCH. inv STACK. inv STEPTGT. }
+      inv MATCH; ss; des_ifs;
+        match goal with
+        | [H : transl_fundef (Internal ?f) = _ |- _ ] => idtac
+        | [H : transl_fundef (External ?f) = _ |- _ ] => idtac
+        | [  |- context [Returnstate ?ts ?vres ?m]] => idtac
+        | _ =>
+            ( (exploit transl_function_spec_ok ; eauto; intros))
+        end ;
+        match goal with
+        | [SPEC: transl_function_spec ?f ?tf |- _ ] => inv SPEC
+        | _ => idtac
+        end.
+      (* builtin *)
+      * inv SAFESRC; clarify.
+        normalized. pose proof STEPTGT as STEPTGT'. inv STEPTGT; clarify.
+        specialize (H4 O); simpl in *.
+        exploit H4; eauto; i; des; clarify.
+        { left. esplits; eauto.
+          { eapply tr_rel_refl. eapply ev_rel_refl. }
+          left. eapply plus_one. econs; eauto.
+          eapply external_call_symbols_preserved; eauto with valagree.
+          assert (vargs = vargs0).
+          { exploit eval_builtin_args_determ. eapply H15.
+            eapply eval_builtin_args_preserved. i; eapply symbols_preserved.
+            eapply H9. i; eauto. }
+          clarify. }
+        { eapply (reach_nop_star ts sp rs m) in H0 as REACH. inv REACH.
+          - left. esplits; eauto.
+            { eapply tr_rel_refl. eapply ev_rel_refl. }
+            left. eapply plus_one. econs; eauto.
+            eapply external_call_symbols_preserved; eauto with valagree.
+            assert (vargs = vargs0).
+            { exploit eval_builtin_args_determ. eapply H15.
+              eapply eval_builtin_args_preserved. i; eapply symbols_preserved.
+              eapply H9. i; eauto. }
+            clarify.
+          - destruct aux0 as [ | nop0 [ | nop1 [ | nop2 aux2 ]]]; cycle 3.
+            + ss. lia.
+            + exploit Eapp_E0_inv; eauto; i; des; clarify.
+              inv H0.
+              left.
+              eexists; eexists; exists (S n); esplits.
+              { eapply tr_rel_refl. eapply ev_rel_refl. }
+              left. eapply plus_one. econs; eauto.
+              enough (vargs = vargs0). subst vargs; eauto using external_call_symbols_preserved.
+              exploit eval_builtin_args_determ; cycle 2.
+              eauto. eauto. eapply eval_builtin_args_preserved; eauto using symbols_preserved.
+              left. pfold. econs 2. econs. i. econs 1. i.
+              left. inv STEPTGT; clarify.
+              2:{ i. inv FINALTGT. }
+              2:{ right. esplits; eauto. econs; eauto. }
+              esplits.
+              { econs. }
+              { right. esplits; eauto. eapply star_refl. }
+              right. eapply CIH. econs; eauto.
+            + exploit Eapp_E0_inv; eauto; i; des; clarify.
+              inv H0. inv H17.
+              left. eexists; exists tr'; exists (S (S n)); esplits.
+              eapply tr_rel_refl; eapply ev_rel_refl.
+              left. eapply plus_one. econs; eauto.
+              enough (vargs = vargs0). subst vargs; eauto using external_call_symbols_preserved.
+              exploit eval_builtin_args_determ; cycle 2.
+              eauto. eauto. eapply eval_builtin_args_preserved; eauto using symbols_preserved.
+              left. pfold. econs 2. econs. i. econs.
+              { ii. inv STEPTGT; clarify. left. esplits.
+                eapply tr_rel_refl; eapply ev_rel_refl. right; split.
+                eapply star_refl. auto. left. pfold. econs 2. econs. i. econs.
+                ii. inv STEPTGT; clarify. left. esplits.
+                eapply tr_rel_refl; eapply ev_rel_refl. right; split.
+                eapply star_refl. auto. right. eapply CIH; econs; eauto.
+                ii. inv FINALTGT. right; esplits; eauto. econs; eauto. }
+              { ii. inv FINALTGT. }
+              { right; esplits; eauto. econs; eauto. }
+            + exploit Eapp_E0_inv; eauto; i; des; clarify.
+              inv H0. inv H17. inv H13.
+              left. eexists; exists tr'; exists (S (S (S n))); esplits.
+              eapply tr_rel_refl; eapply ev_rel_refl.
+              left. eapply plus_one. econs; eauto.
+              enough (vargs = vargs0). subst vargs; eauto using external_call_symbols_preserved.
+              exploit eval_builtin_args_determ; cycle 2.
+              eauto. eauto. eapply eval_builtin_args_preserved; eauto using symbols_preserved.
+              left. pfold. econs 2. econs. i. econs.
+              { ii. inv STEPTGT; clarify. left. esplits.
+                eapply tr_rel_refl; eapply ev_rel_refl. right; split.
+                eapply star_refl. auto. left. pfold. econs 2. econs. i. econs.
+                ii. inv STEPTGT; clarify. left. esplits.
+                eapply tr_rel_refl; eapply ev_rel_refl. right; split.
+                eapply star_refl. auto. left. pfold. econs 2. econs. i. econs.
+                ii. inv STEPTGT; clarify. left. esplits.
+                eapply tr_rel_refl; eapply ev_rel_refl. right; split.
+                eapply star_refl. auto.
+                right. eapply CIH; econs; eauto.
+                ii. inv FINALTGT. right; esplits; eauto. econs; eauto.
+                ii. inv FINALTGT. right; esplits; eauto. econs; eauto. }
+              { ii. inv FINALTGT. }
+              { right; esplits; eauto. econs; eauto. } }
+      (* external *)
+      * left.
+        inv STEPTGT; ss; clarify. inv SAFESRC; clarify.
+        exists (Returnstate s res m'). esplits.
+        eapply tr_rel_refl; eapply ev_rel_refl.
+        { left. eapply plus_one. econs.
+          eapply external_call_symbols_preserved; eauto with valagree. }
+        { right. eapply CIH; eauto. }
+    + i. unfold is_external in H; des_ifs; inv MATCH; inv FINALTGT.
+    + assert (SEQUIV: Senv.equiv tge ge) by (symmetry; apply senv_preserved).
+    
+      unfold safe in SAFESRC. exploit SAFESRC; [ eapply star_refl | ]; i.
+
+      des. { unfold is_external in H; des_ifs; inv H0. }
+      inv H0; unfold is_external in H; des_ifs; inv MATCH;
+
+      (* right; esplits; eauto. eapply exec_function_external. *)
+      match goal with
+      | [H : transl_fundef (Internal ?f) = _ |- _ ] => idtac
+      | [H : transl_fundef (External ?f) = _ |- _ ] => idtac
+      | [  |- context [Returnstate ?ts ?vres ?m]] => idtac
+      | _ =>
+          ( (exploit transl_function_spec_ok ; eauto; intros))
+      end ;
+      match goal with
+      | [SPEC: transl_function_spec ?f ?tf |- _ ] => inv SPEC
+      | _ => idtac
+      end. normalized.
+
+      right; esplits; eauto. eapply exec_Ibuiltin; eauto.
+      eapply eval_builtin_args_preserved; cycle 1. eauto. i.
+      eauto using symbols_preserved.
+      eapply external_call_symbols_preserved; eauto. symmetry. eauto.
+
+      inv SPEC. right; esplits; eauto. econs.
+      eapply external_call_symbols_preserved; eauto. symmetry; eauto.
+Qed.
+
+Lemma non_static_equiv l:
+  Genv.non_static_glob (Genv.globalenv prog) l = Genv.non_static_glob (Genv.globalenv tprog) l.
+Proof.
+  induction l; ss.
+  specialize senv_preserved. i. unfold ge, tge in H. r in H. des.
+  specialize (H0 a).
+  unfold Senv.public_symbol in H0. ss. rewrite <- H0.
+  specialize (H a). rewrite <- H. erewrite IHl; eauto.
+Qed.
+
+Lemma transf_initial_capture
+    S1 S2 S2'
+    (INITSRC: initial_state prog S1)
+    (INITTGT: initial_state tprog S2)
+    (MATCH: match_states S1 S2)
+    (CAPTGT: glob_capture tprog S2 S2'):
+  exists S1',
+    glob_capture prog S1 S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (concrete_snapshot ge S1') (concrete_snapshot tge S2').
+Proof.
+  specialize senv_preserved. intros SENVEQ. inv CAPTGT. ss.
+  rewrite Genv.globalenv_public in CAPTURE.
+  rewrite <- same_public in CAPTURE. erewrite <- non_static_equiv in CAPTURE.
+  inv MATCH. inv STACK.
+  esplits.
+  - econs; eauto. rewrite Genv.globalenv_public. eauto.
+  - econs; eauto.
+  - ii. unfold concrete_snapshot in *.
+    inv SENVEQ. des. erewrite H1, H0. des_ifs; ss.
+Qed.
+
 Theorem transf_program_correct:
-  forward_simulation (RTL.semantics prog) (RTL.semantics tprog).
+  mixed_simulation (RTL.semantics prog) (RTL.semantics tprog).
 Proof.
-  eapply forward_simulation_plus.
-  eapply senv_preserved. 
-  eexact transf_initial_states.
-  eexact transf_final_states.
-  exact transl_step_correct. 
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (S a). lia.
+  - econs. i. exploit transf_initial_states; eauto. i. des.
+    exists st2. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. inversion INITSRC; subst. inversion H0; subst.
+      inv STACK.
+      exploit transf_initial_capture; eauto.
+      i. des.
+      exists 0%nat. exists S1'. esplits; eauto.
+      apply match_states_xsim; auto.
+  - i. apply senv_preserved.
 Qed.
 
-     End CORRECTNESS.
+End CORRECTNESS.
      
 End PRESERVATION.
diff --git a/midend/RTLnormspec.v b/midend/RTLnormspec.v
index a04174f6..a9cc2071 100644
--- a/midend/RTLnormspec.v
+++ b/midend/RTLnormspec.v
@@ -36,14 +36,14 @@ Variant norm (code code' : code) (pc: node) : Prop :=
       (forall k succ succ', 
          nth_error (successors_instr ins1) k = Some succ ->
          nth_error (successors_instr ins2) k = Some succ' ->
-         (succ' = succ \/ exists aux, reach_nops code' succ' succ aux)) ->
+         (succ' = succ \/ exists aux, reach_nops code' succ' succ aux /\ length aux <= 2)) ->
       norm code code' pc.
 
 (** ** Specification of the translation *)
 Variant transl_function_spec: RTL.function -> RTL.function -> Prop :=
   | transl_function_spec_intro: forall f tf aux,
     forall (NORM: forall pc ins, (fn_code f) ! pc = Some ins -> norm (fn_code f) (fn_code tf) pc)
-           (ENTRY: reach_nops (fn_code tf) (fn_entrypoint tf) (fn_entrypoint f) aux),
+           (ENTRY: reach_nops (fn_code tf) (fn_entrypoint tf) (fn_entrypoint f) aux /\ length aux <= 3),
     transl_function_spec f tf.
 
 (** * Correctness of the checker *)
@@ -74,7 +74,7 @@ Qed.
 
 Lemma inop_tunel_reach_nops : forall code n s1 s2,
     inop_tunel n code s1 s2 = true ->
-    (s2 = s1) \/ exists aux, reach_nops code s2 s1 aux.
+    (s2 = s1) \/ exists aux, reach_nops code s2 s1 aux /\ length aux <= n - 1.
 Proof.
   unfold inop_tunel.
   induction n; intros.
@@ -88,20 +88,24 @@ Proof.
     + rewrite orb_false_l in H.
       flatten H; try congruence.
       subst.
-      eapply IHn in H; eauto.
+      destruct n.
+      * ss. rewrite orb_false_r in H. destruct peq in H.
+        { subst. right; exists nil; split; eauto. econs; eauto. }
+        { inv H. }
+      * eapply IHn in H; eauto.
       inv H.
-      * right.
+      { right.
         exists nil.
-        econstructor; eauto.
-      * right.
-        destruct H0 as [aux Haux].
+        split. econstructor; eauto. simpl; lia. }
+        { right.
+        destruct H0 as [aux [Haux Hlen]].
         exists (n1::aux).
-        econstructor; eauto.
+        split; eauto. econstructor; eauto. ss. inv Hlen; try lia. }
 Qed.
 
 Lemma check_entry_correct : forall f tf,
     check_entry f tf = true ->
-    exists aux, reach_nops (fn_code tf) (fn_entrypoint tf) (fn_entrypoint f) aux.
+    exists aux, reach_nops (fn_code tf) (fn_entrypoint tf) (fn_entrypoint f) aux /\ length aux <= 3.
 Proof.
   unfold check_entry; intros.
   flatten H. subst.
@@ -109,15 +113,15 @@ Proof.
   - destruct peq.
     + subst.
       exists nil.
-      constructor; auto.
+      split; constructor; auto.
     + inv H0.
   - eapply inop_tunel_reach_nops in H0; eauto.
     inv H0.
     + exists nil.
-      constructor; auto.
-    + destruct H as [aux Haux].
+      split; constructor; auto.
+    + destruct H as [aux [Haux Hlen]].
       exists (n::aux).
-      econstructor; eauto.
+      split; [econstructor; eauto | simpl; lia].
 Qed.
 
 Lemma check_mks_spec_correct: forall code tcode pc i ti,
@@ -155,8 +159,7 @@ Proof.
   unfold transl_function ; intros f tf TRANS. 
   flatten TRANS. boolInv. simpl in *.
   eapply check_entry_correct in Eq3; eauto.
-  destruct Eq3 as [aux Hentry]. 
+  destruct Eq3 as [aux [Hentry Hlen]]. 
   eapply transl_function_spec_intro; eauto.
-  intros.
-  eapply checker_correct; eauto.
+  intros. eapply checker_correct; eauto.
 Qed.
diff --git a/midend/RTLpar.v b/midend/RTLpar.v
index f1d54f92..cca0bb26 100644
--- a/midend/RTLpar.v
+++ b/midend/RTLpar.v
@@ -25,6 +25,7 @@ Require Import CSSA.
 Require Parmov.
 Require Import Dom.
 Require Import Registers.
+Require Import PointerOp.
 Unset Allow StrictProp.
 
 (** * Abstract syntax *)
@@ -168,14 +169,35 @@ Variant state : Type :=
              (m: mem),                (**r memory state *)
       state.
 
+
+Definition ros_to_vos (m: Mem.mem) (ros: reg + ident) (rs: regset) : val + ident :=
+  match ros with
+  | inl r => match rs#r with
+            | Vint n => if negb Archi.ptr64
+                       then (match Mem.to_ptr (Vint n) m with
+                             | Some v' => inl v'
+                             | None => inl rs#r
+                             end)
+                       else inl rs#r
+            | Vlong n => if Archi.ptr64
+                        then (match Mem.to_ptr (Vlong n) m with
+                              | Some v' => inl v'
+                              | None => inl rs#r
+                              end)
+                        else inl rs#r
+            | _ => inl rs#r
+            end
+  | inr symb => inr symb
+  end.
+
 Section RELSEM.
 
 Variable ge: genv.
 
 Definition find_function
-  (ros: reg + ident) (rs: regset) : option fundef :=
+  (ros: val + ident) (rs: regset) : option fundef :=
   match ros with
-  | inl r => Genv.find_funct ge (rs # r)
+  | inl r => Genv.find_funct ge r
   | inr symb =>
       match Genv.find_symbol ge symb with
       | None => None
@@ -211,7 +233,7 @@ Inductive step: state -> trace -> state -> Prop :=
 | exec_Iop:
     forall s f sp pc rs m op args res pc' v,
     (fn_code f)!pc = Some(SSA.Iop op args res pc') ->
-    eval_operation ge sp op rs## args m = Some v ->
+    eval_operation_wrapper ge sp op rs## args m = Some v ->
     step (State s f sp pc rs m)
       E0 (State s f sp pc' (rs# res <- v) m)
 | exec_Iload:
@@ -231,14 +253,14 @@ Inductive step: state -> trace -> state -> Prop :=
 | exec_Icall:
     forall s f sp pc rs m sig ros args res pc' fd,
     (fn_code f)!pc = Some(SSA.Icall sig ros args res pc') ->
-    find_function ros rs = Some fd ->
+    find_function (ros_to_vos m ros rs) rs = Some fd ->
     funsig fd = sig ->
     step (State s f sp pc rs m)
       E0 (Callstate (Stackframe res f sp pc' rs :: s) fd rs## args m)
 | exec_Itailcall:
     forall s f stk pc rs m sig ros args fd m',
     (fn_code f)!pc = Some(SSA.Itailcall sig ros args) ->
-    find_function ros rs = Some fd ->
+    find_function (ros_to_vos m ros rs) rs = Some fd ->
     funsig fd = sig ->
     Mem.free m stk 0 f.(fn_stacksize) = Some m' ->
     step (State s f (Vptr stk Ptrofs.zero) pc rs m)
@@ -253,13 +275,13 @@ Inductive step: state -> trace -> state -> Prop :=
 | exec_Icond_true:
     forall s f sp pc rs m cond args ifso ifnot,
     (fn_code f)!pc = Some(SSA.Icond cond args ifso ifnot) ->
-    eval_condition cond rs## args m = Some true ->
+    eval_condition_wrapper cond rs## args m = Some true ->
     step (State s f sp pc rs m)
       E0 (State s f sp ifso rs m)
 | exec_Icond_false:
     forall s f sp pc rs m cond args ifso ifnot,
     (fn_code f)!pc = Some(SSA.Icond cond args ifso ifnot) ->
-    eval_condition cond rs## args m = Some false ->
+    eval_condition_wrapper cond rs## args m = Some false ->
     step (State s f sp pc rs m)
       E0 (State s f sp ifnot rs m)
 | exec_Ijumptable:
@@ -312,12 +334,53 @@ Variant initial_state (p: program): state -> Prop :=
       funsig f = signature_main ->
       initial_state p (Callstate nil f nil m0).
 
+Inductive glob_capture (p: program) : state -> state -> Prop :=
+  | glob_capture_intro
+      f m pbs m'
+      (* (INIT: initial_state p (Callstate nil f nil m)) *)
+      (NONSTATIC: Genv.non_static_glob (Genv.globalenv p) (Genv.genv_public (Genv.globalenv p)) = pbs)
+      (CAPTURE: Genv.capture_init_mem m pbs m') :
+    glob_capture p (Callstate nil f nil m) (Callstate nil f nil m').
+
 (** A final state is a [Returnstate] with an empty call stack. *)
 
 Variant final_state: state -> int -> Prop :=
   | final_state_intro: forall r m, final_state (Returnstate nil (Vint r) m) r.
 
+(** Non-deterministic external state *)
+
+Definition is_external (ge:genv) (s:state) : Prop :=
+  match s with
+  | Callstate stk fd vargs m =>
+    match fd with
+    | External ef => is_external_ef ef
+    | _ => False
+    end
+  | State cs f sp pc rs m =>
+    match (fn_code f)!pc with
+    | Some (Ibuiltin ef args res pc') => is_external_ef ef
+    | _ => False
+    end
+  | _ => False
+  end.
+
+Definition state_mem (st: state) : mem :=
+  match st with
+  | State _ _ _ _ _ m => m
+  | Callstate _ _ _ m => m
+  | Returnstate _ _ m => m
+  end.
+
+Definition concrete_snapshot (ge: Senv.t) (st: state) (id: ident) : option Z :=
+  if Senv.public_symbol ge id
+  then (match Senv.find_symbol ge id with
+        | Some b => Maps.PTree.get b (state_mem st).(Mem.mem_concrete)
+        | None => None
+        end
+    )
+  else None.
+
 (** The small-step semantics for a program. *)
 
 Definition semantics (p: program) :=
-  Semantics step (initial_state p) final_state (Genv.globalenv p).
+  Semantics step (initial_state p) (glob_capture p) (concrete_snapshot (Genv.globalenv p)) final_state is_external (Genv.globalenv p).
diff --git a/midend/RTLparD.v b/midend/RTLparD.v
new file mode 100644
index 00000000..67d6946d
--- /dev/null
+++ b/midend/RTLparD.v
@@ -0,0 +1,63 @@
+Require Import Coqlib CoqlibC Events.
+Require Import Globalenvs Smallstep Simulation.
+Require Import sflib RTLpar.
+
+(** Determinacy *)
+
+Lemma semantics_single_events p s (INT: ~ is_external (Genv.globalenv p) s): single_events_at (RTLpar.semantics p) s.
+Proof.
+  red. intros. inv H; (try (exploit external_call_trace_length; eauto; intro T)); simpl; try lia; ss; des_ifs.
+Qed.
+
+Lemma semantics_determinate_at:
+  forall (p: program) s (INT: ~ is_external (Genv.globalenv p) s), deterministic_at (semantics p) s.
+Proof.
+  intros. constructor; simpl; intros.
+  - (* determinacy *)
+    inv STEP0; inv STEP1; Eq;
+      try (split; [apply match_traces_E0| intro;auto]);
+      try (elim H; simpl; try rewrite H2; auto);ss.
+    + ss. des_ifs.
+      determ_tac eval_builtin_args_determ.
+      determ_tac external_call_determ.
+    + ss. determ_tac external_call_determ.
+  - inv FINAL; inv STEP.
+  - ii. eapply semantics_single_events; eauto.
+Qed.
+
+Lemma semantics_receptive_at:
+  forall (p: program) s (INT: ~ is_external (Genv.globalenv p) s), receptive_at (semantics p) s.
+Proof.
+  intros. constructor; simpl; intros.
+(* receptiveness *)
+- assert (t1 = E0 -> exists s2, step (Genv.globalenv p) s t2 s2).
+    intros. subst. inv H0. exists s1; auto.
+  inversion H; subst; auto.
++ ss. des_ifs.
+  exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
+  esplits; eauto. eapply exec_Ibuiltin; eauto.
++ exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
+  esplits; eauto. econstructor; eauto.
+(* trace length *)
+- red; intros; inv H; simpl; try lia; ss; des_ifs.
+  eapply external_call_trace_length; eauto.
+  eapply external_call_trace_length; eauto.
+Qed.
+
+Lemma initial_state_determ: forall p st0 st1,
+    Smallstep.initial_state (semantics p) st0 ->
+    Smallstep.initial_state (semantics p) st1 -> st0 = st1.
+Proof.
+  intros. inv H; inv H0. subst ge0 ge. Eq.
+Qed.
+
+Theorem final_state_determ: forall p st0 retv,
+    Smallstep.final_state (semantics p) st0 retv ->
+    Dfinal_state (semantics p) st0 retv.
+Proof.
+  econstructor; eauto.
+  - intros. inv FINAL0; inv FINAL1. auto.
+  - red. unfold not. intros. inv FINAL; inv H0.
+Qed.
+
+Ltac DStep_tac := esplit; [(eapply semantics_determinate_at; simpl in *; eauto; des_ifs)|].
diff --git a/midend/RTLparcleanup.v b/midend/RTLparcleanup.v
index 9a3784d9..7bbf9bc5 100644
--- a/midend/RTLparcleanup.v
+++ b/midend/RTLparcleanup.v
@@ -5,6 +5,7 @@ Require Import AST.
 Require Import Integers.
 Require Import Values.
 Require Import Globalenvs.
+Require Import PointerOp Simulation RTLparD sflib.
 Require Import Smallstep.
 Require Import Dom.
 Require Import Op.
@@ -18,6 +19,9 @@ Require Import KildallComp.
 Require Import DLib.
 Require Import Events.
 Require Import CSSAutils.
+Require Import Classical.
+From Paco Require Import paco.
+
 Unset Allow StrictProp.
 
 (** ** Functions to remove redundants copies in parallel copy blocks *)
@@ -237,6 +241,9 @@ Section PRESERVATION.
     Let ge := Genv.globalenv prog.
     Let tge := Genv.globalenv tprog.
 
+    Let sem := RTLpar.semantics prog.
+    Let tsem := RTLpar.semantics tprog.
+
     Theorem is_mill_program : forall p tp,
         match_prog p tp ->
         mill_program tp.
@@ -331,16 +338,16 @@ Proof.
 Qed.
 
 Lemma spec_ros_r_find_function:
-  forall rs rs' f r,
+  forall rs rs' f r m,
   (forall r, rs !! r = rs' !! r) ->
-  RTLpar.find_function ge (inl _ r) rs = Some f ->
+  RTLpar.find_function ge (ros_to_vos m (inl _ r) rs) rs = Some f ->
   exists tf,
-    RTLpar.find_function tge (inl _ r) rs' = Some tf
+    RTLpar.find_function tge (ros_to_vos m (inl _ r) rs') rs' = Some tf
   /\ transl_fundef f = Errors.OK tf.
 Proof.
-  intros.
-  eapply functions_translated; eauto. inv H0.
-  rewrite <- H; auto.
+  intros. simpl in H0. des_ifs.
+  - erewrite H in Heq. ss. des_ifs. eapply functions_translated; eauto. ss. des_ifs.
+  - erewrite H in Heq. ss. des_ifs. eapply functions_translated; eauto.
 Qed.
 
 Lemma stacksize_preserved:
@@ -354,10 +361,10 @@ Proof.
 Qed.
 
 Lemma spec_ros_id_find_function:
-  forall rs rs' f id,
-  RTLpar.find_function ge (inr _ id) rs = Some f ->
+  forall rs rs' f id m,
+  RTLpar.find_function ge (ros_to_vos m (inr _ id) rs) rs = Some f ->
   exists tf,
-     RTLpar.find_function tge (inr _ id) rs' = Some tf
+     RTLpar.find_function tge (ros_to_vos m (inr _ id) rs') rs' = Some tf
   /\ transl_fundef f = Errors.OK tf.
 Proof.
   intros.
@@ -426,16 +433,18 @@ Qed.
 
 Lemma transl_step_correct:
   forall s1 t s2,
-  step ge s1 t s2 ->
+  IStep sem s1 t s2 ->
   forall s1' (MS: match_states s1 s1'),
   exists s2',
-  RTLpar.step tge s1' t s2' /\ match_states s2 s2'.
+  DStep tsem s1' t s2' /\ match_states s2 s2'.
 Proof.
+  destruct 1. generalize dependent s2. rename H into INT.
   induction 1; intros; inv MS.
   {
     (* inop without block *)
     exists (State ts tf sp pc' rs' m).
     split; auto.
+    DStep_tac. dogo SPEC; do 2 (ss; clarify).
     econstructor 1 ; eauto.
     dogo SPEC; eauto.
     intro Hcont; eelim H0; eapply join_point_preserved; eauto.
@@ -448,6 +457,7 @@ Proof.
       (parcopy_store (remove_redundant_copies SSARegSet.empty parcb)
         rs')) m).
     split; auto.
+    DStep_tac. dogo SPEC; do 2 (ss; clarify).
     eapply RTLpar.exec_Inop_jp; eauto.
     dogo SPEC. 
     { rewrite <- join_point_preserved; eauto. }
@@ -482,10 +492,11 @@ Proof.
   { (* Iop *)
     exists (RTLpar.State ts tf sp pc' (rs' # res <- v) m).
     split; auto.
+    DStep_tac. dogo SPEC; do 2 (ss; clarify).
     eapply RTLpar.exec_Iop; eauto.
     dogo SPEC.
     erewrite <- registers_equal; eauto.
-    erewrite <- eval_operation_preserved; eauto.
+    erewrite <- eval_operation_wrapper_preserved; eauto.
     symmetry.
     eapply symbols_preserved.
     constructor; go.
@@ -498,7 +509,8 @@ Proof.
   { (* Iload *)
     exists (RTLpar.State ts tf sp pc' (rs' # dst <- v) m).
     split; auto.
-    - eapply RTLpar.exec_Iload; eauto.
+    - DStep_tac. dogo SPEC; do 2 (ss; clarify).
+      eapply RTLpar.exec_Iload; eauto.
       dogo SPEC.
       erewrite <- registers_equal; eauto;
       try (erewrite <- eval_addressing_preserved; eauto);
@@ -514,6 +526,7 @@ Proof.
   { (* Istore *)
     exists (RTLpar.State ts tf sp pc' rs' m').
     split; auto.
+    DStep_tac. dogo SPEC; do 2 (ss; clarify).
     eapply RTLpar.exec_Istore; eauto.
     dogo SPEC.
     erewrite <- registers_equal; eauto;
@@ -526,7 +539,7 @@ Proof.
   { (* Icall *)
     destruct ros.
     + assert(Htfd: exists tfd,
-        RTLpar.find_function tge (inl _ r) rs' = Some tfd
+        RTLpar.find_function tge (ros_to_vos m (inl _ r) rs') rs' = Some tfd
         /\ transl_fundef fd = Errors.OK tfd).
       eapply spec_ros_r_find_function; eauto.
       destruct Htfd as [tfd Htfd].
@@ -534,13 +547,14 @@ Proof.
         (RTLpar.Stackframe res tf sp pc' rs' :: ts)
         tfd (rs' ## args) m).
       split; auto.
+      DStep_tac; try by (dogo SPEC; do 2 (ss; clarify)).
       eapply RTLpar.exec_Icall; eauto.
       rewrite sig_fundef_translated with (f := fd); go.
       dogo SPEC. tauto. tauto.
       erewrite registers_equal; eauto.
       econstructor; go. tauto.
     + assert(Htfd: exists tfd,
-        RTLpar.find_function tge (inr i) rs' = Some tfd
+        RTLpar.find_function tge (ros_to_vos m (inr i) rs') rs' = Some tfd
         /\ transl_fundef fd = Errors.OK tfd).
       eapply spec_ros_id_find_function; eauto.
       destruct Htfd as [tfd Htfd].
@@ -548,6 +562,7 @@ Proof.
         (RTLpar.Stackframe res tf sp pc' rs' :: ts)
         tfd (rs' ## args) m).
       split; auto.
+      DStep_tac. dogo SPEC; do 2 (ss; clarify). dogo SPEC; do 2 (ss; clarify).
       eapply RTLpar.exec_Icall; eauto.
       rewrite sig_fundef_translated with (f := fd); go.
       dogo SPEC. tauto. tauto.
@@ -557,12 +572,13 @@ Proof.
   { (* Itailcall *)
     destruct ros.
     + assert(Htfd: exists tfd,
-        RTLpar.find_function tge (inl _ r) rs' = Some tfd
+        RTLpar.find_function tge (ros_to_vos m (inl _ r) rs') rs' = Some tfd
         /\ transl_fundef fd = Errors.OK tfd).
       eapply spec_ros_r_find_function; eauto.
       destruct Htfd as [tfd Htfd].
       exists (RTLpar.Callstate ts tfd (rs' ## args) m').
       split; auto.
+      DStep_tac; try by (dogo SPEC; do 2 (ss; clarify)).
       eapply RTLpar.exec_Itailcall; eauto.
       rewrite sig_fundef_translated with (f := fd); go.
       dogo SPEC. tauto. tauto.
@@ -570,12 +586,13 @@ Proof.
       erewrite registers_equal; eauto.
       econstructor; go. tauto.
     + assert(Htfd: exists tfd,
-        RTLpar.find_function tge (inr i) rs' = Some tfd
+        RTLpar.find_function tge (ros_to_vos m (inr i) rs') rs' = Some tfd
         /\ transl_fundef fd = Errors.OK tfd).
       eapply spec_ros_id_find_function; eauto.
       destruct Htfd as [tfd Htfd].
       exists (RTLpar.Callstate ts tfd (rs' ## args) m').
       split; auto.
+      DStep_tac. dogo SPEC; do 2 (ss; clarify). dogo SPEC; do 2 (ss; clarify).
       eapply RTLpar.exec_Itailcall; eauto.
       rewrite sig_fundef_translated with (f := fd); go.
       dogo SPEC. tauto. tauto.
@@ -586,6 +603,8 @@ Proof.
   { (* Ibuiltin *)
     exists (RTLpar.State ts tf sp pc' (regmap_setres res vres rs') m').
     split; auto.
+    DStep_tac. dogo SPEC; do 2 (ss; clarify).
+    unfold is_internal in INT. ss. des_ifs.
     eapply RTLpar.exec_Ibuiltin with (vargs := vargs); eauto.
     dogo SPEC.
     - eapply eval_builtin_args_preserved with (ge1:= ge); eauto.
@@ -610,6 +629,7 @@ Proof.
   { (* ifso *)
     exists (RTLpar.State ts tf sp ifso rs' m).
     split; auto.
+    DStep_tac. dogo SPEC; do 2 (ss; clarify).
     eapply RTLpar.exec_Icond_true; eauto.
     dogo SPEC.
     erewrite <- registers_equal; eauto.
@@ -618,6 +638,7 @@ Proof.
   { (* ifnot *)
     exists (RTLpar.State ts tf sp ifnot rs' m).
     split; auto.
+    DStep_tac. dogo SPEC; do 2 (ss; clarify).
     eapply RTLpar.exec_Icond_false; eauto.
     dogo SPEC.
     erewrite <- registers_equal; eauto.
@@ -626,6 +647,7 @@ Proof.
   { (* ijumptable *)
     exists (RTLpar.State ts tf sp pc' rs' m).
     split; auto.
+    DStep_tac. dogo SPEC; do 2 (ss; clarify).
     eapply RTLpar.exec_Ijumptable; eauto.
     dogo SPEC. go.
     econstructor; go.
@@ -634,12 +656,14 @@ Proof.
     destruct or.
     + exists (RTLpar.Returnstate ts (regmap_optget (Some r) Vundef rs') m').
       split; auto.
+      DStep_tac. dogo SPEC; do 2 (ss; clarify).
       eapply RTLpar.exec_Ireturn.
       dogo SPEC.
       rewrite <- stacksize_preserved with (f := f); auto.
       simpl. rewrite MREG. go.
     + exists (RTLpar.Returnstate ts (regmap_optget None Vundef rs') m').
       split; auto.
+      DStep_tac. dogo SPEC; do 2 (ss; clarify).
       eapply RTLpar.exec_Ireturn.
       dogo SPEC.
       rewrite <- stacksize_preserved with (f := f); auto.
@@ -651,6 +675,7 @@ Proof.
         tf.(RTLpar.fn_entrypoint)
         (init_regs args (RTLpar.fn_params tf)) m').
       split; auto.
+      DStep_tac.
       eapply RTLpar.exec_function_internal.
       erewrite <- stacksize_preserved; eauto.
       go. go.
@@ -660,7 +685,8 @@ Proof.
     inv SPEC.
     exists (RTLpar.Returnstate ts res m').
     split; auto.
-    + eapply RTLpar.exec_function_external.
+    + DStep_tac.
+      eapply RTLpar.exec_function_external.
       eapply external_call_symbols_preserved; eauto.
       apply senv_preserved.
     + go.
@@ -669,7 +695,7 @@ Proof.
     inv STACK.
     exists (RTLpar.State ts0 tf sp pc (rs' # res <- vres) m).
     split; auto.
-    + eapply RTLpar.exec_return.
+    + DStep_tac. eapply RTLpar.exec_return.
     + econstructor; eauto.
       intros.
       case_eq(peq res r); intros.
@@ -679,17 +705,164 @@ Proof.
   }
 Qed.
 
+Lemma match_states_bsim
+      s1
+      (EXT: is_external ge s1)
+      s2 t s2'
+      (STEPTGT: Step tsem s2 t s2')
+      (MATCH: match_states s1 s2)
+      (SAFESRC: safe sem s1)
+  :
+    (exists s1', Step sem s1 t s1' /\ match_states s1' s2').
+Proof.
+  assert (SEQUIV: Senv.equiv tge ge) by (symmetry; apply senv_preserved).
+  unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+  { inv SAFESRC. inv MATCH. ss. }
+  unfold is_external in *; des_ifs.
+  (* builtin *)
+  - inv STEPTGT; inv MATCH; dogo SPEC. clarify.
+    exists (State stack f sp0 pc' (regmap_setres res vres rs) m').
+    split; auto.
+    + eapply external_call_symbols_preserved in H1; eauto.
+      eapply RTLpar.exec_Ibuiltin with (vargs := vargs); eauto.
+      eapply eval_builtin_args_preserved with (ge1:= tge); eauto.
+      i. symmetry. eapply symbols_preserved.
+      revert H0 MREG. clear.
+      induction 1 ; intros ; go.
+      constructor.
+      * revert H MREG. clear.
+        induction 1 ; intros; go.
+        rewrite <- MREG.
+        constructor.
+      * eapply IHlist_forall2; eauto.
+    + econstructor; go. intros.
+      destruct res; simpl; eauto.
+      case_eq(peq x r); intros.
+      * rewrite e0.
+        repeat rewrite PMap.gss; auto.
+      * repeat rewrite PMap.gso; auto.
+  (* external *)
+  - inv STEPTGT; inv MATCH; dogo SPEC. clarify.
+    inv SPEC.
+    exists (RTLpar.Returnstate stack res m').
+    split; auto.
+    + eapply RTLpar.exec_function_external.
+      eapply external_call_symbols_preserved; eauto.
+    + go.
+      Unshelve. all: eauto.
+Qed.
+
+Lemma match_states_xsim
+    st_src0 st_tgt0 gmtgt
+    (MATCH: match_states st_src0 st_tgt0) :
+  xsim (RTLpar.semantics prog) (RTLpar.semantics tprog) gmtgt lt 0%nat st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold.
+  destruct (classic (is_external ge st_src0)); cycle 1.
+  (* not external *)
+  - left. econs. econs.
+    + i. exploit transl_step_correct; eauto. i. des.
+      * esplits; eauto.
+        { eapply tr_rel_refl. eapply ev_rel_refl. }
+        left. split.
+        { eapply plus_one; eauto. }
+        { eapply RTLparD.semantics_receptive_at; auto. }
+    + ii. eapply final_state_determ; eauto.
+      inv FINALSRC. inv MATCH. ss. inv STACK. econs.
+  (* external *)
+  - right. econs. i. econs.
+    + i. exploit match_states_bsim; eauto. i. des.
+      left. esplits; eauto.
+      { eapply tr_rel_refl. eapply ev_rel_refl. }
+      left. eapply plus_one. eauto.
+    + i. unfold is_external in *.
+      des_ifs; inv FINALTGT; inv MATCH; ss.
+    (* progress *)
+    + i.
+      specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+      { inv SAFESRC; ss. }
+      right. inv MATCH; ss; des_ifs; inv SAFESRC; unfold ge in *; clarify.
+      * dogo SPEC. esplits.
+        eapply exec_Ibuiltin; eauto.
+        { clarify. ss. eauto. }
+        { instantiate (1:=vargs).
+          eapply eval_builtin_args_preserved.
+          { eapply senv_preserved. }
+          revert H9 MREG. clear.
+          induction 1 ; intros ; go.
+          constructor.
+          + revert H MREG. clear.
+            induction 1 ; intros; go.
+            rewrite MREG.
+            constructor.
+          + eapply IHlist_forall2; eauto. }
+        eapply external_call_symbols_preserved; eauto.
+        apply senv_preserved.
+      * inv SPEC.
+        esplits.
+        eapply RTLpar.exec_function_external.
+        eapply external_call_symbols_preserved; eauto.
+        apply senv_preserved.
+Qed.
+
+Lemma non_static_equiv l:
+  Genv.non_static_glob (Genv.globalenv prog) l = Genv.non_static_glob (Genv.globalenv tprog) l.
+Proof.
+  induction l; ss.
+  specialize senv_preserved. i. unfold ge, tge in H. r in H. des.
+  specialize (H0 a).
+  unfold Senv.public_symbol in H0. ss. rewrite <- H0.
+  specialize (H a). rewrite <- H. erewrite IHl; eauto.
+Qed.
+
+Lemma same_public:
+  prog_public prog = prog_public tprog.
+Proof. inv TRANSF_PROG. des; eauto. Qed.
+
+Lemma transf_initial_capture
+    S1 S2 S2'
+    (INITSRC: initial_state prog S1)
+    (INITTGT: initial_state tprog S2)
+    (MATCH: match_states S1 S2)
+    (CAPTGT: glob_capture tprog S2 S2'):
+  exists S1',
+    glob_capture prog S1 S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (concrete_snapshot ge S1') (concrete_snapshot tge S2').
+Proof.
+  specialize senv_preserved. intros SENVEQ. inv CAPTGT. ss.
+  rewrite Genv.globalenv_public in CAPTURE.
+  rewrite <- same_public in CAPTURE. erewrite <- non_static_equiv in CAPTURE.
+  inv MATCH. inv STACK.
+  esplits.
+  - econs; eauto. rewrite Genv.globalenv_public. eauto.
+  - econs; eauto. econs.
+  - ii. unfold concrete_snapshot in *.
+    inv SENVEQ. des. erewrite H1, H0. des_ifs; ss.
+Qed.
+
 Theorem transf_program_correct:
-  forward_simulation (RTLpar.semantics prog) (RTLpar.semantics tprog).
+  mixed_simulation (RTLpar.semantics prog) (RTLpar.semantics tprog).
 Proof.
-  eapply forward_simulation_step with (match_states := match_states).
-  intros. eapply senv_preserved. 
-  eexact transf_initial_states.
-  eexact transf_final_states.
-  exact transl_step_correct. 
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (S a). lia.
+  - econs. i. exploit transf_initial_states; eauto. i. des.
+    exists st2. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. inversion INITSRC; subst. inversion H0; subst.
+      inv STACK.
+      exploit transf_initial_capture; eauto.
+      i. des.
+      exists 0%nat. exists S1'. esplits; eauto.
+      apply match_states_xsim; auto.
+  - i. apply senv_preserved.
 Qed.
 
-  End CORRECTNESS.
+End CORRECTNESS.
   
 End PRESERVATION.
 
diff --git a/midend/RTLparproof.v b/midend/RTLparproof.v
index d9cc646a..97c71324 100644
--- a/midend/RTLparproof.v
+++ b/midend/RTLparproof.v
@@ -5,6 +5,7 @@ Require Import AST.
 Require Import Integers.
 Require Import Values.
 Require Import Globalenvs.
+Require Import PointerOp Simulation CSSAD RTLparD sflib.
 Require Import Smallstep.
 Require Import Dom.
 Require Import Op.
@@ -25,6 +26,8 @@ Require Import CSSAutils.
 Require Import Classical.
 Require Import CSSAdef.
 Require Import Registers.
+Require Import Classical.
+From Paco Require Import paco.
 
 Unset Allow StrictProp.
 
@@ -360,6 +363,9 @@ Section PRESERVATION.
     Let ge := Genv.globalenv prog.
     Let tge := Genv.globalenv tprog.
 
+    Let sem := CSSA.semantics prog.
+    Let tsem := RTLpar.semantics tprog.
+
     Hypothesis TRANSF_PROG: match_prog prog tprog.
     Hypothesis WF_PROG : wf_cssa_program prog.
 
@@ -392,6 +398,16 @@ Section PRESERVATION.
             (RTLpar.Returnstate ts v m).
     Hint Constructors match_states: core.
 
+    Variant match_init: CSSA.state -> RTLpar.state -> Prop :=
+    | match_init_intro:
+        forall s ts f tf args m
+               (SPEC: transl_fundef f = Errors.OK tf)
+               (STACK: match_stackframes s ts)
+               (WFF: wf_cssa_fundef f),
+          match_init
+            (Callstate s f args m)
+            (RTLpar.Callstate ts tf args m).
+
 (* NOTE: important *)
 Lemma parcb_transl_other :
   forall parcb f r rs' regrepr,
@@ -1288,16 +1304,35 @@ Ltac split_but_remember :=
 Ltac do_reachability REACH x :=
     inv REACH;
     match goal with
-    | [ Hreach: exists t : trace, _ |- _ ] =>
-        destruct Hreach as [t Hreach];
+    | [ Hreach: exists t : trace, exists s0: state, _ |- _ ] =>
+        destruct Hreach as [t [s0 Hreach]];
         destruct Hreach as [Hinit Hreachstep];
         constructor 1 with (x := x); go;
-        exists t;
-        split; auto;
+        exists t; exists s0; des_safe;
+        esplits; auto;
         eapply star_right; go;
         rewrite E0_right; auto
     end.
 
+    (* match goal with *)
+    (*   | Hreach:exists (t : trace) (s0 : state), _ *)
+    (*                                        |- _ => *)
+    (*       destruct Hreach as [t [s0 Hreach]]; destruct Hreach as [Hinit Hreachstep]; constructor 1 with (x := x); go; exists t; *)
+    (*       exists s0; des_safe; esplits; auto; eapply star_right; go; rewrite E0_right; auto *)
+    (*   end. *)
+(* Ltac do_reachability REACH x := *)
+(*     inv REACH; *)
+(*     match goal with *)
+(*     | [ Hreach: exists t : trace, _ |- _ ] => *)
+(*         destruct Hreach as [t Hreach]; *)
+(*         destruct Hreach as [Hinit Hreachstep]; *)
+(*         constructor 1 with (x := x); go; *)
+(*         exists t; *)
+(*         split; auto; *)
+(*         eapply star_right; go; *)
+(*         rewrite E0_right; auto *)
+(*     end. *)
+
 Lemma predecessors_preserved :
   forall f tf,
   wf_cssa_function f ->
@@ -1859,23 +1894,24 @@ Proof.
 Qed.
 
 Lemma spec_ros_r_find_function:
-  forall rs rs' f r regrepr,
+  forall rs rs' f r regrepr m,
   rs # r = rs' # (regrepr r) ->
-  CSSA.find_function ge (inl _ r) rs = Some f ->
+  CSSA.find_function ge (CSSA.ros_to_vos m (inl _ r) rs) rs = Some f ->
   exists tf,
-    RTLpar.find_function tge (inl _ (regrepr r)) rs' = Some tf
+    RTLpar.find_function tge (RTLpar.ros_to_vos m (inl _ (regrepr r)) rs') rs' = Some tf
   /\ transl_fundef f = Errors.OK tf.
 Proof.
   intros.
-  eapply functions_translated; eauto. inv H0.
-  rewrite <- H; auto.
+  ss. des_ifs.
+  - exploit (functions_translated (Vptr b (Ptrofs.repr z))); eauto.
+  - exploit (functions_translated (Vptr b i)); eauto.
 Qed.
 
 Lemma spec_ros_id_find_function:
-  forall rs rs' f id,
-  CSSA.find_function ge (inr _ id) rs = Some f ->
+  forall rs rs' f id m,
+  CSSA.find_function ge (CSSA.ros_to_vos m (inr _ id) rs) rs = Some f ->
   exists tf,
-     RTLpar.find_function tge (inr _ id) rs' = Some tf
+     RTLpar.find_function tge (RTLpar.ros_to_vos m (inr _ id) rs') rs' = Some tf
   /\ transl_fundef f = Errors.OK tf.
 Proof.
   intros.
@@ -2101,19 +2137,24 @@ Proof.
   rewrite negb_false_iff in Eq3; eauto.
 Qed.
 
-  Lemma senv_preserved:
-    Senv.equiv (Genv.to_senv ge) (Genv.to_senv tge).
-  Proof.
-    eapply Genv.senv_transf_partial; eauto.
-  Qed.
+Lemma senv_preserved:
+  Senv.equiv (Genv.to_senv ge) (Genv.to_senv tge).
+Proof.
+  eapply Genv.senv_transf_partial; eauto.
+Qed.
+
+Lemma same_public:
+  prog_public prog = prog_public tprog.
+Proof. inv TRANSF_PROG. des; eauto. Qed.
 
 Lemma transl_step_correct:
   forall s1 t s2,
-  step ge s1 t s2 ->
+  IStep sem s1 t s2 ->
   forall s1' (MS: match_states s1 s1'),
   exists s2',
-  RTLpar.step tge s1' t s2' /\ match_states s2 s2'.
+  DStep tsem s1' t s2' /\ match_states s2 s2'.
 Proof.
+  destruct 1. generalize dependent s2. rename H into INT.
   induction 1; intros; inv MS; auto;
   match goal with
     | [H : transl_fundef (Internal ?f) = _ |- _ ] => idtac
@@ -2130,11 +2171,21 @@ Proof.
   end.
   (* inop without block *)
   { exists (RTLpar.State ts tf sp pc' rs' m). split; auto.
+    DStep_tac.
+    { eapply codeSome in H; eauto. ss. clarify. }
     econstructor 1 ; eauto.
     - replace (Inop pc') with
         (transl_instruction regrepr (Inop pc')); auto.
     - intro Hcont. eelim H0; eauto using jp_preserved_2. 
     - econstructor; eauto.
+      (* inv REACH. *)
+  
+      (* ; auto; eapply star_right; go; rewrite E0_right; auto *)
+      (* match goal with *)
+      (* | Hreach:exists t : trace, _ |- _ => *)
+      (*     destruct Hreach as [t [s0 Hreach]]; destruct Hreach as [Hinit Hreachstep]; constructor 1 with (x := x); go; exists t; exist  *)
+      (*     split; auto; eapply star_right; go; rewrite E0_right; auto *)
+      (* end. *)
       do_reachability REACH x.
       econstructor; eauto; intros.
       inv MREG.
@@ -2182,6 +2233,8 @@ Proof.
         (parcopy_store (parcb_cleanup (transl_parcb regrepr parcb)) rs')) m).
     split_but_remember.
     {
+      DStep_tac.
+      { eapply codeSome in H; eauto. ss. clarify. }
       apply RTLpar.exec_Inop_jp ; auto.
       replace (Inop pc') with
         (transl_instruction regrepr (Inop pc')); auto.
@@ -2210,12 +2263,14 @@ Proof.
   { (* Iop *)
     exists (RTLpar.State ts tf sp pc' (rs'# (regrepr res) <- v) m).
     split_but_remember.
-    { 
+    {
+      DStep_tac.
+      { eapply codeSome in H; eauto. ss. clarify. }
       apply RTLpar.exec_Iop with (op := op) (args := map regrepr args).
       exploit codeSome; go.
       inv MREG.
       rewrite <- registers_equal with (rs := rs).
-      erewrite eval_operation_preserved; eauto.
+      erewrite eval_operation_wrapper_preserved; eauto.
       eapply symbols_preserved.
       intros.
       eqregreprs regrepr0 regrepr.
@@ -2301,6 +2356,7 @@ Proof.
       unfold cssaval. flatten.
       exploit compute_regrepr_good_cssaval; eauto.
       intros. congruence.
+      rewrite eval_operation_no_ptr_op in H0; ss.
       go.
     }
     { exfalso. eapply ninterlive_outside_inop; go. go. }
@@ -2314,7 +2370,9 @@ Proof.
   { (* Iload *)
     exists (RTLpar.State ts tf sp pc' (rs' # (regrepr dst) <- v) m).
     split_but_remember.
-    { 
+    {
+      DStep_tac.
+      { eapply codeSome in H; eauto. ss. clarify. }
       apply RTLpar.exec_Iload
         with (chunk := chunk) (addr := addr) (args := map regrepr args)
         (a := a).
@@ -2389,7 +2447,9 @@ Proof.
   { (* Istore *)
     exists (RTLpar.State ts tf sp pc' rs' m').
     split_but_remember.
-    { apply RTLpar.exec_Istore with (chunk := chunk)
+    { DStep_tac.
+      { eapply codeSome in H; eauto. ss. clarify. }
+      apply RTLpar.exec_Istore with (chunk := chunk)
         (addr := addr) (args := map regrepr args) (src := regrepr src)
         (a := a).
       rewrite codeSome with
@@ -2470,7 +2530,7 @@ Proof.
     }
     destruct ros.
     + assert(Htfd: exists tfd,
-        RTLpar.find_function tge (inl _ (regrepr r)) rs' = Some tfd
+        RTLpar.find_function tge (RTLpar.ros_to_vos m (inl _ (regrepr r)) rs') rs' = Some tfd
         /\ transl_fundef fd = Errors.OK tfd).
       {
         apply spec_ros_r_find_function
@@ -2488,7 +2548,9 @@ Proof.
         (RTLpar.Stackframe (regrepr res) tf sp pc' rs' :: ts)
         tfd (rs' ## (map regrepr args)) m).
       split_but_remember.
-      - apply RTLpar.exec_Icall with (sig := RTLpar.funsig tfd)
+      - DStep_tac; try by
+        (eapply codeSome in H; eauto; ss; clarify).
+        apply RTLpar.exec_Icall with (sig := RTLpar.funsig tfd)
           (ros := inl (regrepr r)).
         rewrite codeSome with
           (ins := (Icall (funsig fd) (inl r) args res pc'));
@@ -2570,7 +2632,7 @@ Proof.
         apply not_lazydef_after_noinop with (pc := pc); go.
         go. 
     + assert(Htfd: exists tfd,
-        RTLpar.find_function tge (inr i) rs' = Some tfd
+        RTLpar.find_function tge (RTLpar.ros_to_vos m (inr i) rs') rs' = Some tfd
         /\ transl_fundef fd = Errors.OK tfd).
       apply spec_ros_id_find_function
         with (rs := rs); auto.
@@ -2579,7 +2641,10 @@ Proof.
         (RTLpar.Stackframe (regrepr res) tf sp pc' rs' :: ts)
         tfd (rs' ## (map regrepr args)) m).
       split_but_remember.
-      - apply RTLpar.exec_Icall
+      - DStep_tac.
+        { eapply codeSome in H; eauto. ss. clarify. }
+        { eapply codeSome in H; eauto. ss. clarify. }
+        apply RTLpar.exec_Icall
           with (sig := RTLpar.funsig tfd) (ros := inr i).
         rewrite codeSome with
           (ins := (Icall (funsig fd) (inr i) args res pc'));
@@ -2694,7 +2759,7 @@ Proof.
      }
      destruct ros.
      + assert(Htfd: exists tfd,
-         RTLpar.find_function tge (inl _ (regrepr r)) rs' = Some tfd
+         RTLpar.find_function tge (RTLpar.ros_to_vos m (inl _ (regrepr r)) rs') rs' = Some tfd
          /\ transl_fundef fd = Errors.OK tfd).
        {
          apply spec_ros_r_find_function
@@ -2711,7 +2776,9 @@ Proof.
        exists (RTLpar.Callstate
          ts tfd (rs' ## (map regrepr args)) m').
        split_but_remember.
-       - apply RTLpar.exec_Itailcall with (sig := RTLpar.funsig tfd)
+       - DStep_tac; try by
+         (eapply codeSome in H; eauto; ss; clarify).
+         apply RTLpar.exec_Itailcall with (sig := RTLpar.funsig tfd)
            (ros := inl (regrepr r)).
          rewrite codeSome with
            (ins := (Itailcall (funsig fd) (inl r) args));
@@ -2727,7 +2794,7 @@ Proof.
          destruct Hfind. auto.
          go. go.
      + assert(Htfd: exists tfd,
-         RTLpar.find_function tge (inr i) rs' = Some tfd
+         RTLpar.find_function tge (RTLpar.ros_to_vos m (inr i) rs') rs' = Some tfd
          /\ transl_fundef fd = Errors.OK tfd).
        apply spec_ros_id_find_function
          with (rs := rs); auto.
@@ -2735,7 +2802,10 @@ Proof.
        exists(RTLpar.Callstate
          ts tfd (rs' ## (map regrepr args)) m').
        split_but_remember.
-       - apply RTLpar.exec_Itailcall
+       - DStep_tac.
+         { eapply codeSome in H; eauto. ss. clarify. }
+         { eapply codeSome in H; eauto. ss. clarify. }
+         apply RTLpar.exec_Itailcall
            with (sig := RTLpar.funsig tfd) (ros := inr i).
          rewrite codeSome with
            (ins := (Itailcall (funsig fd) (inr i) args));
@@ -2755,7 +2825,10 @@ Proof.
     exists (RTLpar.State ts tf sp pc' (regmap_setres  (map_builtin_res regrepr res)
                                                       vres rs') m'). 
     split_but_remember.
-    { eapply RTLpar.exec_Ibuiltin with(args := map (map_builtin_arg regrepr) args)
+    { DStep_tac.
+      { unfold is_internal in INT. ss. des_ifs.
+        eapply codeSome in Heq0; eauto. ss. clarify. }
+      eapply RTLpar.exec_Ibuiltin with(args := map (map_builtin_arg regrepr) args)
                                       (vargs := vargs)
                                       (res:= map_builtin_res regrepr res).
       rewrite codeSome with (ins := (Ibuiltin ef args res pc')); go.
@@ -2808,10 +2881,12 @@ Proof.
     {
       inv REACH.
       destruct H3 as [tt Hreach].
-      destruct Hreach as [Hinit Hreachstep].
+      destruct Hreach as [s0 [Hinit [Hcap Hreachstep]]].
       constructor 1 with (x := x); go.
+      des_safe.
       exists (Eapp tt t).
-      split; auto.
+      exists s0.
+      esplits; eauto.
       eapply star_right; go.
     }
     {
@@ -2872,7 +2947,9 @@ Proof.
     { (* ifso *)
       exists (RTLpar.State ts tf sp ifso rs' m).
       split_but_remember.
-      { apply RTLpar.exec_Icond_true
+      { DStep_tac.
+        { eapply codeSome in H; eauto. ss. clarify. }
+        apply RTLpar.exec_Icond_true
           with (cond := cond) (args := map regrepr args)
                (ifnot := ifnot).
         rewrite codeSome with
@@ -2906,7 +2983,9 @@ Proof.
     { (* ifnot *)
       exists (RTLpar.State ts tf sp ifnot rs' m).
       split_but_remember.
-      { apply RTLpar.exec_Icond_false
+      { DStep_tac.
+        { eapply codeSome in H; eauto. ss. clarify. }
+        apply RTLpar.exec_Icond_false
           with (cond := cond) (args := map regrepr args)
                (ifso := ifso).
         rewrite codeSome with
@@ -2940,7 +3019,9 @@ Proof.
     { (* ijumptable *)
       exists (RTLpar.State ts tf sp pc' rs' m).
       split_but_remember.
-      { apply RTLpar.exec_Ijumptable with (arg := regrepr arg)
+      { DStep_tac.
+        { eapply codeSome in H; eauto. ss. clarify. }
+        apply RTLpar.exec_Ijumptable with (arg := regrepr arg)
                                           (tbl := tbl) (n := n).
         rewrite codeSome with
             (ins := Ijumptable arg tbl);
@@ -2976,7 +3057,9 @@ Proof.
       {
         exists (RTLpar.Returnstate ts (regmap_optget (Some (regrepr r)) Vundef rs') m').
         split_but_remember.
-        { apply RTLpar.exec_Ireturn.
+        { DStep_tac.
+          { eapply codeSome in H; eauto. ss. clarify. }
+          apply RTLpar.exec_Ireturn.
           rewrite codeSome with
               (ins := Ireturn (Some r));
             go.
@@ -2990,10 +3073,11 @@ Proof.
         {
           inv REACH.
           destruct H3 as [t Hreach].
-          destruct Hreach as [Hinit Hreachstep].
+          destruct Hreach as [s0 [Hinit [Hcap Hreachstep]]].
           econstructor; eauto.
           exists t.
-          split; eauto.
+          exists s0.
+          splits; eauto.
           replace (Returnstate s rs !! r m')
             with (Returnstate s (regmap_optget (Some r) Vundef rs)
                               m').
@@ -3012,6 +3096,8 @@ Proof.
       }
       exists (RTLpar.Returnstate ts (regmap_optget None Vundef rs') m').
       split; eauto.
+      DStep_tac.
+      { eapply codeSome in H; eauto. ss. clarify. }
       apply RTLpar.exec_Ireturn.
       rewrite codeSome with
           (ins := Ireturn None);
@@ -3021,10 +3107,11 @@ Proof.
       {
         inv REACH.
         destruct H2 as [t Hreach].
-        destruct Hreach as [Hinit Hreachstep].
+        destruct Hreach as [s0 [Hinit [Hcap Hreachstep]]].
         econstructor; eauto.
         exists t.
-        split; eauto.
+        exists s0.
+        splits; eauto.
         apply star_right
           with (t1 := t) (t2 := E0) (s2 :=
                                        (State s f (Vptr stk Ptrofs.zero) pc rs m)); go.
@@ -3042,7 +3129,8 @@ Proof.
                            tf.(RTLpar.fn_entrypoint)
                                 (init_regs args (RTLpar.fn_params tf)) m').
       split_but_remember.
-      { eapply RTLpar.exec_function_internal.
+      { DStep_tac.
+        eapply RTLpar.exec_function_internal.
         erewrite <- stacksize_preserved; eauto.
         simpl in SPEC.
         unfold Errors.bind in SPEC.
@@ -3088,17 +3176,19 @@ Proof.
       inv SPEC.
       exists (RTLpar.Returnstate ts res m').
       split.
-      + eapply RTLpar.exec_function_external.
+      + DStep_tac.
+        eapply RTLpar.exec_function_external.
         eapply external_call_symbols_preserved; eauto.
         eapply senv_preserved. 
       + econstructor; eauto.
         {
           inv REACH.
           destruct H0 as [tt Hreach].
-          destruct Hreach as [Hinit Hreachstep].
+          destruct Hreach as [s0 [Hinit [Hcap Hreachstep]]].
           econstructor; eauto.
           exists (Eapp tt t).
-          split; eauto.
+          exists s0.
+          splits; eauto.
           eapply star_right; go.
         }
     }
@@ -3106,7 +3196,7 @@ Proof.
       inv STACK.  
       exists (RTLpar.State ts0 tf sp pc (rs' # (regrepr res) <- vres) m).
       split.
-      + eapply RTLpar.exec_return.
+      + DStep_tac. eapply RTLpar.exec_return.
       + econstructor; eauto.
         do_reachability REACH x.
         econstructor; eauto; intros.
@@ -3122,7 +3212,7 @@ Qed.
 Lemma transf_initial_states:
   forall st1, initial_state prog st1 ->
               exists st2, RTLpar.initial_state tprog st2
-                          /\ match_states st1 st2.
+                          /\ match_init st1 st2.
 Proof.
   intros. inversion H.
   exploit function_ptr_translated ; eauto. intros [tf [Hfind Htrans]].
@@ -3135,9 +3225,7 @@ Proof.
     + eauto.
     + rewrite <- H3. apply sig_fundef_translated; auto.
       eapply Genv.find_funct_ptr_prop; eauto.
-  - eapply match_states_call ; eauto.
-    + econstructor; eauto.
-      exists E0; go.
+  - eapply match_init_intro; eauto.
     + eapply Genv.find_funct_ptr_prop ; eauto.  
 Qed.
 
@@ -3152,14 +3240,318 @@ Proof.
   constructor.
 Qed.
 
+Lemma match_states_bsim
+      s1
+      (EXT: is_external ge s1)
+      s2 t s2'
+      (STEPTGT: Step tsem s2 t s2')
+      (MATCH: match_states s1 s2)
+      (SAFESRC: safe sem s1)
+  :
+    (exists s1', Step sem s1 t s1' /\ match_states s1' s2').
+Proof.
+  assert (SEQUIV: Senv.equiv tge ge) by (symmetry; apply senv_preserved).
+  unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+  { inv SAFESRC. inv MATCH. inv STACK. inv STEPTGT. }
+  inv MATCH; ss; des_ifs;
+  match goal with
+  | [H : transl_fundef (Internal ?f) = _ |- _ ] => idtac
+  | [H : transl_fundef (External ?f) = _ |- _ ] => idtac
+  | [  |- context [RTLpar.Returnstate ?ts ?vres ?m]] => idtac
+  | _ =>
+      (exploit transl_function_charact; eauto; intros;
+       exploit transl_function_correct; eauto; intros)
+  end;
+  match goal with
+  | [SPEC: transl_function_spec ?f ?tf |- _ ] =>
+      inv SPEC
+  | _ => try (generalize (wf_cssa f) ; intros HWF)
+  end.
+  (* builtin *)
+  - exploit codeSome; eauto. i.
+    inv STEPTGT; ss; clarify. inv SAFESRC; clarify.
+    exists (State s f sp n (regmap_setres b vres rs) m').
+    split_but_remember.
+    { eapply CSSA.exec_Ibuiltin with (vargs:=vargs).
+      - eauto.
+      - assert (eval_builtin_args (Genv.globalenv tprog) (fun r : positive => rs' # r)
+                  sp m (map (map_builtin_arg regrepr) l) vargs0).
+        { inv MREG.
+          eqregreprs regrepr0 regrepr.
+          assert (forall r, In r (params_of_builtin_args l) -> rs !! r = rs' !! (regrepr r)).
+          { intros. apply H0.
+            left. split; auto.
+            (* properties of [r] *)
+            eapply live_at_notinop_if_used; eauto.
+            go. go.
+            apply not_lazydef_outside_inop; go.          
+          }
+          eapply eval_builtin_args_preserved with (ge1:= ge).
+          apply senv_preserved.
+          revert H12 H1. clear.
+          induction 1 ; intros; go.
+          simpl. constructor.
+          + clear H12 IHlist_forall2.
+            revert H H1.
+            induction 1 ; intros ; simpl ; go.
+            * rewrite H1; go.
+            * { constructor.
+                - eapply IHeval_builtin_arg1; eauto.
+                  intros. eapply H1; eauto. simpl in *.
+                  eapply in_app_or in H2.
+                  eapply in_or_app. intuition.
+                - eapply IHeval_builtin_arg2; eauto.
+                  intros. eapply H1; eauto. simpl in *.
+                  eapply in_app_or in H2.
+                  eapply in_or_app. intuition.
+              }
+            * { constructor.
+                - eapply IHeval_builtin_arg1; eauto.
+                  intros. eapply H1; eauto. simpl in *.
+                  eapply in_app_or in H2.
+                  eapply in_or_app. intuition.
+                - eapply IHeval_builtin_arg2; eauto.
+                  intros. eapply H1; eauto. simpl in *.
+                  eapply in_app_or in H2.
+                  eapply in_or_app. intuition.
+              }
+          + eapply IHlist_forall2; eauto.
+            intros. eapply H1. go. }
+        exploit eval_builtin_args_determ. eapply H10. eapply H0. i. subst. eauto.
+      - eapply external_call_symbols_preserved; eauto. }
+    constructor; eauto.
+    constructor; eauto.
+    {
+      inv REACH.
+      destruct H0 as [tt Hreach].
+      destruct Hreach as [s0 [Hinit [Hcap Hreachstep]]].
+      constructor 1 with (x := x); go.
+      exists (Eapp tt t).
+      exists s0.
+      splits; auto.
+      eapply star_right; go.
+    }
+    {
+      econstructor; eauto; intros.
+      inv MREG. rewrite RegRepr0 in RegRepr. inv RegRepr.
+      destruct b ; simpl; go.
+      - rewrite PMap.gsspec.
+        rewrite PMap.gsspec.
+        flatten.
+        exploit liveorlazydef_exists_def; eauto; intros DEF.
+        exploit compute_regrepr_correct; eauto; intros Hninterf.
+        inv Hninterf.
+        assert(Hcssavalspec: cssaval_spec f (compute_cssaval_function f))
+        by auto. (* copy of hypothesis *)
+        inv Hcssavalspec.
+        exploit H6; eauto; intros Hcssavalins.
+        simpl in Hcssavalins.
+        {
+        assert(cssalive_spec f r pc).
+        apply live_in_pred_if_notdefined with (pc' := n); go.
+        {
+          destruct H0 as [Hlive | Hlazy].
+          + unfold not; intros Hdef.
+            inv Hdef; go.
+            apply absurd_notinop_at_entry with (f := f); go.
+            induction WFF.
+            inv H0; go.
+            contradict H0.
+            apply not_phi_def_outside_inop; go.
+            contradict H0.
+            apply not_parcb_def_outside_inop; go.
+          + contradict Hlazy.
+            apply not_lazydef_after_noinop with (pc := pc); go.
+        }
+        assert(False) by
+            (eapply cssaval_contradiction_in_Ibuiltin; eauto);
+          contradiction.
+      }
+      exfalso. eapply ninterlive_outside_inop; go. go.
+      apply H1. left.
+      split.
+      + eapply live_props_outside_inop; go.
+        unfold not; intros Hassign; inv Hassign; go.
+      + apply not_lazydef_outside_inop; go.
+      - eapply H1; eauto.
+        left. split.
+        + eapply live_props_outside_inop; go.
+          unfold not; intros Hassign; inv Hassign; go.
+        + apply not_lazydef_outside_inop; go.
+      - eapply H1; eauto.
+        left. split.
+        + eapply live_props_outside_inop; go.
+          unfold not; intros Hassign; inv Hassign; go.
+        + apply not_lazydef_outside_inop; go.
+    }
+  (* external *)
+  - inv SPEC.
+    inv STEPTGT; ss; clarify. inv SAFESRC; clarify.
+    exists (CSSA.Returnstate s res m').
+    split.
+    + eapply CSSA.exec_function_external.
+      eapply external_call_symbols_preserved; eauto.
+    + econstructor; eauto.
+      {
+        inv REACH.
+        destruct H as [tt Hreach].
+        destruct Hreach as [s0 [Hinit [Hcap Hreachstep]]].
+        econstructor; eauto.
+        exists (Eapp tt t).
+        exists s0.
+        splits; eauto.
+        eapply star_right; go.
+        econs; eauto. eapply external_call_symbols_preserved; eauto.
+      }
+Qed.
+
+Lemma match_states_xsim
+    st_src0 st_tgt0 gmtgt
+    (MATCH: match_states st_src0 st_tgt0) :
+  xsim (CSSA.semantics prog) (RTLpar.semantics tprog) gmtgt lt 0%nat st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold.
+  destruct (classic (CSSA.is_external ge st_src0)); cycle 1.
+  (* not external *)
+  - left. econs. econs.
+    + i. exploit transl_step_correct; eauto. i. des; esplits; eauto.
+      { eapply tr_rel_refl. eapply ev_rel_refl. }
+      left. split; eauto.
+      { eapply plus_one; eauto. }
+      { eapply CSSAD.semantics_receptive_at; auto. }
+    + ii. eapply final_state_determ; eauto.
+      inv FINALSRC. inv MATCH. inv STACK. econs.
+  (* external *)
+  - right. econs. i. econs.
+    + i. exploit match_states_bsim; eauto. i. des.
+      left. esplits; eauto.
+      { eapply tr_rel_refl. eapply ev_rel_refl. }
+      left. eapply plus_one. eauto.
+    + ii. inv FINALTGT. inv MATCH. ss.
+    + i.
+      specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+      { inv SAFESRC; ss. }
+      inv MATCH; ss; des_ifs;
+      match goal with
+      | [H : transl_fundef (Internal ?f) = _ |- _ ] => idtac
+      | [H : transl_fundef (External ?f) = _ |- _ ] => idtac
+      | [  |- context [RTLpar.Returnstate ?ts ?vres ?m]] => idtac
+      | _ =>
+          (exploit transl_function_charact; eauto; intros;
+           exploit transl_function_correct; eauto; intros)
+      end;
+      match goal with
+      | [SPEC: transl_function_spec ?f ?tf |- _ ] =>
+          inv SPEC
+      | _ => try (generalize (wf_cssa f) ; intros HWF)
+      end.
+      * exploit codeSome; eauto. i. inv SAFESRC; clarify.
+        right. esplits.
+        (* right. *) (* esplits.  *) eapply RTLpar.exec_Ibuiltin.
+        { eauto. }
+        { inv MREG.
+          eqregreprs regrepr0 regrepr.
+          assert (forall r, In r (params_of_builtin_args l) -> rs !! r = rs' !! (regrepr r)).
+          { intros. apply H2.
+            left. split; auto.
+            (* properties of [r] *)
+            eapply live_at_notinop_if_used; eauto.
+            go. go.
+            apply not_lazydef_outside_inop; go.          
+          }
+          eapply eval_builtin_args_preserved with (ge1:= ge).
+          apply senv_preserved.
+          instantiate (1:=vargs).
+          revert H11 H3. clear.
+          induction 1 ; intros; go.
+          simpl. constructor.
+          + clear H11 IHlist_forall2.
+            revert H H3.
+            induction 1 ; intros ; simpl ; go.
+            * rewrite H3; go.
+            * { constructor.
+                - eapply IHeval_builtin_arg1; eauto.
+                  intros. eapply H3; eauto. simpl in *.
+                  eapply in_app_or in H1.
+                  eapply in_or_app. intuition.
+                - eapply IHeval_builtin_arg2; eauto.
+                  intros. eapply H3; eauto. simpl in *.
+                  eapply in_app_or in H1.
+                  eapply in_or_app. intuition.
+              }
+            * { constructor.
+                - eapply IHeval_builtin_arg1; eauto.
+                  intros. eapply H3; eauto. simpl in *.
+                  eapply in_app_or in H1.
+                  eapply in_or_app. intuition.
+                - eapply IHeval_builtin_arg2; eauto.
+                  intros. eapply H3; eauto. simpl in *.
+                  eapply in_app_or in H1.
+                  eapply in_or_app. intuition.
+              }
+          + eapply IHlist_forall2; eauto.
+            intros. eapply H3. go. }
+        eapply  external_call_symbols_preserved; eauto. apply senv_preserved.
+      * inv SPEC. inv SAFESRC; clarify.
+        right. esplits.
+        eapply RTLpar.exec_function_external.
+        eapply external_call_symbols_preserved; eauto.
+        eapply senv_preserved.
+Qed.
+
+Lemma non_static_equiv l:
+  Genv.non_static_glob (Genv.globalenv prog) l = Genv.non_static_glob (Genv.globalenv tprog) l.
+Proof.
+  induction l; ss.
+  specialize senv_preserved. i. unfold ge, tge in H. r in H. des.
+  specialize (H0 a).
+  unfold Senv.public_symbol in H0. ss. rewrite <- H0.
+  specialize (H a). rewrite <- H. erewrite IHl; eauto.
+Qed.
+
+Lemma transf_initial_capture
+    S1 S2 S2'
+    (INITSRC: CSSA.initial_state prog S1)
+    (INITTGT: RTLpar.initial_state tprog S2)
+    (MATCH: match_init S1 S2)
+    (CAPTGT: RTLpar.glob_capture tprog S2 S2'):
+  exists S1',
+    CSSA.glob_capture prog S1 S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (CSSA.concrete_snapshot ge S1') (RTLpar.concrete_snapshot tge S2').
+Proof.
+  specialize senv_preserved. intros SENVEQ. inv CAPTGT. ss.
+  rewrite Genv.globalenv_public in CAPTURE.
+  rewrite <- same_public in CAPTURE. erewrite <- non_static_equiv in CAPTURE.
+  inv MATCH. inv STACK.
+  esplits.
+  - econs; eauto. rewrite Genv.globalenv_public. eauto.
+  - econs; eauto. r. esplits; eauto.
+    { econs; eauto. rewrite Genv.globalenv_public. eauto. }
+    eapply star_refl.
+  - ii. unfold RTLpar.concrete_snapshot, CSSA.concrete_snapshot in *.
+    inv SENVEQ. des. erewrite H1, H0. des_ifs; ss.
+Qed.
+
 Theorem transf_program_correct:
-  forward_simulation (CSSA.semantics prog) (RTLpar.semantics tprog).
-Proof.
-  eapply forward_simulation_step with (match_states := match_states).
-  eapply senv_preserved.
-  eexact transf_initial_states.
-  eexact transf_final_states.
-  exact transl_step_correct. 
+  mixed_simulation (CSSA.semantics prog) (RTLpar.semantics tprog).
+Proof.
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (S a). lia.
+  - econs. i. exploit transf_initial_states; eauto. i. des.
+    exists st2. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. inversion INITSRC; subst. inversion H0; subst.
+      inv STACK.
+      exploit transf_initial_capture; eauto.
+      i. des.
+      exists 0%nat. exists S1'. esplits; eauto.
+      apply match_states_xsim; auto.
+  - i. apply senv_preserved.
 Qed.
 
   End CORRECTNESS.
diff --git a/midend/SCCPopt.v b/midend/SCCPopt.v
deleted file mode 100644
index f78b69b0..00000000
--- a/midend/SCCPopt.v
+++ /dev/null
@@ -1,1047 +0,0 @@
-Require Import Coqlib.
-Require Import Maps.
-Require Import AST.
-Require Import Op.
-Require Import Registers.
-Require Import Utils.
-Require Import Integers.
-Require Import Floats.
-Require Import Classical.
-Require Import Lattice.
-Require Import Iteration.
-Require Import DLib.
-Require Import Kildall.
-Require Import KildallComp.
-Require Import SSA.
-Require Import SSAutils.
-Require Import Utilsvalidproof.
-Require Opt.
-Require Import Dsd.
-Require Import ValueDomainSSA ValueAOpSSA.
-
-(** Sparse Conditional Constant Propagation *)
-
-(** * Dataflow solver over DU chains *)
-Module Type DATAFLOW_SOLVER.
-
-  Module L := AVal. 
-                
-  Definition lattice_values := PMap.t L.t.
-  Definition exec_state := P2Map.t bool.
-  
-  Definition not_defined (f: function)
-             (absint: instruction -> lattice_values -> option (reg * L.t)) (r: reg) :=
-    (forall lv r' nv i pc, (fn_code f) ! pc = Some i ->  absint i lv = Some (r',nv) -> r <> r')
-    /\ (forall pc pb l r', (fn_phicode f) ! pc = Some pb -> In (Iphi l r') pb -> r <> r').
-  
-  Definition executable_node (f : function) (pc' : node) (es : exec_state) :=
-    pc' = fn_entrypoint f
-    \/ (exists pc, es !!2 (pc, pc') = true /\ cfg f pc pc').
-
-  Parameter fixpoint : forall
-      (f: function)
-      (absint: instruction -> lattice_values -> option (reg * L.t))
-      (init: lattice_values),
-      PMap.t L.t * exec_state.
-
-  Axiom defined_nowhere_stays_top: forall f absint init r lv,
-      not_defined f absint r ->
-      init # r = L.top ->
-      lv = fst (fixpoint f absint init) ->
-      lv # r = L.top.
-
-  Axiom defined_nowhere_becomes_top: forall f absint init r,
-      not_defined f absint r ->
-      init # r = L.bot ->
-      (fst (fixpoint f absint init)) # r = L.top.
-
-  Definition exec_flags_sound (f : function) (lv : Regmap.t L.t) (es : exec_state) := 
-    forall pc pc' i, 
-      cfg f pc pc' ->
-      es !!2 (pc, pc') = false ->
-      (fn_code f) ! pc' = Some i ->
-      ~ executable_node f pc es \/
-      match (fn_code f) ! pc with
-      | Some (Icond cond args ifso ifnot) =>
-        (ifso = pc' -> eval_static_condition cond lv ## args = Just false) /\
-        (ifnot = pc' -> eval_static_condition cond lv ## args = Just true)
-      | Some (Ijumptable arg tbl) =>
-        exists n : int, lv # arg = I n /\ list_nth_z tbl (Int.unsigned n) <> Some pc'
-      | _ => False
-      end.
-
-  Definition code_post_fixpoint (f : function)
-                   (absint: instruction -> lattice_values -> option (reg * L.t))
-                   (lv : lattice_values) (es : exec_state) :=
-    forall pc i r v, 
-      (fn_code f) ! pc = Some i ->
-      executable_node f pc es ->
-      absint i lv = Some (r, v) ->
-      L.ge lv # r v.
-  
-  Definition phicode_post_fixpoint (f : function)
-             (lv : Regmap.t L.t) (es : exec_state) :=
-    forall pc pb r l xi pc' k,
-      (fn_phicode f) ! pc' = Some pb ->
-      In (Iphi l r) pb ->
-      index_pred (make_predecessors (fn_code f) successors_instr) pc pc' = Some k ->
-      es !!2 (pc, pc') = true ->
-      nth_error l k = Some xi ->
-      L.ge (lv # r) (lv # xi).
-  
-  Axiom post_fixpoint : forall f absint init lv es,
-      fixpoint f absint init = (lv, es) ->
-      code_post_fixpoint f absint lv es
-      /\ phicode_post_fixpoint f lv es
-      /\ exec_flags_sound f lv es.
-
-End DATAFLOW_SOLVER.
-
-
-Module DataflowSolver: DATAFLOW_SOLVER.
-
-  Module L := AVal.
-
-  Section CDS.
-
-  Definition lattice_values := PMap.t L.t.
-  Definition exec_state := P2Map.t bool.
-
-  Definition instr_workset := (list reg * list reg)%type.
-  Definition edge := (node * node)%type.
-
-  Definition state := (list edge * instr_workset * lattice_values * exec_state)%type.
-
-  (** * Def-Use Chains *)
-  Definition ssainstruction := (node * (instruction + phiinstruction))%type.
-  Definition du_chain := PMap.t (list ssainstruction).
-
-  Record const_state := mkConstantState {
-     cs_duc: du_chain;
-     cs_preds: PTree.t (list node)
-  }.
-
-  Variable f: function.
-  Variable absint : instruction -> lattice_values -> option (reg * L.t).
-  Variable initial_values : lattice_values.
-
-  Definition bge (x y : L.t) : bool := L.beq (L.lub x y) x.
-
-  Remark bge_correct: forall x y, bge x y = true -> L.ge x y.
-  Proof.
-    intros. unfold bge in H. apply L.beq_correct in H. eapply L.ge_trans.
-    apply L.ge_refl. apply L.eq_sym. apply H. apply L.ge_lub_right.
-  Qed.
-
-  (** Determining whether a given node is executable, in current dataflow solver *)
-  Definition preds_of cs pc := match (cs_preds cs) ! pc with
-                              | None => nil
-                              | Some l => l
-                            end.
-
-  Fixpoint node_is_executable_rec (es: exec_state) preds pc' :=
-    match preds with
-      | nil => false
-      | pc :: pcs =>
-        if es #2 (pc, pc') then true else node_is_executable_rec es pcs pc'
-    end.
-
-  Definition node_is_executable cs (st:state) pc' :=
-    match st with
-        (cfgwl, iws, lv, es) => node_is_executable_rec es (preds_of cs pc') pc'
-    end.
-
-  (* Unconditionally set an edge as executable when there is only one child *)
-  Definition single_succ (pc: node) (i: instruction) : option edge :=
-   match i with
-   | Inop s => Some (pc, s)
-   | Iop op args res s => Some (pc, s)
-   | Iload chunk addr args dst s => Some (pc, s)
-   | Istore chunk addr args src s => Some (pc, s)
-   | Icall sig ros args res s => Some (pc, s)
-   | Itailcall sig ros args => None
-   | Ibuiltin ef args res s => Some (pc, s)
-   | Icond cond args ifso ifnot => None
-   | Ijumptable arg tbl => None
-   | Ireturn optarg => None
-   end.
-
-  (** Picks a register from the worklist, from the top list if possible *)
-  Fixpoint pick_instr_rec vl (iws_t: list reg) (iws_nt: list reg) : (option reg * instr_workset) :=
-    match iws_t, iws_nt with
-      | x::xs, ys => (Some x, (xs, ys))
-      | nil, y::ys => if L.beq L.top vl# y then pick_instr_rec vl nil ys else (Some y, (nil, ys))
-      | nil, nil => (None, (nil, nil))
-    end.
-
-  Definition pick_instr vl (iws: instr_workset) : option reg * instr_workset:=
-    match iws with
-        (ts, nts) => pick_instr_rec vl ts nts
-    end.
-
-  (** Updates the state with the new value [nv] of [r], and adds it
-   to the workset if necessary *)
-  Definition add_instr_aux (r: reg) (v: L.t) (iws: instr_workset) :=
-    let (top, ntop) := iws in
-    if L.beq v L.top then (r :: top, ntop) else (top, r :: ntop).
-
-  Definition update_vals lv iws r nv :=
-    let ov := lv # r in
-    if bge ov nv
-    then (lv, iws)
-    else (lv # r <- (L.lub nv ov), add_instr_aux r (L.lub nv ov) iws).
-
-
-  (** Static evaluation of a phi-block *)
-   Fixpoint visit_phi_rec (lv: lattice_values) (es: exec_state) pc' args preds x :=
-     if L.beq L.top x then Some L.top else
-     match args, preds with
-       | y::ys, pc::pcs =>
-         let a := if es #2 (pc, pc') then lv # y else L.bot in
-         visit_phi_rec lv es pc' ys pcs (L.lub x a)
-       | nil, nil => Some x
-       | _, _ => None
-     end.
-
-   Definition visit_phi cs (st_in: state) pc' r_used pi : state :=
-     match st_in with (cfgwl, iws, lv, es) =>
-     match pi with Iphi args r =>
-       if L.beq L.top lv # r then (cfgwl, iws, lv, es) else
-       match visit_phi_rec lv es pc' args (preds_of cs pc') r_used with
-         | Some x => let (lv', iws') := update_vals lv iws r x in
-                     (cfgwl, iws', lv', es)
-         | None => (cfgwl, iws, lv, es)
-       end
-     end
-     end.
-
-   Definition visit_phibloc cs st r_used pc :=
-     match (fn_phicode f) ! pc with
-       | None => st
-       | Some pb => fold_left (fun acc pi => visit_phi cs acc pc r_used pi) pb st
-     end.
-
-   Definition visit_instr (st_in : state) pc instr :=
-     match st_in with (cfgwl, iws, lv, es) =>
-     match instr with
-       | Icond cond args ifso ifnot =>
-         match eval_static_condition cond lv ## args with
-           | Just true => ((pc, ifso)::cfgwl, iws, lv, es)
-           | Just false => ((pc, ifnot)::cfgwl, iws, lv, es)
-           | _ => ((pc, ifso) :: (pc, ifnot) :: cfgwl, iws, lv, es)
-         end
-       | Ijumptable arg tbl =>
-         match lv # arg with
-           | I k => match list_nth_z tbl (Int.unsigned k) with
-                         | None => (map (fun x:node => (pc, x)) tbl ++ cfgwl, iws, lv, es)
-                         | Some pc' => ((pc, pc')::cfgwl, iws, lv, es)
-                       end
-           | x => (map (fun x:node => (pc, x)) tbl ++ cfgwl, iws, lv, es)
-         end
-       | _ => match absint instr lv with
-                | Some (r, x) =>
-                  let (lv', iws') := update_vals lv iws r x in
-                  (cfgwl, iws', lv', es)
-                | None => (cfgwl, iws, lv, es)
-              end
-     end
-     end.
-
-   (** The register defined by an instruction *)
-   Definition def_reg i :=
-     match i with
-       | Iop _ _ r _ | Iload _ _ _ r _  | Istore _ _ _ r _
-       | Icall _ _ _ r _ | Ibuiltin _ _ (BR r) _  => Some r
-     | _ => None
-   end.
-
-   Definition visit_ssainstr cs st r_used (ssai : ssainstruction) :=
-     match st with (_, _, lv, _) =>
-     match ssai with
-       | (pc, inr pi) =>
-         visit_phi cs st pc r_used pi
-       | (pc, inl instr) =>
-         match def_reg instr with
-           | Some r => if L.beq L.top lv # r (* Optim: nothing to do if at top *)
-                       then st
-                       else match node_is_executable cs st pc with
-                              | false => st
-                              | true => visit_instr st pc instr
-                            end
-           | None =>  match node_is_executable cs st pc with (* Mostly conditionals*)
-                              | false => st
-                              | true => visit_instr st pc instr
-                      end
-         end
-     end
-     end.
-
-   Definition step (ms : const_state * state) : (option (lattice_values * exec_state))
-                                                + (const_state * state) :=
-     let (cs, st) := ms in
-     match st with (cfgwl, iws, lv, es) =>
-     match cfgwl with
-       | (pc0, pc) :: cfgwl' =>
-         match es #2 (pc0, pc) with
-           | true => inr _ (cs, (cfgwl', iws, lv, es))
-           | false =>
-             let es' := es #2 (pc0, pc) <- true in
-             let st2 := visit_phibloc cs (cfgwl', iws, lv ,es') L.bot pc in
-             match (fn_code f) ! pc with
-               | None => inl _ None
-               | Some instr =>
-                 match visit_instr st2 pc instr with
-                   | (cfgwl'', iws'', lv'', es'') =>
-                     match single_succ pc instr with
-                       | None => inr _ (cs, (cfgwl'', iws'', lv'', es''))
-                       | Some (x, y) => inr _ (cs, (if es' #2 (x,y)
-                                                    then cfgwl''
-                                                    else (x,y)::cfgwl'', iws'', lv'', es''))
-                     end
-                 end
-             end
-         end
-       | nil =>
-         match pick_instr lv iws with
-           | (Some r, iws') => (* Fold over all uses of [r] *)
-             inr _ (cs, (fold_left (fun st_in ssai => visit_ssainstr cs st_in lv # r ssai)
-                                   (cs_duc cs) # r
-                                   (cfgwl, iws', lv, es)))
-           | _ => inl _ (Some (lv, es))
-         end
-     end
-
-     end.
-
-   Definition initial_state : option state :=
-     let start i := match single_succ (fn_entrypoint f) i with
-                      | None => nil
-                      | Some x => x :: nil
-                    end in
-     match (fn_code f) ! (fn_entrypoint f) with
-       | None => None
-       | Some i => Some (start i, (nil, nil), initial_values, P2Map.init false)
-     end.
-
-  (** * Post-fixpoint checker *)
-  Definition executable_node (pc': node) (es: exec_state) :=
-    pc' = fn_entrypoint f \/ exists pc, es #2 (pc, pc') = true /\ SSA.cfg f pc pc'.
-
-  Definition bexecutable_node (pc': node) (preds: PTree.t (list node)) (es: exec_state) :=
-    if Pos.eq_dec pc' (fn_entrypoint f) then true else
-      existsb (fun pc => es #2 (pc, pc')) preds !!! pc'.
-
-  Definition check_code lv preds es :=
-    forall_ptree (fun pc i => match bexecutable_node pc preds es with
-                                | false => true
-                                | true => match absint i lv with
-                                            | None => true
-                                            | Some (r, nv) => bge (lv # r) nv
-                                          end
-                              end) (fn_code f).
-
-  Fixpoint check_phiinstruction lv es r rs preds pc' :=
-    match rs, preds with
-      | nil, nil => true
-      | x::xs, pc::pcs => match es #2 (pc, pc') with
-                            | false => check_phiinstruction lv es r xs pcs pc'
-                            | true => bge (lv # r) (lv # x) &&
-                                          check_phiinstruction lv es r xs pcs pc'
-                          end
-      | _, _ => false
-    end.
-
-  Definition check_phicode_g lv es preds (pc: node) pb :=
-    forallb (fun pi => match pi with
-                         | Iphi rs r => check_phiinstruction lv es r rs (preds !!! pc)  pc
-                       end) pb.
-
-  Definition check_phicode lv es preds :=
-    forall_ptree (check_phicode_g lv es preds) (fn_phicode f).
-
-  Definition check_non_exec_edge lv pc pc' :=
-    match (fn_code f) ! pc with
-      | Some (Icond cond args ifso ifnot) =>
-        match Pos.eq_dec pc' ifso with
-          | left _ => match eval_static_condition cond lv ## args with
-                      | Just false => match Pos.eq_dec pc' ifnot with
-                                        | right _ => true
-                                        | left _ => match eval_static_condition cond lv ## args with
-                                                      | Just true => true
-                                                      | _ => false
-                                                    end
-                                      end
-                      | _ => false
-                      end
-          | right _ => match Pos.eq_dec pc' ifnot with
-                       | right _ => false
-                       | left _ => match eval_static_condition cond lv ## args with
-                                   | Just true => true
-                                   | _ => false
-                                   end
-                       end
-        end
-      | Some (Ijumptable arg tbl) =>
-        match lv # arg with
-          | I n => match list_nth_z tbl (Int.unsigned n) with
-                        | Some p => if Pos.eq_dec p pc' then false else true
-                        | None => true (* ???? *)
-                      end
-          | _ => false
-        end
-      | Some i => false
-      | None => false
-    end.
-
-  Definition check_executable_flags lv es preds :=
-    forall_ptree
-      (fun pc' _ => forallb (fun pc => match bexecutable_node pc preds es with
-                                         | true => if bool_dec es #2 (pc, pc') false
-                                                   then check_non_exec_edge lv pc pc'
-                                                   else true
-                                         | false => true
-                                       end) (preds !!! pc')) (fn_code f).
-
-  Definition check lv es preds :=
-    (check_phicode lv es preds)
-      && (check_code lv preds es)
-      && (check_executable_flags lv es preds).
-
-  (** Fixpoint *)
-  
-  (** ** Construction *)
-  Definition regs_used_by (i : instruction) : list reg :=
-    match i with
-    | Iop _ l _ _ => l
-    | Iload _ _ l _ _ => l
-    | Istore _ _ l _ _ => l
-    | Icall _ ros l _ _
-    | Itailcall _ ros l =>
-      match ros with
-      | inl r => r :: l
-      | inr _ => l
-      end
-    | Ibuiltin _ l _ _ => (params_of_builtin_args l)
-    | Icond _ l _ _ => l
-    | Ijumptable r _ => r :: nil
-    | Ireturn (Some r) => r :: nil
-    | _ => nil
-    end.
-
-  Definition handle_reg_list (duc: du_chain) (ssai: ssainstruction) (rs: list reg) :=
-    List.fold_left (fun u r => PMap.set r (ssai :: u # r) u) rs duc.
-
-  Definition def_use_1 duc c :=
-    PTree.fold (fun u pc i => handle_reg_list u (pc, inl _ i) (regs_used_by i)) c duc.
-
-  Definition handle_phi_block (duc : du_chain) pc (pb : phiblock) :=
-    List.fold_left
-      (fun u pi => match pi with
-                     Iphi args _ => handle_reg_list u (pc, inr _ pi) args end)
-      pb duc.
-
-  Definition def_use_2 duc phic :=
-    PTree.fold (fun u pc pb => handle_phi_block u pc pb) phic duc.
-
-  Definition make_du_chain f : du_chain :=
-    let u := def_use_1 (PMap.init nil) (fn_code f) in
-    def_use_2 u (fn_phicode f).
-
-  
-  Definition fixpoint :=
-    let failed := (PMap.init L.top, P2Map.init true) in
-    let preds :=  make_predecessors (fn_code f) successors_instr in
-    let cs := mkConstantState (make_du_chain f) preds in
-    match initial_state with
-    | Some is =>
-      match PrimIter.iterate _ _ step (cs, is) with
-      | Some (Some (lv, es)) =>
-        let lv' := PMap.map (fun v => if L.beq v L.bot then L.top else v) lv in
-        if check lv' es preds then (lv', es) else failed
-      | _ => failed
-      end
-    | None => failed
-    end.
-
-  (** ** Proof of the checker *)
-   Remark bexecutable_node_correct: forall es pc',
-     bexecutable_node pc' (make_predecessors (fn_code f) successors_instr) es = true <->
-     executable_node pc' es.
-   Proof.
-     intros es pc'. split. unfold executable_node, bexecutable_node in *.
-     intros H.
-     destruct (Pos.eq_dec pc' (fn_entrypoint f)). auto. right.
-     apply existsb_exists in H as [pc [H1 H2]].
-     exists pc. intuition.
-     assert (exists i : instruction, (fn_code f) ! pc = Some i).
-     unfold "!!!" in *. flatten H1.
-     eapply make_predecessors_some in Eq; eauto.
-     unfold In in *. contradiction.
-     destruct H as [i H].
-     assert (In pc' (successors_instr i)).
-     eapply make_predecessors_correct2; eauto.
-     econstructor; eauto.
-
-     intros H. unfold bexecutable_node.
-     destruct (Pos.eq_dec pc' (fn_entrypoint f)). auto.
-     apply existsb_exists. unfold executable_node in *.
-     destruct H as [H | [pc H]].
-     contradiction.
-     exists pc.
-     intuition.
-     invh SSA.cfg.
-     eapply make_predecessors_correct_1; eauto.
-   Qed.
-
-   Definition code_post_fixpoint lv es :=
-     forall pc i r v,
-     (fn_code f) ! pc = Some i ->
-     executable_node pc es ->
-     absint i lv = Some (r, v) ->
-     L.ge lv # r v.
-
-   Remark check_code_correct: forall lv es,
-     check_code lv (make_predecessors (fn_code f) successors_instr) es = true ->
-     code_post_fixpoint lv es.
-   Proof.
-     intros lv es H. unfold check_code, code_post_fixpoint in *.
-     intros. eapply forall_ptree_true in H; eauto.
-     apply bexecutable_node_correct in H1.
-     flatten H.
-     apply bge_correct; auto.
-   Qed.
-
-   Definition phicode_post_fixpoint lv es := forall pc pb r l xi pc' k,
-    (fn_phicode f) ! pc' = Some pb ->
-    In (Iphi l r) pb ->
-    index_pred (make_predecessors (fn_code f) successors_instr) pc pc' = Some k ->
-    es #2 (pc, pc') = true ->
-    nth_error l k = Some xi ->
-    L.ge (lv # r) (lv # xi).
-
-   Hint Resolve bge_correct: core.
-   
-   Remark check_phiinstruction_correct: forall lv es pb r l pc' preds,
-     (fn_phicode f) ! pc' = Some pb ->
-     check_phiinstruction lv es r l preds  pc' = true->
-     forall pc xi k,
-     (k < length preds)%nat ->
-     Utils.get_index preds pc = Some k ->
-     es #2 (pc, pc') = true ->
-     nth_error l k = Some xi ->
-     L.ge (lv # r) (lv # xi).
-   Proof.
-     intros.
-     generalize dependent l.
-     induction preds.
-     + simpl in *. intros. lia.
-     + simpl in *. intros.
-       destruct l.
-       simpl in *. congruence.
-
-       assert (check_phiinstruction lv es r l preds pc' = true).
-       simpl in *.
-       flatten H0; apply andb_true_iff in H0; intuition.
-
-       destruct (eq_nat_dec k O).
-       - subst. unfold nth_error in H4. inv H4.
-         assert (a = pc).
-         apply get_index_nth_error in H2.
-         unfold nth_error in *. simpl in *. inv H2. reflexivity.
-         subst. simpl in *. flatten H0.
-         apply bge_correct. apply andb_true_iff in H0. intuition.
-       - assert (exists k0, k = Datatypes.S k0) as [k0 Hk].
-           destruct (O_or_S k). inv s. exists x. auto.
-           congruence.
-         subst.
-         eapply IHpreds with (k := k0) (l := l); eauto.
-         * lia.
-         * eapply get_index_cons_succ; eauto.
-   Qed.
-
-   Remark check_phicode_correct: forall lv es,
-     check_phicode lv es (make_predecessors (fn_code f) successors_instr) = true ->
-     phicode_post_fixpoint lv es.
-   Proof.
-     intros lv es H.
-     unfold phicode_post_fixpoint, check_phicode in *.
-     intros pc pb r l xi pc' k H1 H2 H3 H4.
-     eapply forall_ptree_true in H; eauto.
-     unfold check_phicode_g in *. eapply forallb_forall in H; eauto.
-     flatten H.
-     eapply check_phiinstruction_correct; eauto.
-     eapply index_pred_some; eauto.
-   Qed.
-
-   Definition exec_flags_sound lv es :=
-     forall pc pc' i
-            (EX_CFG: SSA.cfg f pc pc')
-            (EX_NOTEXEC: es #2 (pc, pc') = false)
-            (EX_INS: (fn_code f) ! pc' = Some i),
-       ~executable_node pc es \/
-       match (fn_code f) ! pc with
-         | Some (Icond cond args ifso ifnot) =>
-           (ifso  = pc' -> eval_static_condition cond lv ## args = Just false) /\
-           (ifnot = pc' -> eval_static_condition cond lv ## args = Just true)
-         | Some (Ijumptable arg tbl) =>
-           exists n, (lv # arg = I n /\ list_nth_z tbl (Int.unsigned n) <> Some pc')
-         | _ => False
-       end.
-
-   Remark check_executable_flags_correct: forall es lv,
-     check_executable_flags lv es (make_predecessors (fn_code f) successors_instr) = true ->
-     exec_flags_sound lv es.
-   Proof.
-     intros.
-     unfold exec_flags_sound, check_executable_flags in *. intros.
-     match goal with
-       | H: forall_ptree ?f ?code = true |- _ =>
-         assert (forall pp x, code ! pp = Some x -> f pp x = true) as H0
-     end.
-     apply forall_ptree_true; auto.
-     destruct (classic (executable_node pc es)); intuition.
-     destruct ((fn_code f) ! pc) eqn:eq.
-     + specialize (H0 pc' i EX_INS).
-       eapply forallb_forall with (x := pc) in H0; eauto.
-       flatten H0; eauto.
-       - unfold check_non_exec_edge in H0. rewrite eq in H0.
-         flatten H0; right; intuition.
-         * exists n. intuition. 
-         * exists n. intuition. 
-       - left. intro contra; apply bexecutable_node_correct in contra. congruence.
-       - invh cfg. eapply make_predecessors_correct_1; eauto.
-     + invh cfg. unfold fn_code in *. rewrite eq in HCFG_ins. congruence.
-   Qed.
-
-   Remark top_is_post_fixpoint:
-    code_post_fixpoint (PMap.init L.top) (P2Map.init true)
-    /\ phicode_post_fixpoint (PMap.init L.top) (P2Map.init true)
-    /\ exec_flags_sound (PMap.init L.top) (P2Map.init true).
-  Proof.
-    unfold code_post_fixpoint. split. intros.
-    rewrite PMap.gi. apply L.ge_top. split.
-    unfold phicode_post_fixpoint. intros. rewrite PMap.gi. apply L.ge_top.
-    unfold exec_flags_sound. intros. rewrite P2Map.gi in *. discriminate.
-  Qed.
-
-  Remark check_correct: forall lv es,
-    check lv es (make_predecessors (fn_code f) successors_instr) = true ->
-    code_post_fixpoint lv es /\ phicode_post_fixpoint lv es /\ exec_flags_sound lv es.
-  Proof.
-    intros. unfold check in H. apply andb_prop in H. destruct H as [H1 H2].
-    apply andb_prop in H1. destruct H1 as [H1 H3].
-    split.
-      apply check_code_correct; assumption. split.
-      apply check_phicode_correct; assumption.
-      apply check_executable_flags_correct; assumption.
-  Qed.
-
-  (** ** Correctness of du_chains *)
-  Definition ssai_in_function ssai f :=
-    match ssai with
-    | (pc, inl i)  => (fn_code f) ! pc = Some i
-    | (pc, inr pi) => exists pb, (fn_phicode f) ! pc = Some pb /\ In pi pb
-    end.
-
-  Definition maps_into_function f m := forall r ssai,
-      In ssai (m # r) -> ssai_in_function ssai f.
-
-  Hint Unfold maps_into_function ssai_in_function: core.
-
-  Lemma duc_maps_into_function_handle_reg_list: forall f duc ssai rs,
-      maps_into_function f duc ->
-      ssai_in_function ssai f ->
-      maps_into_function f (handle_reg_list duc ssai rs).
-  Proof.
-    intros. generalize dependent duc.
-    induction rs.
-    tauto.
-    intros.
-    simpl in *. eapply IHrs; eauto.
-    unfold maps_into_function in *. intros.
-    destruct (peq a r).
-    + subst.
-      rewrite PMap.gss in *.
-      inv H1; eauto.
-    + rewrite PMap.gso in *; auto. eauto.
-  Qed.
-
-  Lemma duc_maps_into_function_code: forall f duc,
-      maps_into_function f duc ->
-      maps_into_function f (def_use_1 duc (fn_code f)).
-  Proof.
-    intros.
-    unfold def_use_1.
-    apply PTree_Properties.fold_rec; auto.
-    intros.
-    apply duc_maps_into_function_handle_reg_list; auto.
-  Qed.
-
-  Lemma duc_maps_into_function_phibloc: forall f duc pc pb l,
-      maps_into_function f duc ->
-      (fn_phicode f) ! pc = Some pb ->
-      (exists pref, pref ++ l = pb) ->
-      maps_into_function f (handle_phi_block duc pc l).
-  Proof.
-    intros.
-    generalize dependent duc. induction l; auto.
-    destruct a.
-    unfold maps_into_function; intros.
-    simpl in *; flatten H2.
-
-    eapply IHl with (duc := (handle_reg_list duc (pc, inr (Iphi l0 r)) l0)); eauto.
-    { invh ex. exists (x ++ Iphi l0 r :: nil). rewrite <- app_assoc. reflexivity. }
-    eapply duc_maps_into_function_handle_reg_list; eauto.
-    simpl. exists pb. intuition. invh ex.
-    { assert (In (Iphi l0 r) (Iphi l0 r :: l)). auto. apply in_app. auto. }
-  Qed.
-
-  Lemma duc_maps_into_function_phicode: forall f duc,
-      maps_into_function f duc ->
-      maps_into_function f (def_use_2 duc (fn_phicode f)).
-  Proof.
-    intros.
-    unfold def_use_2.
-    apply PTree_Properties.fold_rec; auto.
-    intros.
-    eapply duc_maps_into_function_phibloc; eauto.
-    exists nil; reflexivity.
-  Qed.
-
-  Lemma duc_maps_into_function: forall f,
-      maps_into_function f (make_du_chain f).
-  Proof.
-    unfold make_du_chain. intros.
-    eapply duc_maps_into_function_phicode; eauto.
-    eapply duc_maps_into_function_code; eauto.
-    unfold maps_into_function. intros.
-    rewrite PMap.gi in H.
-    contradiction.
-  Qed.
-
-  (* Proof that uninitialized values stay at bot *)
-  Definition get_lv (st: state) :=
-    match st with
-        (_, _, lv, _) => lv
-    end.
-
-  Definition not_defined r := (forall lv r' nv i pc,
-    (fn_code f) ! pc = Some i -> absint i lv = Some (r', nv) -> r <> r') /\
-    (forall pc pb l r', (fn_phicode f) ! pc = Some pb -> In (Iphi l r') pb -> r <> r').
-
-  Remark defined_nowhere_stationary_aux_update_val:
-    forall lv b r t lv',
-      fst (update_vals lv b r t) = lv' ->
-      (forall r', r' <> r -> lv' # r' = lv # r').
-  Proof.
-    intros.
-    unfold update_vals in *.
-    flatten H; simpl in *; try congruence.
-    subst. rewrite PMap.gso; auto.
-  Qed.
-
-  Remark defined_nowhere_stationary_aux_visit_instr: forall st r pc i,
-    not_defined r ->
-    (fn_code f) ! pc = Some i ->
-    (get_lv (visit_instr st pc i)) # r = (get_lv st) # r.
-  Proof.
-    intros.
-    unfold not_defined in *.
-    unfold visit_instr in *.
-    destruct H as [Ha Hb].
-    flatten; simpl in *; try (reflexivity); subst;
-      try match goal with
-          [H: (absint _ _ = Some (?r0, _)),
-           H1: update_vals ?l ?i0 ?r1 ?t = (?t0, ?i1)  |- (_ = ?l !! r) ]=>
-           assert (r <> r0);
-             [intro contra; subst; eapply Ha; eauto |
-              eapply (defined_nowhere_stationary_aux_update_val l i0 r0 t) ; eauto];
-             rewrite H1; simpl; auto
-      end.
-  Qed.
-
-  Remark defined_nowhere_stationary_aux_visit_phi: forall st cs r pc r_used pi pb,
-    not_defined r ->
-    (fn_phicode f) ! pc = Some pb -> In pi pb ->
-    (get_lv (visit_phi cs st pc r_used pi)) # r = (get_lv st) # r.
-  Proof.
-    intros.
-    unfold visit_phi in *.
-    flatten.
-    assert (r <> r0) by ( destruct H as [Ha Hb]; eapply Hb; eauto).
-    subst.
-    assert (fst (update_vals l i r0 t) = t0) by (rewrite Eq5; simpl; auto).
-    eapply defined_nowhere_stationary_aux_update_val; go.
-  Qed.
-
-  Remark defined_nowhere_stationary_aux_visit_phibloc_rec:
-    forall st st' cs r pc r_used pb,
-    not_defined r ->
-    (fn_phicode f) ! pc = Some pb ->
-    (forall l, (exists l', l' ++ l = pb) ->
-               fold_left (fun acc pi => visit_phi cs acc pc r_used pi)
-                         l
-                         st = st' ->
-               (get_lv st') # r = (get_lv st) # r).
-  Proof.
-    intros.
-    generalize dependent st.
-    induction l.
-    + intros. simpl in *. unfold get_lv. flatten.
-    + intros.
-      simpl in *.
-      assert ((get_lv st') !! r = (get_lv (visit_phi cs st pc r_used a)) !! r).
-      eapply IHl with (st := visit_phi cs st pc r_used a); eauto.
-      invh ex.
-      exists (x ++ a :: nil). {
-        rewrite <- app_assoc.
-        simpl.
-        apply eq_refl.
-      }
-      assert ((get_lv (visit_phi cs st pc r_used a)) !! r = (get_lv st) !! r).
-      eapply defined_nowhere_stationary_aux_visit_phi; eauto.
-      invh ex. {
-        assert (In a (a::l)). apply in_eq.
-        apply in_app.
-        auto.
-      }
-      congruence.
-  Qed.
-
-  Remark defined_nowhere_stationary_aux_visit_phibloc: forall st st' cs r pc r_used,
-    not_defined r ->
-    visit_phibloc cs st r_used pc = st' ->
-    (get_lv (visit_phibloc cs st r_used pc)) !! r = (get_lv st) !! r.
-  Proof.
-    intros.
-    unfold visit_phibloc in *.
-    destruct ((fn_phicode f) ! pc) as [pb |] eqn:eq.
-    eapply defined_nowhere_stationary_aux_visit_phibloc_rec
-      with (l := pb) (cs := cs) (r_used := r_used) (st := st); eauto.
-    exists nil. reflexivity.
-    subst. reflexivity.
-  Qed.
-
-  Remark defined_nowhere_stationary_aux_rec_helper: forall r m (x : ssainstruction) l',
-    maps_into_function f m ->
-    (exists pref, pref ++ x :: l' = m # r) ->
-    ssai_in_function x f.
-  Proof.
-    intros.
-    destruct H0 as [prefs H0].
-    assert (In x m # r).
-    rewrite <- H0.
-    assert (In x (x::l')); auto.
-    apply in_app. auto.
-    eapply H; eauto.
-  Qed.
-
-  Remark defined_nowhere_stationary_aux: forall st st' r cs cs',
-    not_defined r -> step (cs, st) = inr (cs', st') ->
-    maps_into_function f (cs_duc cs) ->
-    (get_lv st) # r = (get_lv st') # r.
-  Proof.
-    intros.
-    remember st as St.
-    destruct st as [[[a b] lv] c].
-    unfold step in *.
-    rewrite HeqSt in *.
-    flatten H0; try (flatten H0; reflexivity); simpl;
-    try (match goal with
-        [ h: context[ visit_phibloc ?cs ?stin ?bot ?n0 ] |- _ ] =>
-        assert ((get_lv (visit_phibloc cs stin bot n0)) !! r = lv !! r);
-          [eapply defined_nowhere_stationary_aux_visit_phibloc; eauto |
-           assert ( (get_lv (visit_instr
-                               (visit_phibloc cs stin bot n0) n0 i)) !! r =
-                    (get_lv (visit_phibloc cs stin bot n0)) !! r);
-                  [eapply defined_nowhere_stationary_aux_visit_instr; eauto |
-                    assert ((get_lv
-                               (visit_instr
-                                  (visit_phibloc cs stin bot n0) n0 i)) = t)]
-          ]
-      end; [
-
-      match goal with
-          [ H: visit_instr _ _ _ = _ |- _ ] => rewrite H; reflexivity
-      end |
-      congruence]).
-
-    match goal with
-        [ |- context [ fold_left ?fn_ ?l_ ?acc0 ] ]=>
-        set (fn := fn_); set (l := l_)
-    end.
-    assert (forall l' acc,
-              (exists pref, pref ++ l' = l) ->
-              (get_lv (fold_left fn l' acc)) !! r = (get_lv acc) !! r) as Hbi.
-    + induction l'; intros; simpl in *.
-      - tauto.
-      - assert ((get_lv (fn acc a)) # r = (get_lv acc) # r) as Hsame.
-        * unfold fn. unfold visit_ssainstr.
-          flatten;
-          try (unfold l in *; subst;
-               assert (ssai_in_function (n, inl i1) f);
-               [eapply defined_nowhere_stationary_aux_rec_helper; eauto |
-                eapply defined_nowhere_stationary_aux_visit_instr; eauto]).
-          assert (ssai_in_function (n, inr p1) f).
-          eapply defined_nowhere_stationary_aux_rec_helper; eauto.
-          unfold ssai_in_function in *.
-          destruct H2 as [pb [Hphib Hin]].
-          eapply defined_nowhere_stationary_aux_visit_phi; eauto.
-        * rewrite <- Hsame.
-          eapply IHl'.
-          invh ex.
-          exists (x ++ a::nil). rewrite <- app_assoc. auto.
-    + rewrite Hbi; auto.
-      exists nil; auto.
-  Qed.
-
-  Remark cs_constant: forall cs cs' st st',
-    step (cs, st) = inr (cs', st') -> cs = cs'.
-  Proof.
-    intros.
-    unfold step in *. flatten H.
-  Qed.
-
-
-  Remark defined_nowhere_stationary: forall r lv es is ,
-    not_defined r -> initial_state = Some is ->
-    PrimIter.iterate
-      _ _ step (mkConstantState (make_du_chain f)
-                                (make_predecessors (fn_code f) successors_instr), is) = Some (Some (lv, es)) ->
-     lv # r = initial_values # r.
-  Proof.
-    intros.
-    set (P (s:const_state*state) :=
-           forall cs st, s = (cs, st) ->
-                         ((get_lv st) # r = initial_values # r)
-                         /\ (maps_into_function f (cs_duc cs))).
-    set (Q (o: option (lattice_values * exec_state)) :=
-           forall v es', o = Some (v, es') -> v # r = initial_values # r).
-    assert (Q (Some (lv, es))).
-    {
-      eapply PrimIter.iterate_prop with (step := step) (P := P) ; unfold P, Q.
-      + intro. destruct (step a) eqn:eq.
-        unfold step in eq. intros. subst.
-        flatten eq.
-        assert ((get_lv ((nil, i, v, es'):state)) # r =  v # r) by reflexivity.
-        destruct (H2 c (nil, i, v, es')) as [Hlv Hduc]; auto.
-
-        intros. subst. destruct a as (cs0, st0).
-        destruct (H2 cs0 st0) as [Hlv Hduc]; auto.
-        split. rewrite <- Hlv. apply eq_sym.
-        eapply defined_nowhere_stationary_aux; eauto.
-        eapply cs_constant in eq. subst. assumption.
-
-      + eapply H1.
-      + intros. unfold initial_state in *.
-        flatten H0. split; [auto | apply duc_maps_into_function].
-                    split; [auto | apply duc_maps_into_function].
-      }
-
-      unfold Q in *. apply H2 with es. apply eq_refl.
-  Qed.
-  
-  Lemma defined_nowhere_becomes_top: forall r,
-    not_defined r -> initial_values # r = L.bot -> (fst fixpoint) # r = L.top.
-  Proof.
-    intros.
-    unfold fixpoint in *.
-    flatten; subst; simpl; try (rewrite PMap.gi; eauto).
-    assert (l # r = initial_values # r)
-    by (eapply defined_nowhere_stationary with (3:= Eq0); eauto).
-    rewrite PMap.gmap.
-    rewrite H1. rewrite H0. auto.
-  Qed.
-
-  Lemma defined_nowhere_stays_top: forall r lv,
-    not_defined r -> initial_values # r = L.top -> lv = fst fixpoint -> lv # r = L.top.
-  Proof.
-    intros; unfold fixpoint in *.
-    flatten H1 ; subst; try (simpl ; rewrite PMap.gi;  eauto).
-    simpl. rewrite PMap.gmap.
-    assert (l !! r = initial_values !! r)
-      by (eapply defined_nowhere_stationary; eauto).
-    rewrite H0 in *.
-    rewrite H1.
-    auto. 
-  Qed.
-
-  (** * Correctness lemma *)
-  Lemma post_fixpoint: forall lv es,
-    fixpoint = (lv, es) ->
-    code_post_fixpoint lv es
-    /\ phicode_post_fixpoint lv es
-    /\ exec_flags_sound lv es.
-  Proof.
-    intros. unfold fixpoint in H.
-    destruct (initial_state).
-    match goal with
-        H: context [ PrimIter.iterate ?x ?y ?z ?t ] |- _ =>
-        destruct (PrimIter.iterate x y z t)
-    end.
-     + destruct o. destruct p.
-       - flatten H.
-         apply check_correct in Eq. assumption.
-         apply top_is_post_fixpoint.
-       - inv H. apply top_is_post_fixpoint.
-     + inv H. apply top_is_post_fixpoint.
-     + inv H. apply top_is_post_fixpoint.
-  Qed.
-
-  End CDS.
-  
-End DataflowSolver.
-
-
-(** * SCCP optimization, as an instantiation of the generic analysis.  *)
-Section Opt.
-
-  (** ** Definition *)
-  Definition handle_instr (i: instruction) res : option (reg * AVal.t) :=
-    match i with
-    | Iop op regs r _ =>
-      let vs := List.map (fun r => (PMap.get r res)) regs in
-      Some (r,  eval_static_operation op vs)
-    | Iload _ _ _ r _ | Icall _ _ _ r _ | Ibuiltin _ _ (BR r) _ => Some (r, AVal.top)
-    | _ => None
-    end.
-
-  Definition initial f :=
-    List.fold_left
-      (fun vals r => PMap.set r AVal.top vals)
-      (fn_params f)
-      (PMap.init AVal.bot).
-
-  Definition fixpoint f:=
-    let fp := (DataflowSolver.fixpoint f handle_instr (initial f)) in
-    ((fun r => PMap.get r (fst fp)),snd fp).
-
-  Definition const_for_result (a: aval) : option operation :=
-    match a with
-    | I n => Some(Ointconst n)
-    | F n => if Compopts.generate_float_constants tt then Some(Ofloatconst n) else None
-    | FS n => if Compopts.generate_float_constants tt then Some(Osingleconst n) else None
-    | _ => None
-    end.
-  
-  Definition transf_instr (approx: reg -> AVal.t) (n: node) i :=
-    match i with
-    | Iop op args res s =>
-      match const_for_result (eval_static_operation op (map approx args)) with
-      | Some cop => Iop cop nil res s
-      | _ => i
-      end
-    | _ => i
-    end.
-
-  Definition transf_function (f: function) := 
-    @Opt.transf_function _ fixpoint transf_instr f. 
-  
-  Definition transf_fundef (f: fundef) : fundef :=
-    AST.transf_fundef transf_function f.
-
-  Definition transf_program (p: program) : program :=
-    AST.transform_program transf_fundef p.
-
-End Opt.
-
diff --git a/midend/SCCPoptProp.v b/midend/SCCPoptProp.v
deleted file mode 100644
index a32daf75..00000000
--- a/midend/SCCPoptProp.v
+++ /dev/null
@@ -1,585 +0,0 @@
-Require Import Coqlib.
-Require Import Maps.
-Require Import Maps2.
-Require Import AST.
-Require Import Op.
-Require Import Registers.
-Require Import Utils.
-Require Import Classical.
-Require Import Lattice.
-Require Import Iteration.
-Require Import DLib.
-Require Import Integers.
-Require Import Kildall.
-Require Import KildallComp.
-Require Import SSA.
-Require Import SSAutils.
-Require Import Utilsvalidproof.
-Require Values.
-Require Import SCCPopt.
-Require Opt.
-Require Import Dsd.
-Unset Allow StrictProp.
-
-(** * Proof obligations from [OptInv] *)
-Module DS := DataflowSolver.
-Require Import OptInv ValueDomainSSA ValueAOpSSA.
-Require Import Globalenvs.
-
-Section DSD_ANALYSIS.
-
-  Notation A := fixpoint.
-  Notation A_r f := (fst (A f)).
-  Notation A_e f := (snd (A f)).
-
-  (* Minimal block classification for analyzing operators *)
-  Program Definition bctop (ge:genv): block_classification :=
-    BC (fun b =>
-          if (plt b (Genv.genv_next ge)) then
-            match Genv.invert_symbol ge b with
-            | None => BCother
-            | Some id => BCglob id end
-          else BCother) _ _.
-  Next Obligation.
-    flatten H.
-  Qed.
-  Next Obligation.
-    flatten H. 
-    eapply Genv.invert_find_symbol in Eq0.
-    eapply Genv.invert_find_symbol in Eq.
-    congruence.
-  Qed.
-  
-  Definition G (ge: genv) (sp: Values.val) (rs: regset) := fun av v => (vmatch (bctop ge) v av).
-  
-  Hint Unfold G: core.
-  Definition result := reg -> AVal.t.
-  Definition is_at_Top (res: result) (r: reg) : Prop := res r = AVal.top.
-
-  Lemma G_increasing: forall ge sp rs x y z,
-                        vge x y -> G ge sp rs y z -> G ge sp rs x z.
-  Proof.
-    intros.
-    unfold G in *.
-    eapply vmatch_ge; eauto.
-  Qed.
-
-  Lemma G_top : forall f r ge sp rs, is_at_Top (A_r f) r -> G ge sp rs (A_r f r) (rs# r).
-  Proof.
-    intros. invh is_at_Top.
-    unfold G. simpl. rewrite H1. unfold AVal.top.
-    destruct (rs !! r) ; try solve [eapply vmatch_top ; eauto; go].
-    case_eq (bctop ge b); intros.
-    - simpl in H; flatten H.
-    - simpl in H; flatten H.
-      eapply vmatch_top; eauto.
-      econstructor; eauto.
-      econstructor; eauto.
-      simpl. flatten. eauto.
-    - simpl in H; flatten H.
-    - simpl in H; flatten H;
-      try solve [(econstructor; eauto);
-                 (econstructor; eauto);
-                 (simpl; flatten)].
-    Unshelve.
-    go. go.
-  Qed.
-
- Lemma is_at_Top_eq_is_at_Top : forall f dst x,
-   is_at_Top (A_r f) dst -> A_r f x = A_r f dst -> is_at_Top (A_r f) x.
-  Proof.
-    unfold is_at_Top; intros. congruence.
-  Qed.
-
-  Remark ext_params_not_defined: forall (f:function) x,
-      wf_ssa_function f ->
-      ext_params f x ->
-      DS.not_defined f handle_instr x.
-  Proof.
-    intros.
-    Ltac ssa_params :=
-      match goal with
-          HH : In _ (fn_params _) |- _ => apply fn_ssa_params in HH
-      end.
-
-    unfold DS.not_defined. split.
-    + intros lv r' nv i pc H1. 
-      unfold handle_instr in *.
-      intro contra; subst.
-      flatten H1; assert (assigned_code_spec (fn_code f) pc r'); eauto;
-      try (invh ext_params; [ ssa_params ; [intro; subst; intuition; eauto | eauto]
-                  | intro; subst; unfold not in *; eauto]).
-    + intros. 
-      intro contra; subst.
-      assert (assigned_phi_spec (fn_phicode f) pc r'); try (econstructor; eauto).
-      invh ext_params.
-      - ssa_params. intuition; eauto. assumption.
-      - intuition; eauto.
-  Qed.
-
-  Remark params_at_top_aux: forall f,
-                            forall r inilv res,
-    fold_left (fun lv r => PMap.set r AVal.top lv) (fn_params f)  inilv = res ->
-    ((In r (fn_params f) -> res # r = AVal.top)
-     /\ ((~In r (fn_params f)) -> res # r = inilv # r)).
-  Proof.
-    intros. subst. generalize dependent inilv.
-    unfold initial.
-    induction (fn_params f).
-    + intros. simpl in *. intuition.
-    + intros. simpl in *. specialize (IHl (inilv # a <- AVal.top)).
-      destruct IHl.
-      split.
-    - intros. inv H1. 
-      destruct (in_dec peq r l); intuition;
-      match goal with
-          H: ?t = ?t' |- _ => rewrite H
-      end; apply PMap.gss; intuition. intuition.
-    - intros H1. intuition.
-      rewrite H1.
-      apply PMap.gso; eauto.
-  Qed.
-
-  Lemma params_at_top: forall f,
-      forall r,
-        In r (fn_params f) -> (initial f) # r = AVal.top.
-  Proof.
-    intros.
-    set (lv := initial f). unfold initial in *.
-    set (HH := params_at_top_aux f).
-    specialize (HH r (PMap.init AVal.bot) lv).
-    intuition.
-  Qed.
-
-  Lemma ext_param_at_top: forall (f:function) r,
-      wf_ssa_function f ->
-      ext_params f r -> is_at_Top (A_r f) r.
-  Proof.
-    intros.
-    destruct (in_dec peq r (fn_params f)).
-    + assert ((initial f) # r = AVal.top) by (apply params_at_top; auto).
-      exploit ext_params_not_defined; eauto. intros NDEF.
-      eapply DS.defined_nowhere_stays_top; eauto.
-    + set (ini := initial f). unfold initial in *.
-      set (HH := params_at_top_aux f).
-      specialize (HH r (PMap.init AVal.bot) ini).
-      rewrite PMap.gi in *.
-      assert (ini # r = AVal.bot) by intuition.
-      exploit ext_params_not_defined; eauto.  intros NDEF.
-      eapply DS.defined_nowhere_becomes_top; eauto.
-  Qed.
-
-  Definition exec f pc := DS.executable_node f pc (A_e f).
-
-  Lemma exec_fn_entrypoint : forall f, exec f (fn_entrypoint f).
-  Proof.
-    go.
-  Qed.
-
-(** Instantiating the [DsdAnalysis] record *)
-  Definition SCCP := (OptInv.Build_DsdAnalysis AVal.t G is_at_Top A
-                                               exec exec_fn_entrypoint
-                                               is_at_Top_eq_is_at_Top
-                                               ext_param_at_top G_top).
-End DSD_ANALYSIS.
-
-
-(** * Some more auxiliary lemmas to retrieve soundness invariant of the analysis *)
-
-Section AuxResults.
-
-Variant single_succ_instr f : node -> Prop :=
-| SSnop: forall pc s,
-   (fn_code f) !pc = Some (Inop s) -> single_succ_instr f pc
-| SSop: forall pc op args dst s,
-   (fn_code f) !pc = Some (Iop op args dst s) -> single_succ_instr f pc
-| SSload: forall pc chk adr args dst s,
-   (fn_code f) !pc = Some (Iload chk adr args dst s) -> single_succ_instr f pc
-| SSbuiltin: forall pc ef args dst s,
-   (fn_code f) !pc = Some (Ibuiltin ef args dst s) -> single_succ_instr f pc
-| SSstore: forall pc chk adr args src s,
-   (fn_code f) !pc = Some (Istore chk adr args src s) -> single_succ_instr f pc
-| SScall: forall pc sig fn args dst s,
-   (fn_code f) !pc = Some (Icall sig fn args dst s) -> single_succ_instr f pc.
-
-Lemma exec_single_succ: forall (f:function) lv es pc pc' i,
-  wf_ssa_function f ->
-  DataflowSolver.fixpoint f handle_instr (initial f) = (lv, es) ->
-  (fn_code f) ! pc = Some i ->
-  single_succ_instr f pc ->
-  successors_instr i = pc'::nil ->
-  exec f pc ->
-  es #2 (pc, pc') = true.
-Proof.
-  intros f lv es pc pc' i WF FIX H H0 H1 H2.
-  generalize FIX ; intro FIX'.
-  apply DS.post_fixpoint in FIX as [_ [_ He]].
-  unfold DS.exec_flags_sound in *.
-  destruct (classic (es !!2 (pc, pc') = true)) as [Hc | Hc].
-  + assumption.
-  + apply not_true_iff_false in Hc.
-    assert (exists i', (fn_code f) ! pc' = Some i') as [i' Hex].
-    { eapply fn_code_closed; eauto. rewrite H1. auto. }
-    assert (Hcfg: cfg f pc pc').
-    { econstructor; eauto. rewrite H1. auto. }
-    specialize (He pc pc' i' Hcfg Hc Hex).
-    inv He.
-  - inv H2. eelim H3; go.
-    destruct H4 as [pc0 [Htrue HHcfg]]. 
-    unfold fixpoint in *. simpl in *.
-    rewrite FIX' in *. simpl in Htrue.
-    eelim H3. econstructor 2; eauto; go.
-  - destruct ((fn_code f) ! pc) eqn:eq.
-    destruct i0; try contradiction.
-    inv H. simpl in *. inv H1.
-    inv H. inv H0; congruence.
-    contradiction.
-Qed.
-
-Lemma exec_node_single_succ: forall (f:function) lv es pc pc' i,
-   wf_ssa_function f ->
-   DS.fixpoint f handle_instr (initial f) = (lv, es) ->
-   (fn_code f) ! pc = Some i ->
-   single_succ_instr f pc ->
-   successors_instr i = pc'::nil ->
-   exec f pc ->
-   exec f pc'.
-Proof.
-  intros.
-  assert (es #2 (pc, pc') = true).
-  eapply exec_single_succ; eauto.
-  right.
-  exists pc. split.
-  - unfold fixpoint. simpl. rewrite H0. simpl. intuition.
-  - econstructor; eauto.
-    assert (In pc' (pc'::nil)). auto. congruence.
-Qed.
-
-Hint Unfold successors_instr: core.
-
-Lemma step_phi_aux: forall (f:function) ge pc pc' phib k sp rs,
-   wf_ssa_function f ->
-   reached f pc ->
-   exec f pc ->
-
-   (fn_code f) ! pc = Some (Inop pc') ->
-   (fn_phicode f) ! pc' = Some phib ->
-   index_pred (Kildall.make_predecessors (fn_code f) successors_instr) pc pc' = Some k ->
-
-   gamma SCCP f ge sp pc rs ->
-   gamma SCCP f ge sp pc' (phi_store k phib rs).
-Proof.
-  intros f ge pc pc' phib k sp rs WF HH H H0 H1 H2 H3.
-  intros r Hr Hexr.
-  destruct (classic (assigned_phi_spec (fn_phicode f) pc' r)) as [H6 | H6].
-  + invh assigned_phi_spec. invh ex.
-    allinv.
-    destruct (nth_error x k) eqn:eq.
-    * erewrite phi_store_copy2; eauto.
-      assert (AVal.ge (A_r SCCP f r) (A_r SCCP f r0)).
-      { case_eq (DataflowSolver.fixpoint f handle_instr (initial f)). intros lv es Hfp.
-        exploit DS.post_fixpoint; eauto.
-        intros [Hc [Hp He]].
-        exploit Hp; eauto.
-        eapply exec_single_succ with (lv:= lv); eauto; intuition.
-        econstructor; eauto.
-        intros.
-        unfold SCCP, A_r ; simpl.
-        rewrite Hfp. simpl. auto.
-      }
-
-      exploit dsd_pred_jpn'; eauto.
-      { intros [Hcase1 | Hcase2].
-        - destruct Hcase1. eapply G_increasing; eauto.
-           eapply H3; eauto.
-        - destruct Hcase2. eapply G_increasing; eauto.
-          exploit ext_param_at_top ; eauto. intros Htop.
-          replace (A_r SCCP f r0) with (fst (fixpoint f) r0) by reflexivity.
-          eapply (G_top); eauto.
-      }
-
-    * unfold phi_store.
-      assert (exists arg : reg, nth_error x k = Some arg).
-      eapply fn_phiargs; eauto. invh ex. congruence.
-  + destruct (peq pc (fn_entrypoint f)).
-    * subst.
-      exploit dsd_entry_ext_param; eauto. intros.
-      replace (A_r SCCP f r) with (fst (fixpoint f) r) by reflexivity.
-      eapply G_top; eauto.
-      eapply ext_param_at_top with (r:= r) ; eauto.
-    * erewrite phi_store_notin_preserved; eauto.
-      replace (A_r SCCP f r) with (fst (fixpoint f) r) by reflexivity.
-      exploit (dsd_pred_njp f WF pc pc' r) ; eauto. go.
-      { intros [Hcase1 | [Hcase2 | Hcase3]]; intuition auto.
-        - exploit H3; eauto.
-        - exploit (H3 r); eauto.
-          invh def; try congruence.
-          unfold fn_code in *.
-          invh assigned_code_spec; try congruence.
-      }
-Qed.
-
-Lemma exec_exec_helper : forall f pc es,
- exec f pc ->
- es = (A_e SCCP f) ->
- DS.executable_node f pc es.
-Proof.
-  unfold SCCP, A_e ; simpl in *.
-  intros. rewrite H0.
-  inv H. go.
-  destruct H1 as [pc0 [Hsnd Hcfg]].
-  go. 
-Qed.
-
-Lemma same_fn_code1 : forall (f:function) pc res,
-  forall (WF : wf_ssa_function f),
-    (forall op args res pc', (fn_code f) ! pc <> Some (Iop op args res pc')) ->
-    exec f pc ->
-    assigned_code_spec (fn_code f) pc res ->
-    is_at_Top (A_r SCCP f) res.
-Proof.
-  intros.
-  case_eq (DS.fixpoint f handle_instr (initial f)); intros lv es FIX.
-  generalize FIX; intros FIX'.
-  eapply DS.post_fixpoint in FIX as [Hc [Hp _]].
-  unfold DS.code_post_fixpoint in *.
-  assert (AVal.ge lv !! res AVal.top).
-  { inv H1; eapply Hc; eauto; try eapply exec_exec_helper; go;
-    (unfold SCCP, A_e; simpl; try rewrite FIX';auto); try congruence.
-  }
-  unfold SCCP, A_r ; simpl.
-  rewrite FIX'. simpl.
-  unfold is_at_Top.
-  invh AVal.ge; auto; intuition auto.
-  invh pge; auto.
-Qed.
-
-Lemma G_list_val_list_match_approx : forall f ge sp lv es args rs,
-  G_list SCCP ge sp rs (map (A_r SCCP f) args) rs ## args ->
-  DS.fixpoint f handle_instr (initial f) = (lv, es) ->
-  list_forall2 (vmatch (bctop ge)) rs ## args lv ## args.
-Proof.
-  induction args ; intros; go.
-  simpl in *. inv H.
-  econstructor; eauto.
-  unfold G, SCCP, A_r in * ; simpl in * ; rewrite H0 in * ; simpl in *.
-  apply H4; auto.
-Qed.
-
-Import SSAinv.
-Import Utils.
-  
-Lemma Iop_correct : forall (f:function) pc sf op args res pc' v rs
-                           (ge: Globalenvs.Genv.t fundef unit) sp m x,
-                    forall (WFF: wf_ssa_function f)
-                           (SINV: s_inv ge (State sf f (Values.Vptr sp Ptrofs.zero) pc rs m)),
-    (fn_code f) ! pc = Some (Iop op args res pc') ->
-    eval_operation ge (Values.Vptr sp Ptrofs.zero) op (rs ## args) m = Some v ->
-    gamma SCCP f ge (Values.Vptr sp Ptrofs.zero) pc rs ->
-    exec f pc ->
-    dsd f x pc' ->
-    G ge (Values.Vptr sp Ptrofs.zero) (rs # res <- v) (A_r SCCP f x) (rs # res <- v) !! x.
-Proof.
-  intros until x; intros WFF SINV CODE EVAL GAMMA EXE DSD.
-  destruct (peq x res).
-  - subst.
-    rewrite PMap.gss.
-    case_eq (DS.fixpoint f handle_instr (initial f)).
-    intros lv es FIX.
-    assert (AVal.ge (lv !! res) (eval_static_operation op lv ## args)).
-    { generalize FIX ; intros FIX'.
-      apply DS.post_fixpoint in FIX as [Hc _].
-      unfold DS.code_post_fixpoint in Hc.
-      eapply Hc; eauto.
-      unfold SCCP, A_e in * ; simpl in *; auto.
-      unfold exec in EXE; simpl in *.
-      rewrite FIX' in EXE. simpl in *. auto.
-    }
-    assert (vmatch (bctop ge) v (eval_static_operation op lv ## args)).
-    { exploit (all_used_approx SCCP ge f pc (Values.Vptr sp Ptrofs.zero) rs args); eauto.
-      induction args; go. intros HG_list. 
-      eapply eval_static_operation_sound; eauto.
-      - constructor; auto.
-        + intros. split; intros.
-          * simpl. flatten; try solve [unfold Genv.find_symbol in *;
-                                       apply Genv.genv_symb_range in H0; intuition].
-            -- apply Genv.find_invert_symbol in H0; congruence.
-            -- apply Genv.find_invert_symbol in H0; congruence.
-          * simpl in H0; flatten H0.
-            apply Genv.invert_find_symbol. auto.
-        + intros. simpl. flatten.
-          * split; congruence.
-          * split; congruence. 
-      - simpl. flatten.
-      - eapply G_list_val_list_match_approx; eauto.
-    }
-    eapply G_increasing; eauto.
-    replace (A_r SCCP f res) with ((fst (fixpoint f)) res) by reflexivity.
-    unfold fixpoint ; simpl; rewrite FIX; auto.
-  - exploit (dsd_pred_not_join_point f WFF pc pc' x); eauto.
-    go. 
-    intro contra. eapply fn_normalized with (pc := pc) in contra; go.
-    + unfold successors, Kildall.successors_list.
-      rewrite PTree.gmap1. unfold option_map.
-      unfold fn_code in *.
-      rewrite CODE. simpl. auto.
-    + intros [Hcase1 | [ Hcase2 | Hcase3]]; intuition auto.
-      * exploit ext_param_at_top; go.
-        intros HTOP.
-        replace (A_r SCCP f x) with ((fst (fixpoint f)) x) in * by reflexivity.
-        eapply G_top; eauto.
-      * rewrite PMap.gso; eauto.
-        exploit GAMMA; eauto.
-      * unfold fn_code in *.
-        invh assigned_code_spec; try congruence.
-Qed.
-
-Import Dom.
-Hint Resolve sdom_dom_pred fn_code_reached fn_entry_pred fn_phicode_inv
-             list_nth_z_in: core.
-Hint Unfold reached: core.
-Hint Constructors SSA.step: core.
-
-Lemma exec_step : forall prog0 ,
-                  forall ge0  t sf sp pc rs m (f0:function) s',
-   wf_ssa_function f0 ->
-   sfg_inv SCCP prog0 sf ->
-   gamma SCCP f0 ge0 sp pc rs ->
-   OptInv.exec SCCP f0 pc ->
-   step ge0 (State sf f0 sp pc rs m) t s' ->
-   match s' with
-   | State _ f1 _ pc' _ _ => OptInv.exec SCCP f1 pc'
-   | Callstate nil _ _ _ => True
-   | Callstate (Stackframe _ f2 _ pc' _ :: _) _ _ _ => OptInv.exec SCCP f2 pc'
-   | Returnstate _ _ _ => True
-   end.
-Proof.
- intros.
-    case_eq (DS.fixpoint f0 handle_instr (initial f0)); intros lv es FIX.
-    generalize H3 ; intros STEP.
-    inv H3; try solve [exploit exec_node_single_succ; go]; auto.
-    + destruct sf; auto.
-      destruct s. inv H0; go.
-    + assert (es #2 (pc, ifso) = true).
-      { generalize FIX ; intros FIX'.
-        apply DS.post_fixpoint in FIX as [_ [_ Hes]].
-        unfold DS.exec_flags_sound in *.
-        assert (Hcfg: cfg f0 pc ifso) by go.
-        destruct (classic (es !!2 (pc, ifso) = true)) as [Hcl | Hcl]; auto.
-        apply not_true_iff_false in Hcl.
-        assert (exists i, (fn_code f0) ! ifso = Some i)
-          as [i Hpc'] by (eapply fn_code_closed; go).
-        specialize (Hes pc ifso i Hcfg Hcl Hpc').
-        destruct Hes.
-        + eelim H3; eapply exec_exec_helper; eauto.
-          unfold SCCP, A_e ; simpl ; rewrite FIX'; go.
-        + flatten H12. destruct H3 as [Hso _].
-          specialize (Hso (eq_refl _)).
-          exploit (eval_static_condition_sound (bctop ge0) cond (rs## args) m (lv## args)); eauto. 
-          eapply G_list_val_list_match_approx; eauto.
-          eapply all_used_approx; eauto.
-          induction args; go.
-          intros.
-          rewrite Hso in H3 at 1. inv H3; try congruence. 
-      }
-      right. exists pc ; split; go.
-      unfold fixpoint ; rewrite FIX; simpl; auto.
-    + assert (es #2 (pc, ifnot) = true).
-      { generalize FIX ; intros FIX'.
-        apply DS.post_fixpoint in FIX as [_ [_ Hes]].
-        unfold DS.exec_flags_sound in *.
-        assert (Hcfg: cfg f0 pc ifnot) by go.
-        destruct (classic (es !!2 (pc, ifnot) = true)) as [Hcl | Hcl]; auto.
-        apply not_true_iff_false in Hcl.
-        assert (exists i, (fn_code f0) ! ifnot = Some i)
-          as [i Hpc'] by (eapply fn_code_closed; go).
-        specialize (Hes pc ifnot i Hcfg Hcl Hpc').
-        destruct Hes.
-        + eelim H3; eapply exec_exec_helper; eauto.
-          unfold SCCP, A_e ; simpl ; rewrite FIX'; go.
-        + flatten H12. destruct H3 as [_ Hifnot].
-          specialize (Hifnot (eq_refl _)).
-          exploit (eval_static_condition_sound (bctop ge0) cond (rs## args) m (lv## args)); eauto.
-          eapply G_list_val_list_match_approx; eauto.
-          eapply all_used_approx; eauto.
-          induction args; go.
-          intros. rewrite Hifnot in H3 at 1. inv H3; try congruence. 
-      }
-      right. exists pc ; split; go.
-      unfold fixpoint ; rewrite FIX; simpl; auto.
-    + assert (es #2 (pc, pc') = true).
-      { generalize FIX ; intros FIX'.
-        apply DS.post_fixpoint in FIX as [_ [_ Hes]].
-        unfold DS.exec_flags_sound in *.
-        assert (Hcfg: cfg f0 pc pc') by go.
-        destruct (classic (es !!2 (pc, pc') = true)) as [Hcl | Hcl]; auto.
-        apply not_true_iff_false in Hcl.
-        assert (exists i, (fn_code f0) ! pc' = Some i)
-          as [i Hpc'] by (eapply fn_code_closed; go).
-        specialize (Hes pc pc' i Hcfg Hcl Hpc').
-        destruct Hes.
-        + eelim H3; eapply exec_exec_helper; eauto.
-          unfold SCCP, A_e ; simpl ; rewrite FIX'; go.
-        + flatten H12. destruct H3 as [n0 [Hlv Hlistnth]].
-          assert (n0 = n).
-          {
-            assert (vmatch (bctop ge0) rs !! arg  lv !! arg).
-            exploit used_match_approx; eauto.
-            econstructor 10; eauto. intros.
-            unfold G, SCCP, A_r in * ; simpl in *; auto.
-            rewrite FIX' in *. simpl in *. go.
-            rewrite Hlv in H3 at 1.
-            rewrite H13 in H3 at 1.
-            inv H3. auto. 
-          }
-          subst.
-          congruence.
-      }
-      right. exists pc ; split; go.
-      unfold fixpoint ; rewrite FIX; simpl; auto.
-Unshelve.
-all: go. 
-Qed.
-
-(** * Structural properties. Helpers *)
-
-Lemma new_code_same_or_Iop :
-  forall (f:function) (Hwf: wf_ssa_function f) pc ins,
-    (fn_code f) ! pc = Some ins ->
-    transf_instr (fst (fixpoint f)) pc ins = ins
-    \/ match ins with
-       | Iop _ _ dst pc'
-       | Iload _ _ _ dst pc'
-       | Icall _ _ _ dst pc'
-       | Ibuiltin _ _ (BR dst) pc' =>
-         exists op' args',
-         transf_instr (fst (fixpoint f)) pc ins = Iop op' args' dst pc'
-         /\ forall x, In x args' -> exists d : node, def f x d /\ SSA.sdom f d pc
-       | _ => False
-       end.
-Proof.
-  destruct ins; simpl; flatten; eauto; right.
-  exists o0; exists nil;
-    split; auto;
-      intros x Hin; inv Hin.
-Qed.
-
-Lemma join_point_transf_function :
-  forall (f:function) (Hwf: wf_ssa_function f) j,
-    join_point j (transf_function f) <-> join_point j f.
-Proof.
-  intros.
-  eapply Opt.join_point_transf_function; eauto.
-  eapply new_code_same_or_Iop; eauto.
-Qed.
-
-Lemma make_predecessors_transf_function: forall (f:function) (Hwf: wf_ssa_function f),
-  (Kildall.make_predecessors (fn_code (transf_function f)) successors_instr) =
-  (Kildall.make_predecessors (fn_code f) successors_instr).
-Proof.
-  intros.
-  eapply Opt.make_predecessors_transf_function; eauto.
-  eapply new_code_same_or_Iop; eauto.
-Qed.
-
-End AuxResults.
diff --git a/midend/SCCPoptproof.v b/midend/SCCPoptproof.v
deleted file mode 100644
index 5bf2f57a..00000000
--- a/midend/SCCPoptproof.v
+++ /dev/null
@@ -1,450 +0,0 @@
-Require Import Coqlib.
-Require Import Maps.
-Require Import Maps2.
-Require Import AST.
-Require Import Op.
-Require Import Utils.
-Require Import Integers.
-Require Import Floats.
-Require Import Classical.
-Require Import Dom.
-Require Import SSA.
-Require Import SSAutils.
-Require Import Smallstep.
-Require Import Globalenvs.
-Require Import Values.
-Require Import Events.
-Require Import SCCPopt.
-Require Import ConstpropOp.
-Require Import DLib.
-Require Import Utilsvalidproof.
-Require Import KildallComp.
-Require Import Dsd.
-Require Import Relations.
-Require Import SSAinv.
-Require Import OptInv.
-Require Import SCCPopt.
-Require Import SCCPoptProp.
-Require Import Registers.
-Require Import Linking.
-Unset Allow StrictProp.
-
-(** Correctness proof of the SCCP optimization *)
-
-Section PRESERVATION.
-
-  Definition match_prog (p: SSA.program) (tp: SSA.program) :=
-    match_program (fun cu f tf => tf = transf_fundef f) eq p tp.
-
-  Lemma transf_program_match:
-    forall p, match_prog p (transf_program p).
-  Proof.
-    intros; subst.
-    eapply match_transform_program_contextual; auto.
-  Qed.
-
-  Section CORRECTNESS.
-    
-    Hint Unfold exec: core.
-    
-    Variable prog: program.
-    Variable tprog: program.
-    Hypothesis TRANSL: match_prog prog tprog.
-    Hypothesis HWF: wf_ssa_program prog.
-
-    Definition ge := Genv.globalenv prog.
-    Definition tge := Genv.globalenv tprog.
-
-    Lemma same_symbols: forall s,
-        Genv.find_symbol tge s = Genv.find_symbol ge s.
-    Proof.
-      eapply Genv.find_symbol_transf; eauto.
-    Qed.
-
-    Lemma match_prog_wf_ssa : wf_ssa_program tprog.
-    Proof.
-      red. intros.
-      red in  HWF.
-      inv TRANSL.
-      intuition. revert H0 H HWF.
-      induction 1; intros.
-      - inv H.
-      - inv H1.      
-        + inv H. inv H4.
-          destruct f1 ; simpl in * ; try constructor; auto.
-          eapply Opt.transf_function_preserve_wf_ssa_function; eauto.
-          * eapply new_code_same_or_Iop; eauto.
-          * exploit (HWF (Internal f) id); eauto.
-            destruct a1, g; simpl in * ; try congruence. 
-            left. inv H; simpl in *; auto. 
-            intros. inv H4; auto.
-        + eapply IHlist_forall2; eauto.
-    Qed.
-
-    Lemma funct_ptr_translated:
-      forall (b: Values.block) (f: fundef),
-        Genv.find_funct_ptr ge b = Some f ->
-        Genv.find_funct_ptr tge b = Some (transf_fundef f).
-    Proof.
-      eapply Genv.find_funct_ptr_transf ; eauto. 
-    Qed.
-
-    Lemma functions_translated:
-      forall (v: val) (f: fundef),
-        Genv.find_funct ge v = Some f ->
-        Genv.find_funct tge v = Some (transf_fundef f).
-    Proof.
-      eapply Genv.find_funct_transf ; eauto.
-    Qed.
-
-    Lemma sig_preserved:
-      forall f, funsig (transf_fundef f) = funsig f.
-    Proof.
-      destruct f;  simpl ; try reflexivity.
-    Qed.
-
-    Lemma transf_ros_correct:
-      forall ros rs f,
-        find_function ge ros rs = Some f ->
-        find_function tge ros rs = Some (transf_fundef f).
-    Proof.
-      intros.
-      unfold find_function in *.
-      destruct ros; simpl.
-      exploit functions_translated; eauto.
-      flatten; rewrite same_symbols in *;
-        rewrite Eq in *; eauto using funct_ptr_translated.
-      inv H.
-    Qed.
-
-    Lemma same_eval_addressing: forall sp addr rs args,
-        eval_addressing tge sp addr rs ## args = eval_addressing ge sp addr rs ## args.
-    Proof.
-      intros.
-      unfold eval_addressing;
-        try (unfold eval_addressing32, eval_addressing64);
-        unfold Genv.symbol_address.
-      flatten; rewrite <- same_symbols in *; eauto; flatten.
-    Qed.
-
-    Hint Resolve same_symbols: core.
-
-    Lemma same_eval: forall sp op rs args m,
-        eval_operation tge sp op rs ## args m = eval_operation ge sp op rs ## args m.
-    Proof.
-      intros.
-      unfold eval_operation;
-        try unfold eval_addressing32, eval_addressing64;
-        unfold Genv.symbol_address.
-      flatten;
-        match goal with
-        | id: Genv.find_symbol _ _ = _ |- _ =>
-          rewrite same_symbols in id ; try congruence
-        end.
-    Qed.
-
-    Lemma senv_equiv : Senv.equiv ge tge.
-    Proof.
-      apply (Genv.senv_transf TRANSL).
-    Qed.
-
-    (** * Simulation relation *)
-    Inductive match_stackframes : list stackframe -> list stackframe -> Prop :=
-    | match_stackframes_nil: match_stackframes nil nil
-    | match_stackframes_cons:
-        forall res f sp pc rs s st b
-               (SP: sp = (Vptr b Ptrofs.zero))
-               (STACK: (match_stackframes s st))
-               (WFF: wf_ssa_function f)
-               (HG:forall v, gamma SCCP f ge sp pc (rs# res <- v))
-               (EXE: exec f pc),
-          match_stackframes
-            ((Stackframe res f sp pc rs) :: s)
-            ((Stackframe res (transf_function f) sp pc rs) :: st).
-
-    Variant match_states: SSA.state -> SSA.state -> Prop :=
-    | match_states_intro:
-        forall s st sp pc rs m f b
-               (SP: sp = (Vptr b Ptrofs.zero))
-               (SINV:s_inv ge (State s f sp pc rs m))
-               (HG:gamma SCCP f ge sp pc rs)
-               (EXE: exec f pc)
-               (STACK: match_stackframes s st),
-          match_states (State s f sp pc rs m) (State st (transf_function f) sp pc rs m)
-    | match_states_call:
-        forall s st f args m
-               (SINV:s_inv ge (Callstate s f args m))
-               (STACK: match_stackframes s st),
-          match_states (Callstate s f args m) (Callstate st (transf_fundef f) args m)
-    | match_states_return:
-        forall s st v m
-               (SINV:s_inv ge (Returnstate s v m))
-               (STACK: match_stackframes s st),
-          match_states (Returnstate s v m) (Returnstate st v m).
-    
-    Hint Resolve sdom_dom_pred fn_code_reached fn_entry_pred
-         fn_phicode_inv list_nth_z_in: core.
-    Hint Constructors clos_refl_trans SSA.step: core.
-    
-    Lemma match_stackframes_sfg_inv : forall s st,
-        match_stackframes s st ->
-        sfg_inv SCCP prog s.
-    Proof.
-      induction 1 ; go.
-    Qed.
-
-    Lemma transf_initial_states:
-      forall st1, SSA.initial_state prog st1 ->
-                  exists st2, SSA.initial_state tprog st2 /\ match_states st1 st2.
-    Proof.
-      intros. inversion H.
-      exploit @funct_ptr_translated ; eauto. intros. 
-      econstructor; split.
-      - econstructor.
-        assert (MEM: (Genv.init_mem tprog) = Some m0) by (eapply (Genv.init_mem_transf TRANSL); eauto).
-        + apply MEM ; auto.
-        + replace (prog_main tprog) with (prog_main prog). rewrite same_symbols; eauto.
-          symmetry; eapply match_program_main; eauto.
-        + eauto.
-        + rewrite <- H3. apply sig_preserved; auto.
-      - eapply match_states_call  ; eauto.
-        + constructor.
-          eapply Genv.find_funct_ptr_prop ; eauto.
-          constructor.
-        + constructor.
-    Qed.
-
-    Lemma transf_final_states:
-      forall st1 st2 r,
-        match_states st1 st2 -> SSA.final_state st1 r -> SSA.final_state st2 r.
-    Proof.
-      intros. inv H0. inv H. 
-      inv STACK.
-      constructor.
-    Qed.
-    
-    (** * Soundness invariant of the analysis *)
-    Lemma subj_red_gamma : forall prog (WFP: wf_ssa_program prog),
-        forall (f f':function) (HWF : wf_ssa_function f)
-               t m m' rs rs' sp sp' pc pc' s s',
-          gamma SCCP f (Genv.globalenv prog) (Vptr sp Ptrofs.zero) pc rs ->
-          sfg_inv SCCP prog s ->
-          exec f pc ->
-          s_inv (Genv.globalenv prog) (State s f (Vptr sp Ptrofs.zero) pc rs m) ->
-          SSA.step (Genv.globalenv prog) (State s f (Vptr sp Ptrofs.zero) pc rs m) t
-                       (State s' f' (Vptr sp' Ptrofs.zero) pc' rs' m') ->
-          gamma SCCP f' (Genv.globalenv prog) (Vptr sp' Ptrofs.zero) pc' rs'.
-    Proof.
-      intros. 
-      eapply subj_red_gamma; eauto.
-      - intros; eapply same_fn_code1; eauto.
-      - intros; eapply Iop_correct; eauto.
-      - intros; eapply step_phi_aux; eauto.
-      - intros; eapply exec_step; eauto.
-    Qed. 
-
-    Hint Resolve match_stackframes_sfg_inv
-         subj_red subj_red_gamma: core.
-    
-    Ltac match_go :=
-      match goal with
-      | id: SSA.step _ _ _ _ |- match_states _ _  =>
-        econstructor; eauto ; [eapply SSAinv.subj_red; eauto
-                              | eapply subj_red_gamma; eauto
-                              | eapply exec_step in id; eauto]
-      end.
-
-    Ltac TransfInstr :=
-      match goal with
-      | f : function,
-            id: (fn_code _)! ?pc = Some ?instr |- _ =>
-        case_eq (DS.fixpoint f handle_instr (initial f)) ;
-        intros lv es FIX;
-        set (lv' := fun reg => PMap.get reg lv) in * ;
-        try assert ((fn_code (transf_function f)) !pc = Some(transf_instr lv' pc instr))
-          by (unfold transf_function, Opt.transf_function, fn_code;
-              simpl; rewrite PTree.gmap; try rewrite FIX;
-              unfold option_map; destruct f ; simpl in *;
-              flatten ; reflexivity);
-        simpl transf_instr in *
-      end.
-
-    Hint Extern 1 (wf_ssa_function _) => invh s_inv: core.
-    
-    Lemma transf_step_correct:
-      forall s1 t s2,
-        SSA.step ge s1 t s2 ->
-        SSA.step ge s1 t s2 ->
-        forall s1' (MS: match_states s1 s1'),
-        exists s2', SSA.step tge s1' t s2' /\ match_states s2 s2'.
-    Proof.
-      intros s1 t s2.
-
-      induction 1; intros; inv MS; auto.
-
-      (* Inop *)
-      - exists (State st (transf_function f) (Vptr b Ptrofs.zero) pc' rs m).
-        split; try match_go.
-        TransfInstr.
-        eapply exec_Inop_njp; eauto.
-        intro Hcont.
-        erewrite join_point_transf_function in Hcont ; go.
-          
-      (* Inop phi *)
-      - exists (State st (transf_function f) (Vptr b Ptrofs.zero) pc' (phi_store k phib rs) m).
-        split; try match_go.
-        TransfInstr.
-        eapply exec_Inop_jp; eauto.
-        erewrite join_point_transf_function; go.
-        rewrite make_predecessors_transf_function; auto.
-        
-      (* Iop *)
-      - exists (State st (transf_function f) (Vptr b Ptrofs.zero) pc' rs # res <- v m).
-        split; try match_go.        
-        TransfInstr.
-
-        assert ((fn_code (transf_function f)) !pc = Some(transf_instr lv' pc (Iop op args res pc'))).
-        { unfold transf_function, transf_instr, Opt.transf_function.
-          simpl; rewrite PTree.gmap; try rewrite FIX. simpl.
-          unfold option_map; unfold transf_instr ; destruct f ; simpl in *; flatten;
-            (replace (lv## args) with (map lv' args)
-              in Eq1 at 1 by (induction args; go));
-            rewrite Eq1 in Eq2 at 1; congruence.
-        }
-        simpl transf_instr in *.
-        flatten H2; try ( eapply exec_Iop; eauto; rewrite same_eval; auto).
-        exploit (ValueAOpSSA.eval_static_operation_sound (bctop ge) ge); eauto.
-        + constructor.
-          * intros. split; intros.
-            -- simpl. flatten; try solve [unfold Genv.find_symbol in *;
-                                          apply Genv.genv_symb_range in H3  ; intuition].
-               ++ apply Genv.find_invert_symbol in H3; congruence.
-               ++ apply Genv.find_invert_symbol in H3; congruence.
-            -- simpl in H3. flatten H3.
-               apply Genv.invert_find_symbol. auto.
-          * intros. simpl. flatten.
-            -- split; congruence.
-            -- split; congruence. 
-        + simpl. flatten. 
-        + eapply G_list_val_list_match_approx; eauto.
-          eapply gamma_v_args; eauto.
-        + intros.
-          (replace (lv## args) with (map (fun r : reg => lv' r) args)
-            in H3 at 1 by (induction args; go)).
-          unfold const_for_result in *. flatten Eq; inv H3; auto.  
-                                                              
-      - exists (State st (transf_function f) (Vptr b Ptrofs.zero) pc' rs # dst <- v m).
-        split; try match_go.
-        TransfInstr.
-        eapply exec_Iload; eauto;
-        try (rewrite same_eval_addressing; auto).
-        
-      - exists (State st (transf_function f) (Vptr b Ptrofs.zero) pc' rs m').
-        split; try match_go.
-        TransfInstr.
-        eapply exec_Istore; eauto;
-          try (rewrite same_eval_addressing; auto).
-
-      - exists (Callstate (Stackframe res (transf_function f) (Vptr b Ptrofs.zero) pc' rs::st)
-                          (transf_fundef fd) rs ## args m); split.
-        + TransfInstr; intros.
-      eapply exec_Icall; eauto.
-      rewrite transf_ros_correct with (f := fd); eauto.
-      unfold funsig, transf_fundef.
-      destruct fd; simpl; eauto.
-
-      + econstructor; eauto.
-        * eapply SSAinv.subj_red; eauto.
-        * econstructor; eauto.
-          -- intros v x Hyp1 Hyp2.
-             destruct (peq x res).
-             ++ subst. exploit (same_fn_code1 f pc); go.
-                eapply G_top; eauto.
-             ++ rewrite PMap.gso; auto.
-                exploit (HG x); eauto.
-                destruct dsd_pred_njp with f pc pc' x as
-                    [[Dx Dx']|[[Dx [Dx' Dx'']]|[Dx Dx']]]; simplify_dsd; eauto.
-                go.
-                intro; subst; exploit fn_entry; eauto; intros (succ' & Hscucc); congruence.
-                go.
-                eelim ssa_not_Inop_not_phi; eauto; go.
-          -- eapply exec_step in H2; eauto.
-
-      - exists (Callstate st (transf_fundef fd) rs ## args m'); split; try match_go.
-        + TransfInstr; intros.
-      eapply exec_Itailcall; eauto.
-      rewrite transf_ros_correct with (f := fd); eauto.
-      unfold funsig, transf_fundef.
-      destruct fd; simpl; eauto; unfold transf_function.
-
-      + econstructor; eauto.
-        eapply SSAinv.subj_red; eauto.
-
-      - exists (State st (transf_function f) (Vptr b Ptrofs.zero) pc' (regmap_setres res vres rs) m').
-        split; try match_go.
-        TransfInstr.
-        eapply exec_Ibuiltin with (vargs:= vargs); eauto.
-        eapply eval_builtin_args_preserved; eauto.
-        eapply external_call_symbols_preserved; eauto.
-        apply senv_equiv.
-        
-      - exists (State st (transf_function f) (Vptr b Ptrofs.zero) ifso rs m).
-        split; try match_go.
-        TransfInstr. eapply exec_Icond_true; eauto.
-        
-      - exists (State st (transf_function f) (Vptr b Ptrofs.zero) ifnot rs m).
-        split; try match_go.
-        TransfInstr. eapply exec_Icond_false; eauto.
-
-      - exists (State st (transf_function f) (Vptr b Ptrofs.zero) pc' rs m).
-        split; try match_go.
-        TransfInstr. eapply exec_Ijumptable; eauto.
-
-      - exists (Returnstate st (regmap_optget or Vundef rs) m'); split; try match_go.
-        + TransfInstr.
-          econstructor; eauto.
-
-        + econstructor; eauto.
-          eapply SSAinv.subj_red; eauto.
-
-      - exists (State st (transf_function f) (Vptr stk Ptrofs.zero)
-                      (fn_entrypoint (transf_function f))
-                      (init_regs args (fn_params (transf_function f))) m');
-          split; try match_go.
-        + econstructor; eauto.
-        + replace (fn_entrypoint (transf_function f)) with (fn_entrypoint f);
-            [|compute; reflexivity].
-          replace (fn_params (transf_function f)) with (fn_params f);
-            [|compute; reflexivity].
-          econstructor; eauto.
-          * eapply SSAinv.subj_red; eauto.
-          * eapply gamma_entry; eauto.
-            invh s_inv. invh wf_ssa_fundef; auto.
-          * go.
-          
-      - exists (Returnstate st res m'); split.
-        + econstructor; eauto.
-          eapply external_call_symbols_preserved; eauto.
-          apply senv_equiv.
-        + econstructor; eauto.
-          eapply SSAinv.subj_red; eauto.
-
-      - inv STACK.
-        exists (State st0 (transf_function f) (Vptr b Ptrofs.zero) pc rs # res <- vres m); split; go.
-        econstructor; eauto.
-        eapply SSAinv.subj_red; eauto.
-    Qed.
-    
-    Theorem transf_program_correct:
-      forward_simulation (SSA.semantics prog) (SSA.semantics tprog).
-    Proof.
-      eapply forward_simulation_step.
-      eapply senv_equiv.
-      eexact transf_initial_states.
-      eexact transf_final_states.
-      intros; eapply transf_step_correct; eauto.
-    Qed.
-
-  End CORRECTNESS.
-        
-End PRESERVATION.
diff --git a/midend/SSA.v b/midend/SSA.v
index d0dea760..d50ed850 100644
--- a/midend/SSA.v
+++ b/midend/SSA.v
@@ -29,6 +29,7 @@ Require Import Relations.Relation_Definitions.
 Require Import DLib.
 Require Import Dom.
 Require Import Utils.
+Require Import PointerOp Simulation.
 
 Unset Allow StrictProp.
 
@@ -239,13 +240,37 @@ Variant state : Type :=
              (m: mem),                (**r memory state *)
       state.
 
+Definition ros_to_vos (m: Mem.mem) (ros: reg + ident) (rs: regset) : val + ident :=
+  match ros with
+  | inl r => match rs#r with
+            | Vint n => if negb Archi.ptr64
+                       then (match Mem.to_ptr (Vint n) m with
+                             | Some v' => inl v'
+                             | None => inl rs#r
+                             end)
+                       else inl rs#r
+            | Vlong n => if Archi.ptr64
+                        then (match Mem.to_ptr (Vlong n) m with
+                              | Some v' => inl v'
+                              | None => inl rs#r
+                              end)
+                        else inl rs#r
+            (* | Vptr b ofs => match (Mem.mem_access m) # b (Ptrofs.unsigned ofs) Max with *)
+            (*                | Some p => (inl (Vptr b ofs)) *)
+            (*                | _ => inl (Vnullptr) (* fix: option type needed *) *)
+                           (* end *)
+            | _ => inl rs#r
+            end
+  | inr symb => inr symb
+  end.
+
 Section RELSEM.
 
 Variable ge: genv.
 
-Definition find_function (ros: reg + ident) (rs: regset) : option fundef :=
+Definition find_function (ros: val + ident) (rs: regset) : option fundef :=
       match ros with
-        | inl r => Genv.find_funct ge (rs # r)
+        | inl r => Genv.find_funct ge r
         | inr symb =>
           match Genv.find_symbol ge symb with
             | None => None
@@ -289,7 +314,7 @@ Inductive step: state -> trace -> state -> Prop :=
 | exec_Iop:
   forall s f sp pc rs m op args res pc' v,
     (fn_code f)!pc = Some(Iop op args res pc') ->
-    eval_operation ge sp op rs## args m = Some v ->
+    eval_operation_wrapper ge sp op rs## args m = Some v ->
     step (State s f sp pc rs m)
     E0 (State s f sp pc' (rs#res <- v) m)
 | exec_Iload:
@@ -309,14 +334,14 @@ Inductive step: state -> trace -> state -> Prop :=
 | exec_Icall:
   forall s f sp pc rs m sig ros args res pc' fd,
     (fn_code f)!pc = Some(Icall sig ros args res pc') ->
-    find_function ros rs = Some fd ->
+    find_function (ros_to_vos m ros rs) rs = Some fd ->
     funsig fd = sig ->
     step (State s f sp pc rs m)
     E0 (Callstate (Stackframe res f sp pc' rs :: s) fd rs## args m)
 | exec_Itailcall:
   forall s f stk pc rs m sig ros args fd m',
     (fn_code f)!pc = Some(Itailcall sig ros args) ->
-    find_function ros rs = Some fd ->
+    find_function (ros_to_vos m ros rs) rs = Some fd ->
     funsig fd = sig ->
     Mem.free m stk 0 f.(fn_stacksize) = Some m' ->
     step (State s f (Vptr stk (Ptrofs.zero)) pc rs m)
@@ -331,13 +356,13 @@ Inductive step: state -> trace -> state -> Prop :=
 | exec_Icond_true:
   forall s f sp pc rs m cond args ifso ifnot,
     (fn_code f)!pc = Some(Icond cond args ifso ifnot) ->
-    eval_condition cond rs## args m = Some true ->
+    eval_condition_wrapper cond rs## args m = Some true ->
     step (State s f sp pc rs m)
     E0 (State s f sp ifso rs m)
 | exec_Icond_false:
   forall s f sp pc rs m cond args ifso ifnot,
     (fn_code f)!pc = Some(Icond cond args ifso ifnot) ->
-    eval_condition cond rs## args m = Some false ->
+    eval_condition_wrapper cond rs## args m = Some false ->
     step (State s f sp pc rs m)
     E0 (State s f sp ifnot rs m)
 | exec_Ijumptable:
@@ -391,15 +416,58 @@ Variant initial_state (p: program): state -> Prop :=
       funsig f = signature_main ->
       initial_state p (Callstate nil f nil m0).
 
+Inductive glob_capture (p: program) : state -> state -> Prop :=
+  | glob_capture_intro
+      f m pbs m'
+      (* (INIT: initial_state p (Callstate nil f nil m)) *)
+      (NONSTATIC: Genv.non_static_glob (Genv.globalenv p) (Genv.genv_public (Genv.globalenv p)) = pbs)
+      (CAPTURE: Genv.capture_init_mem m pbs m') :
+    glob_capture p (Callstate nil f nil m) (Callstate nil f nil m').
+
 (** A final state is a [Returnstate] with an empty call stack. *)
 
 Variant final_state: state -> int -> Prop :=
   | final_state_intro: forall r m, final_state (Returnstate nil (Vint r) m) r.
 
+(** Non-deterministic external state *)
+
+(** A external state *)
+
+Definition is_external (ge:genv) (s:state) : Prop :=
+  match s with
+  | Callstate stk fd vargs m =>
+    match fd with
+    | External ef => is_external_ef ef
+    | _ => False
+    end
+  | State cs f sp pc rs m =>
+    match (fn_code f)!pc with
+    | Some (Ibuiltin ef args res pc') => is_external_ef ef
+    | _ => False
+    end
+  | _ => False
+  end.
+
+Definition state_mem (st: state) : mem :=
+  match st with
+  | State _ _ _ _ _ m => m
+  | Callstate _ _ _ m => m
+  | Returnstate _ _ m => m
+  end.
+
+Definition concrete_snapshot (ge: Senv.t) (st: state) (id: ident) : option Z :=
+  if Senv.public_symbol ge id
+  then (match Senv.find_symbol ge id with
+        | Some b => Maps.PTree.get b (state_mem st).(Mem.mem_concrete)
+        | None => None
+        end
+    )
+  else None.
+
 (** The small-step semantics for a program. *)
 
 Definition semantics (p: program) :=
-  Semantics step (initial_state p) final_state (Genv.globalenv p).
+  Semantics step (initial_state p) (glob_capture p) (concrete_snapshot (Genv.globalenv p)) final_state is_external (Genv.globalenv p).
 
 (** * Use and definition of registers *)
 Section UDEF.
diff --git a/midend/SSAD.v b/midend/SSAD.v
new file mode 100644
index 00000000..9e71bd26
--- /dev/null
+++ b/midend/SSAD.v
@@ -0,0 +1,283 @@
+Require Import Coqlib CoqlibC Events.
+Require Import Memory Globalenvs Smallstep Simulation.
+Require Import sflib SSA.
+
+(** Determinacy *)
+
+Lemma semantics_single_events p s (INT: ~ is_external (Genv.globalenv p) s): single_events_at (SSA.semantics p) s.
+Proof.
+  red. intros. inv H; (try (exploit external_call_trace_length; eauto; intro T)); simpl; try lia; ss.
+  des_ifs.
+Qed.
+
+(* Definition ev_rel_eq (ev1 ev2: event) : Prop := ev1 = ev2. *)
+
+(* Definition ev_rel (p:program) (st: Smallstep.state (semantics p)) (ev1 ev2: event) : Prop := *)
+(*     let ge := Genv.globalenv p in *)
+(*     event_rel (eventval_bind ge (state_mem st)) ev1 ev2. *)
+    (* match st with *)
+    (* | State _ _ _ _ _ m => event_rel (eventval_bind ge m) ev1 ev2 *)
+    (* | Callstate _ _ _ m => event_rel (eventval_bind ge m) ev1 ev2 *)
+    (* | Returnstate _ _ m => event_rel (eventval_bind ge m) ev1 ev2 *)
+    (* end. *)
+
+Definition ge_binded_state (ge: genv) (st: state) (gm: positive -> option Z) : Prop :=
+  ge_binded ge (state_mem st) gm.
+
+Lemma ge_binded_state_step
+    ge st st' tr gm
+    (BIND: ge_binded_state ge st gm)
+    (STEP: step ge st tr st'):
+  ge_binded_state ge st' gm.
+Proof.
+  inv STEP; ss.
+  - unfold Mem.storev in H1. des_ifs; eapply ge_binded_store; eauto; ss.
+  - eapply ge_binded_free; eauto.
+  - eapply ge_binded_external_call; eauto.
+  - eapply ge_binded_free; eauto.
+  - eapply ge_binded_alloc; eauto.
+  - eapply ge_binded_external_call; eauto.
+Qed.
+
+(*   sem_ev_rel (semantics p) (state_event_rel p). *)
+
+(* Lemma ssa_init_ge_bind *)
+(*   (INIT: initial_state p s) *)
+(*   (ICAP: glob_capture s s'): *)
+(*   ge_binded (Genv.globalenv p)  *)
+Lemma semantics_determinate_at:
+  forall (p: program) s (INT: ~ is_external (Genv.globalenv p) s),
+    deterministic_at (semantics p) s.
+Proof.
+  intros. constructor; simpl; intros.
+  - (* determinacy *)
+    inv STEP0; inv STEP1; Eq;
+      try (split; [apply match_traces_E0| intro;auto]);
+      try (elim H; simpl; try rewrite H2; auto);ss.
+    + ss. des_ifs.
+      determ_tac eval_builtin_args_determ.
+      determ_tac external_call_determ.
+    + ss. 
+      determ_tac external_call_determ.
+  - inv FINAL; inv STEP.
+  - ii. eapply semantics_single_events; eauto.
+Qed.
+
+Lemma semantics_determinate_at2:
+  forall (p: program) s (INT: ~ is_external (Genv.globalenv p) s),
+    deterministic_at (semantics p) s.
+Proof.
+  intros. constructor; simpl; intros.
+  - (* determinacy *)
+    inv STEP0; inv STEP1; Eq;
+      try (split; [apply match_traces_E0| intro;auto]);
+      try (elim H; simpl; try rewrite H2; auto);ss.
+    + ss. des_ifs.
+      determ_tac eval_builtin_args_determ.
+      determ_tac external_call_determ.
+    + ss. 
+      determ_tac external_call_determ.
+  - inv FINAL; inv STEP.
+  - ii. eapply semantics_single_events; eauto.
+Qed.
+
+Lemma semantics_receptive_at:
+  forall (p: program) s (INT: ~ is_external (Genv.globalenv p) s), receptive_at (semantics p) s.
+Proof.
+  intros. constructor; simpl; intros.
+(* receptiveness *)
+- assert (t1 = E0 -> exists s2, step (Genv.globalenv p) s t2 s2).
+    intros. subst. inv H0. exists s1; auto.
+  inversion H; subst; auto.
++ ss. des_ifs.
+  exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
+  esplits; eauto. eapply exec_Ibuiltin; eauto.
++ exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
+  esplits; eauto. econstructor; eauto.
+(* trace length *)
+- red; intros; inv H; simpl; try lia; ss; des_ifs.
+  eapply external_call_trace_length; eauto.
+  eapply external_call_trace_length; eauto.
+Qed.
+
+Lemma initial_state_determ: forall p st0 st1,
+    Smallstep.initial_state (semantics p) st0 ->
+    Smallstep.initial_state (semantics p) st1 -> st0 = st1.
+Proof.
+  intros. inv H; inv H0. subst ge0 ge. Eq.
+Qed.
+
+Theorem final_state_determ: forall p st0 retv,
+    Smallstep.final_state (semantics p) st0 retv ->
+    Dfinal_state (semantics p) st0 retv.
+Proof.
+  econstructor; eauto.
+  - intros. inv FINAL0; inv FINAL1. auto.
+  - red. unfold not. intros. inv FINAL; inv H0.
+Qed.
+
+Ltac DStep_tac := esplit; [(eapply semantics_determinate_at; simpl in *; eauto; des_ifs)|].
+
+Ltac DStep_tac2 := esplit; [(eapply semantics_determinate_at2; simpl in *; eauto; des_ifs)|].
+
+Section INITBIND.
+
+Variable p: program.
+Definition sem := SSA.semantics p.
+Variables st st1: sem.(Smallstep.state).
+Hypothesis ICAP: sem.(Smallstep.initial_capture) st st1.
+Definition ge := sem.(globalenv).
+
+Lemma initial_capture_binded:
+  ge_binded_state ge st1 (concrete_snapshot ge st1).
+Proof.
+  inv ICAP. inv CAPTURE. ii. unfold ge in *. ss.
+  unfold Genv.public_symbol in H. erewrite H0 in H.
+  assert (In b (Genv.non_static_glob (Genv.globalenv p) (Genv.genv_public (Genv.globalenv p)))).
+  { assert (In id (Genv.genv_public (Genv.globalenv p))).
+    { remember (Genv.genv_public (Genv.globalenv p)) as l. clear - H.
+      ginduction l; ss; ii. des_ifs; eauto. }
+    (* unfold Genv.non_static_glob, Genv.public_symbol. *)
+    remember (Genv.genv_public (Genv.globalenv p)) as l.
+    assert (Genv.public_symbol (Genv.globalenv p) id = true).
+    { unfold Genv.public_symbol. des_ifs. }
+    clear Heql H CAP.
+    induction l; ss. des; subst; eauto.
+    - rewrite H0. ss. des_ifs.
+    - exploit IHl; eauto. i. des_ifs; ss. right. eauto. }
+  unfold concrete_snapshot. ss. unfold Genv.public_symbol. erewrite H0, H. ss. split; eauto.
+  remember (Genv.non_static_glob (Genv.globalenv p) (Genv.genv_public (Genv.globalenv p))) as l.
+  clear -CAP H1. exploit Mem.capture_list_concrete; eauto. i. des. esplits; eauto.
+Qed.
+(* Definition ev_rel (p: program) (st_init_tgt:  Smallstep.state (semantics p)) : event -> event -> Prop := *)
+  
+End INITBIND.
+
+Section FUNCPERM.
+
+
+Variable p: program.
+Let ge := Genv.globalenv p.
+
+Definition mem_char (m: mem) :=
+  forall b fd, Genv.find_funct_ptr ge b = Some fd ->
+  Mem.perm m b 0 Max Nonempty
+  /\ (forall ofs k p, Mem.perm m b ofs k p -> ofs = 0 /\ p = Nonempty).
+
+Lemma capture_mem_char
+    m b addr m'
+    (CHAR: mem_char m)
+    (CAP: Mem.capture m b addr m'):
+  mem_char m'.
+Proof.
+  unfold mem_char in *. i. exploit CHAR; eauto. i. des. split.
+  - erewrite <- Genv.capture_same_perm; eauto.
+  - i. eapply H1. erewrite Genv.capture_same_perm; eauto.
+Qed.
+
+Lemma capture_list_mem_char
+    m bs addrs m'
+    (CHAR: mem_char m)
+    (CAP: Mem.capture_list m bs addrs m'):
+  mem_char m'.
+Proof.
+  ginduction bs; i.
+  { inv CAP. eauto. }
+  inv CAP. hexploit capture_mem_char; eauto.
+Qed.
+
+Definition state_char (s: state) : Prop :=
+  mem_char (state_mem s).
+
+Lemma init_mem_mem_char
+    m
+    (INIT: Genv.init_mem p = Some m):
+  mem_char m.
+Proof.
+  r. i. exploit Genv.init_mem_characterization_2; eauto. i. des; split; eauto.
+  eapply Mem.perm_max. eauto.
+Qed.
+
+Lemma initial_state_char
+    s
+    (INIT: initial_state p s):
+  state_char s.
+Proof.
+  inv INIT. ss. r. ss. eapply init_mem_mem_char; eauto.
+Qed.
+
+Lemma glob_capture_char
+    s s'
+    (CHAR: state_char s)
+    (GCAP: glob_capture p s s'):
+  state_char s'.
+Proof.
+  inv GCAP. inv CAPTURE. unfold state_char in *. ss.
+  eapply capture_list_mem_char; eauto.
+Qed.
+(* Lemma xxx *)
+(*   ef ge vargs m1 t vres m2 *)
+(*   (A: external_call ef ge vargs m1 t vres m2) *)
+(*   (B: Mem.valid_block m1 b) -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p *)
+
+Lemma state_char_preservation
+    s s' tr
+    (CHAR: state_char s)
+    (STEP: step ge s tr s'):
+  state_char s'.
+Proof.
+  Local Transparent Mem.free.
+  inv STEP; ss; unfold state_char in *; ss.
+  - r. i. exploit CHAR; eauto. i. des. split.
+    { unfold Mem.storev in H1. des_ifs; eapply Mem.perm_store_1; eauto. }
+    i. unfold Mem.storev in H1. des_ifs; eapply H4; eapply Mem.perm_store_2; eauto.
+  - r. i. exploit CHAR; eauto. i. des. split.
+    2:{ i. eapply H4. eapply Mem.perm_free_3; eauto. }
+    hexploit Mem.free_range_perm; eauto. intros FPERM.
+    destruct (classic ((fn_stacksize f) > 0)); cycle 1.
+    { eapply Mem.perm_free_1; eauto. }
+    destruct (peq b stk); cycle 1.
+    { eapply Mem.perm_free_1; eauto. }
+    subst. specialize (FPERM 0). exploit FPERM; try lia. i.
+    eapply H4 in H6. des; clarify.
+  - r. i. exploit CHAR; eauto. i. des. split; cycle 1.
+    { i. eapply H4. instantiate (1:=Max).
+      eapply external_call_max_perm; eauto.
+      { eapply Mem.perm_valid_block; eauto. }
+      eapply Mem.perm_max; eauto. }
+    assert (NM: nonempty_perm m b 0).
+    { r. split; eauto. i. exploit H4; eauto. i. des; eauto. }
+    exploit ec_nonempty; eauto.
+    { eapply external_call_common_spec. }
+    i. r in H5. des; eauto.
+  - r. i. exploit CHAR; eauto. i. des. split.
+    2:{ i. eapply H3. eapply Mem.perm_free_3; eauto. }
+    hexploit Mem.free_range_perm; eauto. intros FPERM.
+    destruct (classic ((fn_stacksize f) > 0)); cycle 1.
+    { eapply Mem.perm_free_1; eauto. }
+    destruct (peq b stk); cycle 1.
+    { eapply Mem.perm_free_1; eauto. }
+    subst. specialize (FPERM 0). exploit FPERM; try lia. i.
+    eapply H3 in H5. des; clarify.
+  - unfold mem_char in *. i. exploit CHAR; eauto. i. des.
+    assert (stk <> b).
+    { hexploit Mem.fresh_block_alloc; eauto. i.
+      eapply Mem.perm_valid_block in H1. ii; subst; clarify. }
+    split; [eapply Mem.perm_alloc_1; eauto|].
+    i. eapply H2. eapply Mem.perm_alloc_4; eauto.
+  - r. i. exploit CHAR; eauto. i. des. split; cycle 1.
+    { i. eapply H2. instantiate (1:=Max).
+      eapply external_call_max_perm; eauto.
+      { eapply Mem.perm_valid_block; eauto. }
+      eapply Mem.perm_max; eauto. }
+    assert (NM: nonempty_perm m b 0).
+    { r. split; eauto. i. exploit H2; eauto. i. des; eauto. }
+    exploit ec_nonempty; eauto.
+    { eapply external_call_common_spec. }
+    i. r in H3. des; eauto.
+Qed.
+    
+  (*   {  *)
+(* Qed. *)
+
+End FUNCPERM.
diff --git a/midend/SSAinv.v b/midend/SSAinv.v
index fbcf67c1..654ad689 100644
--- a/midend/SSAinv.v
+++ b/midend/SSAinv.v
@@ -23,20 +23,21 @@ Require Import Kildall.
 Require Import KildallComp.
 Require Import Relation_Operators.
 Require Import Events.
+Require Import PointerOp.
 Unset Allow StrictProp.
 
 (** * The [rhs] (right hand side) predicate, and equational invariant *)
 Variant rhs (f:function) (x : reg) : instruction -> Prop := 
 | rhs_iop : forall op args pc succ
   (RHS: (fn_code f) ! pc  = Some (Iop op args x succ))
-  (MIND: op_depends_on_memory op = false),
+  (MIND: op_depends_on_both_memory op = false),
   rhs f x (Iop op args x succ).
 Global Hint Constructors rhs: core.
 
 Variant eval : genv -> val -> regset -> instruction -> val -> Prop := 
 | eval_Iop : forall ge sp rs m op args res pc' v
-  (EVAL: eval_operation ge sp op rs## args m = Some v)
-  (MIND: op_depends_on_memory op = false),  
+  (EVAL: eval_operation_wrapper ge sp op rs## args m = Some v)
+  (MIND: op_depends_on_both_memory op = false),  
   eval ge sp rs (Iop op args res pc') v.
 Global Hint Constructors eval: core.
 
@@ -440,10 +441,10 @@ Definition reachable (prog:program) (s:state) :=
 Theorem equation_lemma : 
   forall d op args x succ f m rs sp pc s, 
       (fn_code f) ! d  = Some (Iop op args x succ) ->
-      op_depends_on_memory op = false ->
+      op_depends_on_both_memory op = false ->
       sdom f d pc -> 
       reachable prog (State s f sp pc rs m) -> 
-      eval_operation ge_prog sp op (rs## args) m = Some (rs # x).
+      eval_operation_wrapper ge_prog sp op (rs## args) m = Some (rs # x).
 Proof.
   intros.
   unfold reachable in H2.
@@ -454,17 +455,17 @@ Proof.
   inv Hmodels ; eauto.
   inv H4 ; auto.
   rewrite <- EVAL. 
-  eapply op_depends_on_memory_correct ; eauto.
+  eapply op_wrapper_depends_on_both_memory_correct ; eauto.
 Qed.
 
 Theorem equation_corollary : 
   forall d op args x succ f m rs sp pc s, 
     wf_ssa_program prog ->
       (fn_code f) ! d  = Some (Iop op args x succ) ->
-      op_depends_on_memory op = false ->
+      op_depends_on_both_memory op = false ->
       use f x pc ->
       reachable prog (State s f sp pc rs m) -> 
-      eval_operation (Genv.globalenv prog) sp op (rs## args) m = Some (rs # x).
+      eval_operation_wrapper (Genv.globalenv prog) sp op (rs## args) m = Some (rs # x).
 Proof.
   intros.
   unfold reachable in H3.
@@ -495,7 +496,7 @@ Proof.
   inv Hmodels ; eauto.
   inv H5 ; auto.
   rewrite <- EVAL. 
-  eapply op_depends_on_memory_correct ; eauto.
+  eapply op_wrapper_depends_on_both_memory_correct ; eauto.
 Qed.
 
 End INV.  
diff --git a/midend/SSAvalidator_proof.v b/midend/SSAvalidator_proof.v
index afcc9588..a8f5908a 100644
--- a/midend/SSAvalidator_proof.v
+++ b/midend/SSAvalidator_proof.v
@@ -28,6 +28,7 @@ Require Import SSAvalidprop.
 Require Import LightLive.
 Require Import SSAvalidspec.
 Require Import Bijection.
+Require Import sflib.
 
 (** * The checkers [check_valid_index] and [check_valid_index_phis] are correct *)
 Lemma check_valid_index_correct : forall size def,
@@ -412,7 +413,7 @@ Proof.
   case_eq (forall_ptree (fun _ xdef : positive => negb (Pos.eqb 1 xdef)) t); intros Hb.
   red; intros; subst.
   exploit forall_ptree_true; eauto.
-  simpl; congruence.
+  (* simpl; congruence. *)
   rewrite Hb in *; congruence.
   congruence.
 Qed.
@@ -840,7 +841,7 @@ Proof.
                 rewrite (PTree.elements_complete dpi x' i') in H1; congruence.
 
               * intros i Hin; elim HINV7 with i; simpl; intuition.
-                subst; auto.
+                (* subst; auto. *)
               * intros i j ins Hin Hcode1 Hcode2 Hjun; destruct Hin; [subst|eapply HINV9; eauto; fail]. 
                 clean; in_succ_case; clean.
                 apply HINV8; auto.
diff --git a/midend/SSAvalidproof.v b/midend/SSAvalidproof.v
index a64dc5d5..d0bec3b2 100644
--- a/midend/SSAvalidproof.v
+++ b/midend/SSAvalidproof.v
@@ -17,6 +17,7 @@ Require Import Smallstep.
 Require Import Op.
 Require Import Registers.
 Require Import Integers.
+Require Import PointerOp Simulation RTLdfsD SSAD sflib.
 Require Import RTL RTLdfs.
 Require Import Kildall.
 Require Import KildallComp.
@@ -32,6 +33,8 @@ Require Import SSAvalidator_proof.
 Require Import Utilsvalidproof.
 Require Import LightLive.
 Require Import Bijection.
+Require Import Classical.
+From Paco Require Import paco.
 
 Unset Allow StrictProp.
 
@@ -117,6 +120,9 @@ Section PRESERVATION.
   Let ge : RTLdfs.genv := Genv.globalenv prog.
   Let tge : SSA.genv := Genv.globalenv tprog.
 
+  Let sem := RTLdfs.semantics prog.
+  Let tsem:= SSA.semantics tprog.
+  
   Import RTLdfsproof.
     
   Lemma symbols_preserved:
@@ -209,25 +215,28 @@ Section PRESERVATION.
     apply (Genv.senv_transf_partial TRANSL_PROG).
   Qed.
 
+  Lemma same_public:
+  prog_public prog = prog_public tprog.
+  Proof. inv TRANSL_PROG. des; eauto. Qed.
+
   Lemma spec_ros_r_find_function:
-    forall rs rs' f r r',
+    forall rs rs' f r r' m,
       rs#r = rs'# r' ->
-      RTLdfs.find_function ge (inl _ r) rs = Some f ->
+      RTLdfs.find_function ge (RTLdfs.ros_to_vos m (inl _ r) rs) rs = Some f ->
       exists tf,
-        SSA.find_function tge (inl _ r') rs' = Some tf
+        SSA.find_function tge (SSA.ros_to_vos m (inl _ r') rs') rs' = Some tf
         /\ transf_fundef f = OK tf.
   Proof.
-    intros.
-    eapply functions_translated; eauto.
-    rewrite <- H0. symmetry. simpl.
-    rewrite <- H. auto.
+    intros. ss. des_ifs.
+    - ss. exploit (functions_translated (Vptr b (Ptrofs.repr z))); eauto.
+    - ss. exploit (functions_translated (Vptr b i)); eauto.
   Qed.
   
   Lemma spec_ros_id_find_function:
-    forall rs rs' f id,
-      RTLdfs.find_function ge (inr _ id) rs = Some f ->
+    forall rs rs' f id m,
+      RTLdfs.find_function ge (RTLdfs.ros_to_vos m (inr _ id) rs) rs = Some f ->
       exists tf,
-        SSA.find_function tge (inr _ id) rs' = Some tf
+        SSA.find_function tge (SSA.ros_to_vos m (inr _ id) rs') rs' = Some tf
         /\ transf_fundef f = OK tf.
   Proof.
     intros.
@@ -240,12 +249,12 @@ Section PRESERVATION.
   Qed.
 
   Lemma spec_ros_find_function:
-  forall size rs rs' f ros ros',
+  forall size rs rs' f ros ros' m,
     check_ros_spec size ros ros' ->
     (forall r r', ros = (inl ident (erase_reg size r)) -> ros' = (inl ident r') -> rs#(erase_reg size r) = rs'# r') ->
-    RTLdfs.find_function ge ros rs = Some f ->
+    RTLdfs.find_function ge (RTLdfs.ros_to_vos m ros rs) rs = Some f ->
     exists tf,
-      SSA.find_function tge ros' rs' = Some tf
+      SSA.find_function tge (SSA.ros_to_vos m ros' rs') rs' = Some tf
       /\ transf_fundef f = OK tf.
     Proof.
       intros.
@@ -589,8 +598,8 @@ Proof.
     rewrite <- HGEQ.
     intuition. 
     
-    eapply agree_preserve_arg with (γ := Γ pc) ; eauto.
-    * well_typed; rewrite HGEQ; eauto.
+    (* eapply agree_preserve_arg with (γ := Γ pc) ; eauto. *)
+    (* * (* well_typed; rewrite HGEQ; eauto. *)  *)
     * inv H13; allinv.
       unfold erase_reg in *. rewrite H8 in *. 
       go.
@@ -823,12 +832,13 @@ Proof.
 Qed.
 
 Lemma transl_step_correct:
-  forall s1 t s2, RTLdfs.step ge s1 t s2 ->
+  forall s1 t s2, IStep sem s1 t s2 ->
     forall s1', 
       s1 ≃ s1' ->
       exists s2',
-        SSA.step tge s1' t s2' /\ s2 ≃ s2'.
+        DStep tsem s1' t s2' /\ s2 ≃ s2'.
 Proof.
+  destruct 1. generalize dependent s2. rename H into INT.
   induction 1; intros s1' MATCH;
     inv MATCH; auto;
 
@@ -847,7 +857,7 @@ Proof.
   - (* nop *)
     (* 1 - from a state with phi-block at pc' : exec phiblock and then instr at pc' *)
     exists (State ts tf sp pc' (phi_store x p rs') m).
-    split. constructor 2; auto. 
+    split. DStep_tac. constructor 2; auto. 
     inv Hwtedge; allinv.
     econstructor ; eauto.  
     eapply phistore_preserve_agree  with (pc:= pc') (pc0:= pc) ; eauto. 
@@ -856,7 +866,7 @@ Proof.
     
   - (* 2 - from a state with no phi-block at pc' *)
     exists (State ts tf sp pc' rs' m).
-    split.  constructor ; auto.
+    split. DStep_tac.  constructor ; auto.
     inv Hwtedge; allinv. well_typed; allinv.
     matches pc pc'. 
     unfold agree in *; intros.
@@ -866,10 +876,11 @@ Proof.
 
   - (* op *)
     exists (State ts tf sp pc' (rs'# dst <- v) m).
-    split. econstructor ; eauto.
+    split. DStep_tac. econstructor ; eauto.
     inv Hwtedge; allinv.
     well_typed.
     rewrite <- H0. replace (rs'## args') with (rs##args); eauto with valagree.
+    { eapply eval_operation_wrapper_preserved. eapply senv_preserved. }
     eapply agree_preserve_args; eauto.
     intros ; exploit (wf_live_use f (Lout live)) ; eauto.
 
@@ -883,7 +894,7 @@ Proof.
       
   - (* load *)
     exists (State ts tf sp pc' (rs'# dst0 <- v) m).
-    split. eapply exec_Iload; eauto.
+    split. DStep_tac. eapply exec_Iload; eauto.
     inv Hwtedge ; allinv ; well_typed ; rewrite <- H0; replace (rs'## args') with (rs##args); eauto with valagree.
     eapply agree_preserve_args; eauto.
     intros ; exploit (wf_live_use f (Lout live)) ; eauto.
@@ -898,7 +909,7 @@ Proof.
   - (* store *)
     exists (State ts tf sp pc' rs' m').
     split.
-    + eapply exec_Istore with (a:= a) ; eauto.
+    + DStep_tac. eapply exec_Istore with (a:= a) ; eauto.
       * inv Hwtedge ; allinv ; well_typed;
         rewrite <- H0; replace (rs'## args') with (rs##args); eauto with valagree.
         eapply agree_preserve_args; eauto.
@@ -945,6 +956,7 @@ Proof.
     + intros [tf' [Hfind Htrans]].
       exists (Callstate (Stackframe dst tf sp pc' rs':: ts)  tf' rs'## args' m).
       split.
+      DStep_tac.
       econstructor ; eauto with valagree.
       replace (rs'## args') with (rs##args).
       econstructor ; eauto. 
@@ -952,9 +964,11 @@ Proof.
       eapply wt_call_agree; eauto. 
       eapply check_args_spec_erased_rwt ; eauto.
       destruct ros; simpl in H0.
-      (eapply Genv.find_funct_prop ; eauto).
-      destruct Genv.find_symbol in H0 ; try congruence.
-      (eapply Genv.find_funct_ptr_prop ; eauto). 
+      { des_ifs.
+        { (eapply Genv.find_funct_prop ; eauto). instantiate (1:= (Vptr b (Ptrofs.repr z))). ss. }
+        { (eapply Genv.find_funct_prop ; eauto). instantiate (1:= (Vptr b i)). ss. } }
+      { destruct Genv.find_symbol in H0 ; try congruence.
+        (eapply Genv.find_funct_ptr_prop ; eauto). }
       
       inv Hwtedge; allinv ; well_typed ; inversion Hspec ; eapply agree_preserve_args ; eauto.
       intros ; eapply (wf_live_use f (Lout live)) ; eauto. 
@@ -986,15 +1000,20 @@ Proof.
     + intros [tf' [Hfind Htrans]].
       
       exists (Callstate ts tf' rs'## args' m').
-      split.  econstructor; eauto with valagree.
+      split. DStep_tac.  econstructor; eauto with valagree.
       congruence.
       
       replace (rs'## args') with (rs##args).
       econstructor; eauto.
       destruct ros; simpl in H0.
-      (eapply Genv.find_funct_prop ; eauto).
-      destruct Genv.find_symbol in H0 ; try congruence.
-      (eapply Genv.find_funct_ptr_prop ; eauto). 
+      { des_ifs.
+        { (eapply Genv.find_funct_prop ; eauto). instantiate (1:= (Vptr b (Ptrofs.repr z))). ss. }
+        { (eapply Genv.find_funct_prop ; eauto). instantiate (1:= (Vptr b i)). ss. } }
+      { destruct Genv.find_symbol in H0 ; try congruence.
+        (eapply Genv.find_funct_ptr_prop ; eauto). }
+      (* (eapply Genv.find_funct_prop ; eauto). *)
+      (* destruct Genv.find_symbol in H0 ; try congruence. *)
+      (* (eapply Genv.find_funct_ptr_prop ; eauto).  *)
       
       well_typed; eapply agree_preserve_args; eauto. 
       intros ; eapply (wf_live_use f (Lout live)) ; eauto.
@@ -1003,9 +1022,10 @@ Proof.
       destruct ros ; eauto. 
 
   - (* built in *)
+    unfold is_internal in INT. ss. des_ifs_safe. rename Heq into SRCINT.
     exists (State ts tf sp pc' (regmap_setres dst vres rs') m').
     split.
-    + eapply exec_Ibuiltin with (vargs:= vargs); eauto with valagree.
+    + DStep_tac. eapply exec_Ibuiltin with (vargs:= vargs); eauto with valagree.
       * { exploit check_instr_spec_erase; eauto.
           simpl. intros [Heq _]. inv Heq.
           eapply agree_preserve_builtin_args; eauto with valagree.
@@ -1024,10 +1044,10 @@ Proof.
 
       * matches pc pc'.
         eapply update_preserve_agree with (dst:= x0) (i:= i) ; eauto.
-        -- unfold erase_reg. rewrite H13. auto.
+        -- unfold erase_reg. rewrite H12. auto.
         -- intros ; exploit (wf_live_incl f (Lout live)) ; eauto. 
-           intuition. inversion H8 ; allinv. intuition.
-        -- unfold erase_reg. rewrite H13. simpl. auto.
+           intuition. inversion H6 ; allinv. intuition.
+        -- unfold erase_reg. rewrite H12. simpl. auto.
       * matches pc pc'.
         rewrite regmap_setres_erase_noBR; try solve [eapply H9 ; eauto].
         rewrite regmap_setres_noBR; try solve [eapply H9 ; eauto].
@@ -1036,7 +1056,7 @@ Proof.
         -- eapply (AG r) ; eauto.
         -- inv Hcont ; allinv.
            { destruct dst; simpl in *.
-             - eelim H12 ; eauto.
+             - eelim H11 ; eauto.
              - congruence.
              - congruence.
            }
@@ -1054,7 +1074,7 @@ Proof.
       destruct H1.
       
       exists (State ts tf sp ifso rs' m).
-      split. eapply exec_Icond_true ; eauto.
+      split. DStep_tac. eapply exec_Icond_true ; eauto.
       replace (rs'## args') with (rs##args) ; eauto with valagree.
       eapply agree_preserve_args ; eauto.
       intros ; eapply (wf_live_use f (Lout live)) ; eauto.
@@ -1082,7 +1102,7 @@ Proof.
       eapply SSA.fn_code_closed; eauto. destruct H1.
       
       exists (State ts tf sp ifnot rs' m);
-        split; try (eapply exec_Icond_false ; eauto).
+        split; try DStep_tac; try (eapply exec_Icond_false ; eauto).
       replace (rs'## args') with (rs##args) ; eauto with valagree.
       inv Hwtedge; allinv ; try well_typed ; eapply agree_preserve_args ; eauto.
       intros ; eapply (wf_live_use f (Lout live)) ; eauto.
@@ -1106,7 +1126,7 @@ Proof.
     assert (Hedge : is_edge tf pc pc') by (econstructor; eauto; simpl; eapply list_nth_z_in; eauto).
     assert (Hwtedge : wt_edge tf _ (Lin f pc' (Lout live)) Γ pc pc') by auto.
     exists (State ts tf sp pc' rs' m);
-      split; try (eapply exec_Ijumptable ; eauto).
+      split; try DStep_tac; try (eapply exec_Ijumptable ; eauto).
     rewrite <- H0. symmetry.
     inv Hwtedge; allinv ; try well_typed; conv ; eauto with agree.
     + destruct (Bij.rmap size arg0) as (r, p) eqn:EQN.
@@ -1142,9 +1162,11 @@ Proof.
     exploit_hyps SPEC.
     exploit (Hwto pc). constructor 2 with (or:= None); eauto. clear Hwto; intros Hwto; inv Hwto; allinv.
     exists (SSA.Returnstate ts (regmap_optget None Vundef rs') m'); split ; eauto.
+    DStep_tac.
     eapply SSA.exec_Ireturn; eauto. congruence.
     exploit (Hwto pc). constructor 2 with (or:= Some r); eauto. clear Hwto; intros Hwto; inv Hwto; allinv.
     exists (Returnstate ts (regmap_optget (Some r) Vundef rs') m'); split ; eauto.
+    DStep_tac.
     eapply exec_Ireturn; eauto. congruence.
     simpl. replace (rs'#r) with (rs#(erase_reg size r)); eauto.
     well_typed; conv ; eauto with valagree. 
@@ -1177,6 +1199,7 @@ Proof.
 
     exists (State ts x (Vptr stk Ptrofs.zero) x.(fn_entrypoint) (init_regs args x.(fn_params)) m').
     split.
+    DStep_tac.
     eapply exec_function_internal; eauto.
     erewrite <- typecheck_function_correct_ssize; eauto.
     replace (RTLdfs.fn_entrypoint f) with (fn_entrypoint x) at 1; auto.
@@ -1193,7 +1216,8 @@ Proof.
 
   - (* external *)
     inv TRANSF.
-    exists (Returnstate ts res m'). split. 
+    exists (Returnstate ts res m'). split.
+    DStep_tac.
     eapply exec_function_external; eauto.
     eapply external_call_symbols_preserved; eauto with valagree.
     eapply senv_preserved.
@@ -1202,7 +1226,7 @@ Proof.
   - (* return state *)
     inv STACKS. 
     exists (State ts0 tf sp pc (rs'# res0 <- vres) m);
-      split; ( try constructor ; eauto).
+      split; try DStep_tac; ( try constructor ; eauto).
     
     econstructor ; eauto.
     unfold agree; intros.
@@ -1226,20 +1250,199 @@ Proof.
         rewrite EQN in *. simpl in *. subst.
         rewrite Bij.BIJ1 in EQN. inv EQN. congruence.
         auto.
-Qed. 
+Qed.
+
+Lemma match_states_bsim
+      s1 s2 s2' t
+      (EXT: RTLdfs.is_external ge s1)
+      (STEPTGT: Step tsem s2 t s2')
+      (MATCH: s1 ≃ s2)
+      (SAFESRC: safe sem s1)
+  :
+    (exists s1', Step sem s1 t s1' /\ s1' ≃ s2').
+Proof.
+  assert (SEQUIV: Senv.equiv tge ge) by (symmetry; apply senv_preserved).
+  unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+  { inv SAFESRC. inv MATCH. inv STACKS. inv STEPTGT. }
+  inv MATCH; ss; des_ifs; try (try exploit_hyps SPEC;
+  try (assert (Hedge : is_edge tf pc n) by go;
+    assert (Hwtedge : wt_edge tf _ (Lin f n (Lout live)) Γ pc n) by eauto);
+  (exploit is_edge_pred ; eauto ; intros [x H2] ) ;
+  try (
+    assert (Hedge0 : is_edge tf pc0 pc) by (eapply pred_is_edge; eauto);
+      assert (Hwtedge0 : wt_edge tf _ (Lin f n (Lout live)) Γ pc0 pc) by (eauto)
+  );
+  try (case_eq ((fn_phicode tf)!n); intros) ;
+  try destruct (join_point_exclusive tf HWF n)); try (error n); try (error_struct tf pc n);
+  try (instr_succ pc n Hi ; try (error n); try (error_struct tf pc n)).
+
+  (* builtin *)
+  - i. inv STEPTGT; clarify. inv SAFESRC; clarify.
+    exists (RTLdfs.State s f sp n (regmap_setres (map_builtin_res (erase_reg size) dst) vres rs) m').
+    esplits.
+    + eapply RTLdfs.exec_Ibuiltin with (ef:=e) (args:=l).
+      { eauto. }
+      { instantiate (1:=vargs).
+        exploit check_instr_spec_erase; eauto.
+        simpl. intros [Heq _]. inv Heq.
+        exploit eval_builtin_args_preserved; try eapply H15.
+        { eapply senv_preserved. }
+        i. exploit agree_preserve_builtin_args; try eapply H1; eauto with valagree.
+        - intros ; eapply (wf_live_use f (Lout live)) ; eauto.
+        - exploit (Hwte pc). econstructor; eauto.
+          clear Hwte; intros Hwte; inv Hwte; allinv.
+          inv WTI; eauto.
+        - inv Hwtedge; allinv.
+          inv WTI; eauto.
+        - inv Hwtedge; allinv.
+          inv WTI; eauto.
+        - i. exploit eval_builtin_args_determ. eapply H12. eapply H3. i. subst.
+          eauto. }
+      eapply external_call_symbols_preserved; eauto.
+    + inv Hwtedge; allinv; well_typed.
+
+      * matches pc n.
+        eapply update_preserve_agree with (dst:= x0) (i:= i) ; eauto.
+        -- unfold erase_reg. rewrite H10. auto.
+        -- intros ; exploit (wf_live_incl f (Lout live)) ; eauto. 
+           intuition. inversion H5 ; allinv. intuition.
+        -- unfold erase_reg. rewrite H10. simpl. auto.
+      * matches pc n.
+        rewrite regmap_setres_erase_noBR; try solve [eapply H9 ; eauto].
+        rewrite regmap_setres_noBR; try solve [eapply H9 ; eauto].
+        unfold agree in * ; intros.
+        exploit (wf_live_incl f (Lout live)) ; eauto. intros [Hok | Hcont].
+        -- eapply (AG r) ; eauto.
+        -- inv Hcont ; allinv.
+           { destruct dst; simpl in *.
+             - eelim H9 ; eauto.
+             - congruence.
+             - congruence.
+           }
+  (* external call *)
+  - i. inv STEPTGT; clarify. inv SAFESRC; clarify.
+    inv TRANSF.
+    exists (RTLdfs.Returnstate s res m'). split.
+    eapply RTLdfs.exec_function_external; eauto.
+    eapply external_call_symbols_preserved; eauto with valagree.
+    econstructor ; eauto.
+Qed.
+
+Lemma match_states_xsim
+    st_src0 st_tgt0 gmtgt
+    (MATCH: match_states st_src0 st_tgt0) :
+  xsim (RTLdfs.semantics prog) (semantics tprog) gmtgt lt 0%nat st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold.
+  destruct (classic (RTLdfs.is_external ge st_src0)); cycle 1.
+  (* not external *)
+  - left. econs. econs.
+    + i. exploit transl_step_correct; eauto. i. des; esplits; eauto.
+      { eapply tr_rel_refl. eapply ev_rel_refl. }
+      left. split; eauto.
+      { eapply plus_one; eauto. }
+      { eapply RTLdfsD.semantics_receptive_at; auto. }
+    + ii. eapply final_state_determ; eauto.
+      inv FINALSRC. inv MATCH. ss. inv STACKS. econs.
+  (* external *)
+  - right. econs. i. econs.
+    (* bsim *)
+    + i. exploit match_states_bsim; eauto. i. des.
+      left. esplits; eauto.
+      { eapply tr_rel_refl. eapply ev_rel_refl. }
+      left. eapply plus_one. eauto.
+    + ii. inv FINALTGT. inv MATCH. inv STACKS. ss.
+    (* progress *)
+    + i. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+      { inv SAFESRC; ss. }
+      right. inv MATCH; ss; des_ifs; inv SAFESRC; unfold ge in *; clarify; try (try exploit_hyps SPEC;
+      try (assert (Hedge : is_edge tf pc n) by go;
+           assert (Hwtedge : wt_edge tf _ (Lin f n (Lout live)) Γ pc n) by eauto);
+          (exploit is_edge_pred ; eauto ; intros [x H2] ) ;
+      try (assert (Hedge0 : is_edge tf pc0 pc) by (eapply pred_is_edge; eauto);
+           assert (Hwtedge0 : wt_edge tf _ (Lin f n (Lout live)) Γ pc0 pc) by (eauto));
+      try (case_eq ((fn_phicode tf)!n); intros) ;
+      try destruct (join_point_exclusive tf HWF n)); try (error n); try (error_struct tf pc n);
+      try (instr_succ pc n Hi ; try (error n); try (error_struct tf pc n)).
+      * esplits. eapply exec_Ibuiltin. eauto.
+        { instantiate (1:=vargs).
+          exploit check_instr_spec_erase; eauto.
+          simpl. intros [Heq _]. inv Heq.
+          (* exploit eval_builtin_args_preserved; try eapply H15. *)
+          (* { eapply senv_preserved. } *)
+          (* i. *)
+          exploit agree_preserve_builtin_args; eauto with valagree.
+          - intros ; eapply (wf_live_use f (Lout live)) ; eauto.
+          - exploit (Hwte pc). econstructor; eauto.
+            clear Hwte; intros Hwte; inv Hwte; allinv.
+            inv WTI; eauto.
+          - inv Hwtedge; allinv.
+            inv WTI; eauto.
+          - inv Hwtedge; allinv.
+            inv WTI; eauto. }
+        eapply external_call_symbols_preserved; eauto with valagree.
+        eapply senv_preserved.
+      * inv TRANSF. esplits.
+        eapply exec_function_external; eauto.
+        eapply external_call_symbols_preserved; eauto with valagree.
+        eapply senv_preserved.
+Qed.
+
+Lemma non_static_equiv l:
+  Genv.non_static_glob (Genv.globalenv prog) l = Genv.non_static_glob (Genv.globalenv tprog) l.
+Proof.
+  induction l; ss.
+  specialize senv_preserved. i. unfold ge, tge in H. r in H. des.
+  specialize (H0 a).
+  unfold Senv.public_symbol in H0. ss. rewrite <- H0.
+  specialize (H a). rewrite <- H. erewrite IHl; eauto.
+Qed.
+
+Lemma transf_initial_capture
+    S1 S2 S2'
+    (INITSRC: RTLdfs.initial_state prog S1)
+    (INITTGT: SSA.initial_state tprog S2)
+    (MATCH: match_states S1 S2)
+    (CAPTGT: SSA.glob_capture tprog S2 S2'):
+  exists S1',
+    RTLdfs.glob_capture prog S1 S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (RTLdfs.concrete_snapshot ge S1') (SSA.concrete_snapshot tge S2').
+Proof.
+  specialize senv_preserved. intros SENVEQ. inv CAPTGT. ss.
+  rewrite Genv.globalenv_public in CAPTURE.
+  rewrite <- same_public in CAPTURE. erewrite <- non_static_equiv in CAPTURE.
+  inv MATCH. inv STACKS.
+  esplits.
+  - econs; eauto. rewrite Genv.globalenv_public. eauto.
+  - econs; eauto. econs.
+  - ii. unfold RTLdfs.concrete_snapshot, SSA.concrete_snapshot in *.
+    inv SENVEQ. des. erewrite H1, H0. des_ifs; ss.
+Qed.
 
 (** ** Final semantics preservation result *)
 Theorem transf_program_correct:
-  forward_simulation (RTLdfs.semantics prog) (SSA.semantics tprog).
+  mixed_simulation (RTLdfs.semantics prog) (SSA.semantics tprog).
 Proof.
-  eapply forward_simulation_step.
-  - eapply senv_preserved; eauto.
-  - eexact transf_initial_states.
-  - eexact transf_final_states.
-  - exact transl_step_correct. 
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (S a). lia.
+  - econs. i. exploit transf_initial_states; eauto. i. des.
+    exists st2. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. inversion INITSRC; subst. inversion H0; subst.
+      inv STACKS.
+      exploit transf_initial_capture; eauto.
+      i. des.
+      exists 0%nat. exists S1'. esplits; eauto.
+      apply match_states_xsim; auto.
+  - i. apply senv_preserved.
 Qed.
 
-  End CORRECTNESS.
+End CORRECTNESS.
 
   
 End PRESERVATION.
diff --git a/small-examples/cse-example.c b/small-examples/cse-example.c
new file mode 100644
index 00000000..732ccb7c
--- /dev/null
+++ b/small-examples/cse-example.c
@@ -0,0 +1,11 @@
+#include <stdlib.h>
+#include <stdint.h>
+
+int foo(long *p, long *q) {
+  uintptr_t i = (uintptr_t) p;
+
+  int c1 = ((void *)i < q);
+  int c2 = (p < q);
+
+  return c1 + c2;
+}
diff --git a/small-examples/many_cast1.c b/small-examples/many_cast1.c
new file mode 100644
index 00000000..8dff727b
--- /dev/null
+++ b/small-examples/many_cast1.c
@@ -0,0 +1,48 @@
+#include <stdlib.h>
+#include <stdint.h>
+long main (long sz, long temp) {
+  void* p = (void *) malloc(sz - 10);
+  uintptr_t i0 = (uintptr_t) p;
+  uintptr_t i1 = i0;
+  uintptr_t i2 = i1;
+  uintptr_t i3 = (uintptr_t) p;
+  uintptr_t i4 = (uintptr_t) p;
+  uintptr_t i5 = (uintptr_t) p;
+  uintptr_t i6 = (uintptr_t) p;
+  uintptr_t i7 = (uintptr_t) p;
+  long i8 = (long) p;
+  long i9 = (long) p;
+  long j0 = (long) p;
+  long j1 = (long) p;
+  long j2 = (long) p;
+  long j3 = (long) p;
+  long j4 = (long) p;
+  long j5 = (long) p;
+  long j6 = (long) p;
+  long j7 = (long) p;
+  long j8 = (long) p;
+  long j9 = (long) p;
+
+  long r =
+  i0 +
+  i1 +
+  i2 +
+  i3 +
+  i4 +
+  i5 +
+  i6 +
+  i7 +
+  i8 +
+  i9 +
+  j0 +
+  j1 +
+  j2 +
+  j3 +
+  j4 +
+  j5 +
+  j6 +
+  j7 +
+  j8 + j9;
+
+  return 100 + temp*temp + (temp-42) + r;
+}
diff --git a/test/.gitignore b/test/.gitignore
index de4aef22..09144e68 100644
--- a/test/.gitignore
+++ b/test/.gitignore
@@ -6,6 +6,3 @@
 *.light.c
 *.compcert
 *.gcc
-*.ssa.[0-9]
-*.rtl.[0-9]
-*.rtl.norm
\ No newline at end of file
diff --git a/test/Makefile b/test/Makefile
index 013cdd64..fa1fef30 100644
--- a/test/Makefile
+++ b/test/Makefile
@@ -1,17 +1,12 @@
 include ../Makefile.config
 
-DIRS=c compression raytracer spass regression abi \
-     extra
-PICOSAT=picosat-965
-
+DIRS=c compression raytracer spass regression abi
 ifeq ($(CLIGHTGEN),true)
 DIRS+=clightgen
 endif
 
 all:
 	set -e; for i in $(DIRS); do $(MAKE) CCOMPOPTS='$(CCOMPOPTS)' -C $$i all; done
-	cd $(PICOSAT) && ./configure.sh && cd ..
-	$(MAKE) CCOMPOPTS='$(CCOMPOPTS)' -C $(PICOSAT) -f Makefile.local all
 
 test:
 	set -e; for i in $(DIRS); do $(MAKE) SIMU='$(SIMU)' -C $$i test; done
@@ -24,4 +19,3 @@ bench:
 
 clean:
 	for i in $(DIRS); do $(MAKE) -C $$i clean; done
-	$(MAKE) CCOMPOPTS='$(CCOMPOPTS)' -C $(PICOSAT) -f Makefile.local clean
diff --git a/test/abi/Makefile b/test/abi/Makefile
index eb9ca292..ea8cd20b 100644
--- a/test/abi/Makefile
+++ b/test/abi/Makefile
@@ -1,6 +1,6 @@
 include ../../Makefile.config
 
-CCOMP=../../ccomp -stdlib ../../runtime
+CCOMP=../../ccomp -stdlib ../../runtime -dclight -dasm
 CCOMPFLAGS=
 CFLAGS=-O -Wno-overflow -Wno-constant-conversion
 
diff --git a/test/c/Makefile b/test/c/Makefile
index 21ddc46b..4b521bb5 100644
--- a/test/c/Makefile
+++ b/test/c/Makefile
@@ -1,7 +1,7 @@
 include ../../Makefile.config
 
 CCOMP=../../ccomp
-CCOMPFLAGS=$(CCOMPOPTS) -stdlib ../../runtime -dc -dclight -dasm $(SSA_MODE)
+CCOMPFLAGS=$(CCOMPOPTS) -stdlib ../../runtime -dc -dclight -dasm
 
 CFLAGS=-O1 -Wall
 
@@ -57,5 +57,4 @@ bench:
 
 clean:
 	rm -f *.compcert *.gcc
-	rm -f *.compcert.c *.light.c *.parsed.c *.s *.o *.sdump *~
-	rm -f *.rtl.[0-9] *.ssa.[0-9] *.cssa *.rtlpar *.rtl.norm
+	rm -f *.compcert.c *.light.c *.parsed.c *.s *.o *.sdump *~ 
diff --git a/test/compression/Makefile b/test/compression/Makefile
index 8b554657..e8f3cf4d 100644
--- a/test/compression/Makefile
+++ b/test/compression/Makefile
@@ -1,7 +1,7 @@
 include ../../Makefile.config
 
 CC=../../ccomp 
-CFLAGS=$(CCOMPOPTS) -U__GNUC__ -stdlib ../../runtime -dclight -dasm $(SSA_MODE)
+CFLAGS=$(CCOMPOPTS) -U__GNUC__ -stdlib ../../runtime -dclight -dasm
 LIBS=
 TIME=ocaml unix.cma ../../tools/xtime.ml -mintime 2.0 -minruns 2
 
@@ -56,7 +56,6 @@ include .depend
 
 clean:
 	rm -f *.o *.light.c *.s *.sdump $(EXE)
-	rm -f *.ssa.[0-9] *.rtl.norm *.rtl.[0-9] *.cssa  *.rtlpar
 
 depend:
 	gcc -MM *.c > .depend
diff --git a/test/extra/Makefile b/test/extra/Makefile
deleted file mode 100644
index aa4214d6..00000000
--- a/test/extra/Makefile
+++ /dev/null
@@ -1,60 +0,0 @@
-include ../../Makefile.config
-
-CCOMP=../../ccomp
-CCOMPFLAGS=$(CCOMPOPTS) -stdlib ../../runtime -dc -dclight -dasm $(SSA_MODE)
-
-CFLAGS=-O1 -Wall
-
-LIBS=$(LIBMATH)
-
-TIME=ocaml unix.cma ../../tools/xtime.ml -o /dev/null -mintime 2.0 -minruns 4
-
-PROGS=self-loop
-
-BENCHPROGS=
-
-all: $(PROGS:%=%.compcert)
-
-all_s: $(PROGS:%=%.s)
-
-all_gcc: $(PROGS:%=%.gcc)
-
-%.compcert: %.c
-	$(CCOMP) $(CCOMPFLAGS) -o $*.compcert $*.c $(LIBS)
-
-%.s: %.c
-	$(CCOMP) $(CCOMPFLAGS) -S $*.c
-
-%.gcc: %.c
-	$(CC) $(CFLAGS) -o $*.gcc $*.c $(LIBS)
-
-test:
-	@for i in $(BENCHPROGS); do \
-	   if $(SIMU) ./$$i.compcert | cmp -s - Results/$$i; \
-           then echo "$$i: passed"; \
-           else echo "$$i: FAILED"; exit 2; \
-	   fi; \
-         done
-
-test_gcc:
-	@for i in $(BENCHPROGS); do \
-	   if ./$$i.gcc | cmp -s - Results/$$i; \
-           then echo "$$i: passed"; \
-           else echo "$$i: FAILED"; \
-	   fi; \
-         done
-
-bench_gcc:
-	@for i in $(BENCHPROGS); do \
-	   $(TIME) -name $$i -- ./$$i.gcc; \
-         done
-
-bench:
-	@for i in $(BENCHPROGS); do \
-	   $(TIME) -name $$i -- ./$$i.compcert; \
-         done
-
-clean:
-	rm -f *.compcert *.gcc
-	rm -f *.compcert.c *.light.c *.parsed.c *.s *.o *.sdump *~
-	rm -f *.rtl.[0-9] *.ssa.[0-9] *.rtl.norm *.cssa *.rtlpar
diff --git a/test/extra/self-loop.c b/test/extra/self-loop.c
deleted file mode 100644
index d810da1f..00000000
--- a/test/extra/self-loop.c
+++ /dev/null
@@ -1,4 +0,0 @@
-int main() {
-a:
-  goto a;
-}
diff --git a/test/picosat-965/LICENSE b/test/picosat-965/LICENSE
deleted file mode 100644
index 96739de2..00000000
--- a/test/picosat-965/LICENSE
+++ /dev/null
@@ -1,20 +0,0 @@
-Copyright (c) 2006 - 2014, Armin Biere, Johannes Kepler University.
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to
-deal in the Software without restriction, including without limitation the
-rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
-sell copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-IN THE SOFTWARE.
-
diff --git a/test/picosat-965/Makefile.local b/test/picosat-965/Makefile.local
deleted file mode 100644
index 9db5dfac..00000000
--- a/test/picosat-965/Makefile.local
+++ /dev/null
@@ -1,62 +0,0 @@
-include ../../Makefile.config
-
-CC=../../ccomp 
-CFLAGS=$(CCOMPOPTS) -stdlib ../../runtime -dparse -dclight -dasm -fstruct-return -fbitfields $(SSA_MODE)
-
-all: picosat picomcs picomus picogcnf libpicosat.a
-
-clean:
-	rm -f picosat picomcs picomus picogcnf
-	rm -f *.exe *.s *.o *.a *.so *.plist
-	rm -f makefile config.h
-	rm -f *.o *.s *.parsed.c *.light.c *.sdump
-	rm -f gmon.out *~ 
-
-analyze:
-	clang --analyze $(CFLAGS) *.c *.h
-
-picosat: libpicosat.a app.o main.o
-	$(CC) $(CFLAGS) -o $@ main.o app.o -L. -lpicosat
-
-picomcs: libpicosat.a picomcs.o
-	$(CC) $(CFLAGS) -o $@ picomcs.o -L. -lpicosat
-
-picomus: libpicosat.a picomus.o
-	$(CC) $(CFLAGS) -o $@ picomus.o -L. -lpicosat
-
-picogcnf: libpicosat.a picogcnf.o
-	$(CC) $(CFLAGS) -o $@ picogcnf.o -L. -lpicosat
-
-app.o: app.c picosat.h makefile
-	$(CC) $(CFLAGS) -c $<
-
-picomcs.o: picomcs.c picosat.h makefile
-	$(CC) $(CFLAGS) -c $<
-
-picomus.o: picomus.c picosat.h makefile
-	$(CC) $(CFLAGS) -c $<
-
-picogcnf.o: picogcnf.c picosat.h makefile
-	$(CC) $(CFLAGS) -c $<
-
-main.o: main.c picosat.h makefile
-	$(CC) $(CFLAGS) -c $<
-
-picosat.o: picosat.c picosat.h makefile
-	$(CC) $(CFLAGS) -c $<
-
-version.o: version.c config.h makefile
-	$(CC) $(CFLAGS) -c $<
-
-config.h: makefile VERSION mkconfig.sh # and actually picosat.c
-	rm -f $@; ./mkconfig.sh > $@
-
-libpicosat.a: picosat.o version.o
-	ar rc $@ picosat.o version.o
-	ranlib $@
-
-SONAME=-Xlinker -soname -Xlinker libpicosat.so
-libpicosat.so: picosat.o version.o
-	$(CC) $(CFLAGS) -shared -o $@ picosat.o version.o $(SONAME)
-
-.PHONY: all clean
diff --git a/test/picosat-965/NEWS b/test/picosat-965/NEWS
deleted file mode 100644
index 7ad60b53..00000000
--- a/test/picosat-965/NEWS
+++ /dev/null
@@ -1,162 +0,0 @@
-news for release 965 since 959
-------------------------------
-
-* ADC code works again (spotted by Himanshu Jain)
-* include into R projects (with Christoph Muessel) (--rcode)
-* fixed 'undefined' + 'ptrdiff_' issues (thanks to Christoph Muessel)
-* added 'picosat_set_interrupt' and '-a <alarm>' command line option
-* fixed various issues pointed out by Stefan Hengelein:
-  - fixed incremental usage of 'picosat_adjust'
-  - added CPP fixes (STATS, NO_BINARY_CLAUSE versus TRACE mix-ups)
-  - removed redundant explicit set to zero on reset
-* fixed various usage bugs with 'picomus' (thanks to Stefan Hengelein)
-* removed '-fno-strict-aliasing' (thanks to Jerry James)
-
-news for release 959 since 953
-------------------------------
-
-* fixed header comments
-
-* fixed minor compilation issues
-
-* fixed unitialized memory access problem for 'picosat_deref_partial'
-  and another issue with partial models
-
-* added 'picosat_add_arg' and 'picosat_add_lits'
-
-* '--plain' and 'picosat_set_plain' to disable failed literal probing
-
-* new '#define PICOSAT_REENTRANT_API' in 'picosat.h'
-
-* added manager so no more global variables
-  (allows multiple instances, requires manager object)
-
-news for release 951 since 941
-------------------------------
-
-* cleaned up code (based on comments by Donald Knuth)
-
-* lreduce=O(conflicts^.5)
-
-* added 'picosat_visits' and 'picosat_decisions'
-
-* added '--partial' command line option
-
-* added 'picosat_deref_partial' and 'picosat_save_original_clauses'
-
-* added 'picomcs' as example for MSS computation
-
-news for release 941 since 936
-------------------------------
-
-* added 'picogcnf'
-
-* added All-SAT mode ('--all' command line option)
-
-* statistics include time spent in failed literal preprocessing (probing)
-
-* 'picosat_failed_context' for 'push & pop'
-   (and tested failed assumptions for 'push & pop')
-
-* 'picosat_simplify' for forced garbage collection
-
-* undefined NFL, defined NADC (= failed literals on, ADC's off)
-
-* 'picosat_push' and 'picosat_pop' (beta version)
-
-* fixed some issues related to binary clause handling and 
-  generating list of failed assumptions
-
-news for release 936 since 935
-------------------------------
-
-* simple minimal unsatisfiable core (MUS) extractor 'picomus'
-  (example for using 'picosat_mus_assumptions' and 'picosat_coreclause')
-
-* added 'picosat_mus_assumptions'
-
-* added 'picosat_{set_}propagations'
-
-* new 'int' return value for 'picosat_enable_trace_generation' to
-  check for trace code being compiled
-
-news for release 935 since 926
-------------------------------
-
-* added 'picosat_failed_assumptions' (plural)
-
-* new '-A <failedlits>' command line option
-
-* fixed failed assumption issues
-
-* added 'picosat_remove_learned'
-
-* added 'picosat_reset_{phases,scores}'
-
-* added 'picosat_set_less_important_lit'
-
-* added 'picosat_res'
-
-news for release 926 since 846
-------------------------------
-
-* random initial phase (API of 'picosat_set_default_phase' changed)
-
-* fixed accumulative failed assumption (multiple times)
-
-* fixed missing original clause in core generation with assumptions
-
-* fixed debugging code for memory allocation
-
-* shared library in addition to static library
-
-* removed potential UNKNOWN result without decision limit
-
-* added picosat_set_more_important_lit
-
-* added picosat_coreclause
-
-* propagation of binary clauses until completion
-
-* fixed API usage 'assume;sat;sat'
-
-* literals move to front (LMTF) during traversal of visited clauses
-
-* switched from inner/outer to Luby style restart scheduling
-
-* less agressive reduce schedule
-
-* replaced watched literals with head and tail pointers
-
-* add 'picosat_failed_assumption', which allows to avoid tracing and core
-  generation, if one is only interested in assumptions in the core
-
-* fixed a BUG in the generic iterator code of clauses
-  (should rarely happen unless you use a very sophisticated malloc lib)
-
-news for release 846 since 632
-------------------------------
-
-* cleaned up assumption handling (actually removed buggy optimization)
-
-* incremental core generation 
-
-* experimental 'all different constraint' handling as in our FMCAD'08 paper
-
-* new API calls: 
-
-  - picosat_add_ado_lit       (add all different object literal)
-  - picosat_deref_top_level   (deref top level assignment)
-  - picosat_changed           (check whether extension was possible)
-  - picosat_measure_all_calls (per default do not measure adding time)
-  - picosat_set_prefix        (set prefix for messages)
-
-* 64 bit port (and compilation options)
-
-* optional NVSIDS visualization code
-
-* resource controlled failed literal implementation
-
-* disconnect long clauses satisfied at lower decision level
-
-* controlling restarts
diff --git a/test/picosat-965/README b/test/picosat-965/README
deleted file mode 100644
index 05b84396..00000000
--- a/test/picosat-965/README
+++ /dev/null
@@ -1,5 +0,0 @@
-These are the sources of the PicoSAT solver.
-The preprocessor is not included.
-To compile run './configure.sh && make'.
-The API is document in 'picosat.h'.
-See also 'NEWS' and 'LICENSE'.
diff --git a/test/picosat-965/VERSION b/test/picosat-965/VERSION
deleted file mode 100644
index aa5bea4e..00000000
--- a/test/picosat-965/VERSION
+++ /dev/null
@@ -1 +0,0 @@
-965
diff --git a/test/picosat-965/app.c b/test/picosat-965/app.c
deleted file mode 100644
index 8c907374..00000000
--- a/test/picosat-965/app.c
+++ /dev/null
@@ -1,1192 +0,0 @@
-#include "picosat.h"
-
-#include <assert.h>
-#include <ctype.h>
-#include <signal.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-
-#define GUNZIP "gunzip -c %s"
-#define BUNZIP2 "bzcat %s"
-#define GZIP "gzip -c -f > %s"
-
-FILE * popen (const char *, const char*);
-int pclose (FILE *);
-
-static PicoSAT * picosat;
-
-static int lineno;
-static FILE *input;
-static int inputid;
-static FILE *output;
-static int verbose;
-static int sargc;
-static char ** sargv;
-static char buffer[100];
-static char *bhead = buffer;
-static const char *eob = buffer + 80;
-static FILE * incremental_rup_file;
-static signed char * sol;
-
-extern void picosat_enter (PicoSAT *);
-extern void picosat_leave (PicoSAT *);
-
-static int
-next (void)
-{
-  int res = getc (input);
-  if (res == '\n')
-    lineno++;
-
-  return res;
-}
-
-static const char *
-parse (PicoSAT * picosat, int force)
-{
-  int ch, sign, lit, vars, clauses;
-
-  lineno = 1;
-  inputid = fileno (input);
-
-SKIP_COMMENTS:
-  ch = next ();
-  if (ch == 'c')
-    {
-      while ((ch = next ()) != EOF && ch != '\n')
-	;
-      goto SKIP_COMMENTS;
-    }
-
-  if (isspace (ch))
-    goto SKIP_COMMENTS;
-
-  if (ch != 'p')
-INVALID_HEADER:
-    return "missing or invalid 'p cnf <variables> <clauses>' header";
-
-  if (!isspace (next ()))
-    goto INVALID_HEADER;
-
-  while (isspace (ch = next ()))
-    ;
-
-  if (ch != 'c' || next () != 'n' || next () != 'f' || !isspace (next ()))
-    goto INVALID_HEADER;
-
-  while (isspace (ch = next ()))
-    ;
-    
-  if (!isdigit (ch))
-    goto INVALID_HEADER;
-
-  vars = ch - '0';
-  while (isdigit (ch = next ()))
-    vars = 10 * vars + (ch - '0');
-
-  if (!isspace (ch))
-    goto INVALID_HEADER;
-
-  while (isspace (ch = next ()))
-    ;
-
-  if (!isdigit (ch))
-    goto INVALID_HEADER;
-
-  clauses = ch - '0';
-  while (isdigit (ch = next ()))
-    clauses = 10 * clauses + (ch - '0');
-
-  if (!isspace (ch) && ch != '\n' )
-    goto INVALID_HEADER;
-
-  if (verbose)
-    {
-      fprintf (output, "c parsed header 'p cnf %d %d'\n", vars, clauses);
-      fflush (output);
-    }
-
-  picosat_adjust (picosat, vars);
-
-  if (incremental_rup_file)
-    picosat_set_incremental_rup_file (picosat, incremental_rup_file, vars, clauses);
-
-  lit = 0;
-READ_LITERAL:
-  ch = next ();
-
-  if (ch == 'c')
-    {
-      while ((ch = next ()) != EOF && ch != '\n')
-	;
-      goto READ_LITERAL;
-    }
-
-  if (ch == EOF)
-    {
-      if (lit)
-	return "trailing 0 missing";
-
-      if (clauses && !force)
-	return "clause missing";
-
-      return 0;
-    }
-
-  if (isspace (ch))
-    goto READ_LITERAL;
-
-  sign = 1;
-  if (ch == '-')
-    {
-      sign = -1;
-      ch = next ();
-    }
-
-  if (!isdigit (ch))
-    return "expected number";
-
-  lit = ch - '0';
-  while (isdigit (ch = next ()))
-    lit = 10 * lit + (ch - '0');
-
-  if (!clauses && !force)
-    return "too many clauses";
-
-  if (lit)
-    {
-      if (lit > vars && !force)
-	return "maximal variable index exceeded";
-
-      lit *= sign;
-    }
-  else
-    clauses--;
-
-  picosat_add (picosat, lit);
-
-  goto READ_LITERAL;
-}
-
-static void
-bflush (void)
-{
-  *bhead = 0;
-  fputs (buffer, output);
-  fputc ('\n', output);
-  bhead = buffer;
-}
-
-static void
-printi (int i)
-{
-  char *next;
-  int l;
-
-REENTER:
-  if (bhead == buffer)
-    *bhead++ = 'v';
-
-  l = sprintf (bhead, " %d", i);
-  next = bhead + l;
-
-  if (next >= eob)
-    {
-      bflush ();
-      goto REENTER;
-    }
-  else
-    bhead = next;
-}
-
-static void
-printa (PicoSAT * picosat, int partial)
-{
-  int max_idx = picosat_variables (picosat), i, lit, val;
-
-  assert (bhead == buffer);
-
-  for (i = 1; i <= max_idx; i++)
-    {
-      if (partial)
-	{
-	  val = picosat_deref_partial (picosat, i);
-	  if (!val)
-	    continue;
-	}
-      else
-	val = picosat_deref (picosat, i);
-      lit = (val > 0) ? i : -i;
-      printi (lit);
-    }
-
-  printi (0);
-  if (bhead > buffer)
-    bflush ();
-}
-
-static void
-blocksol (PicoSAT * picosat)
-{
-  int max_idx = picosat_variables (picosat), i;
-
-  if (!sol)
-    {
-      sol = malloc (max_idx + 1);
-      memset (sol, 0, max_idx + 1);
-    }
-
-  for (i = 1; i <= max_idx; i++)
-    sol[i] = (picosat_deref (picosat, i) > 0) ? 1 : -1;
-
-  for (i = 1; i <= max_idx; i++)
-    picosat_add (picosat, (sol[i] < 0) ? i : -i);
-
-  picosat_add (picosat, 0);
-}
-
-static int
-has_suffix (const char *str, const char *suffix)
-{
-  const char *tmp = strstr (str, suffix);
-  if (!tmp)
-    return 0;
-
-  return str + strlen (str) - strlen (suffix) == tmp;
-}
-
-static void
-write_core_variables (PicoSAT * picosat, FILE * file)
-{
-  int i, max_idx = picosat_variables (picosat), count = 0;
-  for (i = 1; i <= max_idx; i++)
-    if (picosat_corelit (picosat, i))
-      {
-	fprintf (file, "%d\n", i);
-	count++;
-      }
-
-  if (verbose)
-    fprintf (output, "c found and wrote %d core variables\n", count);
-}
-
-static int
-next_assumption (int start)
-{
-  char * arg, c;
-  int res;
-  res = start + 1;
-  while (res < sargc)
-  {
-    arg = sargv[res++];
-    if (!strcmp (arg, "-a"))
-      {
-	assert (res < sargc);
-	break;
-      }
-
-    if (arg[0] == '-') {
-      c = arg[1];
-      if (c == 'l' || c == 'i' || c == 's' || c == 'o' || c == 't' ||
-	  c == 'T' || c == 'r' || c == 'R' || c == 'c' || c == 'V' ||
-	  c == 'U' || c == 'A') res++;
-    }
-  }
-  if (res >= sargc) res = 0;
-  return res;
-}
-
-static void
-write_failed_assumptions (PicoSAT * picosat, FILE * file)
-{
-  int i, lit, count = 0;
-#ifndef NDEBUG
-  int max_idx = picosat_variables (picosat);
-#endif
-  i = 0;
-  while ((i = next_assumption (i))) {
-    lit = atoi (sargv[i]);
-    if (!picosat_failed_assumption (picosat, lit)) continue;
-    fprintf (file, "%d\n", lit);
-    count++;
-  }
-  if (verbose)
-    fprintf (output, "c found and wrote %d failed assumptions\n", count);
-#ifndef NDEBUG
-  for (i = 1; i <= max_idx; i++)
-    if (picosat_failed_assumption (picosat, i))
-      count--;
-#endif
-  assert (!count);
-}
-
-static void
-write_to_file (PicoSAT * picosat, 
-               const char *name, 
-               const char *type,
-	       void (*writer) (PicoSAT *, FILE *))
-{
-  int pclose_file, zipped = has_suffix (name, ".gz");
-  FILE *file;
-  char *cmd;
-
-  if (zipped)
-    {
-      cmd = malloc (strlen (GZIP) + strlen (name));
-      sprintf (cmd, GZIP, name);
-      file = popen (cmd, "w");
-      free (cmd);
-      pclose_file = 1;
-    }
-  else
-    {
-      file = fopen (name, "w");
-      pclose_file = 0;
-    }
-
-  if (file)
-    {
-      if (verbose)
-	fprintf (output,
-		 "c\nc writing %s%s to '%s'\n",
-		 zipped ? "gzipped " : "", type, name);
-
-      writer (picosat, file);
-
-      if (pclose_file)
-	pclose (file);
-      else
-	fclose (file);
-    }
-  else
-    fprintf (output, "*** picosat: can not write to '%s'\n", name);
-}
-
-static int catched;
-
-static void (*sig_int_handler);
-static void (*sig_segv_handler);
-static void (*sig_abrt_handler);
-static void (*sig_term_handler);
-#ifndef NALLSIGNALS
-static void (*sig_kill_handler);
-static void (*sig_xcpu_handler);
-static void (*sig_xfsz_handler);
-#endif
-
-static void
-resetsighandlers (void)
-{
-  (void) signal (SIGINT, sig_int_handler);
-  (void) signal (SIGSEGV, sig_segv_handler);
-  (void) signal (SIGABRT, sig_abrt_handler);
-  (void) signal (SIGTERM, sig_term_handler);
-#ifndef NALLSIGNALS
-  (void) signal (SIGKILL, sig_kill_handler);
-  (void) signal (SIGXCPU, sig_xcpu_handler);
-  (void) signal (SIGXFSZ, sig_xfsz_handler);
-#endif
-}
-
-static int time_limit_in_seconds;
-static void (*sig_alarm_handler);
-static int ought_to_be_interrupted, interrupt_notified;
-
-static void
-alarm_triggered (int sig)
-{
-  (void) sig;
-  assert (sig == SIGALRM);
-  assert (time_limit_in_seconds);
-  assert (!ought_to_be_interrupted);
-  ought_to_be_interrupted = 1;
-  assert (!interrupt_notified);
-}
-
-static int
-interrupt_call_back (void * dummy)
-{
-  (void) dummy;
-  if (!ought_to_be_interrupted)
-    return 0;
-  if (!interrupt_notified)
-    {
-      if (verbose)
-	{
-	  picosat_message (picosat, 1, "");
-	  picosat_message (picosat, 1,
-	    "*** TIME LIMIT OF %d SECONDS REACHED ***",
-	    time_limit_in_seconds);
-	  picosat_message (picosat, 1, "");
-	}
-      interrupt_notified = 1;
-    }
-  return 1;
-}
-
-static void
-setalarm ()
-{
-  assert (time_limit_in_seconds > 0);
-  sig_alarm_handler = signal (SIGALRM, alarm_triggered);
-  alarm (time_limit_in_seconds);
-  assert (picosat);
-  picosat_set_interrupt (picosat, 0, interrupt_call_back);
-}
-
-static void
-resetalarm ()
-{
-  assert (time_limit_in_seconds > 0);
-  (void) signal (SIGALRM, sig_term_handler);
-}
-
-static void
-message (int sig)
-{
-  picosat_message (picosat, 1, "");
-  picosat_message (picosat, 1, "*** CAUGHT SIGNAL %d ***", sig);
-  picosat_message (picosat, 1, "");
-}
-
-static void
-catch (int sig)
-{
-  if (!catched)
-    {
-      message (sig);
-      catched = 1;
-      picosat_stats (picosat);
-      message (sig);
-    }
-
-  resetsighandlers ();
-  raise (sig);
-}
-
-static void
-setsighandlers (void)
-{
-  sig_int_handler = signal (SIGINT, catch);
-  sig_segv_handler = signal (SIGSEGV, catch);
-  sig_abrt_handler = signal (SIGABRT, catch);
-  sig_term_handler = signal (SIGTERM, catch);
-#ifndef NALLSIGNALS
-  sig_kill_handler = signal (SIGKILL, catch);
-  sig_xcpu_handler = signal (SIGXCPU, catch);
-  sig_xfsz_handler = signal (SIGXFSZ, catch);
-#endif
-}
-
-#define USAGE \
-"usage: picosat [ <option> ... ] [ <input> ]\n" \
-"\n" \
-"where <option> is one of the following\n" \
-"\n" \
-"  -h           print this command line option summary and exit\n" \
-"  --version    print version and exit\n" \
-"  --config     print build configuration and exit\n" \
-"\n" \
-"  -v           enable verbose output\n" \
-"  -f           ignore invalid header\n" \
-"  -n           do not print satisfying assignment\n" \
-"  -p           print formula in DIMACS format and exit\n" \
-"  --plain      disable preprocessing (failed literal probing)\n" \
-"  -a <lit>     start with an assumption\n" \
-"  -l <limit>   set decision limit (no limit per default)\n" \
-"  -L <limit>   set time limit in seconds (no limit per default)\n" \
-"  -P <limit>   set propagation limit (no limit per default)\n" \
-"  -i [0-3]     [0-3]=[FALSE,TRUE,JWH,RAND] initial phase (default 2=JWH)\n" \
-"  -s <seed>    set random number generator seed (default 0)\n" \
-"  -o <output>  set output file (<stdout> per default)\n" \
-"  -t <trace>   generate compact proof trace file\n" \
-"  -T <trace>   generate extended proof trace file\n" \
-"  -r <trace>   generate reverse unit propagation proof file\n" \
-"  -R <trace>   generate reverse unit propagation proof file incrementally\n" \
-"  -c <core>    generate clausal core file in DIMACS format\n" \
-"  -V <core>    generate file listing core variables\n" \
-"  -U <core>    generate file listing used variables\n" \
-"  -A <core>    generate file listing failed assumptions\n" \
-"\n" \
-"  --all        enumerate all solutions\n" \
-"  --partial    generate and print only partial assignment\n" \
-"\n" \
-"and <input> is an optional input file in DIMACS format.\n"
-
-int
-picosat_main (int argc, char **argv)
-{
-  int res, done, err, print_satisfying_assignment, force, print_formula;
-  const char *compact_trace_name, *extended_trace_name, * rup_trace_name;
-  int assumption, assumptions, defaultphase, allsat, partial, plain;
-  const char * clausal_core_name, * variable_core_name;
-  const char *input_name, *output_name;
-  const char * failed_assumptions_name;
-  int close_input, pclose_input;
-  long long propagation_limit;
-  int i, decision_limit;
-  double start_time;
-  long long sols;
-  unsigned seed;
-  FILE *file;
-  int trace;
-
-  start_time = picosat_time_stamp ();
-
-  sargc = argc;
-  sargv = argv;
-
-  clausal_core_name = 0;
-  variable_core_name = 0;
-  failed_assumptions_name = 0;
-  output_name = 0;
-  compact_trace_name = 0;
-  extended_trace_name = 0;
-  rup_trace_name = 0;
-  incremental_rup_file = 0;
-  close_input = 0;
-  pclose_input = 0;
-  input_name = "<stdin>";
-  input = stdin;
-  output = stdout;
-  verbose = 0;
-  done = err = 0;
-  decision_limit = -1;
-  propagation_limit = -1;
-  defaultphase = 2;
-  assumptions = 0;
-  force = 0;
-  allsat = 0;
-  partial = 0;
-  trace = 0;
-  plain = 0;
-  seed = 0;
-  sols= 0;
-
-  picosat = 0;
-
-  print_satisfying_assignment = 1;
-  print_formula = 0;
-
-  for (i = 1; !done && !err && i < argc; i++)
-    {
-      if (!strcmp (argv[i], "-h"))
-	{
-	  fputs (USAGE, output);
-	  done = 1;
-	}
-      else if (!strcmp (argv[i], "--version"))
-	{
-	  fprintf (output, "%s\n", picosat_version ());
-	  done = 1;
-	}
-      else if (!strcmp (argv[i], "--config"))
-	{
-	  fprintf (output, "%s\n", picosat_config ());
-	  done = 1;
-	}
-      else if (!strcmp (argv[i], "-v"))
-	{
-	  verbose++;
-	}
-      else if (!strcmp (argv[i], "--plain"))
-	{
-	  plain = 1;
-	}
-      else if (!strcmp (argv[i], "-f"))
-	{
-	  force = 1;
-	}
-      else if (!strcmp (argv[i], "-n"))
-	{
-	  print_satisfying_assignment = 0;
-	}
-      else if (!strcmp (argv[i], "--partial"))
-	{
-	  partial = 1;
-	}
-      else if (!strcmp (argv[i], "-p"))
-	{
-	  print_formula = 1;
-	}
-      else if (!strcmp (argv[i], "-l"))
-	{
-	  if (++i == argc)
-	    {
-	      fprintf (output, "*** picosat: argument to '-l' missing\n");
-	      err = 1;
-	    }
-	  else
-	    decision_limit = atoi (argv[i]);
-	}
-      else if (!strcmp (argv[i], "-L"))
-	{
-	  if (++i == argc)
-	    {
-	      fprintf (output, "*** picosat: argument to '-L' missing\n");
-	      err = 1;
-	    }
-	  else
-	    {
-	      time_limit_in_seconds = atoi (argv[i]);
-	      if (time_limit_in_seconds <= 0)
-		{
-		  fprintf (output, "*** picosat: invalid '-L' argument\n");
-		  err = 1;
-		}
-	    }
-	}
-      else if (!strcmp (argv[i], "-P"))
-	{
-	  if (++i == argc)
-	    {
-	      fprintf (output, "*** picosat: argument to '-P' missing\n");
-	      err = 1;
-	    }
-	  else
-	    propagation_limit = atoll (argv[i]);
-	}
-      else if (!strcmp (argv[i], "-i"))
-	{
-	  if (++i == argc)
-	    {
-	      fprintf (output, "*** picosat: argument to '-i' missing\n");
-	      err = 1;
-	    }
-	  else if (!argv[i][1] && ('0' <= argv[i][0] && argv[i][0] <= '3'))
-	    {
-	      defaultphase = argv[i][0] - '0';
-	    }
-	  else
-	    {
-	      fprintf (output, "*** picosat: invalid argument to '-i'\n");
-	      err = 1;
-	    }
-	}
-      else if (!strcmp (argv[i], "-a"))
-	{
-	  if (++i == argc)
-	    {
-	      fprintf (output, "*** picosat: argument to '-a' missing\n");
-	      err = 1;
-	    }
-	  else if (!atoi (argv[i]))
-	    {
-	      fprintf (output, "*** picosat: argument to '-a' zero\n");
-	      err = 1;
-	    }
-	  else
-	    {
-	      /* Handle assumptions further down
-	       */
-	      assumptions++;
-	    }
-	}
-      else if (!strcmp (argv[i], "--all"))
-	{
-	  allsat = 1;
-	}
-      else if (!strcmp (argv[i], "-s"))
-	{
-	  if (++i == argc)
-	    {
-	      fprintf (output, "*** picosat: argument to '-s' missing\n");
-	      err = 1;
-	    }
-	  else
-	    seed = atoi (argv[i]);
-	}
-      else if (!strcmp (argv[i], "-o"))
-	{
-	  if (output_name)
-	    {
-	      fprintf (output,
-		       "*** picosat: "
-		       "multiple output files '%s' and '%s'\n",
-		       output_name, argv[i]);
-	      err = 1;
-	    }
-	  else if (++i == argc)
-	    {
-	      fprintf (output, "*** picosat: argument ot '-o' missing\n");
-	      err = 1;
-	    }
-	  else if (!(file = fopen (argv[i], "w")))
-	    {
-	      fprintf (output,
-		       "*** picosat: "
-		       "can not write output file '%s'\n", argv[i]);
-	      err = 1;
-	    }
-	  else
-	    {
-	      output_name = argv[i];
-	      output = file;
-	    }
-	}
-      else if (!strcmp (argv[i], "-t"))
-	{
-	  if (compact_trace_name)
-	    {
-	      fprintf (output,
-		       "*** picosat: "
-		       "multiple compact trace files '%s' and '%s'\n",
-		       compact_trace_name, argv[i]);
-	      err = 1;
-	    }
-	  else if (++i == argc)
-	    {
-	      fprintf (output, "*** picosat: argument ot '-t' missing\n");
-	      err = 1;
-	    }
-	  else
-	    {
-	      compact_trace_name = argv[i];
-	      trace = 1;
-	    }
-	}
-      else if (!strcmp (argv[i], "-T"))
-	{
-	  if (extended_trace_name)
-	    {
-	      fprintf (output,
-		       "*** picosat: "
-		       "multiple extended trace files '%s' and '%s'\n",
-		       extended_trace_name, argv[i]);
-	      err = 1;
-	    }
-	  else if (++i == argc)
-	    {
-	      fprintf (output, "*** picosat: argument ot '-T' missing\n");
-	      err = 1;
-	    }
-	  else
-	    {
-	      extended_trace_name = argv[i];
-	      trace = 1;
-	    }
-	}
-      else if (!strcmp (argv[i], "-r"))
-	{
-	  if (rup_trace_name)
-	    {
-	      fprintf (output,
-		       "*** picosat: "
-		       "multiple RUP trace files '%s' and '%s'\n",
-		       rup_trace_name, argv[i]);
-	      err = 1;
-	    }
-	  else if (++i == argc)
-	    {
-	      fprintf (output, "*** picosat: argument ot '-r' missing\n");
-	      err = 1;
-	    }
-	  else
-	    {
-	      rup_trace_name = argv[i];
-	      trace = 1;
-	    }
-	}
-      else if (!strcmp (argv[i], "-R"))
-	{
-	  if (rup_trace_name)
-	    {
-	      fprintf (output,
-		       "*** picosat: "
-		       "multiple RUP trace files '%s' and '%s'\n",
-		       rup_trace_name, argv[i]);
-	      err = 1;
-	    }
-	  else if (++i == argc)
-	    {
-	      fprintf (output, "*** picosat: argument ot '-R' missing\n");
-	      err = 1;
-	    }
-	  else if (!(file = fopen (argv[i], "w")))
-	    {
-	      fprintf (output,
-		       "*** picosat: can not write to '%s'\n", argv[i]);
-	      err = 1;
-	    }
-	  else
-	    {
-	      rup_trace_name = argv[i];
-	      incremental_rup_file = file;
-	    }
-	}
-      else if (!strcmp (argv[i], "-c"))
-	{
-	  if (clausal_core_name)
-	    {
-	      fprintf (output,
-		       "*** picosat: "
-		       "multiple clausal core files '%s' and '%s'\n",
-		       clausal_core_name, argv[i]);
-	      err = 1;
-	    }
-	  else if (++i == argc)
-	    {
-	      fprintf (output, "*** picosat: argument ot '-c' missing\n");
-	      err = 1;
-	    }
-	  else
-	    {
-	      clausal_core_name = argv[i];
-	      trace = 1;
-	    }
-	}
-      else if (!strcmp (argv[i], "-V"))
-	{
-	  if (variable_core_name)
-	    {
-	      fprintf (output,
-		       "*** picosat: "
-		       "multiple variable core files '%s' and '%s'\n",
-		       variable_core_name, argv[i]);
-	      err = 1;
-	    }
-	  else if (++i == argc)
-	    {
-	      fprintf (output, "*** picosat: argument ot '-V' missing\n");
-	      err = 1;
-	    }
-	  else
-	    {
-	      variable_core_name = argv[i];
-	      trace = 1;
-	    }
-	}
-      else if (!strcmp (argv[i], "-A"))
-	{
-	  if (failed_assumptions_name)
-	    {
-	      fprintf (output,
-		       "*** picosat: "
-		       "multiple failed assumptions files '%s' and '%s'\n",
-		       failed_assumptions_name, argv[i]);
-	      err = 1;
-	    }
-	  else if (++i == argc)
-	    {
-	      fprintf (output, "*** picosat: argument ot '-A' missing\n");
-	      err = 1;
-	    }
-	  else
-	    failed_assumptions_name = argv[i];
-	}
-      else if (argv[i][0] == '-')
-	{
-	  fprintf (output,
-		   "*** picosat: "
-		   "unknown command line option '%s' (try '-h')\n", argv[i]);
-	  err = 1;
-	}
-      else if (close_input || pclose_input)
-	{
-	  fprintf (output,
-		   "*** picosat: "
-		   "multiple input files '%s' and '%s'\n",
-		   input_name, argv[i]);
-	  err = 1;
-	}
-      else if (has_suffix (argv[i], ".gz"))
-	{
-	  char *cmd = malloc (strlen (GUNZIP) + strlen (argv[i]));
-	  sprintf (cmd, GUNZIP, argv[i]);
-	  if ((file = popen (cmd, "r")))
-	    {
-	      input_name = argv[i];
-	      pclose_input = 1;
-	      input = file;
-	    }
-	  else
-	    {
-	      fprintf (output,
-		       "*** picosat: "
-		       "can not read compressed input file '%s'\n", argv[i]);
-	      err = 1;
-	    }
-	  free (cmd);
-	}
-      else if (has_suffix (argv[i], ".bz2"))
-	{
-	  char *cmd = malloc (strlen (BUNZIP2) + strlen (argv[i]));
-	  sprintf (cmd, BUNZIP2, argv[i]);
-	  if ((file = popen (cmd, "r")))
-	    {
-	      input_name = argv[i];
-	      pclose_input = 1;
-	      input = file;
-	    }
-	  else
-	    {
-	      fprintf (output,
-		       "*** picosat: "
-		       "can not read compressed input file '%s'\n", argv[i]);
-	      err = 1;
-	    }
-	  free (cmd);
-	}
-      else if (!(file = fopen (argv[i], "r")))	/* TODO .gz ? */
-	{
-	  fprintf (output,
-		   "*** picosat: can not read input file '%s'\n", argv[i]);
-	  err = 1;
-	}
-      else
-	{
-	  input_name = argv[i];
-	  close_input = 1;
-	  input = file;
-	}
-    }
-
-  if (allsat && partial)
-    {
-      fprintf (output,
-	       "*** picosat: can not combine '--all' and '--partial'");
-      err = 1;
-    }
-
-  res = PICOSAT_UNKNOWN;
-
-  if (!done && !err)
-    {
-      const char *err_msg;
-
-      if (verbose)
-	{
-	  fprintf (output,
-		   "c PicoSAT SAT Solver Version %s\n",
-		   picosat_version ());
-
-	  fprintf (output, "c %s\n", picosat_copyright ());
-	  fprintf (output, "c %s\n", picosat_config ());
-	}
-
-      picosat = picosat_init ();
-
-      if (verbose)
-	setsighandlers ();
-
-      if (time_limit_in_seconds)
-	setalarm ();
-
-      picosat_enter (picosat);
-
-      if (output_name)
-	picosat_set_output (picosat, output);
-
-      picosat_set_verbosity (picosat, verbose);
-      picosat_set_plain (picosat, plain);
-
-      if (verbose) fputs ("c\n", output);
-
-      if (trace)
-	{
-	  if (verbose)
-	    fprintf (output, "c tracing proof\n");
-	  picosat_enable_trace_generation (picosat);
-	}
-
-      if (defaultphase)
-	{
-	  if (verbose)
-	    fprintf (output, "c using %d as default phase\n", defaultphase);
-	  picosat_set_global_default_phase (picosat, defaultphase);
-	}
-
-      if (propagation_limit >= 0)
-	{
-	  if (verbose)
-	    fprintf (output, "c propagation limit of %lld propagations\n",
-	             propagation_limit);
-	  picosat_set_propagation_limit (picosat, 
-	    (unsigned long long) propagation_limit);
-	}
-
-      if (partial) 
-	{
-	  if (verbose)
-	    fprintf (output, 
-	      "c saving original clauses for partial assignment\n");
-
-	  picosat_save_original_clauses (picosat);
-	}
-
-      if (verbose)
-	fprintf (output, "c\nc parsing %s\n", input_name);
-
-      if (verbose)
-	fflush (output);
-
-      if ((err_msg = parse (picosat, force)))
-	{
-	  fprintf (output, "%s:%d: %s\n", input_name, lineno, err_msg);
-	  err = 1;
-	}
-      else
-	{
-NEXT_SOLUTION:
-	  if (assumptions)
-	    {
-	      i = 0;
-	      while ((i = next_assumption (i)))
-		{
-		  assert (i < argc);
-		  assumption = atoi (argv[i]);
-		  assert (assumption);
-
-		  picosat_assume (picosat, assumption);
-
-		  if (verbose)
-		    fprintf (output, "c assumption %d\n", assumption);
-		}
-	    }
-
-	  if (print_formula)
-	    {
-	      picosat_print (picosat, output);
-	    }
-	  else
-	    {
-	      if (verbose)
-		fprintf (output,
-			 "c initialized %u variables\n"
-			 "c found %u non trivial clauses\n",
-			 picosat_variables (picosat),
-			 picosat_added_original_clauses (picosat));
-
-	      picosat_set_seed (picosat, seed);
-	      if (verbose)
-		fprintf (output,
-			 "c\nc random number generator seed %u\n", 
-			 seed);
-
-	      res = picosat_sat (picosat, decision_limit);
-
-	      if (res == PICOSAT_UNSATISFIABLE)
-		{
-
-		  if (allsat)
-		    fprintf (output, "s SOLUTIONS %lld\n", sols);
-		  else
-		    fputs ("s UNSATISFIABLE\n", output);
-
-		  fflush (output);
-
-		  if (compact_trace_name)
-		    write_to_file (picosat,
-		                   compact_trace_name,
-				   "compact trace", 
-				   picosat_write_compact_trace);
-
-		  if (extended_trace_name)
-		    write_to_file (picosat,
-		                   extended_trace_name,
-				   "extended trace", 
-				   picosat_write_extended_trace);
-
-		  if (!incremental_rup_file && rup_trace_name)
-		    write_to_file (picosat,
-		                   rup_trace_name,
-				   "rup trace", 
-				   picosat_write_rup_trace);
-
-		  if (clausal_core_name)
-		    write_to_file (picosat,
-		                   clausal_core_name, 
-				   "clausal core",
-				   picosat_write_clausal_core);
-
-		  if (variable_core_name)
-		    write_to_file (picosat,
-		                   variable_core_name, 
-				   "variable core",
-				   write_core_variables);
-
-		  if (failed_assumptions_name)
-		    write_to_file (picosat,
-		                   failed_assumptions_name,
-		                   "failed assumptions", 
-				   write_failed_assumptions);
-		}
-	      else if (res == PICOSAT_SATISFIABLE)
-		{
-	          if (allsat)
-		    {
-		      sols++;
-		      if (verbose)
-			fprintf (output, "c\nc solution %lld\nc\n", sols);
-		    }
-
-		  if (!allsat || print_satisfying_assignment)
-		    fputs ("s SATISFIABLE\n", output);
-
-		  if (!allsat || verbose || print_satisfying_assignment)
-		    fflush (output);
-
-		  if (print_satisfying_assignment)
-		    printa (picosat, partial);
-
-		  if (allsat)
-		    {
-		      blocksol (picosat);
-		      goto NEXT_SOLUTION;
-		    }
-		}
-	      else
-		{
-		  fputs ("s UNKNOWN\n", output);
-
-		  if (allsat && verbose)
-		    fprintf (output,
-			     "c\nc limit reached after %lld solutions\n",
-			     sols);
-		  fflush (output);
-		}
-	    }
-	}
-
-      if (!err && verbose)
-	{
-	  fputs ("c\n", output);
-	  picosat_stats (picosat);
-	  fprintf (output,
-	           "c %.1f seconds total run time\n",
-		   picosat_time_stamp () - start_time);
-	}
-
-      if (sol)
-	{
-	  free (sol);
-	  sol = 0;
-	}
-
-      picosat_leave (picosat);
-
-      if (time_limit_in_seconds)
-	resetalarm ();
-
-      if (verbose)
-	resetsighandlers ();
-
-      picosat_reset (picosat);
-    }
-
-  if (incremental_rup_file)
-    fclose (incremental_rup_file);
-
-  if (close_input)
-    fclose (input);
-
-  if (pclose_input)
-    pclose (input);
-
-  if (output_name)
-    fclose (output);
-
-  return res;
-}
diff --git a/test/picosat-965/configure.sh b/test/picosat-965/configure.sh
deleted file mode 100755
index a82cfe87..00000000
--- a/test/picosat-965/configure.sh
+++ /dev/null
@@ -1,150 +0,0 @@
-#!/bin/sh
-
-satcompetition=no
-
-log=no
-debug=no
-stats=undefined
-trace=undefined
-static=yes
-shared=no
-thirtytwobit=no
-static=no
-rcode=no
-
-while [ $# -gt 0 ]
-do
-  case $1 in
-    -g|--debug) debug=yes;;
-    -O|--optimize) debug=no;;
-    -l|--log) log=yes;;
-    -s|--stats) stats=yes;;
-    -t|--trace) trace=yes;;
-    --no-stats) stats=no;;
-    --no-trace) trace=no;;
-    --no-rcode) rcode=no;;
-    --rcode) rcode=yes;;
-    -32|--32|-m32) thirtytwobit=yes;;
-    -static|--static) static=yes;;
-    -shared|--shared) shared=yes;;
-    *) cat <<EOF
-usage: ./configure.sh [<option> ...]
-
-where <option> is one of the following:
-
-  -g|--debug           include debugging code and symbols
-  -O|--optimize        optimized compilation (default)
-  -l|--log             add low level logging code (default with '-g')
-  -s|--stats           more expensive statististcs (default with '-g')
-  -t|--trace           trace generation (more memory, default with '-g')
-  --no-stats           disable expensive stats
-  --no-trace           enable trace generation
-  -32|--32|-m32        compile for 32 bit machine even on 64 bit host
-  -rcode|--no-rcode    enable/disable compatibility for used in R exension
-  -static|--static     produce static binary
-  -shared|--shared     produce shared library
-EOF
-exit 1
-;;
-  esac
-shift
-done
-
-echo "version ... `cat VERSION`"
-
-if [ $satcompetition = yes ]
-then
-  debug=no
-  stats=no
-  trace=no
-  thirtytwobit=yes
-  static=yes
-  shared=no
-fi
-
-echo "debug ... $debug"
-echo "log ... $log"
-
-[ $stats = undefined ] && stats=$debug
-echo "stats ... $stats"
-
-[ $trace = undefined ] && trace=$debug
-echo "trace ... $trace"
-
-echo "static ... $static"
-
-echo "shared ... $shared"
-
-[ "X$CC" = X ] && CC=gcc
-
-if [ X"$CFLAGS" = X ]
-then
-  case X"$CC" in
-    *wine*|*mingw*) CFLAGS="-DNGETRUSAGE -DNALLSIGNALS";;
-    *);;
-  esac
-  [ $log = yes ] && CFLAGS="$CFLAGS -DLOGGING"
-  [ $stats = yes ] && CFLAGS="$CFLAGS -DSTATS"
-  [ $trace = yes ] && CFLAGS="$CFLAGS -DTRACE"
-  [ $static = yes ] && CFLAGS="$CFLAGS -static"
-  [ $rcode = yes ] && CFLAGS="$CFLAGS -DRCODE"
-  case X"$CC" in
-    X*gcc*)
-      CFLAGS="$CFLAGS -Wall -Wextra"
-      [ $thirtytwobit = yes ] && CFLAGS="$CFLAGS -m32"
-      if [ $debug = yes ]
-      then
-        CFLAGS="$CFLAGS -g3 -ggdb"
-      else
-	CFLAGS="$CFLAGS -DNDEBUG -O3"
-      fi
-      ;;
-    *)
-      if [ $debug = yes ]
-      then
-        CFLAGS="$CFLAGS -g"
-      else
-        CFLAGS="$CFLAGS -O"
-      fi
-      ;;
-  esac
-fi
-
-if [ $rcode = yes ]
-then
-  for rdoth in /usr/share/R/include/R.h $RINC undefined
-  do
-    [ -f $rdoth ] && break
-  done
-  if [ $rdoth = undefined ]
-  then
-    echo "R.h ... not found (add '-I' manually or 'RHEADER=...  ./configure')"
-  else
-    RINC="-I`dirname $rdoth`"
-    CFLAGS="$CFLAGS $RINC"
-    echo "R.h ... added '$RINC' include directive"
-  fi
-  TARGETS="libpicosat.a"
-else
-  TARGETS="picosat picomcs picomus picogcnf libpicosat.a"
-fi
-
-if [ $shared = yes ]
-then
-  TARGETS="$TARGETS libpicosat.so"
-  CFLAGS="$CFLAGS -fPIC"
-fi
-echo "targets ... $TARGETS"
-
-echo "cc ... $CC"
-
-echo "cflags ... $CFLAGS"
-
-printf "makefile ..."
-rm -f makefile
-sed \
-  -e "s,@CC@,$CC," \
-  -e "s,@CFLAGS@,$CFLAGS," \
-  -e "s,@TARGETS@,$TARGETS," \
-makefile.in > makefile
-echo " done"
diff --git a/test/picosat-965/main.c b/test/picosat-965/main.c
deleted file mode 100644
index 03fad79f..00000000
--- a/test/picosat-965/main.c
+++ /dev/null
@@ -1,7 +0,0 @@
-int picosat_main (int, char **);
-
-int
-main (int argc, char **argv)
-{
-  return picosat_main (argc, argv);
-}
diff --git a/test/picosat-965/makefile.in b/test/picosat-965/makefile.in
deleted file mode 100644
index 8e0e7403..00000000
--- a/test/picosat-965/makefile.in
+++ /dev/null
@@ -1,59 +0,0 @@
-CC=@CC@
-CFLAGS=@CFLAGS@
-
-all: @TARGETS@
-
-clean:
-	rm -f picosat picomcs picomus picogcnf
-	rm -f *.exe *.s *.o *.a *.so *.plist
-	rm -f makefile config.h
-	rm -f gmon.out *~ 
-
-analyze:
-	clang --analyze $(CFLAGS) *.c *.h
-
-picosat: libpicosat.a app.o main.o
-	$(CC) $(CFLAGS) -o $@ main.o app.o -L. -lpicosat
-
-picomcs: libpicosat.a picomcs.o
-	$(CC) $(CFLAGS) -o $@ picomcs.o -L. -lpicosat
-
-picomus: libpicosat.a picomus.o
-	$(CC) $(CFLAGS) -o $@ picomus.o -L. -lpicosat
-
-picogcnf: libpicosat.a picogcnf.o
-	$(CC) $(CFLAGS) -o $@ picogcnf.o -L. -lpicosat
-
-app.o: app.c picosat.h makefile
-	$(CC) $(CFLAGS) -c $<
-
-picomcs.o: picomcs.c picosat.h makefile
-	$(CC) $(CFLAGS) -c $<
-
-picomus.o: picomus.c picosat.h makefile
-	$(CC) $(CFLAGS) -c $<
-
-picogcnf.o: picogcnf.c picosat.h makefile
-	$(CC) $(CFLAGS) -c $<
-
-main.o: main.c picosat.h makefile
-	$(CC) $(CFLAGS) -c $<
-
-picosat.o: picosat.c picosat.h makefile
-	$(CC) $(CFLAGS) -c $<
-
-version.o: version.c config.h makefile
-	$(CC) $(CFLAGS) -c $<
-
-config.h: makefile VERSION mkconfig.sh # and actually picosat.c
-	rm -f $@; ./mkconfig.sh > $@
-
-libpicosat.a: picosat.o version.o
-	ar rc $@ picosat.o version.o
-	ranlib $@
-
-SONAME=-Xlinker -soname -Xlinker libpicosat.so
-libpicosat.so: picosat.o version.o
-	$(CC) $(CFLAGS) -shared -o $@ picosat.o version.o $(SONAME)
-
-.PHONY: all clean
diff --git a/test/picosat-965/mkconfig.sh b/test/picosat-965/mkconfig.sh
deleted file mode 100755
index 621210b9..00000000
--- a/test/picosat-965/mkconfig.sh
+++ /dev/null
@@ -1,35 +0,0 @@
-#!/bin/sh
-
-die () {
-   echo "*** mkconfig.sh: $*" 1>&2
-   exit 1
-}
-
-[ -f makefile ] || die "can not find 'makefile'"
-
-sed \
-  -e '/^C[A-Z]*=/!d' \
-  -e 's,^,#define PICOSAT_,' \
-  -e 's,= *, ",' \
-  -e 's,$,",' \
-  makefile
-
-id=""
-if [ -d .git -a -f .git/HEAD ]
-then
-  head="`awk 'NF == 1' .git/HEAD`"
-  if [ x"$head" = x ]
-  then
-    head="`awk '{print $2}' .git/HEAD`"
-    if [ ! x"$head" = x -a -f ".git/$head" ]
-    then
-      id=" `cat .git/$head`"
-    fi
-  else
-    id=" $head"
-  fi
-fi
-
-echo "#define PICOSAT_VERSION \"`cat VERSION`$id\""
-
-exit 0
diff --git a/test/picosat-965/picogcnf.c b/test/picosat-965/picogcnf.c
deleted file mode 100644
index 4d91bfae..00000000
--- a/test/picosat-965/picogcnf.c
+++ /dev/null
@@ -1,165 +0,0 @@
-/****************************************************************************
-Copyright (c) 2011-2012, Armin Biere, Johannes Kepler University.
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to
-deal in the Software without restriction, including without limitation the
-rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
-sell copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-IN THE SOFTWARE.
-****************************************************************************/
-
-#include "picosat.h"
-
-#include <stdio.h>
-#include <assert.h>
-#include <stdarg.h>
-#include <ctype.h>
-#include <limits.h>
-
-#if 1
-#define LOG(ARGS...) do { } while (0)
-#else
-#define LOG(ARGS...) do { printf (##ARGS); } while (0)
-#endif
-
-static int reductions, ngroups;
-
-static PicoSAT * ps;
-
-static void die (const char * fmt, ...) {
-  va_list ap;
-  fprintf (stderr, "*** picogcnf: ");
-  va_start (ap, fmt);
-  vfprintf (stderr, fmt, ap);
-  va_end (ap);
-  fputc ('\n', stderr);
-  exit (1);
-}
-
-static void msg (const char * fmt, ...) {
-  va_list ap;
-  printf ("c [picogcnf] %.2f seconds: ", picosat_time_stamp ());
-  va_start (ap, fmt);
-  vprintf (fmt, ap);
-  va_end (ap);
-  fputc ('\n', stdout);
-  fflush (stdout);
-}
-
-static double percent (double a, double b) { return b?100.0*a/b:0.0; }
-
-static void callback (void * dummy, const int * mus) {
-  int remaining;
-  const int * p;
-  (void) dummy;
-  remaining = 0;
-  for (p = mus; *p; p++) remaining++;
-  assert (remaining <= ngroups);
-  msg ("<%d> reduction to %d out of %d (%.0f%%)",
-       ++reductions, remaining, ngroups, percent (remaining, ngroups));
-}
-
-int main (int argc, char ** argv) {
-  int ch, nvars, sclauses, nclauses, sign, lit, group, res;
-  const int * mus, * p;
-  FILE * file;
-  if (argc != 2) die ("usage: picogcnf <gcnf-file>");
-  if (!(file = fopen (argv[1], "r"))) die ("can not read '%s'", argv[1]);
-  ps = picosat_init ();
-HEADER:
-  ch = getc (file);
-  if (ch == 'c') {
-    while ((ch = getc (file)) != '\n')
-      if (ch == EOF) die ("unexpected EOF");
-    goto HEADER;
-  }
-  if (ch != 'p' || 
-      getc (file) != ' ' ||
-      fscanf (file, "gcnf %d %d %d", &nvars, &sclauses, &ngroups) != 3)
-    die ("invalid header");
-  nclauses = lit = 0;
-  group = INT_MAX;
-  LOG ("p gcnf %d %d %d\n", nvars, sclauses, ngroups);
-LIT:
-  ch = getc (file);
-  if (ch == EOF) {
-    if (lit) die ("zero missing");
-    if (nclauses < sclauses) die ("clauses missing");
-    goto DONE;
-  }
-  if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r') goto LIT;
-  if (lit) {
-    if (ch == '-') {
-      sign = -1;
-      ch = getc (file);
-    } else sign = 1;
-    lit = ch - '0';
-    while (isdigit (ch = getc (file)))
-      lit = 10 * lit + ch - '0';
-    if (lit > nvars) die ("maximum variable exceeded");
-    lit *= sign;
-    if (lit) {
-      LOG ("%d ", lit);
-    } else {
-      LOG ("0\n");
-      group = INT_MAX;
-      nclauses++;
-    }
-    picosat_add (ps, lit);
-  } else if (ch == '{') {
-    if (nclauses == sclauses) die ("too many clauses");
-    if (group < INT_MAX) die ("multiple groups per clause");
-GROUP:
-    ch = getc (file);
-    if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r') goto GROUP;
-    if (!isdigit (ch)) die ("group does not start with digit");
-    group = ch - '0';
-    while (isdigit (ch = getc (file)))
-      group = 10 * group + (ch - '0');
-    if (group > ngroups) die ("maximal group exceeded");
-    while (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r')
-      ch = getc (file);
-    if (ch != '}') die ("expected '}'");
-    LOG ("{%d} ", group);
-    if (group) picosat_add (ps, -(nvars + group));
-    lit = INT_MAX;
-  } else die ("expected '{'");
-  goto LIT;
-DONE:
-  fclose (file);
-  for (lit = nvars + 1; lit <= nvars + ngroups; lit++) picosat_assume (ps, lit);
-  res = picosat_sat (ps, -1);
-  msg ("first call to SAT solver returned");
-  if (res == 10) printf ("s SATISFIABLE\n");
-  else if (res == 20) printf ("s UNSATISFIABLE\n");
-  else printf ("s UNKNOWN\n");
-  fflush (stdout);
-  if (res == 20) {
-    mus = picosat_mus_assumptions (ps, 0, callback, 1);
-    assert (mus);
-    printf ("v");
-    for (p = mus; (lit = *p); p++) {
-      assert (nvars + 1 <= lit && lit <= nvars + ngroups);
-      printf (" %d", lit - nvars);
-    }
-    printf (" 0\n");
-    fflush (stdout);
-  }
-  msg ("max memory %.1f MB",
-       picosat_max_bytes_allocated (ps) / (double)(1<<20));
-  picosat_reset (ps);
-  msg ("%d reductions", reductions);
-  return res;
-}
diff --git a/test/picosat-965/picomcs.c b/test/picosat-965/picomcs.c
deleted file mode 100644
index 3acf7bd7..00000000
--- a/test/picosat-965/picomcs.c
+++ /dev/null
@@ -1,334 +0,0 @@
-#include <assert.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <stdarg.h>
-#include <ctype.h>
-#include <string.h>
-#include <unistd.h>
-
-#include "picosat.h"
-
-typedef struct Clause { int cid, * lits; struct Clause * next; } Clause;
-typedef struct MCS { int mid, * clauses; struct MCS * next; } MCS;
-
-static int nvars;
-static char * marked;
-
-static Clause * first_clause, * last_clause;
-static int nclauses, first_cid, last_cid;
-
-static MCS * first_mcs, * last_mcs;
-static int nmcs;
-
-static int * stk, szstk, nstk;
-
-static int verbose, join, noprint;
-
-static int lineno = 1, close_input;
-static const char * input_name;
-static FILE * input;
-
-static PicoSAT * ps;
-
-static void release_clauses (void) {
-  Clause * p, * next;
-  for (p = first_clause; p; p = next) {
-    next = p->next;
-    free (p->lits);
-    free (p);
-  }
-}
-
-static void release_mss (void) {
-  MCS * p, * next;
-  for (p = first_mcs; p; p = next) {
-    next = p->next;
-    free (p->clauses);
-    free (p);
-  }
-}
-
-static void release (void) {
-  release_clauses ();
-  release_mss ();
-  free (marked);
-  free (stk);
-}
-
-static void push_stack (int n) {
-  if (nstk == szstk)
-    stk = realloc (stk, (szstk = szstk ? 2*szstk : 1) * sizeof *stk);
-  stk[nstk++] = n;
-}
-
-static void push_clause (void) {
-  Clause * clause;
-  size_t bytes;
-  clause = malloc (sizeof *clause);
-  clause->cid = ++nclauses;
-  clause->next = 0;
-  push_stack (0);
-  bytes = nstk * sizeof *clause->lits;
-  clause->lits = malloc (bytes);
-  memcpy (clause->lits, stk, bytes);
-  if (last_clause) last_clause->next = clause;
-  else first_clause = clause;
-  last_clause = clause;
-  nstk = 0;
-}
-
-static void push_mcs (void) {
-  MCS * mcs;
-  size_t bytes;
-  mcs = malloc (sizeof *mcs);
-  mcs->mid = ++nmcs;
-  mcs->next = 0;
-  push_stack (0);
-  bytes = nstk * sizeof *mcs->clauses;
-  mcs->clauses = malloc (bytes);
-  memcpy (mcs->clauses, stk, bytes);
-  if (last_mcs) last_mcs->next = mcs;
-  else first_mcs = mcs;
-  last_mcs = mcs;
-  nstk = 0;
-}
-
-static int nextch (void) {
-  int res = getc (input);
-  if (res == '\n') lineno++;
-  return res;
-}
-
-static void msg (int level, const char * fmt, ...) {
-  va_list ap;
-  if (level > verbose) return;
-  printf ("c [picomcs] ");
-  va_start (ap, fmt);
-  vprintf (fmt, ap);
-  va_end (ap);
-  fputc ('\n', stdout);
-  fflush (stdout);
-}
-
-static const char * parse (void) {
-  int ch, expclauses, lit, sign;
-  size_t bytes;
-  msg (1, "parsing %s", input_name);
-COMMENTS:
-  ch = nextch ();
-  if (ch == 'c') {
-    while ((ch = nextch ()) != '\n')
-      if (ch == EOF) return "out of file in comment";
-    goto COMMENTS;
-  }
-  if (ch != 'p') 
-INVALID_HEADER:
-    return "invalid header";
-  ungetc (ch, input);
-  if (fscanf (input, "p cnf %d %d", &nvars, &expclauses) != 2)
-    goto INVALID_HEADER;
-  msg (1, "found 'p cnf %d %d' header", nvars, expclauses);
-  bytes = (1 + nvars + expclauses) * sizeof *marked;
-  marked = malloc (bytes);
-  memset (marked, 0, bytes);
-LIT:
-  ch = nextch ();
-  if (ch == ' '  || ch == '\n' || ch == '\t' || ch == '\r') goto LIT;
-  if (ch == EOF) {
-    assert (nclauses <= expclauses);
-    if (nclauses < expclauses) return "clauses missing";
-    return 0;
-  }
-  if (ch == '-') {
-    ch = nextch ();
-    if (!isdigit (ch)) return "expected digit after '-'";
-    if (ch == '0') return "expected positive digit after '-'";
-    sign = -1;
-  } else if (!isdigit (ch)) return "expected '-' or digit";
-  else sign = 1;
-  lit = ch - '0';
-  while (isdigit (ch = nextch ()))
-    lit = 10*lit + (ch - '0');
-  if (lit) {
-    if (lit > nvars) return "maximum variable index exceeded";
-    if (nclauses == expclauses) return "too many clauses";
-    push_stack (sign * lit);
-  } else {
-    assert (nclauses < expclauses);
-    push_clause ();
-  }
-  goto LIT;
-}
-
-#ifndef NDEBUG
-static void dump_clause (Clause * c) {
-  int * p, lit;
-  for (p = c->lits; (lit = *p); p++)
-    printf ("%d ", lit);
-  printf ("0\n");
-}
-
-void dump (void) {
-  Clause * p;
-  printf ("p cnf %d %d\n", nvars, nclauses);
-  for (p = first_clause; p; p = p->next)
-    dump_clause (p);
-}
-#endif
-
-static int clause2selvar (Clause * c) { 
-  int res = c->cid + nvars;
-  assert (first_cid <= res && res <= last_cid);
-  return res;
-}
-
-static void encode_clause (Clause * c) {
-  int * p, lit;
-  if (verbose >= 2) {
-    printf ("c [picomcs] encode clause %d :", c->cid);
-    printf (" %d", -clause2selvar (c));
-    for (p = c->lits; (lit = *p); p++) printf (" %d", lit);
-    fputc ('\n', stdout), fflush (stdout);
-  }
-  picosat_add (ps, -clause2selvar (c));
-  for (p = c->lits; (lit = *p); p++) picosat_add (ps, lit);
-  picosat_add (ps, 0);
-}
-
-static void encode (void) {
-  Clause * p;
-  first_cid = nvars + 1;
-  last_cid = nvars + nclauses;
-  msg (2, "selector variables range %d to %d", first_cid, last_cid);
-  for (p = first_clause; p; p = p->next)
-    encode_clause (p);
-  msg (1, "encoded %d clauses", nclauses);
-}
-
-static void camcs (void) {
-  int cid, i;
-  const int * mcs, * p;
-  msg (1, "starting to compute all minimal correcting sets");
-  while ((mcs = picosat_next_minimal_correcting_subset_of_assumptions (ps))) {
-    for (p = mcs; (cid = *p); p++)
-      push_stack (cid);
-    if (verbose >= 2) {
-      printf ("c [picomcs] mcs %d :", nmcs);
-      for (i = 0; i < nstk; i++) printf (" %d", stk[i] - nvars);
-      fputc ('\n', stdout);
-      fflush (stdout);
-    } else if (verbose && isatty (1)) {
-      printf ("\rc [picomcs] mcs %d", nmcs);
-      fflush (stdout);
-    }
-    push_mcs ();
-  }
-  if (verbose && isatty (1)) fputc ('\r', stdout);
-  msg (1, "found %d minimal correcting sets", nmcs);
-}
-
-static void cumcscb (void * state, int nmcs, int nhumus) {
-  int * ptr = state;
-  *ptr = nmcs;
-  ptr[0] = nmcs, ptr[1] = nhumus;
-  if (!verbose || (!isatty (1) && verbose == 1)) return;
-  if (verbose == 1) fputc ('\r', stdout);
-  printf ("c [picomcs] mcs %d humus %d", nmcs, nhumus);
-  if (verbose >= 2) fputc ('\n', stdout);
-  fflush (stdout);
-}
-
-static void cumcs (void) {
-  int stats[2], count, cid;
-  const int * humus, * p;
-  stats[0] = stats[1] = 0;
-  humus = picosat_humus (ps, cumcscb, stats);
-  if (isatty (1) && verbose == 1) fputc ('\n', stdout);
-  count = 0;
-  for (p = humus; (cid = *p); p++) {
-    if (marked[cid]) continue;
-    marked[cid] = 1;
-    count++;
-  }
-  assert (count == stats[1]);
-  msg (1, 
-    "computed union of minimal correcting sets of size %d with %d mcs", 
-    stats[1], stats[0]);
-}
-
-static void
-print_umcs (void) {
-  int cid;
-  printf ("v");
-  for (cid = first_cid; cid <= last_cid; cid++)
-    if (marked[cid])
-      printf (" %d", cid - nvars);
-  printf (" 0\n");
-}
-
-static void
-print_mcs (MCS * mcs) 
-{
-  const int * p;
-  int cid;
-  printf ("v");
-  for (p = mcs->clauses; (cid = *p); p++)
-    printf (" %d", cid - nvars);
-  printf (" 0\n");
-}
-
-static void
-print_all_mcs (void)
-{
-  MCS * p;
-  for (p = first_mcs; p; p = p->next)
-    print_mcs (p);
-}
-
-int main (int argc, char ** argv) {
-  const char * perr;
-  int i, res;
-  for (i = 1; i < argc; i++) {
-    if (!strcmp (argv[i], "-h")) {
-      printf ("usage: picomcs [-h][-v][-j][-n][<input>]\n");
-      exit (0);
-    }
-    else if (!strcmp (argv[i], "-v")) verbose++;
-    else if (!strcmp (argv[i], "-j")) join = 1;
-    else if (!strcmp (argv[i], "-n")) noprint = 1;
-    else if (argv[i][0] == '-') {
-      fprintf (stderr, "*** picomcs: invalid option '%s'\n", argv[i]);
-      exit (1);
-    } else if (input_name) {
-      fprintf (stderr, "*** picomcs: two input files specified\n");
-      exit (1);
-    } else if (!(input = fopen ((input_name = argv[i]), "r"))) {
-      fprintf (stderr, "*** picomcs: can not read '%s'\n", argv[i]);
-      exit (1);
-    } else close_input = 1;
-  }
-  if (!input_name) input_name = "<stdin>", input = stdin;
-  if ((perr = parse ())) {
-    fprintf (stderr, "%s:%d: parse error: %s\n", input_name, lineno, perr);
-    exit (1);
-  }
-  if (close_input) fclose (input);
-  ps = picosat_init ();
-  picosat_set_prefix (ps, "c [picosat] ");
-  encode ();
-  for (i = first_cid; i <= last_cid; i++) 
-    picosat_set_default_phase_lit (ps, i, 1);
-  for (i = first_cid; i <= last_cid; i++) picosat_assume (ps, i);
-  res = picosat_sat (ps, -1);
-  if (res == 10) printf ("s SATISFIABLE\n");
-  else printf ("s UNSATISFIABLE\n");
-  fflush (stdout);
-  if (join) cumcs (); else camcs ();
-  if (verbose) picosat_stats (ps);
-  picosat_reset (ps);
-  if (!noprint) {
-    if (join) print_umcs (); else print_all_mcs ();
-  }
-  release ();
-  return res;
-}
diff --git a/test/picosat-965/picomus.c b/test/picosat-965/picomus.c
deleted file mode 100644
index f92a2d58..00000000
--- a/test/picosat-965/picomus.c
+++ /dev/null
@@ -1,407 +0,0 @@
-/****************************************************************************
-Copyright (c) 2011-2014, Armin Biere, Johannes Kepler University.
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to
-deal in the Software without restriction, including without limitation the
-rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
-sell copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-IN THE SOFTWARE.
-****************************************************************************/
-
-#include "picosat.h"
-
-#include <stdio.h>
-#include <assert.h>
-#include <string.h>
-#include <stdarg.h>
-#include <ctype.h>
-
-#define MAXNONREDROUNDS 3
-#define MINCOREROUNDS 5
-#define MAXCOREROUNDS 100
-
-typedef struct Cls { int lit, red, * lits; } Cls;
-
-static int verbose, nowitness;
-static int fclose_input, pclose_input, close_output;
-static FILE * input_file, * output_file;
-static const char * input_name, * output_name;
-static int lineno = 1;
-static int nvars, nclauses;
-static Cls * clauses;
-static int * lits, nlits, szlits;
-static double start;
-static int reductions;
-
-static PicoSAT * ps;
-
-static int next (void) {
-  int res = fgetc (input_file);
-  if (res == '\n') lineno++;
-  return res;
-}
-
-static void msg (int level, const char * fmt, ...) {
-  va_list ap;
-  if (verbose < level) return;
-  fputs ("c [picomus] ", stdout);
-  va_start (ap, fmt);
-  vfprintf (stdout, fmt, ap);
-  va_end (ap);
-  fputc ('\n', stdout);
-  fflush (stdout);
-}
-
-static void warn (const char * fmt, ...) {
-  va_list ap;
-  if (verbose < 0) return;
-  fputs ("c [picomus] WARNING: ", stdout);
-  va_start (ap, fmt);
-  vfprintf (stdout, fmt, ap);
-  va_end (ap);
-  fputc ('\n', stdout);
-  fflush (stdout);
-}
-
-static const char * parse (void) {
-  int ch, n, lit, sign, i;
-  Cls * c;
-HEADER:
-  ch = next ();
-  if (ch == 'c') {
-    while ((ch = next ()) != '\n')
-      if (ch == EOF) return "EOF after 'c'";
-    goto HEADER;
-  }
-  if (ch == '\r') goto HEADER;
-  if (ch != 'p') return "expected 'c' or 'p'";
-  if (fscanf (input_file, " cnf %d %d", &nvars, &nclauses) != 2)
-    return "invalid header";
-  msg (1, "p cnf %d %d", nvars, nclauses);
-  clauses = calloc (nclauses, sizeof *clauses);
-  lit = n = 0;
-LIT:
-  ch = next ();
-  if (ch == ' ' || ch == '\n' || ch == '\t' || ch == '\r') goto LIT;
-  if (ch == 'c') {
-    while ((ch = next ()) != '\n')
-      if (ch == EOF) return "EOF after 'c'";
-    goto LIT;
-  }
-  if (ch == EOF) {
-    if (lit) return "zero missing";
-    if (n < nclauses) return "clauses missing";
-    return 0;
-  }
-  if (n == nclauses) return "too many clauses";
-  if (ch == '-') {
-    sign = -1;
-    ch = next ();
-    if (!isdigit (ch)) return "expected digit after '-'";
-  } else sign = 1;
-  if (!isdigit (ch)) return "expected digit";
-  lit = ch - '0';
-  while (isdigit (ch = next ()))
-    lit = 10 * lit + (ch - '0');
-  if (lit > nvars) return "maximum variable index exceeded";
-  if (lit) {
-    lit *= sign;
-    if (nlits == szlits) {
-      szlits = szlits ? 2 * szlits : 1;
-      lits = realloc (lits, szlits * sizeof *lits);
-    }
-    lits[nlits++] = lit;
-  } else {
-    c = clauses + n++;
-    c->lits = malloc ((nlits + 1) * sizeof *c->lits);
-    for (i = 0; i < nlits; i++)
-      c->lits[i] = lits[i];
-    c->lits[i] = 0;
-    nlits = 0;
-  }
-  goto LIT;
-}
-
-static void die (const char * fmt, ...) {
-  va_list ap;
-  fputs ("*** picomus: ", stdout);
-  va_start (ap, fmt);
-  vfprintf (stdout, fmt, ap);
-  va_end (ap);
-  fputc ('\n', stdout);
-  fflush (stdout);
-  exit (1);
-}
-
-static double percent (double a, double b) { return b?100.0*a/b:0.0; }
-
-static void callback (void * dummy, const int * mus) {
-  int remaining;
-  const int * p;
-  (void) dummy;
-  if (verbose <= 0) return;
-  remaining = 0;
-  for (p = mus; *p; p++) remaining++;
-  assert (remaining <= nclauses);
-  reductions++;
-  msg (1, "reduction %d to %d = %.0f%% out of %d after %.1f sec",
-       reductions,
-       remaining, percent (remaining, nclauses), nclauses,
-       picosat_time_stamp () - start);
-}
-
-static const char * USAGE =
-"picomus [-h][-v][-q] [ <input> [ <output> ] ]\n"
-"\n"
-"  -h  print this command line option summary\n"
-"  -v  increase verbosity level (default 0 = no messages)\n"
-"  -q  be quiet (no warnings nor messages)\n"
-"\n"
-"This tool is a SAT solver that uses the PicoSAT library to\n"
-"generate a 'minimal unsatisfiable core' also known as 'minimal\n"
-"unsatisfiable set' (MUS) of a CNF in DIMACS format.\n"
-"\n"
-"Both file arguments can be \"-\" and then denote <stdin> and\n"
-"<stdout> respectively.  If no input file is given <stdin> is used.\n"
-"If no output file is specified the MUS is computed and only printed\n"
-"to <stdout> in the format of the SAT competition 2011 MUS track.\n"
-"\n"
-"Note, that the 's ...' lines and in case the instance is satisfiable\n"
-"also the 'v ...' lines for the satisfying assignment are always\n"
-"printed to <stdout> (or not printed at all with '-q').\n"
-"\n"
-"If '-n' is specified satisfying assignment and MUS printing\n"
-"on <stdout> (using the 'v ...' format) is suppressed.\n"
-"The 's ...' line is still printed unless '-q' is specified.\n"
-"If <output> is specified an MUS is written to this file,\n"
-"even if '-n' or '-q' is used.\n"
-"\n"
-#ifndef TRACE
-"WARNING: PicosSAT is compiled without trace support.\n"
-"\n"
-"This typically slows down this MUS extractor, since\n"
-"it only relies on clause selector variables and\n"
-"can not make use of core extraction.  To enable\n"
-"trace generation use './configure.sh --trace' or\n"
-"'./configure.sh -O --trace' when building PicoSAT.\n"
-#else
-"Since trace generation code is included, this binary\n"
-"uses also core extraction in addition to clause selector\n"
-"variables.\n"
-#endif
-;
-
-int main (int argc, char ** argv) {
-  int i, * p, n, oldn, red, nonred, res, round, printed, len;
-  const char * err;
-  const int * q;
-  char * cmd;
-  Cls * c;
-#ifndef NDEBUG
-  int tmp;
-#endif
-  start = picosat_time_stamp ();
-  for (i = 1; i < argc; i++) {
-    if (!strcmp (argv[i], "-h")) {
-      fputs (USAGE, stdout);
-      exit (0);
-    } else if (!strcmp (argv[i], "-v")) {
-      if (verbose < 0) die ("'-v' option after '-q'");
-      verbose++;
-    } else if (!strcmp (argv[i], "-q")) {
-      if (verbose < 0) die ("two '-q' options");
-      if (verbose > 0) die ("'-q' option after '-v'");
-      verbose = -1;
-    } else if (!strcmp (argv[i], "-n")) nowitness = 1;
-    else if (argv[i][0] == '-' && argv[i][1]) 
-      die ("invalid command line option '%s'", argv[i]);
-    else if (output_name) die ("too many arguments");
-    else if (!input_name) input_name = argv[i];
-    else output_name = argv[i];
-  }
-  if (!output_name) warn ("no output file given");
-  if (input_name && strcmp (input_name, "-")) {
-    len = strlen (input_name);
-    if (len >= 3 && !strcmp (input_name + len - 3, ".gz")) {
-      cmd = malloc (len + 20);
-      sprintf (cmd, "gunzip -c %s 2>/dev/null", input_name);
-      input_file = popen (cmd, "r");
-      pclose_input = 1;
-      free (cmd);
-    } else input_file = fopen (input_name, "r"), fclose_input = 1;
-    if (!input_file) die ("can not read '%s'", input_name);
-  } else input_file = stdin, input_name = "-";
-  if ((err =  parse ())) {
-    fprintf (stdout, "%s:%d: %s\n", input_name, lineno, err);
-    fflush (stdout);
-    exit (1);
-  }
-  if (fclose_input) fclose (input_file);
-  if (pclose_input) pclose (input_file);
-  ps = picosat_init ();
-  picosat_set_prefix (ps, "c [picosat] ");
-  picosat_set_output (ps, stdout);
-  if (verbose > 1) picosat_set_verbosity (ps, verbose - 1);
-  printed = 0;
-  if (!picosat_enable_trace_generation (ps))
-    warn ("PicoSAT compiled without trace generation"),
-    warn ("core extraction disabled");
-  else {
-    n = nclauses;
-    nonred = 0;
-    for (round = 1; round <= MAXCOREROUNDS; round++) {
-      if (verbose > 1)
-	msg (1, "starting core extraction round %d", round);
-      picosat_set_seed (ps, round);
-      for (i = 0; i < nclauses; i++) {
-	c = clauses + i;
-	if (c->red) {
-	  picosat_add (ps, 1);
-	  picosat_add (ps, -1);
-	} else {
-	  for (p = c->lits; *p; p++)
-	    picosat_add (ps, *p);
-	}
-#ifndef NDEBUG
-	tmp = 
-#endif
-	picosat_add (ps, 0);
-	assert (tmp == i);
-      }
-      res = picosat_sat (ps, -1);
-      if (res == 10) { assert (round == 1); goto SAT; }
-      assert (res == 20);
-      if (!printed) {
-	assert (round == 1);
-	printed = 1;
-	if (verbose >= 0)
-	  printf ("s UNSATISFIABLE\n"),
-	  fflush (stdout);
-      }
-      for (i = 0; i < nclauses; i++) {
-	c = clauses + i;
-	if (c->red) { assert (!picosat_coreclause (ps, i)); continue; }
-	if (picosat_coreclause (ps, i)) continue;
-	c->red = 1;
-      }
-      oldn = n;
-      n = 0;
-      for (i = 0; i < nclauses; i++) if (!clauses[i].red) n++;
-      msg (1, "extracted core %d of size %d = %0.f%% out of %d after %.1f sec",
-	   round, n, percent (n, nclauses), nclauses,
-	   picosat_time_stamp () - start);
-      assert (oldn >= n);
-      picosat_reset (ps);
-      ps = picosat_init ();
-      picosat_set_prefix (ps, "c [picosat] ");
-      picosat_set_output (ps, stdout);
-      if (round >= MINCOREROUNDS) {
-	red = oldn - n;
-	if (red < 10 && (100*red + 99)/oldn < 2) {
-	  nonred++;
-	  if (nonred > MAXNONREDROUNDS) break;
-	}
-      }
-      if (round < MAXCOREROUNDS) picosat_enable_trace_generation (ps);
-    }
-  }
-  for (i = 0; i < nclauses; i++) {
-    c = clauses + i;
-    if (c->red) {
-      picosat_add (ps, 1);
-      picosat_add (ps, -1);
-#ifndef NDEBUG
-      tmp = 
-#endif
-      picosat_add (ps, 0);
-      assert (tmp == i);
-      continue;
-    }
-    c->lit = nvars + i + 1;
-    picosat_add (ps, -c->lit);
-    for (p = c->lits; *p; p++)
-      (void) picosat_add (ps, *p);
-#ifndef NDEBUG
-    tmp = 
-#endif
-    picosat_add (ps, 0);
-    assert (tmp == i);
-  }
-  for (i = 0; i < nclauses; i++) {
-    c = clauses + i;
-    if (c->red) continue;
-    picosat_assume (ps, c->lit);
-  }
-  res = picosat_sat (ps, -1);
-  if (res == 20) {
-    if (!printed && verbose >= 0)
-      printf ("s UNSATISFIABLE\n"), fflush (stdout);
-    for (i = 0; i < nclauses; i++) clauses[i].red = 1;
-    q = picosat_mus_assumptions (ps, 0, callback, 1);
-    while ((i = *q++)) {
-      i -= nvars + 1;
-      assert (0 <= i && i < nclauses);
-      clauses[i].red = 0;
-    }
-  } else {
-SAT:
-    assert (res == 10);
-    if (!printed && verbose >= 0)
-      printf ("s SATISFIABLE\n"), fflush (stdout);
-    if (!nowitness && verbose >= 0) {
-      for (i = 1; i <= nvars; i++)
-	printf ("v %d\n", ((picosat_deref (ps, i) < 0) ? -1 : 1) * i);
-      printf ("v 0\n");
-    }
-  }
-  if (verbose > 0) picosat_stats (ps);
-  picosat_reset (ps);
-  n = 0;
-  for (i = 0; i < nclauses; i++) if (!clauses[i].red) n++;
-  red = nclauses - n;
-  msg (1, "found %d redundant clauses %.0f%%", red, percent (red, nclauses));
-  if (res == 20)
-    msg (0, "computed MUS of size %d out of %d (%.0f%%)",
-	 n, nclauses, percent (n, nclauses));
-  if (output_name && strcmp (output_name, "-")) {
-    output_file = fopen (output_name, "w");
-    if (!output_file) die ("can not write '%s'", output_name);
-    close_output = 1;
-  } else if (output_name && !strcmp (output_name, "-")) output_file = stdout;
-  if (output_file) {
-    fprintf (output_file, "p cnf %d %d\n", nvars, n);
-    for (i = 0; i < nclauses; i++) 
-      if (!clauses[i].red) {
-	for (p = clauses[i].lits; *p; p++) fprintf (output_file, "%d ", *p);
-	fprintf (output_file, "0\n");
-      }
-    if (close_output) fclose (output_file);
-  } 
-  if (res == 20) {
-    if (!nowitness && verbose >= 0) {
-      for (i = 0; i < nclauses; i++)
-	if (!clauses[i].red) printf ("v %d\n", i+1);
-      printf ("v 0\n");
-    }
-  }
-  msg (1, "%s %d irredundant clauses %.0f%%",
-       output_file ? "printed" : "computed", n, percent (n, nclauses));
-  for (i = 0; i < nclauses; i++) free (clauses[i].lits);
-  free (clauses);
-  free (lits);
-  msg (1, "%d reductions in %.1f seconds", 
-       reductions, picosat_time_stamp () - start);
-  return res;
-}
diff --git a/test/picosat-965/picosat.c b/test/picosat-965/picosat.c
deleted file mode 100644
index 76db7ae0..00000000
--- a/test/picosat-965/picosat.c
+++ /dev/null
@@ -1,8502 +0,0 @@
-/****************************************************************************
-Copyright (c) 2006 - 2015, Armin Biere, Johannes Kepler University.
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to
-deal in the Software without restriction, including without limitation the
-rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
-sell copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-IN THE SOFTWARE.
-****************************************************************************/
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <assert.h>
-#include <limits.h>
-#include <ctype.h>
-#include <stdarg.h>
-#include <stdint.h>
-
-#include "picosat.h"
-
-/* By default code for 'all different constraints' is disabled, since 'NADC'
- * is defined.
- */
-#define NADC
-
-/* By default we enable failed literals, since 'NFL' is undefined.
- *
-#define NFL
- */
-
-/* By default we 'detach satisfied (large) clauses', e.g. NDSC undefined.
- *
-#define NDSC
- */
-
-/* Do not use luby restart schedule instead of inner/outer.
- *
-#define NLUBY
- */
-
-/* Enabling this define, will use gnuplot to visualize how the scores evolve.
- *
-#define VISCORES 
- */
-#ifdef VISCORES
-// #define WRITEGIF		/* ... to generate a video */
-#endif
-
-#ifdef VISCORES
-#ifndef WRITEGIF
-#include <unistd.h>		/* for 'usleep' */
-#endif
-#endif
-
-#ifdef RCODE
-#include <R.h>
-#endif
-
-#define MINRESTART	100	/* minimum restart interval */
-#define MAXRESTART	1000000 /* maximum restart interval */
-#define RDECIDE		1000	/* interval of random decisions */
-#define FRESTART	110	/* restart increase factor in percent */
-#define FREDUCE		110	/* reduce increase factor in percent  */
-#define FREDADJ		121	/* reduce increase adjustment factor */
-#define MAXCILS		10	/* maximal number of unrecycled internals */
-#define FFLIPPED	10000	/* flipped reduce factor */
-#define FFLIPPEDPREC	10000000/* flipped reduce factor precision */
-#define INTERRUPTLIM	1024	/* check interrupt after that many decisions */
-
-#ifndef TRACE
-#define NO_BINARY_CLAUSES	/* store binary clauses more compactly */
-#endif
-
-/* For debugging purposes you may want to define 'LOGGING', which actually
- * can be enforced by using './configure.sh --log'.
- */
-#ifdef LOGGING
-#define LOG(code) do { code; } while (0)
-#else
-#define LOG(code) do { } while (0)
-#endif
-#define NOLOG(code) do { } while (0)		/* log exception */
-#define ONLYLOG(code) do { code; } while (0)	/* force logging */
-
-#define FALSE ((Val)-1)
-#define UNDEF ((Val)0)
-#define TRUE ((Val)1)
-
-#define COMPACT_TRACECHECK_TRACE_FMT 0
-#define EXTENDED_TRACECHECK_TRACE_FMT 1
-#define RUP_TRACE_FMT 2
-
-#define NEWN(p,n) do { (p) = new (ps, sizeof (*(p)) * (n)); } while (0)
-#define CLRN(p,n) do { memset ((p), 0, sizeof (*(p)) * (n)); } while (0)
-#define CLR(p) CLRN(p,1)
-#define DELETEN(p,n) \
-  do { delete (ps, p, sizeof (*(p)) * (n)); (p) = 0; } while (0)
-
-#define RESIZEN(p,old_num,new_num) \
-  do { \
-    size_t old_size = sizeof (*(p)) * (old_num); \
-    size_t new_size = sizeof (*(p)) * (new_num); \
-    (p) = resize (ps, (p), old_size, new_size) ; \
-  } while (0)
-
-#define ENLARGE(start,head,end) \
-  do { \
-    unsigned old_num = (ptrdiff_t)((end) - (start)); \
-    size_t new_num = old_num ? (2 * old_num) : 1; \
-    unsigned count = (head) - (start); \
-    assert ((start) <= (end)); \
-    RESIZEN((start),old_num,new_num); \
-    (head) = (start) + count; \
-    (end) = (start) + new_num; \
-  } while (0)
-
-#define NOTLIT(l) (ps->lits + (1 ^ ((l) - ps->lits)))
-
-#define LIT2IDX(l) ((ptrdiff_t)((l) - ps->lits) / 2)
-#define LIT2IMPLS(l) (ps->impls + (ptrdiff_t)((l) - ps->lits))
-#define LIT2INT(l) ((int)(LIT2SGN(l) * LIT2IDX(l)))
-#define LIT2SGN(l) (((ptrdiff_t)((l) - ps->lits) & 1) ? -1 : 1)
-#define LIT2VAR(l) (ps->vars + LIT2IDX(l))
-#define LIT2HTPS(l) (ps->htps + (ptrdiff_t)((l) - ps->lits))
-#define LIT2JWH(l) (ps->jwh + ((l) - ps->lits))
-
-#ifndef NDSC
-#define LIT2DHTPS(l) (ps->dhtps + (ptrdiff_t)((l) - ps->lits))
-#endif
-
-#ifdef NO_BINARY_CLAUSES
-typedef uintptr_t Wrd;
-#define ISLITREASON(C) (1&(Wrd)C)
-#define LIT2REASON(L) \
-  (assert (L->val==TRUE), ((Cls*)(1 + (2*(L - ps->lits)))))
-#define REASON2LIT(C) ((Lit*)(ps->lits + ((Wrd)C)/2))
-#endif
-
-#define ENDOFCLS(c) ((void*)((Lit**)(c)->lits + (c)->size))
-
-#define SOC ((ps->oclauses == ps->ohead) ? ps->lclauses : ps->oclauses)
-#define EOC (ps->lhead)
-#define NXC(p) (((p) + 1 == ps->ohead) ? ps->lclauses : (p) + 1)
-
-#define OIDX2IDX(idx) (2 * ((idx) + 1))
-#define LIDX2IDX(idx) (2 * (idx) + 1)
-
-#define ISLIDX(idx) ((idx)&1)
-
-#define IDX2OIDX(idx) (assert(!ISLIDX(idx)), (idx)/2 - 1)
-#define IDX2LIDX(idx) (assert(ISLIDX(idx)), (idx)/2)
-
-#define EXPORTIDX(idx) \
-  ((ISLIDX(idx) ? (IDX2LIDX (idx) + (ps->ohead - ps->oclauses)) : IDX2OIDX(idx)) + 1)
-
-#define IDX2CLS(i) \
-  (assert(i), (ISLIDX(i) ? ps->lclauses : ps->oclauses)[(i)/2 - !ISLIDX(i)])
-
-#define IDX2ZHN(i) (assert(i), (ISLIDX(i) ? ps->zhains[(i)/2] : 0))
-
-#define CLS2TRD(c) (((Trd*)(c)) - 1)
-#define CLS2IDX(c) ((((Trd*)(c)) - 1)->idx)
-
-#define CLS2ACT(c) \
-  ((Act*)((assert((c)->learned)),assert((c)->size>2),ENDOFCLS(c)))
-
-#define VAR2LIT(v) (ps->lits + 2 * ((v) - ps->vars))
-#define VAR2RNK(v) (ps->rnks + ((v) - ps->vars))
-
-#define RNK2LIT(r) (ps->lits + 2 * ((r) - ps->rnks))
-#define RNK2VAR(r) (ps->vars + ((r) - ps->rnks))
-
-#define BLK_FILL_BYTES 8
-#define SIZE_OF_BLK (sizeof (Blk) - BLK_FILL_BYTES)
-
-#define PTR2BLK(void_ptr) \
-  ((void_ptr) ? (Blk*)(((char*)(void_ptr)) - SIZE_OF_BLK) : 0)
-
-#define AVERAGE(a,b) ((b) ? (((double)a) / (double)(b)) : 0.0)
-#define PERCENT(a,b) (100.0 * AVERAGE(a,b))
-
-#ifndef RCODE
-#define ABORT(msg) \
-  do { \
-    fputs ("*** picosat: " msg "\n", stderr); \
-    abort (); \
-  } while (0)
-#else
-#define ABORT(msg) \
-  do { \
-    Rf_error (msg); \
-  } while (0)
-#endif
-
-#define ABORTIF(cond,msg) \
-  do { \
-    if (!(cond)) break; \
-    ABORT (msg); \
-  } while (0)
-
-#define ZEROFLT		(0x00000000u)
-#define EPSFLT		(0x00000001u)
-#define INFFLT		(0xffffffffu)
-
-#define FLTCARRY	(1u << 25)
-#define FLTMSB		(1u << 24)
-#define FLTMAXMANTISSA	(FLTMSB - 1)
-
-#define FLTMANTISSA(d)	((d) & FLTMAXMANTISSA)
-#define FLTEXPONENT(d)	((int)((d) >> 24) - 128)
-
-#define FLTMINEXPONENT	(-128)
-#define FLTMAXEXPONENT	(127)
-
-#define CMPSWAPFLT(a,b) \
-  do { \
-    Flt tmp; \
-    if (((a) < (b))) \
-      { \
-	tmp = (a); \
-	(a) = (b); \
-	(b) = tmp; \
-      } \
-  } while (0)
-
-#define UNPACKFLT(u,m,e) \
-  do { \
-    (m) = FLTMANTISSA(u); \
-    (e) = FLTEXPONENT(u); \
-    (m) |= FLTMSB; \
-  } while (0)
-
-#define INSERTION_SORT_LIMIT 10
-
-#define SORTING_SWAP(T,p,q) \
-do { \
-  T tmp = *(q); \
-  *(q) = *(p); \
-  *(p) = tmp; \
-} while (0)
-
-#define SORTING_CMP_SWAP(T,cmp,p,q) \
-do { \
-  if ((cmp) (ps, *(p), *(q)) > 0) \
-    SORTING_SWAP (T, p, q); \
-} while(0)
-
-#define QUICKSORT_PARTITION(T,cmp,a,l,r) \
-do { \
-  T pivot; \
-  int j; \
-  i = (l) - 1; 			/* result in 'i' */ \
-  j = (r); \
-  pivot = (a)[j]; \
-  for (;;) \
-    { \
-      while ((cmp) (ps, (a)[++i], pivot) < 0) \
-	; \
-      while ((cmp) (ps, pivot, (a)[--j]) < 0) \
-        if (j == (l)) \
-	  break; \
-      if (i >= j) \
-	break; \
-      SORTING_SWAP (T, (a) + i, (a) + j); \
-    } \
-  SORTING_SWAP (T, (a) + i, (a) + (r)); \
-} while(0)
-
-#define QUICKSORT(T,cmp,a,n) \
-do { \
-  int l = 0, r = (n) - 1, m, ll, rr, i; \
-  assert (ps->ihead == ps->indices); \
-  if (r - l <= INSERTION_SORT_LIMIT) \
-    break; \
-  for (;;) \
-    { \
-      m = (l + r) / 2; \
-      SORTING_SWAP (T, (a) + m, (a) + r - 1); \
-      SORTING_CMP_SWAP (T, cmp, (a) + l, (a) + r - 1); \
-      SORTING_CMP_SWAP (T, cmp, (a) + l, (a) + r); \
-      SORTING_CMP_SWAP (T, cmp, (a) + r - 1, (a) + r); \
-      QUICKSORT_PARTITION (T, cmp, (a), l + 1, r - 1); \
-      if (i - l < r - i) \
-	{ \
-	  ll = i + 1; \
-	  rr = r; \
-	  r = i - 1; \
-	} \
-      else \
-	{ \
-	  ll = l; \
-	  rr = i - 1; \
-	  l = i + 1; \
-	} \
-      if (r - l > INSERTION_SORT_LIMIT) \
-	{ \
-	  assert (rr - ll > INSERTION_SORT_LIMIT); \
-	  if (ps->ihead == ps->eoi) \
-	    ENLARGE (ps->indices, ps->ihead, ps->eoi); \
-	  *ps->ihead++ = ll; \
-	  if (ps->ihead == ps->eoi) \
-	    ENLARGE (ps->indices, ps->ihead, ps->eoi); \
-	  *ps->ihead++ = rr; \
-	} \
-      else if (rr - ll > INSERTION_SORT_LIMIT) \
-        { \
-	  l = ll; \
-	  r = rr; \
-	} \
-      else if (ps->ihead > ps->indices) \
-	{ \
-	  r = *--ps->ihead; \
-	  l = *--ps->ihead; \
-	} \
-      else \
-	break; \
-    } \
-} while (0)
-
-#define INSERTION_SORT(T,cmp,a,n) \
-do { \
-  T pivot; \
-  int l = 0, r = (n) - 1, i, j; \
-  for (i = r; i > l; i--) \
-    SORTING_CMP_SWAP (T, cmp, (a) + i - 1, (a) + i); \
-  for (i = l + 2; i <= r; i++)  \
-    { \
-      j = i; \
-      pivot = (a)[i]; \
-      while ((cmp) (ps, pivot, (a)[j - 1]) < 0) \
-        { \
-	  (a)[j] = (a)[j - 1]; \
-	  j--; \
-	} \
-      (a)[j] = pivot; \
-    } \
-} while (0)
-
-#ifdef NDEBUG
-#define CHECK_SORTED(cmp,a,n) do { } while(0)
-#else
-#define CHECK_SORTED(cmp,a,n) \
-do { \
-  int i; \
-  for (i = 0; i < (n) - 1; i++) \
-    assert ((cmp) (ps, (a)[i], (a)[i + 1]) <= 0); \
-} while(0)
-#endif
-
-#define SORT(T,cmp,a,n) \
-do { \
-  T * aa = (a); \
-  int nn = (n); \
-  QUICKSORT (T, cmp, aa, nn); \
-  INSERTION_SORT (T, cmp, aa, nn); \
-  assert (ps->ihead == ps->indices); \
-  CHECK_SORTED (cmp, aa, nn); \
-} while (0)
-
-#define WRDSZ (sizeof (long) * 8)
-
-#ifdef RCODE
-#define fprintf(...) do { } while (0)
-#define vfprintf(...) do { } while (0)
-#define fputs(...) do { } while (0)
-#define fputc(...) do { } while (0)
-#endif
-
-typedef unsigned Flt;		/* 32 bit deterministic soft float */
-typedef Flt Act;		/* clause and variable activity */
-typedef struct Blk Blk;		/* allocated memory block */
-typedef struct Cls Cls;		/* clause */
-typedef struct Lit Lit;		/* literal */
-typedef struct Rnk Rnk;		/* variable to score mapping */
-typedef signed char Val;	/* TRUE, UNDEF, FALSE */
-typedef struct Var Var;		/* variable */
-#ifdef TRACE
-typedef struct Trd Trd;		/* trace data for clauses */
-typedef struct Zhn Zhn;		/* compressed chain (=zain) data */
-typedef unsigned char Znt;	/* compressed antecedent data */
-#endif
-
-#ifdef NO_BINARY_CLAUSES
-typedef struct Ltk Ltk;
-
-struct Ltk
-{
-  Lit ** start;
-  unsigned count : WRDSZ == 32 ? 27 : 32;
-  unsigned ldsize : WRDSZ == 32 ? 5 : 32;
-};
-#endif
-
-struct Lit
-{
-  Val val;
-};
-
-struct Var
-{
-  unsigned mark		: 1;	/*bit 1*/
-  unsigned resolved	: 1;	/*bit 2*/
-  unsigned phase	: 1;	/*bit 3*/
-  unsigned assigned	: 1;	/*bit 4*/
-  unsigned used		: 1;	/*bit 5*/
-  unsigned failed	: 1;	/*bit 6*/
-  unsigned internal	: 1;	/*bit 7*/
-  unsigned usedefphase  : 1;    /*bit 8*/
-  unsigned defphase     : 1;    /*bit 9*/
-  unsigned msspos       : 1;    /*bit 10*/
-  unsigned mssneg       : 1;    /*bit 11*/
-  unsigned humuspos     : 1;    /*bit 12*/
-  unsigned humusneg     : 1;    /*bit 13*/
-  unsigned partial      : 1;    /*bit 14*/
-#ifdef TRACE
-  unsigned core		: 1;	/*bit 15*/
-#endif
-  unsigned level;
-  Cls *reason;
-#ifndef NADC
-  Lit ** inado;
-  Lit ** ado;
-  Lit *** adotabpos;
-#endif
-};
-
-struct Rnk
-{
-  Act score;
-  unsigned pos : 30;			/* 0 iff not on heap */
-  unsigned moreimportant : 1;
-  unsigned lessimportant : 1;
-};
-
-struct Cls
-{
-  unsigned size;
-
-  unsigned collect:1;	/* bit 1 */
-  unsigned learned:1;	/* bit 2 */
-  unsigned locked:1;	/* bit 3 */
-  unsigned used:1;	/* bit 4 */
-#ifndef NDEBUG
-  unsigned connected:1;	/* bit 5 */
-#endif
-#ifdef TRACE
-  unsigned collected:1;	/* bit 6 */
-  unsigned core:1;	/* bit 7 */
-#endif
-
-#define LDMAXGLUE 25	/* 32 - 7 */
-#define MAXGLUE 	((1<<LDMAXGLUE)-1)
-
-  unsigned glue:LDMAXGLUE;
-
-  Cls *next[2];
-  Lit *lits[2];
-};
-
-#ifdef TRACE
-struct Zhn
-{
-  unsigned ref:31;
-  unsigned core:1;
-  Znt * liz;
-  Znt znt[0];
-};
-
-struct Trd
-{
-  unsigned idx;
-  Cls cls[0];
-};
-#endif
-
-struct Blk
-{
-#ifndef NDEBUG
-  union
-  {
-    size_t size;		/* this is what we really use */
-    void *as_two_ptrs[2];	/* 2 * sizeof (void*) alignment of data */
-  }
-  header;
-#endif
-  char data[BLK_FILL_BYTES];
-};
-
-enum State
-{
-  RESET = 0,
-  READY = 1,
-  SAT = 2,
-  UNSAT = 3,
-  UNKNOWN = 4,
-};
-
-enum Phase
-{
-  POSPHASE,
-  NEGPHASE,
-  JWLPHASE,
-  RNDPHASE,
-};
-
-struct PicoSAT 
-{
-  enum State state;
-  enum Phase defaultphase;
-  int last_sat_call_result;
-
-  FILE *out;
-  char * prefix;
-  int verbosity;
-  int plain;
-  unsigned LEVEL;
-  unsigned max_var;
-  unsigned size_vars;
-
-  Lit *lits;
-  Var *vars;
-  Rnk *rnks;
-  Flt *jwh;
-  Cls **htps;
-#ifndef NDSC
-  Cls **dhtps;
-#endif
-#ifdef NO_BINARY_CLAUSES
-  Ltk *impls;
-  Cls impl, cimpl;
-  int implvalid, cimplvalid;
-#else
-  Cls **impls;
-#endif
-  Lit **trail, **thead, **eot, **ttail, ** ttail2;
-#ifndef NADC
-  Lit **ttailado;
-#endif
-  unsigned adecidelevel;
-  Lit **als, **alshead, **alstail, **eoals;
-  Lit **CLS, **clshead, **eocls;
-  int *rils, *rilshead, *eorils;
-  int *cils, *cilshead, *eocils;
-  int *fals, *falshead, *eofals;
-  int *mass, szmass;
-  int *mssass, szmssass;
-  int *mcsass, nmcsass, szmcsass;
-  int *humus, szhumus;
-  Lit *failed_assumption;
-  int extracted_all_failed_assumptions;
-  Rnk **heap, **hhead, **eoh;
-  Cls **oclauses, **ohead, **eoo;	/* original clauses */
-  Cls **lclauses, **lhead, ** EOL;	/* learned clauses */
-  int * soclauses, * sohead, * eoso; /* saved original clauses */
-  int saveorig;
-  int partial;
-#ifdef TRACE
-  int trace;
-  Zhn **zhains, **zhead, **eoz;
-  int ocore;
-#endif
-  FILE * rup;
-  int rupstarted;
-  int rupvariables;
-  int rupclauses;
-  Cls *mtcls;
-  Cls *conflict;
-  Lit **added, **ahead, **eoa;
-  Var **marked, **mhead, **eom;
-  Var **dfs, **dhead, **eod;
-  Cls **resolved, **rhead, **eor;
-  unsigned char *levels, *levelshead, *eolevels;
-  unsigned *dused, *dusedhead, *eodused;
-  unsigned char *buffer, *bhead, *eob;
-  Act vinc, lscore, ilvinc, ifvinc;
-#ifdef VISCORES
-  Act fvinc, nvinc;
-#endif
-  Act cinc, lcinc, ilcinc, fcinc;
-  unsigned srng;
-  size_t current_bytes;
-  size_t max_bytes;
-  size_t recycled;
-  double seconds, flseconds;
-  double entered;
-  unsigned nentered;
-  int measurealltimeinlib;
-  char *rline[2];
-  int szrline, RCOUNT;
-  double levelsum;
-  unsigned iterations;
-  int reports;
-  int lastrheader;
-  unsigned calls;
-  unsigned decisions;
-  unsigned restarts;
-  unsigned simps;
-  unsigned fsimplify;
-  unsigned isimplify;
-  unsigned reductions;
-  unsigned lreduce;
-  unsigned lreduceadjustcnt;
-  unsigned lreduceadjustinc;
-  unsigned lastreduceconflicts;
-  unsigned llocked;	/* locked large learned clauses */
-  unsigned lrestart;
-#ifdef NLUBY
-  unsigned drestart;
-  unsigned ddrestart;
-#else
-  unsigned lubycnt;
-  unsigned lubymaxdelta;
-  int waslubymaxdelta;
-#endif
-  unsigned long long lsimplify;
-  unsigned long long propagations;
-  unsigned long long lpropagations;
-  unsigned fixed;		/* top level assignments */
-#ifndef NFL
-  unsigned failedlits;
-  unsigned ifailedlits;
-  unsigned efailedlits;
-  unsigned flcalls;
-#ifdef STATS
-  unsigned flrounds;
-  unsigned long long flprops;
-  unsigned long long floopsed, fltried, flskipped;
-#endif
-  unsigned long long fllimit;
-  int simplifying;
-  Lit ** saved;
-  unsigned saved_size;
-#endif
-  unsigned conflicts;
-  unsigned contexts;
-  unsigned internals;
-  unsigned noclauses;	/* current number large original clauses */
-  unsigned nlclauses;	/* current number large learned clauses */
-  unsigned olits;		/* current literals in large original clauses */
-  unsigned llits;		/* current literals in large learned clauses */
-  unsigned oadded;		/* added original clauses */
-  unsigned ladded;		/* added learned clauses */
-  unsigned loadded;	/* added original large clauses */
-  unsigned lladded;	/* added learned large clauses */
-  unsigned addedclauses;	/* oadded + ladded */
-  unsigned vused;		/* used variables */
-  unsigned llitsadded;	/* added learned literals */
-  unsigned long long visits;
-#ifdef STATS
-  unsigned loused;		/* used large original clauses */
-  unsigned llused;		/* used large learned clauses */
-  unsigned long long bvisits;
-  unsigned long long tvisits;
-  unsigned long long lvisits;
-  unsigned long long othertrue;
-  unsigned long long othertrue2;
-  unsigned long long othertruel;
-  unsigned long long othertrue2u;
-  unsigned long long othertruelu;
-  unsigned long long ltraversals;
-  unsigned long long traversals;
-#ifdef TRACE
-  unsigned long long antecedents;
-#endif
-  unsigned uips;
-  unsigned znts;
-  unsigned assumptions;
-  unsigned rdecisions;
-  unsigned sdecisions;
-  size_t srecycled;
-  size_t rrecycled;
-  unsigned long long derefs;
-#endif
-  unsigned minimizedllits;
-  unsigned nonminimizedllits;
-#ifndef NADC
-  Lit *** ados, *** hados, *** eados;
-  Lit *** adotab;
-  unsigned nadotab;
-  unsigned szadotab;
-  Cls * adoconflict;
-  unsigned adoconflicts;
-  unsigned adoconflictlimit;
-  int addingtoado;
-  int adodisabled;
-#endif
-  unsigned long long flips;
-#ifdef STATS
-  unsigned long long FORCED;
-  unsigned long long assignments;
-  unsigned inclreduces;
-  unsigned staticphasedecisions;
-  unsigned skippedrestarts;
-#endif
-  int * indices, * ihead, *eoi; 
-  unsigned sdflips;
-
-  unsigned long long saved_flips;
-  unsigned saved_max_var;
-  unsigned min_flipped;
-
-  void * emgr;
-  picosat_malloc enew;
-  picosat_realloc eresize;
-  picosat_free edelete;
-
-  struct {
-    void * state;
-    int (*function) (void *);
-  } interrupt;
-
-#ifdef VISCORES
-  FILE * fviscores;
-#endif
-};
-
-typedef PicoSAT PS;
-
-static Flt
-packflt (unsigned m, int e)
-{
-  Flt res;
-  assert (m < FLTMSB);
-  assert (FLTMINEXPONENT <= e);
-  assert (e <= FLTMAXEXPONENT);
-  res = m | ((unsigned)(e + 128) << 24);
-  return res;
-}
-
-static Flt
-base2flt (unsigned m, int e)
-{
-  if (!m)
-    return ZEROFLT;
-
-  if (m < FLTMSB)
-    {
-      do
-	{
-	  if (e <= FLTMINEXPONENT)
-	    return EPSFLT;
-
-	  e--;
-	  m <<= 1;
-
-	}
-      while (m < FLTMSB);
-    }
-  else
-    {
-      while (m >= FLTCARRY)
-	{
-	  if (e >= FLTMAXEXPONENT)
-	    return INFFLT;
-
-	  e++;
-	  m >>= 1;
-	}
-    }
-
-  m &= ~FLTMSB;
-  return packflt (m, e);
-}
-
-static Flt
-addflt (Flt a, Flt b)
-{
-  unsigned ma, mb, delta;
-  int ea, eb;
-
-  CMPSWAPFLT (a, b);
-  if (!b)
-    return a;
-
-  UNPACKFLT (a, ma, ea);
-  UNPACKFLT (b, mb, eb);
-
-  assert (ea >= eb);
-  delta = ea - eb;
-  if (delta < 32) mb >>= delta; else mb = 0;
-  if (!mb)
-    return a;
-
-  ma += mb;
-  if (ma & FLTCARRY)
-    {
-      if (ea == FLTMAXEXPONENT)
-	return INFFLT;
-
-      ea++;
-      ma >>= 1;
-    }
-
-  assert (ma < FLTCARRY);
-  ma &= FLTMAXMANTISSA;
-
-  return packflt (ma, ea);
-}
-
-static Flt
-mulflt (Flt a, Flt b)
-{
-  unsigned ma, mb;
-  unsigned long long accu;
-  int ea, eb;
-
-  CMPSWAPFLT (a, b);
-  if (!b)
-    return ZEROFLT;
-
-  UNPACKFLT (a, ma, ea);
-  UNPACKFLT (b, mb, eb);
-
-  ea += eb;
-  ea += 24;
-  if (ea > FLTMAXEXPONENT)
-    return INFFLT;
-
-  if (ea < FLTMINEXPONENT)
-    return EPSFLT;
-
-  accu = ma;
-  accu *= mb;
-  accu >>= 24;
-
-  if (accu >= FLTCARRY)
-    {
-      if (ea == FLTMAXEXPONENT)
-	return INFFLT;
-
-      ea++;
-      accu >>= 1;
-
-      if (accu >= FLTCARRY)
-	return INFFLT;
-    }
-
-  assert (accu < FLTCARRY);
-  assert (accu & FLTMSB);
-
-  ma = accu;
-  ma &= ~FLTMSB;
-
-  return packflt (ma, ea);
-}
-
-static Flt
-ascii2flt (const char *str)
-{
-  Flt ten = base2flt (10, 0);
-  Flt onetenth = base2flt (26843546, -28);
-  Flt res = ZEROFLT, tmp, base;
-  const char *p = str;
-  int ch;
-
-  ch = *p++;
-
-  if (ch != '.')
-    {
-      if (!isdigit (ch))
-	return INFFLT;	/* better abort ? */
-
-      res = base2flt (ch - '0', 0);
-
-      while ((ch = *p++))
-	{
-	  if (ch == '.')
-	    break;
-
-	  if (!isdigit (ch))
-	    return INFFLT;	/* better abort? */
-
-	  res = mulflt (res, ten);
-	  tmp = base2flt (ch - '0', 0);
-	  res = addflt (res, tmp);
-	}
-    }
-
-  if (ch == '.')
-    {
-      ch = *p++;
-      if (!isdigit (ch))
-	return INFFLT;	/* better abort ? */
-
-      base = onetenth;
-      tmp = mulflt (base2flt (ch - '0', 0), base);
-      res = addflt (res, tmp);
-
-      while ((ch = *p++))
-	{
-	  if (!isdigit (ch))
-	    return INFFLT;	/* better abort? */
-
-	  base = mulflt (base, onetenth);
-	  tmp = mulflt (base2flt (ch - '0', 0), base);
-	  res = addflt (res, tmp);
-	}
-    }
-
-  return res;
-}
-
-#if defined(VISCORES)
-
-static double
-flt2double (Flt f)
-{
-  double res;
-  unsigned m;
-  int e, i;
-
-  UNPACKFLT (f, m, e);
-  res = m;
-
-  if (e < 0)
-    {
-      for (i = e; i < 0; i++)
-	res *= 0.5;
-    }
-  else
-    {
-      for (i = 0; i < e; i++)
-	res *= 2.0;
-    }
-
-  return res;
-}
-
-#endif
-
-static int
-log2flt (Flt a)
-{
-  return FLTEXPONENT (a) + 24;
-}
-
-static int
-cmpflt (Flt a, Flt b)
-{
-  if (a < b)
-    return -1;
-
-  if (a > b)
-    return 1;
-
-  return 0;
-}
-
-static void *
-new (PS * ps, size_t size)
-{
-  size_t bytes;
-  Blk *b;
-  
-  if (!size)
-    return 0;
-
-  bytes = size + SIZE_OF_BLK;
-
-  if (ps->enew)
-    b = ps->enew (ps->emgr, bytes);
-  else
-    b = malloc (bytes);
-
-  ABORTIF (!b, "out of memory in 'new'");
-#ifndef NDEBUG
-  b->header.size = size;
-#endif
-  ps->current_bytes += size;
-  if (ps->current_bytes > ps->max_bytes)
-    ps->max_bytes = ps->current_bytes;
-  return b->data;
-}
-
-static void
-delete (PS * ps, void *void_ptr, size_t size)
-{
-  size_t bytes;
-  Blk *b;
-
-  if (!void_ptr)
-    {
-      assert (!size);
-      return;
-    }
-
-  assert (size);
-  b = PTR2BLK (void_ptr);
-
-  assert (size <= ps->current_bytes);
-  ps->current_bytes -= size;
-
-  assert (b->header.size == size);
-
-  bytes = size + SIZE_OF_BLK;
-  if (ps->edelete)
-    ps->edelete (ps->emgr, b, bytes);
-  else
-    free (b);
-}
-
-static void *
-resize (PS * ps, void *void_ptr, size_t old_size, size_t new_size)
-{
-  size_t old_bytes, new_bytes;
-  Blk *b;
-
-  b = PTR2BLK (void_ptr);
-
-  assert (old_size <= ps->current_bytes);
-  ps->current_bytes -= old_size;
-
-  if ((old_bytes = old_size))
-    {
-      assert (old_size && b && b->header.size == old_size);
-      old_bytes += SIZE_OF_BLK;
-    }
-  else
-    assert (!b);
-
-  if ((new_bytes = new_size))
-    new_bytes += SIZE_OF_BLK;
-
-  if (ps->eresize)
-    b = ps->eresize (ps->emgr, b, old_bytes, new_bytes);
-  else
-    b = realloc (b, new_bytes);
-
-  if (!new_size)
-    {
-      assert (!b);
-      return 0;
-    }
-
-  ABORTIF (!b, "out of memory in 'resize'");
-#ifndef NDEBUG
-  b->header.size = new_size;
-#endif
-
-  ps->current_bytes += new_size;
-  if (ps->current_bytes > ps->max_bytes)
-    ps->max_bytes = ps->current_bytes;
-
-  return b->data;
-}
-
-static unsigned
-int2unsigned (int l)
-{
-  return (l < 0) ? 1 + 2 * -l : 2 * l;
-}
-
-static Lit *
-int2lit (PS * ps, int l)
-{
-  return ps->lits + int2unsigned (l);
-}
-
-static Lit **
-end_of_lits (Cls * c)
-{
-  return (Lit**)c->lits + c->size;
-}
-
-#if !defined(NDEBUG) || defined(LOGGING)
-
-static void
-dumplits (PS * ps, Lit ** l, Lit ** end)
-{
-  int first;
-  Lit ** p;
-
-  if (l == end)
-    {
-      /* empty clause */
-    }
-  else if (l + 1 == end)
-    {
-      fprintf (ps->out, "%d ", LIT2INT (l[0]));
-    }
-  else
-    { 
-      assert (l + 2 <= end);
-      first = (abs (LIT2INT (l[0])) > abs (LIT2INT (l[1])));
-      fprintf (ps->out, "%d ", LIT2INT (l[first]));
-      fprintf (ps->out, "%d ", LIT2INT (l[!first]));
-      for (p = l + 2; p < end; p++)
-	 fprintf (ps->out, "%d ", LIT2INT (*p));
-    }
-
-  fputc ('0', ps->out);
-}
-
-static void
-dumpcls (PS * ps, Cls * c)
-{
-  Lit **end;
-
-  if (c)
-    {
-      end = end_of_lits (c);
-      dumplits (ps, c->lits, end);
-#ifdef TRACE
-      if (ps->trace)
-	 fprintf (ps->out, " clause(%u)", CLS2IDX (c));
-#endif
-    }
-  else
-    fputs ("DECISION", ps->out);
-}
-
-static void
-dumpclsnl (PS * ps, Cls * c)
-{
-  dumpcls (ps, c);
-  fputc ('\n', ps->out);
-}
-
-void
-dumpcnf (PS * ps)
-{
-  Cls **p, *c;
-
-  for (p = SOC; p != EOC; p = NXC (p))
-    {
-      c = *p;
-
-      if (!c)
-	continue;
-
-#ifdef TRACE
-      if (c->collected)
-	continue;
-#endif
-
-      dumpclsnl (ps, *p);
-    }
-}
-
-#endif
-
-static void
-delete_prefix (PS * ps)
-{
-  if (!ps->prefix)
-    return;
-    
-  delete (ps, ps->prefix, strlen (ps->prefix) + 1);
-  ps->prefix = 0;
-}
-
-static void
-new_prefix (PS * ps, const char * str)
-{
-  delete_prefix (ps);
-  assert (str);
-  ps->prefix = new (ps, strlen (str) + 1);
-  strcpy (ps->prefix, str);
-}
-
-static PS *
-init (void * pmgr, 
-      picosat_malloc pnew, picosat_realloc presize, picosat_free pdelete)
-{
-  PS * ps;
-
-#if 0
-  int count = 3 - !pnew - !presize - !pdelete;
-
-  ABORTIF (count && !pnew, "API usage: missing 'picosat_set_new'");
-  ABORTIF (count && !presize, "API usage: missing 'picosat_set_resize'");
-  ABORTIF (count && !pdelete, "API usage: missing 'picosat_set_delete'");
-#endif
-
-  ps = pnew ? pnew (pmgr, sizeof *ps) : malloc (sizeof *ps);
-  ABORTIF (!ps, "failed to allocate memory for PicoSAT manager");
-  memset (ps, 0, sizeof *ps);
-
-  ps->emgr = pmgr;
-  ps->enew = pnew;
-  ps->eresize = presize;
-  ps->edelete = pdelete;
-
-  ps->size_vars = 1;
-  ps->state = RESET;
-  ps->defaultphase = JWLPHASE;
-#ifdef TRACE
-  ps->ocore = -1;
-#endif
-  ps->lastrheader = -2;
-#ifndef NADC
-  ps->adoconflictlimit = UINT_MAX;
-#endif
-  ps->min_flipped = UINT_MAX;
-
-  NEWN (ps->lits, 2 * ps->size_vars);
-  NEWN (ps->jwh, 2 * ps->size_vars);
-  NEWN (ps->htps, 2 * ps->size_vars);
-#ifndef NDSC
-  NEWN (ps->dhtps, 2 * ps->size_vars);
-#endif
-  NEWN (ps->impls, 2 * ps->size_vars);
-  NEWN (ps->vars, ps->size_vars);
-  NEWN (ps->rnks, ps->size_vars);
-
-  /* because '0' pos denotes not on heap
-   */
-  ENLARGE (ps->heap, ps->hhead, ps->eoh); 
-  ps->hhead = ps->heap + 1;
-
-  ps->vinc = base2flt (1, 0);		/* initial var activity */
-  ps->ifvinc = ascii2flt ("1.05");	/* var score rescore factor */
-#ifdef VISCORES
-  ps->fvinc = ascii2flt ("0.9523809");	/*     1/f =     1/1.05 */
-  ps->nvinc = ascii2flt ("0.0476191");	/* 1 - 1/f = 1 - 1/1.05 */
-#endif
-  ps->lscore = base2flt (1, 90);	/* var activity rescore limit */
-  ps->ilvinc = base2flt (1, -90);	/* inverse of 'lscore' */
-
-  ps->cinc = base2flt (1, 0);		/* initial clause activity */
-  ps->fcinc = ascii2flt ("1.001");	/* cls activity rescore factor */
-  ps->lcinc = base2flt (1, 90);		/* cls activity rescore limit */
-  ps->ilcinc = base2flt (1, -90);	/* inverse of 'ilcinc' */
-
-  ps->lreduceadjustcnt = ps->lreduceadjustinc = 100;
-  ps->lpropagations = ~0ull;
-
-#ifndef RCODE
-  ps->out = stdout;
-#else
-  ps->out = 0;
-#endif
-  new_prefix (ps, "c ");
-  ps->verbosity = 0;
-  ps->plain = 0;
-
-#ifdef NO_BINARY_CLAUSES
-  memset (&ps->impl, 0, sizeof (ps->impl));
-  ps->impl.size = 2;
-
-  memset (&ps->cimpl, 0, sizeof (ps->impl));
-  ps->cimpl.size = 2;
-#endif
-
-#ifdef VISCORES
-  ps->fviscores = popen (
-    "/usr/bin/gnuplot -background black"
-    " -xrm 'gnuplot*textColor:white'"
-    " -xrm 'gnuplot*borderColor:white'"
-    " -xrm 'gnuplot*axisColor:white'"
-    , "w");
-  fprintf (ps->fviscores, "unset key\n");
-  // fprintf (ps->fviscores, "set log y\n");
-  fflush (ps->fviscores);
-  system ("rm -rf /tmp/picosat-viscores");
-  system ("mkdir /tmp/picosat-viscores");
-  system ("mkdir /tmp/picosat-viscores/data");
-#ifdef WRITEGIF
-  system ("mkdir /tmp/picosat-viscores/gif");
-  fprintf (ps->fviscores,
-           "set terminal gif giant animate opt size 1024,768 x000000 xffffff"
-	   "\n");
-
-  fprintf (ps->fviscores, 
-           "set output \"/tmp/picosat-viscores/gif/animated.gif\"\n");
-#endif
-#endif
-  ps->defaultphase = JWLPHASE;
-  ps->state = READY;
-  ps->last_sat_call_result = 0;
-
-  return ps;
-}
-
-static size_t
-bytes_clause (PS * ps, unsigned size, unsigned learned)
-{
-  size_t res;
-
-  res = sizeof (Cls);
-  res += size * sizeof (Lit *);
-  res -= 2 * sizeof (Lit *);
-
-  if (learned && size > 2)
-    res += sizeof (Act);	/* add activity */
-
-#ifdef TRACE
-  if (ps->trace)
-    res += sizeof (Trd);	/* add trace data */
-#else
-  (void) ps;
-#endif
-
-  return res;
-}
-
-static Cls *
-new_clause (PS * ps, unsigned size, unsigned learned)
-{
-  size_t bytes;
-  void * tmp;
-#ifdef TRACE
-  Trd *trd;
-#endif
-  Cls *res;
-
-  bytes = bytes_clause (ps, size, learned);
-  tmp = new (ps, bytes);
-
-#ifdef TRACE
-  if (ps->trace)
-    {
-      trd = tmp;
-
-      if (learned)
-	trd->idx = LIDX2IDX (ps->lhead - ps->lclauses);
-      else
-	trd->idx = OIDX2IDX (ps->ohead - ps->oclauses);
-
-      res = trd->cls;
-    }
-  else
-#endif
-    res = tmp;
-
-  res->size = size;
-  res->learned = learned;
-
-  res->collect = 0;
-#ifndef NDEBUG
-  res->connected = 0;
-#endif
-  res->locked = 0;
-  res->used = 0;
-#ifdef TRACE
-  res->core = 0;
-  res->collected = 0;
-#endif
-
-  if (learned && size > 2)
-    {
-      Act * p = CLS2ACT (res);
-      *p = ps->cinc;
-    }
-
-  return res;
-}
-
-static void
-delete_clause (PS * ps, Cls * c)
-{
-  size_t bytes;
-#ifdef TRACE
-  Trd *trd;
-#endif
-
-  bytes = bytes_clause (ps, c->size, c->learned);
-
-#ifdef TRACE
-  if (ps->trace)
-    {
-      trd = CLS2TRD (c);
-      delete (ps, trd, bytes);
-    }
-  else
-#endif
-    delete (ps, c, bytes);
-}
-
-static void
-delete_clauses (PS * ps)
-{
-  Cls **p;
-  for (p = SOC; p != EOC; p = NXC (p))
-    if (*p)
-      delete_clause (ps, *p);
-
-  DELETEN (ps->oclauses, ps->eoo - ps->oclauses);
-  DELETEN (ps->lclauses, ps->EOL - ps->lclauses);
-
-  ps->ohead = ps->eoo = ps->lhead = ps->EOL = 0;
-}
-
-#ifdef TRACE
-
-static void
-delete_zhain (PS * ps, Zhn * zhain)
-{
-  const Znt *p, *znt;
-
-  assert (zhain);
-
-  znt = zhain->znt;
-  for (p = znt; *p; p++)
-    ;
-
-  delete (ps, zhain, sizeof (Zhn) + (p - znt) + 1);
-}
-
-static void
-delete_zhains (PS * ps)
-{
-  Zhn **p, *z;
-  for (p = ps->zhains; p < ps->zhead; p++)
-    if ((z = *p))
-      delete_zhain (ps, z);
-
-  DELETEN (ps->zhains, ps->eoz - ps->zhains);
-  ps->eoz = ps->zhead = 0;
-}
-
-#endif
-
-#ifdef NO_BINARY_CLAUSES
-static void
-lrelease (PS * ps, Ltk * stk)
-{
-  if (stk->start)
-    DELETEN (stk->start, (1 << (stk->ldsize)));
-  memset (stk, 0, sizeof (*stk));
-}
-#endif
-
-#ifndef NADC
-
-static unsigned
-llength (Lit ** a)
-{
-  Lit ** p;
-  for (p = a; *p; p++)
-    ;
-  return p - a;
-}
-
-static void
-resetadoconflict (PS * ps)
-{
-  assert (ps->adoconflict);
-  delete_clause (ps, ps->adoconflict);
-  ps->adoconflict = 0;
-}
-
-static void
-reset_ados (PS * ps)
-{
-  Lit *** p;
-
-  for (p = ps->ados; p < ps->hados; p++)
-    DELETEN (*p, llength (*p) + 1);
-
-  DELETEN (ps->ados, ps->eados - ps->ados);
-  ps->hados = ps->eados = 0;
-
-  DELETEN (ps->adotab, ps->szadotab);
-  ps->szadotab = ps->nadotab = 0;
-
-  if (ps->adoconflict)
-    resetadoconflict (ps);
-
-  ps->adoconflicts = 0;
-  ps->adoconflictlimit = UINT_MAX;
-  ps->adodisabled = 0;
-}
-
-#endif
-
-static void
-reset (PS * ps)
-{
-  ABORTIF (!ps || 
-           ps->state == RESET, "API usage: reset without initialization");
-
-  delete_clauses (ps);
-#ifdef TRACE
-  delete_zhains (ps);
-#endif
-#ifdef NO_BINARY_CLAUSES
-  {
-    unsigned i;
-    for (i = 2; i <= 2 * ps->max_var + 1; i++)
-      lrelease (ps, ps->impls + i);
-  }
-#endif
-#ifndef NADC
-  reset_ados (ps);
-#endif
-#ifndef NFL
-  DELETEN (ps->saved, ps->saved_size);
-#endif
-  DELETEN (ps->htps, 2 * ps->size_vars);
-#ifndef NDSC
-  DELETEN (ps->dhtps, 2 * ps->size_vars);
-#endif
-  DELETEN (ps->impls, 2 * ps->size_vars);
-  DELETEN (ps->lits, 2 * ps->size_vars);
-  DELETEN (ps->jwh, 2 * ps->size_vars);
-  DELETEN (ps->vars, ps->size_vars);
-  DELETEN (ps->rnks, ps->size_vars);
-  DELETEN (ps->trail, ps->eot - ps->trail);
-  DELETEN (ps->heap, ps->eoh - ps->heap);
-  DELETEN (ps->als, ps->eoals - ps->als);
-  DELETEN (ps->CLS, ps->eocls - ps->CLS);
-  DELETEN (ps->rils, ps->eorils - ps->rils);
-  DELETEN (ps->cils, ps->eocils - ps->cils);
-  DELETEN (ps->fals, ps->eofals - ps->fals);
-  DELETEN (ps->mass, ps->szmass);
-  DELETEN (ps->mssass, ps->szmssass);
-  DELETEN (ps->mcsass, ps->szmcsass);
-  DELETEN (ps->humus, ps->szhumus);
-  DELETEN (ps->added, ps->eoa - ps->added);
-  DELETEN (ps->marked, ps->eom - ps->marked);
-  DELETEN (ps->dfs, ps->eod - ps->dfs);
-  DELETEN (ps->resolved, ps->eor - ps->resolved);
-  DELETEN (ps->levels, ps->eolevels - ps->levels);
-  DELETEN (ps->dused, ps->eodused - ps->dused);
-  DELETEN (ps->buffer, ps->eob - ps->buffer);
-  DELETEN (ps->indices, ps->eoi - ps->indices);
-  DELETEN (ps->soclauses, ps->eoso - ps->soclauses);
-  delete_prefix (ps);
-  delete (ps, ps->rline[0], ps->szrline);
-  delete (ps, ps->rline[1], ps->szrline);
-  assert (getenv ("LEAK") || !ps->current_bytes);	/* found leak if failing */
-#ifdef VISCORES
-  pclose (ps->fviscores);
-#endif
-  if (ps->edelete)
-    ps->edelete (ps->emgr, ps, sizeof *ps);
-  else
-    free (ps);
-}
-
-inline static void
-tpush (PS * ps, Lit * lit)
-{
-  assert (ps->lits < lit && lit <= ps->lits + 2* ps->max_var + 1);
-  if (ps->thead == ps->eot)
-    {
-      unsigned ttail2count = ps->ttail2 - ps->trail;
-      unsigned ttailcount = ps->ttail - ps->trail;
-#ifndef NADC
-      unsigned ttailadocount = ps->ttailado - ps->trail;
-#endif
-      ENLARGE (ps->trail, ps->thead, ps->eot);
-      ps->ttail = ps->trail + ttailcount;
-      ps->ttail2 = ps->trail + ttail2count;
-#ifndef NADC
-      ps->ttailado = ps->trail + ttailadocount;
-#endif
-    }
-
-  *ps->thead++ = lit;
-}
-
-static void
-assign_reason (PS * ps, Var * v, Cls * reason)
-{
-#if defined(NO_BINARY_CLAUSES) && !defined(NDEBUG)
-  assert (reason != &ps->impl);
-#else
-  (void) ps;
-#endif
-  v->reason = reason;
-}
-
-static void
-assign_phase (PS * ps, Lit * lit)
-{
-  unsigned new_phase, idx;
-  Var * v = LIT2VAR (lit);
-
-#ifndef NFL
-  /* In 'simplifying' mode we only need to keep 'min_flipped' up to date if
-   * we force assignments on the top level.   The other assignments will be
-   * undone and thus we can keep the old saved value of the phase.
-   */
-  if (!ps->LEVEL || !ps->simplifying)
-#endif
-    {
-      new_phase = (LIT2SGN (lit) > 0);
-
-      if (v->assigned)
-	{
-	  ps->sdflips -= ps->sdflips/FFLIPPED;
-
-	  if (new_phase != v->phase)
-	    {
-	      assert (FFLIPPEDPREC >= FFLIPPED);
-	      ps->sdflips += FFLIPPEDPREC / FFLIPPED;
-	      ps->flips++;
-
-	      idx = LIT2IDX (lit);
-	      if (idx < ps->min_flipped)
-		ps->min_flipped = idx;
-
-              NOLOG (fprintf (ps->out, 
-	                      "%sflipped %d\n",
-			       ps->prefix, LIT2INT (lit)));
-	    }
-	}
-
-      v->phase = new_phase;
-      v->assigned = 1;
-    }
-
-  lit->val = TRUE;
-  NOTLIT (lit)->val = FALSE;
-}
-
-inline static void
-assign (PS * ps, Lit * lit, Cls * reason)
-{
-  Var * v = LIT2VAR (lit);
-  assert (lit->val == UNDEF);
-#ifdef STATS
-  ps->assignments++;
-#endif
-  v->level = ps->LEVEL;
-  assign_phase (ps, lit);
-  assign_reason (ps, v, reason);
-  tpush (ps, lit);
-}
-
-inline static int
-cmp_added (PS * ps, Lit * k, Lit * l)
-{
-  Val a = k->val, b = l->val;
-  Var *u, *v;
-  int res;
-
-  if (a == UNDEF && b != UNDEF)
-    return -1;
-
-  if (a != UNDEF && b == UNDEF)
-    return 1;
-
-  u = LIT2VAR (k);
-  v = LIT2VAR (l);
-
-  if (a != UNDEF)
-    {
-      assert (b != UNDEF);
-      res = v->level - u->level;
-      if (res)
-	return res;		/* larger level first */
-    }
-
-  res = cmpflt (VAR2RNK (u)->score, VAR2RNK (v)->score);
-  if (res)
-    return res;			/* smaller activity first */
-
-  return u - v;			/* smaller index first */
-}
-
-static void
-sorttwolits (Lit ** v)
-{
-  Lit * a = v[0], * b = v[1];
-
-  assert (a != b);
-
-  if (a < b)
-    return;
-
-  v[0] = b;
-  v[1] = a;
-}
-
-inline static void
-sortlits (PS * ps, Lit ** v, unsigned size)
-{
-  if (size == 2)
-    sorttwolits (v);	/* same order with and with out 'NO_BINARY_CLAUSES' */
-  else
-    SORT (Lit *, cmp_added, v, size);
-}
-
-#ifdef NO_BINARY_CLAUSES
-static Cls *
-setimpl (PS * ps, Lit * a, Lit * b)
-{
-  assert (!ps->implvalid);
-  assert (ps->impl.size == 2);
-
-  ps->impl.lits[0] = a;
-  ps->impl.lits[1] = b;
-
-  sorttwolits (ps->impl.lits);
-  ps->implvalid = 1;
-
-  return &ps->impl;
-}
-
-static void
-resetimpl (PS * ps)
-{
-  ps->implvalid = 0;
-}
-
-static Cls *
-setcimpl (PS * ps, Lit * a, Lit * b)
-{
-  assert (!ps->cimplvalid);
-  assert (ps->cimpl.size == 2);
-
-  ps->cimpl.lits[0] = a;
-  ps->cimpl.lits[1] = b;
-
-  sorttwolits (ps->cimpl.lits);
-  ps->cimplvalid = 1;
-
-  return &ps->cimpl;
-}
-
-static void
-resetcimpl (PS * ps)
-{
-  assert (ps->cimplvalid);
-  ps->cimplvalid = 0;
-}
-
-#endif
-
-static int
-cmp_ptr (PS * ps, void *l, void *k)
-{
-  (void) ps;
-  return ((char*)l) - (char*)k;		/* arbitrarily already reverse */
-}
-
-static int
-cmp_rnk (Rnk * r, Rnk * s)
-{
-  if (!r->moreimportant && s->moreimportant)
-    return -1;
-
-  if (r->moreimportant && !s->moreimportant)
-    return 1;
-
-  if (!r->lessimportant && s->lessimportant)
-    return 1;
-
-  if (r->lessimportant && !s->lessimportant)
-    return -1;
-
-  if (r->score < s->score)
-    return -1;
-
-  if (r->score > s->score)
-    return 1;
-
-  return -cmp_ptr (0, r, s);
-}
-
-static void
-hup (PS * ps, Rnk * v)
-{
-  int upos, vpos;
-  Rnk *u;
-
-#ifndef NFL
-  assert (!ps->simplifying);
-#endif
-
-  vpos = v->pos;
-
-  assert (0 < vpos);
-  assert (vpos < ps->hhead - ps->heap);
-  assert (ps->heap[vpos] == v);
-
-  while (vpos > 1)
-    {
-      upos = vpos / 2;
-
-      u = ps->heap[upos];
-
-      if (cmp_rnk (u, v) > 0)
-	break;
-
-      ps->heap[vpos] = u;
-      u->pos = vpos;
-
-      vpos = upos;
-    }
-
-  ps->heap[vpos] = v;
-  v->pos = vpos;
-}
-
-static Cls *add_simplified_clause (PS *, int);
-
-inline static void
-add_antecedent (PS * ps, Cls * c)
-{
-  assert (c);
-
-#ifdef NO_BINARY_CLAUSES
-  if (ISLITREASON (c))
-    return;
-
-  if (c == &ps->impl)
-    return;
-#elif defined(STATS) && defined(TRACE)
-  ps->antecedents++;
-#endif
-  if (ps->rhead == ps->eor)
-    ENLARGE (ps->resolved, ps->rhead, ps->eor);
-
-  assert (ps->rhead < ps->eor);
-  *ps->rhead++ = c;
-}
-
-#ifdef TRACE
-
-#ifdef NO_BINARY_CLAUSES
-#error "can not combine TRACE and NO_BINARY_CLAUSES"
-#endif
-
-#endif /* TRACE */
-
-static void
-add_lit (PS * ps, Lit * lit)
-{
-  assert (lit);
-
-  if (ps->ahead == ps->eoa)
-    ENLARGE (ps->added, ps->ahead, ps->eoa);
-
-  *ps->ahead++ = lit;
-}
-
-static void
-push_var_as_marked (PS * ps, Var * v)
-{
-  if (ps->mhead == ps->eom)
-    ENLARGE (ps->marked, ps->mhead, ps->eom);
-
-  *ps->mhead++ = v;
-}
-
-static void
-mark_var (PS * ps, Var * v)
-{
-  assert (!v->mark);
-  v->mark = 1;
-  push_var_as_marked (ps, v);
-}
-
-#ifdef NO_BINARY_CLAUSES
-
-static Cls *
-impl2reason (PS * ps, Lit * lit)
-{
-  Lit * other;
-  Cls * res;
-  other = ps->impl.lits[0];
-  if (lit == other)
-    other = ps->impl.lits[1];
-  assert (other->val == FALSE);
-  res = LIT2REASON (NOTLIT (other));
-  resetimpl (ps);
-  return res;
-}
-
-#endif
-
-/* Whenever we have a top level derived unit we really should derive a unit
- * clause otherwise the resolutions in 'add_simplified_clause' become
- * incorrect.
- */
-static Cls *
-resolve_top_level_unit (PS * ps, Lit * lit, Cls * reason)
-{
-  unsigned count_resolved;
-  Lit **p, **eol, *other;
-  Var *u, *v;
-
-  assert (ps->rhead == ps->resolved);
-  assert (ps->ahead == ps->added);
-
-  add_lit (ps, lit);
-  add_antecedent (ps, reason);
-  count_resolved = 1;
-  v = LIT2VAR (lit);
-
-  eol = end_of_lits (reason);
-  for (p = reason->lits; p < eol; p++)
-    {
-      other = *p;
-      u = LIT2VAR (other);
-      if (u == v)
-	continue;
-
-      add_antecedent (ps, u->reason);
-      count_resolved++;
-    }
-
-  /* Some of the literals could be assumptions.  If at least one
-   * variable is not an assumption, we should resolve.
-   */
-  if (count_resolved >= 2)
-    {
-#ifdef NO_BINARY_CLAUSES
-      if (reason == &ps->impl)
-	resetimpl (ps);
-#endif
-      reason = add_simplified_clause (ps, 1);
-#ifdef NO_BINARY_CLAUSES
-      if (reason->size == 2)
-	{
-	  assert (reason == &ps->impl);
-	  reason = impl2reason (ps, lit);
-	}
-#endif
-      assign_reason (ps, v, reason);
-    }
-  else
-    {
-      ps->ahead = ps->added;
-      ps->rhead = ps->resolved;
-    }
-
-  return reason;
-}
-
-static void
-fixvar (PS * ps, Var * v)
-{
-  Rnk * r;
-
-  assert (VAR2LIT (v) != UNDEF);
-  assert (!v->level);
-
-  ps->fixed++;
-
-  r = VAR2RNK (v);
-  r->score = INFFLT;
-
-#ifndef NFL
-  if (ps->simplifying)
-    return;
-#endif
-
-  if (!r->pos)
-    return;
-
-  hup (ps, r);
-}
-
-static void
-use_var (PS * ps, Var * v)
-{
-  if (v->used)
-    return;
-
-  v->used = 1;
-  ps->vused++;
-}
-
-static void
-assign_forced (PS * ps, Lit * lit, Cls * reason)
-{
-  Var *v;
-
-  assert (reason);
-  assert (lit->val == UNDEF);
-
-#ifdef STATS
-  ps->FORCED++;
-#endif
-  assign (ps, lit, reason);
-
-#ifdef NO_BINARY_CLAUSES
-  assert (reason != &ps->impl);
-  if (ISLITREASON (reason)) 
-    {
-      reason = setimpl (ps, lit, NOTLIT (REASON2LIT (reason)));
-      assert (reason);
-    }
-#endif
-  LOG ( fprintf (ps->out,
-                "%sassign %d at level %d by ",
-                ps->prefix, LIT2INT (lit), ps->LEVEL);
-       dumpclsnl (ps, reason));
-
-  v = LIT2VAR (lit);
-  if (!ps->LEVEL)
-    use_var (ps, v);
-
-  if (!ps->LEVEL && reason->size > 1)
-    {
-      reason = resolve_top_level_unit (ps, lit, reason);
-      assert (reason);
-    }
-
-#ifdef NO_BINARY_CLAUSES
-  if (ISLITREASON (reason) || reason == &ps->impl)
-    {
-      /* DO NOTHING */
-    }
-  else
-#endif
-    {
-      assert (!reason->locked);
-      reason->locked = 1;
-      if (reason->learned && reason->size > 2)
-	ps->llocked++;
-    }
-
-#ifdef NO_BINARY_CLAUSES
-  if (reason == &ps->impl)
-    resetimpl (ps);
-#endif
-
-  if (!ps->LEVEL)
-    fixvar (ps, v);
-}
-
-#ifdef NO_BINARY_CLAUSES
-
-static void
-lpush (PS * ps, Lit * lit, Cls * c)
-{
-  int pos = (c->lits[0] == lit);
-  Ltk * s = LIT2IMPLS (lit);
-  unsigned oldsize, newsize;
-
-  assert (c->size == 2);
-
-  if (!s->start)
-    {
-      assert (!s->count);
-      assert (!s->ldsize);
-      NEWN (s->start, 1);
-    }
-  else 
-    {
-      oldsize = (1 << (s->ldsize));
-      assert (s->count <= oldsize);
-      if (s->count == oldsize)
-	{
-	  newsize = 2 * oldsize;
-	  RESIZEN (s->start, oldsize, newsize);
-	  s->ldsize++;
-	}
-    }
-
-  s->start[s->count++] = c->lits[pos];
-}
-
-#endif
-
-static void
-connect_head_tail (PS * ps, Lit * lit, Cls * c)
-{
-  Cls ** s;
-  assert (c->size >= 1);
-  if (c->size == 2)
-    {
-#ifdef NO_BINARY_CLAUSES
-      lpush (ps, lit, c);
-      return;
-#else
-      s = LIT2IMPLS (lit);
-#endif
-    }
-  else
-    s = LIT2HTPS (lit);
-
-  if (c->lits[0] != lit)
-    {
-      assert (c->size >= 2);
-      assert (c->lits[1] == lit);
-      c->next[1] = *s;
-    }
-  else
-    c->next[0] = *s;
-
-  *s = c;
-}
-
-#ifdef TRACE
-static void
-zpush (PS * ps, Zhn * zhain)
-{
-  assert (ps->trace);
-
-  if (ps->zhead == ps->eoz)
-    ENLARGE (ps->zhains, ps->zhead, ps->eoz);
-
-  *ps->zhead++ = zhain;
-}
-
-static int
-cmp_resolved (PS * ps, Cls * c, Cls * d)
-{
-#ifndef NDEBUG
-  assert (ps->trace);
-#else
-  (void) ps;
-#endif
-  return CLS2IDX (c) - CLS2IDX (d);
-}
-
-static void
-bpushc (PS * ps, unsigned char ch)
-{
-  if (ps->bhead == ps->eob)
-    ENLARGE (ps->buffer, ps->bhead, ps->eob);
-
-  *ps->bhead++ = ch;
-}
-
-static void
-bpushu (PS * ps, unsigned u)
-{
-  while (u & ~0x7f)
-    {
-      bpushc (ps, u | 0x80);
-      u >>= 7;
-    }
-
-  bpushc (ps, u);
-}
-
-static void
-bpushd (PS * ps, unsigned prev, unsigned this)
-{
-  unsigned delta;
-  assert (prev < this);
-  delta = this - prev;
-  bpushu (ps, delta);
-}
-
-static void
-add_zhain (PS * ps)
-{
-  unsigned prev, this, count, rcount;
-  Cls **p, *c;
-  Zhn *res;
-
-  assert (ps->trace);
-  assert (ps->bhead == ps->buffer);
-  assert (ps->rhead > ps->resolved);
-
-  rcount = ps->rhead - ps->resolved;
-  SORT (Cls *, cmp_resolved, ps->resolved, rcount);
-
-  prev = 0;
-  for (p = ps->resolved; p < ps->rhead; p++)
-    {
-      c = *p;
-      this = CLS2TRD (c)->idx;
-      bpushd (ps, prev, this);
-      prev = this;
-    }
-  bpushc (ps, 0);
-
-  count = ps->bhead - ps->buffer;
-
-  res = new (ps, sizeof (Zhn) + count);
-  res->core = 0;
-  res->ref = 0;
-  memcpy (res->znt, ps->buffer, count);
-
-  ps->bhead = ps->buffer;
-#ifdef STATS
-  ps->znts += count - 1;
-#endif
-  zpush (ps, res);
-}
-
-#endif
-
-static void
-add_resolved (PS * ps, int learned)
-{
-#if defined(STATS) || defined(TRACE)
-  Cls **p, *c;
-
-  for (p = ps->resolved; p < ps->rhead; p++)
-    {
-      c = *p;
-      if (c->used)
-	continue;
-
-      c->used = 1;
-
-      if (c->size <= 2)
-	continue;
-
-#ifdef STATS
-      if (c->learned)
-	ps->llused++;
-      else
-	ps->loused++;
-#endif
-    }
-#endif
-
-#ifdef TRACE
-  if (learned && ps->trace)
-    add_zhain (ps);
-#else
-  (void) learned;
-#endif
-  ps->rhead = ps->resolved;
-}
-
-static void
-incjwh (PS * ps, Cls * c)
-{
-  Lit **p, *lit, ** eol;
-  Flt * f, inc, sum;
-  unsigned size = 0;
-  Var * v;
-  Val val;
-
-  eol = end_of_lits (c);
-
-  for (p = c->lits; p < eol; p++)
-    {
-      lit = *p;
-      val = lit->val;
-
-      if (val && ps->LEVEL > 0)
-	{
-	  v = LIT2VAR (lit);
-	  if (v->level > 0)
-	    val = UNDEF;
-	}
-
-      if (val == TRUE)
-	return;
-
-      if (val != FALSE)
-	size++;
-    }
-
-  inc = base2flt (1, -size);
-
-  for (p = c->lits; p < eol; p++)
-    {
-      lit = *p;
-      f = LIT2JWH (lit);
-      sum = addflt (*f, inc);
-      *f = sum;
-    }
-}
-
-static void
-write_rup_header (PS * ps, FILE * file)
-{
-  char line[80];
-  int i;
-
-  sprintf (line, "%%RUPD32 %u %u", ps->rupvariables, ps->rupclauses);
-
-  fputs (line, file);
-  for (i = 255 - strlen (line); i >= 0; i--)
-    fputc (' ', file);
-
-  fputc ('\n', file);
-  fflush (file);
-}
-
-static Cls *
-add_simplified_clause (PS * ps, int learned)
-{
-  unsigned num_true, num_undef, num_false, size, count_resolved;
-  Lit **p, **q, *lit, ** end;
-  unsigned litlevel, glue;
-  Cls *res, * reason;
-  int reentered;
-  Val val;
-  Var *v;
-#if !defined(NDEBUG) && defined(TRACE)
-  unsigned idx;
-#endif
-
-  reentered = 0;
-
-REENTER:
-
-  size = ps->ahead - ps->added;
-
-  add_resolved (ps, learned);
-
-  if (learned)
-    {
-      ps->ladded++;
-      ps->llitsadded += size;
-      if (size > 2)
-	{
-	  ps->lladded++;
-	  ps->nlclauses++;
-	  ps->llits += size;
-	}
-    }
-  else
-    {
-      ps->oadded++;
-      if (size > 2)
-	{
-	  ps->loadded++;
-	  ps->noclauses++;
-	  ps->olits += size;
-	}
-    }
-
-  ps->addedclauses++;
-  assert (ps->addedclauses == ps->ladded + ps->oadded);
-
-#ifdef NO_BINARY_CLAUSES
-  if (size == 2)
-    res = setimpl (ps, ps->added[0], ps->added[1]);
-  else
-#endif
-    {
-      sortlits (ps, ps->added, size); 
-
-      if (learned)
-	{
-	  if (ps->lhead == ps->EOL)
-	    {
-	      ENLARGE (ps->lclauses, ps->lhead, ps->EOL);
-
-	      /* A very difficult to find bug, which only occurs if the
-	       * learned clauses stack is immediately allocated before the
-	       * original clauses stack without padding.  In this case, we
-	       * have 'SOC == EOC', which terminates all loops using the
-	       * idiom 'for (p = SOC; p != EOC; p = NXC(p))' immediately.
-	       * Unfortunately this occurred in 'fix_clause_lits' after
-	       * using a recent version of the memory allocator of 'Google'
-	       * perftools in the context of one large benchmark for 
-	       * our SMT solver 'Boolector'.
-	       */
-	      if (ps->EOL == ps->oclauses)
-		ENLARGE (ps->lclauses, ps->lhead, ps->EOL);
-	    }
-
-#if !defined(NDEBUG) && defined(TRACE)
-	  idx = LIDX2IDX (ps->lhead - ps->lclauses);
-#endif
-	}
-      else
-	{
-	  if (ps->ohead == ps->eoo)
-	    {
-	      ENLARGE (ps->oclauses, ps->ohead, ps->eoo);
-	      if (ps->EOL == ps->oclauses)
-		ENLARGE (ps->oclauses, ps->ohead, ps->eoo);	/* ditto */
-	    }
-
-#if !defined(NDEBUG) && defined(TRACE)
-	  idx = OIDX2IDX (ps->ohead - ps->oclauses);
-#endif
-	}
-
-      assert (ps->EOL != ps->oclauses);			/* ditto */
-
-      res = new_clause (ps, size, learned);
-
-      glue = 0;
-
-      if (learned)
-	{
-	  assert (ps->dusedhead == ps->dused);
-
-	  for (p = ps->added; p < ps->ahead; p++) 
-	    {
-	      lit = *p;
-	      if (lit->val)
-		{
-		  litlevel = LIT2VAR (lit)->level;
-		  assert (litlevel <= ps->LEVEL);
-		  while (ps->levels + litlevel >= ps->levelshead)
-		    {
-		      if (ps->levelshead >= ps->eolevels)
-			ENLARGE (ps->levels, ps->levelshead, ps->eolevels);
-		      assert (ps->levelshead < ps->eolevels);
-		      *ps->levelshead++ = 0;
-		    }
-		  if (!ps->levels[litlevel])
-		    {
-		      if (ps->dusedhead >= ps->eodused)
-			ENLARGE (ps->dused, ps->dusedhead, ps->eodused);
-		      assert (ps->dusedhead < ps->eodused);
-		      *ps->dusedhead++ = litlevel;
-		      ps->levels[litlevel] = 1;
-		      glue++;
-		    }
-		}
-	      else
-		glue++;
-	    }
-
-	  while (ps->dusedhead > ps->dused) 
-	    {
-	      litlevel = *--ps->dusedhead;
-	      assert (ps->levels + litlevel < ps->levelshead);
-	      assert (ps->levels[litlevel]);
-	      ps->levels[litlevel] = 0;
-	    }
-	}
-
-      assert (glue <= MAXGLUE);
-      res->glue = glue;
-
-#if !defined(NDEBUG) && defined(TRACE)
-      if (ps->trace)
-	assert (CLS2IDX (res) == idx);
-#endif
-      if (learned)
-	*ps->lhead++ = res;
-      else
-	*ps->ohead++ = res;
-
-#if !defined(NDEBUG) && defined(TRACE)
-      if (ps->trace && learned)
-	assert (ps->zhead - ps->zhains == ps->lhead - ps->lclauses);
-#endif
-      assert (ps->lhead != ps->oclauses);		/* ditto */
-    }
-
-  if (learned && ps->rup)
-    {
-      if (!ps->rupstarted)
-	{
-	  write_rup_header (ps, ps->rup);
-	  ps->rupstarted = 1;
-	}
-    }
-
-  num_true = num_undef = num_false = 0;
-
-  q = res->lits;
-  for (p = ps->added; p < ps->ahead; p++)
-    {
-      lit = *p;
-      *q++ = lit;
-
-      if (learned && ps->rup)
-	fprintf (ps->rup, "%d ", LIT2INT (lit));
-
-      val = lit->val;
-
-      num_true += (val == TRUE);
-      num_undef += (val == UNDEF);
-      num_false += (val == FALSE);
-    }
-  assert (num_false + num_true + num_undef == size);
-
-  if (learned && ps->rup)
-    fputs ("0\n", ps->rup);
-
-  ps->ahead = ps->added;		/* reset */
-
-  if (!reentered)				// TODO merge
-  if (size > 0)
-    {
-      assert (size <= 2 || !reentered);		// TODO remove
-      connect_head_tail (ps, res->lits[0], res);
-      if (size > 1)
-	connect_head_tail (ps, res->lits[1], res);
-    }
-
-  if (size == 0)
-    {
-      if (!ps->mtcls)
-	ps->mtcls = res;
-    }
-
-#ifdef NO_BINARY_CLAUSES
-  if (size != 2)
-#endif
-#ifndef NDEBUG
-    res->connected = 1;
-#endif
-
-  LOG ( fprintf (ps->out, "%s%s ", ps->prefix, learned ? "learned" : "original");
-        dumpclsnl (ps, res));
-
-  /* Shrink clause by resolving it against top level assignments.
-   */
-  if (!ps->LEVEL && num_false > 0)
-    {
-      assert (ps->ahead == ps->added);
-      assert (ps->rhead == ps->resolved);
-
-      count_resolved = 1;
-      add_antecedent (ps, res);
-
-      end = end_of_lits (res);
-      for (p = res->lits; p < end; p++)
-	{
-	  lit = *p;
-	  v = LIT2VAR (lit);
-	  use_var (ps, v);
-
-	  if (lit->val == FALSE)
-	    {
-	      add_antecedent (ps, v->reason);
-	      count_resolved++;
-	    }
-	  else
-	    add_lit (ps, lit);
-	}
-
-      assert (count_resolved >= 2);
-
-      learned = 1;
-#ifdef NO_BINARY_CLAUSES
-      if (res == &ps->impl)
-	resetimpl (ps);
-#endif
-      reentered = 1;
-      goto REENTER;		/* and return simplified clause */
-    }
-
-  if (!num_true && num_undef == 1)	/* unit clause */
-    {
-      lit = 0;
-      for (p = res->lits; p < res->lits + size; p++)
-	{
-	  if ((*p)->val == UNDEF)
-	    lit = *p;
-
-	  v = LIT2VAR (*p);
-	  use_var (ps, v);
-	}
-      assert (lit);
-
-      reason = res;
-#ifdef NO_BINARY_CLAUSES
-      if (size == 2)
-        {
-	  Lit * other = res->lits[0];
-	  if (other == lit)
-	    other = res->lits[1];
-
-	  assert (other->val == FALSE);
-	  reason = LIT2REASON (NOTLIT (other));
-	}
-#endif
-      assign_forced (ps, lit, reason);
-      num_true++;
-    }
-
-  if (num_false == size && !ps->conflict)
-    {
-#ifdef NO_BINARY_CLAUSES
-      if (res == &ps->impl)
-	ps->conflict = setcimpl (ps, res->lits[0], res->lits[1]);
-      else
-#endif
-      ps->conflict = res;
-    }
-
-  if (!learned && !num_true && num_undef)
-    incjwh (ps, res);
-
-#ifdef NO_BINARY_CLAUSES
-  if (res == &ps->impl)
-    resetimpl (ps);
-#endif
-  return res;
-}
-
-static int
-trivial_clause (PS * ps)
-{
-  Lit **p, **q, *prev;
-  Var *v;
-
-  SORT (Lit *, cmp_ptr, ps->added,  ps->ahead - ps->added);
-
-  prev = 0;
-  q = ps->added;
-  for (p = q; p < ps->ahead; p++)
-    {
-      Lit *this = *p;
-
-      v = LIT2VAR (this);
-
-      if (prev == this)		/* skip repeated literals */
-	continue;
-
-      /* Top level satisfied ? 
-       */
-      if (this->val == TRUE && !v->level)
-	 return 1;
-
-      if (prev == NOTLIT (this))/* found pair of dual literals */
-	return 1;
-
-      *q++ = prev = this;
-    }
-
-  ps->ahead = q;			/* shrink */
-
-  return 0;
-}
-
-static void
-simplify_and_add_original_clause (PS * ps)
-{
-#ifdef NO_BINARY_CLAUSES
-  Cls * c;
-#endif
-  if (trivial_clause (ps))
-    {
-      ps->ahead = ps->added;
-
-      if (ps->ohead == ps->eoo)
-	ENLARGE (ps->oclauses, ps->ohead, ps->eoo);
-
-      *ps->ohead++ = 0;
-
-      ps->addedclauses++;
-      ps->oadded++;
-    }
-  else
-    {
-      if (ps->CLS != ps->clshead)
-	add_lit (ps, NOTLIT (ps->clshead[-1]));
-
-#ifdef NO_BINARY_CLAUSES
-      c = 
-#endif
-      add_simplified_clause (ps, 0);
-#ifdef NO_BINARY_CLAUSES
-      if (c == &ps->impl) assert (!ps->implvalid);
-#endif
-    }
-}
-
-#ifndef NADC
-
-static void
-add_ado (PS * ps)
-{
-  unsigned len = ps->ahead - ps->added;
-  Lit ** ado, ** p, ** q, *lit;
-  Var * v, * u;
-
-#ifdef TRACE
-  assert (!ps->trace);
-#endif
-
-  ABORTIF (ps->ados < ps->hados && llength (ps->ados[0]) != len,
-           "internal: non matching all different constraint object lengths");
-
-  if (ps->hados == ps->eados)
-    ENLARGE (ps->ados, ps->hados, ps->eados);
-
-  NEWN (ado, len + 1);
-  *ps->hados++ = ado;
-
-  p = ps->added;
-  q = ado;
-  u = 0;
-  while (p < ps->ahead)
-    {
-      lit = *p++;
-      v = LIT2VAR (lit);
-      ABORTIF (v->inado, 
-               "internal: variable in multiple all different objects");
-      v->inado = ado;
-      if (!u && !lit->val)
-	u = v;
-      *q++ = lit;
-    }
-
-  assert (q == ado + len);
-  *q++ = 0;
-
-  /* TODO simply do a conflict test as in propado */
-
-  ABORTIF (!u,
-    "internal: "
-    "adding fully instantiated all different object not implemented yet");
-
-  assert (u);
-  assert (u->inado == ado);
-  assert (!u->ado);
-  u->ado = ado;
-
-  ps->ahead = ps->added;
-}
-
-#endif
-
-static void
-hdown (PS * ps, Rnk * r)
-{
-  unsigned end, rpos, cpos, opos;
-  Rnk *child, *other;
-
-  assert (r->pos > 0);
-  assert (ps->heap[r->pos] == r);
-
-  end = ps->hhead - ps->heap;
-  rpos = r->pos;
-
-  for (;;)
-    {
-      cpos = 2 * rpos;
-      if (cpos >= end)
-	break;
-
-      opos = cpos + 1;
-      child = ps->heap[cpos];
-
-      if (cmp_rnk (r, child) < 0)
-	{
-	  if (opos < end)
-	    {
-	      other = ps->heap[opos];
-
-	      if (cmp_rnk (child, other) < 0)
-		{
-		  child = other;
-		  cpos = opos;
-		}
-	    }
-	}
-      else if (opos < end)
-	{
-	  child = ps->heap[opos];
-
-	  if (cmp_rnk (r, child) >= 0)
-	    break;
-
-	  cpos = opos;
-	}
-      else
-	break;
-
-      ps->heap[rpos] = child;
-      child->pos = rpos;
-      rpos = cpos;
-    }
-
-  r->pos = rpos;
-  ps->heap[rpos] = r;
-}
-
-static Rnk *
-htop (PS * ps)
-{
-  assert (ps->hhead > ps->heap + 1);
-  return ps->heap[1];
-}
-
-static Rnk *
-hpop (PS * ps)
-{
-  Rnk *res, *last;
-  unsigned end;
-
-  assert (ps->hhead > ps->heap + 1);
-
-  res = ps->heap[1];
-  res->pos = 0;
-
-  end = --ps->hhead - ps->heap;
-  if (end == 1)
-    return res;
-
-  last = ps->heap[end];
-
-  ps->heap[last->pos = 1] = last;
-  hdown (ps, last);
-
-  return res;
-}
-
-inline static void
-hpush (PS * ps, Rnk * r)
-{
-  assert (!r->pos);
-
-  if (ps->hhead == ps->eoh)
-    ENLARGE (ps->heap, ps->hhead, ps->eoh);
-
-  r->pos = ps->hhead++ - ps->heap;
-  ps->heap[r->pos] = r;
-  hup (ps, r);
-}
-
-static void
-fix_trail_lits (PS * ps, long delta)
-{
-  Lit **p;
-  for (p = ps->trail; p < ps->thead; p++)
-    *p += delta;
-}
-
-#ifdef NO_BINARY_CLAUSES
-static void
-fix_impl_lits (PS * ps, long delta)
-{
-  Ltk * s;
-  Lit ** p;
-
-  for (s = ps->impls + 2; s <= ps->impls + 2 * ps->max_var + 1; s++)
-    for (p = s->start; p < s->start + s->count; p++)
-      *p += delta;
-}
-#endif
-
-static void
-fix_clause_lits (PS * ps, long delta)
-{
-  Cls **p, *clause;
-  Lit **q, *lit, **eol;
-
-  for (p = SOC; p != EOC; p = NXC (p))
-    {
-      clause = *p;
-      if (!clause)
-	continue;
-
-      q = clause->lits;
-      eol = end_of_lits (clause);
-      while (q < eol)
-	{
-	  assert (q - clause->lits <= (int) clause->size);
-	  lit = *q;
-	  lit += delta;
-	  *q++ = lit;
-	}
-    }
-}
-
-static void
-fix_added_lits (PS * ps, long delta)
-{
-  Lit **p;
-  for (p = ps->added; p < ps->ahead; p++)
-    *p += delta;
-}
-
-static void
-fix_assumed_lits (PS * ps, long delta)
-{
-  Lit **p;
-  for (p = ps->als; p < ps->alshead; p++)
-    *p += delta;
-}
-
-static void
-fix_cls_lits (PS * ps, long delta)
-{
-  Lit **p;
-  for (p = ps->CLS; p < ps->clshead; p++)
-    *p += delta;
-}
-
-static void
-fix_heap_rnks (PS * ps, long delta)
-{
-  Rnk **p;
-
-  for (p = ps->heap + 1; p < ps->hhead; p++)
-    *p += delta;
-}
-
-#ifndef NADC
-
-static void
-fix_ado (long delta, Lit ** ado)
-{
-  Lit ** p;
-  for (p = ado; *p; p++)
-    *p += delta;
-}
-
-static void
-fix_ados (PS * ps, long delta)
-{
-  Lit *** p;
-
-  for (p = ps->ados; p < ps->hados; p++)
-    fix_ado (delta, *p);
-}
-
-#endif
-
-static void
-enlarge (PS * ps, unsigned new_size_vars)
-{
-  long rnks_delta, lits_delta;
-  Lit *old_lits = ps->lits;
-  Rnk *old_rnks = ps->rnks;
-
-  RESIZEN (ps->lits, 2 * ps->size_vars, 2 * new_size_vars);
-  RESIZEN (ps->jwh, 2 * ps->size_vars, 2 * new_size_vars);
-  RESIZEN (ps->htps, 2 * ps->size_vars, 2 * new_size_vars);
-#ifndef NDSC
-  RESIZEN (ps->dhtps, 2 * ps->size_vars, 2 * new_size_vars);
-#endif
-  RESIZEN (ps->impls, 2 * ps->size_vars, 2 * new_size_vars);
-  RESIZEN (ps->vars, ps->size_vars, new_size_vars);
-  RESIZEN (ps->rnks, ps->size_vars, new_size_vars);
-
-  if ((lits_delta = ps->lits - old_lits))
-    {
-      fix_trail_lits (ps, lits_delta);
-      fix_clause_lits (ps, lits_delta);
-      fix_added_lits (ps, lits_delta);
-      fix_assumed_lits (ps, lits_delta);
-      fix_cls_lits (ps, lits_delta);
-#ifdef NO_BINARY_CLAUSES
-      fix_impl_lits (ps, lits_delta);
-#endif
-#ifndef NADC
-      fix_ados (ps, lits_delta);
-#endif
-    }
-
-  if ((rnks_delta = ps->rnks - old_rnks))
-    {
-      fix_heap_rnks (ps, rnks_delta);
-    }
-
-  assert (ps->mhead == ps->marked);
-
-  ps->size_vars = new_size_vars;
-}
-
-static void
-unassign (PS * ps, Lit * lit)
-{
-  Cls *reason;
-  Var *v;
-  Rnk *r;
-
-  assert (lit->val == TRUE);
-
-  LOG ( fprintf (ps->out, "%sunassign %d\n", ps->prefix, LIT2INT (lit)));
-
-  v = LIT2VAR (lit);
-  reason = v->reason;
-
-#ifdef NO_BINARY_CLAUSES
-  assert (reason != &ps->impl);
-  if (ISLITREASON (reason))
-    {
-      /* DO NOTHING */
-    }
-  else
-#endif
-  if (reason)
-    {
-      assert (reason->locked);
-      reason->locked = 0;
-      if (reason->learned && reason->size > 2)
-	{
-	  assert (ps->llocked > 0);
-	  ps->llocked--;
-	}
-    }
-
-  lit->val = UNDEF;
-  NOTLIT (lit)->val = UNDEF;
-
-  r = VAR2RNK (v);
-  if (!r->pos)
-    hpush (ps, r);
-
-#ifndef NDSC
-  {
-    Cls * p, * next, ** q;
-
-    q = LIT2DHTPS (lit);
-    p = *q;
-    *q = 0;
-
-    while (p)
-      {
-	Lit * other = p->lits[0];
-
-	if (other == lit)
-	  {
-	    other = p->lits[1];
-	    q = p->next + 1;
-	  }
-	else
-	  {
-	    assert (p->lits[1] == lit);
-	    q = p->next;
-	  }
-
-	next = *q;
-	*q = *LIT2HTPS (other);
-	*LIT2HTPS (other) = p;
-	p = next;
-      }
-  }
-#endif
-
-#ifndef NADC
-  if (v->adotabpos)
-    {
-      assert (ps->nadotab);
-      assert (*v->adotabpos == v->ado);
-
-      *v->adotabpos = 0;
-      v->adotabpos = 0;
-
-      ps->nadotab--;
-    }
-#endif
-}
-
-static Cls *
-var2reason (PS * ps, Var * var)
-{
-  Cls * res = var->reason;
-#ifdef NO_BINARY_CLAUSES
-  Lit * this, * other;
-  if (ISLITREASON (res))
-    {
-      this = VAR2LIT (var);
-      if (this->val == FALSE)
-	this = NOTLIT (this);
-
-      other = REASON2LIT (res);
-      assert (other->val == TRUE);
-      assert (this->val == TRUE);
-      res = setimpl (ps, NOTLIT (other), this);
-    }
-#else
-  (void) ps;
-#endif
-  return res;
-}
-
-static void
-mark_clause_to_be_collected (Cls * c)
-{
-  assert (!c->collect);
-  c->collect = 1;
-}
-
-static void
-undo (PS * ps, unsigned new_level)
-{
-  Lit *lit;
-  Var *v;
-
-  while (ps->thead > ps->trail)
-    {
-      lit = *--ps->thead;
-      v = LIT2VAR (lit);
-      if (v->level == new_level)
-	{
-	  ps->thead++;		/* fix pre decrement */
-	  break;
-	}
-
-      unassign (ps, lit);
-    }
-
-  ps->LEVEL = new_level;
-  ps->ttail = ps->thead;
-  ps->ttail2 = ps->thead;
-#ifndef NADC
-  ps->ttailado = ps->thead;
-#endif
-
-#ifdef NO_BINARY_CLAUSES
-  if (ps->conflict == &ps->cimpl)
-    resetcimpl (ps);
-#endif
-#ifndef NADC
-  if (ps->conflict && ps->conflict == ps->adoconflict)
-    resetadoconflict (ps);
-#endif
-  ps->conflict = ps->mtcls;
-  if (ps->LEVEL < ps->adecidelevel)
-    {
-      assert (ps->als < ps->alshead);
-      ps->adecidelevel = 0;
-      ps->alstail = ps->als;
-    }
-  LOG ( fprintf (ps->out, "%sback to level %u\n", ps->prefix, ps->LEVEL));
-}
-
-#ifndef NDEBUG
-
-static int
-clause_satisfied (Cls * c)
-{
-  Lit **p, **eol, *lit;
-
-  eol = end_of_lits (c);
-  for (p = c->lits; p < eol; p++)
-    {
-      lit = *p;
-      if (lit->val == TRUE)
-	return 1;
-    }
-
-  return 0;
-}
-
-static void
-original_clauses_satisfied (PS * ps)
-{
-  Cls **p, *c;
-
-  for (p = ps->oclauses; p < ps->ohead; p++)
-    {
-      c = *p;
-
-      if (!c)
-	continue;
-
-      if (c->learned)
-	continue;
-
-      assert (clause_satisfied (c));
-    }
-}
-
-static void
-assumptions_satisfied (PS * ps)
-{
-  Lit *lit, ** p;
-
-  for (p = ps->als; p < ps->alshead; p++)
-    {
-      lit = *p;
-      assert (lit->val == TRUE);
-    }
-}
-
-#endif
-
-static void
-sflush (PS * ps)
-{
-  double now = picosat_time_stamp ();
-  double delta = now - ps->entered;
-  delta = (delta < 0) ? 0 : delta;
-  ps->seconds += delta;
-  ps->entered = now;
-}
-
-static double
-mb (PS * ps)
-{
-  return ps->current_bytes / (double) (1 << 20);
-}
-
-static double
-avglevel (PS * ps)
-{
-  return ps->decisions ? ps->levelsum / ps->decisions : 0.0;
-}
-
-static void
-rheader (PS * ps)
-{
-  assert (ps->lastrheader <= ps->reports);
-
-  if (ps->lastrheader == ps->reports)
-    return;
-
-  ps->lastrheader = ps->reports;
-
-   fprintf (ps->out, "%s\n", ps->prefix);
-   fprintf (ps->out, "%s %s\n", ps->prefix, ps->rline[0]);
-   fprintf (ps->out, "%s %s\n", ps->prefix, ps->rline[1]);
-   fprintf (ps->out, "%s\n", ps->prefix);
-}
-
-static unsigned
-dynamic_flips_per_assignment_per_mille (PS * ps)
-{
-  assert (FFLIPPEDPREC >= 1000);
-  return ps->sdflips / (FFLIPPEDPREC / 1000);
-}
-
-#ifdef NLUBY
-
-static int
-high_agility (PS * ps)
-{
-  return dynamic_flips_per_assignment_per_mille (ps) >= 200;
-}
-
-static int
-very_high_agility (PS * ps)
-{
-  return dynamic_flips_per_assignment_per_mille (ps) >= 250;
-}
-
-#else
-
-static int
-medium_agility (PS * ps)
-{
-  return dynamic_flips_per_assignment_per_mille (ps) >= 230;
-}
-
-#endif
-
-static void
-relemdata (PS * ps)
-{
-  char *p;
-  int x;
-
-  if (ps->reports < 0)
-    {
-      /* strip trailing white space 
-       */
-      for (x = 0; x <= 1; x++)
-	{
-	  p = ps->rline[x] + strlen (ps->rline[x]);
-	  while (p-- > ps->rline[x])
-	    {
-	      if (*p != ' ')
-		break;
-
-	      *p = 0;
-	    }
-	}
-
-      rheader (ps);
-    }
-  else
-    fputc ('\n', ps->out);
-
-  ps->RCOUNT = 0;
-}
-
-static void
-relemhead (PS * ps, const char * name, int fp, double val)
-{
-  int x, y, len, size;
-  const char *fmt;
-  unsigned tmp, e;
-
-  if (ps->reports < 0)
-    {
-      x = ps->RCOUNT & 1;
-      y = (ps->RCOUNT / 2) * 12 + x * 6;
-
-      if (ps->RCOUNT == 1)
-	sprintf (ps->rline[1], "%6s", "");
-
-      len = strlen (name);
-      while (ps->szrline <= len + y + 1)
-	{
-	  size = ps->szrline ? 2 * ps->szrline : 128;
-	  ps->rline[0] = resize (ps, ps->rline[0], ps->szrline, size);
-	  ps->rline[1] = resize (ps, ps->rline[1], ps->szrline, size);
-	  ps->szrline = size;
-	}
-
-      fmt = (len <= 6) ? "%6s%10s" : "%-10s%4s";
-      sprintf (ps->rline[x] + y, fmt, name, "");
-    }
-  else if (val < 0)
-    {
-      assert (fp);
-
-      if (val > -100 && (tmp = val * 10.0 - 0.5) > -1000.0)
-	{
-	   fprintf (ps->out, "-%4.1f ", -tmp / 10.0);
-	}
-      else
-	{
-	  tmp = -val / 10.0 + 0.5;
-	  e = 1;
-	  while (tmp >= 100)
-	    {
-	      tmp /= 10;
-	      e++;
-	    }
-
-	   fprintf (ps->out, "-%2ue%u ", tmp, e);
-	}
-    }
-  else
-    {
-      if (fp && val < 1000 && (tmp = val * 10.0 + 0.5) < 10000)
-	{
-	   fprintf (ps->out, "%5.1f ", tmp / 10.0);
-	}
-      else if (!fp && (tmp = val) < 100000)
-	{
-	   fprintf (ps->out, "%5u ", tmp);
-	}
-      else
-	{
-	  tmp = val / 10.0 + 0.5;
-	  e = 1;
-
-	  while (tmp >= 1000)
-	    {
-	      tmp /= 10;
-	      e++;
-	    }
-
-	   fprintf (ps->out, "%3ue%u ", tmp, e);
-	}
-    }
-
-  ps->RCOUNT++;
-}
-
-inline static void
-relem (PS * ps, const char *name, int fp, double val)
-{
-  if (name)
-    relemhead (ps, name, fp, val);
-  else
-    relemdata (ps);
-}
-
-static unsigned
-reduce_limit_on_lclauses (PS * ps)
-{
-  unsigned res = ps->lreduce;
-  res += ps->llocked;
-  return res;
-}
-
-static void
-report (PS * ps, int replevel, char type)
-{
-  int rounds;
-
-#ifdef RCODE
-  (void) type;
-#endif
-
-  if (ps->verbosity < replevel)
-    return;
-
-  sflush (ps);
-
-  if (!ps->reports)
-    ps->reports = -1;
-
-  for (rounds = (ps->reports < 0) ? 2 : 1; rounds; rounds--)
-    {
-      if (ps->reports >= 0)
-	 fprintf (ps->out, "%s%c ", ps->prefix, type);
-
-      relem (ps, "seconds", 1, ps->seconds);
-      relem (ps, "level", 1, avglevel (ps));
-      assert (ps->fixed <=  ps->max_var);
-      relem (ps, "variables", 0, ps->max_var - ps->fixed);
-      relem (ps, "used", 1, PERCENT (ps->vused, ps->max_var));
-      relem (ps, "original", 0, ps->noclauses);
-      relem (ps, "conflicts", 0, ps->conflicts);
-      // relem (ps, "decisions", 0, ps->decisions);
-      // relem (ps, "conf/dec", 1, PERCENT(ps->conflicts,ps->decisions));
-      // relem (ps, "limit", 0, reduce_limit_on_lclauses (ps));
-      relem (ps, "learned", 0, ps->nlclauses);
-      // relem (ps, "limit", 1, PERCENT (ps->nlclauses, reduce_limit_on_lclauses (ps)));
-      relem (ps, "limit", 0, ps->lreduce);
-#ifdef STATS
-      relem (ps, "learning", 1, PERCENT (ps->llused, ps->lladded));
-#endif
-      relem (ps, "agility", 1, dynamic_flips_per_assignment_per_mille (ps) / 10.0);
-      // relem (ps, "original", 0, ps->noclauses);
-      relem (ps, "MB", 1, mb (ps));
-      // relem (ps, "lladded", 0, ps->lladded);
-      // relem (ps, "llused", 0, ps->llused);
-
-      relem (ps, 0, 0, 0);
-
-      ps->reports++;
-    }
-
-  /* Adapt this to the number of rows in your terminal.
-   */
-  #define ROWS 25
-
-  if (ps->reports % (ROWS - 3) == (ROWS - 4))
-    rheader (ps);
-
-  fflush (ps->out);
-}
-
-static int
-bcp_queue_is_empty (PS * ps)
-{
-  if (ps->ttail != ps->thead)
-    return 0;
-
-  if (ps->ttail2 != ps->thead)
-    return 0;
-
-#ifndef NADC
-  if (ps->ttailado != ps->thead)
-    return 0;
-#endif
-
-  return 1;
-}
-
-static int
-satisfied (PS * ps)
-{
-  assert (!ps->mtcls);
-  assert (!ps->failed_assumption);
-  if (ps->alstail < ps->alshead)
-    return 0;
-  assert (!ps->conflict);
-  assert (bcp_queue_is_empty (ps));
-  return ps->thead == ps->trail + ps->max_var;	/* all assigned */
-}
-
-static void
-vrescore (PS * ps)
-{
-  Rnk *p, *eor = ps->rnks + ps->max_var;
-  for (p = ps->rnks + 1; p <= eor; p++)
-    if (p->score != INFFLT)
-      p->score = mulflt (p->score, ps->ilvinc);
-  ps->vinc = mulflt (ps->vinc, ps->ilvinc);;
-#ifdef VISCORES
-  ps->nvinc = mulflt (ps->nvinc, ps->lscore);;
-#endif
-}
-
-static void
-inc_score (PS * ps, Var * v)
-{
-  Flt score;
-  Rnk *r;
-
-#ifndef NFL
-  if (ps->simplifying)
-    return;
-#endif
-
-  if (!v->level)
-    return;
-
-  if (v->internal)
-    return;
-
-  r = VAR2RNK (v);
-  score = r->score;
-
-  assert (score != INFFLT);
-
-  score = addflt (score, ps->vinc);
-  assert (score < INFFLT);
-  r->score = score;
-  if (r->pos > 0)
-    hup (ps, r);
-
-  if (score > ps->lscore)
-    vrescore (ps);
-}
-
-static void
-inc_activity (PS * ps, Cls * c)
-{
-  Act *p;
-
-  if (!c->learned)
-    return;
-
-  if (c->size <= 2)
-    return;
-
-  p = CLS2ACT (c);
-  *p = addflt (*p, ps->cinc);
-}
-
-static unsigned
-hashlevel (unsigned l)
-{
-  return 1u << (l & 31);
-}
-
-static void
-push (PS * ps, Var * v)
-{
-  if (ps->dhead == ps->eod)
-    ENLARGE (ps->dfs, ps->dhead, ps->eod);
-
-  *ps->dhead++ = v;
-}
-
-static Var * 
-pop (PS * ps)
-{
-  assert (ps->dfs < ps->dhead);
-  return *--ps->dhead;
-}
-
-static void
-analyze (PS * ps)
-{
-  unsigned open, minlevel, siglevels, l, old, i, orig;
-  Lit *this, *other, **p, **q, **eol;
-  Var *v, *u, **m, *start, *uip;
-  Cls *c;
-
-  assert (ps->conflict);
-
-  assert (ps->ahead == ps->added);
-  assert (ps->mhead == ps->marked);
-  assert (ps->rhead == ps->resolved);
-
-  /* First, search for First UIP variable and mark all resolved variables.
-   * At the same time determine the minimum decision level involved.
-   * Increase activities of resolved variables.
-   */
-  q = ps->thead;
-  open = 0;
-  minlevel = ps->LEVEL;
-  siglevels = 0;
-  uip = 0;
-
-  c = ps->conflict;
-
-  for (;;)
-    {
-      add_antecedent (ps, c);
-      inc_activity (ps, c);
-      eol = end_of_lits (c);
-      for (p = c->lits; p < eol; p++)
-	{
-	  other = *p;
-
-	  if (other->val == TRUE)
-	    continue;
-
-	  assert (other->val == FALSE);
-
-	  u = LIT2VAR (other);
-	  if (u->mark)
-	    continue;
-	  
-	  u->mark = 1;
-	  inc_score (ps, u);
-	  use_var (ps, u);
-
-	  if (u->level == ps->LEVEL)
-	    {
-	      open++;
-	    }
-	  else 
-	    {
-	      push_var_as_marked (ps, u);
-
-	      if (u->level)
-		{
-		  /* The statistics counter 'nonminimizedllits' sums up the
-		   * number of literals that would be added if only the
-		   * 'first UIP' scheme for learned clauses would be used
-		   * and no clause minimization.
-		   */
-		  ps->nonminimizedllits++;
-
-		  if (u->level < minlevel)
-		    minlevel = u->level;
-
-		  siglevels |= hashlevel (u->level);
-		}
-	      else
-		{
-		  assert (!u->level);
-		  assert (u->reason);
-		}
-	    }
-	}
-
-      do
-	{
-	  if (q == ps->trail)
-	    {
-	      uip = 0;
-	      goto DONE_FIRST_UIP;
-	    }
-
-	  this = *--q;
-	  uip = LIT2VAR (this);
-	}
-      while (!uip->mark);
-
-      uip->mark = 0;
-
-      c = var2reason (ps, uip);
-#ifdef NO_BINARY_CLAUSES
-      if (c == &ps->impl)
-	resetimpl (ps);
-#endif
-     open--;
-     if ((!open && ps->LEVEL) || !c)
-	break;
-
-     assert (c);
-    }
-
-DONE_FIRST_UIP:
-
-  if (uip)
-    {
-      assert (ps->LEVEL);
-      this = VAR2LIT (uip);
-      this += (this->val == TRUE);
-      ps->nonminimizedllits++;
-      ps->minimizedllits++;
-      add_lit (ps, this);
-#ifdef STATS
-      if (uip->reason)
-	ps->uips++;
-#endif
-    }
-  else
-    assert (!ps->LEVEL);
-
-  /* Second, try to mark more intermediate variables, with the goal to
-   * minimize the conflict clause.  This is a DFS from already marked
-   * variables backward through the implication graph.  It tries to reach
-   * other marked variables.  If the search reaches an unmarked decision
-   * variable or a variable assigned below the minimum level of variables in
-   * the first uip learned clause or a level on which no variable has been
-   * marked, then the variable from which the DFS is started is not
-   * redundant.  Otherwise the start variable is redundant and will
-   * eventually be removed from the learned clause in step 4.  We initially
-   * implemented BFS, but then profiling revelead that this step is a bottle
-   * neck for certain incremental applications.  After switching to DFS this
-   * hot spot went away.
-   */
-  orig = ps->mhead - ps->marked;
-  for (i = 0; i < orig; i++)
-    {
-      start = ps->marked[i];
-
-      assert (start->mark);
-      assert (start != uip);
-      assert (start->level < ps->LEVEL);
-
-      if (!start->reason)
-	continue;
-
-      old = ps->mhead - ps->marked;
-      assert (ps->dhead == ps->dfs);
-      push (ps, start);
-
-      while (ps->dhead > ps->dfs)
-	{
-	  u = pop (ps);
-	  assert (u->mark);
-
-	  c = var2reason (ps, u);
-#ifdef NO_BINARY_CLAUSES
-	  if (c == &ps->impl)
-	    resetimpl (ps);
-#endif
-	  if (!c || 
-	      ((l = u->level) && 
-	       (l < minlevel || ((hashlevel (l) & ~siglevels)))))
-	    {
-	      while (ps->mhead > ps->marked + old)	/* reset all marked */
-		(*--ps->mhead)->mark = 0;
-
-	      ps->dhead = ps->dfs;		/* and DFS stack */
-	      break;
-	    }
-
-	  eol = end_of_lits (c);
-	  for (p = c->lits; p < eol; p++)
-	    {
-	      v = LIT2VAR (*p);
-	      if (v->mark)
-		continue;
-
-	      mark_var (ps, v);
-	      push (ps, v);
-	    }
-	}
-    }
-
-  for (m = ps->marked; m < ps->mhead; m++)
-    {
-      v = *m;
-
-      assert (v->mark);
-      assert (!v->resolved);
-
-      use_var (ps, v);
-
-      c = var2reason (ps, v);
-      if (!c)
-	continue;
-
-#ifdef NO_BINARY_CLAUSES
-      if (c == &ps->impl)
-	resetimpl (ps);
-#endif
-      eol = end_of_lits (c);
-      for (p = c->lits; p < eol; p++)
-	{
-	  other = *p;
-
-	  u = LIT2VAR (other);
-	  if (!u->level)
-	    continue;
-
-	  if (!u->mark)		/* 'MARKTEST' */
-	    break;
-	}
-
-      if (p != eol)
-	continue;
-
-      add_antecedent (ps, c);
-      v->resolved = 1;
-    }
-
-  for (m = ps->marked; m < ps->mhead; m++)
-    {
-      v = *m;
-
-      assert (v->mark);
-      v->mark = 0;
-
-      if (v->resolved)
-	{
-	  v->resolved = 0;
-	  continue;
-	}
-
-      this = VAR2LIT (v);
-      if (this->val == TRUE)
-	this++;			/* actually NOTLIT */
-
-      add_lit (ps, this);
-      ps->minimizedllits++;
-    }
-
-  assert (ps->ahead <= ps->eoa);
-  assert (ps->rhead <= ps->eor);
-
-  ps->mhead = ps->marked;
-}
-
-static void
-fanalyze (PS * ps)
-{
-  Lit ** eol, ** p, * lit;
-  Cls * c, * reason;
-  Var * v, * u;
-  int next;
-
-#ifndef RCODE
-  double start = picosat_time_stamp ();
-#endif
-
-  assert (ps->failed_assumption);
-  assert (ps->failed_assumption->val == FALSE);
-
-  v = LIT2VAR (ps->failed_assumption);
-  reason = var2reason (ps, v);
-  if (!reason) return;
-#ifdef NO_BINARY_CLAUSES
-  if (reason == &ps->impl)
-    resetimpl (ps);
-#endif
-
-  eol = end_of_lits (reason);
-  for (p = reason->lits; p != eol; p++)
-    {
-      lit = *p;
-      u = LIT2VAR (lit);
-      if (u == v) continue;
-      if (u->reason) break;
-    }
-  if (p == eol) return;
-
-  assert (ps->ahead == ps->added);
-  assert (ps->mhead == ps->marked);
-  assert (ps->rhead == ps->resolved);
-
-  next = 0;
-  mark_var (ps, v);
-  add_lit (ps, NOTLIT (ps->failed_assumption));
-
-  do
-    {
-      v = ps->marked[next++];
-      use_var (ps, v);
-      if (v->reason)
-	{
-	  reason = var2reason (ps, v);
-#ifdef NO_BINARY_CLAUSES
-	  if (reason == &ps->impl)
-	    resetimpl (ps);
-#endif
-	  add_antecedent (ps, reason);
-	  eol = end_of_lits (reason);
-	  for (p = reason->lits; p != eol; p++)
-	    {
-	      lit = *p;
-	      u = LIT2VAR (lit);
-	      if (u == v) continue;
-	      if (u->mark) continue;
-	      mark_var (ps, u);
-	    }
-	}
-      else
-	{
-	  lit = VAR2LIT (v);
-	  if (lit->val == TRUE) lit = NOTLIT (lit);
-	  add_lit (ps, lit);
-	}
-    } 
-  while (ps->marked + next < ps->mhead);
-
-  c = add_simplified_clause (ps, 1);
-  v = LIT2VAR (ps->failed_assumption);
-  reason = v->reason;
-#ifdef NO_BINARY_CLAUSES
-  if (!ISLITREASON (reason))
-#endif
-    {
-      assert (reason->locked);
-      reason->locked = 0;
-      if (reason->learned && reason->size > 2)
-	{
-	  assert (ps->llocked > 0);
-	  ps->llocked--;
-	}
-    }
-
-#ifdef NO_BINARY_CLAUSES
-  if (c == &ps->impl)
-    {
-      c = impl2reason (ps, NOTLIT (ps->failed_assumption));
-    }
-  else
-#endif
-    {
-      assert (c->learned);
-      assert (!c->locked);
-      c->locked = 1;
-      if (c->size > 2)
-	{
-	  ps->llocked++;
-	  assert (ps->llocked > 0);
-	}
-    }
-
-  v->reason = c;
-
-  while (ps->mhead > ps->marked)
-    (*--ps->mhead)->mark = 0;
-
-  if (ps->verbosity)
-     fprintf (ps->out, "%sfanalyze took %.1f seconds\n", 
-	     ps->prefix, picosat_time_stamp () - start);
-}
-
-/* Propagate assignment of 'this' to 'FALSE' by visiting all binary clauses in
- * which 'this' occurs.
- */
-inline static void
-prop2 (PS * ps, Lit * this)
-{
-#ifdef NO_BINARY_CLAUSES
-  Lit ** l, ** start;
-  Ltk * lstk;
-#else
-  Cls * c, ** p;
-  Cls * next;
-#endif
-  Lit * other;
-  Val tmp;
-
-  assert (this->val == FALSE);
-
-#ifdef NO_BINARY_CLAUSES
-  lstk = LIT2IMPLS (this);
-  start = lstk->start;
-  l = start + lstk->count;
-  while (l != start)
-    {
-      /* The counter 'visits' is the number of clauses that are
-       * visited during propagations of assignments.
-       */
-      ps->visits++;
-#ifdef STATS
-      ps->bvisits++;
-#endif
-      other = *--l;
-      tmp = other->val;
-
-      if (tmp == TRUE)
-	{
-#ifdef STATS
-	  ps->othertrue++;
-	  ps->othertrue2++;
-	  if (LIT2VAR (other)->level < ps->LEVEL)
-	    ps->othertrue2u++;
-#endif
-	  continue;
-	}
-
-      if (tmp != FALSE)
-	{
-	  assign_forced (ps, other, LIT2REASON (NOTLIT(this)));
-	  continue;
-	}
-
-      if (ps->conflict == &ps->cimpl)
-	resetcimpl (ps);
-      ps->conflict = setcimpl (ps, this, other);
-    }
-#else
-  /* Traverse all binary clauses with 'this'.  Head/Tail pointers for binary
-   * clauses do not have to be modified here.
-   */
-  p = LIT2IMPLS (this);
-  for (c = *p; c; c = next)
-    {
-      ps->visits++;
-#ifdef STATS
-      ps->bvisits++;
-#endif
-      assert (!c->collect);
-#ifdef TRACE
-      assert (!c->collected);
-#endif
-      assert (c->size == 2);
-      
-      other = c->lits[0];
-      if (other == this)
-	{
-	  next = c->next[0];
-	  other = c->lits[1];
-	}
-      else
-	next = c->next[1];
-
-      tmp = other->val;
-
-      if (tmp == TRUE)
-	{
-#ifdef STATS
-	  ps->othertrue++;
-	  ps->othertrue2++;
-	  if (LIT2VAR (other)->level < ps->LEVEL)
-	    ps->othertrue2u++;
-#endif
-	  continue;
-	}
-
-      if (tmp == FALSE)
-	ps->conflict = c;
-      else
-	assign_forced (ps, other, c);	/* unit clause */
-    }
-#endif /* !defined(NO_BINARY_CLAUSES) */
-}
-
-#ifndef NDSC
-static int
-should_disconnect_head_tail (PS * ps, Lit * lit)
-{
-  unsigned litlevel;
-  Var * v;
-
-  assert (lit->val == TRUE);
-
-  v = LIT2VAR (lit);
-  litlevel = v->level;
-
-  if (!litlevel)
-    return 1;
-
-#ifndef NFL
-  if (ps->simplifying)
-    return 0;
-#endif
-
-  return litlevel < ps->LEVEL;
-}
-#endif
-
-inline static void
-propl (PS * ps, Lit * this)
-{
-  Lit **l, *other, *prev, *new_lit, **eol;
-  Cls *next, **htp_ptr, **new_htp_ptr;
-  Cls *c;
-#ifdef STATS
-  unsigned size;
-#endif
-
-  htp_ptr = LIT2HTPS (this);
-  assert (this->val == FALSE);
-
-  /* Traverse all non binary clauses with 'this'.  Head/Tail pointers are
-   * updated as well.
-   */
-  for (c = *htp_ptr; c; c = next)
-    {
-      ps->visits++;
-#ifdef STATS
-      size = c->size;
-      assert (size >= 3);
-      ps->traversals++;	/* other is dereferenced at least */
-
-      if (size == 3)
-	ps->tvisits++;
-      else if (size >= 4)
-	{
-	  ps->lvisits++;
-	  ps->ltraversals++;
-	}
-#endif
-#ifdef TRACE
-      assert (!c->collected);
-#endif
-      assert (c->size > 0);
-
-      other = c->lits[0];
-      if (other != this)
-	{
-	  assert (c->size != 1);
-	  c->lits[0] = this;
-	  c->lits[1] = other;
-	  next = c->next[1];
-	  c->next[1] = c->next[0];
-	  c->next[0] = next;
-	}
-      else if (c->size == 1)	/* With assumptions we need to
-	                         * traverse unit clauses as well.
-			         */
-	{
-	  assert (!ps->conflict);
-	  ps->conflict = c;
-	  break;
-	}
-      else
-	{
-	  assert (other == this && c->size > 1);
-	  other = c->lits[1];
-	  next = c->next[0];
-	}
-      assert (other == c->lits[1]);
-      assert (this == c->lits[0]);
-      assert (next == c->next[0]);
-      assert (!c->collect);
-
-      if (other->val == TRUE)
-	{
-#ifdef STATS
-	  ps->othertrue++;
-	  ps->othertruel++;
-#endif
-#ifndef NDSC
-	  if (should_disconnect_head_tail (ps, other))
-	    {
-	      new_htp_ptr = LIT2DHTPS (other);
-	      c->next[0] = *new_htp_ptr;
-	      *new_htp_ptr = c;
-#ifdef STATS
-	      ps->othertruelu++;
-#endif
-	      *htp_ptr = next;
-	      continue;
-	    }
-#endif
-	  htp_ptr = c->next;
-	  continue;
-	}
-
-      l = c->lits + 1;
-      eol = (Lit**) c->lits + c->size;
-      prev = this;
-
-      while (++l != eol)
-	{
-#ifdef STATS
-	  if (size >= 3)
-	    {
-	      ps->traversals++;
-	      if (size > 3)
-		ps->ltraversals++;
-	    }
-#endif
-	  new_lit = *l;
-	  *l = prev;
-	  prev = new_lit;
-	  if (new_lit->val != FALSE) break;
-	}
-
-      if (l == eol)
-	{
-	  while (l > c->lits + 2) 
-	    {
-	      new_lit = *--l;
-	      *l = prev;
-	      prev = new_lit;
-	    }
-	  assert (c->lits[0] == this);
-
-	  assert (other == c->lits[1]);
-	  if (other->val == FALSE)	/* found conflict */
-	    {
-	      assert (!ps->conflict);
-	      ps->conflict = c;
-	      return;
-	    }
-
-	  assign_forced (ps, other, c);		/* unit clause */
-	  htp_ptr = c->next;
-	}
-      else
-	{
-	  assert (new_lit->val == TRUE || new_lit->val == UNDEF);
-	  c->lits[0] = new_lit;
-	  // *l = this;
-	  new_htp_ptr = LIT2HTPS (new_lit);
-	  c->next[0] = *new_htp_ptr;
-	  *new_htp_ptr = c;
-	  *htp_ptr = next;
-	}
-    }
-}
-
-#ifndef NADC
-
-static unsigned primes[] = { 996293, 330643, 753947, 500873 };
-
-#define PRIMES ((sizeof primes)/sizeof *primes)
-
-static unsigned
-hash_ado (PS * ps, Lit ** ado, unsigned salt)
-{
-  unsigned i, res, tmp;
-  Lit ** p, * lit;
-
-  assert (salt < PRIMES);
-
-  i = salt;
-  res = 0;
-
-  for (p = ado; (lit = *p); p++)
-    {
-      assert (lit->val);
-
-      tmp = res >> 31;
-      res <<= 1;
-
-      if (lit->val > 0)
-	res |= 1;
-
-      assert (i < PRIMES);
-      res *= primes[i++];
-      if (i == PRIMES)
-	i = 0;
-
-      res += tmp;
-    }
-
-  return res & (ps->szadotab - 1);
-}
-
-static unsigned
-cmp_ado (Lit ** a, Lit ** b)
-{
-  Lit ** p, ** q, * l, * k;
-  int res;
-
-  for (p = a, q = b; (l = *p); p++, q++)
-    {
-      k = *q;
-      assert (k);
-      if ((res = (l->val - k->val)))
-	return res;
-    }
-
-  assert (!*q);
-
-  return 0;
-}
-
-static Lit ***
-find_ado (PS * ps, Lit ** ado)
-{
-  Lit *** res, ** other;
-  unsigned pos, delta;
-
-  pos = hash_ado (ps, ado, 0);
-  assert (pos < ps->szadotab);
-  res = ps->adotab + pos;
-
-  other = *res;
-  if (!other || !cmp_ado (other, ado))
-    return res;
-
-  delta = hash_ado (ps, ado, 1);
-  if (!(delta & 1))
-    delta++;
-
-  assert (delta & 1);
-  assert (delta < ps->szadotab);
-
-  for (;;)
-    {
-      pos += delta;
-      if (pos >= ps->szadotab)
-	pos -= ps->szadotab;
-
-      assert (pos < ps->szadotab);
-      res = ps->adotab + pos;
-      other = *res;
-      if (!other || !cmp_ado (other, ado))
-	return res;
-    }
-}
-
-static void
-enlarge_adotab (PS * ps)
-{
-  /* TODO make this generic */
-
-  ABORTIF (ps->szadotab, 
-           "internal: all different objects table needs larger initial size");
-  assert (!ps->nadotab);
-  ps->szadotab = 10000;
-  NEWN (ps->adotab, ps->szadotab);
-  CLRN (ps->adotab, ps->szadotab);
-}
-
-static int
-propado (PS * ps, Var * v)
-{
-  Lit ** p, ** q, *** adotabpos, **ado, * lit;
-  Var * u;
-
-  if (ps->LEVEL && ps->adodisabled)
-    return 1;
-
-  assert (!ps->conflict);
-  assert (!ps->adoconflict);
-  assert (VAR2LIT (v)->val != UNDEF);
-  assert (!v->adotabpos);
-
-  if (!v->ado)
-    return 1;
-
-  assert (v->inado);
-
-  for (p = v->ado; (lit = *p); p++)
-    if (lit->val == UNDEF)
-      {
-	u = LIT2VAR (lit);
-	assert (!u->ado);
-	u->ado = v->ado;
-	v->ado = 0;
-
-	return 1;
-      }
-
-  if (4 * ps->nadotab >= 3 * ps->szadotab)	/* at least 75% filled */
-    enlarge_adotab (ps);
-
-  adotabpos = find_ado (ps, v->ado);
-  ado = *adotabpos;
-
-  if (!ado)
-    {
-      ps->nadotab++;
-      v->adotabpos = adotabpos;
-      *adotabpos = v->ado;
-      return 1;
-    }
-
-  assert (ado != v->ado);
-
-  ps->adoconflict = new_clause (ps, 2 * llength (ado), 1);
-  q = ps->adoconflict->lits;
-
-  for (p = ado; (lit = *p); p++)
-    *q++ = lit->val == FALSE ? lit : NOTLIT (lit);
-
-  for (p = v->ado; (lit = *p); p++)
-    *q++ = lit->val == FALSE ? lit : NOTLIT (lit);
-
-  assert (q == ENDOFCLS (ps->adoconflict));
-  ps->conflict = ps->adoconflict;
-  ps->adoconflicts++;
-  return 0;
-}
-
-#endif
-
-static void
-bcp (PS * ps)
-{
-  int props = 0;
-  assert (!ps->conflict);
-
-  if (ps->mtcls)
-    return;
-
-  for (;;)
-    {
-      if (ps->ttail2 < ps->thead)	/* prioritize implications */
-	{
-	  props++;
-	  prop2 (ps, NOTLIT (*ps->ttail2++));
-	}
-      else if (ps->ttail < ps->thead)	/* unit clauses or clauses with length > 2 */
-	{
-	  if (ps->conflict) break;
-	  propl (ps, NOTLIT (*ps->ttail++));
-	  if (ps->conflict) break;
-	}
-#ifndef NADC
-      else if (ps->ttailado < ps->thead)
-	{
-	  if (ps->conflict) break;
-	  propado (ps, LIT2VAR (*ps->ttailado++));
-	  if (ps->conflict) break;
-	}
-#endif
-      else
-	break;		/* all assignments propagated, so break */
-    }
-
-  ps->propagations += props;
-}
-
-static unsigned
-drive (PS * ps)
-{
-  unsigned res, vlevel;
-  Lit **p;
-  Var *v;
-
-  res = 0;
-  for (p = ps->added; p < ps->ahead; p++)
-    {
-      v = LIT2VAR (*p);
-      vlevel = v->level;
-      assert (vlevel <= ps->LEVEL);
-      if (vlevel < ps->LEVEL && vlevel > res)
-	res = vlevel;
-    }
-
-  return res;
-}
-
-#ifdef VISCORES
-
-static void
-viscores (PS * ps)
-{
-  Rnk *p, *eor = ps->rnks + ps->max_var;
-  char name[100], cmd[200];
-  FILE * data;
-  Flt s;
-  int i;
-
-  for (p = ps->rnks + 1; p <= ps->eor; p++)
-    {
-      s = p->score;
-      if (s == INFFLT)
-	continue;
-      s = mulflt (s, ps->nvinc);
-      assert (flt2double (s) <= 1.0);
-    }
-
-  sprintf (name, "/tmp/picosat-viscores/data/%08u", ps->conflicts);
-  sprintf (cmd, "sort -n|nl>%s", name);
-
-  data = popen (cmd, "w");
-  for (p = ps->rnks + 1; p <= ps->eor; p++)
-    {
-      s = p->score;
-      if (s == INFFLT)
-	continue;
-      s = mulflt (s, ps->nvinc);
-      fprintf (data, "%lf %d\n", 100.0 * flt2double (s), (int)(p - ps->rnks));
-    }
-  fflush (data);
-  pclose (data);
-
-  for (i = 0; i < 8; i++)
-    {
-      sprintf (cmd, "awk '$3%%8==%d' %s>%s.%d", i, name, name, i);
-      system (cmd);
-    }
-
-  fprintf (ps->fviscores, "set title \"%u\"\n", ps->conflicts);
-  fprintf (ps->fviscores, "plot [0:%u] 0, 100 * (1 - 1/1.1), 100", ps->max_var);
-
-  for (i = 0; i < 8; i++)
-    fprintf (ps->fviscores, 
-             ", \"%s.%d\" using 1:2:3 with labels tc lt %d", 
-	     name, i, i + 1);
-
-  fputc ('\n', ps->fviscores);
-  fflush (ps->fviscores);
-#ifndef WRITEGIF
-  usleep (50000);		/* refresh rate of 20 Hz */
-#endif
-}
-
-#endif
-
-static void
-crescore (PS * ps)
-{
-  Cls **p, *c;
-  Act *a;
-  Flt factor;
-  int l = log2flt (ps->cinc);
-  assert (l > 0);
-  factor = base2flt (1, -l);
-
-  for (p = ps->lclauses; p != ps->lhead; p++)
-    {
-      c = *p;
-
-      if (!c)
-	continue;
-
-#ifdef TRACE
-      if (c->collected)
-	continue;
-#endif
-      assert (c->learned);
-
-      if (c->size <= 2)
-	continue;
-
-      a = CLS2ACT (c);
-      *a = mulflt (*a, factor);
-    }
-
-  ps->cinc = mulflt (ps->cinc, factor);
-}
-
-static void
-inc_vinc (PS * ps)
-{
-#ifdef VISCORES
-  ps->nvinc = mulflt (ps->nvinc, ps->fvinc);
-#endif
-  ps->vinc = mulflt (ps->vinc, ps->ifvinc);
-}
-
-inline static void
-inc_max_var (PS * ps)
-{
-  Lit *lit;
-  Rnk *r;
-  Var *v;
-
-  assert (ps->max_var < ps->size_vars);
-
-  if (ps->max_var + 1 == ps->size_vars)
-    enlarge (ps, ps->size_vars + 2*(ps->size_vars + 3) / 4); /* +25% */
-
-  ps->max_var++;			/* new index of variable */
-  assert (ps->max_var);			/* no unsigned overflow */
-
-  assert (ps->max_var < ps->size_vars);
-
-  lit = ps->lits + 2 * ps->max_var;
-  lit[0].val = lit[1].val = UNDEF;
-
-  memset (ps->htps + 2 * ps->max_var, 0, 2 * sizeof *ps->htps);
-#ifndef NDSC
-  memset (ps->dhtps + 2 * ps->max_var, 0, 2 * sizeof *ps->dhtps);
-#endif
-  memset (ps->impls + 2 * ps->max_var, 0, 2 * sizeof *ps->impls);
-  memset (ps->jwh + 2 * ps->max_var, 0, 2 * sizeof *ps->jwh);
-
-  v = ps->vars + ps->max_var;		/* initialize variable components */
-  CLR (v);
-
-  r = ps->rnks + ps->max_var;		/* initialize rank */
-  CLR (r);
-
-  hpush (ps, r);
-}
-
-static void
-force (PS * ps, Cls * c)
-{
-  Lit ** p, ** eol, * lit, * forced;
-  Cls * reason;
-
-  forced = 0;
-  reason = c;
-
-  eol = end_of_lits (c);
-  for (p = c->lits; p < eol; p++)
-    {
-      lit = *p;
-      if (lit->val == UNDEF)
-	{
-	  assert (!forced);
-	  forced = lit;
-#ifdef NO_BINARY_CLAUSES
-	  if (c == &ps->impl)
-	    reason = LIT2REASON (NOTLIT (p[p == c->lits ? 1 : -1]));
-#endif
-	}
-      else
-	assert (lit->val == FALSE);
-    }
-
-#ifdef NO_BINARY_CLAUSES
-  if (c == &ps->impl)
-    resetimpl (ps);
-#endif
-  if (!forced)
-    return;
-
-  assign_forced (ps, forced, reason);
-}
-
-static void
-inc_lreduce (PS * ps)
-{
-#ifdef STATS
-  ps->inclreduces++;
-#endif
-  ps->lreduce *= FREDUCE;
-  ps->lreduce /= 100;
-  report (ps, 1, '+');
-}
-
-static void
-backtrack (PS * ps)
-{
-  unsigned new_level;
-  Cls * c;
-
-  ps->conflicts++;
-  LOG ( fprintf (ps->out, "%sconflict ", ps->prefix); dumpclsnl (ps, ps->conflict));
-
-  analyze (ps);
-  new_level = drive (ps);
-  // TODO: why not? assert (new_level != 1  || (ps->ahead - ps->added) == 2);
-  c = add_simplified_clause (ps, 1);
-  undo (ps, new_level);
-  force (ps, c);
-
-  if (
-#ifndef NFL
-      !ps->simplifying && 
-#endif
-      !--ps->lreduceadjustcnt)
-    {
-      /* With FREDUCE==110 and FREDADJ=121 we stir 'lreduce' to be
-       * proportional to 'sqrt(conflicts)'.  In earlier version we actually
-       * used  'FREDADJ=150', which results in 'lreduce' to approximate
-       * 'conflicts^(log(1.1)/log(1.5))' which is close to the fourth root
-       * of 'conflicts', since log(1.1)/log(1.5)=0.235 (as observed by
-       * Donald Knuth). The square root is the same we get by a Glucose
-       * style increase, which simply adds a constant at every reduction.
-       * This would be way simpler to implement but for now we keep the more
-       * complicated code using the adjust increments and counters.
-       */
-      ps->lreduceadjustinc *= FREDADJ; ps->lreduceadjustinc /= 100; ps->lreduceadjustcnt
-      = ps->lreduceadjustinc;
-      inc_lreduce (ps);
-    }
-
-  if (ps->verbosity >= 4 && !(ps->conflicts % 1000))
-    report (ps, 4, 'C');
-}
-
-static void
-inc_cinc (PS * ps)
-{
-  ps->cinc = mulflt (ps->cinc, ps->fcinc);
-  if (ps->lcinc < ps->cinc)
-    crescore (ps);
-}
-
-static void
-incincs (PS * ps)
-{
-  inc_vinc (ps);
-  inc_cinc (ps);
-#ifdef VISCORES
-  viscores (ps);
-#endif
-}
-
-static void
-disconnect_clause (PS * ps, Cls * c)
-{
-  assert (c->connected);
-
-  if (c->size > 2)
-    {
-      if (c->learned)
-	{
-	  assert (ps->nlclauses > 0);
-	  ps->nlclauses--;
-
-	  assert (ps->llits >= c->size);
-	  ps->llits -= c->size;
-	}
-      else
-	{
-	  assert (ps->noclauses > 0);
-	  ps->noclauses--;
-
-	  assert (ps->olits >= c->size);
-	  ps->olits -= c->size;
-	}
-    }
-
-#ifndef NDEBUG
-  c->connected = 0;
-#endif
-}
-
-static int
-clause_is_toplevel_satisfied (PS * ps, Cls * c)
-{
-  Lit *lit, **p, **eol = end_of_lits (c);
-  Var *v;
-
-  for (p = c->lits; p < eol; p++)
-    {
-      lit = *p;
-      if (lit->val == TRUE)
-	{
-	  v = LIT2VAR (lit);
-	  if (!v->level)
-	    return 1;
-	}
-    }
-
-  return 0;
-}
-
-static int
-collect_clause (PS * ps, Cls * c)
-{
-  assert (c->collect);
-  c->collect = 0;
-
-#ifdef TRACE
-  assert (!c->collected);
-  c->collected = 1;
-#endif
-  disconnect_clause (ps, c);
-
-#ifdef TRACE
-  if (ps->trace && (!c->learned || c->used))
-    return 0;
-#endif
-  delete_clause (ps, c);
-
-  return 1;
-}
-
-static size_t
-collect_clauses (PS * ps)
-{
-  Cls *c, **p, **q, * next;
-  Lit * lit, * eol;
-  size_t res;
-  int i;
-
-  res = ps->current_bytes;
-
-  eol = ps->lits + 2 * ps->max_var + 1;
-  for (lit = ps->lits + 2; lit <= eol; lit++)
-    {
-      for (i = 0; i <= 1; i++)
-	{
-	  if (i)
-	    {
-#ifdef NO_BINARY_CLAUSES
-	      Ltk * lstk = LIT2IMPLS (lit);
-	      Lit ** r, ** s;
-	      r = lstk->start;
-	      if (lit->val != TRUE || LIT2VAR (lit)->level)
-		for (s = r; s < lstk->start + lstk->count; s++)
-		  {
-		    Lit * other = *s;
-		    Var *v = LIT2VAR (other);
-		    if (v->level ||
-		        other->val != TRUE)
-		      *r++ = other;
-		  }
-	      lstk->count = r - lstk->start;
-	      continue;
-#else
-	      p = LIT2IMPLS (lit);
-#endif
-	    }
-	  else
-	    p = LIT2HTPS (lit);
-
-	  for (c = *p; c; c = next)
-	    {
-	      q = c->next;
-	      if (c->lits[0] != lit)
-		q++;
-
-	      next = *q;
-	      if (c->collect)
-		*p = next;
-	      else
-		p = q;
-	    }
-	}
-    }
-
-#ifndef NDSC
-  for (lit = ps->lits + 2; lit <= eol; lit++)
-    {
-      p = LIT2DHTPS (lit); 
-      while ((c = *p))
-	{
-	  Lit * other = c->lits[0];
-	  if (other == lit)
-	    {
-	      q = c->next + 1;
-	    }
-	  else
-	    {
-	      assert (c->lits[1] == lit);
-	      q = c->next;
-	    }
-
-	  if (c->collect)
-	    *p = *q;
-	  else
-	    p = q;
-	}
-    }
-#endif
-
-  for (p = SOC; p != EOC; p = NXC (p))
-    {
-      c = *p;
-
-      if (!c)
-	continue;
-
-      if (!c->collect)
-	continue;
-
-      if (collect_clause (ps, c))
-	*p = 0;
-    }
-
-#ifdef TRACE
-  if (!ps->trace)
-#endif
-    {
-      q = ps->oclauses;
-      for (p = q; p < ps->ohead; p++)
-	if ((c = *p))
-	  *q++ = c;
-      ps->ohead = q;
-
-      q = ps->lclauses;
-      for (p = q; p < ps->lhead; p++)
-	if ((c = *p))
-	  *q++ = c;
-      ps->lhead = q;
-    }
-
-  assert (ps->current_bytes <= res);
-  res -= ps->current_bytes;
-  ps->recycled += res;
-
-  LOG ( fprintf (ps->out, "%scollected %ld bytes\n", ps->prefix, (long)res));
-
-  return res;
-}
-
-static int
-need_to_reduce (PS * ps)
-{
-  return ps->nlclauses >= reduce_limit_on_lclauses (ps);
-}
-
-#ifdef NLUBY
-
-static void
-inc_drestart (PS * ps)
-{
-  ps->drestart *= FRESTART;
-  ps->drestart /= 100;
-
-  if (ps->drestart >= MAXRESTART)
-    ps->drestart = MAXRESTART;
-}
-
-static void
-inc_ddrestart (PS * ps)
-{
-  ps->ddrestart *= FRESTART;
-  ps->ddrestart /= 100;
-
-  if (ps->ddrestart >= MAXRESTART)
-    ps->ddrestart = MAXRESTART;
-}
-
-#else
-
-static unsigned
-luby (unsigned i)
-{
-  unsigned k;
-  for (k = 1; k < 32; k++)
-    if (i == (1u << k) - 1)
-      return 1u << (k - 1);
-
-  for (k = 1;; k++)
-    if ((1u << (k - 1)) <= i && i < (1u << k) - 1)
-      return luby (i - (1u << (k-1)) + 1);
-}
-
-#endif
-
-#ifndef NLUBY
-static void
-inc_lrestart (PS * ps, int skip)
-{
-  unsigned delta;
-
-  delta = 100 * luby (++ps->lubycnt);
-  ps->lrestart = ps->conflicts + delta;
-
-  if (ps->waslubymaxdelta)
-    report (ps, 1, skip ? 'N' : 'R');
-  else
-    report (ps, 2, skip ? 'n' : 'r');
-
-  if (delta > ps->lubymaxdelta)
-    {
-      ps->lubymaxdelta = delta;
-      ps->waslubymaxdelta = 1;
-    }
-  else
-    ps->waslubymaxdelta = 0;
-}
-#endif
-
-static void
-init_restart (PS * ps)
-{
-#ifdef NLUBY
-  /* TODO: why is it better in incremental usage to have smaller initial
-   * outer restart interval?
-   */
-  ps->ddrestart = ps->calls > 1 ? MINRESTART : 1000;
-  ps->drestart = MINRESTART;
-  ps->lrestart = ps->conflicts + ps->drestart;
-#else
-  ps->lubycnt = 0;
-  ps->lubymaxdelta = 0;
-  ps->waslubymaxdelta = 0;
-  inc_lrestart (ps, 0);
-#endif
-}
-
-static void
-restart (PS * ps)
-{
-  int skip; 
-#ifdef NLUBY
-  char kind;
-  int outer;
- 
-  inc_drestart (ps);
-  outer = (ps->drestart >= ps->ddrestart);
-
-  if (outer)
-    skip = very_high_agility (ps);
-  else
-    skip = high_agility (ps);
-#else
-  skip = medium_agility (ps);
-#endif
-
-#ifdef STATS
-  if (skip)
-    ps->skippedrestarts++;
-#endif
-
-  assert (ps->conflicts >= ps->lrestart);
-
-  if (!skip)
-    {
-      ps->restarts++;
-      assert (ps->LEVEL > 1);
-      LOG ( fprintf (ps->out, "%srestart %u\n", ps->prefix, ps->restarts));
-      undo (ps, 0);
-    }
-
-#ifdef NLUBY
-  if (outer)
-    {
-      kind = skip ? 'N' : 'R';
-      inc_ddrestart (ps);
-      ps->drestart = MINRESTART;
-    }
-  else  if (skip)
-    {
-      kind = 'n';
-    }
-  else
-    {
-      kind = 'r';
-    }
-
-  assert (ps->drestart <= MAXRESTART);
-  ps->lrestart = ps->conflicts + ps->drestart;
-  assert (ps->lrestart > ps->conflicts);
-
-  report (outer ? 1 : 2, kind);
-#else
-  inc_lrestart (ps, skip);
-#endif
-}
-
-inline static void
-assign_decision (PS * ps, Lit * lit)
-{
-  assert (!ps->conflict);
-
-  ps->LEVEL++;
-
-  LOG ( fprintf (ps->out, "%snew level %u\n", ps->prefix, ps->LEVEL));
-  LOG ( fprintf (ps->out,
-		 "%sassign %d at level %d <= DECISION\n",
-		 ps->prefix, LIT2INT (lit), ps->LEVEL));
-
-  assign (ps, lit, 0);
-}
-
-#ifndef NFL
-
-static int
-lit_has_binary_clauses (PS * ps, Lit * lit)
-{
-#ifdef NO_BINARY_CLAUSES
-  Ltk* lstk = LIT2IMPLS (lit);
-  return lstk->count != 0;
-#else
-  return *LIT2IMPLS (lit) != 0;
-#endif
-}
-
-static void
-flbcp (PS * ps)
-{
-#ifdef STATS
-  unsigned long long propagaions_before_bcp = ps->propagations;
-#endif
-  bcp (ps);
-#ifdef STATS
-  ps->flprops += ps->propagations - propagaions_before_bcp;
-#endif
-}
-
-inline static int
-cmp_inverse_rnk (PS * ps, Rnk * a, Rnk * b)
-{
-  (void) ps;
-  return -cmp_rnk (a, b);
-}
-
-inline static Flt
-rnk2jwh (PS * ps, Rnk * r)
-{
-  Flt res, sum, pjwh, njwh;
-  Lit * plit, * nlit;
-
-  plit = RNK2LIT (r);
-  nlit = plit + 1;
-  
-  pjwh = *LIT2JWH (plit);
-  njwh = *LIT2JWH (nlit);
-
-  res = mulflt (pjwh, njwh);
-
-  sum = addflt (pjwh, njwh);
-  sum = mulflt (sum, base2flt (1, -10));
-  res = addflt (res, sum);
-
-  return res;
-}
-
-static int
-cmp_inverse_jwh_rnk (PS * ps, Rnk * r, Rnk * s)
-{
-  Flt a = rnk2jwh (ps, r);
-  Flt b = rnk2jwh (ps, s);
-  int res = cmpflt (a, b);
-
-  if (res)
-    return -res;
-
-  return cmp_inverse_rnk (ps, r, s);
-}
-
-static void
-faillits (PS * ps)
-{
-  unsigned i, j, old_trail_count, common, saved_count;
-  unsigned new_saved_size, oldladded = ps->ladded;
-  unsigned long long limit, delta;
-  Lit * lit, * other, * pivot;
-  Rnk * r, ** p, ** q;
-  int new_trail_count;
-  double started;
-
-  if (ps->plain)
-    return;
-
-  if (ps->heap + 1 >= ps->hhead)
-    return;
-
-  if (ps->propagations < ps->fllimit)
-    return;
-
-  sflush (ps);
-  started = ps->seconds;
-
-  ps->flcalls++;
-#ifdef STATSA
-  ps->flrounds++;
-#endif
-  delta = ps->propagations/10;
-  if (delta >= 100*1000*1000) delta = 100*1000*1000;
-  else if (delta <= 100*1000) delta = 100*1000;
-
-  limit = ps->propagations + delta;
-  ps->fllimit = ps->propagations;
-
-  assert (!ps->LEVEL);
-  assert (ps->simplifying);
-
-  if (ps->flcalls <= 1)
-    SORT (Rnk *, cmp_inverse_jwh_rnk, ps->heap + 1, ps->hhead - (ps->heap + 1));
-  else
-    SORT (Rnk *, cmp_inverse_rnk, ps->heap + 1, ps->hhead - (ps->heap + 1));
-
-  i = 1;		/* NOTE: heap starts at position '1' */
-
-  while (ps->propagations < limit)
-    {
-      if (ps->heap + i == ps->hhead)
-	{
-	  if (ps->ladded == oldladded)
-	    break;
-
-	  i = 1;
-#ifdef STATS
-	  ps->flrounds++;
-#endif
-	  oldladded = ps->ladded;
-	}
-
-      assert (ps->heap + i < ps->hhead);
-
-      r = ps->heap[i++];
-      lit = RNK2LIT (r);
-
-      if (lit->val)
-	continue;
-
-      if (!lit_has_binary_clauses (ps, NOTLIT (lit)))
-	{
-#ifdef STATS
-	  ps->flskipped++;
-#endif
-	  continue;
-	}
-
-#ifdef STATS
-      ps->fltried++;
-#endif
-      LOG ( fprintf (ps->out, "%strying %d as failed literal\n",
-	    ps->prefix, LIT2INT (lit)));
-
-      assign_decision (ps, lit);
-      old_trail_count = ps->thead - ps->trail;
-      flbcp (ps);
-
-      if (ps->conflict)
-	{
-EXPLICITLY_FAILED_LITERAL:
-	  LOG ( fprintf (ps->out, "%sfound explicitly failed literal %d\n",
-		ps->prefix, LIT2INT (lit)));
-
-	  ps->failedlits++;
-	  ps->efailedlits++;
-
-	  backtrack (ps);
-	  flbcp (ps);
-
-	  if (!ps->conflict)
-	    continue;
-
-CONTRADICTION:
-	  assert (!ps->LEVEL);
-	  backtrack (ps);
-	  assert (ps->mtcls);
-
-	  goto RETURN;
-	}
-
-      if (ps->propagations >= limit)
-	{
-	  undo (ps, 0);
-	  break;
-	}
-
-      lit = NOTLIT (lit);
-
-      if (!lit_has_binary_clauses (ps, NOTLIT (lit)))
-	{
-#ifdef STATS
-	  ps->flskipped++;
-#endif
-	  undo (ps, 0);
-	  continue;
-	}
-
-#ifdef STATS
-      ps->fltried++;
-#endif
-      LOG ( fprintf (ps->out, "%strying %d as failed literals\n",
-	    ps->prefix, LIT2INT (lit)));
-
-      new_trail_count = ps->thead - ps->trail;
-      saved_count = new_trail_count - old_trail_count;
-
-      if (saved_count > ps->saved_size)
-	{
-	  new_saved_size = ps->saved_size ? 2 * ps->saved_size : 1;
-	  while (saved_count > new_saved_size)
-	    new_saved_size *= 2;
-
-	  RESIZEN (ps->saved, ps->saved_size, new_saved_size);
-	  ps->saved_size = new_saved_size;
-	}
-
-      for (j = 0; j < saved_count; j++)
-	ps->saved[j] = ps->trail[old_trail_count + j];
-
-      undo (ps, 0);
-
-      assign_decision (ps, lit);
-      flbcp (ps);
-
-      if (ps->conflict)
-	goto EXPLICITLY_FAILED_LITERAL;
-
-      pivot = (ps->thead - ps->trail <= new_trail_count) ? lit : NOTLIT (lit);
-
-      common = 0;
-      for (j = 0; j < saved_count; j++)
-	if ((other = ps->saved[j])->val == TRUE)
-	  ps->saved[common++] = other;
-
-      undo (ps, 0);
-
-      LOG (if (common)
-	     fprintf (ps->out, 
-		      "%sfound %d literals implied by %d and %d\n",
-		      ps->prefix, common, 
-		      LIT2INT (NOTLIT (lit)), LIT2INT (lit)));
-
-#if 1 // set to zero to disable 'lifting'
-      for (j = 0; 
-	   j < common 
-	  /* TODO: For some Velev benchmarks, extracting the common implicit
-	   * failed literals took quite some time.  This needs to be fixed by
-	   * a dedicated analyzer.  Up to then we bound the number of
-	   * propagations in this loop as well.
-	   */
-	   && ps->propagations < limit + delta
-	   ; j++)
-	{
-	  other = ps->saved[j];
-
-	  if (other->val == TRUE)
-	    continue;
-
-	  assert (!other->val);
-
-	  LOG ( fprintf (ps->out, 
-			"%sforcing %d as forced implicitly failed literal\n",
-			ps->prefix, LIT2INT (other)));
-
-	  assert (pivot != NOTLIT (other));
-	  assert (pivot != other);
-
-	  assign_decision (ps, NOTLIT (other));
-	  flbcp (ps);
-
-	  assert (ps->LEVEL == 1);
-
-	  if (ps->conflict)
-	    {
-	      backtrack (ps);
-	      assert (!ps->LEVEL);
-	    }
-	  else
-	    {
-	      assign_decision (ps, pivot);
-	      flbcp (ps);
-
-	      backtrack (ps);
-
-	      if (ps->LEVEL)
-		{
-		  assert (ps->LEVEL == 1);
-
-		  flbcp (ps);
-
-		  if (ps->conflict)
-		    {
-		      backtrack (ps);
-		      assert (!ps->LEVEL);
-		    }
-		  else
-		    {
-		      assign_decision (ps, NOTLIT (pivot));
-		      flbcp (ps);
-		      backtrack (ps);
-
-		      if (ps->LEVEL)
-			{
-			  assert (ps->LEVEL == 1);
-			  flbcp (ps);
-
-			  if (!ps->conflict)
-			    {
-#ifdef STATS
-			      ps->floopsed++;
-#endif
-			      undo (ps, 0);
-			      continue;
-			    }
-
-			  backtrack (ps);
-			}
-
-		      assert (!ps->LEVEL);
-		    }
-
-		  assert (!ps->LEVEL);
-		}
-	    }
-	  assert (!ps->LEVEL);
-	  flbcp (ps);
-
-	  ps->failedlits++;
-	  ps->ifailedlits++;
-
-	  if (ps->conflict)
-	    goto CONTRADICTION;
-	}
-#endif
-    }
-
-  ps->fllimit += 9 * (ps->propagations - ps->fllimit);	/* 10% for failed literals */
-
-RETURN:
-
-  /* First flush top level assigned literals.  Those are prohibited from
-   * being pushed up the heap during 'faillits' since 'simplifying' is set.
-   */
-  assert (ps->heap < ps->hhead);
-  for (p = q = ps->heap + 1; p < ps->hhead; p++)
-    {
-      r = *p;
-      lit = RNK2LIT (r);
-      if (lit->val)
-       	r->pos = 0;
-      else
-	*q++ = r;
-    }
-
-  /* Then resort with respect to EVSIDS score and fix positions.
-   */
-  SORT (Rnk *, cmp_inverse_rnk, ps->heap + 1, ps->hhead - (ps->heap + 1));
-  for (p = ps->heap + 1; p < ps->hhead; p++)
-    (*p)->pos = p - ps->heap;
-
-  sflush (ps);
-  ps->flseconds += ps->seconds - started;
-}
-
-#endif
-
-static void
-simplify (PS * ps, int forced)
-{
-  Lit * lit, * notlit, ** t;
-  unsigned collect, delta;
-#ifdef STATS
-  size_t bytes_collected;
-#endif
-  int * q, ilit;
-  Cls **p, *c;
-  Var * v;
-
-#ifndef NDEDBUG
-  (void) forced;
-#endif
-
-  assert (!ps->mtcls);
-  assert (!satisfied (ps));
-  assert (forced || ps->lsimplify <= ps->propagations);
-  assert (forced || ps->fsimplify <= ps->fixed);
-
-  if (ps->LEVEL)
-    undo (ps, 0);
-#ifndef NFL
-  ps->simplifying = 1;
-  faillits (ps);
-  ps->simplifying = 0;
-
-  if (ps->mtcls)
-    return;
-#endif
-
-  if (ps->cils != ps->cilshead)
-    {
-      assert (ps->ttail == ps->thead);
-      assert (ps->ttail2 == ps->thead);
-      ps->ttail = ps->trail;
-      for (t = ps->trail; t < ps->thead; t++)
-	{
-	  lit = *t;
-	  v = LIT2VAR (lit);
-	  if (v->internal)
-	    {
-	      assert (LIT2INT (lit) < 0);
-	      assert (lit->val == TRUE);
-	      unassign (ps, lit);
-	    }
-	  else
-	    *ps->ttail++ = lit;
-	}
-      ps->ttail2 = ps->thead = ps->ttail;
-
-      for (q = ps->cils; q != ps->cilshead; q++)
-	{
-	  ilit = *q;
-	  assert (0 < ilit && ilit <= (int) ps->max_var);
-	  v = ps->vars + ilit;
-	  assert (v->internal);
-	  v->level = 0;
-	  v->reason = 0;
-	  lit = int2lit (ps, -ilit);
-	  assert (lit->val == UNDEF);
-	  lit->val = TRUE;
-	  notlit = NOTLIT (lit);
-	  assert (notlit->val == UNDEF);
-	  notlit->val = FALSE;
-	}
-    }
-
-  collect = 0;
-  for (p = SOC; p != EOC; p = NXC (p))
-    {
-      c = *p;
-      if (!c)
-	continue;
-
-#ifdef TRACE
-      if (c->collected)
-	continue;
-#endif
-
-      if (c->locked)
-	continue;
-      
-      assert (!c->collect);
-      if (clause_is_toplevel_satisfied (ps, c))
-	{
-	  mark_clause_to_be_collected (c);
-	  collect++;
-	}
-    }
-
-  LOG ( fprintf (ps->out, "%scollecting %d clauses\n", ps->prefix, collect));
-#ifdef STATS
-  bytes_collected = 
-#endif
-  collect_clauses (ps);
-#ifdef STATS
-  ps->srecycled += bytes_collected;
-#endif
-
-  if (ps->cils != ps->cilshead)
-    {
-      for (q = ps->cils; q != ps->cilshead; q++)
-	{
-	  ilit = *q;
-	  assert (0 < ilit && ilit <= (int) ps->max_var);
-	  assert (ps->vars[ilit].internal);
-	  if (ps->rilshead == ps->eorils)
-	    ENLARGE (ps->rils, ps->rilshead, ps->eorils);
-	  *ps->rilshead++ = ilit;
-	  lit = int2lit (ps, -ilit);
-	  assert (lit->val == TRUE);
-	  lit->val = UNDEF;
-	  notlit = NOTLIT (lit);
-	  assert (notlit->val == FALSE);
-	  notlit->val = UNDEF;
-	}
-      ps->cilshead = ps->cils;
-    }
-
-  delta = 10 * (ps->olits + ps->llits) + 100000;
-  if (delta > 2000000)
-    delta = 2000000;
-  ps->lsimplify = ps->propagations + delta;
-  ps->fsimplify = ps->fixed;
-  ps->simps++;
-
-  report (ps, 1, 's');
-}
-
-static void
-iteration (PS * ps)
-{
-  assert (!ps->LEVEL);
-  assert (bcp_queue_is_empty (ps));
-  assert (ps->isimplify < ps->fixed);
-
-  ps->iterations++;
-  report (ps, 2, 'i');
-#ifdef NLUBY
-  ps->drestart = MINRESTART;
-  ps->lrestart = ps->conflicts + ps->drestart;
-#else
-  init_restart (ps);
-#endif
-  ps->isimplify = ps->fixed;
-}
-
-static int
-cmp_glue_activity_size (PS * ps, Cls * c, Cls * d)
-{
-  Act a, b, * p, * q;
-
-  (void) ps;
-
-  assert (c->learned);
-  assert (d->learned);
-
-  if (c->glue < d->glue)		// smaller glue preferred
-    return 1;
-
-  if (c->glue > d->glue)
-    return -1;
-
-  p = CLS2ACT (c);
-  q = CLS2ACT (d);
-  a = *p;
-  b = *q;
-
-  if (a < b)				// then higher activity
-    return -1;
-
-  if (b < a)
-    return 1;
-
-  if (c->size < d->size)		// then smaller size
-    return 1;
-
-  if (c->size > d->size)
-    return -1;
-
-  return 0;
-}
-
-static void
-reduce (PS * ps, unsigned percentage)
-{
-  unsigned redcount, lcollect, collect, target;
-#ifdef STATS
-  size_t bytes_collected;
-#endif
-  Cls **p, *c;
-
-  assert (ps->rhead == ps->resolved);
-
-  ps->lastreduceconflicts = ps->conflicts;
-
-  assert (percentage <= 100);
-  LOG ( fprintf (ps->out, 
-                "%sreducing %u%% learned clauses\n",
-		ps->prefix, percentage));
-
-  while (ps->nlclauses - ps->llocked > (unsigned)(ps->eor - ps->resolved))
-    ENLARGE (ps->resolved, ps->rhead, ps->eor);
-
-  collect = 0;
-  lcollect = 0;
-
-  for (p = ((ps->fsimplify < ps->fixed) ? SOC : ps->lclauses); p != EOC; p = NXC (p))
-    {
-      c = *p;
-      if (!c)
-	continue;
-
-#ifdef TRACE
-      if (c->collected)
-	continue;
-#endif
-
-      if (c->locked)
-	continue;
-
-      assert (!c->collect);
-      if (ps->fsimplify < ps->fixed && clause_is_toplevel_satisfied (ps, c))
-	{
-	  mark_clause_to_be_collected (c);
-	  collect++;
-
-	  if (c->learned && c->size > 2)
-	    lcollect++;
-
-	  continue;
-	}
-
-      if (!c->learned)
-	continue;
-
-      if (c->size <= 2)
-	continue;
-
-      assert (ps->rhead < ps->eor);
-      *ps->rhead++ = c;
-    }
-  assert (ps->rhead <= ps->eor);
-
-  ps->fsimplify = ps->fixed;
-
-  redcount = ps->rhead - ps->resolved;
-  SORT (Cls *, cmp_glue_activity_size, ps->resolved, redcount);
-
-  assert (ps->nlclauses >= lcollect);
-  target = ps->nlclauses - lcollect + 1;
-
-  target = (percentage * target + 99) / 100;
-
-  if (target >= redcount)
-    target = redcount;
-
-  ps->rhead = ps->resolved + target;
-  while (ps->rhead > ps->resolved)
-    {
-      c = *--ps->rhead;
-      mark_clause_to_be_collected (c);
-
-      collect++;
-      if (c->learned && c->size > 2)	/* just for consistency */
-	lcollect++;
-    }
-
-  if (collect)
-    {
-      ps->reductions++;
-#ifdef STATS
-      bytes_collected = 
-#endif
-      collect_clauses (ps);
-#ifdef STATS
-      ps->rrecycled += bytes_collected;
-#endif
-      report (ps, 2, '-');
-    }
-
-  if (!lcollect)
-    inc_lreduce (ps);		/* avoid dead lock */
-
-  assert (ps->rhead == ps->resolved);
-}
-
-static void
-init_reduce (PS * ps)
-{
-  // lreduce = loadded / 2;
-  ps->lreduce = 1000;
-
-  if (ps->lreduce < 100)
-    ps->lreduce = 100;
-
-  if (ps->verbosity)
-     fprintf (ps->out, 
-             "%s\n%sinitial reduction limit %u clauses\n%s\n",
-	     ps->prefix, ps->prefix, ps->lreduce, ps->prefix);
-}
-
-static unsigned
-rng (PS * ps)
-{
-  unsigned res = ps->srng;
-  ps->srng *= 1664525u;
-  ps->srng += 1013904223u;
-  NOLOG ( fprintf (ps->out, "%srng () = %u\n", ps->prefix, res));
-  return res;
-}
-
-static unsigned
-rrng (PS * ps, unsigned low, unsigned high)
-{
-  unsigned long long tmp;
-  unsigned res, elements;
-  assert (low <= high);
-  elements = high - low + 1;
-  tmp = rng (ps);
-  tmp *= elements;
-  tmp >>= 32;
-  tmp += low;
-  res = tmp;
-  NOLOG ( fprintf (ps->out, "%srrng (ps, %u, %u) = %u\n", ps->prefix, low, high, res));
-  assert (low <= res);
-  assert (res <= high);
-  return res;
-}
-
-static Lit *
-decide_phase (PS * ps, Lit * lit)
-{
-  Lit * not_lit = NOTLIT (lit);
-  Var *v = LIT2VAR (lit);
-
-  assert (LIT2SGN (lit) > 0);
-  if (v->usedefphase)
-    {
-      if (v->defphase)
-	{
-	  /* assign to TRUE */
-	}
-      else
-	{
-	  /* assign to FALSE */
-	  lit = not_lit;
-	}
-    }
-  else if (!v->assigned)
-    {
-#ifdef STATS
-      ps->staticphasedecisions++;
-#endif
-      if (ps->defaultphase == POSPHASE)
-	{
-	  /* assign to TRUE */
-	}
-      else if (ps->defaultphase == NEGPHASE)
-	{
-	  /* assign to FALSE */
-	  lit = not_lit;
-	}
-      else if (ps->defaultphase == RNDPHASE)
-	{
-	  /* randomly assign default phase */
-	  if (rrng (ps, 1, 2) != 2)
-	    lit = not_lit;
-	}
-      else if (*LIT2JWH(lit) <= *LIT2JWH (not_lit))
-	{
-	  /* assign to FALSE (Jeroslow-Wang says there are more short
-	   * clauses with negative occurence of this variable, so satisfy
-	   * those, to minimize BCP) 
-	   */
-	  lit = not_lit;
-	}
-      else
-	{
-	  /* assign to TRUE (... but strictly more positive occurrences) */
-	}
-    }
-  else 
-    {
-      /* repeat last phase: phase saving heuristic */
-
-      if (v->phase)
-	{
-	  /* assign to TRUE (last phase was TRUE as well) */
-	}
-      else
-	{
-	  /* assign to FALSE (last phase was FALSE as well) */
-	  lit = not_lit;
-	}
-    }
-
-  return lit;
-}
-
-static unsigned
-gcd (unsigned a, unsigned b)
-{
-  unsigned tmp;
-
-  assert (a);
-  assert (b);
-
-  if (a < b)
-    {
-      tmp = a;
-      a = b;
-      b = tmp;
-    }
-
-  while (b)
-    {
-      assert (a >= b);
-      tmp = b;
-      b = a % b;
-      a = tmp;
-    }
-
-  return a;
-}
-
-static Lit *
-rdecide (PS * ps)
-{
-  unsigned idx, delta, spread;
-  Lit * res;
-
-  spread = RDECIDE;
-  if (rrng (ps, 1, spread) != 2)
-    return 0;
-
-  assert (1 <= ps->max_var);
-  idx = rrng (ps, 1, ps->max_var);
-  res = int2lit (ps, idx);
-
-  if (res->val != UNDEF)
-    {
-      delta = rrng (ps, 1, ps->max_var);
-      while (gcd (delta, ps->max_var) != 1)
-	delta--;
-
-      assert (1 <= delta);
-      assert (delta <= ps->max_var);
-
-      do {
-	idx += delta;
-	if (idx > ps->max_var)
-	  idx -= ps->max_var;
-	res = int2lit (ps, idx);
-      } while (res->val != UNDEF);
-    }
-
-#ifdef STATS
-  ps->rdecisions++;
-#endif
-  res = decide_phase (ps, res);
-  LOG ( fprintf (ps->out, "%srdecide %d\n", ps->prefix, LIT2INT (res)));
-
-  return res;
-}
-
-static Lit *
-sdecide (PS * ps)
-{
-  Lit *res;
-  Rnk *r;
-
-  for (;;)
-    {
-      r = htop (ps);
-      res = RNK2LIT (r);
-      if (res->val == UNDEF) break;
-      (void) hpop (ps);
-      NOLOG ( fprintf (ps->out, 
-                      "%shpop %u %u %u\n",
-		      ps->prefix, r - ps->rnks,
-		      FLTMANTISSA(r->score),
-		      FLTEXPONENT(r->score)));
-    }
-
-#ifdef STATS
-  ps->sdecisions++;
-#endif
-  res = decide_phase (ps, res);
-
-  LOG ( fprintf (ps->out, "%ssdecide %d\n", ps->prefix, LIT2INT (res)));
-
-  return res;
-}
-
-static Lit *
-adecide (PS * ps)
-{
-  Lit *lit;
-  Var * v;
-
-  assert (ps->als < ps->alshead);
-  assert (!ps->failed_assumption);
-
-  while (ps->alstail < ps->alshead)
-    {
-      lit = *ps->alstail++;
-
-      if (lit->val == FALSE)
-	{
-	  ps->failed_assumption = lit;
-	  v = LIT2VAR (lit);
-
-	  use_var (ps, v);
-
-	  LOG ( fprintf (ps->out, "%sfirst failed assumption %d\n",
-			ps->prefix, LIT2INT (ps->failed_assumption)));
-	  fanalyze (ps);
-	  return 0;
-	}
-
-      if (lit->val == TRUE)
-	{
-	  v = LIT2VAR (lit);
-	  if (v->level > ps->adecidelevel)
-	    ps->adecidelevel = v->level;
-	  continue;
-	}
-
-#ifdef STATS
-      ps->assumptions++;
-#endif
-      LOG ( fprintf (ps->out, "%sadecide %d\n", ps->prefix, LIT2INT (lit)));
-      ps->adecidelevel = ps->LEVEL + 1;
-
-      return lit;
-    }
-
-  return 0;
-}
-
-static void
-decide (PS * ps)
-{
-  Lit * lit;
-
-  assert (!satisfied (ps));
-  assert (!ps->conflict);
-
-  if (ps->alstail < ps->alshead && (lit = adecide (ps)))
-    ;
-  else if (ps->failed_assumption)
-    return;
-  else if (satisfied (ps))
-    return;
-  else if (!(lit = rdecide (ps)))
-    lit = sdecide (ps);
-
-  assert (lit);
-  assign_decision (ps, lit);
-
-  ps->levelsum += ps->LEVEL;
-  ps->decisions++;
-}
-
-static int
-sat (PS * ps, int l)
-{
-  int count = 0, backtracked;
-
-  if (!ps->conflict)
-    bcp (ps);
-
-  if (ps->conflict)
-    backtrack (ps);
-
-  if (ps->mtcls)
-    return PICOSAT_UNSATISFIABLE;
-
-  if (satisfied (ps))
-    goto SATISFIED;
-
-  if (ps->lsimplify <= ps->propagations)
-    simplify (ps, 0);
-
-  if (ps->mtcls)
-    return PICOSAT_UNSATISFIABLE;
-
-  if (satisfied (ps))
-    goto SATISFIED;
-
-  init_restart (ps);
-
-  if (!ps->lreduce)
-    init_reduce (ps);
-
-  ps->isimplify = ps->fixed;
-  backtracked = 0;
-
-  for (;;)
-    {
-      if (!ps->conflict)
-	bcp (ps);
-
-      if (ps->conflict)
-	{
-	  incincs (ps);
-	  backtrack (ps);
-
-	  if (ps->mtcls)
-	    return PICOSAT_UNSATISFIABLE;
-	  backtracked = 1;
-	  continue;
-	}
-
-      if (satisfied (ps))
-	{
-SATISFIED:
-#ifndef NDEBUG
-	  original_clauses_satisfied (ps);
-	  assumptions_satisfied (ps);
-#endif
-	  return PICOSAT_SATISFIABLE;
-	}
-
-      if (backtracked)
-	{
-	  backtracked = 0;
-	  if (!ps->LEVEL && ps->isimplify < ps->fixed)
-	    iteration (ps);
-	}
-
-      if (l >= 0 && count >= l)		/* decision limit reached ? */
-	return PICOSAT_UNKNOWN;
-
-      if (ps->interrupt.function &&		/* external interrupt */
-	  count > 0 && !(count % INTERRUPTLIM) &&
-	  ps->interrupt.function (ps->interrupt.state))
-	return PICOSAT_UNKNOWN;
-
-      if (ps->propagations >= ps->lpropagations)/* propagation limit reached ? */
-	return PICOSAT_UNKNOWN;
-
-#ifndef NADC
-      if (!ps->adodisabled && ps->adoconflicts >= ps->adoconflictlimit)
-	{
-	  assert (bcp_queue_is_empty (ps));
-	  return PICOSAT_UNKNOWN;
-	}
-#endif
-
-      if (ps->fsimplify < ps->fixed && ps->lsimplify <= ps->propagations)
-	{
-	  simplify (ps, 0);
-	  if (!bcp_queue_is_empty (ps))
-	    continue;
-#ifndef NFL
-	  if (ps->mtcls)
-	    return PICOSAT_UNSATISFIABLE;
-
-	  if (satisfied (ps))
-	    return PICOSAT_SATISFIABLE;
-
-	  assert (!ps->LEVEL);
-#endif
-	}
-
-      if (need_to_reduce (ps))
-	reduce (ps, 50);
-
-      if (ps->conflicts >= ps->lrestart && ps->LEVEL > 2)
-	restart (ps);
-
-      decide (ps);
-      if (ps->failed_assumption)
-	return PICOSAT_UNSATISFIABLE;
-      count++;
-    }
-}
-
-static void
-rebias (PS * ps)
-{
-  Cls ** p, * c;
-  Var * v;
-
-  for (v = ps->vars + 1; v <= ps->vars + ps->max_var; v++)
-    v->assigned = 0;
-
-  memset (ps->jwh, 0, 2 * (ps->max_var + 1) * sizeof *ps->jwh);
-
-  for (p = ps->oclauses; p < ps->ohead; p++) 
-    {
-      c = *p;
-
-      if (!c) 
-	continue;
-
-      if (c->learned)
-	continue;
-
-      incjwh (ps, c);
-    }
-}
-
-#ifdef TRACE
-
-static unsigned
-core (PS * ps)
-{
-  unsigned idx, prev, this, delta, i, lcore, vcore;
-  unsigned *stack, *shead, *eos;
-  Lit **q, **eol, *lit;
-  Cls *c, *reason;
-  Znt *p, byte;
-  Zhn *zhain;
-  Var *v;
-
-  assert (ps->trace);
-
-  assert (ps->mtcls || ps->failed_assumption);
-  if (ps->ocore >= 0)
-    return ps->ocore;
-
-  lcore = ps->ocore = vcore = 0;
-
-  stack = shead = eos = 0;
-  ENLARGE (stack, shead, eos);
-
-  if (ps->mtcls)
-    {
-      idx = CLS2IDX (ps->mtcls);
-      *shead++ = idx;
-    }
-  else
-    {
-      assert (ps->failed_assumption);
-      v = LIT2VAR (ps->failed_assumption);
-      reason = v->reason;
-      assert (reason);
-      idx = CLS2IDX (reason);
-      *shead++ = idx;
-    }
-
-  while (shead > stack)
-    {
-      idx = *--shead;
-      zhain = IDX2ZHN (idx);
-
-      if (zhain)
-	{
-	  if (zhain->core)
-	    continue;
-
-	  zhain->core = 1;
-	  lcore++;
-
-	  c = IDX2CLS (idx);
-	  if (c)
-	    {
-	      assert (!c->core);
-	      c->core = 1;
-	    }
-
-	  i = 0;
-	  delta = 0;
-	  prev = 0;
-	  for (p = zhain->znt; (byte = *p); p++, i += 7)
-	    {
-	      delta |= (byte & 0x7f) << i;
-	      if (byte & 0x80)
-		continue;
-
-	      this = prev + delta;
-	      assert (prev < this);	/* no overflow */
-
-	      if (shead == eos)
-		ENLARGE (stack, shead, eos);
-	      *shead++ = this;
-
-	      prev = this;
-	      delta = 0;
-	      i = -7;
-	    }
-	}
-      else
-	{
-	  c = IDX2CLS (idx);
-
-	  assert (c);
-	  assert (!c->learned);
-
-	  if (c->core)
-	    continue;
-
-	  c->core = 1;
-	  ps->ocore++;
-
-	  eol = end_of_lits (c);
-	  for (q = c->lits; q < eol; q++)
-	    {
-	      lit = *q;
-	      v = LIT2VAR (lit);
-	      if (v->core)
-		continue;
-
-	      v->core = 1;
-	      vcore++;
-
-	      if (!ps->failed_assumption) continue;
-	      if (lit != ps->failed_assumption) continue;
-
-	      reason = v->reason;
-	      if (!reason) continue;
-	      if (reason->core) continue;
-
-	      idx = CLS2IDX (reason);
-	      if (shead == eos)
-		ENLARGE (stack, shead, eos);
-	      *shead++ = idx;
-	    }
-	}
-    }
-
-  DELETEN (stack, eos - stack);
-
-  if (ps->verbosity)
-     fprintf (ps->out,
-	     "%s%u core variables out of %u (%.1f%%)\n"
-	     "%s%u core original clauses out of %u (%.1f%%)\n"
-	     "%s%u core learned clauses out of %u (%.1f%%)\n",
-	     ps->prefix, vcore, ps->max_var, PERCENT (vcore, ps->max_var),
-	     ps->prefix, ps->ocore, ps->oadded, PERCENT (ps->ocore, ps->oadded),
-	     ps->prefix, lcore, ps->ladded, PERCENT (lcore, ps->ladded));
-
-  return ps->ocore;
-}
-
-static void
-trace_lits (PS * ps, Cls * c, FILE * file)
-{
-  Lit **p, **eol = end_of_lits (c);
-
-  assert (c);
-  assert (c->core);
-
-  for (p = c->lits; p < eol; p++)
-    fprintf (file, "%d ", LIT2INT (*p));
-
-  fputc ('0', file);
-}
-
-static void
-write_idx (PS * ps, unsigned idx, FILE * file)
-{
-  fprintf (file, "%ld", EXPORTIDX (idx));
-}
-
-static void
-trace_clause (PS * ps, unsigned idx, Cls * c, FILE * file, int fmt)
-{
-  assert (c);
-  assert (c->core);
-  assert (fmt == RUP_TRACE_FMT || !c->learned);
-  assert (CLS2IDX (c) == idx);
-
-  if (fmt != RUP_TRACE_FMT)
-    {
-      write_idx (ps, idx, file);
-      fputc (' ', file);
-    }
-
-  trace_lits (ps, c, file);
-
-  if (fmt != RUP_TRACE_FMT)
-    fputs (" 0", file);
-
-  fputc ('\n', file);
-}
-
-static void
-trace_zhain (PS * ps, unsigned idx, Zhn * zhain, FILE * file, int fmt)
-{
-  unsigned prev, this, delta, i;
-  Znt *p, byte;
-  Cls * c;
-
-  assert (zhain);
-  assert (zhain->core);
-
-  write_idx (ps, idx, file);
-  fputc (' ', file);
-
-  if (fmt == EXTENDED_TRACECHECK_TRACE_FMT)
-    {
-      c = IDX2CLS (idx);
-      assert (c);
-      trace_lits (ps, c, file);
-    }
-  else
-    {
-      assert (fmt == COMPACT_TRACECHECK_TRACE_FMT);
-      putc ('*', file);
-    }
-
-  i = 0;
-  delta = 0;
-  prev = 0;
-
-  for (p = zhain->znt; (byte = *p); p++, i += 7)
-    {
-      delta |= (byte & 0x7f) << i;
-      if (byte & 0x80)
-	continue;
-
-      this = prev + delta;
-
-      putc (' ', file);
-      write_idx (ps, this, file);
-
-      prev = this;
-      delta = 0;
-      i = -7;
-    }
-
-  fputs (" 0\n", file);
-}
-
-static void
-write_core (PS * ps, FILE * file)
-{
-  Lit **q, **eol;
-  Cls **p, *c;
-
-  fprintf (file, "p cnf %u %u\n", ps->max_var, core (ps));
-
-  for (p = SOC; p != EOC; p = NXC (p))
-    {
-      c = *p;
-
-      if (!c || c->learned || !c->core)
-	continue;
-
-      eol = end_of_lits (c);
-      for (q = c->lits; q < eol; q++)
-	fprintf (file, "%d ", LIT2INT (*q));
-
-      fputs ("0\n", file);
-    }
-}
-
-#endif
-
-static void
-write_trace (PS * ps, FILE * file, int fmt)
-{
-#ifdef TRACE
-  Cls *c, ** p;
-  Zhn *zhain;
-  unsigned i;
-
-  core (ps);
-
-  if (fmt == RUP_TRACE_FMT)
-    {
-      ps->rupvariables = picosat_variables (ps),
-      ps->rupclauses = picosat_added_original_clauses (ps);
-      write_rup_header (ps, file);
-    }
-
-  for (p = SOC; p != EOC; p = NXC (p))
-    {
-      c = *p;
-
-      if (ps->oclauses <= p && p < ps->eoo)
-	{
-	  i = OIDX2IDX (p - ps->oclauses);
-	  assert (!c || CLS2IDX (c) == i);
-	}
-      else
-	{
-          assert (ps->lclauses <= p && p < ps->EOL);
-	  i = LIDX2IDX (p - ps->lclauses);
-	}
-
-      zhain = IDX2ZHN (i);
-
-      if (zhain)
-	{
-	  if (zhain->core)
-	    {
-	      if (fmt == RUP_TRACE_FMT)
-		trace_clause (ps,i, c, file, fmt);
-	      else
-		trace_zhain (ps, i, zhain, file, fmt);
-	    }
-	}
-      else if (c)
-	{
-	  if (fmt != RUP_TRACE_FMT && c)
-	    {
-	      if (c->core)
-		trace_clause (ps, i, c, file, fmt);
-	    }
-	}
-    }
-#else
-  (void) file;
-  (void) fmt;
-  (void) ps;
-#endif
-}
-
-static void
-write_core_wrapper (PS * ps, FILE * file, int fmt)
-{
-  (void) fmt;
-#ifdef TRACE
-  write_core (ps, file);
-#else
-  (void) ps;
-  (void) file;
-#endif
-}
-
-static Lit *
-import_lit (PS * ps, int lit, int nointernal)
-{
-  Lit * res;
-  Var * v;
-
-  ABORTIF (lit == INT_MIN, "API usage: INT_MIN literal");
-  ABORTIF (abs (lit) > (int) ps->max_var && ps->CLS != ps->clshead,
-           "API usage: new variable index after 'picosat_push'");
-
-  if (abs (lit) <= (int) ps->max_var)
-    {
-      res = int2lit (ps, lit);
-      v = LIT2VAR (res);
-      if (nointernal && v->internal)
-	ABORT ("API usage: trying to import invalid literal");
-      else if (!nointernal && !v->internal)
-	ABORT ("API usage: trying to import invalid context");
-    }
-  else
-    {
-      while (abs (lit) > (int) ps->max_var)
-	inc_max_var (ps);
-      res = int2lit (ps, lit);
-    }
-
-  return res;
-}
-
-#ifdef TRACE
-static void
-reset_core (PS * ps)
-{
-  Cls ** p, * c;
-  Zhn ** q, * z;
-  unsigned i;
-
-  for (i = 1; i <= ps->max_var; i++)
-    ps->vars[i].core = 0;
-
-  for (p = SOC; p != EOC; p = NXC (p))
-    if ((c = *p))
-      c->core = 0;
-
-  for (q = ps->zhains; q != ps->zhead; q++)
-    if ((z = *q))
-      z->core = 0;
-
-  ps->ocore = -1;
-}
-#endif
-
-static void
-reset_assumptions (PS * ps)
-{
-  Lit ** p;
-
-  ps->failed_assumption = 0;
-
-  if (ps->extracted_all_failed_assumptions)
-    {
-      for (p = ps->als; p < ps->alshead; p++)
-	LIT2VAR (*p)->failed = 0;
-
-      ps->extracted_all_failed_assumptions = 0;
-    }
-
-  ps->alstail = ps->alshead = ps->als;
-  ps->adecidelevel = 0;
-}
-
-static void
-check_ready (PS * ps)
-{
-  ABORTIF (!ps || ps->state == RESET, "API usage: uninitialized");
-}
-
-static void
-check_sat_state (PS * ps)
-{
-  ABORTIF (ps->state != SAT, "API usage: expected to be in SAT state");
-}
-
-static void
-check_unsat_state (PS * ps)
-{
-  ABORTIF (ps->state != UNSAT, "API usage: expected to be in UNSAT state");
-}
-
-static void
-check_sat_or_unsat_or_unknown_state (PS * ps)
-{
-  ABORTIF (ps->state != SAT && ps->state != UNSAT && ps->state != UNKNOWN,
-           "API usage: expected to be in SAT, UNSAT, or UNKNOWN state");
-}
-
-static void
-reset_partial (PS * ps)
-{
-  unsigned idx;
-  if (!ps->partial)
-    return;
-  for (idx = 1; idx <= ps->max_var; idx++)
-    ps->vars[idx].partial = 0;
-  ps->partial = 0;
-}
-
-static void
-reset_incremental_usage (PS * ps)
-{
-  unsigned num_non_false;
-  Lit * lit, ** q;
-
-  check_sat_or_unsat_or_unknown_state (ps);
-
-  LOG ( fprintf (ps->out, "%sRESET incremental usage\n", ps->prefix));
-
-  if (ps->LEVEL)
-    undo (ps, 0);
-
-  reset_assumptions (ps);
-
-  if (ps->conflict)
-    { 
-      num_non_false = 0;
-      for (q = ps->conflict->lits; q < end_of_lits (ps->conflict); q++)
-	{
-	  lit = *q;
-	  if (lit->val != FALSE)
-	    num_non_false++;
-	}
-
-      // assert (num_non_false >= 2); // TODO: why this assertion?
-#ifdef NO_BINARY_CLAUSES
-      if (ps->conflict == &ps->cimpl)
-	resetcimpl (ps);
-#endif
-#ifndef NADC
-      if (ps->conflict == ps->adoconflict)
-	resetadoconflict (ps);
-#endif
-      ps->conflict = 0;
-    }
-
-#ifdef TRACE
-  reset_core (ps);
-#endif
-
-  reset_partial (ps);
-
-  ps->saved_flips = ps->flips;
-  ps->min_flipped = UINT_MAX;
-  ps->saved_max_var = ps->max_var;
-
-  ps->state = READY;
-}
-
-static void
-enter (PS * ps)
-{
-  if (ps->nentered++)
-    return;
-
-  check_ready (ps);
-  ps->entered = picosat_time_stamp ();
-}
-
-static void
-leave (PS * ps)
-{
-  assert (ps->nentered);
-  if (--ps->nentered)
-    return;
-
-  sflush (ps);
-}
-
-static void
-check_trace_support_and_execute (PS * ps,
-                                 FILE * file, 
-				 void (*f)(PS*,FILE*,int), int fmt)
-{
-  check_ready (ps);
-  check_unsat_state (ps);
-#ifdef TRACE
-  ABORTIF (!ps->trace, "API usage: tracing disabled");
-  enter (ps);
-  f (ps, file, fmt);
-  leave (ps);
-#else
-  (void) file;
-  (void) fmt;
-  (void) f;
-  ABORT ("compiled without trace support");
-#endif
-}
-
-static void
-extract_all_failed_assumptions (PS * ps)
-{
-  Lit ** p, ** eol;
-  Var * v, * u;
-  int pos;
-  Cls * c;
-
-  assert (!ps->extracted_all_failed_assumptions);
-
-  assert (ps->failed_assumption);
-  assert (ps->mhead == ps->marked);
-
-  if (ps->marked == ps->eom)
-    ENLARGE (ps->marked, ps->mhead, ps->eom);
-
-  v = LIT2VAR (ps->failed_assumption);
-  mark_var (ps, v);
-  pos = 0;
-
-  while (pos < ps->mhead - ps->marked)
-    {
-      v = ps->marked[pos++];
-      assert (v->mark);
-      c = var2reason (ps, v);
-      if (!c)
-	continue;
-      eol = end_of_lits (c);
-      for (p = c->lits; p < eol; p++)
-	{
-	  u = LIT2VAR (*p);
-	  if (!u->mark)
-	    mark_var (ps, u);
-	}
-#ifdef NO_BINARY_CLAUSES
-      if (c == &ps->impl)
-	resetimpl (ps);
-#endif
-    }
-
-  for (p = ps->als; p < ps->alshead; p++)
-    {
-      u = LIT2VAR (*p);
-      if (!u->mark) continue;
-      u->failed = 1;
-      LOG ( fprintf (ps->out,
-                     "%sfailed assumption %d\n",
-		     ps->prefix, LIT2INT (*p)));
-    }
-
-  while (ps->mhead > ps->marked)
-    (*--ps->mhead)->mark = 0;
-
-  ps->extracted_all_failed_assumptions = 1;
-}
-
-const char *
-picosat_copyright (void)
-{
-  return "Copyright (c) 2006 - 2014 Armin Biere JKU Linz";
-}
-
-PicoSAT *
-picosat_init (void)
-{
-  return init (0, 0, 0, 0);
-}
-
-PicoSAT * 
-picosat_minit (void * pmgr,
-	       picosat_malloc pnew,
-	       picosat_realloc presize,
-	       picosat_free pfree)
-{
-  ABORTIF (!pnew, "API usage: zero 'picosat_malloc' argument");
-  ABORTIF (!presize, "API usage: zero 'picosat_realloc' argument");
-  ABORTIF (!pfree, "API usage: zero 'picosat_free' argument");
-  return init (pmgr, pnew, presize, pfree);
-}
-
-
-void
-picosat_adjust (PS * ps, int new_max_var)
-{
-  unsigned new_size_vars;
-
-  ABORTIF (abs (new_max_var) > (int) ps->max_var && ps->CLS != ps->clshead,
-           "API usage: adjusting variable index after 'picosat_push'");
-  enter (ps);
-
-  new_max_var = abs (new_max_var);
-  new_size_vars = new_max_var + 1;
-
-  if (ps->size_vars < new_size_vars)
-    enlarge (ps, new_size_vars);
-
-  while (ps->max_var < (unsigned) new_max_var)
-    inc_max_var (ps);
-
-  leave (ps);
-}
-
-int
-picosat_inc_max_var (PS * ps)
-{
-  if (ps->measurealltimeinlib)
-    enter (ps);
-  else
-    check_ready (ps);
-
-  inc_max_var (ps);
-
-  if (ps->measurealltimeinlib)
-    leave (ps);
-
-  return ps->max_var;
-}
-
-int
-picosat_context (PS * ps)
-{
-  return ps->clshead == ps->CLS ? 0 : LIT2INT (ps->clshead[-1]);
-}
-
-int
-picosat_push (PS * ps)
-{
-  int res;
-  Lit *lit;
-  Var * v;
-
-  if (ps->measurealltimeinlib)
-    enter (ps);
-  else
-    check_ready (ps);
-
-  if (ps->state != READY)
-    reset_incremental_usage (ps);
-
-  if (ps->rils != ps->rilshead)
-    {
-      res = *--ps->rilshead;
-      assert (ps->vars[res].internal);
-    }
-  else
-    {
-      inc_max_var (ps);
-      res = ps->max_var;
-      v = ps->vars + res;
-      assert (!v->internal);
-      v->internal = 1;
-      ps->internals++;
-      LOG ( fprintf (ps->out, "%snew internal variable index %d\n", ps->prefix, res));
-    }
-
-  lit = int2lit (ps, res);
-
-  if (ps->clshead == ps->eocls)
-    ENLARGE (ps->CLS, ps->clshead, ps->eocls);
-  *ps->clshead++ = lit;
-
-  ps->contexts++;
-
-  LOG ( fprintf (ps->out, "%snew context %d at depth %ld after push\n",
-                 ps->prefix, res, (long)(ps->clshead - ps->CLS)));
-
-  if (ps->measurealltimeinlib)
-    leave (ps);
-
-  return res;
-}
-
-int 
-picosat_pop (PS * ps)
-{
-  Lit * lit;
-  int res;
-  ABORTIF (ps->CLS == ps->clshead, "API usage: too many 'picosat_pop'");
-  ABORTIF (ps->added != ps->ahead, "API usage: incomplete clause");
-
-  if (ps->measurealltimeinlib)
-    enter (ps);
-  else
-    check_ready (ps);
-
-  if (ps->state != READY)
-    reset_incremental_usage (ps);
-
-  assert (ps->CLS < ps->clshead);
-  lit = *--ps->clshead;
-  LOG ( fprintf (ps->out, "%sclosing context %d at depth %ld after pop\n",
-                 ps->prefix, LIT2INT (lit), (long)(ps->clshead - ps->CLS) + 1));
-
-  if (ps->cilshead == ps->eocils)
-    ENLARGE (ps->cils, ps->cilshead, ps->eocils);
-  *ps->cilshead++ = LIT2INT (lit);
-
-  if (ps->cilshead - ps->cils > MAXCILS) {
-    LOG ( fprintf (ps->out,
-                  "%srecycling %ld interals with forced simplification\n",
-		  ps->prefix, (long)(ps->cilshead - ps->cils)));
-    simplify (ps, 1);
-  }
-
-  res = picosat_context (ps);
-  if (res)
-    LOG ( fprintf (ps->out, "%snew context %d at depth %ld after pop\n",
-		   ps->prefix, res, (long)(ps->clshead - ps->CLS)));
-  else
-    LOG ( fprintf (ps->out, "%souter most context reached after pop\n", ps->prefix));
-
-  if (ps->measurealltimeinlib)
-    leave (ps);
-  
-  return res;
-}
-
-void
-picosat_set_verbosity (PS * ps, int new_verbosity_level)
-{
-  check_ready (ps);
-  ps->verbosity = new_verbosity_level;
-}
-
-void
-picosat_set_plain (PS * ps, int new_plain_value)
-{
-  check_ready (ps);
-  ps->plain = new_plain_value;
-}
-
-int
-picosat_enable_trace_generation (PS * ps)
-{
-  int res = 0;
-  check_ready (ps);
-#ifdef TRACE
-  ABORTIF (ps->addedclauses, 
-           "API usage: trace generation enabled after adding clauses");
-  res = ps->trace = 1;
-#endif
-  return res;
-}
-
-void
-picosat_set_incremental_rup_file (PS * ps, FILE * rup_file, int m, int n)
-{
-  check_ready (ps);
-  assert (!ps->rupstarted);
-  ps->rup = rup_file;
-  ps->rupvariables = m;
-  ps->rupclauses = n;
-}
-
-void
-picosat_set_output (PS * ps, FILE * output_file)
-{
-  check_ready (ps);
-  ps->out = output_file;
-}
-
-void
-picosat_measure_all_calls (PS * ps)
-{
-  check_ready (ps);
-  ps->measurealltimeinlib = 1;
-}
-
-void
-picosat_set_prefix (PS * ps, const char * str)
-{
-  check_ready (ps);
-  new_prefix (ps, str);
-}
-
-void
-picosat_set_seed (PS * ps, unsigned s)
-{
-  check_ready (ps);
-  ps->srng = s;
-}
-
-void
-picosat_reset (PS * ps)
-{
-  check_ready (ps);
-  reset (ps);
-}
-
-int
-picosat_add (PS * ps, int int_lit)
-{
-  int res = ps->oadded;
-  Lit *lit;
-
-  if (ps->measurealltimeinlib)
-    enter (ps);
-  else
-    check_ready (ps);
-
-  ABORTIF (ps->rup && ps->rupstarted && ps->oadded >= (unsigned)ps->rupclauses,
-           "API usage: adding too many clauses after RUP header written");
-#ifndef NADC
-  ABORTIF (ps->addingtoado, 
-           "API usage: 'picosat_add' and 'picosat_add_ado_lit' mixed");
-#endif
-  if (ps->state != READY)
-    reset_incremental_usage (ps);
-
-  if (ps->saveorig)
-    {
-      if (ps->sohead == ps->eoso)
-	ENLARGE (ps->soclauses, ps->sohead, ps->eoso);
-
-      *ps->sohead++ = int_lit;
-    }
-
-  if (int_lit)
-    {
-      lit = import_lit (ps, int_lit, 1);
-      add_lit (ps, lit);
-    }
-  else
-    simplify_and_add_original_clause (ps);
-
-  if (ps->measurealltimeinlib)
-    leave (ps);
-
-  return res;
-}
-
-int
-picosat_add_arg (PS * ps, ...)
-{
-  int lit;
-  va_list ap;
-  va_start (ap, ps);
-  while ((lit = va_arg (ap, int)))
-    (void) picosat_add (ps, lit);
-  va_end (ap);
-  return picosat_add (ps, 0);
-}
-
-int
-picosat_add_lits (PS * ps, int * lits)
-{
-  const int * p;
-  int lit;
-  for (p = lits; (lit = *p); p++)
-    (void) picosat_add (ps, lit);
-  return picosat_add (ps, 0);
-}
-
-void
-picosat_add_ado_lit (PS * ps, int external_lit)
-{
-#ifndef NADC
-  Lit * internal_lit;
-
-  if (ps->measurealltimeinlib)
-    enter (ps);
-  else
-    check_ready (ps);
-
-  if (ps->state != READY)
-    reset_incremental_usage (ps);
-
-  ABORTIF (!ps->addingtoado && ps->ahead > ps->added,
-           "API usage: 'picosat_add' and 'picosat_add_ado_lit' mixed");
-
-  if (external_lit)
-    {
-      ps->addingtoado = 1;
-      internal_lit = import_lit (ps, external_lit, 1);
-      add_lit (ps, internal_lit);
-    }
-  else
-    {
-      ps->addingtoado = 0;
-      add_ado (ps);
-    }
-  if (ps->measurealltimeinlib)
-    leave (ps);
-#else
-  (void) ps;
-  (void) external_lit;
-  ABORT ("compiled without all different constraint support");
-#endif
-}
-
-static void
-assume (PS * ps, Lit * lit)
-{
-  if (ps->alshead == ps->eoals)
-    {
-      assert (ps->alstail == ps->als);
-      ENLARGE (ps->als, ps->alshead, ps->eoals);
-      ps->alstail = ps->als;
-    }
-
-  *ps->alshead++ = lit;
-  LOG ( fprintf (ps->out, "%sassumption %d\n", ps->prefix, LIT2INT (lit)));
-}
-
-static void
-assume_contexts (PS * ps)
-{
-  Lit ** p;
-  if (ps->als != ps->alshead)
-    return;
-  for (p = ps->CLS; p != ps->clshead; p++)
-    assume (ps, *p);
-}
-
-#ifndef RCODE
-static const char * enumstr (int i) {
-  int last = i % 10;
-  if (last == 1) return "st";
-  if (last == 2) return "nd";
-  if (last == 3) return "rd";
-  return "th";
-}
-#endif
-
-static int
-tderef (PS * ps, int int_lit)
-{
-  Lit * lit;
-  Var * v;
-
-  assert (abs (int_lit) <= (int) ps->max_var);
-
-  lit = int2lit (ps, int_lit);
-
-  v = LIT2VAR (lit);
-  if (v->level > 0)
-    return 0;
-
-  if (lit->val == TRUE)
-    return 1;
-
-  if (lit->val == FALSE)
-    return -1;
-
-  return 0;
-}
-
-static int
-pderef (PS * ps, int int_lit)
-{
-  Lit * lit;
-  Var * v;
-
-  assert (abs (int_lit) <= (int) ps->max_var);
-
-  v = ps->vars + abs (int_lit);
-  if (!v->partial)
-    return 0;
-
-  lit = int2lit (ps, int_lit);
-
-  if (lit->val == TRUE)
-    return 1;
-
-  if (lit->val == FALSE)
-    return -1;
-
-  return 0;
-}
-
-static void
-minautarky (PS * ps)
-{
-  unsigned * occs, maxoccs, tmpoccs, npartial;
-  int * p, * c, lit, best, val;
-#ifdef LOGGING
-  int tl;
-#endif
-
-  assert (!ps->partial);
-
-  npartial = 0;
-
-  NEWN (occs, 2*ps->max_var + 1);
-  CLRN (occs, 2*ps->max_var + 1);
-  occs += ps->max_var;
-  for (p = ps->soclauses; p < ps->sohead; p++)
-    occs[*p]++;
-  assert (occs[0] == ps->oadded);
-
-  for (c = ps->soclauses; c < ps->sohead; c = p + 1) 
-    {
-#ifdef LOGGING
-      tl = 0;
-#endif
-      best = 0; 
-      maxoccs = 0;
-      for (p = c; (lit = *p); p++)
-	{
-	  val = tderef (ps, lit);
-	  if (val < 0)
-	    continue;
-	  if (val > 0)
-	    {
-#ifdef LOGGING
-	      tl = 1;
-#endif
-	      best = lit;
-	      maxoccs = occs[lit];
-	    }
-
-	  val = pderef (ps, lit);
-	  if (val > 0)
-	    break;
-	  if (val < 0)
-	    continue;
-	  val = int2lit (ps, lit)->val;
-	  assert (val);
-	  if (val < 0)
-	    continue;
-	  tmpoccs = occs[lit];
-	  if (best && tmpoccs <= maxoccs)
-	    continue;
-	  best = lit;
-	  maxoccs = tmpoccs;
-	}
-      if (!lit)
-	{
-	  assert (best);
-	  LOG ( fprintf (ps->out, "%sautark %d with %d occs%s\n", 
-	       ps->prefix, best, maxoccs, tl ? " (top)" : ""));
-	  ps->vars[abs (best)].partial = 1;
-	  npartial++;
-	}
-      for (p = c; (lit = *p); p++)
-	{
-	  assert (occs[lit] > 0);
-	  occs[lit]--;
-	}
-    }
-  occs -= ps->max_var;
-  DELETEN (occs, 2*ps->max_var + 1);
-  ps->partial = 1;
-
-  if (ps->verbosity)
-     fprintf (ps->out,
-      "%sautarky of size %u out of %u satisfying all clauses (%.1f%%)\n",
-      ps->prefix, npartial, ps->max_var, PERCENT (npartial, ps->max_var));
-}
-
-void
-picosat_assume (PS * ps, int int_lit)
-{
-  Lit *lit;
-
-  if (ps->measurealltimeinlib)
-    enter (ps);
-  else
-    check_ready (ps);
-
-  if (ps->state != READY)
-    reset_incremental_usage (ps);
-
-  assume_contexts (ps);
-  lit = import_lit (ps, int_lit, 1);
-  assume (ps, lit);
-
-  if (ps->measurealltimeinlib)
-    leave (ps);
-}
-
-int
-picosat_sat (PS * ps, int l)
-{
-  int res;
-  char ch;
-
-  enter (ps);
-
-  ps->calls++;
-  LOG ( fprintf (ps->out, "%sSTART call %u\n", ps->prefix, ps->calls));
-
-  if (ps->added < ps->ahead)
-    {
-#ifndef NADC
-      if (ps->addingtoado)
-	ABORT ("API usage: incomplete all different constraint");
-      else
-#endif
-	ABORT ("API usage: incomplete clause");
-    }
-
-  if (ps->state != READY)
-    reset_incremental_usage (ps);
-
-  assume_contexts (ps);
-
-  res = sat (ps, l);
-
-  assert (ps->state == READY);
-
-  switch (res)
-    {
-    case PICOSAT_UNSATISFIABLE:
-      ch = '0';
-      ps->state = UNSAT;
-      break;
-    case PICOSAT_SATISFIABLE:
-      ch = '1';
-      ps->state = SAT;
-      break;
-    default:
-      ch = '?';
-      ps->state = UNKNOWN;
-      break;
-    }
-
-  if (ps->verbosity)
-    {
-      report (ps, 1, ch);
-      rheader (ps);
-    }
-
-  leave (ps);
-  LOG ( fprintf (ps->out, "%sEND call %u result %d\n", ps->prefix, ps->calls, res));
-
-  ps->last_sat_call_result = res;
-
-  return res;
-}
-
-int
-picosat_res (PS * ps)
-{
-  return ps->last_sat_call_result;
-}
-
-int
-picosat_deref (PS * ps, int int_lit)
-{
-  Lit *lit;
-
-  check_ready (ps);
-  check_sat_state (ps);
-  ABORTIF (!int_lit, "API usage: can not deref zero literal");
-  ABORTIF (ps->mtcls, "API usage: deref after empty clause generated");
-
-#ifdef STATS
-  ps->derefs++;
-#endif
-
-  if (abs (int_lit) > (int) ps->max_var)
-    return 0;
-
-  lit = int2lit (ps, int_lit);
-
-  if (lit->val == TRUE)
-    return 1;
-
-  if (lit->val == FALSE)
-    return -1;
-
-  return 0;
-}
-
-int
-picosat_deref_toplevel (PS * ps, int int_lit)
-{
-  check_ready (ps);
-  ABORTIF (!int_lit, "API usage: can not deref zero literal");
-
-#ifdef STATS
-  ps->derefs++;
-#endif
-  if (abs (int_lit) > (int) ps->max_var)
-    return 0;
-
-  return tderef (ps, int_lit);
-}
-
-int
-picosat_inconsistent (PS * ps)
-{
-  check_ready (ps);
-  return ps->mtcls != 0;
-}
-
-int
-picosat_corelit (PS * ps, int int_lit)
-{
-  check_ready (ps);
-  check_unsat_state (ps);
-  ABORTIF (!int_lit, "API usage: zero literal can not be in core");
-
-  assert (ps->mtcls || ps->failed_assumption);
-
-#ifdef TRACE
-  {
-    int res = 0;
-    ABORTIF (!ps->trace, "tracing disabled");
-    if (ps->measurealltimeinlib)
-      enter (ps);
-    core (ps);
-    if (abs (int_lit) <= (int) ps->max_var)
-      res = ps->vars[abs (int_lit)].core;
-    assert (!res || ps->failed_assumption || ps->vars[abs (int_lit)].used);
-    if (ps->measurealltimeinlib)
-      leave (ps);
-    return res;
-  }
-#else
-  ABORT ("compiled without trace support");
-  return 0;
-#endif
-}
-
-int
-picosat_coreclause (PS * ps, int ocls)
-{
-  check_ready (ps);
-  check_unsat_state (ps);
-
-  ABORTIF (ocls < 0, "API usage: negative original clause index");
-  ABORTIF (ocls >= (int)ps->oadded, "API usage: original clause index exceeded");
-
-  assert (ps->mtcls || ps->failed_assumption);
-
-#ifdef TRACE
-  {
-    Cls ** clsptr, * c;
-    int res  = 0;
-
-    ABORTIF (!ps->trace, "tracing disabled");
-    if (ps->measurealltimeinlib)
-      enter (ps);
-    core (ps);
-    clsptr = ps->oclauses + ocls;
-    assert (clsptr < ps->ohead);
-    c = *clsptr;
-    if (c) 
-      res = c->core;
-    if (ps->measurealltimeinlib)
-      leave (ps);
-
-    return res;
-  }
-#else
-  ABORT ("compiled without trace support");
-  return 0;
-#endif
-}
-
-int
-picosat_failed_assumption (PS * ps, int int_lit)
-{
-  Lit * lit;
-  Var * v;
-  ABORTIF (!int_lit, "API usage: zero literal as assumption");
-  check_ready (ps);
-  check_unsat_state (ps);
-  if (ps->mtcls)
-    return 0;
-  assert (ps->failed_assumption);
-  if (abs (int_lit) > (int) ps->max_var)
-    return 0;
-  if (!ps->extracted_all_failed_assumptions)
-    extract_all_failed_assumptions (ps);
-  lit = import_lit (ps, int_lit, 1);
-  v = LIT2VAR (lit);
-  return v->failed;
-}
-
-int
-picosat_failed_context (PS * ps, int int_lit)
-{
-  Lit * lit;
-  Var * v;
-  ABORTIF (!int_lit, "API usage: zero literal as context");
-  ABORTIF (abs (int_lit) > (int) ps->max_var, "API usage: invalid context");
-  check_ready (ps);
-  check_unsat_state (ps);
-  assert (ps->failed_assumption);
-  if (!ps->extracted_all_failed_assumptions)
-    extract_all_failed_assumptions (ps);
-  lit = import_lit (ps, int_lit, 0);
-  v = LIT2VAR (lit);
-  return v->failed;
-}
-
-const int *
-picosat_failed_assumptions (PS * ps)
-{
-  Lit ** p, * lit;
-  Var * v;
-  int ilit;
-
-  ps->falshead = ps->fals;
-  check_ready (ps);
-  check_unsat_state (ps);
-  if (!ps->mtcls) 
-    {
-      assert (ps->failed_assumption);
-      if (!ps->extracted_all_failed_assumptions)
-	extract_all_failed_assumptions (ps);
-
-      for (p = ps->als; p < ps->alshead; p++)
-	{
-	  lit = *p;
-	  v = LIT2VAR (*p);
-	  if (!v->failed)
-	    continue;
-	  ilit = LIT2INT (lit);
-	  if (ps->falshead == ps->eofals)
-	    ENLARGE (ps->fals, ps->falshead, ps->eofals);
-	  *ps->falshead++ = ilit;
-	}
-    }
-  if (ps->falshead == ps->eofals)
-    ENLARGE (ps->fals, ps->falshead, ps->eofals);
-  *ps->falshead++ = 0;
-  return ps->fals;
-}
-
-const int *
-picosat_mus_assumptions (PS * ps, void * s, void (*cb)(void*,const int*), int fix)
-{
-  int i, j, ilit, len, nwork, * work, res;
-  signed char * redundant;
-  Lit ** p, * lit;
-  int failed;
-  Var * v;
-#ifndef NDEBUG
-  int oldlen;
-#endif
-#ifndef RCODE
-  int norig = ps->alshead - ps->als; 
-#endif
-
-  check_ready (ps);
-  check_unsat_state (ps);
-  len = 0;
-  if (!ps->mtcls) 
-    {
-      assert (ps->failed_assumption);
-      if (!ps->extracted_all_failed_assumptions)
-	extract_all_failed_assumptions (ps);
-
-      for (p = ps->als; p < ps->alshead; p++)
-	if (LIT2VAR (*p)->failed)
-	  len++;
-    }
-
-  if (ps->mass)
-    DELETEN (ps->mass, ps->szmass);
-  ps->szmass = len + 1;
-  NEWN (ps->mass, ps->szmass);
-
-  i = 0;
-  for (p = ps->als; p < ps->alshead; p++)
-    {
-      lit = *p;
-      v = LIT2VAR (lit);
-      if (!v->failed)
-	continue;
-      ilit = LIT2INT (lit);
-      assert (i < len);
-      ps->mass[i++] = ilit;
-    }
-  assert (i == len);
-  ps->mass[i] = 0;
-  if (ps->verbosity)
-     fprintf (ps->out, 
-      "%sinitial set of failed assumptions of size %d out of %d (%.0f%%)\n",
-      ps->prefix, len, norig, PERCENT (len, norig));
-  if (cb)
-    cb (s, ps->mass);
-
-  nwork = len;
-  NEWN (work, nwork);
-  for (i = 0; i < len; i++)
-    work[i] = ps->mass[i];
-
-  NEWN (redundant, nwork);
-  CLRN (redundant, nwork);
-
-  for (i = 0; i < nwork; i++)
-    {
-      if (redundant[i])
-	continue;
-
-      if (ps->verbosity > 1)
-	 fprintf (ps->out,
-	         "%strying to drop %d%s assumption %d\n", 
-		 ps->prefix, i, enumstr (i), work[i]);
-      for (j = 0; j < nwork; j++)
-	{
-	  if (i == j) continue;
-	  if (j < i && fix) continue;
-	  if (redundant[j]) continue;
-	  picosat_assume (ps, work[j]);
-	}
-
-      res = picosat_sat (ps, -1);
-      if (res == 10)
-	{
-	  if (ps->verbosity > 1)
-	     fprintf (ps->out,
-		     "%sfailed to drop %d%s assumption %d\n", 
-		     ps->prefix, i, enumstr (i), work[i]);
-
-	  if (fix)
-	    {
-	      picosat_add (ps, work[i]);
-	      picosat_add (ps, 0);
-	    }
-	}
-      else
-	{
-	  assert (res == 20);
-	  if (ps->verbosity > 1)
-	     fprintf (ps->out,
-		     "%ssuceeded to drop %d%s assumption %d\n", 
-		     ps->prefix, i, enumstr (i), work[i]);
-	  redundant[i] = 1;
-	  for (j = 0; j < nwork; j++)
-	    {
-	      failed = picosat_failed_assumption (ps, work[j]);
-	      if (j <= i) 
-		{
-		  assert ((j < i && fix) || redundant[j] == !failed);
-		  continue;
-		}
-
-	      if (!failed)
-		{
-		  redundant[j] = -1;
-		  if (ps->verbosity > 1)
-		     fprintf (ps->out,
-			     "%salso suceeded to drop %d%s assumption %d\n", 
-			     ps->prefix, j, enumstr (j), work[j]);
-		}
-	    }
-
-#ifndef NDEBUG
-	    oldlen = len;
-#endif
-	    len = 0;
-	    for (j = 0; j < nwork; j++)
-	      if (!redundant[j])
-		ps->mass[len++] = work[j];
-	    ps->mass[len] = 0;
-	    assert (len < oldlen);
-
-	    if (fix)
-	      {
-		picosat_add (ps, -work[i]);
-		picosat_add (ps, 0);
-	      }
-
-#ifndef NDEBUG
-	    for (j = 0; j <= i; j++)
-	      assert (redundant[j] >= 0);
-#endif
-	    for (j = i + 1; j < nwork; j++) 
-	      {
-		if (redundant[j] >= 0)
-		  continue;
-
-		if (fix)
-		  {
-		    picosat_add (ps, -work[j]);
-		    picosat_add (ps, 0);
-		  }
-
-		redundant[j] = 1;
-	      }
-
-	    if (ps->verbosity)
-	       fprintf (ps->out, 
-	"%sreduced set of failed assumptions of size %d out of %d (%.0f%%)\n",
-		ps->prefix, len, norig, PERCENT (len, norig));
-	    if (cb)
-	      cb (s, ps->mass);
-	}
-    }
-
-  DELETEN (work, nwork);
-  DELETEN (redundant, nwork);
-
-  if (ps->verbosity)
-    {
-       fprintf (ps->out, "%sreinitializing unsat state\n", ps->prefix);
-      fflush (ps->out);
-    }
-
-  for (i = 0; i < len; i++)
-    picosat_assume (ps, ps->mass[i]);
-
-#ifndef NDEBUG
-  res = 
-#endif
-  picosat_sat (ps, -1);
-  assert (res == 20);
-
-  if (!ps->mtcls)
-    {
-      assert (!ps->extracted_all_failed_assumptions);
-      extract_all_failed_assumptions (ps);
-    }
-
-  return ps->mass;
-}
-
-static const int *
-mss (PS * ps, int * a, int size)
-{
-  int i, j, k, res;
-
-  assert (!ps->mtcls);
-
-  if (ps->szmssass)
-    DELETEN (ps->mssass, ps->szmssass);
-
-  ps->szmssass = 0;
-  ps->mssass = 0;
-
-  ps->szmssass = size + 1;
-  NEWN (ps->mssass, ps->szmssass);
-
-  LOG ( fprintf (ps->out, "%ssearch MSS over %d assumptions\n", ps->prefix, size));
-
-  k = 0;
-  for (i = k; i < size; i++)
-    {
-      for (j = 0; j < k; j++)
-	picosat_assume (ps, ps->mssass[j]);
-
-      LOG ( fprintf (ps->out, 
-             "%strying to add assumption %d to MSS : %d\n", 
-	     ps->prefix, i, a[i])); 
-
-      picosat_assume (ps, a[i]);
-
-      res = picosat_sat (ps, -1);
-      if (res == 10)
-	{
-	  LOG ( fprintf (ps->out, 
-		 "%sadding assumption %d to MSS : %d\n", ps->prefix, i, a[i])); 
-
-	  ps->mssass[k++] = a[i];
-
-	  for (j = i + 1; j < size; j++)
-	    {
-	      if (picosat_deref (ps, a[j]) <= 0)
-		continue;
-
-	      LOG ( fprintf (ps->out, 
-		     "%salso adding assumption %d to MSS : %d\n", 
-		     ps->prefix, j, a[j])); 
-
-	      ps->mssass[k++] = a[j];
-
-	      if (++i != j)
-		{
-		  int tmp = a[i];
-		  a[i] = a[j];
-		  a[j] = tmp;
-		}
-	    }
-	}
-      else
-	{
-	  assert (res == 20);
-
-	  LOG ( fprintf (ps->out, 
-		 "%signoring assumption %d in MSS : %d\n", ps->prefix, i, a[i])); 
-	}
-    }
-  ps->mssass[k] = 0;
-  LOG ( fprintf (ps->out, "%sfound MSS of size %d\n", ps->prefix, k));
-
-  return ps->mssass;
-}
-
-static void
-reassume (PS * ps, const int * a, int size)
-{
-  int i;
-  LOG ( fprintf (ps->out, "%sreassuming all assumptions\n", ps->prefix));
-  for (i = 0; i < size; i++)
-    picosat_assume (ps, a[i]);
-}
-
-const int *
-picosat_maximal_satisfiable_subset_of_assumptions (PS * ps)
-{
-  const int * res;
-  int i, *a, size;
-
-  ABORTIF (ps->mtcls,
-           "API usage: CNF inconsistent (use 'picosat_inconsistent')");
-
-  enter (ps);
-
-  size = ps->alshead - ps->als;
-  NEWN (a, size);
-
-  for (i = 0; i < size; i++)
-    a[i] = LIT2INT (ps->als[i]);
-
-  res = mss (ps, a, size);
-  reassume (ps, a, size);
-
-  DELETEN (a, size);
-
-  leave (ps);
-
-  return res;
-}
-
-static void
-check_mss_flags_clean (PS * ps)
-{
-#ifndef NDEBUG
-  unsigned i;
-  for (i = 1; i <= ps->max_var; i++)
-    {
-      assert (!ps->vars[i].msspos);
-      assert (!ps->vars[i].mssneg);
-    }
-#else
-  (void) ps;
-#endif
-}
-
-static void
-push_mcsass (PS * ps, int lit)
-{
-  if (ps->nmcsass == ps->szmcsass)
-    {
-      ps->szmcsass = ps->szmcsass ? 2*ps->szmcsass : 1;
-      RESIZEN (ps->mcsass, ps->nmcsass, ps->szmcsass);
-    }
-
-  ps->mcsass[ps->nmcsass++] = lit;
-}
-
-static const int *
-next_mss (PS * ps, int mcs)
-{
-  int i, *a, size, mssize, mcsize, lit, inmss;
-  const int * res, * p;
-  Var * v;
-
-  if (ps->mtcls) return 0;
-
-  check_mss_flags_clean (ps);
-
-  if (mcs && ps->mcsass)
-    {
-      DELETEN (ps->mcsass, ps->szmcsass);
-      ps->nmcsass = ps->szmcsass = 0;
-      ps->mcsass = 0;
-    }
-
-  size = ps->alshead - ps->als;
-  NEWN (a, size);
-
-  for (i = 0; i < size; i++)
-    a[i] = LIT2INT (ps->als[i]);
-
-  (void) picosat_sat (ps, -1);
-
-  //TODO short cut for 'picosat_res () == 10'?
-
-  if (ps->mtcls)
-    {
-      assert (picosat_res (ps) == 20);
-      res = 0;
-      goto DONE;
-    }
-
-  res = mss (ps, a, size);
-
-  if (ps->mtcls)
-    {
-      res = 0;
-      goto DONE;
-    }
-
-  for (p = res; (lit = *p); p++) 
-    {
-      v = ps->vars + abs (lit);
-      if (lit < 0)
-	{
-	  assert (!v->msspos);
-	  v->mssneg = 1;
-	}
-      else
-	{
-	  assert (!v->mssneg);
-	  v->msspos = 1;
-	}
-    }
-
-  mssize = p - res;
-  mcsize = INT_MIN;
-
-  for (i = 0; i < size; i++)
-    {
-      lit = a[i];
-      v = ps->vars + abs (lit);
-      if (lit > 0 && v->msspos)
-	inmss = 1;
-      else if (lit < 0 && v->mssneg)
-	inmss = 1;
-      else 
-	inmss = 0;
-
-      if (mssize < mcsize)
-	{
-	  if (inmss)
-	    picosat_add (ps, -lit);
-	}
-      else
-	{
-	  if (!inmss)
-	    picosat_add (ps, lit);
-	}
-
-      if (!inmss && mcs)
-	push_mcsass (ps, lit);
-    }
-  picosat_add (ps, 0);
-  if (mcs)
-    push_mcsass (ps, 0);
-
-  for (i = 0; i < size; i++)
-    {
-      lit = a[i];
-      v = ps->vars + abs (lit);
-      v->msspos = 0;
-      v->mssneg = 0;
-    }
-
-DONE:
-
-  reassume (ps, a, size);
-  DELETEN (a, size);
-
-  return res;
-}
-
-const int *
-picosat_next_maximal_satisfiable_subset_of_assumptions (PS * ps)
-{
-  const int * res;
-  enter (ps);
-  res = next_mss (ps, 0);
-  leave (ps);
-  return  res;
-}
-
-const int *
-picosat_next_minimal_correcting_subset_of_assumptions (PS * ps)
-{
-  const int * res, * tmp;
-  enter (ps);
-  tmp = next_mss (ps, 1);
-  res = tmp ? ps->mcsass : 0;
-  leave (ps);
-  return res;
-}
-
-const int *
-picosat_humus (PS * ps, 
-               void (*callback)(void*state,int nmcs,int nhumus),
-	       void * state)
-{
-  int lit, nmcs, j, nhumus;
-  const int * mcs, * p;
-  unsigned i;
-  Var * v;
-  enter (ps);
-#ifndef NDEBUG
-  for (i = 1; i <= ps->max_var; i++)
-    {
-      v = ps->vars + i;
-      assert (!v->humuspos);
-      assert (!v->humusneg);
-    }
-#endif
-  nhumus = nmcs = 0;
-  while ((mcs = picosat_next_minimal_correcting_subset_of_assumptions (ps)))
-    {
-      for (p = mcs; (lit = *p); p++)
-	{
-	  v = ps->vars + abs (lit);
-	  if (lit < 0)
-	    {
-	      if (!v->humusneg)
-		{
-		  v->humusneg = 1;
-		  nhumus++;
-		}
-	    }
-	  else
-	    {
-	      if (!v->humuspos)
-		{
-		  v->humuspos = 1;
-		  nhumus++;
-		}
-	    }
-	}
-      nmcs++;
-      LOG ( fprintf (ps->out, 
-             "%smcs %d of size %d humus %d\n",
-	     ps->prefix, nmcs, (int)(p - mcs), nhumus));
-      if (callback)
-	callback (state, nmcs, nhumus);
-    }
-  assert (!ps->szhumus);
-  ps->szhumus = 1;
-  for (i = 1; i <= ps->max_var; i++)
-    {
-      v = ps->vars + i;
-      if (v->humuspos)
-	ps->szhumus++;
-      if (v->humusneg)
-	ps->szhumus++;
-    }
-  assert (nhumus + 1 == ps->szhumus);
-  NEWN (ps->humus, ps->szhumus);
-  j = 0;
-  for (i = 1; i <= ps->max_var; i++)
-    {
-      v = ps->vars + i;
-      if (v->humuspos)
-	{
-	  assert (j < nhumus);
-	  ps->humus[j++] = (int) i;
-	}
-      if (v->humusneg)
-	{
-	  assert (j < nhumus);
-	  assert (i < INT_MAX);
-	  ps->humus[j++] = - (int) i;
-	}
-    }
-  assert (j == nhumus);
-  assert (j < ps->szhumus);
-  ps->humus[j] = 0;
-  leave (ps);
-  return ps->humus;
-}
-
-int
-picosat_usedlit (PS * ps, int int_lit)
-{
-  int res;
-  check_ready (ps);
-  check_sat_or_unsat_or_unknown_state (ps);
-  ABORTIF (!int_lit, "API usage: zero literal can not be used");
-  int_lit = abs (int_lit);
-  res = (int_lit <= (int) ps->max_var) ? ps->vars[int_lit].used : 0;
-  return res;
-}
-
-void
-picosat_write_clausal_core (PS * ps, FILE * file)
-{
-  check_trace_support_and_execute (ps, file, write_core_wrapper, 0);
-}
-
-void
-picosat_write_compact_trace (PS * ps, FILE * file)
-{
-  check_trace_support_and_execute (ps, file, write_trace,
-                                   COMPACT_TRACECHECK_TRACE_FMT);
-}
-
-void
-picosat_write_extended_trace (PS * ps, FILE * file)
-{
-  check_trace_support_and_execute (ps, file, write_trace,
-                                   EXTENDED_TRACECHECK_TRACE_FMT);
-}
-
-void
-picosat_write_rup_trace (PS * ps, FILE * file)
-{
-  check_trace_support_and_execute (ps, file, write_trace, RUP_TRACE_FMT);
-}
-
-size_t
-picosat_max_bytes_allocated (PS * ps)
-{
-  check_ready (ps);
-  return ps->max_bytes;
-}
-
-void
-picosat_set_propagation_limit (PS * ps, unsigned long long l)
-{
-  ps->lpropagations = l;
-}
-
-unsigned long long
-picosat_propagations (PS * ps)
-{
-  return ps->propagations;
-}
-
-unsigned long long
-picosat_visits (PS * ps)
-{
-  return ps->visits;
-}
-
-unsigned long long
-picosat_decisions (PS * ps)
-{
-  return ps->decisions;
-}
-
-int
-picosat_variables (PS * ps)
-{
-  check_ready (ps);
-  return (int) ps->max_var;
-}
-
-int
-picosat_added_original_clauses (PS * ps)
-{
-  check_ready (ps);
-  return (int) ps->oadded;
-}
-
-void
-picosat_stats (PS * ps)
-{
-#ifndef RCODE
-  unsigned redlits;
-#endif
-#ifdef STATS
-  check_ready (ps);
-  assert (ps->sdecisions + ps->rdecisions + ps->assumptions == ps->decisions);
-#endif
-  if (ps->calls > 1)
-     fprintf (ps->out, "%s%u calls\n", ps->prefix, ps->calls);
-  if (ps->contexts)
-    {
-       fprintf (ps->out, "%s%u contexts", ps->prefix, ps->contexts);
-#ifdef STATS
-       fprintf (ps->out, " %u internal variables", ps->internals);
-#endif
-       fprintf (ps->out, "\n");
-    }
-   fprintf (ps->out, "%s%u iterations\n", ps->prefix, ps->iterations);
-   fprintf (ps->out, "%s%u restarts", ps->prefix, ps->restarts);
-#ifdef STATS
-   fprintf (ps->out, " (%u skipped)", ps->skippedrestarts);
-#endif
-  fputc ('\n', ps->out);
-#ifndef NFL
-   fprintf (ps->out, "%s%u failed literals", ps->prefix, ps->failedlits);
-#ifdef STATS
-   fprintf (ps->out,
-           ", %u calls, %u rounds, %llu propagations",
-           ps->flcalls, ps->flrounds, ps->flprops);
-#endif
-  fputc ('\n', ps->out);
-#ifdef STATS
-   fprintf (ps->out, 
-    "%sfl: %u = %.1f%% implicit, %llu oopsed, %llu tried, %llu skipped\n", 
-    ps->prefix, 
-    ps->ifailedlits, PERCENT (ps->ifailedlits, ps->failedlits),
-    ps->floopsed, ps->fltried, ps->flskipped);
-#endif
-#endif
-   fprintf (ps->out, "%s%u conflicts", ps->prefix, ps->conflicts);
-#ifdef STATS
-   fprintf (ps->out, " (%u uips = %.1f%%)\n", ps->uips, PERCENT(ps->uips,ps->conflicts));
-#else
-  fputc ('\n', ps->out);
-#endif
-#ifndef NADC
-   fprintf (ps->out, "%s%u adc conflicts\n", ps->prefix, ps->adoconflicts);
-#endif
-#ifdef STATS
-   fprintf (ps->out, "%s%llu dereferenced literals\n", ps->prefix, ps->derefs);
-#endif
-   fprintf (ps->out, "%s%u decisions", ps->prefix, ps->decisions);
-#ifdef STATS
-   fprintf (ps->out, " (%u random = %.2f%%",
-           ps->rdecisions, PERCENT (ps->rdecisions, ps->decisions));
-   fprintf (ps->out, ", %u assumptions", ps->assumptions);
-  fputc (')', ps->out);
-#endif
-  fputc ('\n', ps->out);
-#ifdef STATS
-   fprintf (ps->out,
-           "%s%u static phase decisions (%.1f%% of all variables)\n",
-	   ps->prefix,
-	   ps->staticphasedecisions, PERCENT (ps->staticphasedecisions, ps->max_var));
-#endif
-   fprintf (ps->out, "%s%u fixed variables\n", ps->prefix, ps->fixed);
-  assert (ps->nonminimizedllits >= ps->minimizedllits);
-#ifndef RCODE
-  redlits = ps->nonminimizedllits - ps->minimizedllits;
-#endif
-   fprintf (ps->out, "%s%u learned literals\n", ps->prefix, ps->llitsadded);
-   fprintf (ps->out, "%s%.1f%% deleted literals\n",
-     ps->prefix, PERCENT (redlits, ps->nonminimizedllits));
-
-#ifdef STATS
-#ifdef TRACE
-   fprintf (ps->out,
-	   "%s%llu antecedents (%.1f antecedents per clause",
-	   ps->prefix, ps->antecedents, AVERAGE (ps->antecedents, ps->conflicts));
-  if (ps->trace)
-     fprintf (ps->out, ", %.1f bytes/antecedent)", AVERAGE (ps->znts, ps->antecedents));
-  fputs (")\n", ps->out);
-#endif
-
-   fprintf (ps->out, "%s%llu propagations (%.1f propagations per decision)\n",
-           ps->prefix, ps->propagations, AVERAGE (ps->propagations, ps->decisions));
-   fprintf (ps->out, "%s%llu visits (%.1f per propagation)\n",
-	   ps->prefix, ps->visits, AVERAGE (ps->visits, ps->propagations));
-   fprintf (ps->out, 
-           "%s%llu binary clauses visited (%.1f%% %.1f per propagation)\n",
-	   ps->prefix, ps->bvisits, 
-	   PERCENT (ps->bvisits, ps->visits),
-	   AVERAGE (ps->bvisits, ps->propagations));
-   fprintf (ps->out, 
-           "%s%llu ternary clauses visited (%.1f%% %.1f per propagation)\n",
-	   ps->prefix, ps->tvisits, 
-	   PERCENT (ps->tvisits, ps->visits),
-	   AVERAGE (ps->tvisits, ps->propagations));
-   fprintf (ps->out, 
-           "%s%llu large clauses visited (%.1f%% %.1f per propagation)\n",
-	   ps->prefix, ps->lvisits, 
-	   PERCENT (ps->lvisits, ps->visits),
-	   AVERAGE (ps->lvisits, ps->propagations));
-   fprintf (ps->out, "%s%llu other true (%.1f%% of visited clauses)\n",
-	   ps->prefix, ps->othertrue, PERCENT (ps->othertrue, ps->visits));
-   fprintf (ps->out, 
-           "%s%llu other true in binary clauses (%.1f%%)"
-	   ", %llu upper (%.1f%%)\n",
-           ps->prefix, ps->othertrue2, PERCENT (ps->othertrue2, ps->othertrue),
-	   ps->othertrue2u, PERCENT (ps->othertrue2u, ps->othertrue2));
-   fprintf (ps->out, 
-           "%s%llu other true in large clauses (%.1f%%)"
-	   ", %llu upper (%.1f%%)\n",
-           ps->prefix, ps->othertruel, PERCENT (ps->othertruel, ps->othertrue),
-	   ps->othertruelu, PERCENT (ps->othertruelu, ps->othertruel));
-   fprintf (ps->out, "%s%llu ternary and large traversals (%.1f per visit)\n",
-	   ps->prefix, ps->traversals, AVERAGE (ps->traversals, ps->visits));
-   fprintf (ps->out, "%s%llu large traversals (%.1f per large visit)\n",
-	   ps->prefix, ps->ltraversals, AVERAGE (ps->ltraversals, ps->lvisits));
-   fprintf (ps->out, "%s%llu assignments\n", ps->prefix, ps->assignments);
-#else
-   fprintf (ps->out, "%s%llu propagations\n", ps->prefix, picosat_propagations (ps));
-   fprintf (ps->out, "%s%llu visits\n", ps->prefix, picosat_visits (ps));
-#endif
-   fprintf (ps->out, "%s%.1f%% variables used\n", ps->prefix, PERCENT (ps->vused, ps->max_var));
-
-  sflush (ps);
-   fprintf (ps->out, "%s%.1f seconds in library\n", ps->prefix, ps->seconds);
-   fprintf (ps->out, "%s%.1f megaprops/second\n",
-	   ps->prefix, AVERAGE (ps->propagations / 1e6f, ps->seconds));
-   fprintf (ps->out, "%s%.1f megavisits/second\n",
-	   ps->prefix, AVERAGE (ps->visits / 1e6f, ps->seconds));
-   fprintf (ps->out, "%sprobing %.1f seconds %.0f%%\n",
-           ps->prefix, ps->flseconds, PERCENT (ps->flseconds, ps->seconds));
-#ifdef STATS
-   fprintf (ps->out,
-	   "%srecycled %.1f MB in %u reductions\n",
-	   ps->prefix, ps->rrecycled / (double) (1 << 20), ps->reductions);
-   fprintf (ps->out,
-	   "%srecycled %.1f MB in %u simplifications\n",
-	   ps->prefix, ps->srecycled / (double) (1 << 20), ps->simps);
-#else
-   fprintf (ps->out, "%s%u simplifications\n", ps->prefix, ps->simps);
-   fprintf (ps->out, "%s%u reductions\n", ps->prefix, ps->reductions);
-   fprintf (ps->out, "%s%.1f MB recycled\n", ps->prefix, ps->recycled / (double) (1 << 20));
-#endif
-   fprintf (ps->out, "%s%.1f MB maximally allocated\n",
-	    ps->prefix, picosat_max_bytes_allocated (ps) / (double) (1 << 20));
-}
-
-#ifndef NGETRUSAGE
-#include <sys/time.h>
-#include <sys/resource.h>
-#include <sys/unistd.h>
-#endif
-
-double
-picosat_time_stamp (void)
-{
-  double res = -1;
-#ifndef NGETRUSAGE
-  struct rusage u;
-  res = 0;
-  if (!getrusage (RUSAGE_SELF, &u))
-    {
-      res += u.ru_utime.tv_sec + 1e-6 * u.ru_utime.tv_usec;
-      res += u.ru_stime.tv_sec + 1e-6 * u.ru_stime.tv_usec;
-    }
-#endif
-  return res;
-}
-
-double
-picosat_seconds (PS * ps)
-{
-  check_ready (ps);
-  return ps->seconds;
-}
-
-void
-picosat_print (PS * ps, FILE * file)
-{
-#ifdef NO_BINARY_CLAUSES
-  Lit * lit, *other, * last;
-  Ltk * stack;
-#endif
-  Lit **q, **eol;
-  Cls **p, *c;
-  unsigned n;
-
-  if (ps->measurealltimeinlib)
-    enter (ps);
-  else
-    check_ready (ps);
-
-  n = 0;
-  n +=  ps->alshead - ps->als;
-
-  for (p = SOC; p != EOC; p = NXC (p))
-    {
-      c = *p;
-
-      if (!c)
-	continue;
-
-#ifdef TRACE
-      if (c->collected)
-	continue;
-#endif
-      n++;
-    }
-
-#ifdef NO_BINARY_CLAUSES
-  last = int2lit (ps, -ps->max_var);
-  for (lit = int2lit (ps, 1); lit <= last; lit++)
-    {
-      stack = LIT2IMPLS (lit);
-      eol = stack->start + stack->count;
-      for (q = stack->start; q < eol; q++)
-	if (*q >= lit)
-	  n++;
-    }
-#endif
-
-  fprintf (file, "p cnf %d %u\n", ps->max_var, n);
-
-  for (p = SOC; p != EOC; p = NXC (p))
-    {
-      c = *p;
-      if (!c)
-	continue;
-
-#ifdef TRACE
-      if (c->collected)
-	continue;
-#endif
-
-      eol = end_of_lits (c);
-      for (q = c->lits; q < eol; q++)
-	fprintf (file, "%d ", LIT2INT (*q));
-
-      fputs ("0\n", file);
-    }
-
-#ifdef NO_BINARY_CLAUSES
-  last = int2lit (ps, -ps->max_var);
-  for (lit = int2lit (ps, 1); lit <= last; lit++)
-    {
-      stack = LIT2IMPLS (lit);
-      eol = stack->start + stack->count;
-      for (q = stack->start; q < eol; q++)
-	if ((other = *q) >= lit)
-	  fprintf (file, "%d %d 0\n", LIT2INT (lit), LIT2INT (other));
-    }
-#endif
-
-  {
-    Lit **r;
-    for (r = ps->als; r < ps->alshead; r++)
-      fprintf (file, "%d 0\n", LIT2INT (*r));
-  }
-
-  fflush (file);
-
-  if (ps->measurealltimeinlib)
-    leave (ps);
-}
-
-void
-picosat_enter (PS * ps)
-{
-  enter (ps);
-}
-
-void
-picosat_leave (PS * ps)
-{
-  leave (ps);
-}
-
-void
-picosat_message (PS * ps, int vlevel, const char * fmt, ...)
-{
-  va_list ap;
-
-  if (vlevel > ps->verbosity)
-    return;
-
-  fputs (ps->prefix, ps->out);
-  va_start (ap, fmt);
-  vfprintf (ps->out, fmt, ap);
-  va_end (ap);
-  fputc ('\n', ps->out);
-}
-
-int
-picosat_changed (PS * ps)
-{
-  int res;
-
-  check_ready (ps);
-  check_sat_state (ps);
-
-  res = (ps->min_flipped <= ps->saved_max_var);
-  assert (!res || ps->saved_flips != ps->flips);
-
-  return res;
-}
-
-void
-picosat_reset_phases (PS * ps)
-{
-  rebias (ps);
-}
-
-void
-picosat_reset_scores (PS * ps)
-{
-  Rnk * r;
-  ps->hhead = ps->heap + 1;
-  for (r = ps->rnks + 1; r <= ps->rnks + ps->max_var; r++)
-    {
-      CLR (r);
-      hpush (ps, r);
-    }
-}
-
-void
-picosat_remove_learned (PS * ps, unsigned percentage)
-{
-  enter (ps);
-  reset_incremental_usage (ps);
-  reduce (ps, percentage);
-  leave (ps);
-}
-
-void
-picosat_set_global_default_phase (PS * ps, int phase)
-{
-  check_ready (ps);
-  ABORTIF (phase < 0, "API usage: 'picosat_set_global_default_phase' "
-                      "with negative argument");
-  ABORTIF (phase > 3, "API usage: 'picosat_set_global_default_phase' "
-                      "with argument > 3");
-  ps->defaultphase = phase;
-}
-
-void
-picosat_set_default_phase_lit (PS * ps, int int_lit, int phase)
-{
-  unsigned newphase;
-  Lit * lit;
-  Var * v;
-
-  check_ready (ps);
-
-  lit = import_lit (ps, int_lit, 1);
-  v = LIT2VAR (lit);
-
-  if (phase)
-    {
-      newphase = (int_lit < 0) == (phase < 0);
-      v->defphase = v->phase = newphase;
-      v->usedefphase = v->assigned = 1;
-    }
-  else
-    {
-      v->usedefphase = v->assigned = 0;
-    }
-}
-
-void
-picosat_set_more_important_lit (PS * ps, int int_lit)
-{
-  Lit * lit;
-  Var * v;
-  Rnk * r;
-
-  check_ready (ps);
-
-  lit = import_lit (ps, int_lit, 1);
-  v = LIT2VAR (lit);
-  r = VAR2RNK (v);
-
-  ABORTIF (r->lessimportant, "can not mark variable more and less important"); 
-
-  if (r->moreimportant)
-    return;
-
-  r->moreimportant = 1;
-
-  if (r->pos)
-    hup (ps, r);
-}
-
-void
-picosat_set_less_important_lit (PS * ps, int int_lit)
-{
-  Lit * lit;
-  Var * v;
-  Rnk * r;
-
-  check_ready (ps);
-
-  lit = import_lit (ps, int_lit, 1);
-  v = LIT2VAR (lit);
-  r = VAR2RNK (v);
-
-  ABORTIF (r->moreimportant, "can not mark variable more and less important"); 
-
-  if (r->lessimportant)
-    return;
-
-  r->lessimportant = 1;
-
-  if (r->pos)
-    hdown (ps, r);
-}
-
-#ifndef NADC
-
-unsigned 
-picosat_ado_conflicts (PS * ps)
-{
-  check_ready (ps);
-  return ps->adoconflicts;
-}
-
-void
-picosat_disable_ado (PS * ps)
-{
-  check_ready (ps);
-  assert (!ps->adodisabled);
-  ps->adodisabled = 1;
-}
-
-void
-picosat_enable_ado (PS * ps)
-{
-  check_ready (ps);
-  assert (ps->adodisabled);
-  ps->adodisabled = 0;
-}
-
-void
-picosat_set_ado_conflict_limit (PS * ps, unsigned newadoconflictlimit)
-{
-  check_ready (ps);
-  ps->adoconflictlimit = newadoconflictlimit;
-}
-
-#endif
-
-void
-picosat_simplify (PS * ps)
-{
-  enter (ps);
-  reset_incremental_usage (ps);
-  simplify (ps, 1);
-  leave (ps);
-}
-
-int
-picosat_haveados (void)
-{
-#ifndef NADC
-  return 1;
-#else
-  return 0;
-#endif
-}
-
-void
-picosat_save_original_clauses (PS * ps)
-{
-  if (ps->saveorig) return;
-  ABORTIF (ps->oadded, "API usage: 'picosat_save_original_clauses' too late");
-  ps->saveorig = 1;
-}
-
-void picosat_set_interrupt (PicoSAT * ps,
-                            void * external_state,
-			    int (*interrupted)(void * external_state)) 
-{
-  ps->interrupt.state = external_state;
-  ps->interrupt.function = interrupted;
-}
-
-int
-picosat_deref_partial (PS * ps, int int_lit) 
-{
-  check_ready (ps);
-  check_sat_state (ps);
-  ABORTIF (!int_lit, "API usage: can not partial deref zero literal");
-  ABORTIF (ps->mtcls, "API usage: deref partial after empty clause generated");
-  ABORTIF (!ps->saveorig, "API usage: 'picosat_save_original_clauses' missing");
-
-#ifdef STATS
-  ps->derefs++;
-#endif
-
-  if (!ps->partial)
-    minautarky (ps);
-
-  return pderef (ps, int_lit);
-}
diff --git a/test/picosat-965/picosat.h b/test/picosat-965/picosat.h
deleted file mode 100644
index 668bc00b..00000000
--- a/test/picosat-965/picosat.h
+++ /dev/null
@@ -1,658 +0,0 @@
-/****************************************************************************
-Copyright (c) 2006 - 2015, Armin Biere, Johannes Kepler University.
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to
-deal in the Software without restriction, including without limitation the
-rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
-sell copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-IN THE SOFTWARE.
-****************************************************************************/
-
-#ifndef picosat_h_INCLUDED
-#define picosat_h_INCLUDED
-
-/*------------------------------------------------------------------------*/
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <stddef.h>
-
-/*------------------------------------------------------------------------*/
-/* The following macros allows for users to distiguish between different
- * versions of the API.  The first 'PICOSAT_REENTRANT_API' is defined for
- * the new reentrant API which allows to generate multiple instances of
- * PicoSAT in one process.  The second 'PICOSAT_API_VERSION' defines the
- * (smallest) version of PicoSAT to which this API conforms.
- */
-#define PICOSAT_REENTRANT_API
-#define PICOSAT_API_VERSION 953		/* API version */
-
-/*------------------------------------------------------------------------*/
-/* These are the return values for 'picosat_sat' as for instance
- * standardized by the output format of the SAT competition.
- */
-#define PICOSAT_UNKNOWN         0
-#define PICOSAT_SATISFIABLE     10
-#define PICOSAT_UNSATISFIABLE   20
-
-/*------------------------------------------------------------------------*/
-
-typedef struct PicoSAT PicoSAT;
-
-/*------------------------------------------------------------------------*/
-
-const char *picosat_version (void);
-const char *picosat_config (void);
-const char *picosat_copyright (void);
-
-/*------------------------------------------------------------------------*/
-/* You can make PicoSAT use an external memory manager instead of the one
- * provided by LIBC. But then you need to call these three function before
- * 'picosat_init'.  The memory manager functions here all have an additional
- * first argument which is a pointer to the memory manager, but otherwise
- * are supposed to work as their LIBC counter parts 'malloc', 'realloc' and
- * 'free'.  As exception the 'resize' and 'delete' function have as third
- * argument the number of bytes of the block given as second argument.
- */
-
-typedef void * (*picosat_malloc)(void *, size_t);
-typedef void * (*picosat_realloc)(void*, void *, size_t, size_t);
-typedef void (*picosat_free)(void*, void*, size_t);
-
-/*------------------------------------------------------------------------*/
-
-PicoSAT * picosat_init (void);          /* constructor */
-
-PicoSAT * picosat_minit (void * state,
-			 picosat_malloc,
-			 picosat_realloc,
-			 picosat_free);
-
-void picosat_reset (PicoSAT *);         /* destructor */
-
-/*------------------------------------------------------------------------*/
-/* The following five functions are essentially parameters to 'init', and
- * thus should be called right after 'picosat_init' before doing anything
- * else.  You should not call any of them after adding a literal.
- */
-
-/* Set output file, default is 'stdout'.
- */
-void picosat_set_output (PicoSAT *, FILE *);
-
-/* Measure all time spent in all calls in the solver.  By default only the
- * time spent in 'picosat_sat' is measured.  Enabling this function might
- * for instance triple the time needed to add large CNFs, since every call
- * to 'picosat_add' will trigger a call to 'getrusage'.
- */
-void picosat_measure_all_calls (PicoSAT *);
-
-/* Set the prefix used for printing verbose messages and statistics.
- * Default is "c ".
- */
-void picosat_set_prefix (PicoSAT *, const char *);
-
-/* Set verbosity level.  A verbosity level of 1 and above prints more and
- * more detailed progress reports on the output file, set by
- * 'picosat_set_output'.  Verbose messages are prefixed with the string set
- * by 'picosat_set_prefix'.
- */
-void picosat_set_verbosity (PicoSAT *, int new_verbosity_level);
-
-/* Disable/Enable all pre-processing, currently only failed literal probing.
- *
- *  new_plain_value != 0    only 'plain' solving, so no preprocessing
- *  new_plain_value == 0    allow preprocessing
- */
-void picosat_set_plain (PicoSAT *, int new_plain_value);
-
-/* Set default initial phase: 
- *
- *   0 = false
- *   1 = true
- *   2 = Jeroslow-Wang (default)
- *   3 = random initial phase
- *
- * After a variable has been assigned the first time, it will always
- * be assigned the previous value if it is picked as decision variable.
- * The initial assignment can be chosen with this function.
- */
-void picosat_set_global_default_phase (PicoSAT *, int);
-
-/* Set next/initial phase of a particular variable if picked as decision
- * variable.  Second argument 'phase' has the following meaning:
- *
- *   negative = next value if picked as decision variable is false
- *
- *   positive = next value if picked as decision variable is true
- *
- *   0        = use global default phase as next value and
- *              assume 'lit' was never assigned
- *
- * Again if 'lit' is assigned afterwards through a forced assignment,
- * then this forced assignment is the next phase if this variable is
- * used as decision variable.
- */
-void picosat_set_default_phase_lit (PicoSAT *, int lit, int phase);
-
-/* You can reset all phases by the following function.
- */
-void picosat_reset_phases (PicoSAT *);
-
-/* Scores can be erased as well.  Note, however, that even after erasing 
- * scores and phases, learned clauses are kept.  In addition head tail
- * pointers for literals are not moved either.  So expect a difference
- * between calling the solver in incremental mode or with a fresh copy of
- * the CNF.
- */
-void picosat_reset_scores (PicoSAT *);
-
-/* Reset assignment if in SAT state and then remove the given percentage of
- * less active (large) learned clauses.  If you specify 100% all large
- * learned clauses are removed.
- */
-void picosat_remove_learned (PicoSAT *, unsigned percentage);
-
-/* Set some variables to be more important than others.  These variables are
- * always used as decisions before other variables are used.  Dually there
- * is a set of variables that is used last.  The default is
- * to mark all variables as being indifferent only.
- */
-void picosat_set_more_important_lit (PicoSAT *, int lit);
-void picosat_set_less_important_lit (PicoSAT *, int lit);
-
-/* Allows to print to internal 'out' file from client.
- */
-void picosat_message (PicoSAT *, int verbosity_level, const char * fmt, ...);
-
-/* Set a seed for the random number generator.  The random number generator
- * is currently just used for generating random decisions.  In our
- * experiments having random decisions did not really help on industrial
- * examples, but was rather helpful to randomize the solver in order to
- * do proper benchmarking of different internal parameter sets.
- */
-void picosat_set_seed (PicoSAT *, unsigned random_number_generator_seed);
-
-/* If you ever want to extract cores or proof traces with the current
- * instance of PicoSAT initialized with 'picosat_init', then make sure to
- * call 'picosat_enable_trace_generation' right after 'picosat_init'.   This
- * is not necessary if you only use 'picosat_set_incremental_rup_file'.
- *
- * NOTE, trace generation code is not necessarily included, e.g. if you
- * configure PicoSAT with full optimzation as './configure.sh -O' or with
- 
- * you do not get any results by trying to generate traces.
- *
- * The return value is non-zero if code for generating traces is included
- * and it is zero if traces can not be generated.
- */
-int picosat_enable_trace_generation (PicoSAT *);
-
-/* You can dump proof traces in RUP format incrementally even without
- * keeping the proof trace in memory.  The advantage is a reduction of
- * memory usage, but the dumped clauses do not necessarily belong to the
- * clausal core.  Beside the file the additional parameters denotes the
- * maximal number of variables and the number of original clauses.
- */
-void picosat_set_incremental_rup_file (PicoSAT *, FILE * file, int m, int n);
-
-/* Save original clauses for 'picosat_deref_partial'.  See comments to that
- * function further down.
- */
-void picosat_save_original_clauses (PicoSAT *);
-
-/* Add a call back which is checked regularly to notify the SAT solver
- * to terminate earlier.  This is useful for setting external time limits
- * or terminate early in say a portfolio style parallel SAT solver.
- */
-void picosat_set_interrupt (PicoSAT *,
-                            void * external_state,
-			    int (*interrupted)(void * external_state));
-
-/*------------------------------------------------------------------------*/
-/* This function returns the next available unused variable index and
- * allocates a variable for it even though this variable does not occur as
- * assumption, nor in a clause or any other constraints.  In future calls to
- * 'picosat_sat', 'picosat_deref' and particularly for 'picosat_changed',
- * this variable is treated as if it had been used.
- */
-int picosat_inc_max_var (PicoSAT *);
-
-/*------------------------------------------------------------------------*/
-/* Push and pop semantics for PicoSAT.   'picosat_push' opens up a new
- * context.  All clauses added in this context are attached to it and
- * discarded when the context is closed with 'picosat_pop'.  It is also
- * possible to nest contexts.
- *
- * The current implementation uses a new internal variable for each context.
- * However, the indices for these internal variables are shared with
- * ordinary external variables.  This means that after any call to
- * 'picosat_push', new variable indices should be obtained with
- * 'picosat_inc_max_var' and not just by incrementing the largest variable
- * index used so far.
- *
- * The return value is the index of the literal that assumes this context.
- * This literal can only be used for 'picosat_failed_context' otherwise
- * it will lead to an API usage error.
- */
-int picosat_push (PicoSAT *);
-
-/* This is as 'picosat_failed_assumption', but only for internal variables
- * generated by 'picosat_push'.
- */
-int picosat_failed_context (PicoSAT *, int lit);
-
-/* Returns the literal that assumes the current context or zero if the
- * outer context has been reached.
- */
-int picosat_context (PicoSAT *);	
-
-/* Closes the current context and recycles the literal generated for
- * assuming this context.  The return value is the literal for the new
- * outer context or zero if the outer most context has been reached.
- */
-int picosat_pop (PicoSAT *);
-
-/* Force immmediate removal of all satisfied clauses and clauses that are
- * added or generated in closed contexts.  This function is called
- * internally if enough units are learned or after a certain number of
- * contexts have been closed.  This number is fixed at compile time
- * and defined as MAXCILS in 'picosat.c'.
- *
- * Note that learned clauses which only involve outer contexts are kept.
- */
-void picosat_simplify (PicoSAT *);
-
-/*------------------------------------------------------------------------*/
-/* If you know a good estimate on how many variables you are going to use
- * then calling this function before adding literals will result in less
- * resizing of the variable table.  But this is just a minor optimization.
- * Beside exactly allocating enough variables it has the same effect as
- * calling 'picosat_inc_max_var'.
- */
-void picosat_adjust (PicoSAT *, int max_idx);
-
-/*------------------------------------------------------------------------*/
-/* Statistics.
- */
-int picosat_variables (PicoSAT *);                      /* p cnf <m> n */
-int picosat_added_original_clauses (PicoSAT *);         /* p cnf m <n> */
-size_t picosat_max_bytes_allocated (PicoSAT *);
-double picosat_time_stamp (void);                       /* ... in process */
-void picosat_stats (PicoSAT *);                         /* > output file */
-unsigned long long picosat_propagations (PicoSAT *);	/* #propagations */
-unsigned long long picosat_decisions (PicoSAT *);	/* #decisions */
-unsigned long long picosat_visits (PicoSAT *);		/* #visits */
-
-/* The time spent in calls to the library or in 'picosat_sat' respectively.
- * The former is returned if, right after initialization
- * 'picosat_measure_all_calls' is called.
- */
-double picosat_seconds (PicoSAT *);
-
-/*------------------------------------------------------------------------*/
-/* Add a literal of the next clause.  A zero terminates the clause.  The
- * solver is incremental.  Adding a new literal will reset the previous
- * assignment.   The return value is the original clause index to which
- * this literal respectively the trailing zero belong starting at 0.
- */
-int picosat_add (PicoSAT *, int lit);
-
-/* As the previous function, but allows to add a full clause at once with an
- * at compiled time known size.  The list of argument literals has to be
- * terminated with a zero literal.  Literals beyond the first zero literal
- * are discarded.
- */
-int picosat_add_arg (PicoSAT *, ...);
-
-/* As the previous function but with an at compile time unknown size.
- */
-int picosat_add_lits (PicoSAT *, int * lits);
-
-/* Print the CNF to the given file in DIMACS format.
- */
-void picosat_print (PicoSAT *, FILE *);
-
-/* You can add arbitrary many assumptions before the next 'picosat_sat'
- * call.  This is similar to the using assumptions in MiniSAT, except that
- * for PicoSAT you do not have to collect all your assumptions in a vector
- * yourself.  In PicoSAT you can add one after the other, to be used in the 
- * next call to 'picosat_sat'.
- *
- * These assumptions can be interpreted as adding unit clauses with those
- * assumptions as literals.  However these assumption clauses are only valid
- * for exactly the next call to 'picosat_sat', and will be removed
- * afterwards, e.g. in following future calls to 'picosat_sat' after the
- * next 'picosat_sat' call, unless they are assumed again trough
- * 'picosat_assume'.
- *
- * More precisely, assumptions actually remain valid even after the next
- * call to 'picosat_sat' has returned.  Valid means they remain 'assumed'
- * internally until a call to 'picosat_add', 'picosat_assume', or a second
- * 'picosat_sat', following the first 'picosat_sat'.  The reason for keeping
- * them valid is to allow 'picosat_failed_assumption' to return correct
- * values.  
- *
- * Example:
- *
- *   picosat_assume (1);        // assume unit clause '1 0'
- *   picosat_assume (-2);       // additionally assume clause '-2 0'
- *   res = picosat_sat (1000);  // assumes 1 and -2 to hold
- *                              // 1000 decisions max.
- *
- *   if (res == PICOSAT_UNSATISFIABLE) 
- *     {
- *       if (picosat_failed_assumption (1))
- *         // unit clause '1 0' was necessary to derive UNSAT
- *
- *       if (picosat_failed_assumption (-2))
- *         // unit clause '-2 0' was necessary to derive UNSAT
- *
- *       // at least one but also both could be necessary
- *
- *       picosat_assume (17);  // previous assumptions are removed
- *                             // now assume unit clause '17 0' for
- *                             // the next call to 'picosat_sat'
- *
- *       // adding a new clause, actually the first literal of
- *       // a clause would also make the assumptions used in the previous
- *       // call to 'picosat_sat' invalid.
- *
- *       // The first two assumptions above are not assumed anymore.  Only
- *       // the assumptions, since the last call to 'picosat_sat' returned
- *       // are assumed, e.g. the unit clause '17 0'.
- *
- *       res = picosat_sat (-1);
- *     }
- *   else if (res == PICOSAT_SATISFIABLE)
- *     {
- *       // now the assignment is valid and we can call 'picosat_deref'
- *
- *       assert (picosat_deref (1) == 1));
- *       assert (picosat_deref (-2) == 1));
- *
- *       val = picosat_deref (15);
- *
- *       // previous two assumptions are still valid
- *
- *       // would become invalid if 'picosat_add' or 'picosat_assume' is
- *       // called here, but we immediately call 'picosat_sat'.  Now when
- *       // entering 'picosat_sat' the solver knows that the previous call
- *       // returned SAT and it can safely reset the previous assumptions
- *
- *       res = picosat_sat (-1);
- *     }
- *   else
- *     {
- *       assert (res == PICOSAT_UNKNOWN);
- *
- *       // assumptions valid, but assignment invalid
- *       // except for top level assigned literals which
- *       // necessarily need to have this value if the formula is SAT
- *
- *       // as above the solver nows that the previous call returned UNKWOWN
- *       // and will before doing anything else reset assumptions
- *
- *       picosat_sat (-1);
- *     }
- */
-void picosat_assume (PicoSAT *, int lit);
-
-/*------------------------------------------------------------------------*/
-/* This is an experimental feature for handling 'all different constraints'
- * (ADC).  Currently only one global ADC can be handled.  The bit-width of
- * all the bit-vectors entered in this ADC (stored in 'all different
- * objects' or ADOs) has to be identical.
- *
- * TODO: also handle top level assigned literals here.
- */
-void picosat_add_ado_lit (PicoSAT *, int);
-
-/*------------------------------------------------------------------------*/
-/* Call the main SAT routine.  A negative decision limit sets no limit on
- * the number of decisions.  The return values are as above, e.g.
- * 'PICOSAT_UNSATISFIABLE', 'PICOSAT_SATISFIABLE', or 'PICOSAT_UNKNOWN'.
- */
-int picosat_sat (PicoSAT *, int decision_limit);
-
-/* As alternative to a decision limit you can use the number of propagations
- * as limit.  This is more linearly related to execution time. This has to
- * be called after 'picosat_init' and before 'picosat_sat'.
- */
-void picosat_set_propagation_limit (PicoSAT *, unsigned long long limit);
-
-/* Return last result of calling 'picosat_sat' or '0' if not called.
- */
-int picosat_res (PicoSAT *);
-
-/* After 'picosat_sat' was called and returned 'PICOSAT_SATISFIABLE', then
- * the satisfying assignment can be obtained by 'dereferencing' literals.
- * The value of the literal is return as '1' for 'true',  '-1' for 'false'
- * and '0' for an unknown value.
- */
-int picosat_deref (PicoSAT *, int lit);
-
-/* Same as before but just returns true resp. false if the literals is
- * forced to this assignment at the top level.  This function does not
- * require that 'picosat_sat' was called and also does not internally reset
- * incremental usage.
- */
-int picosat_deref_toplevel (PicoSAT *, int lit);
-
-/* After 'picosat_sat' was called and returned 'PICOSAT_SATISFIABLE' a
- * partial satisfying assignment can be obtained as well.  It satisfies all
- * original clauses.  The value of the literal is return as '1' for 'true',
- * '-1' for 'false' and '0' for an unknown value.  In order to make this
- * work all original clauses have to be saved internally, which has to be
- * enabled by 'picosat_save_original_clauses' right after initialization.
- */
-int picosat_deref_partial (PicoSAT *, int lit);
-
-/* Returns non zero if the CNF is unsatisfiable because an empty clause was
- * added or derived.
- */
-int picosat_inconsistent  (PicoSAT *);
-
-/* Returns non zero if the literal is a failed assumption, which is defined
- * as an assumption used to derive unsatisfiability.  This is as accurate as
- * generating core literals, but still of course is an overapproximation of
- * the set of assumptions really necessary.  The technique does not need
- * clausal core generation nor tracing to be enabled and thus can be much
- * more effective.  The function can only be called as long the current
- * assumptions are valid.  See 'picosat_assume' for more details.
- */
-int picosat_failed_assumption (PicoSAT *, int lit);
-
-/* Returns a zero terminated list of failed assumption in the last call to
- * 'picosat_sat'.  The pointer is valid until the next call to
- * 'picosat_sat' or 'picosat_failed_assumptions'.  It only makes sense if the
- * last call to 'picosat_sat' returned 'PICOSAT_UNSATISFIABLE'.
- */
-const int * picosat_failed_assumptions (PicoSAT *);
-
-/* Returns a zero terminated minimized list of failed assumption for the last
- * call to 'picosat_sat'.  The pointer is valid until the next call to this
- * function or 'picosat_sat' or 'picosat_mus_assumptions'.  It only makes sense
- * if the last call to 'picosat_sat' returned 'PICOSAT_UNSATISFIABLE'.
- *
- * The call back function is called for all successful simplification
- * attempts.  The first argument of the call back function is the state
- * given as first argument to 'picosat_mus_assumptions'.  The second
- * argument to the call back function is the new reduced list of failed
- * assumptions.
- *
- * This function will call 'picosat_assume' and 'picosat_sat' internally but
- * before returning reestablish a proper UNSAT state, e.g.
- * 'picosat_failed_assumption' will work afterwards as expected.
- *
- * The last argument if non zero fixes assumptions.  In particular, if an
- * assumption can not be removed it is permanently assigned true, otherwise
- * if it turns out to be redundant it is permanently assumed to be false.
- */
-const int * picosat_mus_assumptions (PicoSAT *, void *,
-                                     void(*)(void*,const int*),int);
-
-/* Compute one maximal subset of satisfiable assumptions.  You need to set
- * the assumptions, call 'picosat_sat' and check for 'picosat_inconsistent',
- * before calling this function.  The result is a zero terminated array of
- * assumptions that consistently can be asserted at the same time.  Before
- * returing the library 'reassumes' all assumptions.
- *
- * It could be beneficial to set the default phase of assumptions
- * to true (positive).  This can speed up the computation.
- */
-const int * picosat_maximal_satisfiable_subset_of_assumptions (PicoSAT *);
-
-/* This function assumes that you have set up all assumptions with
- * 'picosat_assume'.  Then it calls 'picosat_sat' internally unless the
- * formula is already inconsistent without assumptions, i.e.  it contains
- * the empty clause.  After that it extracts a maximal satisfiable subset of
- * assumptions.
- *
- * The result is a zero terminated maximal subset of consistent assumptions
- * or a zero pointer if the formula contains the empty clause and thus no
- * more maximal consistent subsets of assumptions can be extracted.  In the
- * first case, before returning, a blocking clause is added, that rules out
- * the result for the next call.
- *
- * NOTE: adding the blocking clause changes the CNF.
- *
- * So the following idiom
- *
- * const int * mss;
- * picosat_assume (a1);
- * picosat_assume (a2);
- * picosat_assume (a3);
- * picosat_assume (a4);
- * while ((mss = picosat_next_maximal_satisfiable_subset_of_assumptions ()))
- *   process_mss (mss);
- *
- * can be used to iterate over all maximal consistent subsets of
- * the set of assumptions {a1,a2,a3,a4}.
- *
- * It could be beneficial to set the default phase of assumptions
- * to true (positive).  This might speed up the computation.
- */
-const int * 
-picosat_next_maximal_satisfiable_subset_of_assumptions (PicoSAT *);
-
-/* Similarly we can iterate over all minimal correcting assumption sets.
- * See the CAMUS literature [M. Liffiton, K. Sakallah JAR 2008].
- *
- * The result contains each assumed literal only once, even if it
- * was assumed multiple times (in contrast to the maximal consistent
- * subset functions above).
- *
- * It could be beneficial to set the default phase of assumptions
- * to true (positive).  This might speed up the computation.
- */
-const int *
-picosat_next_minimal_correcting_subset_of_assumptions (PicoSAT *);
-
-/* Compute the union of all minmal correcting sets, which is called
- * the 'high level union of all minimal unsatisfiable subset sets'
- * or 'HUMUS' in our papers.
- *
- * It uses 'picosat_next_minimal_correcting_subset_of_assumptions' and
- * the same notes and advices apply.  In particular, this implies that
- * after calling the function once, the current CNF becomes inconsistent,
- * and PicoSAT has to be reset.  So even this function internally uses
- * PicoSAT incrementally, it can not be used incrementally itself at this
- * point.
- *
- * The 'callback' can be used for progress logging and is called after
- * each extracted minimal correcting set if non zero.  The 'nhumus'
- * parameter of 'callback' denotes the number of assumptions found to be
- * part of the HUMUS sofar.
- */
-const int *
-picosat_humus (PicoSAT *,
-               void (*callback)(void * state, int nmcs, int nhumus),
-	       void * state);
-
-/*------------------------------------------------------------------------*/
-/* Assume that a previous call to 'picosat_sat' in incremental usage,
- * returned 'SATISFIABLE'.  Then a couple of clauses and optionally new
- * variables were added (a new variable is a variable that has an index
- * larger then the maximum variable added so far).  The next call to
- * 'picosat_sat' also returns 'SATISFIABLE'. If this function
- * 'picosat_changed' returns '0', then the assignment to the old variables
- * is guaranteed to not have changed.  Otherwise it might have changed.
- * 
- * The return value to this function is only valid until new clauses are
- * added through 'picosat_add', an assumption is made through
- * 'picosat_assume', or again 'picosat_sat' is called.  This is the same
- * assumption as for 'picosat_deref'.
- *
- * TODO currently this function might also return a non zero value even if
- * the old assignment did not change, because it only checks whether the
- * assignment of at least one old variable was flipped at least once during
- * the search.  In principle it should be possible to be exact in the other
- * direction as well by using a counter of variables that have an odd number
- * of flips.  But this is not implemented yet.
- */
-int picosat_changed (PicoSAT *);
-
-/*------------------------------------------------------------------------*/
-/* The following six functions internally extract the variable and clausal
- * core and thus require trace generation to be enabled with
- * 'picosat_enable_trace_generation' right after calling 'picosat_init'.
- *
- * TODO: using these functions in incremental mode with failed assumptions
- * has only been tested for 'picosat_corelit' thoroughly.  The others
- * probably only work in non-incremental mode or without using
- * 'picosat_assume'.
- */
-
-/* This function determines whether the i'th added original clause is in the
- * core.  The 'i' is the return value of 'picosat_add', which starts at zero
- * and is incremented by one after a original clause is added (that is after
- * 'picosat_add (0)').  For the index 'i' the following has to hold: 
- *
- *   0 <= i < picosat_added_original_clauses ()
- */
-int picosat_coreclause (PicoSAT *, int i);
-
-/* This function gives access to the variable core, which is made up of the
- * variables that were resolved in deriving the empty clause.
- */
-int picosat_corelit (PicoSAT *, int lit);
-
-/* Write the clauses that were used in deriving the empty clause to a file
- * in DIMACS format.
- */
-void picosat_write_clausal_core (PicoSAT *, FILE * core_file);
-
-/* Write a proof trace in TraceCheck format to a file.
- */
-void picosat_write_compact_trace (PicoSAT *, FILE * trace_file);
-void picosat_write_extended_trace (PicoSAT *, FILE * trace_file);
-
-/* Write a RUP trace to a file.  This trace file contains only the learned
- * core clauses while this is not necessarily the case for the RUP file
- * obtained with 'picosat_set_incremental_rup_file'.
- */
-void picosat_write_rup_trace (PicoSAT *, FILE * trace_file);
-
-/*------------------------------------------------------------------------*/
-/* Keeping the proof trace around is not necessary if an over-approximation
- * of the core is enough.  A literal is 'used' if it was involved in a
- * resolution to derive a learned clause.  The core literals are necessarily
- * a subset of the 'used' literals.
- */
-
-int picosat_usedlit (PicoSAT *, int lit);
-/*------------------------------------------------------------------------*/
-#endif
diff --git a/test/picosat-965/version.c b/test/picosat-965/version.c
deleted file mode 100644
index 71c322bd..00000000
--- a/test/picosat-965/version.c
+++ /dev/null
@@ -1,14 +0,0 @@
-#include "config.h"
-
-const char *
-picosat_version (void)
-{
-  return PICOSAT_VERSION;
-}
-
-const char *
-picosat_config (void)
-{
-  return PICOSAT_CC " " PICOSAT_CFLAGS;
-}
-
diff --git a/test/raytracer/Makefile b/test/raytracer/Makefile
index 7f2b60ef..24461bd1 100644
--- a/test/raytracer/Makefile
+++ b/test/raytracer/Makefile
@@ -1,7 +1,7 @@
 include ../../Makefile.config
 
 CC=../../ccomp 
-CFLAGS=$(CCOMPOPTS) -stdlib ../../runtime -dparse -dclight -dasm -fstruct-return $(SSA_MODE)
+CFLAGS=$(CCOMPOPTS) -stdlib ../../runtime -dparse -dclight -dasm -fstruct-return
 LIBS=$(LIBMATH)
 TIME=ocaml unix.cma ../../tools/xtime.ml -mintime 2.0 -minruns 4
 
@@ -16,7 +16,6 @@ render: $(OBJS)
 
 clean:
 	rm -f *.o *.parsed.c *.light.c *.s *.sdump *.ppm render
-	rm -f *.ssa.[0-9] *.rtl.norm *.rtl.[0-9] *.rtlpar *.cssa
 
 include .depend
 
diff --git a/test/regression/Makefile b/test/regression/Makefile
index 379b72b5..698c1392 100644
--- a/test/regression/Makefile
+++ b/test/regression/Makefile
@@ -3,9 +3,7 @@ include ../../Makefile.config
 CCOMP=../../ccomp
 CCOMPFLAGS=$(CCOMPOPTS) -stdlib ../../runtime \
  -dparse -dc -dclight -dasm -fall \
- -DARCH_$(ARCH) -DMODEL_$(MODEL) \
- $(SSA_MODE)
-
+ -DARCH_$(ARCH) -DMODEL_$(MODEL)
 INTERPFLAGS=-stdlib ../../runtime -interp -quiet -fall
 LIBS=$(LIBMATH)
 
@@ -55,7 +53,6 @@ all_s: $(TESTS:%=%.s) $(TESTS_COMP:%=%.s) $(TESTS_DIFF:%=%.s) $(EXTRAS:%=%.s)
 clean:
 	rm -f *.compcert
 	rm -f *.parsed.c *.compcert.c *.light.c *.s *.o *.sdump *~ 
-	rm -f *.ssa.[0-9] *.rtl.norm *.rtl.[0-9] *.rtlpar *.cssa
 
 test:
 	@echo "----------- Compiled tests -------------"
diff --git a/test/spass/Makefile b/test/spass/Makefile
index d79cd6fd..d512ea95 100644
--- a/test/spass/Makefile
+++ b/test/spass/Makefile
@@ -1,7 +1,7 @@
 include ../../Makefile.config
 
 CC=../../ccomp 
-CFLAGS=$(CCOMPOPTS) -stdlib ../../runtime -dparse -dclight -dasm -fstruct-return $(SSA_MODE)
+CFLAGS=$(CCOMPOPTS) -stdlib ../../runtime -dparse -dclight -dasm -fstruct-return
 
 SRCS=analyze.c clause.c clock.c closure.c cnf.c component.c                 \
   condensing.c context.c defs.c dfgparser.c dfgscanner.c doc-proof.c        \
@@ -17,14 +17,9 @@ all: spass
 spass: $(SRCS:.c=.o)
 	$(CC) $(CFLAGS) -o spass $(SRCS:.c=.o) $(LIBMATH)
 
-ssa:
-	$(MAKE) clean
-	$(MAKE) SSA_MODE='-ssa on' spass
-
 clean:
 	rm -f spass
 	rm -f *.o *.s *.parsed.c *.light.c *.sdump
-	rm -f *.ssa.[0-9] *.rtl.norm *.rtl.[0-9] *.cssa *.rtlpar
 
 test:
 	$(SIMU) ./spass small_problem.dfg | grep 'Proof found'
diff --git a/x86/Asm.v b/x86/Asm.v
index 799b533e..6911a693 100644
--- a/x86/Asm.v
+++ b/x86/Asm.v
@@ -15,6 +15,7 @@
 Require Import Coqlib Maps.
 Require Import AST Integers Floats Values Memory Events Globalenvs Smallstep.
 Require Import Locations Stacklayout Conventions.
+Require Import IntPtrRel PointerOp CoqlibC Simulation.
 
 (** * Abstract syntax *)
 
@@ -159,6 +160,7 @@ Inductive instruction: Type :=
   | Paddq_ri (rd: ireg) (n: int64)
   | Psubl_rr (rd: ireg) (r1: ireg)
   | Psubq_rr (rd: ireg) (r1: ireg)
+  | Psubp_rr (rd: ireg) (r1: ireg) (* pointer subraction *)
   | Pimull_rr (rd: ireg) (r1: ireg)
   | Pimulq_rr (rd: ireg) (r1: ireg)
   | Pimull_ri (rd: ireg) (n: int)
@@ -428,6 +430,7 @@ Definition eval_addrmode (a: addrmode) (rs: regset) : val :=
 -       PF is undefined
 *)
 
+(* TODO: 32bit version  *)
 Definition compare_ints (x y: val) (rs: regset) (m: mem): regset :=
   rs #ZF  <- (Val.cmpu (Mem.valid_pointer m) Ceq x y)
      #CF  <- (Val.cmpu (Mem.valid_pointer m) Clt x y)
@@ -436,8 +439,8 @@ Definition compare_ints (x y: val) (rs: regset) (m: mem): regset :=
      #PF  <- Vundef.
 
 Definition compare_longs (x y: val) (rs: regset) (m: mem): regset :=
-  rs #ZF  <- (Val.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq x y))
-     #CF  <- (Val.maketotal (Val.cmplu (Mem.valid_pointer m) Clt x y))
+  rs #ZF  <- (Val.maketotal (cmplu_join_asm m Ceq x y))
+     #CF  <- (Val.maketotal (cmplu_join_asm m Clt x y))
      #SF  <- (Val.negativel (Val.subl x y))
      #OF  <- (Val.subl_overflow x y)
      #PF  <- Vundef.
@@ -606,6 +609,12 @@ Definition exec_store (chunk: memory_chunk) (m: mem)
     but we do not need to model this precisely.
 *)
 
+Definition to_ptr (v: val) (m: mem) : val :=
+  match (Mem.to_ptr v m) with
+  | Some v' => v'
+  | _ => Vundef
+  end.
+
 Definition exec_instr (f: function) (i: instruction) (rs: regset) (m: mem) : outcome :=
   match i with
   (** Moves *)
@@ -711,6 +720,8 @@ Definition exec_instr (f: function) (i: instruction) (rs: regset) (m: mem) : out
       Next (nextinstr_nf (rs#rd <- (Val.sub rs#rd rs#r1))) m
   | Psubq_rr rd r1 =>
       Next (nextinstr_nf (rs#rd <- (Val.subl rs#rd rs#r1))) m
+  | Psubp_rr rd r1 =>
+      Next (nextinstr_nf (rs#rd <- (psub_join_asm m rs#rd rs#r1))) m
   | Pimull_rr rd r1 =>
       Next (nextinstr_nf (rs#rd <- (Val.mul rs#rd rs#r1))) m
   | Pimulq_rr rd r1 =>
@@ -900,7 +911,7 @@ Definition exec_instr (f: function) (i: instruction) (rs: regset) (m: mem) : out
   | Pjmp_s id sg =>
       Next (rs#PC <- (Genv.symbol_address ge id Ptrofs.zero)) m
   | Pjmp_r r sg =>
-      Next (rs#PC <- (rs r)) m
+      Next (rs#PC <- (to_ptr (rs r) m)) m
   | Pjcc cond lbl =>
       match eval_testcond cond rs with
       | Some true => goto_label f lbl rs m
@@ -925,7 +936,7 @@ Definition exec_instr (f: function) (i: instruction) (rs: regset) (m: mem) : out
   | Pcall_s id sg =>
       Next (rs#RA <- (Val.offset_ptr rs#PC Ptrofs.one) #PC <- (Genv.symbol_address ge id Ptrofs.zero)) m
   | Pcall_r r sg =>
-      Next (rs#RA <- (Val.offset_ptr rs#PC Ptrofs.one) #PC <- (rs r)) m
+      Next (rs#RA <- (Val.offset_ptr rs#PC Ptrofs.one) #PC <- (to_ptr (rs r) m)) m
   | Pret =>
       Next (rs#PC <- (rs#RA)) m
   (** Saving and restoring registers *)
@@ -1138,14 +1149,54 @@ Inductive initial_state (p: program): state -> Prop :=
         # RSP <- Vnullptr in
       initial_state p (State rs0 m0).
 
+Inductive glob_capture (p: program) : state -> state -> Prop :=
+  | glob_capture_intro
+      rs m pbs m'
+      (* (INIT: initial_state p (Callstate nil f nil m)) *)
+      (NONSTATIC: Genv.non_static_glob (Genv.globalenv p) (Genv.genv_public (Genv.globalenv p)) = pbs)
+      (CAPTURE: Genv.capture_init_mem m pbs m') :
+    glob_capture p (State rs m) (State rs m').
+
+Definition state_mem (st: state) : mem :=
+  match st with
+  | State _ m => m
+  end.
+
+Definition concrete_snapshot (ge: Senv.t) (st: state) (id: ident) : option Z :=
+  if Senv.public_symbol ge id
+  then (match Senv.find_symbol ge id with
+        | Some b => Maps.PTree.get b (state_mem st).(Mem.mem_concrete)
+        | None => None
+        end
+    )
+  else None.
+
 Inductive final_state: state -> int -> Prop :=
   | final_state_intro: forall rs m r,
       rs#PC = Vnullptr ->
       rs#RAX = Vint r ->
       final_state (State rs m) r.
 
+(** Non-deterministic external state *)
+
+Definition is_external (ge: genv) (st: state): Prop :=
+  match st with
+  | State rs mem =>
+    match rs PC with
+    | Vptr b ofs => match Genv.find_funct_ptr ge b with
+                   | Some (External ef) => is_external_ef ef
+                   | Some (Internal f) => match find_instr (Ptrofs.unsigned ofs) f.(fn_code) with
+                                         | Some (Pbuiltin ef args res) => is_external_ef ef
+                                         | _ => False
+                                         end
+                   | None => False      
+                   end
+    | _ => False
+    end
+  end.
+
 Definition semantics (p: program) :=
-  Semantics step (initial_state p) final_state (Genv.globalenv p).
+  Semantics step (initial_state p) (glob_capture p) (concrete_snapshot (Genv.globalenv p)) final_state is_external (Genv.globalenv p).
 
 (** Determinacy of the [Asm] semantics. *)
 
@@ -1171,7 +1222,7 @@ Proof.
   intros. eapply C; eauto.
 Qed.
 
-Lemma semantics_determinate: forall p, determinate (semantics p).
+Lemma semantics_determinate_at: forall p s (INT: ~ is_external (Genv.globalenv p) s), deterministic_at (semantics p) s.
 Proof.
 Ltac Equalities :=
   match goal with
@@ -1181,29 +1232,22 @@ Ltac Equalities :=
   end.
   intros; constructor; simpl; intros.
 - (* determ *)
-  inv H; inv H0; Equalities.
-+ split. constructor. auto.
-+ discriminate.
-+ discriminate.
+  inv STEP0; inv STEP1; Equalities; ss.
+(* + split. constructor. auto. *)
+(* + discriminate. *)
+(* + discriminate. *)
 + assert (vargs0 = vargs) by (eapply eval_builtin_args_determ; eauto). subst vargs0.
-  exploit external_call_determ. eexact H5. eexact H11. intros [A B].
-  split. auto. intros. destruct B; auto. subst. auto.
+  ss. des_ifs.
+  exploit external_call_determ. eauto. eexact H3. eexact H10. i; des; subst; eauto.
 + assert (args0 = args) by (eapply extcall_arguments_determ; eauto). subst args0.
-  exploit external_call_determ. eexact H4. eexact H9. intros [A B].
-  split. auto. intros. destruct B; auto. subst. auto.
+  ss. des_ifs.
+  exploit external_call_determ. eauto. eexact H2. eexact H8. i; des; subst; eauto.
+- ii. inv FINAL. inv STEP; Eq.
 - (* trace length *)
-  red; intros; inv H; simpl.
+  red; intros; inv H; simpl; ss.
   lia.
-  eapply external_call_trace_length; eauto.
-  eapply external_call_trace_length; eauto.
-- (* initial states *)
-  inv H; inv H0. f_equal. congruence.
-- (* final no step *)
-  assert (NOTNULL: forall b ofs, Vnullptr <> Vptr b ofs).
-  { intros; unfold Vnullptr; destruct Archi.ptr64; congruence. }
-  inv H. red; intros; red; intros. inv H; rewrite H0 in *; eelim NOTNULL; eauto.
-- (* final states *)
-  inv H; inv H0. congruence.
+  rewrite H0, H1, H2 in INT. eapply external_call_trace_length; eauto.
+  rewrite H0, H1 in INT. eapply external_call_trace_length; eauto.
 Qed.
 
 (** Classification functions for processor registers (used in Asmgenproof). *)
diff --git a/x86/AsmD.v b/x86/AsmD.v
new file mode 100644
index 00000000..91d5bc58
--- /dev/null
+++ b/x86/AsmD.v
@@ -0,0 +1,249 @@
+Require Import Coqlib sflib CoqlibC.
+Require Import Events.
+Require Import Integers.
+Require Import Globalenvs.
+Require Import Smallstep Simulation.
+Require Import Asm.
+
+Lemma semantics_single_events p s (INT: ~ is_external (Genv.globalenv p) s): single_events_at (Asm.semantics p) s.
+Proof.
+  red. intros. inv H; (try (exploit external_call_trace_length; eauto; intro T)); simpl; try lia; ss; des_ifs.
+Qed.
+
+Lemma semantics_receptive_at:
+  forall (p: program) s (INT: ~ is_external (Genv.globalenv p) s), receptive_at (semantics p) s.
+Proof.
+  intros. constructor; simpl; intros.
+  - (* receptiveness *)
+    assert (t1 = E0 -> exists s2, step (Genv.globalenv p) s t2 s2).
+    { intros. subst. inv H0. exists s1; auto. }
+    inversion H; subst; auto.
+    (* builtin *)
+    ss. des_ifs.
+    exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
+    econstructor; econstructor; eauto.
+    (* external *)
+    simpl in INT. rewrite H2, H3 in INT.
+    exploit external_call_receptive; eauto. intros [vres2 [m2 EC2]].
+    eexists. eapply exec_step_external; eauto.
+  - red; intros; inv H; simpl; try lia; ss; des_ifs.
+    eapply external_call_trace_length; eauto.
+    eapply external_call_trace_length; eauto.
+Qed.
+
+Lemma initial_state_determ: forall p st0 st1,
+    Smallstep.initial_state (semantics p) st0 ->
+    Smallstep.initial_state (semantics p) st1 -> st0 = st1.
+Proof. intros. inv H; inv H0. subst ge0 ge. Eq. Qed.
+
+Theorem final_state_determ: forall p st0 retv,
+    Smallstep.final_state (semantics p) st0 retv ->
+    Dfinal_state (semantics p) st0 retv.
+Proof.
+  econstructor; eauto.
+  - intros. inv FINAL0; inv FINAL1; Eq; auto.
+  - red. unfold not. intros. inv FINAL; inv H0; simpl in *; Eq.
+Qed.
+
+Ltac DStep_tac := esplit; [(eapply semantics_determinate_at; simpl in *; eauto)|].
+
+Require Import Memory.
+
+Section FUNCPERM.
+
+Variable p: program.  
+Let ge := Genv.globalenv p.
+Let sem := Asm.semantics p.
+
+Definition mem_char (m: mem) :=
+  forall b fd, Genv.find_funct_ptr ge b = Some fd ->
+  Mem.perm m b 0 Max Nonempty
+  /\ (forall ofs k p, Mem.perm m b ofs k p -> ofs = 0 /\ p = Nonempty).
+
+Lemma capture_mem_char m b addr m'
+    (CHAR: mem_char m)
+    (CAP: Mem.capture m b addr m'):
+  mem_char m'.
+Proof.
+  unfold mem_char in *. i. exploit CHAR; eauto. i. des. split.
+  - erewrite <- Genv.capture_same_perm; eauto.
+  - i. eapply H1. erewrite Genv.capture_same_perm; eauto.
+Qed.
+
+Lemma capture_list_mem_char m bs addrs m'
+    (CHAR: mem_char m)
+    (CAP: Mem.capture_list m bs addrs m'):
+  mem_char m'.
+Proof.
+  ginduction bs; i; [inv CAP; eauto|].
+  inv CAP. hexploit capture_mem_char; eauto.
+Qed.
+
+Definition state_char (s: state) : Prop :=
+  mem_char (state_mem s).
+
+Lemma init_mem_mem_char m
+    (INIT: Genv.init_mem p = Some m):
+  mem_char m.
+Proof.
+  r. i. exploit Genv.init_mem_characterization_2; eauto. i. des; split; eauto.
+  eapply Mem.perm_max. eauto.
+Qed.
+
+Lemma initial_state_char s
+    (INIT: initial_state p s):
+  state_char s.
+Proof.
+  inv INIT. ss. r. ss. eapply init_mem_mem_char; eauto.
+Qed.
+
+Lemma glob_capture_char
+    s s'
+    (CHAR: state_char s)
+    (GCAP: glob_capture p s s'):
+  state_char s'.
+Proof.
+  inv GCAP. inv CAPTURE. unfold state_char in *. ss.
+  eapply capture_list_mem_char; eauto.
+Qed.
+
+(* move to Memory.v *)
+Lemma store_mem_char
+    chunk m b ofs v' m'
+    (CHAR: mem_char m)
+    (STORE: Mem.store chunk m b ofs v' = Some m'):
+  mem_char m'.
+Proof.
+  r. i. exploit CHAR; eauto. i. des. split.
+  { des_ifs; eapply Mem.perm_store_1; eauto. }
+  i. des_ifs; eapply H1; eapply Mem.perm_store_2; eauto.
+Qed.
+
+Lemma storev_mem_char
+    chunk m v v' m'
+    (CHAR: mem_char m)
+    (STORE: Mem.storev chunk m v v' = Some m'):
+  mem_char m'.
+Proof.
+  unfold Mem.storev in STORE. des_ifs; eapply store_mem_char; eauto.
+Qed.
+
+Lemma alloc_mem_char
+    m lo hi m' b
+    (CHAR: mem_char m)
+    (ALLOC: Mem.alloc m lo hi = (m', b)):
+  mem_char m'.
+Proof.
+  unfold mem_char in *. i. exploit CHAR; eauto. i. des.
+  assert (b0 <> b).
+  { hexploit Mem.fresh_block_alloc; eauto. i.
+    eapply Mem.perm_valid_block in H0. ii; subst; clarify. }
+  split; [eapply Mem.perm_alloc_1; eauto|].
+  i. eapply H1. eapply Mem.perm_alloc_4; eauto.
+Qed.
+
+Lemma free_mem_char
+    m b hi m'
+    (CHAR: mem_char m)
+    (FREE: Mem.free m b 0 hi = Some m'):
+  mem_char m'.
+Proof.
+  r. i. exploit CHAR; eauto. i. des. split.
+  2:{ i. eapply H1. eapply Mem.perm_free_3; eauto. }
+  hexploit Mem.free_range_perm; eauto. intros FPERM.
+  destruct (classic (hi > 0)); cycle 1.
+  { eapply Mem.perm_free_1; eauto. }
+  destruct (peq b0 b); cycle 1.
+  { eapply Mem.perm_free_1; eauto. }
+  subst. specialize (FPERM 0). exploit FPERM; try lia. i.
+  eapply H1 in H3. des; clarify.
+Qed.
+
+Lemma state_char_preservation
+    s s' tr
+    (CHAR: state_char s)
+    (STEP: step ge s tr s'):
+  state_char s'.
+Proof.
+  Local Transparent Mem.free.
+  inv STEP; ss; unfold state_char in *; ss.
+  - destruct i; ss; clarify; eauto; try by (unfold exec_load in *; des_ifs).
+    + unfold exec_store in *. des_ifs. eapply storev_mem_char; eauto.
+    + unfold exec_store in *. des_ifs. eapply storev_mem_char; eauto.
+    + unfold exec_store in *. des_ifs. eapply storev_mem_char; eauto.
+    + unfold exec_store in *. des_ifs. eapply storev_mem_char; eauto.
+    + unfold exec_store in *. des_ifs. eapply storev_mem_char; eauto.
+    + unfold exec_store in *. des_ifs. eapply storev_mem_char; eauto.
+    + unfold exec_store in *. des_ifs. eapply storev_mem_char; eauto.
+    + unfold exec_store in *. des_ifs. eapply storev_mem_char; eauto.
+    + unfold goto_label in H2. des_ifs.
+    + unfold goto_label in H2. des_ifs.
+    + unfold goto_label in H2. des_ifs.
+    + unfold goto_label in H2. des_ifs.
+    + unfold exec_store in *. des_ifs. eapply storev_mem_char; eauto.
+    + unfold exec_store in *. des_ifs. eapply storev_mem_char; eauto.
+    + des_ifs.
+      eapply store_mem_char; try eapply Heq1.
+      eapply store_mem_char; try eapply Heq0.
+      eapply alloc_mem_char; eauto.
+    + des_ifs. eapply free_mem_char; eauto.
+  - r. i. exploit CHAR; eauto. i. des. split; cycle 1.
+    { i. eapply H6. instantiate (1:=Max).
+      eapply external_call_max_perm; eauto.
+      { eapply Mem.perm_valid_block; eauto. }
+      eapply Mem.perm_max; eauto. }
+    assert (NM: nonempty_perm m b0 0).
+    { r. split; eauto. i. exploit H6; eauto. i. des; eauto. }
+    exploit ec_nonempty; eauto.
+    { eapply external_call_common_spec. }
+    i. r in H7. des; eauto.
+  - r. i. exploit CHAR; eauto. i. des. split; cycle 1.
+    { i. eapply H5. instantiate (1:=Max).
+      eapply external_call_max_perm; eauto.
+      { eapply Mem.perm_valid_block; eauto. }
+      eapply Mem.perm_max; eauto. }
+    assert (NM: nonempty_perm m b0 0).
+    { r. split; eauto. i. exploit H5; eauto. i. des; eauto. }
+    exploit ec_nonempty; eauto.
+    { eapply external_call_common_spec. }
+    i. r in H6. des; eauto.
+Qed.
+
+Lemma state_char_star
+    s s' tr
+    (CHAR: state_char s)
+    (STEP: star step ge s tr s'):
+  state_char s'.
+Proof.
+  ginduction STEP; eauto. i. eapply IHSTEP. eapply state_char_preservation; eauto.
+Qed.
+
+Lemma state_char_plus
+    s s' tr
+    (CHAR: state_char s)
+    (STEP: plus step ge s tr s'):
+  state_char s'.
+Proof.
+  inv STEP. eapply state_char_star; try eapply H0; eauto. eapply state_char_preservation; eauto.
+Qed.
+
+Lemma state_char_dstar
+    s s' tr
+    (CHAR: state_char s)
+    (STEP: DStar sem s tr s'):
+  state_char s'.
+Proof.
+  ginduction STEP; eauto. i. eapply IHSTEP. inv H. eapply state_char_preservation; eauto.
+Qed.
+
+Lemma state_char_dplus
+    s s' tr
+    (CHAR: state_char s)
+    (STEP: DPlus sem s tr s'):
+  state_char s'.
+Proof.
+  inv STEP. eapply state_char_dstar; try eapply H0; eauto.
+  inv H. eapply state_char_preservation; eauto.
+Qed.
+
+End FUNCPERM.
diff --git a/x86/Asmexpand.ml b/x86/Asmexpand.ml
index d757d7c2..e0a2ea8a 100644
--- a/x86/Asmexpand.ml
+++ b/x86/Asmexpand.ml
@@ -203,6 +203,16 @@ let expand_builtin_vload chunk args res =
   | _ ->
      assert false
 
+let expand_builtin_capture args res =
+  let dst = (match res with
+             | (BR (IR r)) -> r
+             | _ -> assert false)
+  in
+  match args with
+  | [(BA (IR src))] -> emit (Pmov_rr (dst, src))
+  | [(BA_long n)] -> emit (Pmovq_ri (dst, n))
+  | _ -> assert false
+
 let expand_builtin_vstore_common chunk addr src tmp =
   match chunk, src with
   | (Mint8signed | Mint8unsigned), BA(IR src) ->
@@ -612,6 +622,8 @@ let expand_instruction instr =
           expand_builtin_vstore chunk args
        | EF_memcpy(sz, al) ->
           expand_builtin_memcpy (Z.to_int sz) (Z.to_int al) args
+       | EF_capture ->
+          expand_builtin_capture args res
        | EF_annot_val(kind,txt, targ) ->
           expand_annot_val kind txt targ args res
        | EF_annot _ | EF_debug _ | EF_inline_asm _ ->
diff --git a/x86/Asmgen.v b/x86/Asmgen.v
index 73e3263e..0140c5cc 100644
--- a/x86/Asmgen.v
+++ b/x86/Asmgen.v
@@ -477,6 +477,9 @@ Definition transl_op
   | Osubl, a1 :: a2 :: nil =>
       assertion (mreg_eq a1 res);
       do r <- ireg_of res; do r2 <- ireg_of a2; OK (Psubq_rr r r2 :: k)
+  | Opsub, a1 :: a2 :: nil =>
+      assertion (mreg_eq a1 res);
+      do r <- ireg_of res; do r2 <- ireg_of a2; OK (Psubp_rr r r2 :: k)
   | Omull, a1 :: a2 :: nil =>
       assertion (mreg_eq a1 res);
       do r <- ireg_of res; do r2 <- ireg_of a2; OK (Pimulq_rr r r2 :: k)
diff --git a/x86/Asmgenproof.v b/x86/Asmgenproof.v
index 67c42b2b..0d45b3a2 100644
--- a/x86/Asmgenproof.v
+++ b/x86/Asmgenproof.v
@@ -14,9 +14,11 @@
 
 Require Import Coqlib Errors.
 Require Import Integers Floats AST Linking.
+Require Import sflib CoqlibC Simulation PointerOp MachD AsmD Classical.
 Require Import Values Memory Events Globalenvs Smallstep.
 Require Import Op Locations Mach Conventions Asm.
 Require Import Asmgen Asmgenproof0 Asmgenproof1.
+From Paco Require Import paco.
 
 Definition match_prog (p: Mach.program) (tp: Asm.program) :=
   match_program (fun _ f tf => transf_fundef f = OK tf) eq p tp.
@@ -35,6 +37,9 @@ Hypothesis TRANSF: match_prog prog tprog.
 Let ge := Genv.globalenv prog.
 Let tge := Genv.globalenv tprog.
 
+Let sem := Mach.semantics return_address_offset prog.
+Let tsem := Asm.semantics tprog.
+
 Lemma symbols_preserved:
   forall (s: ident), Genv.find_symbol tge s = Genv.find_symbol ge s.
 Proof (Genv.find_symbol_match TRANSF).
@@ -73,8 +78,8 @@ Qed.
 Lemma exec_straight_exec:
   forall fb f c ep tf tc c' rs m rs' m',
   transl_code_at_pc ge (rs PC) fb f c ep tf tc ->
-  exec_straight tge tf tc rs m c' rs' m' ->
-  plus step tge (State rs m) E0 (State rs' m').
+  exec_straight tprog tf tc rs m c' rs' m' ->
+  DPlus tsem (State rs m) E0 (State rs' m').
 Proof.
   intros. inv H.
   eapply exec_straight_steps_1; eauto.
@@ -86,7 +91,7 @@ Lemma exec_straight_at:
   forall fb f c ep tf tc c' ep' tc' rs m rs' m',
   transl_code_at_pc ge (rs PC) fb f c ep tf tc ->
   transl_code f c' ep' = OK tc' ->
-  exec_straight tge tf tc rs m tc' rs' m' ->
+  exec_straight tprog tf tc rs m tc' rs' m' ->
   transl_code_at_pc ge (rs' PC) fb f c' ep' tf tc'.
 Proof.
   intros. inv H.
@@ -340,17 +345,24 @@ Qed.
 (** Existence of return addresses *)
 
 Lemma return_address_exists:
-  forall f sg ros c, is_tail (Mcall sg ros :: c) f.(Mach.fn_code) ->
+  forall f sg ros c v (FUNCT: Genv.find_funct (Genv.globalenv prog) v = Some (Internal f)), is_tail (Mcall sg ros :: c) f.(Mach.fn_code) ->
   exists ra, return_address_offset f c ra.
 Proof.
+  intros.
+  assert(TF: exists tf, transf_function f = OK tf).
+  { inv TRANSF.
+    exploit Genv.find_funct_inversion; eauto. i; des.
+    eapply list_forall2_in_left in H0; eauto.
+    des. inv H4. ss. clarify. inv H6. ss. monadInv H8. esplits; eauto.
+  } des.
   intros. eapply Asmgenproof0.return_address_exists; eauto.
 - intros. exploit transl_instr_label; eauto.
   destruct i; try (intros [A B]; apply A). intros. subst c0. repeat constructor.
-- intros. monadInv H0.
+- intros. monadInv TF.
   destruct (zlt Ptrofs.max_unsigned (list_length_z (fn_code x))); inv EQ0.
   monadInv EQ. rewrite transl_code'_transl_code in EQ0.
   exists x; exists true; split; auto. unfold fn_code. repeat constructor.
-- exact transf_function_no_overflow.
+- eapply transf_function_no_overflow; eauto.
 Qed.
 
 (** * Proof of semantic preservation *)
@@ -408,11 +420,11 @@ Lemma exec_straight_steps:
   transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc ->
   (forall k c (TR: transl_instr f i ep k = OK c),
    exists rs2,
-       exec_straight tge tf c rs1 m1' k rs2 m2'
+       exec_straight tprog tf c rs1 m1' k rs2 m2'
     /\ agree ms2 sp rs2
     /\ (it1_is_parent ep i = true -> rs2#RAX = parent_sp s)) ->
   exists st',
-  plus step tge (State rs1 m1') E0 st' /\
+  DPlus tsem (State rs1 m1') E0 st' /\
   match_states (Mach.State s fb sp c ms2 m2) st'.
 Proof.
   intros. inversion H2. subst. monadInv H7.
@@ -432,11 +444,11 @@ Lemma exec_straight_steps_goto:
   it1_is_parent ep i = false ->
   (forall k c (TR: transl_instr f i ep k = OK c),
    exists jmp, exists k', exists rs2,
-       exec_straight tge tf c rs1 m1' (jmp :: k') rs2 m2'
+       exec_straight tprog tf c rs1 m1' (jmp :: k') rs2 m2'
     /\ agree ms2 sp rs2
     /\ exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') ->
   exists st',
-  plus step tge (State rs1 m1') E0 st' /\
+  DPlus tsem (State rs1 m1') E0 st' /\
   match_states (Mach.State s fb sp c' ms2 m2) st'.
 Proof.
   intros. inversion H3. subst. monadInv H9.
@@ -450,8 +462,11 @@ Proof.
   exists (State rs3 m2'); split.
   eapply plus_right'.
   eapply exec_straight_steps_1; eauto.
+  DStep_tac. rewrite PC2. fold tge. rewrite FN. erewrite find_instr_tail; eauto.
+  destruct jmp; ss. rewrite <- C in GOTO; inv GOTO.
   econstructor; eauto.
   eapply find_instr_tail. eauto.
+  ss. fold tge.
   rewrite C. eexact GOTO.
   traceEq.
   econstructor; eauto.
@@ -477,11 +492,12 @@ Definition measure (s: Mach.state) : nat :=
 (** This is the simulation diagram.  We prove it by case analysis on the Mach transition. *)
 
 Theorem step_simulation:
-  forall S1 t S2, Mach.step return_address_offset ge S1 t S2 ->
-  forall S1' (MS: match_states S1 S1'),
-  (exists S2', plus step tge S1' t S2' /\ match_states S2 S2')
+  forall S1 t S2, IStep sem S1 t S2 ->
+  forall S1' (TCHAR: state_char tprog S1') (MS: match_states S1 S1'),
+  (exists S2', DPlus tsem S1' t S2' /\ match_states S2 S2')
   \/ (measure S2 < measure S1 /\ t = E0 /\ match_states S2 S1')%nat.
 Proof.
+destruct 1. generalize dependent S2. rename H into INT.  
   induction 1; intros; inv MS.
 
 - (* Mlabel *)
@@ -513,6 +529,7 @@ Local Transparent destroyed_by_setstack.
   destruct ty; simpl; intuition congruence.
 
 - (* Mgetparam *)
+  ss. fold ge in H.  
   assert (f0 = f) by congruence; subst f0.
   unfold load_stack in *.
   exploit Mem.loadv_extends. eauto. eexact H0. auto.
@@ -544,9 +561,9 @@ Opaque loadind.
   simpl; intros. rewrite U; auto.
 
 - (* Mop *)
-  assert (eval_operation tge sp op rs##args m = Some v).
-    rewrite <- H. apply eval_operation_preserved. exact symbols_preserved.
-  exploit eval_operation_lessdef. eapply preg_vals; eauto. eauto. eexact H0.
+  assert (eval_operation_wrapper tge sp op rs##args m = Some v).
+    rewrite <- H. apply eval_operation_wrapper_preserved. exact symbols_preserved.
+  exploit eval_operation_wrapper_lessdef. eapply preg_vals; eauto. eauto. eexact H0.
   intros [v' [A B]]. rewrite (sp_val _ _ _ AG) in A.
   left; eapply exec_straight_steps; eauto; intros. simpl in TR.
   exploit transl_op_correct; eauto. intros [rs2 [P [Q R]]].
@@ -582,39 +599,47 @@ Opaque loadind.
   simpl; congruence.
 
 - (* Mcall *)
+  ss. fold ge in H0.
   assert (f0 = f) by congruence.  subst f0.
   inv AT.
   assert (NOOV: list_length_z tf.(fn_code) <= Ptrofs.max_unsigned).
     eapply transf_function_no_overflow; eauto.
   destruct ros as [rf|fid]; simpl in H; monadInv H5.
 + (* Indirect call *)
-  assert (rs rf = Vptr f' Ptrofs.zero).
-    destruct (rs rf); try discriminate.
-    revert H; predSpec Ptrofs.eq Ptrofs.eq_spec i Ptrofs.zero; intros; congruence.
-  assert (rs0 x0 = Vptr f' Ptrofs.zero).
-    exploit ireg_val; eauto. rewrite H5; intros LD; inv LD; auto.
+  assert (Mem.to_ptr (rs rf) m = Some (Vptr f' Ptrofs.zero)).
+  { destruct (rs rf); ss; try discriminate; des_ifs_safe.
+    2:{ eapply Ptrofs.same_if_eq in Heq; eauto. i. subst; eauto. }
+    ss. des_ifs. eapply Ptrofs.same_if_eq in Heq2. rewrite Heq2. eauto. }
+  assert (find_function_ptr (Genv.globalenv prog) (inl (Vptr f' Ptrofs.zero)) rs = Some f') by ss.
+  clear H. rename H7 into H.
+  assert (Mem.to_ptr (rs0 x0) m' = Some (Vptr f' Ptrofs.zero)).
+    exploit ireg_val; eauto. i. eapply Mem.to_ptr_extends; eauto.
   generalize (code_tail_next_int _ _ _ _ NOOV H6). intro CT1.
   assert (TCA: transl_code_at_pc ge (Vptr fb (Ptrofs.add ofs Ptrofs.one)) fb f c false tf x).
     econstructor; eauto.
   exploit return_address_offset_correct; eauto. intros; subst ra.
   left; econstructor; split.
-  apply plus_one. eapply exec_step_internal. eauto.
+  apply plus_one. DStep_tac. exploit functions_transl; eauto. intros.
+  rewrite <- H2. fold tge. rewrite H8. erewrite find_instr_tail; eauto. ss.
+  eapply exec_step_internal. eauto.
   eapply functions_transl; eauto. eapply find_instr_tail; eauto.
   simpl. eauto.
   econstructor; eauto.
   econstructor; eauto.
   eapply agree_sp_def; eauto.
   simpl. eapply agree_exten; eauto. intros. Simplifs.
-  Simplifs. rewrite <- H2. auto.
+  Simplifs. unfold to_ptr. rewrite H7. eauto. rewrite <- H2. auto.
 + (* Direct call *)
   generalize (code_tail_next_int _ _ _ _ NOOV H6). intro CT1.
   assert (TCA: transl_code_at_pc ge (Vptr fb (Ptrofs.add ofs Ptrofs.one)) fb f c false tf x).
     econstructor; eauto.
   exploit return_address_offset_correct; eauto. intros; subst ra.
   left; econstructor; split.
-  apply plus_one. eapply exec_step_internal. eauto.
+  apply plus_one. DStep_tac. exploit functions_transl; eauto. intros.
+  rewrite <- H2. fold tge. rewrite H5. erewrite find_instr_tail; eauto. ss.
+  eapply exec_step_internal. eauto.
   eapply functions_transl; eauto. eapply find_instr_tail; eauto.
-  simpl. unfold Genv.symbol_address. rewrite symbols_preserved. rewrite H. eauto.
+  simpl. unfold Genv.symbol_address. rewrite symbols_preserved. unfold ge. rewrite H. eauto.
   econstructor; eauto.
   econstructor; eauto.
   eapply agree_sp_def; eauto.
@@ -622,6 +647,7 @@ Opaque loadind.
   Simplifs. rewrite <- H2. auto.
 
 - (* Mtailcall *)
+  simpl in *. fold ge in H0.
   assert (f0 = f) by congruence.  subst f0.
   inv AT.
   assert (NOOV: list_length_z tf.(fn_code) <= Ptrofs.max_unsigned).
@@ -632,45 +658,87 @@ Opaque loadind.
   exploit lessdef_parent_sp; eauto. intros. subst parent'. clear B.
   exploit lessdef_parent_ra; eauto. intros. subst ra'. clear D.
   exploit Mem.free_parallel_extends; eauto. intros [m2' [E F]].
+  exploit functions_transl; eauto. intros TFUN. unfold tge in TFUN.
+  assert (NEXT: nextinstr (rs0 # RSP <- (parent_sp s)) # RA <- (parent_ra s) PC = Vptr fb (Ptrofs.add ofs Ptrofs.one)).
+  { transitivity (Val.offset_ptr rs0#PC Ptrofs.one). auto. rewrite <- H4. simpl. eauto. }  
   destruct ros as [rf|fid]; simpl in H; monadInv H7.
 + (* Indirect call *)
-  assert (rs rf = Vptr f' Ptrofs.zero).
-    destruct (rs rf); try discriminate.
-    revert H; predSpec Ptrofs.eq Ptrofs.eq_spec i Ptrofs.zero; intros; congruence.
-  assert (rs0 x0 = Vptr f' Ptrofs.zero).
-    exploit ireg_val; eauto. rewrite H7; intros LD; inv LD; auto.
+  assert (Mem.to_ptr (rs rf) m = Some (Vptr f' Ptrofs.zero)).
+  { destruct (rs rf); ss; try discriminate; des_ifs_safe.
+    2:{ eapply Ptrofs.same_if_eq in Heq; eauto. i. subst; eauto. }
+    ss. des_ifs. eapply Ptrofs.same_if_eq in Heq2. rewrite Heq2. eauto. }
+  assert (Mem.to_ptr (rs0 x0) m'0 = Some (Vptr f' Ptrofs.zero)).
+  { exploit ireg_val; eauto. i. eapply Mem.to_ptr_extends; eauto. }
   generalize (code_tail_next_int _ _ _ _ NOOV H8). intro CT1.
   left; econstructor; split.
-  eapply plus_left. eapply exec_step_internal. eauto.
+  eapply plus_left. DStep_tac. exploit functions_transl; eauto. intros.
+  rewrite <- H4. fold tge. rewrite H10. erewrite find_instr_tail; eauto. ss.
+  eapply exec_step_internal. eauto.
   eapply functions_transl; eauto. eapply find_instr_tail; eauto.
   simpl. replace (chunk_of_type Tptr) with Mptr in * by (unfold Tptr, Mptr; destruct Archi.ptr64; auto).
   rewrite C. rewrite A. rewrite <- (sp_val _ _ _ AG). rewrite E. eauto.
-  apply star_one. eapply exec_step_internal.
+  apply star_one. DStep_tac. rewrite NEXT, TFUN. erewrite find_instr_tail; eauto. ss. eapply exec_step_internal.
   transitivity (Val.offset_ptr rs0#PC Ptrofs.one). auto. rewrite <- H4. simpl. eauto.
   eapply functions_transl; eauto. eapply find_instr_tail; eauto.
   simpl. eauto. traceEq.
   econstructor; eauto.
   apply agree_set_other; auto. apply agree_nextinstr. apply agree_set_other; auto.
   eapply agree_change_sp; eauto. eapply parent_sp_def; eauto.
-  Simplifs. rewrite Pregmap.gso; auto.
-  generalize (preg_of_not_SP rf). rewrite (ireg_of_eq _ _ EQ1). congruence.
+  Simplifs.
+  assert ((nextinstr (rs0 # RSP <- (parent_sp s)) # RA <- (parent_ra s) x0) = rs0 x0).
+  { Simplifs. rewrite Pregmap.gso; auto.
+    generalize (preg_of_not_SP rf). rewrite (ireg_of_eq _ _ EQ1). congruence. }
+  rewrite H10.
+  assert (Mem.to_ptr (rs0 x0) m2' = Some (Vptr f' Ptrofs.zero)).
+  { destruct (rs0 x0); try by ss. simpl in H9.
+    destruct Archi.ptr64 eqn:SF; try by ss.
+    destruct (Int64.eq i Int64.zero) eqn:NULL; try by ss.
+    destruct (Mem.denormalize (Int64.unsigned i) m'0) eqn:DENO; try by ss.
+    destruct p. simpl. rewrite SF, NULL.
+    assert (z = 0).
+    { eapply Mem.denormalize_info in DENO. des.
+      assert (ZERO: Ptrofs.repr z = Ptrofs.zero).
+      { eapply Ptrofs.same_if_eq. unfold Ptrofs.eq. des_ifs. }
+      rewrite <- Ptrofs.unsigned_repr; try lia.
+      rewrite <- Ptrofs.unsigned_repr at 1; try lia. rewrite ZERO. eauto. }
+    subst. inv H9.
+    assert (P2I: Mem.ptr2int f' 0 m2' = Some (Int64.unsigned i)).
+    { eapply Mem.denormalize_info in DENO. des.
+      unfold Mem.ptr2int. erewrite <- Mem.concrete_free; eauto. rewrite CONC. f_equal. lia. }
+    exploit Mem.denormalize_perm; eauto. i. des. eapply Mem.perm_implies in H9; [|eapply perm_any_N].
+    destruct (classic (fn_stacksize f > 0)); cycle 1.
+    { exploit Mem.perm_free_1; try eapply E; eauto. i.
+      exploit Mem.ptr2int_to_denormalize_max; eauto. 
+      { unfold Ptrofs.max_unsigned, Ptrofs.modulus, two_power_nat. lia. }
+      i. rewrite H13. eauto. }
+    destruct (peq f' stk).
+    { subst. hexploit Mem.free_range_perm; eauto. intros FPERM.
+      specialize (FPERM 0). exploit FPERM; try lia. i.
+      r in TCHAR. ss. r in TCHAR. exploit functions_translated; try eapply FUNCPTR; eauto. i. des.
+      eapply TCHAR in H13. i. des. eapply H15 in H12. des; clarify. }
+    exploit Mem.perm_free_1; try eapply E; eauto. i.
+    exploit Mem.ptr2int_to_denormalize_max; eauto.
+    { unfold Ptrofs.max_unsigned, Ptrofs.modulus, two_power_nat. lia. }
+    i. rewrite H13. eauto. }
+  unfold to_ptr. rewrite H11. eauto.
 + (* Direct call *)
   generalize (code_tail_next_int _ _ _ _ NOOV H8). intro CT1.
   left; econstructor; split.
-  eapply plus_left. eapply exec_step_internal. eauto.
+  eapply plus_left. DStep_tac. rewrite <- H4. rewrite TFUN. erewrite find_instr_tail; eauto. ss. eapply exec_step_internal. eauto.
   eapply functions_transl; eauto. eapply find_instr_tail; eauto.
   simpl. replace (chunk_of_type Tptr) with Mptr in * by (unfold Tptr, Mptr; destruct Archi.ptr64; auto).
   rewrite C. rewrite A. rewrite <- (sp_val _ _ _ AG). rewrite E. eauto.
-  apply star_one. eapply exec_step_internal.
+  apply star_one. DStep_tac. rewrite NEXT, TFUN. erewrite find_instr_tail; eauto. ss. eapply exec_step_internal.
   transitivity (Val.offset_ptr rs0#PC Ptrofs.one). auto. rewrite <- H4. simpl. eauto.
   eapply functions_transl; eauto. eapply find_instr_tail; eauto.
   simpl. eauto. traceEq.
   econstructor; eauto.
   apply agree_set_other; auto. apply agree_nextinstr. apply agree_set_other; auto.
   eapply agree_change_sp; eauto. eapply parent_sp_def; eauto.
-  rewrite Pregmap.gss. unfold Genv.symbol_address. rewrite symbols_preserved. rewrite H. auto.
+  rewrite Pregmap.gss. unfold Genv.symbol_address. rewrite symbols_preserved. unfold ge. rewrite H. auto.
 
 - (* Mbuiltin *)
+  unfold is_internal in INT. simpl in INT.
   inv AT. monadInv H4.
   exploit functions_transl; eauto. intro FN.
   generalize (transf_function_no_overflow _ _ H3); intro NOOV.
@@ -678,6 +746,7 @@ Opaque loadind.
   exploit external_call_mem_extends; eauto.
   intros [vres' [m2' [A [B [C D]]]]].
   left. econstructor; split. apply plus_one.
+  DStep_tac. rewrite <- H1. fold tge. rewrite FN. erewrite find_instr_tail; eauto. ss.  
   eapply exec_step_builtin. eauto. eauto.
   eapply find_instr_tail; eauto.
   erewrite <- sp_val by eauto.
@@ -698,11 +767,13 @@ Opaque loadind.
   congruence.
 
 - (* Mgoto *)
+  simpl in *. fold ge in H.  
   assert (f0 = f) by congruence. subst f0.
   inv AT. monadInv H4.
   exploit find_label_goto_label; eauto. intros [tc' [rs' [GOTO [AT2 INV]]]].
   left; exists (State rs' m'); split.
-  apply plus_one. econstructor; eauto.
+  apply plus_one. DStep_tac. rewrite <- H1. exploit functions_transl; eauto; intros.
+  unfold tge in H4. rewrite H4. erewrite find_instr_tail; eauto. ss. econstructor; eauto.
   eapply functions_transl; eauto.
   eapply find_instr_tail; eauto.
   simpl; eauto.
@@ -711,11 +782,12 @@ Opaque loadind.
   congruence.
 
 - (* Mcond true *)
+  simpl in *. fold ge in H0.  
   assert (f0 = f) by congruence. subst f0.
-  exploit eval_condition_lessdef. eapply preg_vals; eauto. eauto. eauto. intros EC.
+  exploit eval_condition_wrapper_lessdef. eapply preg_vals; eauto. eauto. eauto. intros EC.
   left; eapply exec_straight_steps_goto; eauto.
   intros. simpl in TR.
-  destruct (transl_cond_correct tge tf cond args _ _ rs0 m' TR)
+  destruct (transl_cond_correct tprog tf cond args _ _ rs0 m' TR)
   as [rs' [A [B C]]].
   rewrite EC in B. destruct B as [B _].
   destruct (testcond_for_condition cond); simpl in *.
@@ -751,9 +823,9 @@ Opaque loadind.
   simpl. rewrite TC1; rewrite TC2; auto.
 
 - (* Mcond false *)
-  exploit eval_condition_lessdef. eapply preg_vals; eauto. eauto. eauto. intros EC.
+  exploit eval_condition_wrapper_lessdef. eapply preg_vals; eauto. eauto. eauto. intros EC.
   left; eapply exec_straight_steps; eauto. intros. simpl in TR.
-  destruct (transl_cond_correct tge tf cond args _ _ rs0 m' TR)
+  destruct (transl_cond_correct tprog tf cond args _ _ rs0 m' TR)
   as [rs' [A [B C]]].
   rewrite EC in B. destruct B as [B _].
   destruct (testcond_for_condition cond); simpl in *.
@@ -786,6 +858,7 @@ Opaque loadind.
   rewrite H1; congruence.
 
 - (* Mjumptable *)
+  simpl in *. fold ge in H1.  
   assert (f0 = f) by congruence. subst f0.
   inv AT. monadInv H6.
   exploit functions_transl; eauto. intro FN.
@@ -795,7 +868,7 @@ Opaque loadind.
   intros [tc' [rs' [A [B C]]]].
   exploit ireg_val; eauto. rewrite H. intros LD; inv LD.
   left; econstructor; split.
-  apply plus_one. econstructor; eauto.
+  apply plus_one. DStep_tac. rewrite <- H3. fold tge. rewrite FN. erewrite find_instr_tail; eauto. ss. econstructor; eauto.
   eapply find_instr_tail; eauto.
   simpl. rewrite <- H9.  unfold Mach.label in H0; unfold label; rewrite H0. eexact A.
   econstructor; eauto.
@@ -805,6 +878,7 @@ Transparent destroyed_by_jumptable.
   congruence.
 
 - (* Mreturn *)
+  simpl in *. fold ge in H.  
   assert (f0 = f) by congruence. subst f0.
   inv AT.
   assert (NOOV: list_length_z tf.(fn_code) <= Ptrofs.max_unsigned).
@@ -818,11 +892,16 @@ Transparent destroyed_by_jumptable.
   exploit Mem.free_parallel_extends; eauto. intros [m2' [E F]].
   monadInv H6.
   exploit code_tail_next_int; eauto. intro CT1.
+  assert (NEXT: nextinstr (rs0 # RSP <- (parent_sp s)) # RA <- (parent_ra s) PC = Vptr fb (Ptrofs.add ofs Ptrofs.one)).
+  { transitivity (Val.offset_ptr rs0#PC Ptrofs.one). auto. rewrite <- H3. simpl. eauto. }
+  exploit functions_transl; eauto; intros TFN. unfold tge in TFN.   
   left; econstructor; split.
-  eapply plus_left. eapply exec_step_internal. eauto.
+  eapply plus_left. DStep_tac. rewrite <- H3. rewrite TFN. erewrite find_instr_tail; eauto. ss.
+  eapply exec_step_internal. eauto.
   eapply functions_transl; eauto. eapply find_instr_tail; eauto.
   simpl. rewrite C. rewrite A. rewrite <- (sp_val _ _ _ AG). rewrite E. eauto.
-  apply star_one. eapply exec_step_internal.
+  apply star_one. DStep_tac. rewrite NEXT, TFN. erewrite find_instr_tail; eauto. ss.
+  eapply exec_step_internal.
   transitivity (Val.offset_ptr rs0#PC Ptrofs.one). auto. rewrite <- H3. simpl. eauto.
   eapply functions_transl; eauto. eapply find_instr_tail; eauto.
   simpl. eauto. traceEq.
@@ -842,8 +921,9 @@ Transparent destroyed_by_jumptable.
   intros [m2' [F G]].
   exploit Mem.storev_extends. eexact G. eexact H2. eauto. eauto.
   intros [m3' [P Q]].
+  exploit functions_transl; eauto; intros TFN. unfold tge in TFN.  
   left; econstructor; split.
-  apply plus_one. econstructor; eauto.
+  apply plus_one. DStep_tac. rewrite ATPC, TFN. ss. econstructor; eauto.
   simpl. rewrite Ptrofs.unsigned_zero. simpl. eauto.
   simpl. rewrite C. simpl in F, P.
   replace (chunk_of_type Tptr) with Mptr in F, P by (unfold Tptr, Mptr; destruct Archi.ptr64; auto).
@@ -862,6 +942,7 @@ Transparent destroyed_at_function_entry.
   intros. Simplifs. eapply agree_sp; eauto.
 
 - (* external function *)
+  unfold is_internal in INT. simpl in INT, H. rewrite H in INT.  
   exploit functions_translated; eauto.
   intros [tf [A B]]. simpl in B. inv B.
   exploit extcall_arguments_match; eauto.
@@ -869,7 +950,7 @@ Transparent destroyed_at_function_entry.
   exploit external_call_mem_extends; eauto.
   intros [res' [m2' [P [Q [R S]]]]].
   left; econstructor; split.
-  apply plus_one. eapply exec_step_external; eauto.
+  apply plus_one. DStep_tac. fold tge. rewrite ATPC, A. auto. eapply exec_step_external; eauto.
   eapply external_call_symbols_preserved; eauto. apply senv_preserved.
   econstructor; eauto.
   unfold loc_external_result. apply agree_set_other; auto. apply agree_set_pair; auto.
@@ -878,7 +959,7 @@ Transparent destroyed_at_function_entry.
 - (* return *)
   inv STACKS. simpl in *.
   right. split. lia. split. auto.
-  econstructor; eauto. rewrite ATPC; eauto. congruence.
+  econstructor; eauto. rewrite ATPC; eauto. congruence.  
 Qed.
 
 Lemma transf_initial_states:
@@ -914,14 +995,188 @@ Proof.
   generalize (preg_val _ _ _ AX AG). rewrite H2. intros LD; inv LD. auto.
 Qed.
 
+Lemma match_states_bsim
+    s1 (EXT: Mach.is_external ge s1)
+    s2 t s2' (STEPTGT: Step tsem s2 t s2')
+    (MATCH: match_states s1 s2)
+    (SAFESRC: safe sem s1) :
+  (exists s1', Step sem s1 t s1' /\ match_states s1' s2')
+\/ (~ trace_intact t /\ exists s1'' t', Star sem s1 t' s1'' /\ exists tl, t' = (trace_cut_pterm t) ** tl).
+Proof.
+  assert (SEQUIV: Senv.equiv tge ge) by (symmetry; apply senv_preserved).
+  unfold safe in SAFESRC. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify.
+  { inv SAFESRC. inv MATCH. inv STEPTGT; clarify. }
+  unfold is_external in *.
+  inv MATCH; des_ifs.
+  (* builtin *)
+  - i. ss. destruct c; try inversion EXT. destruct i; try inversion EXT.
+    inv AT. monadInv H2.
+    inv STEPTGT; cycle 2.
+    { rewrite <- H in H5. clarify. exploit functions_transl; try eapply H1. eauto. i.
+      fold tge in H6. Eq. }
+    { rewrite <- H in H5. clarify. exploit find_instr_tail; eauto. i.
+      exploit functions_transl; try eapply H1. eauto. i.
+      fold tge in H6. Eq. ss. }
+    inv SAFESRC.
+    exploit functions_transl; eauto. intro FN.
+    generalize (transf_function_no_overflow _ _ H1); intro NOOV.
+    exploit builtin_args_match; eauto. intros [vargs' [P Q]].
+    rewrite <- H in H5. clarify.
+    exploit find_instr_tail. eapply H3. i. fold tge in H6. Eq.
+    determ_tac eval_builtin_args_preserved.
+    fold ge in P. inversion AG. subst.
+    exploit eval_builtin_args_determ. eapply P. eapply H2. i. subst.
+    exploit external_call_symbols_preserved; try eapply H9. eapply SEQUIV. i.
+    exploit external_call_mem_extends_backward; try eapply MEXT; eauto. i. des.
+    + left. esplits; eauto.
+      * econs; eauto.
+      * econstructor; eauto.
+        instantiate (2 := tf); instantiate (1 := x).
+        unfold nextinstr_nf, nextinstr. rewrite Pregmap.gss.
+        rewrite undef_regs_other. rewrite set_res_other. rewrite undef_regs_other_2.
+        rewrite <- H. simpl. econstructor; eauto.
+        eapply code_tail_next_int; eauto.
+        rewrite preg_notin_charact. intros. auto with asmgen.
+        auto with asmgen.
+        simpl; intros. intuition congruence.
+        apply agree_nextinstr_nf. eapply agree_set_res; auto.
+        eapply agree_undef_regs; eauto. intros; apply undef_regs_other_2; auto.
+        congruence.
+    + exploit UBSRC; eauto. clarify.
+    + right. esplits; eauto. eapply star_one. econs; eauto.
+  (* external *)
+  - ss. des_ifs.
+    inv STEPTGT; ss; Eq; clarify.
+    { exploit functions_translated; try eapply Heq. i. des. fold tge in H2. Eq. ss. }
+    { exploit functions_translated; try eapply Heq. i. des. fold tge in H2. Eq. ss. }
+    inv SAFESRC; clarify.
+    { exploit functions_translated; try eapply H6. i. des. fold tge in H2. Eq. monadInv H0. }
+    exploit functions_translated; eauto.
+    intros [tf [A B]]. simpl in B. inv B.
+    exploit extcall_arguments_match; eauto.
+    intros [args' [C D]].
+    fold ge in H6, H10. fold tge in H2. Eq.
+    exploit external_call_mem_extends_backward; try eapply MEXT; eauto.
+    exploit functions_translated. eapply Heq. i. des. inv H0.
+    determ_tac Asm.extcall_arguments_determ. eauto. i. des.
+    + left. esplits; eauto.
+      * econs; eauto. eapply external_call_symbols_preserved; eauto.
+      * econstructor; eauto.
+        unfold loc_external_result. apply agree_set_other; auto. apply agree_set_pair; auto.
+        apply agree_undef_caller_save_regs; auto.
+    + exploit UBSRC; eauto.
+      eapply external_call_symbols_preserved; eauto. eapply senv_preserved. clarify.
+    + right. esplits; eauto. eapply star_one. econs; eauto. eapply external_call_symbols_preserved; eauto.
+Qed.
+
+Lemma match_states_xsim st_src0 st_tgt0 gmtgt
+    (TCHAR: state_char tprog st_tgt0)
+    (MATCH: match_states st_src0 st_tgt0) :
+  xsim sem tsem gmtgt lt (measure st_src0) st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold.
+  destruct (classic (Mach.is_external ge st_src0)); cycle 1; rename H into EXT.
+  (* internal *)
+  - left. econs. econs.
+    + i. exploit step_simulation; eauto. i. des.
+      * esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl| |].
+        left. esplits; eauto. eapply MachD.semantics_receptive_at; auto.
+        right. eapply CIH; eauto. eapply state_char_dplus; eauto.
+      * esplits; eauto. eapply tr_rel_refl. eapply ev_rel_refl.
+    + i. exploit transf_final_states; eauto. i. eapply final_state_determ; eauto.
+  (* external *)
+  - right. econs. i. econs.
+    + i. exploit match_states_bsim; eauto. i. des.
+      * left. esplits; eauto; [eapply tr_rel_refl; eapply ev_rel_refl| |].
+        { left. eapply plus_one. eauto. }
+        right. eapply CIH; eauto. eapply state_char_preservation; eauto.
+      * right. esplits; eauto. subst. eapply tr_rel_refl. eapply ev_rel_refl.
+    + i. inversion FINALTGT; inv MATCH; ss; des_ifs; clarify; [|Eq].
+      { inv AT. rewrite H in H1. inv H1. }
+    + i. specialize (SAFESRC _ (star_refl _ _ _)). des; cycle 2; clarify; [inv SAFESRC; ss|].
+      right. inv MATCH; ss; des_ifs; inv SAFESRC; unfold ge in *; clarify.
+      (* state *)
+      * inv AT. monadInv H2.
+        exploit functions_transl; eauto. intro FN.
+        generalize (transf_function_no_overflow _ _ H1); intro NOOV.
+        exploit builtin_args_match; eauto. intros [vargs' [P Q]].
+        exploit external_call_mem_extends_backward_progress; eauto. i. des.
+        exploit external_call_symbols_preserved. apply senv_preserved. eauto. i.
+        eapply find_instr_tail in H3.
+        inv AG. exploit eval_builtin_args_preserved; try eapply P. eapply senv_preserved. i.
+        esplits. eapply exec_step_builtin; eauto. 
+      (* exnteral call *)
+      * exploit functions_translated; eauto.
+        intros [tf [A B]]. simpl in B. inv B.
+        exploit extcall_arguments_match; eauto.
+        intros [args' [C D]].
+        exploit external_call_symbols_preserved. apply senv_preserved. eauto. i.
+        exploit external_call_mem_extends_backward_progress; eauto.
+        fold ge in H3. Eq. ss. i. des.
+        esplits. eapply exec_step_external; eauto.
+Qed.
+
+Lemma non_static_equiv l:
+  Genv.non_static_glob (Genv.globalenv prog) l = Genv.non_static_glob (Genv.globalenv tprog) l.
+Proof.
+  Local Transparent ge tge.
+  induction l; ss.
+  specialize senv_preserved. ss. i. inv H. inv H1. unfold ge, tge, fundef in *.
+  specialize (H a). unfold Senv.public_symbol in H. ss. erewrite H.
+  specialize (H0 a). rewrite <- H0. erewrite IHl; eauto.
+Qed.
+
+Lemma same_public: prog_public prog = prog_public tprog.
+Proof. inv TRANSF. des; eauto. Qed.
+
+Lemma transf_initial_capture S1 S2 S2'
+    (INITSRC: Mach.initial_state prog S1)
+    (INITTGT: Asm.initial_state tprog S2)
+    (MATCH: match_states S1 S2)
+    (CAPTGT: Asm.glob_capture tprog S2 S2'):
+  exists S1', Mach.glob_capture prog S1 S1'
+  /\ match_states S1' S2'
+  /\ gm_improves (Mach.concrete_snapshot ge S1') (concrete_snapshot tge S2').
+Proof.
+  specialize senv_preserved. intros SENVEQ.
+  inv CAPTGT. ss. rename m' into m2'.
+  rewrite Genv.globalenv_public in CAPTURE. erewrite <- same_public in CAPTURE; eauto.
+  inv MATCH; try by inv INITSRC.
+  exploit non_static_equiv. instantiate (1:=AST.prog_public prog). intros EQUIV.
+  assert (exists m1', Genv.capture_init_mem m0 (Genv.non_static_glob (Genv.globalenv prog) (AST.prog_public prog)) m1'
+               /\ Mem.extends m1' m2').
+  { clear INITSRC INITTGT. rewrite <- EQUIV in CAPTURE. clear EQUIV. inv CAPTURE.
+    remember (Genv.non_static_glob (Genv.globalenv prog) (prog_public prog)) as l. clear Heql.
+    clear SENVEQ. move l before fb. revert_until fb.
+    induction l; ss; i.
+    { inv CAP. esplits; eauto. econs. econs. }
+    inv CAP. exploit Mem.capture_extends_backward; eauto. i. des.
+    exploit IHl; try eapply CAPLIST; eauto. i. des. inv H. esplits; eauto. econs. econs; eauto. }
+  des. inv INITSRC. esplits; eauto.
+  - econs. eauto. rewrite Genv.globalenv_public. eauto.
+  - econs; eauto.
+  - ii. unfold Mach.concrete_snapshot, concrete_snapshot in *. inv SENVEQ. des. erewrite H4, H2. des_ifs; ss.
+    eapply Mem.mext_concrete; eauto. eapply Mem.concrete_valid; eauto.
+Qed.
+
 Theorem transf_program_correct:
-  forward_simulation (Mach.semantics return_address_offset prog) (Asm.semantics tprog).
+  mixed_simulation (Mach.semantics return_address_offset prog) (Asm.semantics tprog).
 Proof.
-  eapply forward_simulation_star with (measure := measure).
-  apply senv_preserved.
-  eexact transf_initial_states.
-  eexact transf_final_states.
-  exact step_simulation.
+  econs. econs.
+  - apply lt_wf.
+  - rr. i. exists (1 + a)%nat. lia.
+  - econs. i. exploit transf_initial_states; eauto. i. des.
+    exists st2. split.
+    (* initial state *)
+    + econs; eauto. eapply initial_state_determ.
+    (* mixed sim *) 
+    + r. ii. inversion INITSRC; subst. inversion H0; subst.
+      exploit transf_initial_capture;
+      [eapply INITSRC|eapply H|eapply H0|eapply CAPTGT|]. i. des.
+      exists (measure S1')%nat. exists S1'. esplits; eauto. apply match_states_xsim; auto.
+      eapply glob_capture_char; eauto. eapply initial_state_char; eauto.
+  - i. apply senv_preserved.
 Qed.
 
 End PRESERVATION.
diff --git a/x86/Asmgenproof1.v b/x86/Asmgenproof1.v
index fd88954e..a64ba17f 100644
--- a/x86/Asmgenproof1.v
+++ b/x86/Asmgenproof1.v
@@ -16,6 +16,7 @@ Require Import Coqlib.
 Require Import AST Errors Integers Floats Values Memory Globalenvs.
 Require Import Op Locations Conventions Mach Asm.
 Require Import Asmgen Asmgenproof0.
+Require Import IntPtrRel PointerOp Simulation AsmD.
 
 Local Open Scope error_monad_scope.
 
@@ -85,7 +86,8 @@ Ltac Simplifs := repeat Simplif.
 
 Section CONSTRUCTORS.
 
-Variable ge: genv.
+Variable prog: Asm.program.
+Let ge := Genv.globalenv prog.
 Variable fn: function.
 
 (** Smart constructor for moves. *)
@@ -94,7 +96,7 @@ Lemma mk_mov_correct:
   forall rd rs k c rs1 m,
   mk_mov rd rs k = OK c ->
   exists rs2,
-     exec_straight ge fn c rs1 m k rs2 m
+     exec_straight prog fn c rs1 m k rs2 m
   /\ rs2#rd = rs1#rs
   /\ forall r, data_preg r = true -> r <> rd -> rs2#r = rs1#r.
 Proof.
@@ -197,7 +199,7 @@ Lemma mk_shrximm_correct:
   mk_shrximm n k = OK c ->
   Val.shrx (rs1#RAX) (Vint n) = Some v ->
   exists rs2,
-     exec_straight ge fn c rs1 m k rs2 m
+     exec_straight prog fn c rs1 m k rs2 m
   /\ rs2#RAX = v
   /\ forall r, data_preg r = true -> r <> RAX -> r <> RCX -> rs2#r = rs1#r.
 Proof.
@@ -236,7 +238,7 @@ Lemma mk_shrxlimm_correct:
   mk_shrxlimm n k = OK c ->
   Val.shrxl (rs1#RAX) (Vint n) = Some v ->
   exists rs2,
-     exec_straight ge fn c rs1 m k rs2 m
+     exec_straight prog fn c rs1 m k rs2 m
   /\ rs2#RAX = v
   /\ forall r, data_preg r = true -> r <> RAX -> r <> RDX -> rs2#r = rs1#r.
 Proof.
@@ -276,7 +278,7 @@ Lemma mk_intconv_correct:
   (forall c rd rs r m,
    exec_instr ge c (mk rd rs) r m = Next (nextinstr (r#rd <- (sem r#rs))) m) ->
   exists rs2,
-     exec_straight ge fn c rs1 m k rs2 m
+     exec_straight prog fn c rs1 m k rs2 m
   /\ rs2#rd = sem rs1#rs
   /\ forall r, data_preg r = true -> r <> rd -> r <> RAX -> rs2#r = rs1#r.
 Proof.
@@ -307,14 +309,14 @@ Lemma mk_storebyte_correct:
   mk_storebyte addr r k = OK c ->
   Mem.storev Mint8unsigned m1 (eval_addrmode ge addr rs1) (rs1 r) = Some m2 ->
   exists rs2,
-     exec_straight ge fn c rs1 m1 k rs2 m2
+     exec_straight prog fn c rs1 m1 k rs2 m2
   /\ forall r, data_preg r = true -> preg_notin r (if Archi.ptr64 then nil else AX :: CX :: nil) -> rs2#r = rs1#r.
 Proof.
   unfold mk_storebyte; intros.
   destruct (Archi.ptr64 || low_ireg r) eqn:E.
 (* low reg *)
   monadInv H. econstructor; split. apply exec_straight_one.
-  simpl. unfold exec_store. rewrite H0. eauto. auto.
+  simpl. unfold exec_store. fold ge. rewrite H0. eauto. auto.
   intros; Simplifs.
 (* high reg *)
   InvBooleans. rewrite H1; simpl. destruct (addressing_mentions addr RAX) eqn:E; monadInv H.
@@ -334,6 +336,7 @@ Proof.
   rewrite H0. eauto.
   unfold eval_addrmode in *; rewrite H1 in *.
   destruct (eval_addrmode32 ge addr rs1); simpl in H0; try discriminate H0.
+  des_ifs.
   simpl. rewrite H1. rewrite Ptrofs.add_zero; auto.
   auto. auto. auto.
   intros. destruct H4. Simplifs. unfold rs3; Simplifs. unfold rs2; Simplifs.
@@ -342,7 +345,7 @@ Proof.
   econstructor; split.
   apply exec_straight_two with rs2 m1.
   simpl. auto.
-  simpl. unfold exec_store. unfold eval_addrmode in *; rewrite H1 in *.
+  simpl. unfold exec_store. fold ge. unfold eval_addrmode in *; rewrite H1 in *.
   rewrite (addressing_mentions_correct addr RAX rs2 rs1); auto.
   change (rs2 RAX) with (rs1 r). rewrite H0. eauto.
   intros. unfold rs2; Simplifs.
@@ -376,7 +379,7 @@ Lemma loadind_correct:
   loadind base ofs ty dst k = OK c ->
   Mem.loadv (chunk_of_type ty) m (Val.offset_ptr rs#base ofs) = Some v ->
   exists rs',
-     exec_straight ge fn c rs m k rs' m
+     exec_straight prog fn c rs m k rs' m
   /\ rs'#(preg_of dst) = v
   /\ forall r, data_preg r = true -> r <> preg_of dst -> rs'#r = rs#r.
 Proof.
@@ -386,7 +389,7 @@ Proof.
   { apply eval_addrmode_indexed. destruct (rs base); auto || discriminate. }
   rewrite <- H1 in H0.
   exists (nextinstr_nf (rs#(preg_of dst) <- v)); split.
-- loadind_correct_solve; apply exec_straight_one; auto; simpl in *; unfold exec_load; rewrite ?Heqb, ?H0; auto.
+- loadind_correct_solve; apply exec_straight_one; auto; simpl in *; unfold exec_load; fold ge; rewrite ?Heqb, ?H0; auto.
 - intuition Simplifs.
 Qed.
 
@@ -395,7 +398,7 @@ Lemma storeind_correct:
   storeind src base ofs ty k = OK c ->
   Mem.storev (chunk_of_type ty) m (Val.offset_ptr rs#base ofs) (rs#(preg_of src)) = Some m' ->
   exists rs',
-     exec_straight ge fn c rs m k rs' m'
+     exec_straight prog fn c rs m k rs' m'
   /\ forall r, data_preg r = true -> preg_notin r (destroyed_by_setstack ty) -> rs'#r = rs#r.
 Proof.
   unfold storeind; intros.
@@ -405,7 +408,7 @@ Proof.
   rewrite <- H1 in H0.
   loadind_correct_solve; simpl in H0;
   (econstructor; split;
-  [apply exec_straight_one; [simpl; unfold exec_store; rewrite ?Heqb, H0;eauto|auto]
+  [apply exec_straight_one; [simpl; unfold exec_store; fold ge; rewrite ?Heqb, H0;eauto|auto]
   |simpl; intros; unfold undef_regs; repeat Simplifs]).
 Qed.
 
@@ -597,8 +600,8 @@ Qed.
 Lemma compare_longs_spec:
   forall rs v1 v2 m,
   let rs' := nextinstr (compare_longs v1 v2 rs m) in
-     rs'#ZF = Val.maketotal (Val.cmplu (Mem.valid_pointer m) Ceq v1 v2)
-  /\ rs'#CF = Val.maketotal (Val.cmplu (Mem.valid_pointer m) Clt v1 v2)
+     rs'#ZF = Val.maketotal (cmplu_join_asm m Ceq v1 v2)
+  /\ rs'#CF = Val.maketotal (cmplu_join_asm m Clt v1 v2)
   /\ rs'#SF = Val.negativel (Val.subl v1 v2)
   /\ rs'#OF = Val.subl_overflow v1 v2
   /\ (forall r, data_preg r = true -> rs'#r = rs#r).
@@ -649,9 +652,92 @@ Proof.
   destruct (Int64.lt i i0); reflexivity.
 Qed.
 
+Lemma cmplu_bool_split
+  m v1 v2 b
+  (CMPLU: Val.cmplu_bool (Mem.valid_pointer m) Cle v1 v2 = Some b)
+  :
+  <<LT: Val.cmplu_bool (Mem.valid_pointer m) Clt v1 v2 = Some b>>
+\/ <<EQ: Val.cmplu_bool (Mem.valid_pointer m) Ceq v1 v2 = Some b>>.
+Proof.
+  destruct v1; destruct v2; ss; FuncInv; subst; try by des_ifs.
+  - rewrite Int64.not_ltu.
+    destruct (Int64.eq i i0).
+    + right. rewrite orb_true_r; eauto.
+    + destruct (Int64.ltu i i0); auto.
+  - des_ifs_safe.
+    fold (Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i)) in *.
+    fold (Mem.weak_valid_pointer m b1 (Ptrofs.unsigned i0)) in *.
+    + destruct (eq_block b0 b1).
+      destruct (Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i) &&
+                  Mem.weak_valid_pointer m b1 (Ptrofs.unsigned i0)); clarify.
+      * rewrite Ptrofs.not_ltu.
+        destruct (Ptrofs.eq i i0); auto.
+        { right. rewrite orb_true_r; eauto. }
+        { destruct (Ptrofs.ltu i i0); auto. }
+      * des_ifs.
+Qed.
+
+Lemma cmplu_join_split1
+  m i blk ofs b
+  (CMPLU: cmplu_join m Cle (Vlong i) (Vptr blk ofs) = Some b)
+  :
+  <<LT: cmplu_join m Clt (Vlong i) (Vptr blk ofs) = Some b>>
+\/ <<EQ: cmplu_join m Ceq (Vlong i) (Vptr blk ofs) = Some b>>.
+Proof.
+  unfold cmplu_join in CMPLU. unfold bool_optjoin, opt_join, bool_join in CMPLU. des_ifs.
+  - eapply eqb_prop in Heq1. subst. eapply cmplu_bool_split in Heq, Heq0. des.
+    + left. unfold cmplu_join. rewrite LT, LT0; eauto.
+      eapply bool_optjoin_same_bool.
+    + left. unfold cmplu_join, bool_optjoin, opt_join. des_ifs.
+      exploit cmplu_no_angelic; eauto. i. r in H. subst. eapply bool_join_angelic; eauto.
+    + left. unfold cmplu_join, bool_optjoin, opt_join. des_ifs.
+      exploit cmplu_no_angelic; eauto. i. r in H. subst. eapply bool_join_angelic; eauto.
+    + right. unfold cmplu_join. rewrite EQ, EQ0; eauto.
+      eapply bool_optjoin_same_bool.
+  - eapply cmplu_bool_split in Heq. des.
+    + left. unfold cmplu_join, bool_optjoin, opt_join. des_ifs.
+      exploit cmplu_no_angelic; eauto. i. r in H. subst. eapply bool_join_angelic; eauto.
+    + right. unfold cmplu_join, bool_optjoin, opt_join. des_ifs.
+      exploit cmplu_no_angelic; eauto. i. r in H. subst. eapply bool_join_angelic; eauto.
+  - eapply cmplu_bool_split in Heq0. des.
+    + left. unfold cmplu_join, bool_optjoin, opt_join. des_ifs.
+      exploit cmplu_no_angelic; eauto. i. r in H. subst. eapply bool_join_angelic; eauto.
+    + right. unfold cmplu_join, bool_optjoin, opt_join. des_ifs.
+      exploit cmplu_no_angelic; eauto. i. r in H. subst. eapply bool_join_angelic; eauto.
+Qed.
+
+Lemma cmplu_join_split2
+  m i blk ofs b
+  (CMPLU: cmplu_join m Cle (Vptr blk ofs) (Vlong i) = Some b)
+  :
+  <<LT: cmplu_join m Clt (Vptr blk ofs) (Vlong i) = Some b>>
+\/ <<EQ: cmplu_join m Ceq (Vptr blk ofs) (Vlong i) = Some b>>.
+Proof.
+  unfold cmplu_join in CMPLU. unfold bool_optjoin, opt_join, bool_join in CMPLU. des_ifs.
+  - eapply eqb_prop in Heq1. subst. eapply cmplu_bool_split in Heq, Heq0. des.
+    + left. unfold cmplu_join. rewrite LT, LT0; eauto.
+      eapply bool_optjoin_same_bool.
+    + left. unfold cmplu_join, bool_optjoin, opt_join. des_ifs.
+      exploit cmplu_no_angelic; eauto. i. r in H. subst. eapply bool_join_angelic; eauto.
+    + left. unfold cmplu_join, bool_optjoin, opt_join. des_ifs.
+      exploit cmplu_no_angelic; eauto. i. r in H. subst. eapply bool_join_angelic; eauto.
+    + right. unfold cmplu_join. rewrite EQ, EQ0; eauto.
+      eapply bool_optjoin_same_bool.
+  - eapply cmplu_bool_split in Heq. des.
+    + left. unfold cmplu_join, bool_optjoin, opt_join. des_ifs.
+      exploit cmplu_no_angelic; eauto. i. r in H. subst. eapply bool_join_angelic; eauto.
+    + right. unfold cmplu_join, bool_optjoin, opt_join. des_ifs.
+      exploit cmplu_no_angelic; eauto. i. r in H. subst. eapply bool_join_angelic; eauto.
+  - eapply cmplu_bool_split in Heq0. des.
+    + left. unfold cmplu_join, bool_optjoin, opt_join. des_ifs.
+      exploit cmplu_no_angelic; eauto. i. r in H. subst. eapply bool_join_angelic; eauto.
+    + right. unfold cmplu_join, bool_optjoin, opt_join. des_ifs.
+      exploit cmplu_no_angelic; eauto. i. r in H. subst. eapply bool_join_angelic; eauto.
+Qed.
+
 Lemma testcond_for_unsigned_comparison_64_correct:
   forall c v1 v2 rs m b,
-  Val.cmplu_bool (Mem.valid_pointer m) c v1 v2 = Some b ->
+  cmplu_bool_join_asm m c v1 v2 = Some b ->
   eval_testcond (testcond_for_unsigned_comparison c)
                 (nextinstr (compare_longs v1 v2 rs m)) = Some b.
 Proof.
@@ -669,17 +755,135 @@ Proof.
   rewrite (Int64.ltu_not i i0). destruct (Int64.ltu i i0); destruct (Int64.eq i i0); reflexivity.
   destruct (Int64.ltu i i0); reflexivity.
 - (* int ptr *)
-  unfold Val.cmplu; simpl; destruct Archi.ptr64; try discriminate.
+  unfold cmplu_join_asm in *. ss. destruct Archi.ptr64 eqn:SF; try discriminate.
   destruct (Int64.eq i Int64.zero &&
     (Mem.valid_pointer m b0 (Ptrofs.unsigned i0) || Mem.valid_pointer m b0 (Ptrofs.unsigned i0 - 1))) eqn:?; try discriminate H.
++ eapply andb_prop in Heqb1. des. rewrite Heqb1 in *; ss.
   destruct c; simpl in *; inv H; auto.
++ simpl in *. des_ifs_safe.
+  destruct c; simpl in *.
+  { rewrite H; ss; destruct b; ss. }
+  { replace Cne with (negate_comparison Ceq) in H by ss.
+    rewrite negate_cmplu_join in H.
+    destruct (cmplu_join m Ceq (Vlong i) (Vptr b0 i0)) eqn:CMP; [|ss].
+    ss. clarify. destruct b1; ss. }
+  { rewrite H; ss; destruct b; ss. }
+  { destruct (cmplu_join m Clt (Vlong i) (Vptr b0 i0)) eqn:LT.
+    - destruct (cmplu_join m Ceq (Vlong i) (Vptr b0 i0)) eqn:EQ.
+      + simpl. exploit cmplu_join_split1; eauto. i. des.
+        * clarify. destruct b1, b2; ss.
+          exfalso. clear - EQ H Heq.
+          exploit cmplu_always_captured1; try eapply H; eauto; [ss|].
+          i. des. erewrite cmplu_always_captured1' in H; eauto.
+          erewrite cmplu_always_captured1' in EQ; eauto. inv H. inv EQ.
+          rewrite Int64.not_ltu in H2. rewrite H1 in H2. rewrite orb_true_r in H2. clarify.
+        * clarify. destruct b1, b2; ss.
+          exfalso. clear - LT H Heq.
+          exploit cmplu_always_captured1; try eapply H; eauto; [ss|].
+          i. des. erewrite cmplu_always_captured1' in H; eauto.
+          erewrite cmplu_always_captured1' in LT; eauto. inv H. inv LT.
+          rewrite Int64.not_ltu in H2. rewrite H1 in H2. rewrite orb_true_l in H2. clarify.
+      + ss. exfalso. eapply cmplu_always_captured1 in H; eauto; [|ss].
+        des. eapply cmplu_always_captured1' with (c:= Ceq) (i:= i) (ofs:= i0) in H.
+        des; clarify.
+    - exfalso. eapply cmplu_always_captured1 in H; eauto; [|ss].
+      des. eapply cmplu_always_captured1' with (c:= Clt) (i:= i) (ofs:= i0) in H.
+      des; clarify. }
+  { replace Cgt with (negate_comparison Cle) in H by ss.
+    rewrite negate_cmplu_join in H.
+    destruct (cmplu_join m Cle (Vlong i) (Vptr b0 i0)) eqn:CMP; [|ss].
+    simpl in *. inv H.
+    destruct (cmplu_join m Clt (Vlong i) (Vptr b0 i0)) eqn:LT.
+    - destruct (cmplu_join m Ceq (Vlong i) (Vptr b0 i0)) eqn:EQ.
+      + simpl. exploit cmplu_join_split1; eauto. i. des.
+        * clarify. destruct b, b2; ss.
+          exfalso. clear - EQ CMP Heq.
+          exploit cmplu_always_captured1; try eapply CMP; eauto; [ss|].
+          i. des. erewrite cmplu_always_captured1' in CMP; eauto.
+          erewrite cmplu_always_captured1' in EQ; eauto. inv CMP. inv EQ.
+          rewrite Int64.not_ltu in H1. rewrite H2 in H1. rewrite orb_true_r in H1. clarify.
+        * clarify. destruct b, b2; ss.
+          exfalso. clear - LT CMP Heq.
+          exploit cmplu_always_captured1; try eapply CMP; eauto; [ss|].
+          i. des. erewrite cmplu_always_captured1' in CMP; eauto.
+          erewrite cmplu_always_captured1' in LT; eauto. inv CMP. inv LT.
+          rewrite Int64.not_ltu in H1. rewrite H2 in H1. rewrite orb_true_l in H1. clarify.
+      + ss. exfalso. eapply cmplu_always_captured1 in CMP; eauto; [|ss].
+        des. eapply cmplu_always_captured1' with (c:= Ceq) (i:= i) (ofs:= i0) in CMP.
+        des; clarify.
+    - exfalso. eapply cmplu_always_captured1 in CMP; eauto; [|ss].
+      des. eapply cmplu_always_captured1' with (c:= Clt) (i:= i) (ofs:= i0) in CMP.
+      des; clarify. }
+  { replace Cge with (negate_comparison Clt) in H by ss.
+    rewrite negate_cmplu_join in H.
+    destruct (cmplu_join m Clt (Vlong i) (Vptr b0 i0)) eqn:CMP; [|ss].
+    ss. clarify. destruct b1; ss. }
 - (* ptr int *)
-  unfold Val.cmplu; simpl; destruct Archi.ptr64; try discriminate.
+  unfold cmplu_join_asm in *. ss. destruct Archi.ptr64 eqn:SF; try discriminate.
   destruct (Int64.eq i0 Int64.zero &&
     (Mem.valid_pointer m b0 (Ptrofs.unsigned i) || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1))) eqn:?; try discriminate H.
++ eapply andb_prop in Heqb1. des. rewrite Heqb1 in *; ss.
   destruct c; simpl in *; inv H; auto.
++ simpl in *. des_ifs_safe.
+  destruct c; simpl in *.
+  { rewrite H; ss; destruct b; ss. }
+  { replace Cne with (negate_comparison Ceq) in H by ss.
+    rewrite negate_cmplu_join in H.
+    destruct (cmplu_join m Ceq (Vptr b0 i) (Vlong i0)) eqn:CMP; [|ss].
+    ss. clarify. destruct b1; ss. }
+  { rewrite H; ss; destruct b; ss. }
+  { destruct (cmplu_join m Clt (Vptr b0 i) (Vlong i0)) eqn:LT.
+    - destruct (cmplu_join m Ceq (Vptr b0 i) (Vlong i0)) eqn:EQ.
+      + simpl. exploit cmplu_join_split2; eauto. i. des.
+        * clarify. destruct b1, b2; ss.
+          exfalso. clear - EQ H Heq.
+          exploit cmplu_always_captured2; try eapply H; eauto; [ss|].
+          i. des. erewrite cmplu_always_captured2' in H; eauto.
+          erewrite cmplu_always_captured2' in EQ; eauto. inv H. inv EQ.
+          rewrite Int64.not_ltu in H2. rewrite H1 in H2. rewrite orb_true_r in H2. clarify.
+        * clarify. destruct b1, b2; ss.
+          exfalso. clear - LT H Heq.
+          exploit cmplu_always_captured2; try eapply H; eauto; [ss|].
+          i. des. erewrite cmplu_always_captured2' in H; eauto.
+          erewrite cmplu_always_captured2' in LT; eauto. inv H. inv LT.
+          rewrite Int64.not_ltu in H2. rewrite H1 in H2. rewrite orb_true_l in H2. clarify.
+      + ss. exfalso. eapply cmplu_always_captured2 in H; eauto; [|ss].
+        des. eapply cmplu_always_captured2' with (c:= Ceq) (i:= i0) (ofs:= i) in H.
+        des; clarify.
+    - exfalso. eapply cmplu_always_captured2 in H; eauto; [|ss].
+      des. eapply cmplu_always_captured2' with (c:= Clt) (i:= i0) (ofs:= i) in H.
+      des; clarify. }
+  { replace Cgt with (negate_comparison Cle) in H by ss.
+    rewrite negate_cmplu_join in H.
+    destruct (cmplu_join m Cle (Vptr b0 i) (Vlong i0)) eqn:CMP; [|ss].
+    simpl in *. inv H.
+    destruct (cmplu_join m Clt (Vptr b0 i) (Vlong i0)) eqn:LT.
+    - destruct (cmplu_join m Ceq (Vptr b0 i) (Vlong i0)) eqn:EQ.
+      + simpl. exploit cmplu_join_split2; eauto. i. des.
+        * clarify. destruct b, b2; ss.
+          exfalso. clear - EQ CMP Heq.
+          exploit cmplu_always_captured2; try eapply CMP; eauto; [ss|].
+          i. des. erewrite cmplu_always_captured2' in CMP; eauto.
+          erewrite cmplu_always_captured2' in EQ; eauto. inv CMP. inv EQ.
+          rewrite Int64.not_ltu in H1. rewrite H2 in H1. rewrite orb_true_r in H1. clarify.
+        * clarify. destruct b, b2; ss.
+          exfalso. clear - LT CMP Heq.
+          exploit cmplu_always_captured2; try eapply CMP; eauto; [ss|].
+          i. des. erewrite cmplu_always_captured2' in CMP; eauto.
+          erewrite cmplu_always_captured2' in LT; eauto. inv CMP. inv LT.
+          rewrite Int64.not_ltu in H1. rewrite H2 in H1. rewrite orb_true_l in H1. clarify.
+      + ss. exfalso. eapply cmplu_always_captured2 in CMP; eauto; [|ss].
+        des. eapply cmplu_always_captured2' with (c:= Ceq) (i:= i0) (ofs:= i) in CMP.
+        des; clarify.
+    - exfalso. eapply cmplu_always_captured2 in CMP; eauto; [|ss].
+      des. eapply cmplu_always_captured2' with (c:= Clt) (i:= i0) (ofs:= i) in CMP.
+      des; clarify. }
+  { replace Cge with (negate_comparison Clt) in H by ss.
+    rewrite negate_cmplu_join in H.
+    destruct (cmplu_join m Clt (Vptr b0 i) (Vlong i0)) eqn:CMP; [|ss].
+    ss. clarify. destruct b1; ss. }
 - (* ptr ptr *)
-  unfold Val.cmplu; simpl; destruct Archi.ptr64; try discriminate H.
+  unfold cmplu_join_asm in *. ss. destruct Archi.ptr64 eqn:SF; try discriminate H; ss.
   fold (Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i)) in *.
   fold (Mem.weak_valid_pointer m b1 (Ptrofs.unsigned i0)) in *.
   destruct (eq_block b0 b1).
@@ -909,8 +1113,8 @@ Lemma transl_cond_correct:
   forall cond args k c rs m,
   transl_cond cond args k = OK c ->
   exists rs',
-     exec_straight ge fn c rs m k rs' m
-  /\ match eval_condition cond (map rs (map preg_of args)) m with
+     exec_straight prog fn c rs m k rs' m
+  /\ match eval_condition_wrapper cond (map rs (map preg_of args)) m with
      | None => True
      | Some b => eval_extcond (testcond_for_condition cond) rs' = Some b
               /\ eval_extcond (testcond_for_condition (negate_condition cond)) rs' = Some (negb b)
@@ -922,6 +1126,7 @@ Proof.
 - (* comp *)
   simpl. rewrite (ireg_of_eq _ _ EQ). rewrite (ireg_of_eq _ _ EQ1).
   econstructor. split. apply exec_straight_one. simpl. eauto. auto.
+  rewrite eval_condition_no_ptr_op; ss.
   split. destruct (Val.cmp_bool c0 (rs x) (rs x0)) eqn:?; auto. split.
   eapply testcond_for_signed_comparison_32_correct; eauto.
   eapply testcond_for_signed_comparison_32_correct; eauto.
@@ -930,6 +1135,7 @@ Proof.
 - (* compu *)
   simpl. rewrite (ireg_of_eq _ _ EQ). rewrite (ireg_of_eq _ _ EQ1).
   econstructor. split. apply exec_straight_one. simpl. eauto. auto.
+  rewrite eval_condition_no_ptr_op; ss.
   split. destruct (Val.cmpu_bool (Mem.valid_pointer m) c0 (rs x) (rs x0)) eqn:?; auto. split.
   eapply testcond_for_unsigned_comparison_32_correct; eauto.
   eapply testcond_for_unsigned_comparison_32_correct; eauto.
@@ -938,12 +1144,14 @@ Proof.
 - (* compimm *)
   simpl. rewrite (ireg_of_eq _ _ EQ). destruct (Int.eq_dec n Int.zero).
   econstructor; split. apply exec_straight_one. simpl; eauto. auto.
+  rewrite eval_condition_no_ptr_op; ss.
   split. destruct (rs x); simpl; auto. subst. rewrite Int.and_idem. split.
   eapply testcond_for_signed_comparison_32_correct; eauto.
   eapply testcond_for_signed_comparison_32_correct; eauto.
   rewrite Val.negate_cmp_bool; auto.
   intros. unfold compare_ints. Simplifs.
   econstructor; split. apply exec_straight_one. simpl; eauto. auto.
+  rewrite eval_condition_no_ptr_op; ss.
   split. destruct (Val.cmp_bool c0 (rs x) (Vint n)) eqn:?; auto. split.
   eapply testcond_for_signed_comparison_32_correct; eauto.
   eapply testcond_for_signed_comparison_32_correct; eauto.
@@ -952,6 +1160,7 @@ Proof.
 - (* compuimm *)
   simpl. rewrite (ireg_of_eq _ _ EQ).
   econstructor. split. apply exec_straight_one. simpl. eauto. auto.
+  rewrite eval_condition_no_ptr_op; ss.
   split. destruct (Val.cmpu_bool (Mem.valid_pointer m) c0 (rs x) (Vint n)) eqn:?; auto; split.
   eapply testcond_for_unsigned_comparison_32_correct; eauto.
   eapply testcond_for_unsigned_comparison_32_correct; eauto.
@@ -960,6 +1169,7 @@ Proof.
 - (* compl *)
   simpl. rewrite (ireg_of_eq _ _ EQ). rewrite (ireg_of_eq _ _ EQ1).
   econstructor. split. apply exec_straight_one. simpl. eauto. auto.
+  rewrite eval_condition_no_ptr_op; ss.
   split. destruct (Val.cmpl_bool c0 (rs x) (rs x0)) eqn:?; auto. split.
   eapply testcond_for_signed_comparison_64_correct; eauto.
   eapply testcond_for_signed_comparison_64_correct; eauto.
@@ -968,20 +1178,28 @@ Proof.
 - (* complu *)
   simpl. rewrite (ireg_of_eq _ _ EQ). rewrite (ireg_of_eq _ _ EQ1).
   econstructor. split. apply exec_straight_one. simpl. eauto. auto.
-  split. destruct (Val.cmplu_bool (Mem.valid_pointer m) c0 (rs x) (rs x0)) eqn:?; auto. split.
+  assert (PTRCOND:ptr_cond (Ccomplu c0) = true).
+  { unfold ptr_cond. ss. }
+  unfold eval_condition_wrapper. rewrite PTRCOND.
+  rewrite <- cmplu_join_same_eval_condition_join.
+  split. destruct (cmplu_bool_join_asm m c0 (rs x) (rs x0)) eqn:?; auto. split.
   eapply testcond_for_unsigned_comparison_64_correct; eauto.
   eapply testcond_for_unsigned_comparison_64_correct; eauto.
-  rewrite Val.negate_cmplu_bool, Heqo; auto.
+  rewrite cmplu_join_same_eval_condition_join in *.
+  replace (Ccomplu (negate_comparison c0)) with (negate_condition (Ccomplu c0)) by ss.
+  rewrite eval_negate_condition_join, Heqo; auto.
   intros. unfold compare_longs. Simplifs.
 - (* compimm *)
   simpl. rewrite (ireg_of_eq _ _ EQ). destruct (Int64.eq_dec n Int64.zero).
   econstructor; split. apply exec_straight_one. simpl; eauto. auto.
+  rewrite eval_condition_no_ptr_op; ss.
   split. destruct (rs x); simpl; auto. subst. rewrite Int64.and_idem. split.
   eapply testcond_for_signed_comparison_64_correct; eauto.
   eapply testcond_for_signed_comparison_64_correct; eauto.
   rewrite Val.negate_cmpl_bool; auto.
   intros. unfold compare_longs. Simplifs.
   econstructor; split. apply exec_straight_one. simpl; eauto. auto.
+  rewrite eval_condition_no_ptr_op; ss.
   split. destruct (Val.cmpl_bool c0 (rs x) (Vlong n)) eqn:?; auto. split.
   eapply testcond_for_signed_comparison_64_correct; eauto.
   eapply testcond_for_signed_comparison_64_correct; eauto.
@@ -990,12 +1208,19 @@ Proof.
 - (* compuimm *)
   simpl. rewrite (ireg_of_eq _ _ EQ).
   econstructor. split. apply exec_straight_one. simpl. eauto. auto.
-  split. destruct (Val.cmplu_bool (Mem.valid_pointer m) c0 (rs x) (Vlong n)) eqn:?; auto. split.
+  assert (PTRCOND:ptr_cond (Ccompluimm c0 n) = true).
+  { unfold ptr_cond. ss. }
+  unfold eval_condition_wrapper. rewrite PTRCOND.
+  rewrite <- cmplu_join_same_eval_condition_join_imm.
+  split. destruct (cmplu_bool_join_asm m c0 (rs x) (Vlong n)) eqn:?; auto. split.
   eapply testcond_for_unsigned_comparison_64_correct; eauto.
   eapply testcond_for_unsigned_comparison_64_correct; eauto.
-  rewrite Val.negate_cmplu_bool, Heqo; auto.
+  rewrite cmplu_join_same_eval_condition_join_imm in *.
+  replace (Ccompluimm (negate_comparison c0) n) with (negate_condition (Ccompluimm c0 n)) by ss.
+  rewrite eval_negate_condition_join, Heqo; auto.
   intros. unfold compare_longs. Simplifs.
 - (* compf *)
+  rewrite eval_condition_no_ptr_op; [|ss].
   simpl. rewrite (freg_of_eq _ _ EQ). rewrite (freg_of_eq _ _ EQ1).
   exists (nextinstr (compare_floats (swap_floats c0 (rs x) (rs x0)) (swap_floats c0 (rs x0) (rs x)) rs)).
   split. apply exec_straight_one.
@@ -1007,6 +1232,7 @@ Proof.
   apply testcond_for_neg_float_comparison_correct.
   intros. Simplifs. apply compare_floats_inv; auto with asmgen.
 - (* notcompf *)
+  rewrite eval_condition_no_ptr_op; [|ss].
   simpl. rewrite (freg_of_eq _ _ EQ). rewrite (freg_of_eq _ _ EQ1).
   exists (nextinstr (compare_floats (swap_floats c0 (rs x) (rs x0)) (swap_floats c0 (rs x0) (rs x)) rs)).
   split. apply exec_straight_one.
@@ -1018,6 +1244,7 @@ Proof.
   rewrite negb_involutive. apply testcond_for_float_comparison_correct.
   intros. Simplifs. apply compare_floats_inv; auto with asmgen.
 - (* compfs *)
+  rewrite eval_condition_no_ptr_op; [|ss].
   simpl. rewrite (freg_of_eq _ _ EQ). rewrite (freg_of_eq _ _ EQ1).
   exists (nextinstr (compare_floats32 (swap_floats c0 (rs x) (rs x0)) (swap_floats c0 (rs x0) (rs x)) rs)).
   split. apply exec_straight_one.
@@ -1029,6 +1256,7 @@ Proof.
   apply testcond_for_neg_float32_comparison_correct.
   intros. Simplifs. apply compare_floats32_inv; auto with asmgen.
 - (* notcompfs *)
+  rewrite eval_condition_no_ptr_op; [|ss].
   simpl. rewrite (freg_of_eq _ _ EQ). rewrite (freg_of_eq _ _ EQ1).
   exists (nextinstr (compare_floats32 (swap_floats c0 (rs x) (rs x0)) (swap_floats c0 (rs x0) (rs x)) rs)).
   split. apply exec_straight_one.
@@ -1070,7 +1298,7 @@ Qed.
 Lemma mk_setcc_base_correct:
   forall cond rd k rs1 m,
   exists rs2,
-  exec_straight ge fn (mk_setcc_base cond rd k) rs1 m k rs2 m
+  exec_straight prog fn (mk_setcc_base cond rd k) rs1 m k rs2 m
   /\ rs2#rd = Val.of_optbool(eval_extcond cond rs1)
   /\ forall r, data_preg r = true -> r <> RAX /\ r <> RCX -> r <> rd -> rs2#r = rs1#r.
 Proof.
@@ -1150,7 +1378,7 @@ Qed.
 Lemma mk_setcc_correct:
   forall cond rd k rs1 m,
   exists rs2,
-  exec_straight ge fn (mk_setcc cond rd k) rs1 m k rs2 m
+  exec_straight prog fn (mk_setcc cond rd k) rs1 m k rs2 m
   /\ rs2#rd = Val.of_optbool(eval_extcond cond rs1)
   /\ forall r, data_preg r = true -> r <> RAX /\ r <> RCX -> r <> rd -> rs2#r = rs1#r.
 Proof.
@@ -1185,7 +1413,7 @@ Lemma mk_sel_correct:
   | None => True
   end ->
   exists rs',
-     exec_straight ge fn c rs m k rs' m
+     exec_straight prog fn c rs m k rs' m
   /\ Val.lessdef (Val.select ob rs#rd rs#r2 ty) rs'#rd
   /\ forall r, data_preg r = true -> r <> rd -> rs'#r = rs r.
 Proof.
@@ -1231,15 +1459,15 @@ Lemma transl_sel_correct:
   forall ty cond args rd r2 k c rs m,
   transl_sel cond args rd r2 k = OK c ->
   exists rs',
-     exec_straight ge fn c rs m k rs' m
-  /\ Val.lessdef (Val.select (eval_condition cond (map rs (map preg_of args)) m) rs#rd rs#r2 ty) rs'#rd
+     exec_straight prog fn c rs m k rs' m
+  /\ Val.lessdef (Val.select (eval_condition_wrapper cond (map rs (map preg_of args)) m) rs#rd rs#r2 ty) rs'#rd
   /\ forall r, data_preg r = true -> r <> rd -> rs'#r = rs r.
 Proof.
   unfold transl_sel; intros. destruct (ireg_eq rd r2); monadInv H. 
 - econstructor; split. 
   apply exec_straight_one; reflexivity.
   split. rewrite nextinstr_inv, Pregmap.gss by auto with asmgen. 
-  destruct eval_condition as [[]|]; simpl; auto using Val.lessdef_normalize.
+  destruct eval_condition_wrapper as [[]|]; simpl; auto using Val.lessdef_normalize.
   intros; Simplifs.
 - destruct (transl_cond_correct _ _ _ _ rs m EQ0) as (rs1 & A & B & C).
   rewrite <- negate_testcond_for_condition in B.
@@ -1274,9 +1502,9 @@ Ltac TranslOp :=
 Lemma transl_op_correct:
   forall op args res k c (rs: regset) m v,
   transl_op op args res k = OK c ->
-  eval_operation ge (rs#RSP) op (map rs (map preg_of args)) m = Some v ->
+  eval_operation_wrapper ge (rs#RSP) op (map rs (map preg_of args)) m = Some v ->
   exists rs',
-     exec_straight ge fn c rs m k rs' m
+     exec_straight prog fn c rs m k rs' m
   /\ Val.lessdef v rs'#(preg_of res)
   /\ forall r, data_preg r = true -> r <> preg_of res -> preg_notin r (destroyed_by_op op) -> rs' r = rs r.
 Proof.
@@ -1284,11 +1512,11 @@ Transparent destroyed_by_op.
   intros until v; intros TR EV.
   assert (SAME:
   (exists rs',
-     exec_straight ge fn c rs m k rs' m
+     exec_straight prog fn c rs m k rs' m
   /\ rs'#(preg_of res) = v
   /\ forall r, data_preg r = true -> r <> preg_of res -> preg_notin r (destroyed_by_op op) -> rs' r = rs r) ->
   exists rs',
-     exec_straight ge fn c rs m k rs' m
+     exec_straight prog fn c rs m k rs' m
   /\ Val.lessdef v rs'#(preg_of res)
   /\ forall r, data_preg r = true -> r <> preg_of res -> preg_notin r (destroyed_by_op op) -> rs' r = rs r).
   {
@@ -1317,6 +1545,7 @@ Transparent destroyed_by_op.
   apply SAME. TranslOp. destruct H1. Simplifs.
 (* div *)
   apply SAME.
+  rewrite eval_operation_no_ptr_op in H0; ss.
   exploit (divs_mods_exists (rs RAX) (rs RCX)). left; congruence.
   intros (nh & nl & d & q & r & A & B & C & D & E & F).
   set (rs1 := nextinstr_nf (rs#RDX <- (Vint nh))).
@@ -1329,6 +1558,7 @@ Transparent destroyed_by_op.
   simpl; intros. destruct H2. unfold rs1; Simplifs.
 (* divu *)
   apply SAME.
+  rewrite eval_operation_no_ptr_op in H0; ss.
   exploit (divu_modu_exists (rs RAX) (rs RCX)). left; congruence.
   intros (n & d & q & r & B & C & D & E & F).
   set (rs1 := nextinstr_nf (rs#RDX <- Vzero)).
@@ -1341,6 +1571,7 @@ Transparent destroyed_by_op.
   simpl; intros. destruct H2. unfold rs1; Simplifs.
 (* mod *)
   apply SAME.
+  rewrite eval_operation_no_ptr_op in H0; ss.
   exploit (divs_mods_exists (rs RAX) (rs RCX)). right; congruence.
   intros (nh & nl & d & q & r & A & B & C & D & E & F).
   set (rs1 := nextinstr_nf (rs#RDX <- (Vint nh))).
@@ -1353,6 +1584,7 @@ Transparent destroyed_by_op.
   simpl; intros. destruct H2. unfold rs1; Simplifs.
 (* modu *)
   apply SAME.
+  rewrite eval_operation_no_ptr_op in H0; ss.
   exploit (divu_modu_exists (rs RAX) (rs RCX)). right; congruence.
   intros (n & d & q & r & B & C & D & E & F).
   set (rs1 := nextinstr_nf (rs#RDX <- Vzero)).
@@ -1366,6 +1598,7 @@ Transparent destroyed_by_op.
 (* shrximm *)
   apply SAME. eapply mk_shrximm_correct; eauto.
 (* lea *)
+  rewrite eval_operation_no_ptr_op in H0; ss.
   exploit transl_addressing_mode_32_correct; eauto. intros EA.
   TranslOp. rewrite nextinstr_inv; auto with asmgen. rewrite Pregmap.gss. rewrite normalize_addrmode_32_correct; auto.
 (* mullhs *)
@@ -1374,6 +1607,7 @@ Transparent destroyed_by_op.
   apply SAME. TranslOp. destruct H1. Simplifs.
 (* divl *)
   apply SAME.
+  rewrite eval_operation_no_ptr_op in H0; ss.
   exploit (divls_modls_exists (rs RAX) (rs RCX)). left; congruence.
   intros (nh & nl & d & q & r & A & B & C & D & E & F).
   set (rs1 := nextinstr_nf (rs#RDX <- (Vlong nh))).
@@ -1386,6 +1620,7 @@ Transparent destroyed_by_op.
   simpl; intros. destruct H2. unfold rs1; Simplifs.
 (* divlu *)
   apply SAME.
+  rewrite eval_operation_no_ptr_op in H0; ss.
   exploit (divlu_modlu_exists (rs RAX) (rs RCX)). left; congruence.
   intros (n & d & q & r & B & C & D & E & F).
   set (rs1 := nextinstr_nf (rs#RDX <- (Vlong Int64.zero))).
@@ -1398,6 +1633,7 @@ Transparent destroyed_by_op.
   simpl; intros. destruct H2. unfold rs1; Simplifs.
 (* modl *)
   apply SAME.
+  rewrite eval_operation_no_ptr_op in H0; ss.
   exploit (divls_modls_exists (rs RAX) (rs RCX)). right; congruence.
   intros (nh & nl & d & q & r & A & B & C & D & E & F).
   set (rs1 := nextinstr_nf (rs#RDX <- (Vlong nh))).
@@ -1410,6 +1646,7 @@ Transparent destroyed_by_op.
   simpl; intros. destruct H2. unfold rs1; Simplifs.
 (* modlu *)
   apply SAME.
+  rewrite eval_operation_no_ptr_op in H0; ss.
   exploit (divlu_modlu_exists (rs RAX) (rs RCX)). right; congruence.
   intros (n & d & q & r & B & C & D & E & F).
   set (rs1 := nextinstr_nf (rs#RDX <- (Vlong Int64.zero))).
@@ -1423,41 +1660,69 @@ Transparent destroyed_by_op.
 (* shrxlimm *)
   apply SAME. eapply mk_shrxlimm_correct; eauto.
 (* leal *)
+  rewrite eval_operation_no_ptr_op in H0; ss.
   exploit transl_addressing_mode_64_correct; eauto. intros EA.
   generalize (normalize_addrmode_64_correct x rs). destruct (normalize_addrmode_64 x) as [am' [delta|]]; intros EV.
   econstructor; split. eapply exec_straight_two.
   simpl. reflexivity.  simpl. reflexivity. auto. auto.
   split. rewrite nextinstr_nf_inv by auto. rewrite Pregmap.gss. rewrite nextinstr_inv by auto with asmgen.
-  rewrite Pregmap.gss. rewrite <- EV; auto.
+  rewrite Pregmap.gss. fold ge. rewrite <- EV; auto.
   intros; Simplifs.
-  TranslOp. rewrite nextinstr_inv; auto with asmgen. rewrite Pregmap.gss; auto. rewrite <- EV; auto.
+  TranslOp. rewrite nextinstr_inv; auto with asmgen. rewrite Pregmap.gss; auto. fold ge. rewrite <- EV; auto.
 (* intoffloat *)
+  rewrite eval_operation_no_ptr_op in H0; ss.
   apply SAME. TranslOp. rewrite H0; auto.
 (* floatofint *)
-  apply SAME. TranslOp. rewrite H0; auto.
+  rewrite eval_operation_no_ptr_op in H0; ss.
+  apply SAME. TranslOp. fold ge. rewrite H0; auto.
 (* intofsingle *)
+  rewrite eval_operation_no_ptr_op in H0; ss.
   apply SAME. TranslOp. rewrite H0; auto.
 (* singleofint *)
+  rewrite eval_operation_no_ptr_op in H0; ss.
   apply SAME. TranslOp. rewrite H0; auto.
 (* longoffloat *)
+  rewrite eval_operation_no_ptr_op in H0; ss.
   apply SAME. TranslOp. rewrite H0; auto.
 (* floatoflong *)
+  rewrite eval_operation_no_ptr_op in H0; ss.
   apply SAME. TranslOp. rewrite H0; auto.
 (* longofsingle *)
+  rewrite eval_operation_no_ptr_op in H0; ss.
   apply SAME. TranslOp. rewrite H0; auto.
 (* singleoflong *)
+  rewrite eval_operation_no_ptr_op in H0; ss.
   apply SAME. TranslOp. rewrite H0; auto.
+(* (* psub *) *)
+(*   apply SAME. TranslOp. *)
+(*   unfold eval_operation_wrapper in H0. ss. unfold psub_join_asm. des_ifs. *)
 (* condition *)
   exploit transl_cond_correct; eauto. intros [rs2 [P [Q R]]].
   exploit mk_setcc_correct; eauto. intros [rs3 [S [T U]]].
   exists rs3.
   split. eapply exec_straight_trans. eexact P. eexact S.
+  destruct (ptr_cond cond) eqn:PCOND.
+  { unfold eval_operation_wrapper in H0. ss. rewrite PCOND in H0. inv H0.
+    unfold eval_condition_wrapper in Q. rewrite PCOND in Q.
+    split. rewrite T. destruct (eval_condition_join cond rs ## (preg_of ## args) m).
+    destruct Q as [Q _]. rewrite Q. auto.
+    simpl; auto.
+    intros. transitivity (rs2 r); auto. }
+  rewrite eval_operation_no_ptr_op in H0; [|ss]. simpl in H0. inv H0.
+  rewrite eval_condition_no_ptr_op in Q; [|ss].
   split. rewrite T. destruct (eval_condition cond rs ## (preg_of ## args) m).
   destruct Q as [Q _]. rewrite Q. auto.
   simpl; auto.
   intros. transitivity (rs2 r); auto.
 (* selection *)
+  destruct (ptr_cond c0) eqn:PCOND.
+  { unfold eval_operation_wrapper in H0. ss. rewrite PCOND in H0. inv H0.
+    rewrite EQ1. exploit transl_sel_correct; eauto. intros (rs' & A & B & C).
+    unfold eval_condition_wrapper in B. rewrite PCOND in B.
+    exists rs'; split. eexact A. eauto. }
+  rewrite eval_operation_no_ptr_op in H0; ss. inv H0.
   rewrite EQ1. exploit transl_sel_correct; eauto. intros (rs' & A & B & C).
+  rewrite eval_condition_no_ptr_op in B; ss.
   exists rs'; split. eexact A. eauto.
 Qed.
 
@@ -1469,7 +1734,7 @@ Lemma transl_load_correct:
   eval_addressing ge (rs#RSP) addr (map rs (map preg_of args)) = Some a ->
   Mem.loadv chunk m a = Some v ->
   exists rs',
-     exec_straight ge fn c rs m k rs' m
+     exec_straight prog fn c rs m k rs' m
   /\ rs'#(preg_of dest) = v
   /\ forall r, data_preg r = true -> r <> preg_of dest -> rs'#r = rs#r.
 Proof.
@@ -1494,7 +1759,7 @@ Lemma transl_store_correct:
   eval_addressing ge (rs#RSP) addr (map rs (map preg_of args)) = Some a ->
   Mem.storev chunk m a (rs (preg_of src)) = Some m' ->
   exists rs',
-     exec_straight ge fn c rs m k rs' m'
+     exec_straight prog fn c rs m k rs' m'
   /\ forall r, data_preg r = true -> preg_notin r (destroyed_by_store chunk addr) -> rs'#r = rs#r.
 Proof.
   unfold transl_store; intros. monadInv H.
@@ -1502,38 +1767,43 @@ Proof.
   assert (EA': eval_addrmode ge x rs = a). destruct a; simpl in H1; try discriminate; inv EA; auto.
   rewrite <- EA' in H1. destruct chunk; ArgsInv.
 (* int8signed *)
-  eapply mk_storebyte_correct; eauto.
-  destruct (eval_addrmode ge x rs); simpl; auto. rewrite <- Mem.store_signed_unsigned_8; auto.
+  eapply mk_storebyte_correct; eauto. 
+  destruct (eval_addrmode ge x rs); simpl; auto.
+  { ss. des_ifs. rewrite <- Mem.store_signed_unsigned_8; auto. }
+  rewrite <- Mem.store_signed_unsigned_8; auto.
 (* int8unsigned *)
   eapply mk_storebyte_correct; eauto.
 (* int16signed *)
   econstructor; split.
   apply exec_straight_one. simpl. unfold exec_store.
+  fold ge.
   replace (Mem.storev Mint16unsigned m (eval_addrmode ge x rs) (rs x0))
      with (Mem.storev Mint16signed m (eval_addrmode ge x rs) (rs x0)).
   rewrite H1. eauto.
-  destruct (eval_addrmode ge x rs); simpl; auto. rewrite Mem.store_signed_unsigned_16; auto.
+  destruct (eval_addrmode ge x rs); simpl; auto.
+  { ss. des_ifs. rewrite Mem.store_signed_unsigned_16; auto. }
+  rewrite Mem.store_signed_unsigned_16; auto.
   auto.
   intros. Simplifs.
 (* int16unsigned *)
   econstructor; split.
-  apply exec_straight_one. simpl. unfold exec_store. rewrite H1. eauto. auto.
+  apply exec_straight_one. fold ge. simpl. unfold exec_store. rewrite H1. eauto. auto.
   intros. Simplifs.
 (* int32 *)
   econstructor; split.
-  apply exec_straight_one. simpl. unfold exec_store. rewrite H1. eauto. auto.
+  apply exec_straight_one. fold ge. simpl. unfold exec_store. rewrite H1. eauto. auto.
   intros. Simplifs.
 (* int64 *)
   econstructor; split.
-  apply exec_straight_one. simpl. unfold exec_store. rewrite H1. eauto. auto.
+  apply exec_straight_one. fold ge. simpl. unfold exec_store. rewrite H1. eauto. auto.
   intros. Simplifs.
 (* float32 *)
   econstructor; split.
-  apply exec_straight_one. simpl. unfold exec_store. rewrite H1. eauto. auto.
+  apply exec_straight_one. fold ge. simpl. unfold exec_store. rewrite H1. eauto. auto.
   intros. Transparent destroyed_by_store. simpl in H2. simpl. Simplifs.
 (* float64 *)
   econstructor; split.
-  apply exec_straight_one. simpl. unfold exec_store. rewrite H1. eauto. auto.
+  apply exec_straight_one. fold ge. simpl. unfold exec_store. rewrite H1. eauto. auto.
   intros. Simplifs.
 Qed.
 
diff --git a/x86/CombineOpproof.v b/x86/CombineOpproof.v
index 69abbf61..8b71c09d 100644
--- a/x86/CombineOpproof.v
+++ b/x86/CombineOpproof.v
@@ -18,6 +18,7 @@ Require Import Coqlib.
 Require Import Integers Values Memory.
 Require Import Op RTL CSEdomain.
 Require Import CombineOp.
+Require Import PointerOp.
 
 Section COMBINE.
 
@@ -29,7 +30,7 @@ Variable valu: valnum -> val.
 Hypothesis get_sound: forall v rhs, get v = Some rhs -> rhs_eval_to valu ge sp m rhs (valu v).
 
 Lemma get_op_sound:
-  forall v op vl, get v = Some (Op op vl) -> eval_operation ge sp op (map valu vl) m = Some (valu v).
+  forall v op vl, get v = Some (Op op vl) -> eval_operation_wrapper ge sp op (map valu vl) m = Some (valu v).
 Proof.
   intros. exploit get_sound; eauto. intros REV; inv REV; auto.
 Qed.
@@ -43,54 +44,76 @@ Ltac UseGetSound :=
 Lemma combine_compimm_ne_0_sound:
   forall x cond args,
   combine_compimm_ne_0 get x = Some(cond, args) ->
-  eval_condition cond (map valu args) m = Val.cmp_bool Cne (valu x) (Vint Int.zero) /\
-  eval_condition cond (map valu args) m = Val.cmpu_bool (Mem.valid_pointer m) Cne (valu x) (Vint Int.zero).
+  eval_condition_wrapper cond (map valu args) m = Val.cmp_bool Cne (valu x) (Vint Int.zero) /\
+  eval_condition_wrapper cond (map valu args) m = Val.cmpu_bool (Mem.valid_pointer m) Cne (valu x) (Vint Int.zero).
 Proof.
   intros until args. functional induction (combine_compimm_ne_0 get x); intros EQ; inv EQ.
   (* of cmp *)
-  UseGetSound. rewrite <- H.
+  UseGetSound. unfold eval_operation_wrapper in EQ. ss. des_ifs.
+  unfold eval_condition_wrapper. rewrite Heq.
+  rewrite <- H0.
+  destruct (eval_condition_join cond (map valu args) m); simpl; auto. destruct b; auto.
+  unfold eval_condition_wrapper. rewrite Heq.
+  rewrite <- H0.
   destruct (eval_condition cond (map valu args) m); simpl; auto. destruct b; auto.
   (* of and *)
-  UseGetSound. rewrite <- H.
+  UseGetSound. rewrite eval_operation_no_ptr_op in EQ; [|ss].
+  inv EQ. des_ifs. inv Heq. rewrite <- H0, H1.
   destruct v; simpl; auto.
 Qed.
 
 Lemma combine_compimm_eq_0_sound:
   forall x cond args,
   combine_compimm_eq_0 get x = Some(cond, args) ->
-  eval_condition cond (map valu args) m = Val.cmp_bool Ceq (valu x) (Vint Int.zero) /\
-  eval_condition cond (map valu args) m = Val.cmpu_bool (Mem.valid_pointer m) Ceq (valu x) (Vint Int.zero).
+  eval_condition_wrapper cond (map valu args) m = Val.cmp_bool Ceq (valu x) (Vint Int.zero) /\
+  eval_condition_wrapper cond (map valu args) m = Val.cmpu_bool (Mem.valid_pointer m) Ceq (valu x) (Vint Int.zero).
 Proof.
   intros until args. functional induction (combine_compimm_eq_0 get x); intros EQ; inv EQ.
   (* of cmp *)
-  UseGetSound. rewrite <- H.
+  UseGetSound. unfold eval_operation_wrapper in EQ. ss. des_ifs.
+  unfold eval_condition_wrapper. rewrite <- negate_ptr_cond, Heq.
+  rewrite <- H0.
+  rewrite eval_negate_condition_join; eauto.
+  destruct (eval_condition_join c (map valu args) m); simpl; auto. destruct b; auto.
+  unfold eval_condition_wrapper. rewrite <- negate_ptr_cond, Heq.
+  rewrite <- H0.
   rewrite eval_negate_condition.
   destruct (eval_condition c (map valu args) m); simpl; auto. destruct b; auto.
   (* of and *)
-  UseGetSound. rewrite <- H. destruct v; auto.
+  UseGetSound. rewrite eval_operation_no_ptr_op in EQ; [|ss].
+  inv EQ. des_ifs. inv Heq. rewrite <- H0, H1. destruct v; auto.
 Qed.
 
 Lemma combine_compimm_eq_1_sound:
   forall x cond args,
   combine_compimm_eq_1 get x = Some(cond, args) ->
-  eval_condition cond (map valu args) m = Val.cmp_bool Ceq (valu x) (Vint Int.one) /\
-  eval_condition cond (map valu args) m = Val.cmpu_bool (Mem.valid_pointer m) Ceq (valu x) (Vint Int.one).
+  eval_condition_wrapper cond (map valu args) m = Val.cmp_bool Ceq (valu x) (Vint Int.one) /\
+  eval_condition_wrapper cond (map valu args) m = Val.cmpu_bool (Mem.valid_pointer m) Ceq (valu x) (Vint Int.one).
 Proof.
   intros until args. functional induction (combine_compimm_eq_1 get x); intros EQ; inv EQ.
   (* of cmp *)
-  UseGetSound. rewrite <- H.
+  UseGetSound. unfold eval_operation_wrapper in EQ. ss. des_ifs.
+  unfold eval_condition_wrapper. rewrite Heq. rewrite <- H0.
+  destruct (eval_condition_join cond (map valu args) m); simpl; auto. destruct b; auto.
+  unfold eval_condition_wrapper. rewrite Heq. rewrite <- H0.
   destruct (eval_condition cond (map valu args) m); simpl; auto. destruct b; auto.
 Qed.
 
 Lemma combine_compimm_ne_1_sound:
   forall x cond args,
   combine_compimm_ne_1 get x = Some(cond, args) ->
-  eval_condition cond (map valu args) m = Val.cmp_bool Cne (valu x) (Vint Int.one) /\
-  eval_condition cond (map valu args) m = Val.cmpu_bool (Mem.valid_pointer m) Cne (valu x) (Vint Int.one).
+  eval_condition_wrapper cond (map valu args) m = Val.cmp_bool Cne (valu x) (Vint Int.one) /\
+  eval_condition_wrapper cond (map valu args) m = Val.cmpu_bool (Mem.valid_pointer m) Cne (valu x) (Vint Int.one).
 Proof.
   intros until args. functional induction (combine_compimm_ne_1 get x); intros EQ; inv EQ.
   (* of cmp *)
-  UseGetSound. rewrite <- H.
+  UseGetSound. unfold eval_operation_wrapper in EQ. ss. des_ifs.
+  unfold eval_condition_wrapper. rewrite <- negate_ptr_cond, Heq.
+  rewrite <- H0.
+  rewrite eval_negate_condition_join; eauto.
+  destruct (eval_condition_join c (map valu args) m); simpl; auto. destruct b; auto.
+  unfold eval_condition_wrapper. rewrite <- negate_ptr_cond, Heq.
+  rewrite <- H0.
   rewrite eval_negate_condition.
   destruct (eval_condition c (map valu args) m); simpl; auto. destruct b; auto.
 Qed.
@@ -98,9 +121,9 @@ Qed.
 Theorem combine_cond_sound:
   forall cond args cond' args',
   combine_cond get cond args = Some(cond', args') ->
-  eval_condition cond' (map valu args') m = eval_condition cond (map valu args) m.
+  eval_condition_wrapper cond' (map valu args') m = eval_condition_wrapper cond (map valu args) m.
 Proof.
-  intros. functional inversion H; subst.
+  intros. dup H. functional inversion H; subst.
   (* compimm ne zero *)
   simpl; eapply combine_compimm_ne_0_sound; eauto.
   (* compimm ne one *)
@@ -154,7 +177,7 @@ Qed.
 Theorem combine_op_sound:
   forall op args op' args',
   combine_op get op args = Some(op', args') ->
-  eval_operation ge sp op' (map valu args') m = eval_operation ge sp op (map valu args) m.
+  eval_operation_wrapper ge sp op' (map valu args') m = eval_operation_wrapper ge sp op (map valu args) m.
 Proof.
   intros. functional inversion H; subst.
 (* lea-lea *)
@@ -162,19 +185,43 @@ Proof.
 (* leal-leal *)
   simpl. eapply combine_addr_64_sound; eauto.
 (* andimm - andimm *)
-  UseGetSound; simpl. rewrite <- H0. rewrite Val.and_assoc. auto.
+  UseGetSound; simpl.
+  rewrite eval_operation_no_ptr_op in *; [|ss|ss]. rewrite eval_operation_no_ptr_op; [|ss].
+  simpl in *. des_ifs. destruct args'; ss. destruct args'; ss. clarify.
+  rewrite <- H1. rewrite Val.and_assoc. auto.
 (* orimm - orimm *)
-  UseGetSound; simpl. rewrite <- H0. rewrite Val.or_assoc. auto.
+  UseGetSound; simpl.
+  rewrite eval_operation_no_ptr_op in *; [|ss|ss]. rewrite eval_operation_no_ptr_op; [|ss].
+  simpl in *. des_ifs. destruct args'; ss. destruct args'; ss. clarify.
+  rewrite <- H1. rewrite Val.or_assoc. auto.
 (* xorimm - xorimm *)
-  UseGetSound; simpl. rewrite <- H0. rewrite Val.xor_assoc. auto.
+  UseGetSound; simpl.
+  rewrite eval_operation_no_ptr_op in *; [|ss|ss]. rewrite eval_operation_no_ptr_op; [|ss].
+  simpl in *. des_ifs. destruct args'; ss. destruct args'; ss. clarify.
+  rewrite <- H1. rewrite Val.xor_assoc. auto.
 (* andimm - andimm *)
-  UseGetSound; simpl. rewrite <- H0. rewrite Val.andl_assoc. auto.
+  UseGetSound; simpl.
+  rewrite eval_operation_no_ptr_op in *; [|ss|ss]. rewrite eval_operation_no_ptr_op; [|ss].
+  simpl in *. des_ifs. destruct args'; ss. destruct args'; ss. clarify.
+  rewrite <- H1. rewrite Val.andl_assoc. auto.
 (* orimm - orimm *)
-  UseGetSound; simpl. rewrite <- H0. rewrite Val.orl_assoc. auto.
+  UseGetSound; simpl.
+  rewrite eval_operation_no_ptr_op in *; [|ss|ss]. rewrite eval_operation_no_ptr_op; [|ss].
+  simpl in *. des_ifs. destruct args'; ss. destruct args'; ss. clarify.
+  rewrite <- H1. rewrite Val.orl_assoc. auto.
 (* xorimm - xorimm *)
-  UseGetSound; simpl. rewrite <- H0. rewrite Val.xorl_assoc. auto.
+  UseGetSound; simpl.
+  rewrite eval_operation_no_ptr_op in *; [|ss|ss]. rewrite eval_operation_no_ptr_op; [|ss].
+  simpl in *. des_ifs. destruct args'; ss. destruct args'; ss. clarify.
+  rewrite <- H1. rewrite Val.xorl_assoc. auto.
 (* cmp *)
-  simpl. decEq; decEq. eapply combine_cond_sound; eauto.
+  exploit combine_cond_sound; eauto. i.
+  unfold eval_operation_wrapper. unfold eval_condition_wrapper in H0.
+  simpl. des_ifs.
+  - rewrite H0. eauto.
+  - rewrite H0. eauto.
+  - rewrite H0. eauto.
+  - rewrite H0. eauto.
 Qed.
 
 End COMBINE.
diff --git a/x86/ConstpropOpproof.v b/x86/ConstpropOpproof.v
index 09c6e91b..dc31b5c3 100644
--- a/x86/ConstpropOpproof.v
+++ b/x86/ConstpropOpproof.v
@@ -16,6 +16,7 @@ Require Import Coqlib Compopts.
 Require Import Integers Floats Values Memory Globalenvs Events.
 Require Import Op Registers RTL ValueDomain ValueAOp ValueAnalysis.
 Require Import ConstpropOp.
+Require Import sflib IntPtrRel PointerOp.
 
 Section STRENGTH_REDUCTION.
 
@@ -83,8 +84,9 @@ Ltac SimplVM :=
 
 Lemma eval_Olea_ptr:
   forall a el,
-  eval_operation ge (Vptr sp Ptrofs.zero) (Olea_ptr a) el m = eval_addressing ge (Vptr sp Ptrofs.zero) a el.
+  eval_operation_wrapper ge (Vptr sp Ptrofs.zero) (Olea_ptr a) el m = eval_addressing ge (Vptr sp Ptrofs.zero) a el.
 Proof.
+  i. erewrite eval_operation_no_ptr_op; [|ss].
   unfold Olea_ptr, eval_addressing; intros. destruct Archi.ptr64; auto.
 Qed.
 
@@ -92,7 +94,7 @@ Lemma const_for_result_correct:
   forall a op v,
   const_for_result a = Some op ->
   vmatch bc v a ->
-  exists v', eval_operation ge (Vptr sp Ptrofs.zero) op nil m = Some v' /\ Val.lessdef v v'.
+  exists v', eval_operation_wrapper ge (Vptr sp Ptrofs.zero) op nil m = Some v' /\ Val.lessdef v v'.
 Proof.
   unfold const_for_result. generalize Archi.ptr64; intros ptr64; intros.
   destruct a; inv H; SimplVM.
@@ -941,4 +943,207 @@ Proof.
   exists v; auto.
 Qed.
 
+Definition not_sel (op: operation): bool:=
+  match op with
+  | Osel _ _ => false
+  | _ => true
+  end.
+
+Lemma ptr_op_reduction_not_sel
+  op args vl op' args'
+  (PTROP: ptr_op op = true)
+  (NOTSE: not_sel op = true)
+  (REDUX: op_strength_reduction op args vl = (op', args'))
+  :
+  <<PTROP': ptr_op op' = true>>.
+Proof.
+  unfold op_strength_reduction in REDUX. destruct op; ss; clarify.
+  unfold ptr_cond, make_cmp in *; des_ifs. destruct c; ss; des_ifs.
+  - unfold make_cmp_base, cond_strength_reduction in *.
+    unfold cond_strength_reduction_match in REDUX. ss. des_ifs.
+  - unfold make_cmp_base, cond_strength_reduction in *.
+    unfold cond_strength_reduction_match in REDUX. ss. des_ifs.
+Qed.
+
+Lemma not_ptr_cond_reduction
+  c args vl c' args'
+  (PTRCOND: ptr_cond c = false)
+  (REDUX: cond_strength_reduction c args vl = (c', args'))
+  :
+  <<PTROP': ptr_cond c' = false>>.
+Proof.
+  revert REDUX. unfold cond_strength_reduction.
+  case (cond_strength_reduction_match c args vl) eqn:CCASE; simpl; intros; InvApproxRegs; SimplVM; clarify.
+Qed.
+
+Lemma ptr_cond_reduction
+  c args vl c' args'
+  (PTRCOND: ptr_cond c = true)
+  (REDUX: cond_strength_reduction c args vl = (c', args'))
+  :
+  <<PTROP': ptr_cond c' = true>>.
+Proof.
+  revert REDUX. unfold cond_strength_reduction.
+  case (cond_strength_reduction_match c args vl) eqn:CCASE; simpl; intros; InvApproxRegs; SimplVM; clarify.
+Qed.
+
+Lemma cond_strength_reduction_wrapper_correct
+    cond args vl
+    (ARGS: vl = map (fun r => AE.get r ae) args) :
+  let (cond', args') := cond_strength_reduction cond args vl in
+  eval_condition_wrapper cond' e##args' m = eval_condition_wrapper cond e##args m.
+Proof.
+  destruct (ptr_cond cond) eqn:PCOND.
+  2:{ des_ifs. exploit not_ptr_cond_reduction; eauto. i. do 2 (rewrite eval_condition_no_ptr_op; eauto).
+      exploit cond_strength_reduction_correct; eauto. rewrite Heq. ss. }
+  destruct cond; ss.
+  unfold cond_strength_reduction.
+  case (cond_strength_reduction_match (Ccomplu c) args vl) eqn:CMP; simpl; intros; ss; InvApproxRegs; SimplVM; ss.
+  unfold eval_condition_wrapper. rewrite PCOND.
+  assert (ptr_cond (Ccompluimm (swap_comparison c0) n1) = true) by ss. rewrite H0.
+  unfold eval_condition_join, cmplu_join_common, cmplu_join. repeat rewrite Val.swap_cmplu_bool. eauto.
+Qed.
+
+Lemma yyy n2 r1 r2 op' args':
+   make_divlimm n2 r1 r2 = (op', args') -> ptr_op op' = false.
+Proof.
+  unfold make_divlimm.
+  destruct (Int64.is_power2' n2) eqn:?; [|i; inv H; simpl; reflexivity].
+  destruct (Int.ltu i (Int.repr 63)) eqn:?; i; inv H; simpl; reflexivity.
+Qed.
+
+Lemma zzz n2 r1 r2 op' args':
+  make_divluimm n2 r1 r2 = (op', args') -> ptr_op op' = false.
+Proof.
+  unfold make_divluimm.
+  destruct (Int64.is_power2' n2) eqn:?; i; inv H; simpl; reflexivity.
+Qed.
+
+Lemma not_ptr_op_reduction op args vl op' args'
+    (PTROP: ptr_op op = false)
+    (REDUX: op_strength_reduction op args vl = (op', args')) :
+  <<PTROP': ptr_op op' = false>>.
+Proof.
+  revert REDUX. 
+  unfold op_strength_reduction;
+    case (op_strength_reduction_match op args vl) eqn:OPCASE; simpl; intros.
+  - unfold make_cast8signed in REDUX. des_ifs; clarify; ss.
+  - unfold make_cast8unsigned in REDUX. des_ifs; clarify; ss.
+  - unfold make_cast16signed in REDUX. des_ifs; clarify; ss.
+  - unfold make_cast16unsigned in REDUX. des_ifs; clarify; ss.
+  - unfold make_addimm in REDUX. des_ifs; clarify.
+  - unfold make_mulimm in *; des_ifs; clarify.
+  - unfold make_mulimm in *; des_ifs; clarify.
+  - unfold make_divimm in *; des_ifs; clarify.
+  - unfold make_divuimm in *; des_ifs; clarify.
+  - unfold make_moduimm in *; des_ifs; clarify.
+  - unfold make_andimm in *; des_ifs; clarify.
+  - unfold make_andimm in *; des_ifs; clarify.
+  - unfold make_andimm in *; des_ifs; clarify.
+  - unfold make_orimm in *; des_ifs; clarify.
+  - unfold make_orimm in *; des_ifs; clarify.
+  - unfold make_xorimm in *; des_ifs; clarify.
+  - unfold make_xorimm in *; des_ifs; clarify.
+  - unfold make_shlimm in *; des_ifs; clarify.
+  - unfold make_shrimm in *; des_ifs; clarify.
+  - unfold make_shruimm in *; des_ifs; clarify.
+  - destruct (addr_strength_reduction_32 addr args vl); ss. clarify.
+  - unfold make_addlimm in *.
+    destruct (Int64.eq (Int64.neg n2) Int64.zero); simpl in *; inv REDUX; simpl; auto.
+  - unfold make_mullimm in *; des_ifs; clarify.
+  - unfold make_mullimm in *; des_ifs; clarify.
+  - eapply yyy. eauto.
+  - eapply zzz. eauto.
+  - unfold make_modluimm in *; des_ifs; clarify.
+  - unfold make_andlimm in *; des_ifs; clarify.
+  - unfold make_andlimm in *; des_ifs; clarify.
+  - unfold make_andlimm in *; des_ifs; clarify.
+  - unfold make_orlimm in *; des_ifs; clarify.
+  - unfold make_orlimm in *; des_ifs; clarify.
+  - unfold make_xorlimm in *; des_ifs; clarify.
+  - unfold make_xorlimm in *; des_ifs; clarify.
+  - unfold make_shllimm in *; des_ifs; clarify.             
+  - unfold make_shrlimm in *; des_ifs; clarify.
+  - unfold make_shrluimm in *; des_ifs; clarify.
+  - destruct (addr_strength_reduction_64 addr args vl); ss. clarify.
+  - unfold make_cmp in REDUX. case (make_cmp_match c args vl) eqn:CMPCASE; intros.
+    + unfold make_cmp_imm_eq in REDUX. des_ifs; clarify.
+      unfold make_cmp_base in REDUX. ss. clarify.
+    + unfold make_cmp_imm_ne in REDUX. des_ifs; clarify.
+      unfold make_cmp_base in REDUX. ss. clarify.
+    + unfold make_cmp_imm_eq in REDUX. des_ifs; clarify.
+      unfold make_cmp_base in REDUX. ss. clarify.
+    + unfold make_cmp_imm_ne in REDUX. des_ifs; clarify.
+      unfold make_cmp_base in REDUX. ss. clarify.
+    + unfold make_cmp_base in REDUX.
+      destruct (cond_strength_reduction c args vl) eqn:CONDCASE; ss.
+      exploit not_ptr_cond_reduction; eauto. i. clarify.
+  - unfold make_select in REDUX. des_ifs_safe.
+    ss. exploit not_ptr_cond_reduction; eauto.
+  - unfold make_mulfimm in *; des_ifs; clarify.
+  - unfold make_mulfimm in *; des_ifs; clarify.
+  - unfold make_mulfsimm in *; des_ifs; clarify.
+  - unfold make_mulfsimm in *; des_ifs; clarify.
+  - clarify.
+Qed.  
+
+Lemma make_select_wrapper_correct:
+  forall c ty r1 r2 args vl (PTRCOND: ptr_cond c = true),
+  vl = map (fun r => AE.get r ae) args ->
+  let (op', args') := make_select c ty r1 r2 args vl in
+  exists v, eval_operation_wrapper ge (Vptr sp Ptrofs.zero) op' e##args' m = Some v
+         /\ Val.lessdef (Val.select (eval_condition_join c e##args m) e#r1 e#r2 ty) v.
+Proof.
+  unfold make_select; intros.
+  destruct (resolve_branch (eval_static_condition c vl)) as [b|] eqn:RB.
+- exists (if b then e#r1 else e#r2); split.
++ simpl. destruct b; auto.
++ destruct (eval_condition_join c e##args m) as [b'|] eqn:EC; simpl; auto.
+  assert (b = b').
+  { eapply resolve_branch_sound; eauto. 
+    rewrite <- EC. apply eval_static_condition_join_sound with bc.
+    eauto.
+    subst vl. exact (aregs_sound _ _ _ args MATCH). }
+  subst b'. apply Val.lessdef_normalize.
+- generalize (cond_strength_reduction_wrapper_correct c args vl H).
+  destruct (cond_strength_reduction c args vl) as [cond' args'] eqn:STR; intros EQ.
+  assert (PTRCOND': ptr_cond cond' = true) by (eapply ptr_cond_reduction; eauto).
+  unfold eval_operation_wrapper. ss. rewrite PTRCOND'.
+  unfold eval_condition_wrapper in EQ. rewrite PTRCOND, PTRCOND' in EQ.
+  econstructor; split. simpl; eauto. rewrite EQ; auto.
+Qed.
+
+Lemma op_strength_reduction_wrapper_correct
+    op args vl v
+    (ARGS: vl = map (fun r => AE.get r ae) args)
+    (EVAL: eval_operation_wrapper ge (Vptr sp Ptrofs.zero) op e##args m = Some v) :
+  <<EVAL': let (op', args') := op_strength_reduction op args vl in
+           exists w, eval_operation_wrapper ge (Vptr sp Ptrofs.zero) op' e##args' m = Some w /\ Val.lessdef v w>>.
+Proof.
+  destruct (ptr_op op) eqn:PTROP.
+- destruct (not_sel op) eqn:NOTSEL.
++ destruct op; ss.
+* esplits; eauto.
+* destruct cond; ss; des_ifs_safe.
+  { unfold op_strength_reduction in Heq. ss. unfold make_cmp in Heq. ss. unfold make_cmp_base in Heq. ss.
+    destruct (cond_strength_reduction (Ccomplu c) args (map (fun r : positive => AE.get r ae) args)) eqn:STR; ss.
+    clarify. unfold eval_operation_wrapper in *. ss. rewrite PTROP in EVAL.
+    exploit ptr_cond_reduction; eauto. i. rewrite H.
+    exploit cond_strength_reduction_wrapper_correct; eauto.
+    instantiate (2:=Ccomplu c). instantiate (1:=args). rewrite STR. i.
+    unfold eval_condition_wrapper in H0. rewrite PTROP, H in H0. rewrite H0. eauto. }
+  esplits; eauto.
++ destruct op; ss.
+  destruct (op_strength_reduction (Osel c t) args vl) eqn:STR; ss.
+  unfold op_strength_reduction in STR; ss. des_ifs; try by (esplits; eauto). ss.
+  exploit (make_select_wrapper_correct c t p p0 l1); eauto.
+  inv Heq. rewrite STR. i. des. esplits; eauto.
+  unfold eval_operation_wrapper in EVAL. ss. des_ifs.
+- rewrite eval_operation_no_ptr_op in EVAL; eauto. r. des_ifs.
+  exploit not_ptr_op_reduction; try eapply PTROP; eauto. i.
+  rewrite eval_operation_no_ptr_op; eauto.
+  exploit op_strength_reduction_correct; eauto. i.
+  rewrite Heq in H0. eauto.
+Qed.
+
 End STRENGTH_REDUCTION.
diff --git a/x86/IntPtrRef.v b/x86/IntPtrRef.v
new file mode 100644
index 00000000..bec2f50d
--- /dev/null
+++ b/x86/IntPtrRef.v
@@ -0,0 +1,1718 @@
+Require Import BoolEqual.
+Require Import Coqlib.
+Require Import AST.
+Require Import Integers.
+Require Import Floats.
+Require Import Values.
+Require Import Maps.
+Require Import Memory.
+Require Import Events.
+Require Import Globalenvs.
+Require Import sflib Classical.
+Require Import IntPtrRel.
+Require Import Op PointerOp.
+
+Ltac TrivialExists :=
+  match goal with
+  | [ |- exists v2, <<_ :Some ?v1 = Some v2>> /\ <<_: val_intptr _ _ v2>> ] =>
+      esplits; eauto
+  | _ => idtac
+  end.
+
+Ltac InvBind :=
+  match goal with
+  | [ H: val_intptr _ (Vint _) _ |- _ ] =>
+      inv H; InvBind
+  | [ H:  val_intptr _ (Vfloat _) _ |- _ ] =>
+      inv H; InvBind
+  | [ H: val_intptr _ (Vptr _ _) _ |- _ ] =>
+      inv H; InvBind
+  | [ H: val_intptrist _ nil _ |- _ ] =>
+      inv H; InvBind
+  | [ H: val_intptrist _ (_ :: _) _ |- _ ] =>
+      inv H; InvBind
+  | _ => idtac
+  end.
+
+Section EVAL_WRAPPER_REFINE.
+
+Variable F V: Type.
+Variable genv: Genv.t F V.
+
+Lemma eval_condition_binded_no_ptr_binary
+    m m' vl vl' c b
+    (NOTPTR: ptr_cond c = false)
+    (CONCEXT: concrete_extends m m')
+    (BIND: val_intptrist m' vl vl')
+    (COND: eval_condition c vl m = Some b) :
+  <<COND: eval_condition c vl' m' = Some b>>.
+Proof.
+  assert (SAMEVLD: forall b ofs, Mem.valid_pointer m b ofs = true -> Mem.valid_pointer m' b ofs = true).
+  { eapply valid_concrete_extends; eauto. }
+  destruct BIND; ss. destruct BIND.
+  { inv H; destruct c; ss. }
+  destruct BIND; [|ss]. inv H; inv H0; ss; destruct c; ss.
+Qed.
+
+Lemma select_binded
+    ob ob' m m' v1 v1' v2 v2' ty
+    (OB: ob = None \/ ob = ob')
+    (CONCEXT: concrete_extends m m')
+    (BIND1: val_intptr m' v1 v1')
+    (BIND2: val_intptr m' v2 v2') :
+  <<BIND: val_intptr m' (Val.select ob v1 v2 ty) (Val.select ob' v1' v2' ty)>>.
+Proof.
+  intros; unfold Val.select. destruct OB.
+- subst ob; auto. econs.
+- subst ob'; destruct ob as [b|]; auto.
+  2: { econs. }
+  eapply normalize_binded; eauto. destruct b; auto.
+Qed.
+
+Lemma symbol_address_binded m id ofs :
+  val_intptr m (Genv.symbol_address genv id ofs) (Genv.symbol_address genv id ofs).
+Proof.
+  intros. unfold Genv.symbol_address. destruct (Genv.find_symbol genv id) eqn:?; auto; econs.
+Qed.
+
+Lemma eval_addressing32_binded addr sp vl1 vl2 m2 v1
+    (BIND: val_intptrist m2 vl1 vl2)
+    (EVAL: eval_addressing32 genv sp addr vl1 = Some v1) :
+  exists v2, <<EVAL: eval_addressing32 genv sp addr vl2 = Some v2>>
+      /\ <<BIND: val_intptr m2 v1 v2>>.
+Proof.
+  destruct addr; simpl in *; FuncInv; InvBind; TrivialExists; try (by econs).
+  - eapply add_bind; eauto. econs; eauto.
+  - eapply add_bind; eauto; [eapply add_bind; eauto|econs; eauto].
+  - eapply add_bind; eauto; [|econs; eauto].
+    eapply mul_bind; eauto. econs; eauto.
+  - do 2 (eapply add_bind; eauto); [|econs; eauto].
+    eapply mul_bind; eauto. econs; eauto.
+  - eapply symbol_address_binded.
+  - eapply add_bind; eauto. eapply symbol_address_binded.
+  - eapply add_bind; eauto; [eapply symbol_address_binded|eapply mul_bind]; eauto; econs.
+  - unfold Val.offset_ptr. destruct sp; econs; eauto.
+Qed.
+
+Lemma eval_addressing64_binded addr sp vl1 vl2 m2 v1
+  (BIND: val_intptrist m2 vl1 vl2)
+  (EVAL: eval_addressing64 genv sp addr vl1 = Some v1) :
+  exists v2, <<EVAL: eval_addressing64 genv sp addr vl2 = Some v2>>
+      /\ <<BIND: val_intptr m2 v1 v2>>.
+Proof.
+  destruct addr; simpl in *; FuncInv; InvBind; TrivialExists; try (by econs).
+  - eapply addl_bind; eauto. econs; eauto.
+  - eapply addl_bind; eauto; [eapply addl_bind; eauto|econs; eauto].
+  - eapply addl_bind; eauto; [|econs; eauto].
+    eapply mull_bind; eauto. econs; eauto.
+  - do 2 (eapply addl_bind; eauto); [|econs; eauto].
+    eapply mull_bind; eauto. econs; eauto.
+  - eapply symbol_address_binded.
+  - unfold Val.offset_ptr. destruct sp; econs; eauto.
+Qed.
+
+Lemma eval_addressing_binded addr sp vl1 vl2 m2 v1
+    (BIND: val_intptrist m2 vl1 vl2)
+    (EVAL: eval_addressing genv sp addr vl1 = Some v1) :
+  exists v2, <<EVAL: eval_addressing genv sp addr vl2 = Some v2>>
+      /\ <<BIND: val_intptr m2 v1 v2>>.
+Proof.
+  unfold eval_addressing in *. destruct Archi.ptr64.
+- eapply eval_addressing64_binded; eauto.
+- eapply eval_addressing32_binded; eauto.
+Qed.
+
+Lemma to_ptr_null_id m v
+  (NULL: to_ptr_val m v = Vnullptr) : v = Vnullptr.
+Proof.
+  unfold to_ptr_val, Mem.to_ptr in *. destruct v; simpl in *.
+  2:{ destruct Archi.ptr64 eqn:SF; simpl in *; [inv NULL|].
+      destruct (Int.eq i Int.zero) eqn:A; [|des_ifs]. eapply Int.same_if_eq in A.
+      subst; eauto. ss. }
+  2:{ destruct Archi.ptr64 eqn:SF; simpl in *;[|inv NULL].
+      destruct (Int64.eq i Int64.zero) eqn:A; [|des_ifs].
+      eapply Int64.same_if_eq in A. subst. eauto. }
+  all: inv NULL.
+Qed.
+  
+Lemma psubl_to_ptr_binded m m' v1 v1' v2 v2' v
+    (BIT: Archi.ptr64 = true)
+    (CONCEXT: concrete_extends m m')
+    (BIND1: val_intptr m' v1 v1')
+    (BIND2: val_intptr m' v2 v2')
+    (PSUB: Val.psubl (to_ptr_val m v1) (to_ptr_val m v2) = v) :
+  <<PSUBP: exists v', Val.psubl (to_ptr_val m' v1') (to_ptr_val m' v2') = v'
+               /\ val_intptr m' v v'>> \/
+  <<PSUBI: exists v', Val.psubl (to_int_val m' v1') (to_int_val m' v2') = v'
+               /\ val_intptr m' v v'>>.
+Proof.
+  unfold Val.psubl in PSUB. rewrite BIT in PSUB.
+  destruct (to_ptr_val m v1) eqn:TOPTR1; subst; try (by (left; esplits; eauto; econs)).
+  { exploit to_ptr_val_ptr_or_undef; eauto. i. des; try by inv H.
+    rewrite H in TOPTR1. exploit to_ptr_null_id; eauto. i. subst.
+    destruct (to_ptr_val m v2) eqn:TOPTR2; subst; try (by (left; esplits; eauto; econs)).
+    exploit to_ptr_val_ptr_or_undef; eauto. i. des; try by inv H0.
+    rewrite H0 in TOPTR2. exploit to_ptr_null_id; eauto. i. subst.
+    right. esplits; eauto.
+    assert (v1' = Vnullptr /\ v2' = Vnullptr).
+    { inv BIND1; inv BIND2. des_ifs. }
+    des; subst. unfold to_int_val, Mem.to_int. unfold Vnullptr in *. rewrite BIT in *.
+    simpl. simpl in *. rewrite BIT. inv H. inv H0. econs. }
+  destruct (to_ptr_val m v2) eqn:TOPTR2; subst; try (by (left; esplits; eauto; econs)).
+  destruct (eq_block b b0); simpl in *; cycle 1.
+  { left. esplits; eauto. econs. }
+  subst b0. unfold to_ptr_val, Mem.to_ptr in *. rewrite BIT in *.
+  destruct v1; simpl in *;[clarify|clarify|simpl in *|clarify|clarify|simpl in *].
+  - destruct v2; simpl in *;[clarify|clarify|simpl in *|clarify|clarify|simpl in *].
+    (* int int *)
+    + inv BIND1; inv BIND2; simpl in *. left.
+      destruct (Int64.eq i1 Int64.zero) eqn:NULL1; simpl in *; [clarify| ].
+      destruct (Int64.eq i2 Int64.zero) eqn:NULL2; simpl in *; [clarify| ].
+      destruct (Mem.denormalize (Int64.unsigned i1) m) eqn:DENO1; simpl in *; [|clarify].
+      destruct (Mem.denormalize (Int64.unsigned i2) m) eqn:DENO2; simpl in *; [|clarify].
+      destruct p; destruct p0. simpl in *. inv TOPTR1; inv TOPTR2.
+      exploit denormalize_concrete_extends; try eapply DENO1; eauto. intros TOPTR1'.
+      exploit denormalize_concrete_extends; try eapply DENO2; eauto. intros TOPTR2'. des.
+      rewrite TOPTR1', TOPTR2'. simpl. rewrite BIT. simpl.
+      destruct (eq_block b b); [|contradiction]. esplits; eauto. econs.
+    (* int ptr *)
+    + destruct (Int64.eq i1 Int64.zero) eqn:NULL1; simpl in *; [clarify| ].
+      inv BIND1. inv TOPTR2.
+      destruct (Mem.denormalize (Int64.unsigned i1) m) eqn:DENO1; simpl in *; [|clarify].
+      destruct p. simpl in *. inv TOPTR1.
+      exploit denormalize_concrete_extends; try eapply DENO1; eauto. intros TOPTR1'. des.
+      rewrite TOPTR1'. simpl. inv BIND2; simpl in *;[|clarify|]; rewrite BIT.
+      * left. rewrite NULL1. simpl. rewrite BIT; simpl.
+        destruct (eq_block b b); [|contradiction]. esplits; eauto. econs.
+      * right. destruct (Mem.ptr2int b (Ptrofs.unsigned i0) m') eqn:P2I; cycle 1.
+        { clarify. }
+        rewrite BIT in *. inv H3. eapply Mem.denormalize_info in TOPTR1'. des.
+        unfold Mem.ptr2int in P2I. rewrite CONC in P2I. inv P2I. esplits; eauto.
+        assert ((Ptrofs.to_int64 (Ptrofs.sub (Ptrofs.repr (Int64.unsigned i1 - caddr)) i0))
+                = (Int64.sub i1 (Int64.repr (caddr + Ptrofs.unsigned i0)))).
+        { unfold Ptrofs.sub, Ptrofs.to_int64, Int64.sub.
+          eapply Int64.same_if_eq. unfold Int64.eq.
+          do 3 rewrite Int64.unsigned_repr_eq. do 2 rewrite Ptrofs.unsigned_repr_eq.
+          eapply Ptrofs.modulus_eq64 in BIT. rewrite BIT.
+          rewrite Zminus_mod_idemp_r. rewrite Zminus_mod_idemp_l. rewrite Z.mod_mod.
+          2:{ specialize Int64.modulus_pos. lia. }
+          replace (Int64.unsigned i1 - caddr - Ptrofs.unsigned i0)
+            with (Int64.unsigned i1 - (caddr + Ptrofs.unsigned i0)) by lia. des_ifs; lia. }
+        rewrite H. econs.
+  - destruct v2; simpl in *;[clarify|clarify|simpl in *|clarify|clarify|simpl in *].
+    (* ptr int *)
+    + destruct (Int64.eq i2 Int64.zero) eqn:NULL2; simpl in *; [clarify| ].
+      inv BIND2. inv TOPTR1.
+      destruct (Mem.denormalize (Int64.unsigned i2) m) eqn:DENO2; simpl in *; [|clarify].
+      destruct p. simpl in *. inv TOPTR2.
+      exploit denormalize_concrete_extends; try eapply DENO2; eauto. intros TOPTR2'. des.
+      rewrite TOPTR2'. simpl. inv BIND1; simpl in *;[|clarify|]; rewrite BIT.
+      * left. rewrite NULL2. simpl.
+        destruct (eq_block b b); [|contradiction]. esplits; eauto. econs.
+      * right. destruct (Mem.ptr2int b (Ptrofs.unsigned i) m') eqn:P2I; cycle 1; [clarify|].
+        rewrite BIT in *. inv H3. eapply Mem.denormalize_info in TOPTR2'. des.
+        unfold Mem.ptr2int in P2I. rewrite CONC in P2I. inv P2I. esplits; eauto.
+        assert (Ptrofs.to_int64 (Ptrofs.sub i (Ptrofs.repr (Int64.unsigned i2 - caddr)))
+                = Int64.sub (Int64.repr (caddr + Ptrofs.unsigned i)) i2).
+        { unfold Ptrofs.sub, Ptrofs.to_int64, Int64.sub. eapply Int64.same_if_eq. unfold Int64.eq.
+          do 3 rewrite Int64.unsigned_repr_eq. do 2 rewrite Ptrofs.unsigned_repr_eq.
+          eapply Ptrofs.modulus_eq64 in BIT. rewrite BIT.
+          rewrite Zminus_mod_idemp_r. rewrite Zminus_mod_idemp_l. rewrite Z.mod_mod.
+          2:{ specialize Int64.modulus_pos. lia. }
+          replace (Ptrofs.unsigned i - (Int64.unsigned i2 - caddr))
+            with (caddr + Ptrofs.unsigned i - Int64.unsigned i2) by lia. des_ifs; lia. }
+        rewrite H. econs.
+    (* ptr ptr *)
+    + unfold Val.psubl. simpl. inv TOPTR1; inv TOPTR2.
+      inv BIND1; [|clarify|].
+      * inv BIND2; [|clarify|].
+        { simpl. rewrite BIT. destruct (eq_block b b); [|contradiction]. left.
+          esplits; eauto. econs. }
+        { right. unfold to_int_val, Mem.to_int, Mem.ptr2int_v, Mem.ptr2int in *. rewrite BIT in *.
+          destruct ((Mem.mem_concrete m') ! b) eqn:CONC; inv H3. simpl. esplits; eauto.
+          assert (Ptrofs.to_int64 (Ptrofs.sub i i0)
+                  = Int64.sub (Int64.repr (z + Ptrofs.unsigned i)) (Int64.repr (z + Ptrofs.unsigned i0))).
+          { unfold Ptrofs.sub, Ptrofs.to_int64, Int64.sub. eapply Int64.same_if_eq. unfold Int64.eq.
+            repeat rewrite Int64.unsigned_repr_eq. repeat rewrite Ptrofs.unsigned_repr_eq.
+            eapply Ptrofs.modulus_eq64 in BIT. rewrite BIT.
+            rewrite Zminus_mod_idemp_r. rewrite Zminus_mod_idemp_l. rewrite Z.mod_mod.
+            2:{ specialize Int64.modulus_pos. lia. }
+            replace (Ptrofs.unsigned i - Ptrofs.unsigned i0) with (z + Ptrofs.unsigned i - (z + Ptrofs.unsigned i0)) by lia.
+            des_ifs; lia. }
+          rewrite H. econs. }
+      * inv BIND2; [|clarify|].
+        { right. unfold to_int_val, Mem.to_int, Mem.ptr2int_v, Mem.ptr2int in *. rewrite BIT in *.
+          destruct ((Mem.mem_concrete m') ! b) eqn:CONC; inv H3. simpl.
+          esplits; eauto.
+          assert (Ptrofs.to_int64 (Ptrofs.sub i i0)
+                  = Int64.sub (Int64.repr (z + Ptrofs.unsigned i)) (Int64.repr (z + Ptrofs.unsigned i0))).
+          { unfold Ptrofs.sub, Ptrofs.to_int64, Int64.sub. eapply Int64.same_if_eq. unfold Int64.eq.
+            repeat rewrite Int64.unsigned_repr_eq. repeat rewrite Ptrofs.unsigned_repr_eq.
+            eapply Ptrofs.modulus_eq64 in BIT. rewrite BIT.
+            rewrite Zminus_mod_idemp_r. rewrite Zminus_mod_idemp_l. rewrite Z.mod_mod.
+            2:{ specialize Int64.modulus_pos. lia. }
+            replace (Ptrofs.unsigned i - Ptrofs.unsigned i0) with (z + Ptrofs.unsigned i - (z + Ptrofs.unsigned i0)) by lia.
+            des_ifs; lia. }
+          rewrite H. econs. }
+        { right. unfold to_int_val, Mem.to_int, Mem.ptr2int_v, Mem.ptr2int in *.
+          destruct ((Mem.mem_concrete m') ! b) eqn:CONC; [| inv H3].
+          rewrite BIT in *. inv H3. inv H5. simpl. esplits; eauto.
+          assert (Ptrofs.to_int64 (Ptrofs.sub i i0)
+                  = Int64.sub (Int64.repr (z + Ptrofs.unsigned i)) (Int64.repr (z + Ptrofs.unsigned i0))).
+          { unfold Ptrofs.sub, Ptrofs.to_int64, Int64.sub. eapply Int64.same_if_eq. unfold Int64.eq.
+            repeat rewrite Int64.unsigned_repr_eq. repeat rewrite Ptrofs.unsigned_repr_eq.
+            eapply Ptrofs.modulus_eq64 in BIT. rewrite BIT.
+            rewrite Zminus_mod_idemp_r. rewrite Zminus_mod_idemp_l. rewrite Z.mod_mod.
+            2:{ specialize Int64.modulus_pos. lia. }
+            replace (Ptrofs.unsigned i - Ptrofs.unsigned i0) with (z + Ptrofs.unsigned i - (z + Ptrofs.unsigned i0)) by lia.
+            des_ifs; lia. }
+          rewrite H. econs. }
+Qed.
+
+Lemma psubl_to_int_binded
+    m m' v1 v1' v2 v2' v
+    (BIT: Archi.ptr64 = true)
+    (CONCEXT: concrete_extends m m')
+    (BIND1: val_intptr m' v1 v1')
+    (BIND2: val_intptr m' v2 v2')
+    (PSUB: Val.psubl (to_int_val m v1) (to_int_val m v2) = v) :
+  <<PSUBI: exists v', Val.psubl (to_int_val m' v1') (to_int_val m' v2') = v'
+               /\ val_intptr m' v v'>>.
+Proof.
+  unfold Val.psubl in PSUB. rewrite BIT in PSUB.
+  destruct (to_int_val m v1) eqn:TOINT1; clarify; try (by (esplits; eauto; econs)).
+  2:{ eapply to_int_val_int_or_undef in TOINT1. des; clarify. }
+  destruct (to_int_val m v2) eqn:TOINT2; clarify; try (by (esplits; eauto; econs)); ss.
+  exploit to_int_bind; try eapply BIND1; eauto. intros IBIND1.
+  exploit to_int_bind; try eapply BIND2; eauto. intros IBIND2. des.
+  rewrite TOINT1 in IBIND1. rewrite TOINT2 in IBIND2. inv IBIND1; inv IBIND2.
+  esplits; eauto. econs.
+Qed.
+
+Lemma psub_to_ptr_binded
+    m m' v1 v1' v2 v2' v
+    (BIT: Archi.ptr64 = false)
+    (CONCEXT: concrete_extends m m')
+    (BIND1: val_intptr m' v1 v1')
+    (BIND2: val_intptr m' v2 v2')
+    (PSUB: Val.psub (to_ptr_val m v1) (to_ptr_val m v2) = v) :
+  <<PSUBP: exists v', Val.psub (to_ptr_val m' v1') (to_ptr_val m' v2') = v'
+               /\ val_intptr m' v v'>> \/
+  <<PSUBI: exists v', Val.psub (to_int_val m' v1') (to_int_val m' v2') = v'
+               /\ val_intptr m' v v'>>.
+Proof.
+  unfold Val.psub in PSUB. rewrite BIT in PSUB.
+  destruct (to_ptr_val m v1) eqn:TOPTR1; subst; try (by (left; esplits; eauto; econs)).
+  { exploit to_ptr_val_ptr_or_undef; eauto. i. des; [inv H|inv H|].
+    rewrite H in TOPTR1. exploit to_ptr_null_id; eauto. i. subst.
+    destruct (to_ptr_val m v2) eqn:TOPTR2; subst; try (by (left; esplits; eauto; econs)).
+    exploit to_ptr_val_ptr_or_undef; eauto. i. des; [inv H|inv H|].
+    rewrite H0 in TOPTR2. exploit to_ptr_null_id; eauto. i. subst. right. esplits; eauto.
+    assert (v1' = Vnullptr /\ v2' = Vnullptr).
+    { inv BIND1; inv BIND2. des_ifs. }
+    des; subst. unfold to_int_val, Mem.to_int. unfold Vnullptr in *. rewrite BIT in *.
+    simpl. simpl in *. rewrite BIT. inv H. inv H0. econs. }
+  destruct (to_ptr_val m v2) eqn:TOPTR2; subst; try (by (left; esplits; eauto; econs)).
+  destruct (eq_block b b0); simpl in *; cycle 1.
+  { left. esplits; eauto. econs. }
+  subst b0. unfold to_ptr_val, Mem.to_ptr in *. rewrite BIT in *.
+  destruct v1; simpl in *;[clarify|simpl in *|clarify|clarify|clarify|simpl in *].
+  - destruct v2; simpl in *;[clarify|simpl in *|clarify|clarify|clarify|simpl in *].
+    (* int int *)
+    + inv BIND1; inv BIND2; simpl in *. left.
+      destruct (Int.eq i1 Int.zero) eqn:NULL1; simpl in *; [clarify| ].
+      destruct (Int.eq i2 Int.zero) eqn:NULL2; simpl in *; [clarify| ].
+      destruct (Mem.denormalize (Int.unsigned i1) m) eqn:DENO1; simpl in *; [|clarify].
+      destruct (Mem.denormalize (Int.unsigned i2) m) eqn:DENO2; simpl in *; [|clarify].
+      destruct p; destruct p0. simpl in *. inv TOPTR1; inv TOPTR2.
+      exploit denormalize_concrete_extends; try eapply DENO1; eauto. intros TOPTR1'.
+      exploit denormalize_concrete_extends; try eapply DENO2; eauto. intros TOPTR2'. des.
+      rewrite TOPTR1', TOPTR2'. simpl. rewrite BIT. simpl.
+      destruct (eq_block b b); [|contradiction]. esplits; eauto. econs.
+    (* int ptr *)
+    + inv BIND1. inv TOPTR2.
+      destruct (Int.eq i1 Int.zero) eqn:NULL1; simpl in *; [clarify| ].
+      destruct (Mem.denormalize (Int.unsigned i1) m) eqn:DENO1; simpl in *; [|clarify].
+      destruct p. simpl in *. inv TOPTR1.
+      exploit denormalize_concrete_extends; try eapply DENO1; eauto. intros TOPTR1'. des.
+      rewrite TOPTR1'. simpl. inv BIND2; simpl in *;[| |clarify]; rewrite BIT.
+      * left. destruct (eq_block b b); [|contradiction]. esplits; eauto. econs.
+      * right. destruct (Mem.ptr2int b (Ptrofs.unsigned i0) m') eqn:P2I; cycle 1; [clarify|].
+        rewrite BIT in *. inv H3. eapply Mem.denormalize_info in TOPTR1'. des.
+        unfold Mem.ptr2int in P2I. rewrite CONC in P2I. inv P2I. esplits; eauto.
+        assert ((Ptrofs.to_int (Ptrofs.sub (Ptrofs.repr (Int.unsigned i1 - caddr)) i0))
+                = (Int.sub i1 (Int.repr (caddr + Ptrofs.unsigned i0)))).
+        { unfold Ptrofs.sub, Ptrofs.to_int, Int.sub.
+          eapply Int.same_if_eq. unfold Int.eq.
+          do 3 rewrite Int.unsigned_repr_eq. do 2 rewrite Ptrofs.unsigned_repr_eq.
+          eapply Ptrofs.modulus_eq32 in BIT. rewrite BIT.
+          rewrite Zminus_mod_idemp_r. rewrite Zminus_mod_idemp_l. rewrite Z.mod_mod.
+          2:{ specialize Int.modulus_pos. lia. }
+          replace (Int.unsigned i1 - caddr - Ptrofs.unsigned i0)
+            with (Int.unsigned i1 - (caddr + Ptrofs.unsigned i0)) by lia. des_ifs; lia. }
+        rewrite H. econs.
+  - destruct v2; simpl in *;[clarify|simpl in *|clarify|clarify|clarify|simpl in *].
+    (* ptr int *)
+    + inv BIND2. inv TOPTR1.
+      destruct (Int.eq i2 Int.zero) eqn:NULL2; simpl in *; [clarify| ].
+      destruct (Mem.denormalize (Int.unsigned i2) m) eqn:DENO2; simpl in *; [|clarify].
+      destruct p. simpl in *. inv TOPTR2.
+      exploit denormalize_concrete_extends; try eapply DENO2; eauto. intros TOPTR2'. des.
+      rewrite TOPTR2'. simpl. inv BIND1; simpl in *;[| |clarify]; rewrite BIT.
+      * left. destruct (eq_block b b); [|contradiction]. esplits; eauto. econs.
+      * right. destruct (Mem.ptr2int b (Ptrofs.unsigned i) m') eqn:P2I; cycle 1;[clarify|].
+        rewrite BIT in *. inv H3. eapply Mem.denormalize_info in TOPTR2'. des.
+        unfold Mem.ptr2int in P2I. rewrite CONC in P2I. inv P2I. esplits; eauto.
+        assert (Ptrofs.to_int (Ptrofs.sub i (Ptrofs.repr (Int.unsigned i2 - caddr)))
+                = Int.sub (Int.repr (caddr + Ptrofs.unsigned i)) i2).
+        { unfold Ptrofs.sub, Ptrofs.to_int, Int.sub. eapply Int.same_if_eq. unfold Int.eq.
+          do 3 rewrite Int.unsigned_repr_eq. do 2 rewrite Ptrofs.unsigned_repr_eq.
+          eapply Ptrofs.modulus_eq32 in BIT. rewrite BIT.
+          rewrite Zminus_mod_idemp_r. rewrite Zminus_mod_idemp_l. rewrite Z.mod_mod.
+          2:{ specialize Int.modulus_pos. lia. }
+          replace (Ptrofs.unsigned i - (Int.unsigned i2 - caddr))
+            with (caddr + Ptrofs.unsigned i - Int.unsigned i2) by lia. des_ifs; lia. }
+        rewrite H. econs.
+    (* ptr ptr *)
+    + unfold Val.psub. simpl. inv TOPTR1; inv TOPTR2.
+      inv BIND1; [| |clarify].
+      * inv BIND2; [| |clarify].
+        { simpl. rewrite BIT. destruct (eq_block b b); [|contradiction]. left.
+          esplits; eauto. econs. }
+        { right. unfold to_int_val, Mem.to_int, Mem.ptr2int_v, Mem.ptr2int in *. rewrite BIT in *.
+          destruct ((Mem.mem_concrete m') ! b) eqn:CONC; inv H3. simpl. esplits; eauto.
+          assert (Ptrofs.to_int (Ptrofs.sub i i0)
+                  = Int.sub (Int.repr (z + Ptrofs.unsigned i)) (Int.repr (z + Ptrofs.unsigned i0))).
+          { unfold Ptrofs.sub, Ptrofs.to_int, Int.sub. eapply Int.same_if_eq. unfold Int.eq.
+            repeat rewrite Int.unsigned_repr_eq. repeat rewrite Ptrofs.unsigned_repr_eq.
+            eapply Ptrofs.modulus_eq32 in BIT. rewrite BIT.
+            rewrite Zminus_mod_idemp_r. rewrite Zminus_mod_idemp_l. rewrite Z.mod_mod.
+            2:{ specialize Int.modulus_pos. lia. }
+            replace (Ptrofs.unsigned i - Ptrofs.unsigned i0)
+              with (z + Ptrofs.unsigned i - (z + Ptrofs.unsigned i0)) by lia. des_ifs; lia. }
+          rewrite H. econs. }
+      * inv BIND2; [| |clarify].
+        { right. unfold to_int_val, Mem.to_int, Mem.ptr2int_v, Mem.ptr2int in *. rewrite BIT in *.
+          destruct ((Mem.mem_concrete m') ! b) eqn:CONC; inv H3. simpl. esplits; eauto.
+          assert (Ptrofs.to_int (Ptrofs.sub i i0)
+                  = Int.sub (Int.repr (z + Ptrofs.unsigned i)) (Int.repr (z + Ptrofs.unsigned i0))).
+          { unfold Ptrofs.sub, Ptrofs.to_int, Int.sub. eapply Int.same_if_eq. unfold Int.eq.
+            repeat rewrite Int.unsigned_repr_eq. repeat rewrite Ptrofs.unsigned_repr_eq.
+            eapply Ptrofs.modulus_eq32 in BIT. rewrite BIT.
+            rewrite Zminus_mod_idemp_r. rewrite Zminus_mod_idemp_l. rewrite Z.mod_mod.
+            2:{ specialize Int.modulus_pos. lia. }
+            replace (Ptrofs.unsigned i - Ptrofs.unsigned i0)
+              with (z + Ptrofs.unsigned i - (z + Ptrofs.unsigned i0)) by lia. des_ifs; lia. }
+          rewrite H. econs. }
+        { right. unfold to_int_val, Mem.to_int, Mem.ptr2int_v, Mem.ptr2int in *.
+          destruct ((Mem.mem_concrete m') ! b) eqn:CONC; [|inv H3].
+          rewrite BIT in *. inv H3. inv H5. simpl. esplits; eauto.
+          assert (Ptrofs.to_int (Ptrofs.sub i i0)
+                  = Int.sub (Int.repr (z + Ptrofs.unsigned i)) (Int.repr (z + Ptrofs.unsigned i0))).
+          { unfold Ptrofs.sub, Ptrofs.to_int, Int.sub. eapply Int.same_if_eq. unfold Int.eq.
+            repeat rewrite Int.unsigned_repr_eq. repeat rewrite Ptrofs.unsigned_repr_eq.
+            eapply Ptrofs.modulus_eq32 in BIT. rewrite BIT.
+            rewrite Zminus_mod_idemp_r. rewrite Zminus_mod_idemp_l. rewrite Z.mod_mod.
+            2:{ specialize Int.modulus_pos. lia. }
+            replace (Ptrofs.unsigned i - Ptrofs.unsigned i0)
+              with (z + Ptrofs.unsigned i - (z + Ptrofs.unsigned i0)) by lia. des_ifs; lia. }
+          rewrite H. econs. }
+Qed.
+
+Lemma psub_to_int_binded
+    m m' v1 v1' v2 v2' v
+    (BIT: Archi.ptr64 = false)
+    (CONCEXT: concrete_extends m m')
+    (BIND1: val_intptr m' v1 v1')
+    (BIND2: val_intptr m' v2 v2')
+    (PSUB: Val.psub (to_int_val m v1) (to_int_val m v2) = v) :
+  <<PSUBI: exists v', Val.psub (to_int_val m' v1') (to_int_val m' v2') = v'
+               /\ val_intptr m' v v'>>.
+Proof.
+  unfold Val.psub in PSUB. rewrite BIT in PSUB.
+  destruct (to_int_val m v1) eqn:TOINT1; inversion PSUB; try (by (esplits; eauto; econs)).
+  2:{ eapply to_int_val_int_or_undef in TOINT1. des; clarify. }
+  destruct (to_int_val m v2) eqn:TOINT2; inversion PSUB; try (by (esplits; eauto; econs)).
+  exploit to_int_bind; try eapply BIND1; eauto. intros IBIND1.
+  exploit to_int_bind; try eapply BIND2; eauto. intros IBIND2. des.
+  rewrite TOINT1 in IBIND1. rewrite TOINT2 in IBIND2. inv IBIND1; inv IBIND2.
+  esplits; eauto. unfold Val.psub. rewrite BIT. econs.
+Qed.
+
+Lemma psub_only_int_and_undef v1 v2: Val.psub v1 v2 = Vundef \/ exists n, Val.psub v1 v2 = Vint n.
+Proof. unfold Val.psub in *. des_ifs; eauto. Qed.
+
+Lemma psubl_only_long_and_undef v1 v2: Val.psubl v1 v2 = Vundef \/ exists n, Val.psubl v1 v2 = Vlong n.
+Proof. unfold Val.psubl in *. des_ifs; eauto. Qed.
+
+Lemma cmpu_bool_to_ptr_binded
+    m m' v1 v1' v2 v2' c b
+    (CONCEXT: concrete_extends m m')
+    (BIND1: val_intptr m' v1 v1')
+    (BIND2: val_intptr m' v2 v2')
+    (CMP: Val.cmpu_bool (Mem.valid_pointer m) c (to_ptr_val m v1) (to_ptr_val m v2) = Some b) :
+  <<CMPP: Val.cmpu_bool (Mem.valid_pointer m') c (to_ptr_val m' v1') (to_ptr_val m' v2') = Some b>>
+  \/ <<CMPI: Val.cmpu_bool (Mem.valid_pointer m') c (to_int_val m' v1') (to_int_val m' v2') = Some b>>.
+Proof.
+  assert (SAMEVLD: forall b ofs, Mem.valid_pointer m b ofs = true -> Mem.valid_pointer m' b ofs = true).
+  { eapply valid_concrete_extends; eauto. }
+  destruct Archi.ptr64 eqn:BIT.
+  { unfold Val.cmpu_bool in CMP. rewrite BIT in *; des_ifs;
+    unfold to_ptr_val, Mem.to_ptr in Heq, Heq0; rewrite BIT in *; des_ifs. }
+  unfold Val.cmpu_bool in CMP. rewrite BIT in CMP.
+  destruct (to_ptr_val m v1) eqn:TOPTR1; try inversion CMP.
+  { exploit to_ptr_val_ptr_or_undef; eauto. i. des; [clarify|clarify|].
+    rewrite H in TOPTR1. exploit to_ptr_null_id; eauto. i. subst.
+    destruct (to_ptr_val m v2) eqn:TOPTR2; subst; try inversion CMP.
+    { exploit to_ptr_val_ptr_or_undef; eauto. i. des; [clarify|clarify|].
+      rewrite H1 in TOPTR2. exploit to_ptr_null_id; eauto. i. subst. right. esplits; eauto.
+      assert (v1' = Vnullptr /\ v2' = Vnullptr).
+      { inv BIND1; inv BIND2. des_ifs. }
+      des; subst. unfold to_int_val, Mem.to_int. unfold Vnullptr in *. rewrite BIT in *.
+      simpl. simpl in *. inv H. inv H1. econs. }
+    simpl in *. assert (Int.eq i Int.zero = true) by (unfold Vnullptr in H; des_ifs).
+    rewrite H1 in *. simpl in *. clear H0.
+    destruct (Mem.valid_pointer m b1 (Ptrofs.unsigned i0) ||
+              Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1)) eqn:WVLD; [|inv CMP].
+    assert (v1' = Vnullptr) by (inv BIND1; des_ifs). subst. unfold to_ptr_val in *.
+    destruct v2; simpl in *; [clarify|simpl in *|rewrite BIT in *; simpl in *; clarify|clarify|clarify|simpl in *].
+    { inv BIND2. destruct (Int.eq i1 Int.zero) eqn:A; simpl in  *. { inv TOPTR2. }
+      destruct (Mem.denormalize (Int.unsigned i1) m) eqn:DENO; simpl in  *; [|inv TOPTR2].
+      destruct p; simpl in *. exploit denormalize_concrete_extends; eauto. i. des. rewrite BIT, A, H0.
+      left. unfold Val.cmplu_bool, Mem.to_ptr, Vnullptr in *. rewrite BIT, Int.eq_true in *. simpl.
+      simpl in TOPTR2. inv TOPTR2. exploit weak_valid_concrete_extends; eauto. i.
+      unfold Mem.weak_valid_pointer in H3. rewrite BIT, Int.eq_true. simpl. rewrite H3. eauto. }
+    inv TOPTR2. inv BIND2; [ | |clarify].
+    { unfold Mem.to_ptr, Vnullptr. rewrite BIT, Int.eq_true. simpl. rewrite BIT, Int.eq_true. simpl.
+      left. exploit weak_valid_concrete_extends; eauto. i. unfold Mem.weak_valid_pointer in H0.
+      rewrite H0. eauto. }
+    { unfold Mem.ptr2int_v in H6. destruct (Mem.ptr2int b1 (Ptrofs.unsigned i0) m') eqn:I2P;[|clarify].
+      rewrite BIT in *. inv H6. exploit weak_valid_concrete_extends; eauto. intros WVLD'.
+      exploit Mem.ptr2int_weak_valid; eauto; [eapply Ptrofs.unsigned_range_2|]. i. inv H0. simpl in *.
+      assert (Int.eq (Int.repr z) Int.zero = false).
+      { unfold Int.eq. rewrite Int.unsigned_repr.
+        2:{ unfold Int.max_unsigned. rewrite <- Ptrofs.modulus_eq32; eauto. lia. }
+        destruct (zeq z (Int.unsigned Int.zero)) eqn:ZEQ;[|eauto]. subst.
+        rewrite Int.unsigned_zero in FST. lia. }
+      right. unfold Vnullptr. rewrite BIT. simpl.
+      destruct c; simpl in *; inv CMP.
+      { rewrite Int.eq_sym. rewrite I2P, BIT in H3. inv H3. rewrite H0. eauto. }
+      { rewrite Int.eq_sym. rewrite I2P, BIT in H3. inv H3. rewrite H0. eauto. } } }
+  destruct (to_ptr_val m v2) eqn:TOPTR2; try inversion CMP.
+  { exploit to_ptr_val_ptr_or_undef; eauto. i. des; [clarify|clarify|].
+    rewrite H in TOPTR2. exploit to_ptr_null_id; eauto. i. subst.
+    assert (v2' = Vnullptr) by (inv BIND2; des_ifs). subst.
+    destruct ((Mem.valid_pointer m b0 (Ptrofs.unsigned i) || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1))) eqn:WVLD.
+    2:{ simpl in *. rewrite andb_false_r in CMP. inv CMP. }
+    unfold to_ptr_val in *.
+    destruct v1; simpl in *; [clarify|simpl in *|rewrite BIT in *; simpl in *; clarify|clarify|clarify|simpl in *].
+    { inv BIND1. destruct (Int.eq i1 Int.zero) eqn:A; simpl in  *. { inv TOPTR1. }
+      destruct (Mem.denormalize (Int.unsigned i1) m) eqn:DENO; simpl in  *;[|inv TOPTR1].
+      destruct p; simpl in *. exploit denormalize_concrete_extends; eauto. i. des. rewrite BIT, A, H2.
+      left. unfold Val.cmplu_bool, Mem.to_ptr, Vnullptr in *. rewrite BIT, Int.eq_true in *. simpl.
+      simpl in TOPTR1. inv TOPTR1. exploit weak_valid_concrete_extends; eauto. i.
+      unfold Mem.weak_valid_pointer in H3. inv H. rewrite BIT, Int.eq_true. simpl. rewrite H3. eauto. }
+    inv TOPTR1. inv BIND1; [| |clarify].
+    { unfold Mem.to_ptr, Vnullptr in *. rewrite BIT, Int.eq_true in *. simpl. rewrite BIT, Int.eq_true. simpl.
+      left. inv H. exploit weak_valid_concrete_extends; eauto. i. unfold Mem.weak_valid_pointer in H.
+      rewrite H. eauto. }
+    { unfold Mem.ptr2int_v in H6. destruct (Mem.ptr2int b0 (Ptrofs.unsigned i) m') eqn:I2P;[|clarify].
+      rewrite BIT in *. inv H6. exploit weak_valid_concrete_extends; eauto. intros WVLD'.
+      exploit Mem.ptr2int_weak_valid; eauto; [eapply Ptrofs.unsigned_range_2|]. i. inv H2. simpl in *.
+      assert (Int.eq (Int.repr z) Int.zero = false).
+      { unfold Int.eq. rewrite Int.unsigned_repr.
+        2:{ unfold Int.max_unsigned. rewrite <- Ptrofs.modulus_eq32; eauto. lia. }
+        destruct (zeq z (Int.unsigned Int.zero)) eqn:ZEQ;[|eauto]. subst.
+        rewrite Int.unsigned_zero in FST. lia. }
+      right. unfold Vnullptr in *. rewrite BIT in *. simpl. inv H. rewrite Int.eq_true.
+      destruct c; simpl in *; inv CMP.
+      { rewrite I2P in H3. inv H3. rewrite H2. eauto. }
+      { rewrite I2P in H3. inv H3. rewrite H2. eauto. } } }
+  clear H0. destruct (eq_block b0 b1); subst.
+  (* same block *)
+  - fold (Mem.weak_valid_pointer m b1 (Ptrofs.unsigned i)) in *.
+    fold (Mem.weak_valid_pointer m b1 (Ptrofs.unsigned i0)) in *.
+    destruct (Mem.weak_valid_pointer m b1 (Ptrofs.unsigned i)
+              && Mem.weak_valid_pointer m b1 (Ptrofs.unsigned i0)) eqn:WVLD; [|inv CMP].
+    inv CMP. unfold to_ptr_val in *.
+    destruct v1; simpl in *; [clarify|simpl in *|rewrite BIT in *; simpl in *; clarify|clarify|clarify|simpl in *].
+    + rewrite BIT in TOPTR1. simpl in TOPTR1.
+      destruct v2; simpl in *; [clarify|simpl in *|rewrite BIT in *; simpl in *; clarify|clarify|clarify|simpl in *].
+      * destruct (Mem.denormalize (Int.unsigned i1) m) eqn:DENO1; [|simpl in *; clarify].
+        destruct (Mem.denormalize (Int.unsigned i2) m) eqn:DENO2; [|simpl in *; clarify].
+        rewrite BIT in TOPTR2. simpl in *. destruct p; destruct p0. simpl in *.
+        destruct (Int.eq i1 Int.zero) eqn:NULL1; simpl in *; [clarify| ].
+        destruct (Int.eq i2 Int.zero) eqn:NULL2; simpl in *; [clarify| ].
+        inv TOPTR1. inv TOPTR2. inv BIND1. inv BIND2. left. r. unfold Mem.to_ptr. rewrite BIT. simpl.
+        exploit denormalize_concrete_extends; try apply DENO1; eauto. i.
+        exploit denormalize_concrete_extends; try apply DENO2; eauto. i. des. rewrite H, H0.
+        rewrite NULL1, NULL2. simpl. eapply andb_prop in WVLD. des.
+        exploit weak_valid_concrete_extends; try eapply WVLD; eauto. intros WVLD'.
+        exploit weak_valid_concrete_extends; try eapply WVLD0; eauto. intros WVLD0'.
+        rewrite BIT. destruct (eq_block b1 b1); [|clarify].
+        unfold Mem.weak_valid_pointer in WVLD', WVLD0'. rewrite WVLD', WVLD0'. eauto.
+      * destruct (Mem.denormalize (Int.unsigned i1) m) eqn:DENO1.
+        2:{ simpl in *. clarify. }
+        destruct p. simpl in TOPTR1.
+        destruct (Int.eq i1 Int.zero) eqn:NULL1; simpl in *; [clarify| ].
+        inv TOPTR1. inv TOPTR2. inv BIND1. inv BIND2; [| | clarify].
+        { left. exploit denormalize_concrete_extends; eauto. i. des. unfold Mem.to_ptr. rewrite BIT, H, NULL1. simpl.
+          rewrite BIT. eapply andb_prop in WVLD. des.
+          exploit weak_valid_concrete_extends; try eapply WVLD; eauto. intros WVLD'.
+          exploit weak_valid_concrete_extends; try eapply WVLD0; eauto. intros WVLD0'.
+          destruct (eq_block b1 b1); [|clarify].
+          unfold Mem.weak_valid_pointer in WVLD', WVLD0'. rewrite WVLD', WVLD0'. eauto. }
+        { right. simpl. eapply andb_prop in WVLD. destruct WVLD as [WVLD1 WVLD2]. unfold Mem.to_int, Mem.ptr2int_v in H4.
+          destruct (Mem.ptr2int b1 (Ptrofs.unsigned i0) m') eqn:P2I; cycle 1; [inv H4|].
+          rewrite BIT in H4. inv H4.
+          exploit Mem.denormalize_info; eauto. i. des. subst.
+          eapply weak_valid_concrete_extends in WVLD2; eauto.
+          exploit Mem.ptr2int_weak_valid'; eauto; [eapply Ptrofs.unsigned_range_2|].
+          i. des. eapply extended_concrete in CONC; eauto. rewrite CONC0 in CONC. inv CONC.
+          inv INRANGE. simpl in *.
+          assert (LT: Int.ltu i1 (Int.repr (caddr + Ptrofs.unsigned i0))
+                      = Ptrofs.ltu (Ptrofs.repr (Int.unsigned i1 - caddr)) i0).
+          { unfold Ptrofs.ltu, Int.ltu. rewrite Ptrofs.unsigned_repr; [| lia].
+            rewrite Ptrofs.modulus_eq32 in SND; eauto. rewrite Int.unsigned_repr; [| unfold Int.max_unsigned; lia].
+            des_ifs; lia. }
+          assert (EQ: Int.eq i1 (Int.repr (caddr + Ptrofs.unsigned i0))
+                      = Ptrofs.eq (Ptrofs.repr (Int.unsigned i1 - caddr)) i0).
+          { unfold Ptrofs.eq, Int.eq. rewrite Ptrofs.unsigned_repr; [| lia].
+            rewrite Ptrofs.modulus_eq32 in SND; eauto. rewrite Int.unsigned_repr; [| unfold Int.max_unsigned; lia].
+            des_ifs; lia. }
+          symmetry. f_equal. eapply lt_eq_cmpu; eauto. }
+    + inversion TOPTR1; subst.
+      destruct v2; simpl in *; [clarify|simpl in *|rewrite BIT in *; simpl in *; clarify|clarify|clarify|simpl in *].
+      * destruct (Mem.denormalize (Int.unsigned i1) m) eqn:DENO2; [|simpl in *; clarify].
+        destruct p. rewrite BIT in TOPTR2. simpl in TOPTR2.
+        destruct (Int.eq i1 Int.zero) eqn:NULL1; simpl in *; [clarify| ].
+        inv TOPTR2. inv TOPTR1. inv BIND2. inv BIND1; [| |clarify].
+        { left. exploit denormalize_concrete_extends; eauto. i. des. unfold Mem.to_ptr. rewrite BIT, H, NULL1. simpl.
+          rewrite BIT. eapply andb_prop in WVLD. des.
+          exploit weak_valid_concrete_extends; try eapply WVLD; eauto. intros WVLD'.
+          exploit weak_valid_concrete_extends; try eapply WVLD0; eauto. intros WVLD0'.
+          destruct (eq_block b1 b1); [|clarify].
+          unfold Mem.weak_valid_pointer in WVLD', WVLD0'. rewrite WVLD', WVLD0'. eauto. }
+        { right. simpl. eapply andb_prop in WVLD. destruct WVLD as [WVLD1 WVLD2]. unfold Mem.to_int, Mem.ptr2int_v in H4.
+          destruct (Mem.ptr2int b1 (Ptrofs.unsigned i) m') eqn:P2I; cycle 1; [inv H4|].
+          rewrite BIT in H4. inv H4.
+          exploit Mem.denormalize_info; eauto. i. des. subst.
+          eapply weak_valid_concrete_extends in WVLD1; eauto.
+          exploit Mem.ptr2int_weak_valid'; eauto; [eapply Ptrofs.unsigned_range_2|].
+          i. des. eapply extended_concrete in CONC; eauto. rewrite CONC0 in CONC. inv CONC.
+          inv INRANGE. simpl in *.
+          assert (LT: Int.ltu (Int.repr (caddr + Ptrofs.unsigned i)) i1
+                      = Ptrofs.ltu i (Ptrofs.repr (Int.unsigned i1 - caddr))).
+          { unfold Ptrofs.ltu, Int.ltu. rewrite Ptrofs.unsigned_repr; [| lia].
+            rewrite Ptrofs.modulus_eq32 in SND; eauto. rewrite Int.unsigned_repr; [| unfold Int.max_unsigned; lia].
+            des_ifs; lia. }
+          assert (EQ: Int.eq (Int.repr (caddr + Ptrofs.unsigned i)) i1
+                      = Ptrofs.eq i (Ptrofs.repr (Int.unsigned i1 - caddr))).
+          { unfold Ptrofs.eq, Int.eq. rewrite Ptrofs.unsigned_repr; [| lia].
+            rewrite Ptrofs.modulus_eq32 in SND; eauto. rewrite Int.unsigned_repr; [| unfold Int.max_unsigned; lia].
+            des_ifs; lia. }
+          symmetry. f_equal. eapply lt_eq_cmpu; eauto. }
+      * inv TOPTR2. eapply andb_prop in WVLD. destruct WVLD as [WVLD1 WVLD2].
+        inv BIND1; [ | | clarify].
+        { inv BIND2; [ | | clarify].
+          - left. simpl. rewrite BIT. destruct (eq_block b1 b1); [|clarify].
+            exploit weak_valid_concrete_extends; try eapply WVLD1; eauto. intros WVLD1'.
+            exploit weak_valid_concrete_extends; try eapply WVLD2; eauto. intros WVLD2'.
+            unfold Mem.weak_valid_pointer in WVLD1', WVLD2'.
+            rewrite WVLD1', WVLD2'; eauto.
+          - right. unfold Mem.to_int, Mem.ptr2int_v in H4.
+            destruct (Mem.ptr2int b1 (Ptrofs.unsigned i0) m') eqn:P2I; cycle 1;[clarify|].
+            rewrite BIT in H4. inv H4. eapply weak_valid_concrete_extends in WVLD2; eauto.
+            exploit Mem.ptr2int_weak_valid'; eauto; [eapply Ptrofs.unsigned_range_2|].
+            i. des. subst. simpl. unfold to_int_val. simpl.
+            assert (I2P': Mem.ptr2int b1 (Ptrofs.unsigned i) m' = Some (caddr + (Ptrofs.unsigned i))).
+            { unfold Mem.ptr2int. rewrite CONC. eauto. }
+            eapply weak_valid_concrete_extends in WVLD1; eauto.
+            exploit Mem.ptr2int_weak_valid'; eauto; [eapply Ptrofs.unsigned_range_2|].
+            i. des. rewrite I2P', BIT. simpl. inv INRANGE; inv INRANGE0. simpl in *.
+            assert (LT: Int.ltu (Int.repr (caddr + Ptrofs.unsigned i)) (Int.repr (caddr + Ptrofs.unsigned i0))
+                        = Ptrofs.ltu i i0).
+            { unfold Ptrofs.ltu, Int.ltu. rewrite Ptrofs.modulus_eq32 in *; eauto.
+              do 2 (rewrite Int.unsigned_repr; [| unfold Int.max_unsigned; lia]).
+              des_ifs; lia. }
+            assert (EQ: Int.eq (Int.repr (caddr + Ptrofs.unsigned i)) (Int.repr (caddr + Ptrofs.unsigned i0))
+                        = Ptrofs.eq i i0).
+            { unfold Ptrofs.eq, Int.eq. rewrite Ptrofs.modulus_eq32 in *; eauto.
+              do 2 (rewrite Int.unsigned_repr; [| unfold Int.max_unsigned; lia]).
+              des_ifs; lia. }
+            symmetry. f_equal. eapply lt_eq_cmpu; eauto. }
+        { inv BIND2; [ | | clarify].
+          - right. unfold Mem.to_int, Mem.ptr2int_v in H4.
+            destruct (Mem.ptr2int b1 (Ptrofs.unsigned i) m') eqn:P2I; cycle 1;[clarify|].
+            rewrite BIT in H4. inv H4. eapply weak_valid_concrete_extends in WVLD1; eauto.
+            exploit Mem.ptr2int_weak_valid'; eauto; [eapply Ptrofs.unsigned_range_2|].
+            i. des. subst. unfold to_int_val. simpl.
+            assert (I2P': Mem.ptr2int b1 (Ptrofs.unsigned i0) m' = Some (caddr + (Ptrofs.unsigned i0))).
+            { unfold Mem.ptr2int. rewrite CONC. eauto. }
+            eapply weak_valid_concrete_extends in WVLD2; eauto.
+            exploit Mem.ptr2int_weak_valid'; eauto; [eapply Ptrofs.unsigned_range_2|].
+            i. des. rewrite I2P', BIT. simpl. inv INRANGE; inv INRANGE0. simpl in *.
+            assert (LT: Int.ltu (Int.repr (caddr + Ptrofs.unsigned i)) (Int.repr (caddr + Ptrofs.unsigned i0))
+                        = Ptrofs.ltu i i0).
+            { unfold Ptrofs.ltu, Int.ltu. rewrite Ptrofs.modulus_eq32 in *; eauto.
+              do 2 (rewrite Int.unsigned_repr; [| unfold Int.max_unsigned; lia]).
+              des_ifs; lia. }
+            assert (EQ: Int.eq (Int.repr (caddr + Ptrofs.unsigned i)) (Int.repr (caddr + Ptrofs.unsigned i0))
+                        = Ptrofs.eq i i0).
+            { unfold Ptrofs.eq, Int.eq. rewrite Ptrofs.modulus_eq32 in *; eauto.
+              do 2 (rewrite Int.unsigned_repr; [| unfold Int.max_unsigned; lia]).
+              des_ifs; lia. }
+            symmetry. f_equal. eapply lt_eq_cmpu; eauto.
+          - right. unfold Mem.to_int, Mem.ptr2int_v in *.
+            destruct (Mem.ptr2int b1 (Ptrofs.unsigned i) m') eqn:I2P; cycle 1; [inv H3|].
+            destruct (Mem.ptr2int b1 (Ptrofs.unsigned i0) m') eqn:I2P'; cycle 1; [inv H3|].
+            rewrite BIT in H4, H6. inv H4; inv H6.
+            eapply weak_valid_concrete_extends in WVLD1; eauto.
+            eapply weak_valid_concrete_extends in WVLD2; eauto.
+            exploit Mem.ptr2int_weak_valid'; try eapply I2P; eauto; [eapply Ptrofs.unsigned_range_2|].
+            exploit Mem.ptr2int_weak_valid'; try eapply I2P'; eauto; [eapply Ptrofs.unsigned_range_2|].
+            i. des. subst. simpl. inv INRANGE; inv INRANGE0. simpl in *.
+            assert (LT: Int.ltu (Int.repr (caddr + Ptrofs.unsigned i)) (Int.repr (caddr0 + Ptrofs.unsigned i0))
+                        = Ptrofs.ltu i i0).
+            { unfold Ptrofs.ltu, Int.ltu. rewrite Ptrofs.modulus_eq32 in *; eauto.
+              do 2 (rewrite Int.unsigned_repr; [| unfold Int.max_unsigned; lia]).
+              des_ifs; lia. }
+            assert (EQ: Int.eq (Int.repr (caddr + Ptrofs.unsigned i)) (Int.repr (caddr0 + Ptrofs.unsigned i0))
+                        = Ptrofs.eq i i0).
+            { unfold Ptrofs.eq, Int.eq. rewrite Ptrofs.modulus_eq32 in *; eauto.
+              do 2 (rewrite Int.unsigned_repr; [| unfold Int.max_unsigned; lia]).
+              des_ifs; lia. }
+            symmetry. f_equal. eapply lt_eq_cmpu; eauto. }
+  (* diff block *)
+  - destruct (Mem.valid_pointer m b0 (Ptrofs.unsigned i) && Mem.valid_pointer m b1 (Ptrofs.unsigned i0)) eqn:VLD;
+    [| clarify]. unfold to_ptr_val in *.
+    destruct v1; simpl in *; [clarify|rewrite BIT in *; simpl in *|simpl in *; clarify|clarify|clarify|simpl in *].
+    + destruct v2; simpl in *; [clarify|simpl in *|rewrite BIT in *; simpl in *; clarify|clarify|clarify|simpl in *].
+      * destruct (Mem.denormalize (Int.unsigned i1) m) eqn:DENO1; [|simpl in *; clarify].
+        destruct (Mem.denormalize (Int.unsigned i2) m) eqn:DENO2; [|simpl in *; clarify].
+        rewrite BIT in TOPTR2. simpl in *. destruct p; destruct p0. simpl in *.
+        destruct (Int.eq i1 Int.zero) eqn:NULL1; simpl in *; [clarify| ].
+        destruct (Int.eq i2 Int.zero) eqn:NULL2; simpl in *; [clarify| ].
+        inv TOPTR1. inv TOPTR2.
+        inv BIND1. inv BIND2. left. r. unfold Mem.to_ptr. rewrite BIT, NULL1, NULL2. simpl.
+        exploit denormalize_concrete_extends; try apply DENO1; eauto. i.
+        exploit denormalize_concrete_extends; try apply DENO2; eauto. i. des. rewrite H, H0. simpl.
+        eapply andb_prop in VLD. des.
+        exploit valid_concrete_extends; try eapply VLD; eauto. intros VLD'.
+        exploit valid_concrete_extends; try eapply VLD0; eauto. intros VLD0'.
+        rewrite BIT. destruct (eq_block b0 b1); [subst; clarify|].
+        rewrite VLD', VLD0'. eauto.
+      * destruct (Mem.denormalize (Int.unsigned i1) m) eqn:DENO1; [|simpl in *; clarify].
+        destruct p. simpl in TOPTR1.
+        destruct (Int.eq i1 Int.zero) eqn:NULL1; simpl in *; [clarify| ].
+        inv TOPTR1. inv TOPTR2. inv BIND1. inv BIND2; [| |clarify].
+        { left. exploit denormalize_concrete_extends; eauto. i. des. unfold Mem.to_ptr. rewrite BIT, H, NULL1. simpl.
+          rewrite BIT. eapply andb_prop in VLD. des.
+          exploit valid_concrete_extends; try eapply VLD; eauto. intros VLD'.
+          exploit valid_concrete_extends; try eapply VLD0; eauto. intros VLD0'.
+          destruct (eq_block b0 b1); [subst; clarify|]. rewrite VLD', VLD0'. eauto. }
+        { simpl. eapply andb_prop in VLD. destruct VLD as [VLD1 VLD2]. unfold Mem.to_int, Mem.ptr2int_v in H4.
+          destruct (Mem.ptr2int b1 (Ptrofs.unsigned i0) m') eqn:P2I; cycle 1;[inv H4|].
+          rewrite BIT in H4. inv H4. exploit Mem.denormalize_info; eauto. i. des. subst. 
+          assert (INBLK1: Mem.addr_in_block (Mem.mem_concrete m) (Mem.mem_access m) (Int.unsigned i1) b0).
+          { eapply Mem.conditions_of_addr_in_block; eauto. }
+          exploit Mem.valid_pointer_implies; try eapply VLD2. i.
+          eapply weak_valid_concrete_extends in H; eauto.
+          exploit Mem.ptr2int_weak_valid'; eauto;[eapply Ptrofs.unsigned_range_2|].
+          i. des. subst. inv INRANGE. simpl in *.
+          assert (INBLK2: Mem.addr_in_block (Mem.mem_concrete m') (Mem.mem_access m') (caddr0 + Ptrofs.unsigned i0) b1).
+          { eapply Mem.conditions_of_addr_in_block; eauto.
+            - replace (caddr0 + Ptrofs.unsigned i0 - caddr0) with (Ptrofs.unsigned i0) by lia.
+              eapply SAMEVLD in VLD2. rewrite Mem.valid_pointer_nonempty_perm in VLD2; eauto.
+              eapply Mem.perm_cur_max. eauto.
+            - replace (caddr0 + Ptrofs.unsigned i0 - caddr0) with (Ptrofs.unsigned i0) by lia.
+              eapply Ptrofs.unsigned_range_2. }
+          assert (INBLK1': Mem.addr_in_block (Mem.mem_concrete m') (Mem.mem_access m') (Int.unsigned i1) b0).
+          { inv INBLK1. econs; eauto; [eapply extended_concrete; eauto|].
+            des. exploit extended_access; eauto. i. unfold Mem.perm, Mem.perm_order' in H0. des_ifs; eauto. }
+          exploit Ptrofs.modulus_eq32; eauto. i.
+          assert (Int.eq i1 (Int.repr (caddr0 + Ptrofs.unsigned i0)) = false).
+          { unfold Int.eq. rewrite Int.unsigned_repr.
+            2:{ unfold Int.max_unsigned. rewrite <- H0. lia. }
+            destruct (zeq (Int.unsigned i1) (caddr0 + Ptrofs.unsigned i0)) eqn:ZEQ;[|eauto].
+            { rewrite <- e in INBLK2. exfalso. eapply n. eapply Mem.no_concrete_overlap; eauto. } }
+          destruct c; simpl in *; inversion CMP; (right; rewrite H3; eauto). }
+    + inversion TOPTR1; subst.
+      destruct v2; simpl in *; [clarify|simpl in *|rewrite BIT in *; simpl in *; clarify|clarify|clarify|simpl in *].
+      * destruct (Mem.denormalize (Int.unsigned i1) m) eqn:DENO2; [|simpl in *; clarify].
+        destruct p. simpl in TOPTR2. rewrite BIT in TOPTR2. simpl in *.
+        destruct (Int.eq i1 Int.zero) eqn:NULL1; simpl in *; [clarify| ].
+        inv TOPTR2. inv BIND2. inv BIND1; [| |clarify].
+        { left. exploit denormalize_concrete_extends; eauto. i. des. unfold Mem.to_ptr. rewrite BIT, H, NULL1. simpl.
+          rewrite BIT. eapply andb_prop in VLD. des.
+          exploit valid_concrete_extends; try eapply VLD; eauto. intros VLD'.
+          exploit valid_concrete_extends; try eapply VLD0; eauto. intros VLD0'.
+          destruct (eq_block b0 b1); [subst; clarify|]. rewrite VLD', VLD0'. eauto. }
+        { simpl. eapply andb_prop in VLD. destruct VLD as [VLD1 VLD2]. unfold Mem.to_int, Mem.ptr2int_v in H4.
+          destruct (Mem.ptr2int b0 (Ptrofs.unsigned i) m') eqn:P2I; cycle 1; [inv H4|].
+          rewrite BIT in H4. inv H4.
+          exploit Mem.denormalize_info; eauto. i. des. subst. 
+          assert (INBLK1: Mem.addr_in_block (Mem.mem_concrete m) (Mem.mem_access m) (Int.unsigned i1) b1).
+          { eapply Mem.conditions_of_addr_in_block; eauto. }
+          exploit Mem.valid_pointer_implies; try eapply VLD1. i.
+          eapply weak_valid_concrete_extends in H; eauto.
+          exploit Mem.ptr2int_weak_valid'; eauto; [eapply Ptrofs.unsigned_range_2|].
+          i. des. subst. inv INRANGE. simpl in *.
+          assert (INBLK2: Mem.addr_in_block (Mem.mem_concrete m') (Mem.mem_access m') (caddr0 + Ptrofs.unsigned i) b0).
+          { eapply Mem.conditions_of_addr_in_block; eauto.
+            - replace (caddr0 + Ptrofs.unsigned i - caddr0) with (Ptrofs.unsigned i) by lia.
+              eapply SAMEVLD in VLD1. rewrite Mem.valid_pointer_nonempty_perm in VLD1; eauto.
+              eapply Mem.perm_cur_max. eauto.
+            - replace (caddr0 + Ptrofs.unsigned i - caddr0) with (Ptrofs.unsigned i) by lia.
+              eapply Ptrofs.unsigned_range_2. }
+          assert (INBLK1': Mem.addr_in_block (Mem.mem_concrete m') (Mem.mem_access m') (Int.unsigned i1) b1).
+          { inv INBLK1. econs; eauto; [eapply extended_concrete; eauto|].
+            des. exploit extended_access; eauto. i. unfold Mem.perm, Mem.perm_order' in H0. des_ifs; eauto. }
+          exploit Ptrofs.modulus_eq32; eauto. i.
+          assert (Int.eq (Int.repr (caddr0 + Ptrofs.unsigned i)) i1 = false).
+          { unfold Int.eq. rewrite Int.unsigned_repr; [|unfold Int.max_unsigned; rewrite <- H0; lia].
+            destruct (zeq (caddr0 + Ptrofs.unsigned i) (Int.unsigned i1)) eqn:ZEQ;[|eauto].
+            { rewrite e in INBLK2. exfalso. eapply n. eapply Mem.no_concrete_overlap; eauto. } }
+          destruct c; simpl in *; inversion CMP; right; rewrite H3; eauto. }
+      * inv TOPTR2. eapply andb_prop in VLD. destruct VLD as [VLD1 VLD2].
+        inv BIND1; [ | | clarify].
+        { inv BIND2; [ | | clarify].
+          - simpl. rewrite BIT. destruct (eq_block b0 b1); [subst;clarify|].
+            eapply SAMEVLD in VLD1, VLD2. rewrite VLD1, VLD2. simpl. eauto.
+          - unfold Mem.to_int, Mem.ptr2int_v in H4.
+            destruct (Mem.ptr2int b1 (Ptrofs.unsigned i0) m') eqn:P2I;[|inv H4].
+            rewrite BIT in *. inv H4. exploit Mem.ptr2int_to_denormalize; eauto.
+            { eapply Ptrofs.unsigned_range_2. }
+            i. des. exploit Mem.denormalize_paddr_in_range; eauto.  i. inv H0.
+            unfold fst, snd in *.
+            left. simpl. rewrite BIT. simpl. rewrite Int.unsigned_repr.
+            2:{ unfold Int.max_unsigned. rewrite <- Ptrofs.modulus_eq32; eauto. lia. }
+            destruct (Int.eq (Int.repr z) Int.zero) eqn:NULL.
+            { eapply Mem.denormalized_not_nullptr32 in H; eauto. clarify. }
+            simpl. rewrite H. simpl. destruct (eq_block b0 b1); [subst; clarify|].
+            eapply SAMEVLD in VLD1, VLD2. rewrite Ptrofs.repr_unsigned.
+            rewrite VLD1, VLD2. simpl. eauto. }
+        { inv BIND2; [ | | clarify].
+          - unfold Mem.to_int, Mem.ptr2int_v in H4.
+            destruct (Mem.ptr2int b0 (Ptrofs.unsigned i) m') eqn:P2I; [|inv H4].
+            rewrite BIT in *. inv H4. exploit Mem.ptr2int_to_denormalize; eauto.
+            { eapply Ptrofs.unsigned_range_2. }
+            i. des. exploit Mem.denormalize_paddr_in_range; eauto. i. inv H0.
+            unfold fst, snd in *.
+            left. simpl. rewrite BIT. simpl. rewrite Int.unsigned_repr.
+            2:{ unfold Int.max_unsigned. rewrite <- Ptrofs.modulus_eq32; eauto. lia. }
+            destruct (Int.eq (Int.repr z) Int.zero) eqn:NULL.
+            { eapply Mem.denormalized_not_nullptr32 in H; eauto. clarify. }
+            simpl.  rewrite H. simpl. destruct (eq_block b0 b1); [subst; clarify|].
+            eapply SAMEVLD in VLD1, VLD2. rewrite Ptrofs.repr_unsigned. rewrite VLD1, VLD2.
+            rewrite BIT. eauto.
+          - unfold Mem.to_int, Mem.ptr2int_v in H4, H6.
+            destruct (Mem.ptr2int b0 (Ptrofs.unsigned i) m') eqn:P2I;[|inv H4].
+            destruct (Mem.ptr2int b1 (Ptrofs.unsigned i0) m') eqn:P2I';[|inv H6].
+            rewrite BIT in *. inv H4; inv H6.
+            exploit Mem.ptr2int_to_denormalize; try eapply P2I; eauto; i.
+            { eapply Ptrofs.unsigned_range_2. }
+            exploit Mem.ptr2int_to_denormalize; try eapply P2I'; eauto; i; des.
+            { eapply Ptrofs.unsigned_range_2. }
+            exploit Mem.denormalize_paddr_in_range; try eapply H; eauto. i. inv H4.
+            exploit Mem.denormalize_paddr_in_range; try eapply H0; eauto. i. inv H4.
+            unfold fst, snd in *. left. simpl. rewrite BIT. simpl.
+            rewrite Int.unsigned_repr.
+            2:{ unfold Int.max_unsigned. rewrite <- Ptrofs.modulus_eq32; eauto. lia. }
+            rewrite Int.unsigned_repr.
+            2:{ unfold Int.max_unsigned. rewrite <- Ptrofs.modulus_eq32; eauto. lia. }
+            destruct (Int.eq (Int.repr z) Int.zero) eqn:NULL.
+            { eapply Mem.denormalized_not_nullptr32 in H; eauto. clarify. }
+            simpl. destruct (Int.eq (Int.repr z0) Int.zero) eqn:NULL'.
+            { eapply Mem.denormalized_not_nullptr32 in H; eauto. clarify. }
+            simpl. rewrite H, H0. simpl. rewrite BIT. destruct (eq_block b0 b1); [subst; clarify|].
+            eapply SAMEVLD in VLD1, VLD2. do 2 rewrite Ptrofs.repr_unsigned. rewrite VLD1, VLD2. eauto. }
+Qed.
+
+Lemma cmpu_bool_to_int_binded
+  m m' v1 v1' v2 v2' c b
+  (CONCEXT: concrete_extends m m')
+  (BIND1: val_intptr m' v1 v1')
+  (BIND2: val_intptr m' v2 v2')
+  (CMP: Val.cmpu_bool (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2) = Some b) :
+  <<CMPI: Val.cmpu_bool (Mem.valid_pointer m') c (to_int_val m' v1') (to_int_val m' v2') = Some b>>.
+Proof.
+  destruct Archi.ptr64 eqn:BIT.
+  { unfold Val.cmpu_bool in CMP. rewrite BIT in *; des_ifs
+    ;unfold to_int_val, Mem.to_int in Heq, Heq0; des_ifs; simpl in *; clarify; des_ifs;
+      inv BIND1; inv BIND2; simpl; eauto. }
+  unfold Val.cmpu_bool in CMP. rewrite BIT in CMP.
+  destruct (to_int_val m v1) eqn:TOINT1; inversion CMP.
+  2:{ eapply to_int_val_int_or_undef in TOINT1. des; clarify. }
+  destruct (to_int_val m v2) eqn:TOINT2; inv CMP.
+  2:{ eapply to_int_val_int_or_undef in TOINT1. des; clarify. }
+  exploit to_int_bind; try eapply BIND1; eauto. intros IBIND1.
+  exploit to_int_bind; try eapply BIND2; eauto. intros IBIND2. des.
+  rewrite TOINT1 in IBIND1. rewrite TOINT2 in IBIND2. inv IBIND1; inv IBIND2.
+  simpl. eauto.
+Qed.
+
+Lemma cmplu_bool_to_ptr_binded
+    m m' v1 v1' v2 v2' c b
+    (CONCEXT: concrete_extends m m')
+    (BIND1: val_intptr m' v1 v1')
+    (BIND2: val_intptr m' v2 v2')
+    (CMP: Val.cmplu_bool (Mem.valid_pointer m) c (to_ptr_val m v1) (to_ptr_val m v2) = Some b) :
+  <<CMPP: Val.cmplu_bool (Mem.valid_pointer m') c (to_ptr_val m' v1') (to_ptr_val m' v2') = Some b>>
+  \/ <<CMPI: Val.cmplu_bool (Mem.valid_pointer m') c (to_int_val m' v1') (to_int_val m' v2') = Some b>>.
+Proof.
+  assert (SAMEVLD: forall b ofs, Mem.valid_pointer m b ofs = true -> Mem.valid_pointer m' b ofs = true).
+  { eapply valid_concrete_extends; eauto. }
+  destruct Archi.ptr64 eqn:BIT.
+  2:{ unfold Val.cmplu_bool in CMP. rewrite BIT in *; des_ifs;
+      unfold to_ptr_val, Mem.to_ptr in Heq, Heq0; rewrite BIT in *; des_ifs. }
+  unfold Val.cmplu_bool in CMP. rewrite BIT in CMP.
+  destruct (to_ptr_val m v1) eqn:TOPTR1; try inversion CMP.
+  { exploit to_ptr_val_ptr_or_undef; eauto. i. des; try by inv H.
+    rewrite H in TOPTR1. exploit to_ptr_null_id; eauto. i. subst.
+    destruct (to_ptr_val m v2) eqn:TOPTR2; subst; try by inv H0.
+    { exploit to_ptr_val_ptr_or_undef; eauto. i. des; try by inv H1.
+      rewrite H1 in TOPTR2. exploit to_ptr_null_id; eauto. i. subst. right. esplits; eauto.
+      assert (v1' = Vnullptr /\ v2' = Vnullptr).
+      { inv BIND1; inv BIND2. des_ifs. }
+      des; subst. unfold to_int_val, Mem.to_int. unfold Vnullptr in *. rewrite BIT in *.
+      simpl. simpl in *. inv H. inv H1. econs. }
+    simpl in *. assert (Int64.eq i Int64.zero = true) by (unfold Vnullptr in H; des_ifs).
+    rewrite H1 in *. simpl in *. clear H0.
+    destruct (Mem.valid_pointer m b1 (Ptrofs.unsigned i0)
+              || Mem.valid_pointer m b1 (Ptrofs.unsigned i0 - 1)) eqn:WVLD; [|inv CMP].
+    assert (v1' = Vnullptr) by (inv BIND1; des_ifs). subst. unfold to_ptr_val in *.
+    destruct v2; simpl in *; [clarify|clarify|rewrite BIT in *; simpl in *; clarify|clarify|clarify|simpl in *].
+    { inv BIND2. destruct (Int64.eq i1 Int64.zero) eqn:A; simpl in  *. { inv TOPTR2. }
+      destruct (Mem.denormalize (Int64.unsigned i1) m) eqn:DENO; simpl in  *; [|inv TOPTR2].
+      destruct p; simpl in *. exploit denormalize_concrete_extends; eauto. i. des. rewrite BIT, A, H0.
+      left. unfold Val.cmplu_bool, Mem.to_ptr, Vnullptr in *. rewrite BIT, Int64.eq_true in *. simpl.
+      exploit weak_valid_concrete_extends; try eapply WVLD; eauto. intros WVLD'.
+      inv TOPTR2. unfold Mem.weak_valid_pointer in WVLD'. rewrite WVLD', Int64.eq_true. simpl; eauto. }
+    inv TOPTR2. inv BIND2; [|clarify|].
+    { unfold Mem.to_ptr, Vnullptr. rewrite BIT, Int64.eq_true. simpl. rewrite BIT, Int64.eq_true. simpl.
+      left. exploit weak_valid_concrete_extends; try eapply WVLD; eauto. intros WVLD'.
+      unfold Mem.weak_valid_pointer in WVLD'. rewrite WVLD'. eauto. }
+    { simpl in H5. unfold Mem.ptr2int_v in H5. destruct (Mem.ptr2int b1 (Ptrofs.unsigned i0) m') eqn:I2P;[|clarify].
+      rewrite BIT in *. inv H5. eapply weak_valid_concrete_extends in WVLD; eauto.
+      exploit Mem.ptr2int_weak_valid; eauto; [eapply Ptrofs.unsigned_range_2|]. i. inv H0. simpl in *.
+      assert (Int64.eq (Int64.repr z) Int64.zero = false).
+      { unfold Int64.eq. rewrite Int64.unsigned_repr.
+        2:{ unfold Int64.max_unsigned. rewrite <- Ptrofs.modulus_eq64; eauto. lia. }
+        destruct (zeq z (Int64.unsigned Int64.zero)) eqn:ZEQ;[|eauto]. subst.
+        rewrite Int64.unsigned_zero in FST. lia. }
+      right. unfold Vnullptr. rewrite BIT. simpl.
+      destruct c; simpl in *; inv CMP; rewrite Int64.eq_sym; rewrite H0; eauto. } }
+  destruct (to_ptr_val m v2) eqn:TOPTR2; try inversion CMP.
+  { exploit to_ptr_val_ptr_or_undef; eauto. i. des; [clarify|clarify|].
+    rewrite H in TOPTR2. exploit to_ptr_null_id; eauto. i. subst.
+    assert (v2' = Vnullptr) by (inv BIND2; des_ifs). subst.
+    destruct ((Mem.valid_pointer m b0 (Ptrofs.unsigned i) || Mem.valid_pointer m b0 (Ptrofs.unsigned i - 1))) eqn:WVLD.
+    2:{ simpl in *. rewrite andb_false_r in CMP. inv CMP. }
+    unfold to_ptr_val in *.
+    destruct v1; simpl in *; [clarify|clarify|rewrite BIT in *; simpl in *; clarify|clarify|clarify|simpl in *].
+    { inv BIND1. destruct (Int64.eq i1 Int64.zero) eqn:A; simpl in  *. { inv TOPTR1. }
+      destruct (Mem.denormalize (Int64.unsigned i1) m) eqn:DENO; simpl in  *; [|inv TOPTR1].
+      destruct p; simpl in *. exploit denormalize_concrete_extends; eauto. i. des. rewrite BIT, A, H2.
+      left. unfold Val.cmplu_bool, Mem.to_ptr, Vnullptr in *. rewrite BIT, Int64.eq_true in *. simpl.
+      exploit weak_valid_concrete_extends; try eapply WVLD; eauto. intros WVLD'. inv TOPTR1.
+      unfold Mem.weak_valid_pointer in WVLD'. rewrite WVLD', Int64.eq_true. inv H; simpl; eauto. }
+    inv TOPTR1. inv BIND1; [|clarify|].
+    { unfold Mem.to_ptr, Vnullptr in *. rewrite BIT, Int64.eq_true in *. simpl. rewrite BIT, Int64.eq_true. simpl.
+      left. eapply weak_valid_concrete_extends in WVLD; eauto.
+      unfold Mem.weak_valid_pointer in WVLD. rewrite WVLD. inv H; eauto. }
+    { simpl in H6. unfold Mem.ptr2int_v in H6. destruct (Mem.ptr2int b0 (Ptrofs.unsigned i) m') eqn:I2P;[|clarify].
+      rewrite BIT in *. inv H6. eapply weak_valid_concrete_extends in WVLD; eauto.
+      exploit Mem.ptr2int_weak_valid; eauto; [eapply Ptrofs.unsigned_range_2|]. i. inv H2. simpl in *.
+      assert (Int64.eq (Int64.repr z) Int64.zero = false).
+      { unfold Int64.eq. rewrite Int64.unsigned_repr.
+        2:{ unfold Int64.max_unsigned. rewrite <- Ptrofs.modulus_eq64; eauto. lia. }
+        destruct (zeq z (Int64.unsigned Int64.zero)) eqn:ZEQ;[|eauto]. subst.
+        rewrite Int64.unsigned_zero in FST. lia. }
+      right. unfold Vnullptr in *. rewrite BIT in *. simpl. inv H. rewrite Int64.eq_true.
+      destruct c; simpl in *; inv CMP; rewrite H2; eauto. } }
+  clear H0. destruct (eq_block b0 b1); subst.
+  (* same block *)
+  - fold (Mem.weak_valid_pointer m b1 (Ptrofs.unsigned i)) in *.
+    fold (Mem.weak_valid_pointer m b1 (Ptrofs.unsigned i0)) in *.
+    destruct (Mem.weak_valid_pointer m b1 (Ptrofs.unsigned i)
+              && Mem.weak_valid_pointer m b1 (Ptrofs.unsigned i0)) eqn:WVLD; [|inv CMP].
+    inv CMP. unfold to_ptr_val in *.
+    destruct v1; simpl in *; [clarify|clarify|rewrite BIT in *; simpl in *; clarify|clarify|clarify|simpl in *].
+    + destruct v2; simpl in *; [clarify|clarify|rewrite BIT in *; simpl in *; clarify|clarify|clarify|simpl in *].
+      * destruct (Int64.eq i1 Int64.zero) eqn:NULL1; simpl in *; [clarify| ].
+        destruct (Int64.eq i2 Int64.zero) eqn:NULL2; simpl in *; [clarify| ].
+        destruct (Mem.denormalize (Int64.unsigned i1) m) eqn:DENO1; [|simpl in *; clarify].
+        destruct (Mem.denormalize (Int64.unsigned i2) m) eqn:DENO2; [|simpl in *; clarify].
+        simpl in *. destruct p; destruct p0. simpl in *. inv TOPTR1. inv TOPTR2.
+        inv BIND1. inv BIND2. left. r. unfold Mem.to_ptr. rewrite BIT. simpl.
+        exploit denormalize_concrete_extends; try apply DENO1; eauto. i.
+        exploit denormalize_concrete_extends; try apply DENO2; eauto. i. des. rewrite H, H0. simpl.
+        rewrite NULL1, NULL2. simpl. eapply andb_prop in WVLD. des.
+        eapply weak_valid_concrete_extends in WVLD, WVLD0; eauto.
+        rewrite BIT. destruct (eq_block b1 b1); [|clarify].
+        unfold Mem.weak_valid_pointer in WVLD, WVLD0. rewrite WVLD, WVLD0. eauto.
+      * destruct (Int64.eq i1 Int64.zero) eqn:NULL1; simpl in *; [clarify| ].
+        destruct (Mem.denormalize (Int64.unsigned i1) m) eqn:DENO1; [|simpl in *; clarify].
+        destruct p. simpl in TOPTR1. inv TOPTR1. inv TOPTR2. inv BIND1. inv BIND2.
+        { left. exploit denormalize_concrete_extends; eauto. i. des. unfold Mem.to_ptr. rewrite BIT, H, NULL1. simpl.
+          rewrite BIT. eapply andb_prop in WVLD. des.
+          eapply weak_valid_concrete_extends in WVLD, WVLD0; eauto.
+          destruct (eq_block b1 b1); [|clarify].
+          unfold Mem.weak_valid_pointer in WVLD, WVLD0. rewrite WVLD, WVLD0. eauto. }
+        { clarify. }
+        { right. simpl. eapply andb_prop in WVLD. destruct WVLD as [WVLD1 WVLD2]. simpl in H4. unfold Mem.ptr2int_v in H4.
+          destruct (Mem.ptr2int b1 (Ptrofs.unsigned i0) m') eqn:P2I; cycle 1; [inv H4|].
+          rewrite BIT in H4. inv H4. exploit Mem.denormalize_info; eauto. i. des. subst.
+          eapply weak_valid_concrete_extends in WVLD2; eauto.
+          exploit Mem.ptr2int_weak_valid'; eauto.
+          { eapply Ptrofs.unsigned_range_2. }
+          i. des. eapply extended_concrete in CONC; eauto. rewrite CONC0 in CONC. inv CONC.
+          inv INRANGE. simpl in *.
+          assert (LT: Int64.ltu i1 (Int64.repr (caddr + Ptrofs.unsigned i0))
+                      = Ptrofs.ltu (Ptrofs.repr (Int64.unsigned i1 - caddr)) i0).
+          { unfold Ptrofs.ltu, Int64.ltu. rewrite Ptrofs.unsigned_repr; [| lia].
+           rewrite Ptrofs.modulus_eq64 in SND; eauto. rewrite Int64.unsigned_repr; [| unfold Int64.max_unsigned; lia].
+            des_ifs; lia. }
+          assert (EQ: Int64.eq i1 (Int64.repr (caddr + Ptrofs.unsigned i0))
+                      = Ptrofs.eq (Ptrofs.repr (Int64.unsigned i1 - caddr)) i0).
+          { unfold Ptrofs.eq, Int64.eq. rewrite Ptrofs.unsigned_repr; [| lia].
+            rewrite Ptrofs.modulus_eq64 in SND; eauto. rewrite Int64.unsigned_repr; [| unfold Int64.max_unsigned; lia].
+            des_ifs; lia. }
+          symmetry. f_equal. eapply lt_eq_cmplu; eauto. }
+    + inversion TOPTR1; subst.
+      destruct v2; simpl in *; [clarify|clarify|rewrite BIT in *; simpl in *; clarify|clarify|clarify|simpl in *].
+      * destruct (Int64.eq i1 Int64.zero) eqn:NULL2; simpl in *; [clarify| ].
+        destruct (Mem.denormalize (Int64.unsigned i1) m) eqn:DENO2; [|simpl in *; clarify].
+        destruct p. simpl in TOPTR2. inv TOPTR2. inv TOPTR1. inv BIND2. inv BIND1;[|clarify|].
+        { left. exploit denormalize_concrete_extends; eauto. i. des. unfold Mem.to_ptr. rewrite BIT, H, NULL2. simpl.
+          rewrite BIT. eapply andb_prop in WVLD. des.
+          eapply weak_valid_concrete_extends in WVLD, WVLD0; eauto.
+          repeat rewrite <- SAMEVLD. destruct (eq_block b1 b1); [|clarify].
+          unfold Mem.weak_valid_pointer in WVLD, WVLD0. rewrite WVLD, WVLD0. eauto. }
+        { right. simpl. eapply andb_prop in WVLD. destruct WVLD as [WVLD1 WVLD2]. simpl in H4. unfold Mem.ptr2int_v in H4.
+          destruct (Mem.ptr2int b1 (Ptrofs.unsigned i) m') eqn:P2I; cycle 1; [inv H4|].
+          rewrite BIT in H4. inv H4. exploit Mem.denormalize_info; eauto. i. des. subst.
+          eapply weak_valid_concrete_extends in WVLD1; eauto.
+          exploit Mem.ptr2int_weak_valid'; eauto; [eapply Ptrofs.unsigned_range_2|].
+          i. des. eapply extended_concrete in CONC; eauto. rewrite CONC0 in CONC. inv CONC.
+          inv INRANGE. simpl in *.
+          assert (LT: Int64.ltu (Int64.repr (caddr + Ptrofs.unsigned i)) i1
+                      = Ptrofs.ltu i (Ptrofs.repr (Int64.unsigned i1 - caddr))).
+          { unfold Ptrofs.ltu, Int64.ltu. rewrite Ptrofs.unsigned_repr; [| lia].
+            rewrite Ptrofs.modulus_eq64 in SND; eauto. rewrite Int64.unsigned_repr; [| unfold Int64.max_unsigned; lia].
+            des_ifs; lia. }
+          assert (EQ: Int64.eq (Int64.repr (caddr + Ptrofs.unsigned i)) i1
+                      = Ptrofs.eq i (Ptrofs.repr (Int64.unsigned i1 - caddr))).
+          { unfold Ptrofs.eq, Int64.eq. rewrite Ptrofs.unsigned_repr; [| lia].
+            rewrite Ptrofs.modulus_eq64 in SND; eauto. rewrite Int64.unsigned_repr; [| unfold Int64.max_unsigned; lia].
+            des_ifs; lia. }
+          symmetry. f_equal. eapply lt_eq_cmplu; eauto. }
+      * inv TOPTR2. eapply andb_prop in WVLD. destruct WVLD as [WVLD1 WVLD2].
+        inv BIND1; [ |clarify | ].
+        { inv BIND2; [ | clarify | ].
+          - left. simpl. rewrite BIT. destruct (eq_block b1 b1); [|clarify].
+            eapply weak_valid_concrete_extends in WVLD1, WVLD2; eauto.
+            unfold Mem.weak_valid_pointer in WVLD1, WVLD2. rewrite WVLD1, WVLD2; eauto.
+          - right. simpl in H4. unfold Mem.ptr2int_v in H4.
+            destruct (Mem.ptr2int b1 (Ptrofs.unsigned i0) m') eqn:P2I; cycle 1; [clarify|].
+            rewrite BIT in H4. inv H4. eapply weak_valid_concrete_extends in WVLD2; eauto.
+            exploit Mem.ptr2int_weak_valid'; eauto; [eapply Ptrofs.unsigned_range_2|].
+            i. des. subst. simpl. unfold to_int_val. simpl.
+            assert (I2P': Mem.ptr2int b1 (Ptrofs.unsigned i) m' = Some (caddr + (Ptrofs.unsigned i))).
+            { unfold Mem.ptr2int. rewrite CONC. eauto. }
+            eapply weak_valid_concrete_extends in WVLD1; eauto.
+            exploit Mem.ptr2int_weak_valid'; eauto; [eapply Ptrofs.unsigned_range_2|].
+            i. des. rewrite I2P', BIT. simpl. inv INRANGE; inv INRANGE0. simpl in *.
+            assert (LT: Int64.ltu (Int64.repr (caddr + Ptrofs.unsigned i)) (Int64.repr (caddr + Ptrofs.unsigned i0))
+                        = Ptrofs.ltu i i0).
+            { unfold Ptrofs.ltu, Int64.ltu. rewrite Ptrofs.modulus_eq64 in *; eauto.
+              do 2 (rewrite Int64.unsigned_repr; [| unfold Int64.max_unsigned; lia]). des_ifs; lia. }
+            assert (EQ: Int64.eq (Int64.repr (caddr + Ptrofs.unsigned i)) (Int64.repr (caddr + Ptrofs.unsigned i0))
+                        = Ptrofs.eq i i0).
+            { unfold Ptrofs.eq, Int64.eq. rewrite Ptrofs.modulus_eq64 in *; eauto.
+              do 2 (rewrite Int64.unsigned_repr; [| unfold Int64.max_unsigned; lia]). des_ifs; lia. }
+            symmetry. f_equal. eapply lt_eq_cmplu; eauto. }
+        { inv BIND2; [ | | clarify]; [|clarify|].
+          - right. simpl in H4. unfold Mem.ptr2int_v in H4.
+            destruct (Mem.ptr2int b1 (Ptrofs.unsigned i) m') eqn:P2I; cycle 1; [clarify|].
+            rewrite BIT in H4. inv H4. eapply weak_valid_concrete_extends in WVLD1; eauto.
+            exploit Mem.ptr2int_weak_valid'; eauto; [eapply Ptrofs.unsigned_range_2|].
+            i. des. subst. unfold to_int_val. simpl.
+            assert (I2P': Mem.ptr2int b1 (Ptrofs.unsigned i0) m' = Some (caddr + (Ptrofs.unsigned i0))).
+            { unfold Mem.ptr2int. rewrite CONC. eauto. }
+            eapply weak_valid_concrete_extends in WVLD2; eauto.
+            exploit Mem.ptr2int_weak_valid'; eauto; [eapply Ptrofs.unsigned_range_2|].
+            i. des. rewrite I2P', BIT. simpl. inv INRANGE; inv INRANGE0. simpl in *.
+            assert (LT: Int64.ltu (Int64.repr (caddr + Ptrofs.unsigned i)) (Int64.repr (caddr + Ptrofs.unsigned i0))
+                        = Ptrofs.ltu i i0).
+            { unfold Ptrofs.ltu, Int64.ltu. rewrite Ptrofs.modulus_eq64 in *; eauto.
+              do 2 (rewrite Int64.unsigned_repr; [| unfold Int64.max_unsigned; lia]). des_ifs; lia. }
+            assert (EQ: Int64.eq (Int64.repr (caddr + Ptrofs.unsigned i)) (Int64.repr (caddr + Ptrofs.unsigned i0))
+                        = Ptrofs.eq i i0).
+            { unfold Ptrofs.eq, Int64.eq. rewrite Ptrofs.modulus_eq64 in *; eauto.
+              do 2 (rewrite Int64.unsigned_repr; [| unfold Int64.max_unsigned; lia]). des_ifs; lia. }
+            symmetry. f_equal. eapply lt_eq_cmplu; eauto.
+          - right. simpl in *. unfold Mem.ptr2int_v in *.
+            destruct (Mem.ptr2int b1 (Ptrofs.unsigned i) m') eqn:I2P; cycle 1;[inv H4|].
+            destruct (Mem.ptr2int b1 (Ptrofs.unsigned i0) m') eqn:I2P'; cycle 1;[inv H6|].
+            rewrite H3 in H4, H6. inv H4; inv H6.
+            eapply weak_valid_concrete_extends in WVLD1; eauto.
+            eapply weak_valid_concrete_extends in WVLD2; eauto.
+            exploit Mem.ptr2int_weak_valid'; try eapply I2P; eauto; [eapply Ptrofs.unsigned_range_2|].
+            exploit Mem.ptr2int_weak_valid'; try eapply I2P'; eauto; [eapply Ptrofs.unsigned_range_2|].
+            i. des. subst. simpl. inv INRANGE; inv INRANGE0. simpl in *.
+            assert (LT: Int64.ltu (Int64.repr (caddr + Ptrofs.unsigned i)) (Int64.repr (caddr0 + Ptrofs.unsigned i0))
+                        = Ptrofs.ltu i i0).
+            { unfold Ptrofs.ltu, Int64.ltu. rewrite Ptrofs.modulus_eq64 in *; eauto.
+              do 2 (rewrite Int64.unsigned_repr; [| unfold Int64.max_unsigned; lia]). des_ifs; lia. }
+            assert (EQ: Int64.eq (Int64.repr (caddr + Ptrofs.unsigned i)) (Int64.repr (caddr0 + Ptrofs.unsigned i0))
+                        = Ptrofs.eq i i0).
+            { unfold Ptrofs.eq, Int64.eq. rewrite Ptrofs.modulus_eq64 in *; eauto.
+              do 2 (rewrite Int64.unsigned_repr; [| unfold Int64.max_unsigned; lia]). des_ifs; lia. }
+            symmetry. f_equal. eapply lt_eq_cmplu; eauto. }
+  (* diff block *)
+  - destruct (Mem.valid_pointer m b0 (Ptrofs.unsigned i) && Mem.valid_pointer m b1 (Ptrofs.unsigned i0)) eqn:VLD;
+    [|clarify]. unfold to_ptr_val in *.
+    destruct v1; simpl in *; [clarify|clarify; simpl in *|simpl in *; clarify|clarify|clarify|simpl in *].
+    + destruct v2; simpl in *; [clarify|clarify|rewrite BIT in *; simpl in *; clarify|clarify|clarify|simpl in *].
+      * destruct (Int64.eq i1 Int64.zero) eqn:NULL1; simpl in *; [clarify| ].
+        destruct (Int64.eq i2 Int64.zero) eqn:NULL2; simpl in *; [clarify| ].
+        destruct (Mem.denormalize (Int64.unsigned i1) m) eqn:DENO1; [|simpl in *; clarify].
+        destruct (Mem.denormalize (Int64.unsigned i2) m) eqn:DENO2; [|simpl in *; clarify].
+        simpl in *. destruct p; destruct p0. simpl in *. inv TOPTR1. inv TOPTR2.
+        inv BIND1. inv BIND2. left. r. unfold Mem.to_ptr. rewrite BIT. simpl.
+        exploit denormalize_concrete_extends; try apply DENO1; eauto. i.
+        exploit denormalize_concrete_extends; try apply DENO2; eauto. i. des. rewrite H, H0, NULL1, NULL2. simpl.
+        eapply andb_prop in VLD. des. eapply valid_concrete_extends in VLD, VLD0; eauto.
+        rewrite BIT. destruct (eq_block b0 b1); [subst; clarify|]. rewrite VLD, VLD0. eauto.
+      * destruct (Int64.eq i1 Int64.zero) eqn:NULL1; simpl in *; [clarify| ].
+        destruct (Mem.denormalize (Int64.unsigned i1) m) eqn:DENO1; [|simpl in *; clarify].
+        destruct p. simpl in TOPTR1. inv TOPTR1. inv TOPTR2. inv BIND1. inv BIND2;[|clarify|].
+        { left. exploit denormalize_concrete_extends; eauto. i. des. unfold Mem.to_ptr. rewrite BIT, H, NULL1. simpl.
+          rewrite BIT. eapply andb_prop in VLD. des. eapply valid_concrete_extends in VLD, VLD0; eauto.
+          destruct (eq_block b0 b1); [subst; clarify|]. rewrite VLD, VLD0. eauto. }
+        { simpl. eapply andb_prop in VLD. destruct VLD as [VLD1 VLD2]. simpl in H4. unfold Mem.ptr2int_v in H4.
+          destruct (Mem.ptr2int b1 (Ptrofs.unsigned i0) m') eqn:P2I; cycle 1; [inv H4|].
+          rewrite BIT in H4. inv H4. exploit Mem.denormalize_info; eauto. i. des. subst. 
+          assert (INBLK1: Mem.addr_in_block (Mem.mem_concrete m) (Mem.mem_access m) (Int64.unsigned i1) b0).
+          { eapply Mem.conditions_of_addr_in_block; eauto. }
+          exploit Mem.valid_pointer_implies; try eapply VLD2. i.
+          eapply weak_valid_concrete_extends in H; eauto.
+          exploit Mem.ptr2int_weak_valid'; eauto; [eapply Ptrofs.unsigned_range_2|].
+          i. des. subst. inv INRANGE. simpl in *.
+          assert (INBLK2: Mem.addr_in_block (Mem.mem_concrete m') (Mem.mem_access m') (caddr0 + Ptrofs.unsigned i0) b1).
+          { eapply Mem.conditions_of_addr_in_block; eauto.
+            - replace (caddr0 + Ptrofs.unsigned i0 - caddr0) with (Ptrofs.unsigned i0) by lia.
+              eapply SAMEVLD in VLD2. rewrite Mem.valid_pointer_nonempty_perm in VLD2; eauto.
+              eapply Mem.perm_cur_max. eauto.
+            - replace (caddr0 + Ptrofs.unsigned i0 - caddr0) with (Ptrofs.unsigned i0) by lia.
+              eapply Ptrofs.unsigned_range_2. }
+          assert (INBLK1': Mem.addr_in_block (Mem.mem_concrete m') (Mem.mem_access m') (Int64.unsigned i1) b0).
+          { inv INBLK1. econs; eauto; [eapply extended_concrete; eauto|].
+            des. exploit extended_access; eauto. i. unfold Mem.perm, Mem.perm_order' in H0.
+            des_ifs; eauto. }
+          exploit Ptrofs.modulus_eq64; eauto. i.
+          assert (Int64.eq i1 (Int64.repr (caddr0 + Ptrofs.unsigned i0)) = false).
+          { unfold Int64.eq. rewrite Int64.unsigned_repr.
+            2:{ unfold Int64.max_unsigned. rewrite <- H0. lia. }
+            destruct (zeq (Int64.unsigned i1) (caddr0 + Ptrofs.unsigned i0)) eqn:ZEQ;[|eauto].
+            { rewrite <- e in INBLK2. exfalso. eapply n. eapply Mem.no_concrete_overlap; eauto. } }
+          rewrite NULL1, BIT. destruct c; simpl in *; inv H1; right; rewrite H3; eauto. }
+    + inversion TOPTR1; subst.
+      destruct v2; simpl in *; [clarify|clarify|rewrite BIT in *; simpl in *; clarify|clarify|clarify|simpl in *].
+      * destruct (Int64.eq i1 Int64.zero) eqn:NULL1; simpl in *; [clarify| ].
+        destruct (Mem.denormalize (Int64.unsigned i1) m) eqn:DENO2; [|simpl in *; clarify].
+        destruct p. simpl in TOPTR2. simpl in *. inv TOPTR2. inv BIND2. inv BIND1;[|clarify|].
+        { left. exploit denormalize_concrete_extends; eauto. i. des. unfold Mem.to_ptr. rewrite BIT, H, NULL1. simpl.
+          rewrite BIT. eapply andb_prop in VLD. des. eapply valid_concrete_extends in VLD, VLD0; eauto.
+          destruct (eq_block b0 b1); [subst; clarify|]. rewrite VLD, VLD0. eauto. }
+        { simpl. eapply andb_prop in VLD. destruct VLD as [VLD1 VLD2]. simpl in H4. unfold Mem.ptr2int_v in H4.
+          destruct (Mem.ptr2int b0 (Ptrofs.unsigned i) m') eqn:P2I; cycle 1;[inv H4|].
+          rewrite BIT in H4. inv H4. exploit Mem.denormalize_info; eauto. i. des. subst.
+          assert (INBLK1: Mem.addr_in_block (Mem.mem_concrete m) (Mem.mem_access m) (Int64.unsigned i1) b1).
+          { eapply Mem.conditions_of_addr_in_block; eauto. }
+          exploit Mem.valid_pointer_implies; try eapply VLD1. i.
+          eapply weak_valid_concrete_extends in H; eauto.
+          exploit Mem.ptr2int_weak_valid'; eauto; [eapply Ptrofs.unsigned_range_2|].
+          i. des. subst. inv INRANGE. simpl in *.
+          assert (INBLK2: Mem.addr_in_block (Mem.mem_concrete m') (Mem.mem_access m') (caddr0 + Ptrofs.unsigned i) b0).
+          { eapply Mem.conditions_of_addr_in_block; eauto.
+            - replace (caddr0 + Ptrofs.unsigned i - caddr0) with (Ptrofs.unsigned i) by lia.
+              eapply SAMEVLD in VLD1. rewrite Mem.valid_pointer_nonempty_perm in VLD1; eauto.
+              eapply Mem.perm_cur_max. eauto.
+            - replace (caddr0 + Ptrofs.unsigned i - caddr0) with (Ptrofs.unsigned i) by lia.
+              eapply Ptrofs.unsigned_range_2. }
+          assert (INBLK1': Mem.addr_in_block (Mem.mem_concrete m') (Mem.mem_access m') (Int64.unsigned i1) b1).
+          { inv INBLK1. econs; eauto; [eapply extended_concrete; eauto|].
+            des. exploit extended_access; eauto. i. unfold Mem.perm, Mem.perm_order' in H0.
+            des_ifs; eauto. }
+          exploit Ptrofs.modulus_eq64; eauto. i.
+          assert (Int64.eq (Int64.repr (caddr0 + Ptrofs.unsigned i)) i1 = false).
+          { unfold Int64.eq. rewrite Int64.unsigned_repr.
+            2:{ unfold Int64.max_unsigned. rewrite <- H0. lia. }
+            destruct (zeq (caddr0 + Ptrofs.unsigned i) (Int64.unsigned i1)) eqn:ZEQ;[|eauto].
+            { rewrite e in INBLK2. exfalso. eapply n. eapply Mem.no_concrete_overlap; eauto. } }
+          destruct c; simpl in *; inv H1; right; rewrite H3; eauto. }
+      * inv TOPTR2. eapply andb_prop in VLD. destruct VLD as [VLD1 VLD2].
+        inv BIND1; [ | clarify | ].
+        { inv BIND2; [ | clarify | ].
+          - simpl. rewrite BIT. destruct (eq_block b0 b1); [subst;clarify|].
+            eapply SAMEVLD in VLD1, VLD2. rewrite VLD1, VLD2. simpl. eauto.
+          - simpl in H4. unfold Mem.ptr2int_v in H4.
+            destruct (Mem.ptr2int b1 (Ptrofs.unsigned i0) m') eqn:P2I; [|inv H4].
+            rewrite BIT in *. inv H4. exploit Mem.ptr2int_to_denormalize; eauto.
+            { eapply Ptrofs.unsigned_range_2. }
+            i. des. exploit Mem.denormalize_paddr_in_range; eauto.  i. inv H0.
+            unfold fst, snd in *.
+            left. simpl. rewrite BIT. simpl. rewrite Int64.unsigned_repr.
+            2:{ unfold Int64.max_unsigned. rewrite <- Ptrofs.modulus_eq64; eauto. lia. }
+            exploit Mem.denormalized_not_nullptr64; eauto. i. rewrite H0.
+            rewrite H. simpl. destruct (eq_block b0 b1); [subst; clarify|].
+            eapply SAMEVLD in VLD1, VLD2. rewrite Ptrofs.repr_unsigned. simpl. rewrite VLD1, VLD2. eauto. }
+        { inv BIND2; [ | clarify | ].
+          - simpl in H4. unfold Mem.ptr2int_v in H4.
+            destruct (Mem.ptr2int b0 (Ptrofs.unsigned i) m') eqn:P2I; [|inv H4].
+            rewrite BIT in *. inv H4. exploit Mem.ptr2int_to_denormalize; eauto.
+            { eapply Ptrofs.unsigned_range_2. }
+            i. des. exploit Mem.denormalize_paddr_in_range; eauto. i. inv H0.
+            unfold fst, snd in *.
+            left. simpl. rewrite BIT. simpl. rewrite Int64.unsigned_repr.
+            2:{ unfold Int64.max_unsigned. rewrite <- Ptrofs.modulus_eq64; eauto. lia. }
+            exploit Mem.denormalized_not_nullptr64; eauto. i. rewrite H0.
+            rewrite H. simpl. destruct (eq_block b0 b1); [subst; clarify|].
+            eapply SAMEVLD in VLD1, VLD2. rewrite Ptrofs.repr_unsigned. rewrite VLD1, VLD2.
+            rewrite BIT. eauto.
+          - simpl in H4, H6. unfold Mem.ptr2int_v in H4, H6.
+            destruct (Mem.ptr2int b0 (Ptrofs.unsigned i) m') eqn:P2I; [|inv H4].
+            destruct (Mem.ptr2int b1 (Ptrofs.unsigned i0) m') eqn:P2I'; [|inv H6].
+            rewrite BIT in *. inv H4; inv H6.
+            exploit Mem.ptr2int_to_denormalize; try eapply P2I; eauto; i.
+            { eapply Ptrofs.unsigned_range_2. }
+            exploit Mem.ptr2int_to_denormalize; try eapply P2I'; eauto; i; des.
+            { eapply Ptrofs.unsigned_range_2. }
+            exploit Mem.denormalize_paddr_in_range; try eapply H; eauto. i. inv H4.
+            exploit Mem.denormalize_paddr_in_range; try eapply H0; eauto. i. inv H4.
+            unfold fst, snd in *. left. simpl. rewrite BIT. simpl.
+            exploit Mem.denormalized_not_nullptr64; try eapply H; eauto. i.
+            exploit Mem.denormalized_not_nullptr64; try eapply H0; eauto. i. des.
+            rewrite H4, H5. rewrite Int64.unsigned_repr.
+            2:{ unfold Int64.max_unsigned. rewrite <- Ptrofs.modulus_eq64; eauto. lia. }
+            rewrite Int64.unsigned_repr.
+            2:{ unfold Int64.max_unsigned. rewrite <- Ptrofs.modulus_eq64; eauto. lia. }
+            rewrite H, H0. simpl. rewrite BIT. destruct (eq_block b0 b1); [subst; clarify|].
+            eapply SAMEVLD in VLD1, VLD2. do 2 rewrite Ptrofs.repr_unsigned. rewrite VLD1, VLD2. eauto. }
+Qed.
+
+Lemma cmplu_bool_to_int_binded
+    m m' v1 v1' v2 v2' c b
+    (CONCEXT: concrete_extends m m')
+    (BIND1: val_intptr m' v1 v1')
+    (BIND2: val_intptr m' v2 v2')
+    (CMP: Val.cmplu_bool (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2) = Some b) :
+  <<CMPI: Val.cmplu_bool (Mem.valid_pointer m') c (to_int_val m' v1') (to_int_val m' v2') = Some b>>.
+Proof.
+  destruct Archi.ptr64 eqn:BIT.
+  2: { unfold Val.cmplu_bool in CMP. rewrite BIT in *; des_ifs
+       ;unfold to_int_val, Mem.to_int in Heq, Heq0; des_ifs; simpl in *; clarify; des_ifs;
+       inv BIND1; inv BIND2; simpl; eauto. }
+  unfold Val.cmplu_bool in CMP. rewrite BIT in CMP.
+  destruct (to_int_val m v1) eqn:TOINT1; inversion CMP.
+  2:{ eapply to_int_val_int_or_undef in TOINT1. des; clarify. }
+  destruct (to_int_val m v2) eqn:TOINT2; inversion CMP.
+  2:{ eapply to_int_val_int_or_undef in TOINT2. des; clarify. }
+  exploit to_int_bind; try eapply BIND1; eauto. intros IBIND1.
+  exploit to_int_bind; try eapply BIND2; eauto. intros IBIND2. des.
+  rewrite TOINT1 in IBIND1. rewrite TOINT2 in IBIND2. inv IBIND1; inv IBIND2.
+  simpl. eauto.
+Qed.
+
+Lemma cmpu_join_binded
+    v1 v1' v2 v2' c m m' b
+    (BIND1: val_intptr m' v1 v1')
+    (BIND2: val_intptr m' v2 v2')
+    (CONCEXT: concrete_extends m m')
+    (CMP: cmpu_join m c v1 v2 = Some b) :
+  <<CMP: cmpu_join m' c v1' v2' = Some b>>.
+Proof.
+  unfold cmpu_join in *.
+  destruct (Val.cmpu_bool (Mem.valid_pointer m) c (to_ptr_val m v1) (to_ptr_val m v2)) eqn:PCMP.
+  - exploit cmpu_bool_to_ptr_binded; try eapply PCMP; eauto. intros [PCMP'|ICMP'].
+    + destruct (Val.cmpu_bool (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2)) eqn:ICMP.
+      { exploit cmpu_bool_to_int_binded; try eapply ICMP; eauto. i. rewrite PCMP', H. eauto. }
+      destruct (Val.cmpu_bool (Mem.valid_pointer m') c (to_int_val m' v1') (to_int_val m' v2')) eqn:ICMP'.
+      { exploit cmpu_no_angelic; try eapply ICMP'; eauto. i. des; subst. rewrite PCMP'.
+        ss. inv CMP. eapply bool_join_angelic; eauto. }
+      rewrite PCMP'. simpl in *. eauto.
+    + destruct (Val.cmpu_bool (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2)) eqn:ICMP.
+      { exploit cmpu_no_angelic; try eapply PCMP; eauto. i. des; subst.
+        destruct (Val.cmpu_bool (Mem.valid_pointer m') c (to_ptr_val m' v1') (to_ptr_val m' v2')) eqn:PCMP'.
+        { exploit cmpu_no_angelic; try eapply PCMP'; eauto. i. des; subst. rewrite ICMP'. eauto. }
+        rewrite ICMP'. simpl in *. rewrite bool_join_angelic in CMP; eauto. }
+      destruct (Val.cmpu_bool (Mem.valid_pointer m') c (to_ptr_val m' v1') (to_ptr_val m' v2')) eqn:PCMP'.
+      { exploit cmpu_no_angelic; try eapply PCMP'; eauto. i. des; subst. rewrite ICMP'. ss.
+        rewrite bool_join_angelic; eauto. }
+      rewrite ICMP'. eauto.
+  - destruct (Val.cmpu_bool (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2)) eqn:ICMP.
+    2:{ simpl in CMP. inv CMP. }
+    exploit cmpu_bool_to_int_binded; try eapply ICMP; eauto. i. rewrite H.
+    destruct (Val.cmpu_bool (Mem.valid_pointer m') c (to_ptr_val m' v1') (to_ptr_val m' v2')) eqn:PCMP'; eauto.
+    { exploit cmpu_no_angelic; try eapply PCMP'; eauto. i. des; subst. ss. rewrite bool_join_angelic; eauto. }
+Qed.
+
+Lemma cmplu_join_binded
+    v1 v1' v2 v2' c m m' b
+    (BIND1: val_intptr m' v1 v1')
+    (BIND2: val_intptr m' v2 v2')
+    (CONCEXT: concrete_extends m m')
+    (CMP: cmplu_join m c v1 v2 = Some b) :
+  <<CMP: cmplu_join m' c v1' v2' = Some b>>.
+Proof.
+  unfold cmplu_join in *.
+  destruct (Val.cmplu_bool (Mem.valid_pointer m) c (to_ptr_val m v1) (to_ptr_val m v2)) eqn:PCMP.
+  - exploit cmplu_bool_to_ptr_binded; try eapply PCMP; eauto. intros [PCMP'|ICMP'].
+    + destruct (Val.cmplu_bool (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2)) eqn:ICMP.
+      { exploit cmplu_bool_to_int_binded; try eapply ICMP; eauto. i. rewrite PCMP', H. eauto. }
+      destruct (Val.cmplu_bool (Mem.valid_pointer m') c (to_int_val m' v1') (to_int_val m' v2')) eqn:ICMP'.
+      { exploit cmplu_no_angelic; try eapply ICMP'; eauto. i. des; subst. rewrite PCMP'.
+        ss. inv CMP. eapply bool_join_angelic; eauto. }
+      rewrite PCMP'. simpl in *. eauto.
+    + destruct (Val.cmplu_bool (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2)) eqn:ICMP.
+      { exploit cmplu_no_angelic; try eapply PCMP; eauto. i. des; subst.
+        destruct (Val.cmplu_bool (Mem.valid_pointer m') c (to_ptr_val m' v1') (to_ptr_val m' v2')) eqn:PCMP'.
+        { exploit cmplu_no_angelic; try eapply PCMP'; eauto. i. des; subst. rewrite ICMP'. eauto. }
+        rewrite ICMP'. simpl in *. rewrite bool_join_angelic in CMP; eauto. }
+      destruct (Val.cmplu_bool (Mem.valid_pointer m') c (to_ptr_val m' v1') (to_ptr_val m' v2')) eqn:PCMP'.
+      { exploit cmplu_no_angelic; try eapply PCMP'; eauto. i. des; subst. rewrite ICMP'. ss.
+        rewrite bool_join_angelic; eauto. }
+      rewrite ICMP'. eauto.
+  - destruct (Val.cmplu_bool (Mem.valid_pointer m) c (to_int_val m v1) (to_int_val m v2)) eqn:ICMP.
+    2:{ simpl in CMP. inv CMP. }
+    exploit cmplu_bool_to_int_binded; try eapply ICMP; eauto. i. rewrite H.
+    destruct (Val.cmplu_bool (Mem.valid_pointer m') c (to_ptr_val m' v1') (to_ptr_val m' v2')) eqn:PCMP'; eauto.
+    { exploit cmplu_no_angelic; try eapply PCMP'; eauto. i. des; subst. ss. rewrite bool_join_angelic; eauto. }
+Qed.
+
+Lemma cmplu_bool_ptr_concrete_extends
+    c m m' b1 b2 ofs1 ofs2 b
+    (SF: Archi.ptr64 = true)
+    (CONCEXT: concrete_extends m m')
+    (CMP: Val.cmplu_bool (Mem.valid_pointer m) c (Vptr b1 ofs1) (Vptr b2 ofs2) = Some b):
+  Val.cmplu_bool (Mem.valid_pointer m') c (Vptr b1 ofs1) (Vptr b2 ofs2) = Some b.
+Proof.
+  assert (SAMEVLD: forall b ofs, Mem.valid_pointer m b ofs = true -> Mem.valid_pointer m' b ofs = true).
+  { eapply valid_concrete_extends; eauto. }
+  assert (SAMEWVLD: forall b ofs, Mem.weak_valid_pointer m b ofs = true -> Mem.weak_valid_pointer m' b ofs = true).
+  { eapply weak_valid_concrete_extends; eauto. }
+  unfold Val.cmplu_bool in CMP. rewrite SF in CMP. simpl in CMP.
+  fold (Mem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs1)) in *.
+  fold (Mem.weak_valid_pointer m b2 (Ptrofs.unsigned ofs2)) in *.
+  destruct (eq_block b1 b2); subst.
+  - destruct (Mem.weak_valid_pointer m b2 (Ptrofs.unsigned ofs1) &&
+                Mem.weak_valid_pointer m b2 (Ptrofs.unsigned ofs2)) eqn:WVLD; [|inv CMP].
+    eapply andb_prop in WVLD. des_safe. eapply SAMEWVLD in WVLD, WVLD0.
+    simpl. unfold Mem.weak_valid_pointer in WVLD, WVLD0. rewrite SF, WVLD, WVLD0. simpl. des_ifs.
+  - destruct (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1) &&
+                Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)) eqn:VLD; [|inv CMP].
+    eapply andb_prop in VLD. des_safe. eapply SAMEVLD in VLD, VLD0.
+    simpl. rewrite SF, VLD, VLD0. simpl. des_ifs.
+Qed.
+
+Lemma cmplu_bool_ptr_binded
+  c m m' b1 b2 ofs1 ofs2 v1' v2' b
+  (CONCEXT: concrete_extends m m')
+  (BIND1: val_intptr m' (Vptr b1 ofs1) v1')
+  (BIND2: val_intptr m' (Vptr b2 ofs2) v2')
+  (CMP: Val.cmplu_bool (Mem.valid_pointer m) c (Vptr b1 ofs1) (Vptr b2 ofs2) = Some b) :
+  <<CMP: eval_condition_join (Ccomplu c) [v1'; v2'] m' = Some b>>.
+Proof.
+  assert (SAMEVLD: forall b ofs, Mem.valid_pointer m b ofs = true -> Mem.valid_pointer m' b ofs = true).
+  { eapply valid_concrete_extends; eauto. }
+  assert (SAMEWVLD: forall b ofs, Mem.weak_valid_pointer m b ofs = true -> Mem.weak_valid_pointer m' b ofs = true).
+  { eapply weak_valid_concrete_extends; eauto. }
+  exploit cmplu_bool_to_ptr_binded. eauto. eapply BIND1. eapply BIND2.
+  { eauto. }
+  i. simpl. destruct Archi.ptr64 eqn:SF.
+  2:{ inv BIND1; inv BIND2; clarify. }
+  inv BIND1; inv BIND2; try rewrite SF in *; clarify.
+  - eapply cmplu_bool_ptr_concrete_extends; eauto.
+  - unfold cmplu_join_common. simpl in H4. unfold Mem.ptr2int_v in H4. des_ifs_safe.
+    exploit Mem.ptr2int_not_nullptr64; eauto.
+    { unfold Val.cmplu_bool in CMP. des_ifs.
+      - eapply andb_prop in Heq1. des_safe. eapply SAMEWVLD. unfold Mem.weak_valid_pointer. eauto.
+      - eapply andb_prop in Heq1. des_safe. eapply SAMEWVLD. unfold Mem.weak_valid_pointer.
+        rewrite Heq2. eauto. }
+    { eapply Ptrofs.unsigned_range_2. }
+    i. rewrite H0. unfold cmplu_join. des.
+    + rewrite CMPP. unfold bool_optjoin. simpl. des_ifs.
+      exploit cmplu_no_angelic; eauto. i. eapply bool_join_angelic; eauto.
+    + rewrite CMPI. unfold bool_optjoin.
+      destruct (Val.cmplu_bool (Mem.valid_pointer m') c (to_ptr_val m' (Vptr b1 ofs1))
+                  (to_ptr_val m' (Vlong (Int64.repr z)))) eqn:PCMP; eauto.
+      exploit cmplu_no_angelic; eauto. i. rewrite H. eapply bool_join_angelic; eauto.
+  - unfold cmplu_join_common. simpl in H4. unfold Mem.ptr2int_v in H4. des_ifs_safe.
+    exploit Mem.ptr2int_not_nullptr64; eauto;[|eapply Ptrofs.unsigned_range_2|].
+    { unfold Val.cmplu_bool in CMP. des_ifs.
+      - eapply andb_prop in Heq1. des_safe. eapply SAMEWVLD. unfold Mem.weak_valid_pointer. eauto.
+      - eapply andb_prop in Heq1. des_safe. eapply SAMEWVLD. unfold Mem.weak_valid_pointer.
+        rewrite Heq1. eauto. }
+    i. rewrite H0. unfold cmplu_join. des.
+    + rewrite CMPP. unfold bool_optjoin.
+      destruct (Val.cmplu_bool (Mem.valid_pointer m') c (to_int_val m' (Vlong (Int64.repr z)))
+                                                        (to_int_val m' (Vptr b2 ofs2))) eqn:CMPI; eauto.
+      exploit cmplu_no_angelic; eauto. i. eapply bool_join_angelic; eauto.
+    + rewrite CMPI. unfold bool_optjoin.
+      destruct (Val.cmplu_bool (Mem.valid_pointer m') c (to_ptr_val m' (Vlong (Int64.repr z)))
+                                                        (to_ptr_val m' (Vptr b2 ofs2))) eqn:CMPP; eauto.
+      exploit cmplu_no_angelic; eauto. i. rewrite H. eapply bool_join_angelic; eauto.
+  - des; eauto. destruct (Val.cmplu_bool (Mem.valid_pointer m') c (Vlong i) (Vlong i0)) eqn:CMPI.
+    2:{ simpl in CMPI. clarify. }
+    unfold Mem.to_int, Mem.ptr2int_v in *. des_ifs.
+    exploit (cmplu_no_angelic m' c (Vptr b1 ofs1) (Vptr b2 ofs2)).
+    { eapply cmplu_bool_ptr_concrete_extends; eauto. }
+    { unfold to_int_val. simpl. rewrite Heq, Heq0, SF. eauto. }
+    i. rewrite H; eauto.
+Qed.
+
+Lemma cmplu_bool_null_binded_l
+    c m m' n b1 ofs1 v1' v2' b
+    (CONCEXT: concrete_extends m m')
+    (BIND1: val_intptr m' (Vlong n) v1')
+    (BIND2: val_intptr m' (Vptr b1 ofs1) v2')
+    (CMP: Val.cmplu_bool (Mem.valid_pointer m) c (Vlong n) (Vptr b1 ofs1) = Some b) :
+  <<CMP: eval_condition_join (Ccomplu c) [v1'; v2'] m' = Some b>>.
+Proof.
+  assert (SAMEVLD: forall b ofs, Mem.valid_pointer m b ofs = true -> Mem.valid_pointer m' b ofs = true).
+  { eapply valid_concrete_extends; eauto. }
+  unfold Val.cmplu_bool in CMP. des_ifs.
+  eapply andb_prop in Heq0. des. inv BIND1; inv BIND2; [|clarify|].
+  - ss. des_ifs_safe. rewrite andb_false_iff in Heq2. des; clarify.
+    exploit weak_valid_concrete_extends; eauto. i. eapply orb_prop in H.
+    des; clarify. erewrite orb_true_r in Heq2. clarify.
+  - ss. des_ifs. exploit Mem.ptr2int_weak_valid'; eauto.
+    { eapply weak_valid_concrete_extends; eauto. }
+    { eapply Ptrofs.unsigned_range_2. }
+    i. des. inv INRANGE. simpl in *.
+    assert (EQ: Int64.eq Int64.zero (Int64.repr (caddr + Ptrofs.unsigned ofs1)) = false).
+    { unfold Int64.eq. rewrite Int64.unsigned_repr.
+      2:{ rewrite Ptrofs.modulus_eq64 in SND; eauto. unfold Int64.max_unsigned. lia. }
+      rewrite Int64.unsigned_zero. des_ifs; lia. }
+    eapply Int64.same_if_eq in Heq0; subst.
+    destruct c; ss; inv CMP; rewrite EQ; eauto.
+Qed.
+
+Lemma cmplu_bool_null_binded_r
+    c m m' n b1 ofs1 v1' v2' b
+    (CONCEXT: concrete_extends m m')
+    (BIND1: val_intptr m' (Vptr b1 ofs1) v1')
+    (BIND2: val_intptr m' (Vlong n) v2')
+    (CMP: Val.cmplu_bool (Mem.valid_pointer m) c (Vptr b1 ofs1) (Vlong n) = Some b) :
+  <<CMP: eval_condition_join (Ccomplu c) [v1'; v2'] m' = Some b>>.
+Proof.
+  assert (SAMEVLD: forall b ofs, Mem.valid_pointer m b ofs = true -> Mem.valid_pointer m' b ofs = true).
+  { eapply valid_concrete_extends; eauto. }
+  unfold Val.cmplu_bool in CMP. des_ifs.
+  eapply andb_prop in Heq0. des. inv BIND1; inv BIND2; [|clarify|].
+  - ss. des_ifs_safe. rewrite andb_false_iff in Heq2. des; clarify.
+    exploit weak_valid_concrete_extends; eauto. i. eapply orb_prop in H.
+    des; clarify. erewrite orb_true_r in Heq2. clarify.
+  - ss. des_ifs. exploit Mem.ptr2int_weak_valid'; eauto.
+    { eapply weak_valid_concrete_extends; eauto. }
+    { eapply Ptrofs.unsigned_range_2. }
+    i. des. inv INRANGE. simpl in *.
+    assert (EQ: Int64.eq Int64.zero (Int64.repr (caddr + Ptrofs.unsigned ofs1)) = false).
+    { unfold Int64.eq. rewrite Int64.unsigned_repr.
+      2:{ rewrite Ptrofs.modulus_eq64 in SND; eauto. unfold Int64.max_unsigned. lia. }
+      rewrite Int64.unsigned_zero. des_ifs; lia. }
+    eapply Int64.same_if_eq in Heq0; subst.
+    destruct c; ss; inv CMP; rewrite Int64.eq_sym; rewrite EQ; eauto.
+Qed.
+
+Lemma cmplu_bool_long_binded
+    c m m' n1 n2 v1' v2' b
+    (CONCEXT: concrete_extends m m')
+    (BIND1: val_intptr m' (Vlong n1) v1')
+    (BIND2: val_intptr m' (Vlong n2) v2')
+    (CMP: Val.cmplu_bool (Mem.valid_pointer m) c (Vlong n1) (Vlong n2) = Some b) :
+  <<CMP: eval_condition_join (Ccomplu c) [v1'; v2'] m' = Some b>>.
+Proof. inv BIND1; inv BIND2. simpl in *. eauto. Qed.
+
+Lemma eval_condition_join_binded
+    c m m' vl vl' b
+    (COND: ptr_cond c = true)
+    (CONCEXT: concrete_extends m m')
+    (BIND: val_intptrist m' vl vl')
+    (EVAL: eval_condition_join c vl m = Some b) :
+  <<EVAL: eval_condition_join c vl' m' = Some b>>.
+Proof.
+  assert (SAMEVLD: forall b ofs, Mem.valid_pointer m b ofs = true -> Mem.valid_pointer m' b ofs = true).
+  { eapply valid_concrete_extends; eauto. }
+  assert (SAMEWVLD: forall b ofs, Mem.weak_valid_pointer m b ofs = true -> Mem.weak_valid_pointer m' b ofs = true).
+  { eapply weak_valid_concrete_extends; eauto. }
+  destruct (Archi.ptr64) eqn:BIT;[|ss].
+  - destruct c eqn: CC; simpl in *; try rewrite BIT in *; inv COND.
+    2:{ unfold cmplu_join_common in *. destruct BIND; [ss|]. destruct BIND; [|ss]. dup H.
+        destruct v1; try by inv EVAL.
+        - inv H. simpl in *. eauto.
+        - destruct (Int64.eq n Int64.zero) eqn:NULL.
+          + exploit cmplu_bool_null_binded_r; try eapply EVAL; eauto. econs. i.
+            ss. unfold cmplu_join_common in *. rewrite NULL in H1. eauto.
+          + inv H0;[|clarify|].
+            { eapply cmplu_join_binded; eauto. econs. }
+            { exploit cmplu_join_binded.
+              eauto. instantiate (1:=Vlong n). econs 2. eauto. eauto. i.
+              r in H0. unfold cmplu_join in H0. ss.
+              destruct (Val.cmplu_bool (Mem.valid_pointer m') c0 (to_ptr_val m' (Vlong i0))
+                                                                 (to_ptr_val m' (Vlong n))) eqn:PCMP; ss.
+              { exploit cmplu_no_angelic; eauto; ss. i. r in H1.
+                subst. rewrite bool_join_angelic in H0; eauto. } } }
+    unfold cmplu_join_common in *. do 2 (destruct BIND; [ss|]). destruct BIND; [|ss].
+    fold eval_condition_join. destruct v1, v0; try (by ss).
+    + inv H; inv H0. ss.
+    + destruct (Int64.eq i Int64.zero) eqn:NULL.
+      { inv H; inv H0;[|clarify|].
+        - ss. rewrite NULL, BIT in *. ss.
+          fold (Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i0)) in *.
+          destruct (Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i0)) eqn:WVLD; [|inv EVAL].
+          eapply SAMEWVLD in WVLD. unfold Mem.weak_valid_pointer in WVLD. rewrite WVLD. eauto.
+        - exploit cmplu_bool_null_binded_l; eauto. econs. econs 7; eauto. i. ss. }
+      { exploit cmplu_join_binded; try eapply EVAL; eauto. i. inv H; inv H0;[|clarify|].
+        - rewrite NULL. eauto.
+        - unfold cmplu_join in H1. simpl in H1.
+          destruct (Val.cmplu_bool (Mem.valid_pointer m') c0 (to_ptr_val m' (Vlong i)) (to_ptr_val m' (Vlong i1))) eqn:PCMP; ss.
+          { simpl in *. exploit cmplu_no_angelic; eauto; ss. i. r in H. subst.
+            rewrite bool_join_angelic in H1; eauto. } }
+    + inv H; inv H0;[|clarify|].
+      * destruct (Int64.eq i0 Int64.zero) eqn:NULL.
+        { ss. rewrite NULL, BIT in *. ss.
+          fold (Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i)) in *.
+          destruct (Mem.weak_valid_pointer m b0 (Ptrofs.unsigned i)) eqn:WVLD; [|inv EVAL].
+          eapply SAMEWVLD in WVLD. unfold Mem.weak_valid_pointer in WVLD. rewrite WVLD. eauto. }
+        { eapply cmplu_join_binded; eauto; econs. }
+      * destruct (Int64.eq i0 Int64.zero) eqn:NULL.
+        { exploit cmplu_bool_null_binded_r; eauto. econs 7; eauto. econs. i. ss. }
+        { exploit cmplu_join_binded; eauto. econs 7; eauto. econs. i.
+          r in H. unfold cmplu_join in H. ss.
+          destruct (Val.cmplu_bool (Mem.valid_pointer m') c0 (to_ptr_val m' (Vlong i1))
+                      (to_ptr_val m' (Vlong i0))) eqn:PCMP; ss.
+          { simpl in *. exploit cmplu_no_angelic; eauto; ss. i. r in H0. subst.
+            rewrite bool_join_angelic in H; eauto. } }
+    + eapply cmplu_bool_ptr_binded; eauto.
+Qed.
+
+Lemma eval_operation_join_eval_condition_join op c sp vl m
+    (OPCOND: op = Ocmp c)
+    (COND: ptr_cond c = true) :
+  eval_operation_join genv sp op vl m = Some (Val.of_optbool (eval_condition_join c vl m)).
+Proof.
+  subst. unfold eval_operation_join, eval_operation, eval_condition_join in *.
+  unfold Val.of_optbool, Vtrue, Vfalse.
+  destruct (eval_condition c (map (to_ptr_val m) vl) m) eqn:PCMP; simpl.
+  - destruct (eval_condition c (map (to_int_val m) vl) m) eqn:ICMP; simpl.
+    + des_ifs; clarify.
+    + unfold val_join. des_ifs.
+  - destruct (eval_condition c (map (to_int_val m) vl) m) eqn:ICMP; eauto.
+Qed.
+
+Lemma psubl_join_binded
+    m m' v1 v2 v1' v2' v
+    (CONCEXT: concrete_extends m m')
+    (BIND1: val_intptr m' v1 v1')
+    (BIND2: val_intptr m' v2 v2')
+    (PSUB: psubl_join m v1 v2 = v) :
+  exists v', <<PSUB: psubl_join m' v1' v2' = v'>> /\ <<BIND: val_intptr m' v v'>>.
+Proof.
+  unfold psubl_join in *.
+  specialize (psubl_only_long_and_undef (to_ptr_val m v1) (to_ptr_val m v2)).
+  specialize (psubl_only_long_and_undef (to_int_val m v1) (to_int_val m v2)). i.
+  destruct (Val.psubl (to_ptr_val m v1) (to_ptr_val m v2)) eqn:PSUB1; des; inv H;
+  destruct (Val.psubl (to_int_val m v1) (to_int_val m v2)) eqn:PSUB2; des; inv H0;
+  simpl; esplits; eauto; try econs; inv H2.
+  - exploit psubl_to_int_binded; try eapply PSUB2; eauto. i. des. subst. inv H0.
+    symmetry in H. erewrite val_join_angelic_vi; eauto; [econs| |ii; clarify].
+    { eapply psubl_wrapper_no_angelic; eauto. }
+  - exploit psubl_to_ptr_binded; try eapply PSUB1; eauto. i. des.
+    + inv PSUBP0. symmetry in H1. rewrite H1. erewrite val_join_angelic_vp; eauto; [econs| |ii; clarify].
+      { eapply psubl_wrapper_no_angelic; eauto. }
+    + inv PSUBI0. symmetry in H1. rewrite H1. erewrite val_join_angelic_vi; eauto; [econs| |ii; clarify].
+      { eapply psubl_wrapper_no_angelic; eauto. }
+  - exploit psubl_wrapper_no_angelic; eauto. i. des; subst; inv H.
+    rewrite Int64.eq_true. exploit psubl_to_int_binded; try eapply PSUB2; eauto. i. des. subst. inv H0.
+    symmetry in H. erewrite val_join_angelic_vi; eauto; [econs| |ii; clarify].
+    { eapply psubl_wrapper_no_angelic; eauto. }
+Qed.
+
+Lemma eval_operation_join_binded
+    m m' vl vl' sp op v
+    (PTRBIN: ptr_binop op = true)
+    (CONCEXT: concrete_extends m m')
+    (BIND: val_intptrist m' vl vl')
+    (EVAL: eval_operation_join genv sp op vl m = Some v) :
+  exists v', <<EVAL2: eval_operation_join genv sp op vl' m' = Some v'>>
+      /\ <<VIND': val_intptr m' v v'>>.
+Proof.
+  destruct (Archi.ptr64) eqn:BIT; [|ss].
+  - destruct op; ss.
+    (* psubl p >= i *)
+    + do 2 (destruct BIND; [inv EVAL|]). destruct BIND; [|inv EVAL].
+      rewrite BIT in *. destruct v1, v0; try by (simpl in *; inv EVAL; des_ifs; esplits; eauto; econs).
+      (* * inv EVAL. des_ifs; esplits; econs; eauto. *)
+      * inv H; inv H0. esplits; eauto. simpl. eapply val_intptr_refl.
+      * dup H. dup H0. exploit psubl_join_binded. eauto. eapply H. eapply H0. inv EVAL; eauto.
+        i. des. subst. inv H; inv H0;[|clarify|].
+        { inv EVAL. esplits; eauto. }
+        { inv EVAL. esplits; eauto. unfold psubl_join in BIND.
+          erewrite (val_join_angelic_vi _ (Val.psubl (to_int_val m' (Vlong i)) (to_int_val m' (Vlong i1)))) in BIND; eauto.
+          { eapply psubl_wrapper_no_angelic; eauto. }
+          { ii. simpl in H. clarify. } }
+      * dup H. dup H0. exploit psubl_join_binded. eauto. eapply H. eapply H0. inv EVAL; eauto.
+        i. des. subst. inv H; inv H0;[|clarify|].
+        { inv EVAL. esplits; eauto. }
+        { inv EVAL. esplits; eauto. unfold psubl_join in BIND.
+          erewrite (val_join_angelic_vi _ (Val.psubl (to_int_val m' (Vlong i1)) (to_int_val m' (Vlong i0)))) in BIND; eauto.
+          { eapply psubl_wrapper_no_angelic; eauto. }
+          { ii. simpl in H. clarify. } }
+      * destruct (classic (v = Vundef)).
+        { subst. inv H; inv H0; ss; esplits; eauto; econs. }
+        dup H. dup H0. exploit psubl_join_binded. eauto. eapply H. eapply H0.
+        { instantiate (1:= v). unfold psubl_join. rewrite val_join_angelic_vp.
+          - simpl. inv EVAL. eauto.
+          - ss. des_ifs.
+          - eapply psubl_wrapper_no_angelic; eauto.
+          - ii. ss. clarify. }
+        i. des; subst. inv H; inv H0; ss;[|esplits; eauto|esplits; eauto|].
+        { inv EVAL. esplits; eauto. eapply val_intptr_refl. }
+        { rewrite BIT.  unfold psubl_join in BIND. rewrite val_join_angelic_vi in BIND; ss; eauto.
+          eapply psubl_wrapper_no_angelic; eauto. }
+    + destruct (eval_condition_join cond vl m) eqn:COND.
+      2:{ ss. clarify. esplits; eauto. econs. }
+      inv EVAL. exploit eval_condition_join_binded; eauto. i.
+      rewrite H. ss. esplits; eauto. eapply val_intptr_refl.
+Qed.
+
+Lemma eval_operation_wrapper_binded
+    m m' vl vl' sp op v
+    (CONCEXT: concrete_extends m m')
+    (BIND: val_intptrist m' vl vl')
+    (EVAL: eval_operation_wrapper genv sp op vl m = Some v) :
+  exists v', <<EVAL2: eval_operation_wrapper genv sp op vl' m' = Some v'>>
+      /\ <<VIND': val_intptr m' v v'>>.
+Proof.
+  destruct (ptr_op op) eqn:PTROP; cycle 1.
+  - unfold eval_operation_wrapper in *. rewrite PTROP in *.
+    destruct op; simpl in EVAL; simpl; FuncInv; InvBind; TrivialExists;
+      try (by (econs; eauto)); try (by (inv H2; ss; try econs)); try (by (inv H1; inv H2; ss; econs)).
+    + eapply symbol_address_binded.
+    + inv H1; inv H2; ss. des_ifs; clarify. esplits; eauto. econs.
+    + inv H1; inv H2; ss. des_ifs; clarify. esplits; eauto. econs.
+    + inv H1; inv H2; ss. des_ifs; clarify. esplits; eauto. econs.
+    + inv H1; inv H2; ss. des_ifs; clarify. esplits; eauto. econs.
+    + inv H1; inv H2; ss; try econs. des_ifs; econs; eauto.
+    + inv H2; ss; try econs. des_ifs; econs; eauto.
+    + inv H1; inv H2; ss; try econs. des_ifs; econs; eauto.
+    + inv H2; ss; try econs. des_ifs; econs; eauto.
+    + inv H1; ss; try discriminate. des_ifs. esplits; eauto. econs.
+    + inv H1; inv H2; ss; try econs. des_ifs; clarify; econs.
+    + inv H2; ss; try econs. des_ifs; econs; eauto.
+    + inv H1; inv H2; ss; try econs; des_ifs; clarify; econs.
+    + eapply eval_addressing32_binded; eauto.
+    + eapply addl_bind; eauto. econs.
+    + eapply subl_bind; eauto.
+    + inv H1; inv H2; ss. des_ifs; clarify. esplits; eauto. econs.
+    + inv H1; inv H2; ss. des_ifs; clarify. esplits; eauto. econs.
+    + inv H1; inv H2; ss. des_ifs; clarify. esplits; eauto. econs.
+    + inv H1; inv H2; ss. des_ifs; clarify. esplits; eauto. econs.
+    + inv H1; inv H2; ss; try econs. des_ifs; econs; eauto.
+    + inv H2; ss; try econs. des_ifs; econs; eauto.
+    + inv H1; inv H2; ss; try econs. des_ifs; econs; eauto.
+    + inv H2; ss; try econs. des_ifs; econs; eauto.
+    + inv H1; ss; try discriminate. des_ifs. esplits; eauto. econs.
+    + inv H1; inv H2; ss; try econs. des_ifs; clarify; econs.
+    + inv H2; ss; try econs. des_ifs; econs; eauto.
+    + eapply eval_addressing64_binded; eauto.
+    + inv H1; simpl in EVAL; clarify. destruct (Float.to_int f) eqn:A; ss; clarify.
+      exists (Vint i); auto. rewrite A. ss. esplits; eauto. econs.
+    + inv H1; simpl in EVAL; clarify. esplits; ss; eauto. econs.
+    + inv H1; simpl in EVAL; clarify. destruct (Float32.to_int f) eqn:A; ss; clarify.
+      exists (Vint i); auto. rewrite A. ss. esplits; eauto. econs.
+    + inv H1; simpl in EVAL; clarify. esplits; ss; eauto. econs.
+    + inv H1; simpl in EVAL; clarify. destruct (Float.to_long f) eqn:A; ss; clarify.
+      exists (Vlong i); auto. rewrite A. ss. esplits; eauto. econs.
+    + inv H1; simpl in EVAL; clarify. esplits; ss; eauto. econs.
+    + inv H1; simpl in EVAL; clarify. destruct (Float32.to_long f) eqn:A; ss; clarify.
+      exists (Vlong i); auto. rewrite A. ss. esplits; eauto. econs.
+    + inv H1; simpl in EVAL; clarify. esplits; ss; eauto. econs.
+    + subst v. destruct (eval_condition cond vl m) eqn:?; cycle 1.
+      { ss. econs. }
+      exploit eval_condition_binded_no_ptr_binary; eauto. i. des.
+      rewrite H. ss. eapply val_intptr_refl.
+    + eapply select_binded; eauto. destruct (eval_condition c vl m) eqn:?; auto.
+      right. symmetry. eapply eval_condition_binded_no_ptr_binary; eauto.
+  (* ptr operations *)
+  - destruct (Archi.ptr64) eqn:BIT.
+    + destruct (ptr_binop op) eqn:PTRBINOP.
+      (* ptr binop *)
+      { unfold eval_operation_wrapper in *. rewrite PTROP in EVAL.
+        assert (EVAL1: eval_operation_join genv sp op vl m = Some v) by (destruct op; ss).
+        clear EVAL. exploit eval_operation_join_binded; eauto. i. des. rewrite EVAL2.
+        esplits; eauto. rewrite PTROP. destruct op; simpl in *; clarify. }
+      unfold ptr_op, ptr_cond in PTROP. (* rewrite BIT in *. *)
+      destruct op; simpl in *; try rewrite BIT in *; inv PTROP; inv PTRBINOP.
+      { rewrite H0 in H1. inv H1. }
+      (* sel *)
+      destruct c; simpl in *; inv H0.
+      2:{ unfold eval_operation_wrapper in *.
+          (* simpl in *. *) do 2 (destruct BIND;[inv EVAL|]).
+          assert (PTRCMP: ptr_op (Osel (Ccompluimm c n) t) = true).
+          { simpl. unfold ptr_cond. eapply orb_true_intro. left. simpl. eauto. }
+          rewrite PTRCMP in *.
+          destruct ((eval_condition_join (Ccompluimm c n) vl1 m)) eqn:COND1.
+          2:{ simpl in EVAL. inv EVAL. esplits; eauto. econs. }
+          exploit eval_condition_join_binded; eauto.
+          i. rewrite H1. inv EVAL. simpl. esplits; eauto. simpl.
+          eapply normalize_binded; eauto. destruct b; eauto. }
+      unfold eval_operation_wrapper in *.
+      (* simpl in *. *) do 2 (destruct BIND;[inv EVAL|]).
+      assert (PTRCMP: ptr_op (Osel (Ccomplu c) t) = true).
+      { simpl. unfold ptr_cond. eapply orb_true_intro. right. simpl. eauto. }
+      rewrite PTRCMP in *.
+      destruct ((eval_condition_join (Ccomplu c) vl1 m)) eqn:COND1.
+      2:{ simpl in EVAL. inv EVAL. esplits; eauto. econs. }
+      exploit eval_condition_join_binded; eauto.
+      i. rewrite H1. inv EVAL. simpl. esplits; eauto. simpl.
+      eapply normalize_binded; eauto. destruct b; eauto.
+    + destruct (ptr_binop op) eqn:PTRBINOP.
+      (* ptr binop *)
+      { unfold eval_operation_wrapper in *. rewrite PTROP in EVAL.
+        assert (EVAL1: eval_operation_join genv sp op vl m = Some v) by (destruct op; ss).
+        clear EVAL. exploit eval_operation_join_binded; eauto. i. des. rewrite EVAL2.
+        esplits; eauto. rewrite PTROP. destruct op; simpl in *; clarify. }
+      unfold ptr_op, ptr_cond in PTROP. (* rewrite BIT in *. *)
+      destruct op; simpl in *; try rewrite BIT in *; inv PTROP; inv PTRBINOP.
+      { rewrite H0 in H1. inv H1. }
+      unfold ptr_uncond, ptr_bincond in *. rewrite BIT in *. simpl in *.
+      (* sel *)
+      destruct c; simpl in *; inv H0.
+      2:{ unfold eval_operation_wrapper in *.
+          (* simpl in *. *) do 2 (destruct BIND;[inv EVAL|]).
+          assert (PTRCMP: ptr_op (Osel (Ccompuimm c n) t) = true).
+          { simpl. unfold ptr_cond. eapply orb_true_intro. left. simpl. eauto. }
+          rewrite PTRCMP in *.
+          destruct ((eval_condition_join (Ccompuimm c n) vl1 m)) eqn:COND1.
+          2:{ simpl in EVAL. inv EVAL. esplits; eauto. econs. }
+          exploit eval_condition_join_binded; eauto.
+          i. rewrite H1. inv EVAL. simpl. esplits; eauto. simpl.
+          eapply normalize_binded; eauto. destruct b; eauto. }
+      unfold eval_operation_wrapper in *.
+      (* simpl in *. *) do 2 (destruct BIND;[inv EVAL|]).
+      assert (PTRCMP: ptr_op (Osel (Ccompu c) t) = true).
+      { simpl. unfold ptr_cond. eapply orb_true_intro. right. simpl. eauto. }
+      rewrite PTRCMP in *.
+      destruct ((eval_condition_join (Ccompu c) vl1 m)) eqn:COND1.
+      2:{ simpl in EVAL. inv EVAL. esplits; eauto. econs. }
+      exploit eval_condition_join_binded; eauto.
+      i. rewrite H1. inv EVAL. simpl. esplits; eauto. simpl.
+      eapply normalize_binded; eauto. destruct b; eauto.
+Qed.
+
+End EVAL_WRAPPER_REFINE.
diff --git a/x86/Lowerbound.v b/x86/Lowerbound.v
new file mode 100644
index 00000000..3cd7194c
--- /dev/null
+++ b/x86/Lowerbound.v
@@ -0,0 +1,3225 @@
+(* *********************************************************************)
+(*                                                                     *)
+(*              The Compcert verified compiler                         *)
+(*                                                                     *)
+(*                  Xavier Leroy, INRIA Paris                          *)
+(*                                                                     *)
+(*  Copyright Institut National de Recherche en Informatique et en     *)
+(*  Automatique.  All rights reserved.  This file is distributed       *)
+(*  under the terms of the INRIA Non-Commercial License Agreement.     *)
+(*                                                                     *)
+(* *********************************************************************)
+
+(** Abstract syntax and semantics for IA32 assembly language *)
+
+Require Import Coqlib Maps.
+Require Import AST Integers Floats Values Memory Events Globalenvs Smallstep.
+Require Import Locations Stacklayout Conventions.
+Require Import IntPtrRel PointerOp CoqlibC Simulation.
+Require Import IntPtrRef Asm.
+
+(** * Abstract syntax *)
+
+(** ** Registers. *)
+
+(** Integer registers. *)
+
+Section RELSEM.
+
+Definition val_add_one (v: val) : val :=
+  match v with
+  | Vptr b ofs => Vptr b (Ptrofs.add ofs Ptrofs.one)
+  | Vlong n => if Archi.ptr64 then Vlong (Int64.add n Int64.one) else Vundef
+  | Vint n => if negb Archi.ptr64 then Vint (Int.add n Int.one) else Vundef
+  | _ => Vundef
+  end.
+
+Definition val_add_ptrofs (v: val) (delta: ptrofs) : val :=
+  match v with
+  | Vptr b ofs => Vptr b (Ptrofs.add ofs delta)
+  | Vlong n => if Archi.ptr64 then Vlong (Int64.add n (Ptrofs.to_int64 delta)) else Vundef
+  | Vint n => if negb Archi.ptr64 then Vint (Int.add n (Ptrofs.to_int delta)) else Vundef
+  | _ => Vundef
+  end.
+
+Section EVAL_BUILTIN_ARG.
+
+Variable A: Type.
+Variable ge: Senv.t.
+Variable e: A -> val.
+Variable sp: val.
+Variable m: mem.
+
+Inductive eval_builtin_arg: builtin_arg A -> val -> Prop :=
+  | eval_BA: forall x,
+      eval_builtin_arg (BA x) (e x)
+  | eval_BA_int: forall n,
+      eval_builtin_arg (BA_int n) (Vint n)
+  | eval_BA_long: forall n,
+      eval_builtin_arg (BA_long n) (Vlong n)
+  | eval_BA_float: forall n,
+      eval_builtin_arg (BA_float n) (Vfloat n)
+  | eval_BA_single: forall n,
+      eval_builtin_arg (BA_single n) (Vsingle n)
+  | eval_BA_loadstack: forall chunk ofs v,
+      Mem.loadv chunk m (val_add_ptrofs sp ofs) = Some v ->
+      eval_builtin_arg (BA_loadstack chunk ofs) v
+  | eval_BA_addrstack: forall ofs,
+      eval_builtin_arg (BA_addrstack ofs) (val_add_ptrofs sp ofs)
+  | eval_BA_loadglobal: forall chunk id ofs v,
+      Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v ->
+      eval_builtin_arg (BA_loadglobal chunk id ofs) v
+  | eval_BA_addrglobal: forall id ofs,
+      eval_builtin_arg (BA_addrglobal id ofs) (Senv.symbol_address ge id ofs)
+  | eval_BA_splitlong: forall hi lo vhi vlo,
+      eval_builtin_arg hi vhi -> eval_builtin_arg lo vlo ->
+      eval_builtin_arg (BA_splitlong hi lo) (Val.longofwords vhi vlo)
+  | eval_BA_addptr: forall a1 a2 v1 v2,
+      eval_builtin_arg a1 v1 -> eval_builtin_arg a2 v2 ->
+      eval_builtin_arg (BA_addptr a1 a2)
+                       (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2).
+
+Definition eval_builtin_args (al: list (builtin_arg A)) (vl: list val) : Prop :=
+  list_forall2 eval_builtin_arg al vl.
+
+Lemma eval_builtin_arg_determ:
+  forall a v, eval_builtin_arg a v -> forall v', eval_builtin_arg a v' -> v' = v.
+Proof.
+  induction 1; intros v' EV; inv EV; try congruence.
+  f_equal; eauto.
+  apply IHeval_builtin_arg1 in H3. apply IHeval_builtin_arg2 in H5. subst; auto.
+Qed.
+
+Lemma eval_builtin_args_determ:
+  forall al vl, eval_builtin_args al vl -> forall vl', eval_builtin_args al vl' -> vl' = vl.
+Proof.
+  induction 1; intros v' EV; inv EV; f_equal; eauto using eval_builtin_arg_determ.
+Qed.
+
+End EVAL_BUILTIN_ARG.
+
+Variable ge: genv.
+
+Definition nextinstr (rs: regset) :=
+  rs#PC <- (val_add_one (rs#PC)).
+
+Definition nextinstr_nf (rs: regset) : regset :=
+  nextinstr (undef_regs (CR ZF :: CR CF :: CR PF :: CR SF :: CR OF :: nil) rs).
+
+Definition goto_label (f: function) (lbl: label) (rs: regset) (m: mem) :=
+  match label_pos lbl 0 (fn_code f) with
+  | None => Stuck
+  | Some pos =>
+      match Mem.to_ptr (rs#PC) m with
+      | Some (Vptr b ofs) => Next (rs#PC <- (Vptr b (Ptrofs.repr pos))) m
+      | _ => Stuck
+    end
+  end.
+
+(** Auxiliaries for memory accesses. *)
+
+Definition exec_load (chunk: memory_chunk) (m: mem)
+                     (a: addrmode) (rs: regset) (rd: preg) :=
+  match Mem.loadv chunk m (eval_addrmode ge a rs) with
+  | Some v => Next (nextinstr_nf (rs#rd <- v)) m
+  | None => Stuck
+  end.
+
+Definition exec_store (chunk: memory_chunk) (m: mem)
+                      (a: addrmode) (rs: regset) (r1: preg)
+                      (destroyed: list preg) :=
+  match Mem.storev chunk m (eval_addrmode ge a rs) (rs r1) with
+  | Some m' => Next (nextinstr_nf (undef_regs destroyed rs)) m'
+  | None => Stuck
+  end.
+
+Definition exec_instr (f: function) (i: instruction) (rs: regset) (m: mem) : outcome :=
+  match i with
+  (** Moves *)
+  | Pmov_rr rd r1 =>
+      Next (nextinstr (rs#rd <- (rs r1))) m
+  | Pmovl_ri rd n =>
+      Next (nextinstr_nf (rs#rd <- (Vint n))) m
+  | Pmovq_ri rd n =>
+      Next (nextinstr_nf (rs#rd <- (Vlong n))) m
+  | Pmov_rs rd id =>
+      Next (nextinstr_nf (rs#rd <- (Genv.symbol_address ge id Ptrofs.zero))) m
+  | Pmovl_rm rd a =>
+      exec_load Mint32 m a rs rd
+  | Pmovq_rm rd a =>
+      exec_load Mint64 m a rs rd
+  | Pmovl_mr a r1 =>
+      exec_store Mint32 m a rs r1 nil
+  | Pmovq_mr a r1 =>
+      exec_store Mint64 m a rs r1 nil
+  | Pmovsd_ff rd r1 =>
+      Next (nextinstr (rs#rd <- (rs r1))) m
+  | Pmovsd_fi rd n =>
+      Next (nextinstr (rs#rd <- (Vfloat n))) m
+  | Pmovsd_fm rd a =>
+      exec_load Mfloat64 m a rs rd
+  | Pmovsd_mf a r1 =>
+      exec_store Mfloat64 m a rs r1 nil
+  | Pmovss_fi rd n =>
+      Next (nextinstr (rs#rd <- (Vsingle n))) m
+  | Pmovss_fm rd a =>
+      exec_load Mfloat32 m a rs rd
+  | Pmovss_mf a r1 =>
+      exec_store Mfloat32 m a rs r1 nil
+  | Pfldl_m a =>
+      exec_load Mfloat64 m a rs ST0
+  | Pfstpl_m a =>
+      exec_store Mfloat64 m a rs ST0 (ST0 :: nil)
+  | Pflds_m a =>
+      exec_load Mfloat32 m a rs ST0
+  | Pfstps_m a =>
+      exec_store Mfloat32 m a rs ST0 (ST0 :: nil)
+  (** Moves with conversion *)
+  | Pmovb_mr a r1 =>
+      exec_store Mint8unsigned m a rs r1 nil
+  | Pmovw_mr a r1 =>
+      exec_store Mint16unsigned m a rs r1 nil
+  | Pmovzb_rr rd r1 =>
+      Next (nextinstr (rs#rd <- (Val.zero_ext 8 rs#r1))) m
+  | Pmovzb_rm rd a =>
+      exec_load Mint8unsigned m a rs rd
+  | Pmovsb_rr rd r1 =>
+      Next (nextinstr (rs#rd <- (Val.sign_ext 8 rs#r1))) m
+  | Pmovsb_rm rd a =>
+      exec_load Mint8signed m a rs rd
+  | Pmovzw_rr rd r1 =>
+      Next (nextinstr (rs#rd <- (Val.zero_ext 16 rs#r1))) m
+  | Pmovzw_rm rd a =>
+      exec_load Mint16unsigned m a rs rd
+  | Pmovsw_rr rd r1 =>
+      Next (nextinstr (rs#rd <- (Val.sign_ext 16 rs#r1))) m
+  | Pmovsw_rm rd a =>
+      exec_load Mint16signed m a rs rd
+  | Pmovzl_rr rd r1 =>
+      Next (nextinstr (rs#rd <- (Val.longofintu rs#r1))) m
+  | Pmovsl_rr rd r1 =>
+      Next (nextinstr (rs#rd <- (Val.longofint rs#r1))) m
+  | Pmovls_rr rd =>
+      Next (nextinstr (rs#rd <- (Val.loword rs#rd))) m
+  | Pcvtsd2ss_ff rd r1 =>
+      Next (nextinstr (rs#rd <- (Val.singleoffloat rs#r1))) m
+  | Pcvtss2sd_ff rd r1 =>
+      Next (nextinstr (rs#rd <- (Val.floatofsingle rs#r1))) m
+  | Pcvttsd2si_rf rd r1 =>
+      Next (nextinstr (rs#rd <- (Val.maketotal (Val.intoffloat rs#r1)))) m
+  | Pcvtsi2sd_fr rd r1 =>
+      Next (nextinstr (rs#rd <- (Val.maketotal (Val.floatofint rs#r1)))) m
+  | Pcvttss2si_rf rd r1 =>
+      Next (nextinstr (rs#rd <- (Val.maketotal (Val.intofsingle rs#r1)))) m
+  | Pcvtsi2ss_fr rd r1 =>
+      Next (nextinstr (rs#rd <- (Val.maketotal (Val.singleofint rs#r1)))) m
+  | Pcvttsd2sl_rf rd r1 =>
+      Next (nextinstr (rs#rd <- (Val.maketotal (Val.longoffloat rs#r1)))) m
+  | Pcvtsl2sd_fr rd r1 =>
+      Next (nextinstr (rs#rd <- (Val.maketotal (Val.floatoflong rs#r1)))) m
+  | Pcvttss2sl_rf rd r1 =>
+      Next (nextinstr (rs#rd <- (Val.maketotal (Val.longofsingle rs#r1)))) m
+  | Pcvtsl2ss_fr rd r1 =>
+      Next (nextinstr (rs#rd <- (Val.maketotal (Val.singleoflong rs#r1)))) m
+  (** Integer arithmetic *)
+  | Pleal rd a =>
+      Next (nextinstr (rs#rd <- (eval_addrmode32 ge a rs))) m
+  | Pleaq rd a =>
+      Next (nextinstr (rs#rd <- (eval_addrmode64 ge a rs))) m
+  | Pnegl rd =>
+      Next (nextinstr_nf (rs#rd <- (Val.neg rs#rd))) m
+  | Pnegq rd =>
+      Next (nextinstr_nf (rs#rd <- (Val.negl rs#rd))) m
+  | Paddl_ri rd n =>
+      Next (nextinstr_nf (rs#rd <- (Val.add rs#rd (Vint n)))) m
+  | Paddq_ri rd n =>
+      Next (nextinstr_nf (rs#rd <- (Val.addl rs#rd (Vlong n)))) m
+  | Psubl_rr rd r1 =>
+      Next (nextinstr_nf (rs#rd <- (Val.sub rs#rd rs#r1))) m
+  | Psubq_rr rd r1 =>
+      Next (nextinstr_nf (rs#rd <- (Val.subl rs#rd rs#r1))) m
+  | Psubp_rr rd r1 =>
+      Next (nextinstr_nf (rs#rd <- (psub_join_asm m rs#rd rs#r1))) m
+  | Pimull_rr rd r1 =>
+      Next (nextinstr_nf (rs#rd <- (Val.mul rs#rd rs#r1))) m
+  | Pimulq_rr rd r1 =>
+      Next (nextinstr_nf (rs#rd <- (Val.mull rs#rd rs#r1))) m
+  | Pimull_ri rd n =>
+      Next (nextinstr_nf (rs#rd <- (Val.mul rs#rd (Vint n)))) m
+  | Pimulq_ri rd n =>
+      Next (nextinstr_nf (rs#rd <- (Val.mull rs#rd (Vlong n)))) m
+  | Pimull_r r1 =>
+      Next (nextinstr_nf (rs#RAX <- (Val.mul rs#RAX rs#r1)
+                            #RDX <- (Val.mulhs rs#RAX rs#r1))) m
+  | Pimulq_r r1 =>
+      Next (nextinstr_nf (rs#RAX <- (Val.mull rs#RAX rs#r1)
+                            #RDX <- (Val.mullhs rs#RAX rs#r1))) m
+  | Pmull_r r1 =>
+      Next (nextinstr_nf (rs#RAX <- (Val.mul rs#RAX rs#r1)
+                            #RDX <- (Val.mulhu rs#RAX rs#r1))) m
+  | Pmulq_r r1 =>
+      Next (nextinstr_nf (rs#RAX <- (Val.mull rs#RAX rs#r1)
+                            #RDX <- (Val.mullhu rs#RAX rs#r1))) m
+  | Pcltd =>
+      Next (nextinstr_nf (rs#RDX <- (Val.shr rs#RAX (Vint (Int.repr 31))))) m
+  | Pcqto =>
+      Next (nextinstr_nf (rs#RDX <- (Val.shrl rs#RAX (Vint (Int.repr 63))))) m
+  | Pdivl r1 =>
+      match rs#RDX, rs#RAX, rs#r1 with
+      | Vint nh, Vint nl, Vint d =>
+          match Int.divmodu2 nh nl d with
+          | Some(q, r) => Next (nextinstr_nf (rs#RAX <- (Vint q) #RDX <- (Vint r))) m
+          | None => Stuck
+          end
+      | _, _, _ => Stuck
+      end
+  | Pdivq r1 =>
+      match rs#RDX, rs#RAX, rs#r1 with
+      | Vlong nh, Vlong nl, Vlong d =>
+          match Int64.divmodu2 nh nl d with
+          | Some(q, r) => Next (nextinstr_nf (rs#RAX <- (Vlong q) #RDX <- (Vlong r))) m
+          | None => Stuck
+          end
+      | _, _, _ => Stuck
+      end
+  | Pidivl r1 =>
+      match rs#RDX, rs#RAX, rs#r1 with
+      | Vint nh, Vint nl, Vint d =>
+          match Int.divmods2 nh nl d with
+          | Some(q, r) => Next (nextinstr_nf (rs#RAX <- (Vint q) #RDX <- (Vint r))) m
+          | None => Stuck
+          end
+      | _, _, _ => Stuck
+      end
+  | Pidivq r1 =>
+      match rs#RDX, rs#RAX, rs#r1 with
+      | Vlong nh, Vlong nl, Vlong d =>
+          match Int64.divmods2 nh nl d with
+          | Some(q, r) => Next (nextinstr_nf (rs#RAX <- (Vlong q) #RDX <- (Vlong r))) m
+          | None => Stuck
+          end
+      | _, _, _ => Stuck
+      end
+  | Pandl_rr rd r1 =>
+      Next (nextinstr_nf (rs#rd <- (Val.and rs#rd rs#r1))) m
+  | Pandq_rr rd r1 =>
+      Next (nextinstr_nf (rs#rd <- (Val.andl rs#rd rs#r1))) m
+  | Pandl_ri rd n =>
+      Next (nextinstr_nf (rs#rd <- (Val.and rs#rd (Vint n)))) m
+  | Pandq_ri rd n =>
+      Next (nextinstr_nf (rs#rd <- (Val.andl rs#rd (Vlong n)))) m
+  | Porl_rr rd r1 =>
+      Next (nextinstr_nf (rs#rd <- (Val.or rs#rd rs#r1))) m
+  | Porq_rr rd r1 =>
+      Next (nextinstr_nf (rs#rd <- (Val.orl rs#rd rs#r1))) m
+  | Porl_ri rd n =>
+      Next (nextinstr_nf (rs#rd <- (Val.or rs#rd (Vint n)))) m
+  | Porq_ri rd n =>
+      Next (nextinstr_nf (rs#rd <- (Val.orl rs#rd (Vlong n)))) m
+  | Pxorl_r rd =>
+      Next (nextinstr_nf (rs#rd <- Vzero)) m
+  | Pxorq_r rd =>
+      Next (nextinstr_nf (rs#rd <- (Vlong Int64.zero))) m
+  | Pxorl_rr rd r1 =>
+      Next (nextinstr_nf (rs#rd <- (Val.xor rs#rd rs#r1))) m
+  | Pxorq_rr rd r1 =>
+      Next (nextinstr_nf (rs#rd <- (Val.xorl rs#rd rs#r1))) m
+  | Pxorl_ri rd n =>
+      Next (nextinstr_nf (rs#rd <- (Val.xor rs#rd (Vint n)))) m
+  | Pxorq_ri rd n =>
+      Next (nextinstr_nf (rs#rd <- (Val.xorl rs#rd (Vlong n)))) m
+  | Pnotl rd =>
+      Next (nextinstr_nf (rs#rd <- (Val.notint rs#rd))) m
+  | Pnotq rd =>
+      Next (nextinstr_nf (rs#rd <- (Val.notl rs#rd))) m
+  | Psall_rcl rd =>
+      Next (nextinstr_nf (rs#rd <- (Val.shl rs#rd rs#RCX))) m
+  | Psalq_rcl rd =>
+      Next (nextinstr_nf (rs#rd <- (Val.shll rs#rd rs#RCX))) m
+  | Psall_ri rd n =>
+      Next (nextinstr_nf (rs#rd <- (Val.shl rs#rd (Vint n)))) m
+  | Psalq_ri rd n =>
+      Next (nextinstr_nf (rs#rd <- (Val.shll rs#rd (Vint n)))) m
+  | Pshrl_rcl rd =>
+      Next (nextinstr_nf (rs#rd <- (Val.shru rs#rd rs#RCX))) m
+  | Pshrq_rcl rd =>
+      Next (nextinstr_nf (rs#rd <- (Val.shrlu rs#rd rs#RCX))) m
+  | Pshrl_ri rd n =>
+      Next (nextinstr_nf (rs#rd <- (Val.shru rs#rd (Vint n)))) m
+  | Pshrq_ri rd n =>
+      Next (nextinstr_nf (rs#rd <- (Val.shrlu rs#rd (Vint n)))) m
+  | Psarl_rcl rd =>
+      Next (nextinstr_nf (rs#rd <- (Val.shr rs#rd rs#RCX))) m
+  | Psarq_rcl rd =>
+      Next (nextinstr_nf (rs#rd <- (Val.shrl rs#rd rs#RCX))) m
+  | Psarl_ri rd n =>
+      Next (nextinstr_nf (rs#rd <- (Val.shr rs#rd (Vint n)))) m
+  | Psarq_ri rd n =>
+      Next (nextinstr_nf (rs#rd <- (Val.shrl rs#rd (Vint n)))) m
+  | Pshld_ri rd r1 n =>
+      Next (nextinstr_nf
+              (rs#rd <- (Val.or (Val.shl rs#rd (Vint n))
+                                (Val.shru rs#r1 (Vint (Int.sub Int.iwordsize n)))))) m
+  | Prorl_ri rd n =>
+      Next (nextinstr_nf (rs#rd <- (Val.ror rs#rd (Vint n)))) m
+  | Prorq_ri rd n =>
+      Next (nextinstr_nf (rs#rd <- (Val.rorl rs#rd (Vint n)))) m
+  | Pcmpl_rr r1 r2 =>
+      Next (nextinstr (compare_ints (rs r1) (rs r2) rs m)) m
+  | Pcmpq_rr r1 r2 =>
+      Next (nextinstr (compare_longs (rs r1) (rs r2) rs m)) m
+  | Pcmpl_ri r1 n =>
+      Next (nextinstr (compare_ints (rs r1) (Vint n) rs m)) m
+  | Pcmpq_ri r1 n =>
+      Next (nextinstr (compare_longs (rs r1) (Vlong n) rs m)) m
+  | Ptestl_rr r1 r2 =>
+      Next (nextinstr (compare_ints (Val.and (rs r1) (rs r2)) Vzero rs m)) m
+  | Ptestq_rr r1 r2 =>
+      Next (nextinstr (compare_longs (Val.andl (rs r1) (rs r2)) (Vlong Int64.zero) rs m)) m
+  | Ptestl_ri r1 n =>
+      Next (nextinstr (compare_ints (Val.and (rs r1) (Vint n)) Vzero rs m)) m
+  | Ptestq_ri r1 n =>
+      Next (nextinstr (compare_longs (Val.andl (rs r1) (Vlong n)) (Vlong Int64.zero) rs m)) m
+  | Pcmov c rd r1 =>
+      let v :=
+        match eval_testcond c rs with
+        | Some b => if b then rs#r1 else rs#rd
+        | None   => Vundef
+      end in
+      Next (nextinstr (rs#rd <- v)) m
+  | Psetcc c rd =>
+      Next (nextinstr (rs#rd <- (Val.of_optbool (eval_testcond c rs)))) m
+  (** Arithmetic operations over double-precision floats *)
+  | Paddd_ff rd r1 =>
+      Next (nextinstr (rs#rd <- (Val.addf rs#rd rs#r1))) m
+  | Psubd_ff rd r1 =>
+      Next (nextinstr (rs#rd <- (Val.subf rs#rd rs#r1))) m
+  | Pmuld_ff rd r1 =>
+      Next (nextinstr (rs#rd <- (Val.mulf rs#rd rs#r1))) m
+  | Pdivd_ff rd r1 =>
+      Next (nextinstr (rs#rd <- (Val.divf rs#rd rs#r1))) m
+  | Pnegd rd =>
+      Next (nextinstr (rs#rd <- (Val.negf rs#rd))) m
+  | Pabsd rd =>
+      Next (nextinstr (rs#rd <- (Val.absf rs#rd))) m
+  | Pcomisd_ff r1 r2 =>
+      Next (nextinstr (compare_floats (rs r1) (rs r2) rs)) m
+  | Pxorpd_f rd =>
+      Next (nextinstr_nf (rs#rd <- (Vfloat Float.zero))) m
+  (** Arithmetic operations over single-precision floats *)
+  | Padds_ff rd r1 =>
+      Next (nextinstr (rs#rd <- (Val.addfs rs#rd rs#r1))) m
+  | Psubs_ff rd r1 =>
+      Next (nextinstr (rs#rd <- (Val.subfs rs#rd rs#r1))) m
+  | Pmuls_ff rd r1 =>
+      Next (nextinstr (rs#rd <- (Val.mulfs rs#rd rs#r1))) m
+  | Pdivs_ff rd r1 =>
+      Next (nextinstr (rs#rd <- (Val.divfs rs#rd rs#r1))) m
+  | Pnegs rd =>
+      Next (nextinstr (rs#rd <- (Val.negfs rs#rd))) m
+  | Pabss rd =>
+      Next (nextinstr (rs#rd <- (Val.absfs rs#rd))) m
+  | Pcomiss_ff r1 r2 =>
+      Next (nextinstr (compare_floats32 (rs r1) (rs r2) rs)) m
+  | Pxorps_f rd =>
+      Next (nextinstr_nf (rs#rd <- (Vsingle Float32.zero))) m
+  (** Branches and calls *)
+  | Pjmp_l lbl =>
+      goto_label f lbl rs m
+  | Pjmp_s id sg =>
+      Next (rs#PC <- (Genv.symbol_address ge id Ptrofs.zero)) m
+  | Pjmp_r r sg =>
+      Next (rs#PC <- (rs r)) m
+  | Pjcc cond lbl =>
+      match eval_testcond cond rs with
+      | Some true => goto_label f lbl rs m
+      | Some false => Next (nextinstr rs) m
+      | None => Stuck
+      end
+  | Pjcc2 cond1 cond2 lbl =>
+      match eval_testcond cond1 rs, eval_testcond cond2 rs with
+      | Some true, Some true => goto_label f lbl rs m
+      | Some _, Some _ => Next (nextinstr rs) m
+      | _, _ => Stuck
+      end
+  | Pjmptbl r tbl =>
+      match rs#r with
+      | Vint n =>
+          match list_nth_z tbl (Int.unsigned n) with
+          | None => Stuck
+          | Some lbl => goto_label f lbl (rs #RAX <- Vundef #RDX <- Vundef) m
+          end
+      | _ => Stuck
+      end
+  | Pcall_s id sg =>
+      (* make Val.offset_ptr to val_add_one *)
+      Next (rs#RA <- (val_add_one rs#PC) #PC <- (Genv.symbol_address ge id Ptrofs.zero)) m
+  | Pcall_r r sg =>
+      Next (rs#RA <- (val_add_one rs#PC) #PC <- (rs r)) m
+  | Pret =>
+      Next (rs#PC <- (rs#RA)) m
+  (** Saving and restoring registers *)
+  | Pmov_rm_a rd a =>
+      exec_load (if Archi.ptr64 then Many64 else Many32) m a rs rd
+  | Pmov_mr_a a r1 =>
+      exec_store (if Archi.ptr64 then Many64 else Many32) m a rs r1 nil
+  | Pmovsd_fm_a rd a =>
+      exec_load Many64 m a rs rd
+  | Pmovsd_mf_a a r1 =>
+      exec_store Many64 m a rs r1 nil
+  (** Pseudo-instructions *)
+  | Plabel lbl =>
+      Next (nextinstr rs) m
+  | Pallocframe sz ofs_ra ofs_link =>
+      let (m1, stk) := Mem.alloc m 0 sz in
+      let sp := Vptr stk Ptrofs.zero in
+      match Mem.storev Mptr m1 (Val.offset_ptr sp ofs_link) rs#RSP with
+      | None => Stuck
+      | Some m2 =>
+          match Mem.storev Mptr m2 (Val.offset_ptr sp ofs_ra) rs#RA with
+          | None => Stuck
+          | Some m3 => Next (nextinstr (rs #RAX <- (rs#RSP) #RSP <- sp)) m3
+          end
+      end
+  | Pfreeframe sz ofs_ra ofs_link =>
+      match Mem.loadv Mptr m (val_add_ptrofs rs#RSP ofs_ra) with
+      | None => Stuck
+      | Some ra =>
+          match Mem.loadv Mptr m (val_add_ptrofs rs#RSP ofs_link) with
+          | None => Stuck
+          | Some sp =>
+              match to_ptr (val_add_ptrofs rs#RSP ofs_ra) m with
+              | Vptr stk ofs =>
+                  match Mem.free m stk 0 sz with
+                  | None => Stuck
+                  | Some m' => Next (nextinstr (rs#RSP <- sp #RA <- ra)) m'
+                  end
+              | _ => Stuck
+              end
+          end
+      end
+  | Pbuiltin ef args res =>
+      Stuck                             (**r treated specially below *)
+  (** The following instructions and directives are not generated *)
+(*       directly by [Asmgen], so we do not model them. *)
+  | Padcl_ri _ _
+  | Padcl_rr _ _
+  | Paddl_mi _ _
+  | Paddl_rr _ _
+  | Pbsfl _ _
+  | Pbsfq _ _
+  | Pbsrl _ _
+  | Pbsrq _ _
+  | Pbswap64 _
+  | Pbswap32 _
+  | Pbswap16 _
+  | Pcfi_adjust _
+  | Pfmadd132 _ _ _
+  | Pfmadd213 _ _ _
+  | Pfmadd231 _ _ _
+  | Pfmsub132 _ _ _
+  | Pfmsub213 _ _ _
+  | Pfmsub231 _ _ _
+  | Pfnmadd132 _ _ _
+  | Pfnmadd213 _ _ _
+  | Pfnmadd231 _ _ _
+  | Pfnmsub132 _ _ _
+  | Pfnmsub213 _ _ _
+  | Pfnmsub231 _ _ _
+  | Pmaxsd _ _
+  | Pminsd _ _
+  | Pmovb_rm _ _
+  | Pmovq_rf _ _
+  | Pmovsq_rm _ _
+  | Pmovsq_mr _ _
+  | Pmovsb
+  | Pmovsw
+  | Pmovw_rm _ _
+  | Pnop
+  | Prep_movsl
+  | Psbbl_rr _ _
+  | Psqrtsd _ _
+  | Psubl_ri _ _
+  | Psubq_ri _ _ => Stuck
+  end.
+
+Inductive extcall_arg (rs: regset) (m: mem): loc -> val -> Prop :=
+  | extcall_arg_reg: forall r,
+      extcall_arg rs m (R r) (rs (preg_of r))
+  | extcall_arg_stack: forall ofs ty bofs v,
+      bofs = Stacklayout.fe_ofs_arg + 4 * ofs ->
+      Mem.loadv (chunk_of_type ty) m
+                (val_add_ptrofs (rs (IR RSP)) (Ptrofs.repr bofs)) = Some v ->
+      extcall_arg rs m (S Outgoing ofs ty) v.
+
+Inductive extcall_arg_pair (rs: regset) (m: mem): rpair loc -> val -> Prop :=
+  | extcall_arg_one: forall l v,
+      extcall_arg rs m l v ->
+      extcall_arg_pair rs m (One l) v
+  | extcall_arg_twolong: forall hi lo vhi vlo,
+      extcall_arg rs m hi vhi ->
+      extcall_arg rs m lo vlo ->
+      extcall_arg_pair rs m (Twolong hi lo) (Val.longofwords vhi vlo).
+
+Definition extcall_arguments
+    (rs: regset) (m: mem) (sg: signature) (args: list val) : Prop :=
+  list_forall2 (extcall_arg_pair rs m) (loc_arguments sg) args.
+
+(** Execution of the instruction at [rs#PC]. *)
+
+Inductive state: Type :=
+  | State: regset -> mem -> state.
+
+Inductive astep: state -> trace -> state -> Prop :=
+  | exec_step_internal:
+      forall b ofs f i rs m rs' m',
+      Mem.to_ptr (rs PC) m = Some (Vptr b ofs) ->
+      Genv.find_funct_ptr ge b = Some (Internal f) ->
+      find_instr (Ptrofs.unsigned ofs) f.(fn_code) = Some i ->
+      exec_instr f i rs m = Next rs' m' ->
+      astep (State rs m) E0 (State rs' m')
+  | exec_step_builtin:
+      forall b ofs f ef args res rs m vargs t vres rs' m',
+      Mem.to_ptr (rs PC) m = Some (Vptr b ofs) ->
+      Genv.find_funct_ptr ge b = Some (Internal f) ->
+      find_instr (Ptrofs.unsigned ofs) f.(fn_code) = Some (Pbuiltin ef args res) ->
+      eval_builtin_args PregEq.t ge rs (rs RSP) m args vargs ->
+      external_call ef ge vargs m t vres m' ->
+      rs' = nextinstr_nf
+             (set_res res vres
+               (undef_regs (map preg_of (destroyed_by_builtin ef)) rs)) ->
+      astep (State rs m) t (State rs' m')
+  | exec_step_external:
+      forall b ef args res rs m t rs' m',
+      Mem.to_ptr (rs PC) m = Some (Vptr b Ptrofs.zero) ->
+      Genv.find_funct_ptr ge b = Some (External ef) ->
+      extcall_arguments rs m (ef_sig ef) args ->
+      external_call ef ge args m t res m' ->
+      rs' = (set_pair (loc_external_result (ef_sig ef)) res (undef_caller_save_regs rs)) #PC <- (rs RA) ->
+      astep (State rs m) t (State rs' m').
+
+Definition goto_label_state (s: Asm.state) : Prop :=
+  match s with
+  | Asm.State rs m => match (rs PC) with
+                     | Vptr b ofs => match Genv.find_funct_ptr ge b with
+                                    | Some (Internal f) =>
+                                        match find_instr (Ptrofs.unsigned ofs) f.(fn_code) with
+                                        | Some i => match i with
+                                                   | Pjmp_l _ | Pjcc _ _ | Pjcc2 _ _ _ | Pjmptbl _ _ => True
+                                                   | _ => False
+                                                   end
+                                        | _ => False
+                                        end
+                                    | _ => False
+                                    end
+                     | _ => False
+                     end
+  end.
+
+Definition register_concretizer (m: mem) (rs rs': regset) : Prop :=
+  forall r, match rs#r with
+       | Vptr b ofs =>
+           if Mem.is_valid m b
+           then val_intptr m (Vptr b ofs) (rs'#r) /\ is_int_value (rs'#r)
+           (* invalid pointer: ill-formed register *)
+           else rs#r = rs'#r
+       | _ => rs#r = rs'#r
+       end.
+
+Definition register_concretizer_func (m: mem) (v: val) : val :=
+  match v with
+  | Vptr b ofs => if Mem.is_valid m b
+                 then (match Mem.to_int (Vptr b ofs) m with
+                       | Some v => v
+                       | _ => Vundef
+                       end)
+                 else v
+  | _ => v
+  end.
+             
+Lemma register_concretizer_exists m rs
+  (ALLCONC: forall b (VLD: Mem.valid_block m b), exists addr, m.(Mem.mem_concrete) ! b = Some addr):
+  exists rs', register_concretizer m rs rs'.
+Proof.
+  exists (Pregmap.map (register_concretizer_func m) rs). ii. des_ifs; try by (unfold Pregmap.map; rewrite Heq; ss).
+  - unfold Pregmap.map. rewrite Heq. ss. rewrite Heq0.
+    rewrite <- Mem.valid_block_iff_is_valid in Heq0. exploit ALLCONC; eauto. i. des.
+    unfold Mem.ptr2int. des_ifs_safe; ss. des_ifs. split; eauto.
+    econs; eauto. ss. unfold Mem.ptr2int. rewrite Heq1. des_ifs.
+  - unfold Pregmap.map. rewrite Heq. ss. rewrite Heq0. eauto.
+Qed.
+
+Inductive cstep : state -> state -> Prop :=
+| cstep_intros
+    m m' m'' rs rs'
+    (CONC: memory_block_concretize m m')
+    (CCONC: memory_concretize_contents m' m'')
+    (RCONC: register_concretizer m'' rs rs'):
+  cstep (State rs m) (State rs' m'')
+.
+
+Inductive step : state -> trace -> state -> Prop :=
+| step_intro
+    st tr st' st''
+    (ASTEP: astep st tr st')
+    (CSTEP: cstep st' st''):
+  step st tr st''
+| step_oom
+    st tr st' tr'
+    (ASTEP: astep st tr st')
+    (COOM: forall st'', ~ cstep st' st'')
+    (OOMTR: tr' = tr ++ [Event_pterm]) :
+  step st tr' st'.
+
+End RELSEM.
+
+(** Execution of whole programs. *)
+
+Inductive initial_state (p: program): state -> Prop :=
+  | initial_state_intro: forall m0,
+      Genv.init_mem p = Some m0 ->
+      let ge := Genv.globalenv p in
+      let rs0 :=
+        (Pregmap.init Vundef)
+        # PC <- (Genv.symbol_address ge p.(prog_main) Ptrofs.zero)
+        # RA <- Vnullptr
+        # RSP <- Vnullptr in
+      initial_state p (State rs0 m0).
+
+Definition function_length (f: function) : Z :=
+  let len := Zlength f.(fn_code) in
+  if zeq len 0 then 1 else len.
+
+Section LBDINIT.
+
+Variable p: program.
+Let ge := Genv.globalenv p.
+
+Definition realloc_global (m: mem) (b:block): option mem :=
+  match Genv.find_funct_ptr ge b with
+  | Some (Internal f) => Mem.nonempty_alloc m b 0 (function_length f)
+  | Some (External ef) => Some m
+  | _ => Some m
+  end.
+
+
+Inductive _realloc_globals : mem -> block -> mem -> Prop :=
+| _realloc_globals_1
+    b m m'
+    (BLK: b = 1%positive)
+    (RA: realloc_global m 1%positive = Some m'):
+  _realloc_globals m b m'
+| _realloc_globals_pos
+    m b m' m''
+    (BLK: b <> 1%positive)
+    (RA: realloc_global m b = Some m')
+    (RA: _realloc_globals m' (b - 1)%positive m''):
+  _realloc_globals m b m''.
+
+Definition realloc_globals (m m': mem) : Prop :=
+  _realloc_globals m (m.(Mem.nextblock) - 1)%positive m'.
+
+Lemma realloc_globals_determ
+    m m' m''
+    (RA1: realloc_globals m m')
+    (RA2: realloc_globals m m''):
+  m' = m''.
+Proof.
+  unfold realloc_globals in *. des_ifs.
+  remember ((Mem.nextblock m - 1)%positive). (* clear n. *)
+  clear Heqp0. revert RA2 RA1. revert m m' m''. revert p0.
+  induction p0 using positive_Peano_ind; i.
+  - inv RA1; inv RA2; clarify.
+  - inv RA1; inv RA2; try by (exfalso; eapply Pos.succ_not_1; eauto).
+    Eq.
+    assert ((Pos.succ p0 - 1 = p0)%positive).
+    { lia. }
+    erewrite H in *. eapply IHp0; eauto.
+Qed.
+
+End LBDINIT.
+
+Inductive initial_state_r (p: program): state -> Prop :=
+| initial_state_r_intro rs0 m0 m'
+    (INIT: initial_state p (State rs0 m0))
+    (REA: realloc_globals p m0 m'):
+  initial_state_r p (State rs0 m').
+
+Inductive glob_capture (p: program) : state -> state -> Prop :=
+  | glob_capture_intro
+      rs m pbs m'
+      (NONSTATIC: Genv.non_static_glob (Genv.globalenv p) (Genv.genv_public (Genv.globalenv p)) = pbs)
+      (CAPTURE: Genv.capture_init_mem m pbs m') :
+    glob_capture p (State rs m) (State rs m').
+
+Inductive glob_capture_c (p: program) : state -> state -> Prop :=
+| glob_capture_c_intro
+    s s' s''
+    (GC: glob_capture p s s')
+    (CS: cstep s' s''):
+  glob_capture_c p s s''.
+
+Definition state_mem (st: state) : mem :=
+  match st with
+  | State _ m => m
+  end.
+
+Definition concrete_snapshot (ge: Senv.t) (st: state) (id: ident) : option Z :=
+  if Senv.public_symbol ge id
+  then (match Senv.find_symbol ge id with
+        | Some b => Maps.PTree.get b (state_mem st).(Mem.mem_concrete)
+        | None => None
+        end
+    )
+  else None.
+
+Inductive final_state: state -> int -> Prop :=
+  | final_state_intro: forall rs m r,
+      rs#PC = Vnullptr ->
+      rs#RAX = Vint r ->
+      final_state (State rs m) r.
+
+(** Non-deterministic external state *)
+
+Definition is_external (ge: genv) (st: state): Prop := False.
+
+Definition semantics (p: program) :=
+  Semantics step (initial_state_r p) (glob_capture_c p) (concrete_snapshot (Genv.globalenv p)) final_state is_external (Genv.globalenv p).
+
+(* move to Memory.v *)
+Lemma nonempty_nonempty_alloc
+    m b lo hi m' k
+    (LT: lo < hi)
+    (CONC: Mem.is_concrete m b = false)
+    (NA: Mem.nonempty_alloc m b lo hi = Some m'):
+  Mem.range_perm m' b lo hi k Nonempty
+/\ (forall ofs k, (lo <= ofs < hi) -> forall p, Mem.perm m' b ofs k p -> p = Nonempty).
+Proof.
+  unfold Mem.nonempty_alloc in NA. des_ifs.
+  unfold Mem.range_perm, Mem.perm. ss. erewrite CONC. splits.
+  { i. erewrite PMap.gss; eauto. des_ifs.
+    2:{ exfalso. clear - H Heq.
+        eapply andb_false_iff in Heq. des.
+        - eapply proj_sumbool_false in Heq. lia.
+        - eapply proj_sumbool_false in Heq. lia. }
+    ss. econs. }
+  ii. erewrite PMap.gss in H0. des_ifs. inv H0; eauto.
+Qed.
+
+Lemma function_length_pos f: function_length f > 0.
+Proof.
+  unfold function_length. des_ifs. induction (fn_code f).
+  - rewrite Zlength_nil in n. clarify.
+  - rewrite Zlength_cons. destruct c; ss. lia.
+Qed.    
+
+Lemma nonempty_realloc_global
+    p m b m' k f
+    (CONC: Mem.is_concrete m b = false)
+    (FUNC: Genv.find_funct_ptr (Genv.globalenv p) b = Some (Internal f))
+    (RA: realloc_global p m b = Some m'):
+  Mem.range_perm m' b 0 (function_length f) k Nonempty
+/\ (forall ofs k, (0 <= ofs < function_length f) -> forall p, Mem.perm m' b ofs k p -> p = Nonempty).
+    (* (forall p, Mem.range_perm m' b 0 (function_length f) k p -> p = Nonempty). *)
+Proof.
+  unfold realloc_global in RA. unfold fundef in *.
+  erewrite FUNC in RA. eapply nonempty_nonempty_alloc; eauto.
+  specialize (function_length_pos f). lia.
+Qed.
+
+Lemma nonempty_realloc_global_neq
+    p m b m' b'
+    (NEQ: b <> b')
+    (RA: realloc_global p m b = Some m'):
+  m.(Mem.mem_access)!!b' = m'.(Mem.mem_access)!!b'.
+Proof.
+  unfold realloc_global in RA. des_ifs.
+  unfold Mem.nonempty_alloc in RA. des_ifs. ss.
+  des_ifs; eauto. erewrite PMap.gso; eauto.
+Qed.
+
+Lemma nonempty_realloc_global_not_func
+    p m b m' b'
+    (FUNC: Genv.find_funct_ptr (Genv.globalenv p) b = None)
+    (RA: realloc_global p m b' = Some m'):
+  m.(Mem.mem_access)!!b = m'.(Mem.mem_access)!!b.
+Proof.
+  destruct (peq b' b); cycle 1.
+  { eapply nonempty_realloc_global_neq; eauto. }
+  subst. unfold realloc_global in RA.
+  unfold fundef in *. rewrite FUNC in RA. clarify.
+Qed.
+
+Lemma nonempty_realloc_global_external
+    p m b m' b' ef
+    (FUNC: Genv.find_funct_ptr (Genv.globalenv p) b = Some (External ef))
+    (RA: realloc_global p m b' = Some m'):
+  m.(Mem.mem_access)!!b = m'.(Mem.mem_access)!!b.
+Proof.
+  destruct (peq b' b); cycle 1.
+  { eapply nonempty_realloc_global_neq; eauto. }
+  subst. unfold realloc_global in RA.
+  unfold fundef in *. rewrite FUNC in RA. clarify.
+Qed.
+
+Lemma nonempty_realloc_globals_not_func_aux
+    p m m' b bdd
+    (FUNC: Genv.find_funct_ptr (Genv.globalenv p) b = None)
+    (RA: _realloc_globals p m bdd m'):
+  m.(Mem.mem_access)!!b = m'.(Mem.mem_access)!!b.
+Proof.
+  ginduction RA; i.
+  { eapply nonempty_realloc_global_not_func; eauto. }
+  exploit nonempty_realloc_global_not_func; eauto. i.
+  rewrite H. eapply IHRA. eauto.
+Qed.
+
+Lemma nonempty_realloc_globals_external_aux
+    p m m' b bdd ef
+    (FUNC: Genv.find_funct_ptr (Genv.globalenv p) b = Some (External ef))
+    (RA: _realloc_globals p m bdd m'):
+  m.(Mem.mem_access)!!b = m'.(Mem.mem_access)!!b.
+Proof.
+  ginduction RA; i.
+  { eapply nonempty_realloc_global_external; eauto. }
+  exploit nonempty_realloc_global_external; eauto. i.
+  rewrite H. eapply IHRA. eauto.
+Qed.
+
+Lemma nonempty_realloc_globals_not_range
+    p m m' b bdd
+    (RANGE: (b > bdd)%positive)
+    (RA: _realloc_globals p m bdd m'):
+  m.(Mem.mem_access)!!b = m'.(Mem.mem_access)!!b.
+Proof.
+  ginduction RA; i.
+  { assert (b0 <> b) by lia.
+    subst. eapply nonempty_realloc_global_neq; eauto. }
+  assert (b <> b0) by lia.
+  exploit nonempty_realloc_global_neq; eauto. i.
+  rewrite H0. eapply IHRA. lia.
+Qed.
+
+Lemma nonempty_realloc_globals_not_func
+    p m m' b
+    (FUNC: Genv.find_funct_ptr (Genv.globalenv p) b = None)
+    (RA: realloc_globals p m m'):
+  m.(Mem.mem_access)!!b = m'.(Mem.mem_access)!!b.
+Proof. eapply nonempty_realloc_globals_not_func_aux; eauto. Qed.
+
+Lemma nonempty_realloc_globals_external
+    p m m' b ef
+    (FUNC: Genv.find_funct_ptr (Genv.globalenv p) b = Some (External ef))
+    (RA: realloc_globals p m m'):
+  m.(Mem.mem_access)!!b = m'.(Mem.mem_access)!!b.
+Proof. eapply nonempty_realloc_globals_external_aux; eauto. Qed.
+
+Lemma nonempty_realloc_globals_aux
+    p m m' b bdd f k
+    (LOGICAL: forall b, m.(Mem.mem_concrete) ! b = None)
+    (FUNC: Genv.find_funct_ptr (Genv.globalenv p) b = Some (Internal f))
+    (RANGE: (b <= bdd)%positive)
+    (RA: _realloc_globals p m bdd m'):
+  Mem.range_perm m' b 0 (function_length f) k Nonempty
+/\ (forall ofs k, (0 <= ofs < function_length f) -> forall p, Mem.perm m' b ofs k p -> p = Nonempty).
+Proof.
+  induction RA.
+  { subst. assert (b = 1%positive) by lia.
+    subst. eapply nonempty_realloc_global; eauto.
+    specialize (LOGICAL (1%positive)). unfold Mem.is_concrete.
+    rewrite LOGICAL. auto. }
+  destruct (peq b b0).
+  - subst b0. exploit nonempty_realloc_global; eauto.
+    { unfold Mem.is_concrete. specialize (LOGICAL b). rewrite LOGICAL. eauto. }
+    instantiate (1:=k).
+    exploit nonempty_realloc_globals_not_range; try eapply RA0.
+    { instantiate (1:=b). lia. }
+    i. des. unfold Mem.range_perm, Mem.perm in H0, H1.
+    erewrite H in H0, H1. eauto.
+  - exploit IHRA.
+    { unfold realloc_global in RA. des_ifs. eapply Mem.nonempty_alloc_concrete in RA.
+      rewrite <- RA; eauto. }
+    { lia. }
+    i. des. split; eauto.
+Qed.
+
+Lemma nonempty_realloc_globals
+    p m m' b f k
+    (LOGICAL: forall b, m.(Mem.mem_concrete) ! b = None)
+    (FUNC: Genv.find_funct_ptr (Genv.globalenv p) b = Some (Internal f))
+    (VLD: Mem.valid_block m b)
+    (RA: realloc_globals p m m'):
+  Mem.range_perm m' b 0 (function_length f) k Nonempty
+/\ (forall ofs k, (0 <= ofs < function_length f) -> forall p, Mem.perm m' b ofs k p -> p = Nonempty).
+  (* /\ (forall p, Mem.range_perm m' b 0 (function_length f) k p -> p = Nonempty). *)
+Proof.
+  unfold realloc_globals in RA.
+  eapply nonempty_realloc_globals_aux; eauto.
+  unfold Mem.valid_block in VLD. clear -VLD.
+  unfold Plt in VLD. lia.
+Qed.
+  
+Lemma fn_code_length
+  f (NOTNIL: fn_code f <> []):
+  Zlength (fn_code f) = function_length f.
+Proof.
+  unfold function_length. remember (fn_code f). clear Heqc.
+  destruct c;ss. des_ifs. rewrite Zlength_correct in e. ss.
+Qed.
+
+Lemma find_instr_range
+    ofs l i
+    (FIN : find_instr ofs l = Some i):
+  0 <= ofs < Zlength l /\ Zlength l > 0.
+Proof.
+  ginduction l; ss; i.
+  des_ifs; ss.
+  - erewrite Zlength_cons. erewrite Zlength_correct. split; lia.
+  - exploit IHl; eauto. i. des. split.
+    2:{ erewrite Zlength_cons. lia. }
+    split; try lia. erewrite Zlength_cons. lia.
+Qed.
+
+Lemma find_instr_range_function
+    ofs f i
+    (FIN : find_instr ofs (fn_code f) = Some i):
+  0 <= ofs < function_length f.
+Proof.
+  exploit find_instr_range; eauto. intros (RANGE & POS).
+  rewrite fn_code_length in RANGE; eauto. destruct (fn_code f); ss.
+Qed.
+
+Lemma initial_state_r_permission1
+    p rs m b ofs f i k
+    (INIT: initial_state_r p (State rs m))
+    (FUNC: Genv.find_funct_ptr (Genv.globalenv p) b = Some (Internal f))
+    (IN: find_instr ofs f.(fn_code) = Some i):
+  Mem.perm m b ofs k Nonempty
+/\ (forall k p, Mem.perm m b ofs k p -> p = Nonempty).
+Proof.
+  (* inv INIT. exploit Genv.find_funct_ptr_inversion; eauto. i. des. *)
+  inv INIT. (* inv INIT0. *)
+  assert (LOGICAL: forall b, m0.(Mem.mem_concrete) ! b = None).
+  { i. eapply Genv.init_mem_logical; eauto. inv INIT0; eauto. }
+  exploit nonempty_realloc_globals; eauto.
+  { eapply Genv.find_funct_ptr_not_fresh; eauto. inv INIT0; eauto. }
+  instantiate (1:=k). i. des.
+  exploit find_instr_range_function; eauto.
+Qed.
+
+Lemma initial_state_r_permission2
+    p rs m b ef k
+    (INIT: initial_state_r p (State rs m))
+    (FUNC: Genv.find_funct_ptr (Genv.globalenv p) b = Some (External ef)):
+  Mem.perm m b 0 k Nonempty
+/\ (forall ofs k p, Mem.perm m b ofs k p -> ofs = 0 /\ p = Nonempty).
+Proof.
+  inv INIT. inv INIT0. exploit Genv.init_mem_characterization_2; eauto.
+  i. des. exploit nonempty_realloc_globals_external; eauto. i.
+  unfold Mem.perm. erewrite <- H2. split; eauto. eapply Mem.perm_cur. eauto.
+Qed.
+
+Section FUNCPERM.
+
+Variable p: program.  
+Let ge := Genv.globalenv p.
+Let sem := Asm.semantics p.
+
+Definition mem_char (m: mem) :=
+  forall b f, Genv.find_funct_ptr ge b = Some (Internal f) ->
+  forall ofs i, find_instr ofs f.(fn_code) = Some i ->
+  Mem.perm m b ofs Max Nonempty
+  /\ (forall k p, Mem.perm m b ofs k p -> p = Nonempty).
+
+Definition mem_char_ext (m: mem) :=
+  forall b ef, Genv.find_funct_ptr ge b = Some (External ef) ->
+  Mem.perm m b 0 Max Nonempty
+  /\ (forall ofs k p, Mem.perm m b ofs k p -> ofs = 0 /\ p = Nonempty).
+
+Definition mem_char_all (m: mem) := mem_char m /\ mem_char_ext m.
+
+Definition state_char (s: state) : Prop :=
+  mem_char_all (state_mem s).
+
+Lemma initial_state_char
+    s
+    (INIT: initial_state_r p s):
+  state_char s.
+Proof.
+  ii. dup INIT. inv INIT0. ss. r. r. splits; ss.
+  - r. ii. eapply initial_state_r_permission1; eauto.
+  - r. ii. eapply initial_state_r_permission2; eauto.
+Qed.
+
+Lemma store_mem_char
+    chunk m b ofs v' m'
+    (CHAR: mem_char m)
+    (STORE: Mem.store chunk m b ofs v' = Some m'):
+  mem_char m'.
+Proof.
+  r. i. exploit CHAR; eauto. i. des. split.
+  { des_ifs; eapply Mem.perm_store_1; eauto. }
+  i. des_ifs; eapply H2; eapply Mem.perm_store_2; eauto.
+Qed.
+
+Lemma store_mem_char_ext
+    chunk m b ofs v' m'
+    (CHAR: mem_char_ext m)
+    (STORE: Mem.store chunk m b ofs v' = Some m'):
+  mem_char_ext m'.
+Proof.
+  r. i. exploit CHAR; eauto. i. des. split.
+  { des_ifs; eapply Mem.perm_store_1; eauto. }
+  i. des_ifs; eapply H1; eapply Mem.perm_store_2; eauto.
+Qed.
+
+Lemma storev_mem_char
+    chunk m v v' m'
+    (CHAR: mem_char m)
+    (STORE: Mem.storev chunk m v v' = Some m'):
+  mem_char m'.
+Proof.
+  unfold Mem.storev in STORE. des_ifs; eapply store_mem_char; eauto.
+Qed.
+
+Lemma storev_mem_char_ext
+    chunk m v v' m'
+    (CHAR: mem_char_ext m)
+    (STORE: Mem.storev chunk m v v' = Some m'):
+  mem_char_ext m'.
+Proof.
+  unfold Mem.storev in STORE. des_ifs; eapply store_mem_char_ext; eauto.
+Qed.
+
+Lemma alloc_mem_char
+    m lo hi m' b
+    (CHAR: mem_char m)
+    (ALLOC: Mem.alloc m lo hi = (m', b)):
+  mem_char m'.
+Proof.
+  unfold mem_char in *. i. exploit CHAR; eauto. i. des.
+  assert (b0 <> b).
+  { hexploit Mem.fresh_block_alloc; eauto. i.
+    eapply Mem.perm_valid_block in H1. ii; subst; clarify. }
+  split; [eapply Mem.perm_alloc_1; eauto|].
+  i. eapply H2. eapply Mem.perm_alloc_4; eauto.
+Qed.
+
+Lemma alloc_mem_char_ext
+    m lo hi m' b
+    (CHAR: mem_char_ext m)
+    (ALLOC: Mem.alloc m lo hi = (m', b)):
+  mem_char_ext m'.
+Proof.
+  unfold mem_char_ext in *. i. exploit CHAR; eauto. i. des.
+  assert (b0 <> b).
+  { hexploit Mem.fresh_block_alloc; eauto. i.
+    eapply Mem.perm_valid_block in H0. ii; subst; clarify. }
+  split; [eapply Mem.perm_alloc_1; eauto|].
+  i. eapply H1. eapply Mem.perm_alloc_4; eauto.
+Qed.
+
+Lemma free_mem_char
+    m b hi m'
+    (CHAR: mem_char m)
+    (FREE: Mem.free m b 0 hi = Some m'):
+  mem_char m'.
+Proof.
+  r. i. exploit CHAR; eauto. i. des. split.
+  2:{ i. eapply H2. eapply Mem.perm_free_3; eauto. }
+  hexploit Mem.free_range_perm; eauto. intros FPERM.
+  destruct (classic (hi > ofs)); cycle 1.
+  { eapply Mem.perm_free_1; eauto. }
+  destruct (peq b0 b); cycle 1.
+  { eapply Mem.perm_free_1; eauto. }
+  subst. specialize (FPERM ofs). exploit FPERM; try lia.
+  { eapply find_instr_range_function in H0. lia. }
+  i. eapply H2 in H4. des; clarify.
+Qed.
+
+Lemma free_mem_char_ext
+    m b hi m'
+    (CHAR: mem_char_ext m)
+    (FREE: Mem.free m b 0 hi = Some m'):
+  mem_char_ext m'.
+Proof.
+  r. i. exploit CHAR; eauto. i. des. split.
+  2:{ i. eapply H1. eapply Mem.perm_free_3; eauto. }
+  hexploit Mem.free_range_perm; eauto. intros FPERM.
+  destruct (classic (hi > 0)); cycle 1.
+  { eapply Mem.perm_free_1; eauto. }
+  destruct (peq b0 b); cycle 1.
+  { eapply Mem.perm_free_1; eauto. }
+  subst. specialize (FPERM 0). exploit FPERM; try lia. i.
+  eapply H1 in H3. des; clarify.
+Qed.
+
+Lemma store_mem_char_all
+    chunk m b ofs v' m'
+    (CHAR: mem_char_all m)
+    (STORE: Mem.store chunk m b ofs v' = Some m'):
+  mem_char_all m'.
+Proof.
+  inv CHAR. r.
+  eapply store_mem_char in H; eauto. eapply store_mem_char_ext in H0; eauto.
+Qed.
+
+Lemma storev_mem_char_all
+    chunk m v v' m'
+    (CHAR: mem_char_all m)
+    (STORE: Mem.storev chunk m v v' = Some m'):
+  mem_char_all m'.
+Proof.
+  unfold Mem.storev in STORE. des_ifs; eapply store_mem_char_all; eauto.
+Qed.
+
+Lemma alloc_mem_char_all
+    m lo hi m' b
+    (CHAR: mem_char_all m)
+    (ALLOC: Mem.alloc m lo hi = (m', b)):
+  mem_char_all m'.
+Proof.
+  inv CHAR. r.
+  eapply alloc_mem_char in H; eauto. eapply alloc_mem_char_ext in H0; eauto.
+Qed.
+
+Lemma free_mem_char_all
+    m b hi m'
+    (CHAR: mem_char_all m)
+    (FREE: Mem.free m b 0 hi = Some m'):
+  mem_char_all m'.
+Proof.
+  inv CHAR. r.
+  eapply free_mem_char in H; eauto. eapply free_mem_char_ext in H0; eauto.
+Qed.
+
+Lemma state_char_preservation_astep
+    s s' tr
+    (CHAR: state_char s)
+    (STEP: astep ge s tr s'):
+  state_char s'.
+Proof.
+  Local Transparent Mem.free.
+  inv STEP; ss; unfold state_char in *; ss.
+  - destruct i; ss; clarify; eauto; try by (unfold exec_load in *; des_ifs).
+    + unfold exec_store in *. des_ifs. eapply storev_mem_char_all; eauto.
+    + unfold exec_store in *. des_ifs. eapply storev_mem_char_all; eauto.
+    + unfold exec_store in *. des_ifs. eapply storev_mem_char_all; eauto.
+    + unfold exec_store in *. des_ifs. eapply storev_mem_char_all; eauto.
+    + unfold exec_store in *. des_ifs. eapply storev_mem_char_all; eauto.
+    + unfold exec_store in *. des_ifs. eapply storev_mem_char_all; eauto.
+    + unfold exec_store in *. des_ifs. eapply storev_mem_char_all; eauto.
+    + unfold exec_store in *. des_ifs. eapply storev_mem_char_all; eauto.
+    + unfold goto_label in H2. des_ifs.
+    + unfold goto_label in H2. des_ifs.
+    + unfold goto_label in H2. des_ifs.
+    + unfold goto_label in H2. des_ifs.
+    + unfold exec_store in *. des_ifs. eapply storev_mem_char_all; eauto.
+    + unfold exec_store in *. des_ifs. eapply storev_mem_char_all; eauto.
+    + des_ifs.
+      eapply store_mem_char_all; try eapply Heq1.
+      eapply store_mem_char_all; try eapply Heq0.
+      eapply alloc_mem_char_all; eauto.
+    + des_ifs. eapply free_mem_char_all; eauto.
+  - r. destruct CHAR as [CHAR1 CHAR2]. i. split.
+    + ii. exploit CHAR1; eauto. i. des. split; cycle 1.
+      { i. eapply H7. instantiate (1:=Max).
+        eapply external_call_max_perm; eauto.
+        { eapply Mem.perm_valid_block; eauto. }
+        eapply Mem.perm_max; eauto. }
+      assert (NM: nonempty_perm m b0 ofs0).
+      { r. split; eauto. }
+      exploit ec_nonempty; eauto.
+      { eapply external_call_common_spec. }
+      i. r in H8. des; eauto.
+    + ii. exploit CHAR2; eauto. i. des. split; cycle 1.
+      { i. eapply H6. instantiate (1:=Max).
+        eapply external_call_max_perm; eauto.
+        { eapply Mem.perm_valid_block; eauto. }
+        eapply Mem.perm_max; eauto. }
+      assert (NM: nonempty_perm m b0 0).
+      { r. split; eauto. i. exploit H6; eauto. i. des; eauto. }
+      exploit ec_nonempty; eauto.
+      { eapply external_call_common_spec. }
+      i. r in H7. des; eauto.
+  - r. destruct CHAR as [CHAR1 CHAR2]. split.
+    + ii. exploit CHAR1; eauto. i. des. split; cycle 1.
+      { i. eapply H6. instantiate (1:=Max).
+        eapply external_call_max_perm; eauto.
+        { eapply Mem.perm_valid_block; eauto. }
+        eapply Mem.perm_max; eauto. }
+      assert (NM: nonempty_perm m b0 ofs).
+      { r. split; eauto. }
+      exploit ec_nonempty; eauto.
+      { eapply external_call_common_spec. }
+      i. r in H7. des; eauto.
+    + ii. exploit CHAR2; eauto. i. des. split; cycle 1.
+      { i. eapply H5. instantiate (1:=Max).
+        eapply external_call_max_perm; eauto.
+        { eapply Mem.perm_valid_block; eauto. }
+        eapply Mem.perm_max; eauto. }
+      assert (NM: nonempty_perm m b0 0).
+      { r. split; eauto. i. exploit H5; eauto. i. des; eauto. }
+      exploit ec_nonempty; eauto.
+      { eapply external_call_common_spec. }
+      i. r in H6. des; eauto.
+Qed.
+
+Lemma state_char_preservation_cstep
+    s s'
+    (CHAR: state_char s)
+    (STEP: cstep s s'):
+  state_char s'.
+Proof.
+  inv STEP. r in CONC. r in CCONC. des.
+  assert (SAMEACC: Mem.mem_access m = Mem.mem_access m'').
+  { rewrite CONC0. eauto. }
+  unfold state_char in *. ss. inv CHAR. split.
+  - unfold mem_char in *. unfold Mem.perm. rewrite <- SAMEACC. eauto.
+  - unfold mem_char_ext in *. unfold Mem.perm. rewrite <- SAMEACC. eauto.
+Qed.
+
+Lemma state_char_preservation
+    s s' tr
+    (CHAR: state_char s)
+    (STEP: step ge s tr s'):
+  state_char s'.
+Proof.
+  inv STEP.
+  - eapply state_char_preservation_cstep; try eapply CSTEP.
+    eapply state_char_preservation_astep; eauto.
+  - eapply state_char_preservation_astep; eauto.
+Qed.
+
+Lemma state_char_star
+    s s' tr
+    (CHAR: state_char s)
+    (STEP: star step ge s tr s'):
+  state_char s'.
+Proof.
+  ginduction STEP; eauto. i. eapply IHSTEP. eapply state_char_preservation; eauto.
+Qed.
+
+Lemma state_char_plus
+    s s' tr
+    (CHAR: state_char s)
+    (STEP: plus step ge s tr s'):
+  state_char s'.
+Proof.
+  inv STEP. eapply state_char_star; try eapply H0; eauto. eapply state_char_preservation; eauto.
+Qed.
+
+End FUNCPERM.
+  
+(** Determinacy of the [Asm] semantics. *)
+
+Remark extcall_arguments_determ:
+  forall rs m sg args1 args2,
+  extcall_arguments rs m sg args1 -> extcall_arguments rs m sg args2 -> args1 = args2.
+Proof.
+  intros until m.
+  assert (A: forall l v1 v2,
+             extcall_arg rs m l v1 -> extcall_arg rs m l v2 -> v1 = v2).
+  { intros. inv H; inv H0; congruence. }
+  assert (B: forall p v1 v2,
+             extcall_arg_pair rs m p v1 -> extcall_arg_pair rs m p v2 -> v1 = v2).
+  { intros. inv H; inv H0.
+    eapply A; eauto.
+    f_equal; eapply A; eauto. }
+  assert (C: forall ll vl1, list_forall2 (extcall_arg_pair rs m) ll vl1 ->
+             forall vl2, list_forall2 (extcall_arg_pair rs m) ll vl2 -> vl1 = vl2).
+  {
+    induction 1; intros vl2 EA; inv EA.
+    auto.
+    f_equal; eauto. }
+  intros. eapply C; eauto.
+Qed.
+
+(** Classification functions for processor registers (used in Asmgenproof). *)
+
+Definition data_preg (r: preg) : bool :=
+  match r with
+  | PC => false
+  | IR _ => true
+  | FR _ => true
+  | ST0 => true
+  | CR _ => false
+  | RA => false
+  end.
+
+Require Import Asm.
+
+Section PRESERVATION.
+
+Definition rs_binded (m: mem) (rs rs': regset) : Prop :=
+  forall r, val_intptr m (rs#r) (rs'#r).
+
+Lemma rs_binded_refl m rs: rs_binded m rs rs.
+Proof. ii. eapply val_intptr_refl. Qed.
+
+Variable prog: Asm.program.
+(* Hypothesis TRANSF: match_prog prog tprog. *)
+Let ge := Genv.globalenv prog.
+(* Let tge := Genv.globalenv tprog. *)
+
+Let sem := Asm.semantics prog.
+Let tsem := Lowerbound.semantics prog.
+
+Variables st_init_tgt (* st_init_tgt0 *) st_init_tgt1: tsem.(Smallstep.state).
+Hypothesis INIT1: tsem.(Smallstep.initial_state) st_init_tgt.
+(* Hypothesis ICAP0: Lowerbound.glob_capture prog st_init_tgt st_init_tgt0. *)
+Hypothesis ICAP1: tsem.(Smallstep.initial_capture) st_init_tgt st_init_tgt1.
+Definition gmtgt : ident -> option Z := tsem.(initial_pimap) st_init_tgt1.
+
+Inductive match_states: Asm.state -> Lowerbound.state -> Prop :=
+| match_states_intro
+    rs rs' m m'
+    (MCEXT: concrete_extends m m')
+    (RCEXT: rs_binded m' rs rs'):
+  match_states (Asm.State rs m) (Lowerbound.State rs' m').
+
+Lemma pc_add_one_bind
+    m v1 v2
+    (VBIND: val_intptr m v1 v2):
+  val_intptr m (Val.offset_ptr v1 Ptrofs.one) (val_add_one v2).
+Proof.
+  inv VBIND; ss; try by econs. des_ifs. econs; eauto.
+  ss. unfold Mem.ptr2int in *. des_ifs_safe.
+  do 2 f_equal. unfold Int64.add. eapply Int64.same_if_eq. unfold Int64.eq.
+  des_ifs. exfalso. eapply n. unfold Ptrofs.add.
+  repeat rewrite Int64.unsigned_repr_eq. repeat rewrite Ptrofs.unsigned_repr_eq.
+  rewrite Int64.unsigned_one. rewrite Ptrofs.unsigned_one. rewrite Ptrofs.modulus_eq64; eauto.
+  rewrite Zplus_mod_idemp_r. rewrite Zplus_mod_idemp_l. f_equal. lia.
+Qed.
+
+Lemma pc_add_delta_bind
+    m v1 v2 delta
+    (VBIND: val_intptr m v1 v2):
+  val_intptr m (Val.offset_ptr v1 delta) (val_add_ptrofs v2 delta).
+Proof.
+  inv VBIND; ss; try by econs. des_ifs. econs; eauto.
+  ss. unfold Mem.ptr2int in *. des_ifs_safe.
+  do 2 f_equal. unfold Int64.add. eapply Int64.same_if_eq. unfold Int64.eq.
+  des_ifs. exfalso. eapply n. unfold Ptrofs.add. unfold Ptrofs.to_int64.
+  repeat rewrite Int64.unsigned_repr_eq. repeat rewrite Ptrofs.unsigned_repr_eq.
+  rewrite Ptrofs.modulus_eq64; eauto.
+  repeat rewrite Zplus_mod_idemp_r. rewrite Zplus_mod_idemp_l. f_equal. lia.
+Qed.
+
+Lemma set_bind
+    m rs1 rs2 rd v1 v2
+    (VBIND: val_intptr m v1 v2)
+    (RCEXT : rs_binded m rs1 rs2):
+  rs_binded m (rs1 # rd <- v1) (rs2 # rd <- v2).
+Proof.
+  ii. destruct (classic (r = rd)); subst.
+  { do 2 (erewrite Pregmap.gss; eauto). }
+  do 2 (erewrite Pregmap.gso; eauto).
+Qed.
+  
+Lemma nextinstr_sim
+    m rs1 rs2 (RCEXT : rs_binded m rs1 rs2):
+  rs_binded m (Asm.nextinstr rs1) (Lowerbound.nextinstr rs2).
+Proof.
+  r. i. unfold Asm.nextinstr, Lowerbound.nextinstr. eapply set_bind; eauto.
+  eapply pc_add_one_bind; eauto.
+Qed.
+
+Lemma nextinstr_nf_sim
+    m rs1 rs2 (RCEXT : rs_binded m rs1 rs2):
+  rs_binded m (Asm.nextinstr_nf rs1) (Lowerbound.nextinstr_nf rs2).
+Proof.
+  r. i. unfold Asm.nextinstr_nf, Lowerbound.nextinstr_nf. eapply set_bind; eauto.
+  { eapply pc_add_one_bind; eauto. ss. repeat (eapply set_bind; eauto); econs. }
+  repeat (eapply set_bind; eauto); econs.
+Qed.
+
+Lemma addrmode64_bind
+    m rs1 rs2 a (RCEXT : rs_binded m rs1 rs2):
+  val_intptr m (eval_addrmode64 ge a rs1) (eval_addrmode64 ge a rs2).
+Proof.
+  destruct a; ss. eapply addl_bind.
+  { des_ifs. eapply val_intptr_refl. }
+  eapply addl_bind.
+  { des_ifs; cycle 1.
+    - eapply val_intptr_refl.
+    - eapply mull_bind; eauto. econs. }
+  des_ifs; eapply val_intptr_refl.
+Qed.
+
+Lemma addrmode32_bind
+    m rs1 rs2 a (RCEXT : rs_binded m rs1 rs2):
+  val_intptr m (eval_addrmode32 ge a rs1) (eval_addrmode32 ge a rs2).
+Proof.
+  destruct a; ss. eapply add_bind.
+  { des_ifs. eapply val_intptr_refl. }
+  eapply add_bind.
+  { des_ifs; cycle 1.
+    - eapply val_intptr_refl.
+    - eapply mul_bind; eauto. econs. }
+  des_ifs; eapply val_intptr_refl.
+Qed.
+
+Lemma addrmode_bind
+    m rs1 rs2 a (RCEXT : rs_binded m rs1 rs2):
+  val_intptr m (eval_addrmode ge a rs1) (eval_addrmode ge a rs2).
+Proof.
+  unfold eval_addrmode. destruct Archi.ptr64.
+  - eapply addrmode64_bind; eauto.
+  - eapply addrmode32_bind; eauto.
+Qed.
+
+Lemma exec_load_fsim
+    chunk a rd rs1 rs2 m1 m2 rs1' m1'
+    (EXEC : exec_load ge chunk m1 a rs1 rd = Next rs1' m1')
+    (MCEXT : concrete_extends m1 m2)
+    (RCEXT : rs_binded m2 rs1 rs2):
+  exists rs2' m2',
+    Lowerbound.exec_load ge chunk m2 a rs2 rd = Next rs2' m2'
+  /\ concrete_extends m1' m2'
+  /\ rs_binded m2' rs1' rs2'.
+Proof.
+  unfold exec_load in EXEC. des_ifs.
+  exploit loadv_concrete_extends; eauto.
+  { eapply addrmode_bind; eauto. }
+  i. des. esplits; eauto.
+  { unfold Lowerbound.exec_load. rewrite H. esplits; eauto. }
+  eapply nextinstr_nf_sim. eapply set_bind; eauto.
+Qed.
+
+Lemma undef_regs_binded
+    m rs1 rs2 dr
+    (RCEXT: rs_binded m rs1 rs2):
+  rs_binded m (undef_regs dr rs1) (undef_regs dr rs2).
+Proof.
+  revert RCEXT. revert rs1 rs2.
+  induction dr; ss; i. eapply IHdr. eapply set_bind; eauto. econs.
+Qed.
+
+Lemma same_concrete_rs_bind
+    m m' rs1 rs2
+    (SAME: m.(Mem.mem_concrete) = m'.(Mem.mem_concrete)):
+  rs_binded m rs1 rs2 <-> rs_binded m' rs1 rs2.
+Proof.
+  split; ii.
+  - eapply same_conc_val_intptr; eauto.
+  - symmetry in SAME. eapply same_conc_val_intptr; eauto.
+Qed.
+
+Lemma exec_store_fsim
+    chunk a rs1 rs2 m1 m2 r dr rs1' m1'
+    (EXEC : exec_store ge chunk m1 a rs1 r dr = Next rs1' m1')
+    (MCEXT : concrete_extends m1 m2)
+    (RCEXT : rs_binded m2 rs1 rs2):
+  exists rs2' m2',
+    Lowerbound.exec_store ge chunk m2 a rs2 r dr = Next rs2' m2'
+  /\ concrete_extends m1' m2'
+  /\ rs_binded m2' rs1' rs2'.
+Proof.
+  unfold exec_store in EXEC. des_ifs.
+  exploit storev_concrete_extends; eauto.
+  { eapply addrmode_bind; eauto. }
+  i. des. esplits; eauto.
+  { unfold Lowerbound.exec_store. rewrite H. esplits; eauto. }
+  eapply nextinstr_nf_sim. 
+  eapply undef_regs_binded. erewrite <- same_concrete_rs_bind; eauto.
+  eapply Mem.storev_concrete; eauto.
+Qed.
+
+Lemma zero_ext_bind
+    m rs1 rs2 n rs
+    (RCEXT : rs_binded m rs1 rs2):
+  val_intptr m (Val.zero_ext n (rs1 rs)) (Val.zero_ext n (rs2 rs)).
+Proof.
+  unfold Val.zero_ext. specialize (RCEXT rs). des_ifs; inv RCEXT; try econs.
+Qed.
+
+Lemma sign_ext_bind
+    m rs1 rs2 n rs
+    (RCEXT : rs_binded m rs1 rs2):
+  val_intptr m (Val.sign_ext n (rs1 rs)) (Val.sign_ext n (rs2 rs)).
+Proof.
+  unfold Val.sign_ext. specialize (RCEXT rs). des_ifs; inv RCEXT; try econs.
+Qed.
+
+Lemma longofintu_bind
+    m rs1 rs2 rs
+    (RCEXT : rs_binded m rs1 rs2):
+  val_intptr m (Val.longofintu (rs1 rs)) (Val.longofintu (rs2 rs)).
+Proof.
+  unfold Val.longofintu. specialize (RCEXT rs). des_ifs; inv RCEXT; try econs.
+Qed.
+
+Lemma longofint_bind
+    m rs1 rs2 rs
+    (RCEXT : rs_binded m rs1 rs2):
+  val_intptr m (Val.longofint (rs1 rs)) (Val.longofint (rs2 rs)).
+Proof.
+  unfold Val.longofint. specialize (RCEXT rs). des_ifs; inv RCEXT; try econs.
+Qed.
+
+Lemma loword_bind
+    m rs1 rs2 rs
+    (RCEXT : rs_binded m rs1 rs2):
+  val_intptr m (Val.loword (rs1 rs)) (Val.loword (rs2 rs)).
+Proof.
+  unfold Val.loword. specialize (RCEXT rs). des_ifs; inv RCEXT; try econs.
+Qed.
+
+Lemma singleoffloat_bind
+    m rs1 rs2 rs
+    (RCEXT : rs_binded m rs1 rs2):
+  val_intptr m (Val.singleoffloat (rs1 rs)) (Val.singleoffloat (rs2 rs)).
+Proof.
+  unfold Val.singleoffloat. specialize (RCEXT rs). des_ifs; inv RCEXT; try econs.
+Qed.
+
+Lemma floatofsingle_bind
+    m rs1 rs2 rs
+    (RCEXT : rs_binded m rs1 rs2):
+  val_intptr m (Val.floatofsingle (rs1 rs)) (Val.floatofsingle (rs2 rs)).
+Proof.
+  unfold Val.floatofsingle. specialize (RCEXT rs). des_ifs; inv RCEXT; try econs.
+Qed.
+
+Lemma intoffloat_bind
+    m rs1 rs2 rs
+    (RCEXT : rs_binded m rs1 rs2):
+  val_intptr m (Val.maketotal (Val.intoffloat (rs1 rs))) (Val.maketotal (Val.intoffloat (rs2 rs))).
+Proof.
+  unfold Val.intoffloat. specialize (RCEXT rs). des_ifs; inv RCEXT; try econs.
+  unfold option_map. des_ifs; ss; econs.
+Qed.
+
+Lemma floatofint_bind
+    m rs1 rs2 rs
+    (RCEXT : rs_binded m rs1 rs2):
+  val_intptr m (Val.maketotal (Val.floatofint (rs1 rs))) (Val.maketotal (Val.floatofint (rs2 rs))).
+Proof.
+  unfold Val.floatofint. specialize (RCEXT rs). des_ifs; inv RCEXT; try econs.
+Qed.
+
+Lemma intofsingle_bind
+    m rs1 rs2 rs
+    (RCEXT : rs_binded m rs1 rs2):
+  val_intptr m (Val.maketotal (Val.intofsingle (rs1 rs))) (Val.maketotal (Val.intofsingle (rs2 rs))).
+Proof.
+  unfold Val.intofsingle. specialize (RCEXT rs). des_ifs; inv RCEXT; try econs.
+  unfold option_map. des_ifs; ss; econs.
+Qed.
+
+Lemma singleofint_bind
+    m rs1 rs2 rs
+    (RCEXT : rs_binded m rs1 rs2):
+  val_intptr m (Val.maketotal (Val.singleofint (rs1 rs))) (Val.maketotal (Val.singleofint (rs2 rs))).
+Proof.
+  unfold Val.singleofint. specialize (RCEXT rs). des_ifs; inv RCEXT; try econs.
+Qed.
+
+Lemma longoffloat_bind
+    m rs1 rs2 rs
+    (RCEXT : rs_binded m rs1 rs2):
+  val_intptr m (Val.maketotal (Val.longoffloat (rs1 rs))) (Val.maketotal (Val.longoffloat (rs2 rs))).
+Proof.
+  unfold Val.longoffloat. specialize (RCEXT rs). des_ifs; inv RCEXT; try econs.
+  unfold option_map. des_ifs; ss; econs.
+Qed.
+
+Lemma floatoflong_bind
+    m rs1 rs2 rs
+    (RCEXT : rs_binded m rs1 rs2):
+  val_intptr m (Val.maketotal (Val.floatoflong (rs1 rs))) (Val.maketotal (Val.floatoflong (rs2 rs))).
+Proof.
+  unfold Val.floatoflong. specialize (RCEXT rs). des_ifs; inv RCEXT; try econs.
+Qed.
+
+Lemma longofsingle_bind
+    m rs1 rs2 rs
+    (RCEXT : rs_binded m rs1 rs2):
+  val_intptr m (Val.maketotal (Val.longofsingle (rs1 rs))) (Val.maketotal (Val.longofsingle (rs2 rs))).
+Proof.
+  unfold Val.longofsingle. specialize (RCEXT rs). des_ifs; inv RCEXT; try econs.
+  unfold option_map. des_ifs; ss; econs.
+Qed.
+
+Lemma singleoflong_bind
+    m rs1 rs2 rs
+    (RCEXT : rs_binded m rs1 rs2):
+  val_intptr m (Val.maketotal (Val.singleoflong (rs1 rs))) (Val.maketotal (Val.singleoflong (rs2 rs))).
+Proof.
+  unfold Val.singleoflong. specialize (RCEXT rs). des_ifs; inv RCEXT; try econs.
+Qed.
+
+Lemma and_bind
+    m v1 v2 v1' v2'
+    (RCEXT: val_intptr m v1 v1')
+    (RCEXT0: val_intptr m v2 v2'):
+  val_intptr m (Val.and v1 v2) (Val.and v1' v2').
+Proof.
+  destruct v1, v2; ss; inv RCEXT; inv RCEXT0; ss; try econs.
+Qed.
+
+Lemma andl_bind
+    m v1 v2 v1' v2'
+    (RCEXT: val_intptr m v1 v1')
+    (RCEXT0: val_intptr m v2 v2'):
+  val_intptr m (Val.andl v1 v2) (Val.andl v1' v2').
+Proof.
+  destruct v1, v2; ss; inv RCEXT; inv RCEXT0; ss; try econs.
+Qed.
+
+Lemma hiword_bind
+    m v v'
+    (BIND: val_intptr m v v'):
+  val_intptr m (Val.hiword v) (Val.hiword v').
+Proof. inv BIND; ss; try econs. Qed.
+
+Lemma loword_bind'
+    m v v'
+    (BIND: val_intptr m v v'):
+  val_intptr m (Val.loword v) (Val.loword v').
+Proof. inv BIND; ss; try econs. Qed.
+
+Lemma longofwords_bind
+    m v1 v2 v1' v2'
+    (BIND1: val_intptr m v1 v1')
+    (BIND2: val_intptr m v2 v2'):
+  val_intptr m (Val.longofwords v1 v2) (Val.longofwords v1' v2').
+Proof. inv BIND1; inv BIND2; econs. Qed.
+
+Lemma set_res_bind
+    m bres v v' rs rs'
+    (BIND: val_intptr m v v')
+    (RCEXT: rs_binded m rs rs'):
+  rs_binded m (set_res bres v rs) (set_res bres v' rs').
+Proof.
+  revert RCEXT BIND. revert rs rs' v v' m. induction bres; ss; i.
+  - eapply set_bind; eauto.
+  - eapply IHbres2.
+    + eapply IHbres1; eauto. eapply hiword_bind. eauto.
+    + eapply loword_bind'. eauto.
+Qed.
+
+Lemma set_pair_bind
+    m bres v v' rs rs'
+    (BIND: val_intptr m v v')
+    (RCEXT: rs_binded m rs rs'):
+  rs_binded m (set_pair bres v rs) (set_pair bres v' rs').
+Proof.
+  destruct bres; ss.
+  { eapply set_bind; eauto. }
+  eapply set_bind; eauto.
+  - eapply loword_bind'; eauto.
+  - eapply set_bind; eauto. eapply hiword_bind. eauto.
+Qed.
+
+Lemma eval_testcond_bind
+    c m rs1 rs2 b
+    (RCEXT: rs_binded m rs1 rs2)
+    (TEST: eval_testcond c rs1 = Some b):
+  eval_testcond c rs2 = Some b.
+Proof.
+  unfold eval_testcond in TEST. des_ifs; ss.
+  - specialize (RCEXT ZF). rewrite Heq in RCEXT. inv RCEXT. ss.
+  - specialize (RCEXT ZF). rewrite Heq in RCEXT. inv RCEXT. ss.
+  - specialize (RCEXT CF). rewrite Heq in RCEXT. inv RCEXT. ss.
+  - dup RCEXT. specialize (RCEXT CF). specialize (RCEXT0 ZF).
+    rewrite Heq in RCEXT. rewrite Heq0 in RCEXT0. inv RCEXT; inv RCEXT0; ss.
+  - specialize (RCEXT CF). rewrite Heq in RCEXT. inv RCEXT. ss.
+  - dup RCEXT. specialize (RCEXT CF). specialize (RCEXT0 ZF).
+    rewrite Heq in RCEXT. rewrite Heq0 in RCEXT0. inv RCEXT; inv RCEXT0; ss.
+  - dup RCEXT. specialize (RCEXT OF). specialize (RCEXT0 SF).
+    rewrite Heq in RCEXT. rewrite Heq0 in RCEXT0. inv RCEXT; inv RCEXT0; ss.
+  - dup RCEXT. dup RCEXT0. specialize (RCEXT OF). specialize (RCEXT0 SF). specialize (RCEXT1 ZF).
+    rewrite Heq in RCEXT. rewrite Heq0 in RCEXT0. rewrite Heq1 in RCEXT1.
+    inv RCEXT; inv RCEXT0; inv RCEXT1; ss.
+  - dup RCEXT. specialize (RCEXT OF). specialize (RCEXT0 SF).
+    rewrite Heq in RCEXT. rewrite Heq0 in RCEXT0. inv RCEXT; inv RCEXT0; ss.
+  - dup RCEXT. dup RCEXT0. specialize (RCEXT OF). specialize (RCEXT0 SF). specialize (RCEXT1 ZF).
+    rewrite Heq in RCEXT. rewrite Heq0 in RCEXT0. rewrite Heq1 in RCEXT1.
+    inv RCEXT; inv RCEXT0; inv RCEXT1; ss.
+  - specialize (RCEXT PF). rewrite Heq in RCEXT. inv RCEXT. ss.
+  - specialize (RCEXT PF). rewrite Heq in RCEXT. inv RCEXT. ss.
+Qed.
+
+Lemma psubl_join_asm_psub_join
+    m v1 v2
+    (SF: Archi.ptr64 = true)
+    (NOTALLPTR: forall b1 ofs1 b2 ofs2, ~ (v1 = Vptr b1 ofs1 /\ v2 = Vptr b2 ofs2)):
+  psub_join_asm m v1 v2 = psubl_join m v1 v2.
+Proof.
+  destruct v1, v2; ss;
+    (try by (unfold psub_join_asm, psubl_join; ss; unfold to_ptr_val; ss; des_ifs));
+    (try by (unfold psub_join_asm, psubl_join; ss; unfold to_int_val; ss; des_ifs)).
+  - unfold psub_join_asm, psubl_join. erewrite val_join_angelic_vi; try by ss.
+    eapply psubl_wrapper_no_angelic; eauto.
+  - exfalso. eapply NOTALLPTR; eauto.
+Qed.
+    
+
+Lemma psub_join_asm_bind
+    m1 m2 v1 v1' v2 v2'
+    (RCEXT: val_intptr m2 v1 v1')
+    (RCEXT0: val_intptr m2 v2 v2')
+    (MCEXT: concrete_extends m1 m2):
+  val_intptr m2 (psub_join_asm m1 v1 v2) (psub_join_asm m2 v1' v2').
+Proof.
+  (* unfold psub_join_asm. des_ifs_safe. *)
+  exploit psubl_join_binded. eauto. eapply RCEXT. eapply RCEXT0. eauto. i. des. subst.
+  rename BIND into PSUBL.
+  destruct v1, v2; try by (ss; des_ifs; econs).
+  - inv RCEXT; inv RCEXT0; try by (ss; des_ifs; econs).
+  - inv RCEXT; inv RCEXT0; try by (ss; des_ifs; econs).
+    + do 2 try (erewrite psubl_join_asm_psub_join; eauto).
+      { ii. des; clarify. }
+      { ii. des; clarify. }
+  - inv RCEXT; inv RCEXT0; try by (ss; des_ifs; econs).
+    do 2 try (erewrite psubl_join_asm_psub_join; eauto).
+    { ii. des; clarify. }
+    { ii. des; clarify. }
+  - unfold psub_join_asm, psubl_join_common at 1. des_ifs.
+    destruct (classic ((Val.psubl (Vptr b i) (Vptr b0 i0)) = Vundef)).
+    { rewrite H. econs. }
+    dup RCEXT. dup RCEXT0.
+    exploit psubl_join_binded. eauto. eapply RCEXT. eapply RCEXT0.
+    { instantiate (1:= Val.psubl (Vptr b i) (Vptr b0 i0)). unfold psubl_join. rewrite val_join_angelic_vp.
+      - simpl. eauto.
+      - ss. des_ifs.
+      - eapply psubl_wrapper_no_angelic; eauto.
+      - ii. ss. }
+    i. des. inv RCEXT; inv RCEXT0; ss.
+    { des_ifs_safe. unfold psub_join_asm. ss. des_ifs_safe. eapply val_intptr_refl. }
+    { unfold psub_join_asm. ss. des_ifs_safe. unfold psubl_join in BIND.
+      rewrite val_join_angelic_vi in BIND; eauto; [|ss].
+      eapply psubl_wrapper_no_angelic; eauto. }
+Qed.
+
+Lemma cmplu_join_asm_bind
+    c m1 m2 v1 v1' v2 v2' v
+    (RCEXT: val_intptr m2 v1 v1')
+    (RCEXT0: val_intptr m2 v2 v2')
+    (MCEXT: concrete_extends m1 m2)
+    (CMP: cmplu_join_asm m1 c v1 v2 = Some v):
+  exists v', cmplu_join_asm m2 c v1' v2' = Some v'
+      /\ val_intptr m2 v v'.
+Proof.
+  unfold cmplu_join_asm in *. erewrite cmplu_join_same_eval_condition_join in *.
+  destruct (eval_condition_join (Op.Ccomplu c) [v1; v2] m1) eqn: CMP1; try by ss.
+  exploit eval_condition_join_binded; eauto; [ss| |].
+  { econs; eauto. econs; eauto. econs. }
+  i. erewrite H. esplits; eauto. eapply val_intptr_refl.
+Qed.
+
+Lemma compare_longs_binded
+    m1 m2 v1 v1' v2 v2' rs1 rs2
+    (BIND1: val_intptr m2 v1 v1')
+    (BIND2: val_intptr m2 v2 v2')
+    (MCEXT: concrete_extends m1 m2)
+    (RCEXT: rs_binded m2 rs1 rs2):
+  rs_binded m2 (compare_longs v1 v2 rs1 m1) (compare_longs v1' v2' rs2 m2).
+Proof.
+  ii. unfold compare_longs. eapply set_bind.
+  { econs. }
+  eapply set_bind.
+  { destruct v1, v2; ss; try econs. inv BIND1; inv BIND2; ss. eapply val_intptr_refl. }
+  eapply set_bind.
+  { exploit subl_bind. eapply BIND1. eapply BIND2. i. inv H; ss; try by econs. }
+  eapply set_bind.
+  { destruct (cmplu_join_asm m1 Clt v1 v2) eqn:CMP; try by econs.
+    eapply cmplu_join_asm_bind in CMP; eauto. des. erewrite CMP. ss. }
+  eapply set_bind; eauto.
+  { destruct (cmplu_join_asm m1 Ceq v1 v2) eqn:CMP; try by econs.
+    eapply cmplu_join_asm_bind in CMP; eauto. des. erewrite CMP. ss. }
+Qed.
+
+Lemma compare_ints_binded
+    m1 m2 v1 v1' v2 v2' rs1 rs2
+    (BIND1: val_intptr m2 v1 v1')
+    (BIND2: val_intptr m2 v2 v2')
+    (MCEXT: concrete_extends m1 m2)
+    (RCEXT: rs_binded m2 rs1 rs2):
+  rs_binded m2 (compare_ints v1 v2 rs1 m1) (compare_ints v1' v2' rs2 m2).
+Proof.
+  ii. unfold compare_ints. eapply set_bind.
+  { econs. }
+  eapply set_bind.
+  { destruct v1, v2; ss; try econs. inv BIND1; inv BIND2; ss. eapply val_intptr_refl. }
+  eapply set_bind.
+  { exploit sub_bind. eapply BIND1. eapply BIND2. i. inv H; ss; try by econs. }
+  eapply set_bind.
+  { inv BIND1; inv BIND2; ss; (try by eapply val_intptr_refl); unfold Val.cmpu; ss; try by econs. }
+  eapply set_bind; eauto.
+  { inv BIND1; inv BIND2; ss; (try by eapply val_intptr_refl); unfold Val.cmpu; ss; try by econs. }
+Qed.
+
+Lemma addf_bind
+    m v1 v2 v1' v2'
+    (BIND1: val_intptr m v1 v1')
+    (BIND2: val_intptr m v2 v2'):
+  val_intptr m (Val.addf v1 v2) (Val.addf v1' v2').
+Proof. inv BIND1; inv BIND2; econs. Qed.
+
+Lemma subf_bind
+    m v1 v2 v1' v2'
+    (BIND1: val_intptr m v1 v1')
+    (BIND2: val_intptr m v2 v2'):
+  val_intptr m (Val.subf v1 v2) (Val.subf v1' v2').
+Proof. inv BIND1; inv BIND2; econs. Qed.
+
+Lemma mulf_bind
+    m v1 v2 v1' v2'
+    (BIND1: val_intptr m v1 v1')
+    (BIND2: val_intptr m v2 v2'):
+  val_intptr m (Val.mulf v1 v2) (Val.mulf v1' v2').
+Proof. inv BIND1; inv BIND2; econs. Qed.
+
+Lemma divf_bind
+    m v1 v2 v1' v2'
+    (BIND1: val_intptr m v1 v1')
+    (BIND2: val_intptr m v2 v2'):
+  val_intptr m (Val.divf v1 v2) (Val.divf v1' v2').
+Proof. inv BIND1; inv BIND2; econs. Qed.
+
+Lemma negf_bind
+    m v v'
+    (BIND1: val_intptr m v v'):
+  val_intptr m (Val.negf v) (Val.negf v').
+Proof. inv BIND1; econs. Qed.
+
+Lemma absf_bind
+    m v v'
+    (BIND1: val_intptr m v v'):
+  val_intptr m (Val.absf v) (Val.absf v').
+Proof. inv BIND1; econs. Qed.
+
+Lemma compare_floats_binded
+    m1 m2 v1 v1' v2 v2' rs1 rs2
+    (BIND1: val_intptr m2 v1 v1')
+    (BIND2: val_intptr m2 v2 v2')
+    (MCEXT: concrete_extends m1 m2)
+    (RCEXT: rs_binded m2 rs1 rs2):
+  rs_binded m2 (compare_floats v1 v2 rs1) (compare_floats v1' v2' rs2).
+Proof.
+  ii. unfold compare_floats. inv BIND1; inv BIND2; (try by (eapply undef_regs_binded; eauto));
+    (des_ifs; try by  (eapply undef_regs_binded; eauto)).
+  - eapply set_bind; try econs. eapply set_bind; try econs. eapply set_bind.
+    { eapply val_intptr_refl. }
+    eapply set_bind.
+    { eapply val_intptr_refl. }
+    eapply set_bind; eauto.
+    { eapply val_intptr_refl. }
+  - eapply set_bind; try econs. eapply set_bind; try econs. eapply set_bind.
+    { econs. }
+    eapply set_bind.
+    { econs. }
+    eapply set_bind; eauto. econs.
+  - repeat (eapply set_bind; [econs|]). eauto.
+  - repeat (eapply set_bind; [econs|]). eauto.
+Qed.
+  
+Lemma addfs_bind
+    m v1 v2 v1' v2'
+    (BIND1: val_intptr m v1 v1')
+    (BIND2: val_intptr m v2 v2'):
+  val_intptr m (Val.addfs v1 v2) (Val.addfs v1' v2').
+Proof. inv BIND1; inv BIND2; econs. Qed.
+
+Lemma subfs_bind
+    m v1 v2 v1' v2'
+    (BIND1: val_intptr m v1 v1')
+    (BIND2: val_intptr m v2 v2'):
+  val_intptr m (Val.subfs v1 v2) (Val.subfs v1' v2').
+Proof. inv BIND1; inv BIND2; econs. Qed.
+
+Lemma mulfs_bind
+    m v1 v2 v1' v2'
+    (BIND1: val_intptr m v1 v1')
+    (BIND2: val_intptr m v2 v2'):
+  val_intptr m (Val.mulfs v1 v2) (Val.mulfs v1' v2').
+Proof. inv BIND1; inv BIND2; econs. Qed.
+
+Lemma divfs_bind
+    m v1 v2 v1' v2'
+    (BIND1: val_intptr m v1 v1')
+    (BIND2: val_intptr m v2 v2'):
+  val_intptr m (Val.divfs v1 v2) (Val.divfs v1' v2').
+Proof. inv BIND1; inv BIND2; econs. Qed.
+
+Lemma negfs_bind
+    m v v'
+    (BIND1: val_intptr m v v'):
+  val_intptr m (Val.negfs v) (Val.negfs v').
+Proof. inv BIND1; econs. Qed.
+
+Lemma absfs_bind
+    m v v'
+    (BIND1: val_intptr m v v'):
+  val_intptr m (Val.absfs v) (Val.absfs v').
+Proof. inv BIND1; econs. Qed.
+
+Lemma compare_floats32_binded
+    m1 m2 v1 v1' v2 v2' rs1 rs2
+    (BIND1: val_intptr m2 v1 v1')
+    (BIND2: val_intptr m2 v2 v2')
+    (MCEXT: concrete_extends m1 m2)
+    (RCEXT: rs_binded m2 rs1 rs2):
+  rs_binded m2 (compare_floats32 v1 v2 rs1) (compare_floats32 v1' v2' rs2).
+Proof.
+  ii. unfold compare_floats. inv BIND1; inv BIND2; (try by (eapply undef_regs_binded; eauto));
+    (des_ifs; try by  (eapply undef_regs_binded; eauto)); ss.
+  - eapply set_bind; try econs. eapply set_bind; try econs. eapply set_bind.
+    { eapply val_intptr_refl. }
+    eapply set_bind.
+    { eapply val_intptr_refl. }
+    eapply set_bind; eauto.
+    { eapply val_intptr_refl. }
+  - des_ifs; try repeat (eapply set_bind; [econs|]); eauto.
+  - destruct v1'; ss; repeat (eapply set_bind; [econs|]); eauto.
+  - destruct v1'; ss; repeat (eapply set_bind; [econs|]); eauto.
+  - destruct v1'; ss; repeat (eapply set_bind; [econs|]); eauto.
+  - destruct v1'; ss; repeat (eapply set_bind; [econs|]); eauto.
+  - destruct v1'; ss; repeat (eapply set_bind; [econs|]); eauto.
+  - destruct v1'; ss; repeat (eapply set_bind; [econs|]); eauto.
+  - destruct v1', v2'; ss; repeat (eapply set_bind; [econs|]); eauto.
+Qed.
+
+Lemma internal_pc_fsim
+    b ofs f i m rs rs'
+    (MCHAR: mem_char_all prog m)
+    (SPC: rs PC = Vptr b ofs)
+    (INT: Genv.find_funct_ptr ge b = Some (Internal f))
+    (FIND: find_instr (Ptrofs.unsigned ofs) (fn_code f) = Some i)
+    (RCEXT : rs_binded m rs rs'):
+  Mem.to_ptr (rs' PC) m = Some (Vptr b ofs).
+Proof.
+  inv MCHAR. r in H. exploit H; eauto. i. des.
+  dup RCEXT. specialize (RCEXT0 PC). rewrite SPC in RCEXT0. inv RCEXT0; ss.
+  des_ifs_safe. exploit Mem.ptr2int_to_denormalize_max; eauto.
+  { eapply Ptrofs.unsigned_range_2. }
+  i. des. exploit Mem.denormalize_info; eauto. i. des.
+  erewrite Int64.unsigned_repr.
+  2:{ unfold Int64.max_unsigned, Ptrofs.max_unsigned in *. erewrite <- Ptrofs.modulus_eq64; eauto. lia. }
+  des_ifs.
+  2:{ rewrite Ptrofs.repr_unsigned. eauto. }
+  unfold Int64.eq in Heq0. des_ifs. erewrite Int64.unsigned_zero in e.
+  erewrite Int64.unsigned_repr in e; try lia.
+  { unfold Int64.max_unsigned, Ptrofs.max_unsigned in *. erewrite <- Ptrofs.modulus_eq64; eauto. lia. }
+Qed.
+
+Lemma external_pc_fsim
+    b ef m rs rs'
+    (MCHAR: mem_char_all prog m)
+    (SPC: rs PC = Vptr b Ptrofs.zero)
+    (INT: Genv.find_funct_ptr ge b = Some (External ef))
+    (RCEXT : rs_binded m rs rs'):
+  Mem.to_ptr (rs' PC) m = Some (Vptr b Ptrofs.zero).
+Proof.
+  inv MCHAR. r in H0. exploit H0; eauto. i. des.
+  dup RCEXT. specialize (RCEXT0 PC). rewrite SPC in RCEXT0. inv RCEXT0; ss.
+  des_ifs_safe. exploit Mem.ptr2int_to_denormalize_max; eauto.
+  { eapply Ptrofs.unsigned_range_2. }
+  i. des. exploit Mem.denormalize_info; eauto. i. des.
+  erewrite Int64.unsigned_repr.
+  2:{ unfold Int64.max_unsigned, Ptrofs.max_unsigned in *. erewrite <- Ptrofs.modulus_eq64; eauto. lia. }
+  des_ifs.
+  unfold Int64.eq in Heq0. des_ifs. erewrite Int64.unsigned_zero in e.
+  erewrite Int64.unsigned_repr in e; try lia.
+  { unfold Int64.max_unsigned, Ptrofs.max_unsigned in *. erewrite <- Ptrofs.modulus_eq64; eauto. lia. }
+Qed.
+
+Lemma goto_label_fsim
+    m1 m1' m2 rs1 rs2 b ofs f l i rs1'
+    (CHAR: mem_char_all prog m2)
+    (SPC: rs1 PC = Vptr b ofs)
+    (INT: Genv.find_funct_ptr ge b = Some (Internal f))
+    (FIND: find_instr (Ptrofs.unsigned ofs) (fn_code f) = Some i)
+    (EXEC: goto_label f l rs1 m1 = Next rs1' m1')
+    (MCEXT: concrete_extends m1 m2)
+    (RCEXT: rs_binded m2 rs1 rs2):
+  exists rs2' m2',
+    Lowerbound.goto_label f l rs2 m2 = Next rs2' m2' /\ concrete_extends m1' m2' /\ rs_binded m2' rs1' rs2'.
+Proof.
+  exploit internal_pc_fsim; eauto. i. unfold goto_label in EXEC. des_ifs.
+  unfold Lowerbound.goto_label. erewrite Heq, H. esplits; eauto. eapply set_bind; eauto. econs.
+Qed.
+  
+Lemma exec_instr_fsim
+    f i rs1 rs2 m1 m2 rs1' m1' b ofs
+    (CHAR: mem_char_all prog m2)
+    (SPC: rs1 PC = Vptr b ofs)
+    (INT: Genv.find_funct_ptr ge b = Some (Internal f))
+    (FIND: find_instr (Ptrofs.unsigned ofs) (fn_code f) = Some i)
+    (EXEC: Asm.exec_instr ge f i rs1 m1 = Next rs1' m1')
+    (MCEXT: concrete_extends m1 m2)
+    (RCEXT: rs_binded m2 rs1 rs2):
+  exists rs2' m2',
+    Lowerbound.exec_instr ge f i rs2 m2 = Next rs2' m2'
+  /\ concrete_extends m1' m2'
+  /\ rs_binded m2' rs1' rs2'.
+Proof.
+  destruct i; ss; try by clarify;
+    match goal with
+    | H: exec_load _ _ _ _ _ _ = Next _ _ |- _ => (try by exploit exec_load_fsim; eauto)
+    | H: exec_store _ _ _ _ _ _ _ = Next _ _ |- _ => (try by exploit exec_store_fsim; eauto)
+    | _ => idtac
+    end.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto. econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto. econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    eapply val_intptr_refl.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto. econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto. econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto.
+    eapply zero_ext_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto.
+    eapply sign_ext_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto.
+    eapply zero_ext_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto.
+    eapply sign_ext_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto.
+    eapply longofintu_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto.
+    eapply longofint_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto.
+    eapply loword_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto.
+    eapply singleoffloat_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto.
+    eapply floatofsingle_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto.
+    eapply intoffloat_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto.
+    eapply floatofint_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto.
+    eapply intofsingle_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto.
+    eapply singleofint_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto.
+    eapply longoffloat_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto.
+    eapply floatoflong_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto.
+    eapply longofsingle_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto.
+    eapply singleoflong_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto.
+    eapply addrmode32_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto.
+    eapply addrmode64_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto.
+    eapply set_bind; eauto. specialize (RCEXT rd). unfold Val.neg. des_ifs; inv RCEXT; try econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto.
+    eapply set_bind; eauto. specialize (RCEXT rd). unfold Val.negl. des_ifs; inv RCEXT; try econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto.
+    eapply set_bind; eauto. eapply add_bind; eauto. econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto.
+    eapply set_bind; eauto. eapply addl_bind; eauto. econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto.
+    eapply set_bind; eauto. eapply sub_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto.
+    eapply set_bind; eauto. eapply subl_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto.
+    eapply set_bind; eauto. eapply psub_join_asm_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto.
+    eapply set_bind; eauto. eapply mul_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto.
+    eapply set_bind; eauto. eapply mull_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto.
+    eapply set_bind; eauto. eapply mul_bind; eauto. econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto.
+    eapply set_bind; eauto. eapply mull_bind; eauto. econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto.
+    eapply set_bind.
+    + unfold Val.mulhs. dup RCEXT. specialize (RCEXT RAX). specialize (RCEXT0 r1).
+      des_ifs; inv RCEXT; inv RCEXT0; try econs.
+    + eapply set_bind; eauto. eapply mul_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto.
+    eapply set_bind.
+    + unfold Val.mullhs. dup RCEXT. specialize (RCEXT RAX). specialize (RCEXT0 r1).
+      des_ifs; inv RCEXT; inv RCEXT0; try econs.
+    + eapply set_bind; eauto. eapply mull_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. 
+    eapply set_bind.
+    + unfold Val.mullhs. dup RCEXT. specialize (RCEXT RAX). specialize (RCEXT0 r1).
+      des_ifs; inv RCEXT; inv RCEXT0; try econs.
+    + eapply set_bind; eauto. eapply mul_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto.
+    eapply set_bind.
+    + unfold Val.mullhs. dup RCEXT. specialize (RCEXT RAX). specialize (RCEXT0 r1).
+      des_ifs; inv RCEXT; inv RCEXT0; try econs.
+    + eapply set_bind; eauto. eapply mull_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    unfold Val.shr. specialize (RCEXT RAX). des_ifs; inv RCEXT; try econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    unfold Val.shrl. specialize (RCEXT RAX). des_ifs; inv RCEXT; try econs.
+  - des_ifs_safe. dup RCEXT. dup RCEXT0. dup RCEXT1.
+    specialize (RCEXT RDX). specialize (RCEXT0 RAX). specialize (RCEXT1 r1).
+    rewrite Heq in RCEXT. rewrite Heq0 in RCEXT0. rewrite Heq1 in RCEXT1.
+    inv RCEXT; inv RCEXT0; inv RCEXT1. erewrite Heq2.
+    esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto; [econs|].
+    eapply set_bind; eauto. econs.
+  - des_ifs_safe. dup RCEXT. dup RCEXT0. dup RCEXT1.
+    specialize (RCEXT RDX). specialize (RCEXT0 RAX). specialize (RCEXT1 r1).
+    rewrite Heq in RCEXT. rewrite Heq0 in RCEXT0. rewrite Heq1 in RCEXT1.
+    inv RCEXT; inv RCEXT0; inv RCEXT1. erewrite Heq2.
+    esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto; [econs|].
+    eapply set_bind; eauto. econs.
+  - des_ifs_safe. dup RCEXT. dup RCEXT0. dup RCEXT1.
+    specialize (RCEXT RDX). specialize (RCEXT0 RAX). specialize (RCEXT1 r1).
+    rewrite Heq in RCEXT. rewrite Heq0 in RCEXT0. rewrite Heq1 in RCEXT1.
+    inv RCEXT; inv RCEXT0; inv RCEXT1. erewrite Heq2.
+    esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto; [econs|].
+    eapply set_bind; eauto. econs.
+  - des_ifs_safe. dup RCEXT. dup RCEXT0. dup RCEXT1.
+    specialize (RCEXT RDX). specialize (RCEXT0 RAX). specialize (RCEXT1 r1).
+    rewrite Heq in RCEXT. rewrite Heq0 in RCEXT0. rewrite Heq1 in RCEXT1.
+    inv RCEXT; inv RCEXT0; inv RCEXT1. erewrite Heq2.
+    esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto; [econs|].
+    eapply set_bind; eauto. econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    unfold Val.and. dup RCEXT. specialize (RCEXT rd). specialize (RCEXT0 r1).
+    des_ifs; inv RCEXT; inv RCEXT0; try econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    unfold Val.andl. dup RCEXT. specialize (RCEXT rd). specialize (RCEXT0 r1).
+    des_ifs; inv RCEXT; inv RCEXT0; try econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    unfold Val.and. specialize (RCEXT rd). des_ifs; inv RCEXT; try econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    unfold Val.andl. specialize (RCEXT rd). des_ifs; inv RCEXT; try econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    dup RCEXT. specialize (RCEXT rd). specialize (RCEXT0 r1). des_ifs; inv RCEXT; inv RCEXT0; try econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    dup RCEXT. specialize (RCEXT rd). specialize (RCEXT0 r1). des_ifs; inv RCEXT; inv RCEXT0; try econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    specialize (RCEXT rd). des_ifs; inv RCEXT; try econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    specialize (RCEXT rd). des_ifs; inv RCEXT; try econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto. econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto. econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    dup RCEXT. specialize (RCEXT rd). specialize (RCEXT0 r1). des_ifs; inv RCEXT; inv RCEXT0; try econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    dup RCEXT. specialize (RCEXT rd). specialize (RCEXT0 r1). des_ifs; inv RCEXT; inv RCEXT0; try econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    specialize (RCEXT rd). des_ifs; inv RCEXT; try econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    specialize (RCEXT rd). des_ifs; inv RCEXT; try econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    specialize (RCEXT rd). des_ifs; inv RCEXT; try econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    specialize (RCEXT rd). des_ifs; inv RCEXT; try econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    dup RCEXT. specialize (RCEXT rd). specialize (RCEXT0 RCX). des_ifs; inv RCEXT; inv RCEXT0; try econs.
+    eapply val_intptr_refl.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    dup RCEXT. specialize (RCEXT rd). specialize (RCEXT0 RCX). des_ifs; inv RCEXT; inv RCEXT0; try econs.
+    eapply val_intptr_refl.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    specialize (RCEXT rd). des_ifs; inv RCEXT; try econs. eapply val_intptr_refl.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    specialize (RCEXT rd). des_ifs; inv RCEXT; try econs. eapply val_intptr_refl.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    dup RCEXT. specialize (RCEXT rd). specialize (RCEXT0 RCX). des_ifs; inv RCEXT; inv RCEXT0; try econs.
+    eapply val_intptr_refl.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    dup RCEXT. specialize (RCEXT rd). specialize (RCEXT0 RCX). des_ifs; inv RCEXT; inv RCEXT0; try econs.
+    eapply val_intptr_refl.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    specialize (RCEXT rd). des_ifs; inv RCEXT; try econs. eapply val_intptr_refl.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    specialize (RCEXT rd). des_ifs; inv RCEXT; try econs. eapply val_intptr_refl.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    dup RCEXT. specialize (RCEXT rd). specialize (RCEXT0 RCX). des_ifs; inv RCEXT; inv RCEXT0; try econs.
+    eapply val_intptr_refl.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    dup RCEXT. specialize (RCEXT rd). specialize (RCEXT0 RCX). des_ifs; inv RCEXT; inv RCEXT0; try econs.
+    eapply val_intptr_refl.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    specialize (RCEXT rd). des_ifs; inv RCEXT; try econs. eapply val_intptr_refl.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    specialize (RCEXT rd). des_ifs; inv RCEXT; try econs. eapply val_intptr_refl.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    dup RCEXT. specialize (RCEXT rd). specialize (RCEXT0 r1).
+    des_ifs; inv RCEXT; inv RCEXT0; try econs; try eapply  val_intptr_refl.
+    + simpl. des_ifs.
+    + ss. des_ifs; ss; econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    specialize (RCEXT rd). des_ifs; inv RCEXT; try econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto.
+    specialize (RCEXT rd). des_ifs; inv RCEXT; try econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply compare_ints_binded; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply compare_longs_binded; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply compare_ints_binded; eauto. econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply compare_longs_binded; eauto. econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto.
+    eapply compare_ints_binded; eauto; [|econs]. eapply and_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto.
+    eapply compare_longs_binded; eauto; [|econs]. eapply andl_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto.
+    eapply compare_ints_binded; eauto; [|econs]. eapply and_bind; eauto. econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto.
+    eapply compare_longs_binded; eauto; [|econs]. eapply andl_bind; eauto. econs.
+  - destruct (eval_testcond c rs1) eqn:TEST1.
+    2:{ inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto. econs. }
+    exploit eval_testcond_bind; eauto. i. rewrite H.
+    inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto. des_ifs; eauto.
+  - destruct (eval_testcond c rs1) eqn:TEST1.
+    2:{ inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto. econs. }
+    exploit eval_testcond_bind; eauto. i. rewrite H.
+    inv EXEC. esplits; eauto. ss. eapply nextinstr_sim; eauto. eapply set_bind; eauto. eapply val_intptr_refl.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto. eapply addf_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto. eapply subf_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto. eapply mulf_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto. eapply divf_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto. eapply negf_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto. eapply absf_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply compare_floats_binded; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto. econs.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto. eapply addfs_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto. eapply subfs_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto. eapply mulfs_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto. eapply divfs_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto. eapply negfs_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply set_bind; eauto. eapply absfs_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto. eapply compare_floats32_binded; eauto.
+  - inv EXEC. esplits; eauto. eapply nextinstr_nf_sim; eauto. eapply set_bind; eauto. econs.
+  - exploit goto_label_fsim; eauto.
+  - inv EXEC. esplits; eauto. eapply set_bind; eauto. eapply val_intptr_refl.
+  - inv EXEC. esplits; eauto. unfold to_ptr. des_ifs.
+    2:{ eapply set_bind; eauto. econs. }
+    eapply set_bind; eauto. specialize (RCEXT r). inv RCEXT; (try by (rewrite <- H0 in Heq; ss)); ss.
+    + rewrite <- H0 in Heq. ss. des_ifs.
+      { eapply Int64.same_if_eq in Heq1. subst. econs. }
+      econs; eauto. ss. exploit Mem.denormalize_info; eauto. i. des.
+      rewrite Ptrofs.unsigned_repr; [|lia]. unfold Mem.ptr2int.
+      exploit extended_concrete; eauto. i. rewrite H1. subst. des_ifs.
+      do 2 f_equal. eapply Int64.same_if_eq. unfold Int64.eq.
+      des_ifs. exfalso. eapply n.
+      repeat rewrite Int64.unsigned_repr_eq.
+      replace (caddr + (Int64.unsigned i - caddr)) with (Int64.unsigned i) by lia.
+      rewrite <- Int64.unsigned_repr_eq. rewrite Int64.repr_unsigned. eauto.
+    + erewrite <- H0 in Heq. ss. clarify. econs.
+    + des_ifs. erewrite <- H in Heq. ss. clarify. econs; eauto. ss. des_ifs.
+  - destruct (eval_testcond c rs1) eqn:TST; clarify.
+    exploit eval_testcond_bind; eauto. i. rewrite H. destruct b0; ss.
+    + exploit goto_label_fsim; eauto.
+    + inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto.
+  - destruct (eval_testcond c1 rs1) eqn:TST1; clarify.
+    exploit eval_testcond_bind; eauto. i. rewrite H.
+    destruct b0; destruct (eval_testcond c2 rs1) eqn:TST2; clarify.
+    + exploit eval_testcond_bind; eauto. i. rewrite H0.
+      destruct b0; ss.
+      * exploit goto_label_fsim; eauto.
+      * inv EXEC. esplits; eauto. eapply nextinstr_sim; eauto.
+    + exploit eval_testcond_bind; eauto. i. rewrite H0.
+      esplits; eauto. eapply nextinstr_sim; eauto.
+  - destruct (rs1 r) eqn:R; try by (ss; clarify).
+    exploit RCEXT. instantiate (1:=r). i. rewrite R in H. inv H. des_ifs.
+    exploit goto_label_fsim; try eapply EXEC; eauto. repeat (eapply set_bind; try by econs). eauto.
+  - inv EXEC. esplits; eauto. eapply set_bind.
+    { eapply val_intptr_refl. }
+    eapply set_bind; eauto. eapply pc_add_one_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply set_bind.
+    { specialize (RCEXT r). inv RCEXT; unfold to_ptr; ss; try by econs.
+      des_ifs.
+      { eapply Int64.same_if_eq in Heq1. subst. eapply val_intptr_refl. }
+      2:{ econs. }
+      econs; eauto. ss. exploit Mem.denormalize_info; eauto. i. des.
+      unfold Mem.ptr2int. exploit extended_concrete; eauto. i. rewrite H1. des_ifs.
+      do 2 f_equal. eapply Int64.same_if_eq. unfold Int64.eq.
+      des_ifs. exfalso. eapply n.
+      repeat rewrite Int64.unsigned_repr_eq. repeat rewrite Ptrofs.unsigned_repr_eq.
+      rewrite Ptrofs.modulus_eq64; eauto. rewrite Zplus_mod_idemp_r.
+      replace (caddr + (Int64.unsigned i - caddr)) with (Int64.unsigned i) by lia.
+      rewrite <- Int64.unsigned_repr_eq. rewrite Int64.repr_unsigned. eauto. }
+    eapply set_bind; eauto. eapply pc_add_one_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply set_bind; eauto.
+  - inv EXEC. esplits; eauto. eapply set_bind; eauto.
+    eapply pc_add_one_bind; eauto.
+  - des_ifs_safe. exploit alloc_concrete_extends; eauto. i. des.
+    rewrite Heq in FREE. clarify.
+    exploit store_concrete_extends; try eapply Heq1; eauto.
+    { eapply alloc_val_intptr; eauto. }
+    i. des.
+    exploit store_concrete_extends; try eapply Heq2; eauto.
+    { instantiate (1:=rs2 RA). eapply store_val_intptr; eauto. eapply alloc_val_intptr; eauto. }
+    i. des. erewrite STORE, STORE0. esplits; eauto.
+    eapply nextinstr_sim; eauto. eapply set_bind.
+    { econs. }
+    eapply set_bind; eauto.
+    { eapply store_val_intptr; eauto. eapply store_val_intptr; eauto. eapply alloc_val_intptr; eauto. }
+    ii. eapply store_val_intptr; eauto. eapply store_val_intptr; eauto. eapply alloc_val_intptr; eauto.
+  - des_ifs_safe.
+    exploit loadv_concrete_extends; try eapply Heq; eauto.
+    { rewrite <- Heq1. eapply pc_add_delta_bind; eauto. }
+    i. des.
+    exploit loadv_concrete_extends; try eapply Heq0; eauto.
+    { rewrite <- Heq1. eapply pc_add_delta_bind; eauto. }
+    i. des. erewrite H, H1. 
+    assert (to_ptr (val_add_ptrofs (rs2 RSP) ofs_ra) m2 = Val.offset_ptr (Vptr b0 i) ofs_ra).
+    { unfold to_ptr. ss. unfold Mem.loadv in Heq. simpl. ss.
+      exploit Mem.load_valid_access; eauto. i. eapply Mem.valid_access_perm with (k:=Cur) in H3.
+      exploit to_ptr_concrete_exnteds. eauto.
+      2:{ eapply Mem.perm_implies; eauto. econs. }
+      { specialize (RCEXT RSP). eapply pc_add_delta_bind with (delta:=ofs_ra). eapply RCEXT. }
+      { rewrite Heq1. ss. }
+      i. erewrite H4. ss. }
+    erewrite H3. ss. exploit free_concrete_extends; eauto. i. des.
+    erewrite FREE; eauto. esplits; eauto.
+    eapply set_bind.
+    { eapply pc_add_one_bind. eapply free_val_intptr; eauto. eapply set_bind; eauto.
+      eapply set_bind; eauto. }
+    eapply set_bind; eauto.
+    { eapply free_val_intptr; eauto. }
+    eapply set_bind; eauto.
+    { eapply free_val_intptr; eauto. }
+    ii. eapply free_val_intptr; eauto.
+Qed.
+
+Lemma memval_concrete_extends
+    m m' mv1 mv2
+    (CEXT: forall b addr, m.(Mem.mem_concrete) ! b = Some addr -> m'.(Mem.mem_concrete) ! b = Some addr)
+    (MVL: memval_intptr m mv1 mv2):
+  memval_intptr m' mv1 mv2.
+Proof.
+  inv MVL; ss; try by econs.
+  - des_ifs_safe. unfold Mem.ptr2int in Heq0. des_ifs.
+    exploit CEXT; eauto. i. econs; eauto; ss.
+    { ss. unfold Mem.ptr2int. erewrite H0. des_ifs. }
+    ss.
+  - inv H; ss; try by eapply memval_intptr_refl.
+    2:{ econs. econs. }
+    des_ifs. unfold Mem.ptr2int in Heq. des_ifs. exploit CEXT; eauto. i.
+    econs. econs; eauto. ss. unfold Mem.ptr2int. rewrite H. des_ifs.
+Qed.
+
+Lemma val_intptr_concrete_extends
+    m m' v1 v2
+    (CEXT: forall b addr, m.(Mem.mem_concrete) ! b = Some addr -> m'.(Mem.mem_concrete) ! b = Some addr)
+    (BIND: val_intptr m v1 v2):
+  val_intptr m' v1 v2.
+Proof.
+  inv BIND; ss; try by econs. econs; eauto. ss.
+  unfold Mem.ptr2int in *. des_ifs_safe. exploit CEXT; eauto. i. erewrite H0; ss.
+Qed.
+
+Lemma rs_binded_concrete_extends
+    m m' rs1 rs2
+    (CEXT: forall b addr, m.(Mem.mem_concrete) ! b = Some addr -> m'.(Mem.mem_concrete) ! b = Some addr)
+    (RCEXT: rs_binded m rs1 rs2):
+  rs_binded m' rs1 rs2.
+Proof.
+  ii. eapply val_intptr_concrete_extends; eauto.
+Qed.
+
+Lemma val_intptr_trans
+    m v1 v2 v3
+    (BIND1: val_intptr m v1 v2)
+    (BIND2: val_intptr m v2 v3):
+  val_intptr m v1 v3.
+Proof.
+  inv BIND1; inv BIND2; ss; try by econs.
+Qed.
+
+Lemma memval_intptr_trans
+    m mv1 mv2 mv3
+    (MVB1: memval_intptr m mv1 mv2)
+    (MVB2: memval_intptr m mv2 mv3):
+  memval_intptr m mv1 mv3.
+Proof.
+  inv MVB1; inv MVB2; ss; try by econs.
+  { econs; eauto. }
+  { inv H; econs; eauto. }
+  { econs. eapply val_intptr_trans; eauto. }
+  inv H. econs.
+Qed.
+
+Lemma memval_intptr_lbd_memval_intptr
+    m mv1 mv2
+    (MVBL: memval_intptr_lbd m mv1 mv2):
+  memval_intptr m mv1 mv2.
+Proof.
+  unfold memval_intptr_lbd in MVBL. des_ifs; eauto; try by econs.
+  { des; eauto. }
+  { eapply memval_intptr_refl. }
+Qed.
+
+Lemma block_concretize_simulation
+    m1 m2 rs1 rs2 m2'
+    (MCEXT : concrete_extends m1 m2)
+    (RCEXT : rs_binded m2 rs1 rs2)
+    (MCONC: memory_block_concretize m2 m2'):
+  concrete_extends m1 m2' /\ rs_binded m2' rs1 rs2.
+Proof.
+  split.
+  - inv MCEXT. inv MCONC. des. econs.
+    + erewrite same_nextblock. eauto.
+    + i. eapply extended_access in H4.
+      unfold Mem.perm in H4. erewrite H0 in H4. eauto.
+    + i. rewrite <- H. exploit extended_contents; eauto. i.
+      eapply memval_concrete_extends; eauto.
+    + i. exploit extended_concrete; eauto.
+  - inv MCONC. des. eapply rs_binded_concrete_extends; eauto.
+Qed.
+
+Lemma memory_concretize_contents_simulation
+    m1 m2 rs1 rs2 m2'
+    (MCEXT : concrete_extends m1 m2)
+    (RCEXT : rs_binded m2 rs1 rs2)
+    (MCONC: memory_concretize_contents m2 m2'):
+  concrete_extends m1 m2' /\ rs_binded m2' rs1 rs2.
+Proof.
+  inv MCONC. des. splits; cycle 1.
+  { eapply rs_binded_concrete_extends; try eapply RCEXT. i.
+    rewrite <- H1; eauto. }
+  inv MCEXT. econs.
+  - rewrite same_nextblock; eauto.
+  - i. eapply extended_access in H3. unfold Mem.perm. rewrite <-H. eauto.
+  - i. specialize (H2 b ofs). eapply extended_contents in H3.
+    eapply same_concrete_memval_intptr in H3; eauto. des_safe.
+    eapply memval_intptr_trans; eauto.
+    eapply memval_intptr_lbd_memval_intptr; eauto.
+  - i. rewrite <- H1. eauto.
+Qed.
+
+Lemma register_concretizer_simulation
+    m rs1 rs2 rs2'
+    (RCEXT : rs_binded m rs1 rs2)
+    (RCONC: register_concretizer m rs2 rs2'):
+  rs_binded m rs1 rs2'.
+Proof.
+  ii. specialize (RCEXT r). specialize (RCONC r). des_ifs; inv RCEXT; (try by econs);
+    try (rewrite <- RCONC; econs; eauto).
+  des. eauto.
+Qed.
+
+Lemma cstep_simulation
+     S1 S2 S2'
+    (MS: match_states S1 S2)
+    (CSTEP: cstep S2 S2'):
+  match_states S1 S2'.
+Proof.
+  inv CSTEP. inv MS.
+  exploit block_concretize_simulation; eauto. i. des.
+  exploit memory_concretize_contents_simulation; try eapply H; eauto. i. des.
+  eapply register_concretizer_simulation in H2; eauto. econs; eauto.
+Qed.
+
+Definition ge_binded_state (ge: genv) (st: Lowerbound.state) (gm: positive -> option Z) : Prop :=
+  ge_binded ge (Lowerbound.state_mem st) gm.
+
+Lemma ge_binded_state_astep
+    st st' tr gm
+    (BIND: ge_binded_state ge st gm)
+    (STEP: astep ge st tr st'):
+  ge_binded_state ge st' gm.
+Proof.
+  unfold ge_binded_state in *. inv STEP; ss. 
+  - destruct i; ss; try by clarify;
+    match goal with
+    | H: Lowerbound.exec_load _ _ _ _ _ _ = Next _ _ |- _ => (unfold Lowerbound.exec_load in *; des_ifs)
+    | H: Lowerbound.exec_store _ _ _ _ _ _ _ = Next _ _ |- _ =>
+        (unfold Lowerbound.exec_store, Mem.storev in *; des_ifs; eapply ge_binded_store; eauto; ss)
+    | _ => idtac
+    end; try by des_ifs.
+    + unfold Lowerbound.goto_label in H2. des_ifs.
+    + unfold Lowerbound.goto_label in H2. des_ifs.
+    + unfold Lowerbound.goto_label in H2. des_ifs.
+    + unfold Lowerbound.goto_label in H2. des_ifs.
+    + des_ifs. eapply ge_binded_alloc in Heq; eauto.
+      eapply ge_binded_store in Heq0; eauto. eapply ge_binded_store; eauto.
+    + des_ifs. eapply ge_binded_free; eauto.
+  - eapply ge_binded_external_call; eauto.
+  - eapply ge_binded_external_call; eauto.
+Qed.
+
+Lemma ge_binded_block_concretize
+    m m' gm
+    (BIND: ge_binded ge m gm)
+    (CONC : memory_block_concretize m m'):
+  ge_binded ge m' gm.
+Proof.
+  unfold ge_binded in *. i. exploit BIND; eauto. i. des. esplits; eauto.
+  inv CONC. des. rewrite H2 in *. eauto.
+Qed.
+
+Lemma ge_binded_state_cstep
+    st st' gm
+    (BIND: ge_binded_state ge st gm)
+    (STEP: cstep st st'):
+  ge_binded_state ge st' gm.
+Proof.
+  inv STEP. unfold ge_binded_state in *. ss.
+  eapply ge_binded_block_concretize in CONC; eauto. inv CCONC. des.
+  unfold ge_binded in CONC. ii. exploit CONC; eauto. i. des. esplits; eauto.
+  rewrite <- H1; eauto.
+Qed.
+
+Lemma ge_binded_state_step
+    st st' tr gm
+    (BIND: ge_binded_state ge st gm)
+    (STEP: Lowerbound.step ge st tr st'):
+  ge_binded_state ge st' gm.
+Proof.
+  inv STEP.
+  - eapply ge_binded_state_cstep; try eapply CSTEP. eapply ge_binded_state_astep; eauto.
+  - eapply ge_binded_state_astep; eauto.
+Qed.
+
+Lemma eval_builtin_arg_bind
+    m m' rs rs' arg varg
+    (MCEXT: concrete_extends m m')
+    (RCEXT: rs_binded m' rs rs')
+    (SRC: Events.eval_builtin_arg ge rs (rs RSP) m arg varg):
+  exists varg', eval_builtin_arg PregEq.t ge rs' (rs' RSP) m' arg varg' /\ val_intptr m' varg varg'.
+Proof.
+  move SRC before ICAP1. revert_until ICAP1. induction 1; i; ss.
+  - esplits; eauto. econs.
+  - esplits; eauto. econs. econs.
+  - esplits; eauto. econs. econs.
+  - esplits; eauto. econs. econs.
+  - esplits; eauto. econs. econs.
+  - exploit loadv_concrete_extends; try eapply H; eauto.
+    { eapply pc_add_delta_bind. eauto. }
+    i. des. esplits; eauto. econs; eauto.
+  - esplits; eauto; try by econs. eapply pc_add_delta_bind. eauto.
+  - exploit loadv_concrete_extends; try eapply H; eauto.
+    { eapply val_intptr_refl. }
+    i. des. esplits; eauto. econs; eauto.
+  - esplits; eauto. econs. eapply val_intptr_refl.
+  - exploit IHSRC1; eauto. i. des. exploit IHSRC2; eauto. i. des. esplits. econs; eauto.
+    eapply longofwords_bind; eauto.
+  - exploit IHSRC1; eauto. i. des. exploit IHSRC2; eauto. i. des. esplits. econs; eauto.
+    destruct Archi.ptr64.
+    + eapply addl_bind; eauto.
+    + eapply add_bind; eauto.
+Qed.
+
+Lemma eval_builtin_arg_determ_lbd
+    m rs arg varg1
+    (ARG1: eval_builtin_arg PregEq.t ge rs (rs RSP) m arg varg1)
+    varg2 (ARG2: eval_builtin_arg PregEq.t ge rs (rs RSP) m arg varg2):
+  varg2 = varg1.
+Proof.
+  revert_until ICAP1. induction 1; i; try by (inv ARG2; eauto; Eq).
+  - inv ARG2. eapply IHARG1_1 in H1. subst. eapply IHARG1_2 in H3. subst. eauto.
+  - inv ARG2. eapply IHARG1_1 in H1. subst. eapply IHARG1_2 in H3. subst. eauto.
+Qed.
+
+Lemma eval_builtin_args_bind
+    m m' rs rs' args vargs
+    (MCEXT: concrete_extends m m')
+    (RCEXT: rs_binded m' rs rs')
+    (SRC: Events.eval_builtin_args ge rs (rs RSP) m args vargs):
+  exists vargs', eval_builtin_args PregEq.t ge rs' (rs' RSP) m' args vargs' /\ val_intptrist m' vargs vargs'.
+Proof.
+  revert SRC. revert args vargs. induction 1; i.
+  { esplits; eauto; econs. }
+  des. exploit eval_builtin_arg_bind; eauto. i. des. esplits; eauto.
+  { econs; eauto. }
+  econs; eauto.
+Qed.
+
+Lemma eval_builtin_args_determ_lbd
+    m rs arg varg1
+    (ARG1: eval_builtin_args PregEq.t ge rs (rs RSP) m arg varg1)
+    varg2 (ARG2: eval_builtin_args PregEq.t ge rs (rs RSP) m arg varg2):
+  varg2 = varg1.
+Proof.
+  revert_until ICAP1. induction 1; i; try by (inv ARG2; eauto; Eq).
+  inv ARG2. exploit eval_builtin_arg_determ_lbd. eapply H. eapply H2. i. subst.
+  exploit IHARG1; eauto. i. subst. eauto.
+Qed.
+
+Lemma extcall_arg_bind
+    m m' rs rs' l v1
+    (MCEXT: concrete_extends m m')
+    (RCEXT: rs_binded m' rs rs')
+    (SRC: Asm.extcall_arg rs m l v1):
+  exists v2, Lowerbound.extcall_arg rs' m' l v2 /\ val_intptr m' v1 v2.
+Proof.
+  inv SRC.
+  - esplits. econs. eauto.
+  - exploit loadv_concrete_extends; try eapply H0; eauto.
+    { eapply pc_add_delta_bind. eauto. }
+    i. des. esplits; eauto. econs; eauto.
+Qed.
+
+Lemma extcall_arg_pair_bind
+    m m' rs rs' l v1
+    (MCEXT: concrete_extends m m')
+    (RCEXT: rs_binded m' rs rs')
+    (SRC: Asm.extcall_arg_pair rs m l v1):
+  exists v2, Lowerbound.extcall_arg_pair rs' m' l v2 /\ val_intptr m' v1 v2.
+Proof.
+  revert SRC. revert l v1. induction 1; i.
+  - exploit extcall_arg_bind; eauto. i. des. esplits; eauto. econs. eauto.
+  - eapply extcall_arg_bind in H; eauto. eapply extcall_arg_bind in H0; eauto. des.
+    esplits. econs; eauto. eapply longofwords_bind; eauto.
+Qed.
+
+Lemma extcall_arg_pair_list_bind
+    m m' rs rs' l v1
+    (MCEXT: concrete_extends m m')
+    (RCEXT: rs_binded m' rs rs')
+    (SRC: list_forall2 (Asm.extcall_arg_pair rs m) l v1):
+  exists v2, list_forall2 (Lowerbound.extcall_arg_pair rs' m') l v2 /\ val_intptrist m' v1 v2.
+Proof.
+  revert SRC. revert l v1. induction 1; i.
+  { esplits; econs. }
+  des. exploit extcall_arg_pair_bind; eauto. i. des. esplits; econs; eauto.
+Qed.
+
+Lemma extcall_arguments_bind
+    m m' rs rs' ef args
+    (MCEXT: concrete_extends m m')
+    (RCEXT: rs_binded m' rs rs')
+    (SRC: extcall_arguments rs m (ef_sig ef) args):
+  exists args', Lowerbound.extcall_arguments rs' m' (ef_sig ef) args' /\ val_intptrist m' args args'.
+Proof.
+  exploit extcall_arg_pair_list_bind; eauto.
+Qed.
+  
+Theorem astep_simulation:
+  forall S1' t' S2', astep ge S1' t' S2' ->
+  forall S1 (SAFE: safe sem S1) (IBIND: ge_binded_state ge S1' gmtgt) (TCHAR: state_char prog S1') (MS: match_states S1 S1'),
+  (exists t S2, tr_rel (ev_rel gmtgt) t t' /\ Step sem S1 t S2 /\ match_states S2 S2')
+\/ (exists t S2, (~ trace_intact t')
+         /\ Star sem S1 t S2
+         /\ exists tl, tr_rel (ev_rel gmtgt) t (trace_cut_pterm t' ** tl)).
+Proof.
+  induction 1; ss. i.
+  - left. exists E0. inv MS.
+    specialize (SAFE _ (star_refl _ _ _)). des.
+    { inv SAFE. specialize (RCEXT PC). rewrite H5 in RCEXT. inv RCEXT. des_ifs.
+      rewrite <- H6 in H. rewrite <- Heq in H. ss. }
+    assert (rs0 PC = Vptr b ofs).
+    { r in TCHAR. ss. inv SAFE.
+      + exploit internal_pc_fsim; eauto. i. clarify.
+      + exploit internal_pc_fsim; eauto. i. clarify.
+      + exploit external_pc_fsim; eauto. i. clarify. }
+    inv SAFE; Eq; ss; fold ge in H7; Eq; ss.
+    fold ge in H11.
+    exists (State rs'0 m'0). esplits; [econs| |].
+    { econs; eauto. }
+    { exploit exec_instr_fsim; eauto. i. des. ss. Eq.
+      econs; eauto. }
+  - i. inv MS.
+    specialize (SAFE _ (star_refl _ _ _)). des.
+    { inv SAFE. specialize (RCEXT PC). rewrite H6 in RCEXT. inv RCEXT. des_ifs.
+      rewrite <- H7 in H. rewrite <- Heq in H. ss. }
+    assert (rs0 PC = Vptr b ofs).
+    { r in TCHAR. ss. inv SAFE.
+      + exploit internal_pc_fsim; eauto. i. clarify.
+      + exploit internal_pc_fsim; eauto. i. clarify.
+      + exploit external_pc_fsim; eauto. i. clarify. }
+    inv SAFE; Eq; ss; fold ge in H8; Eq; ss.
+    assert (BINDARGS: val_intptrist m vargs0 vargs).
+    { exploit eval_builtin_args_bind; eauto. i. des.
+      exploit eval_builtin_args_determ_lbd. eapply H2. fold ge. eapply H5. i. subst. eauto. }
+    (* MOVE THIS TO Events.v *)
+    assert (BWD: extcall_properties_backward (external_call ef0) (ef_sig ef0)).
+    { destruct (classic (is_external_ef ef0)).
+      { eapply external_call_spec_backward. eauto. }
+      eapply forwrard_axiom_implies_backward_axiom. eapply external_call_spec. eauto. }
+    exploit ec_concrete_extends_backward; try eapply MCEXT; eauto.
+    i. des.
+    + left. esplits; eauto. econs 2; eauto.
+      econs; eauto. eapply nextinstr_nf_sim. eapply set_res_bind; eauto. eapply undef_regs_binded; eauto.
+      ii. eapply val_intptr_concrete_extends.
+      { eapply ec_binds; eauto. eapply external_call_common_spec. }
+      eauto.
+    + eapply UBSRC in H11. contradiction.
+    + right. esplits; eauto. eapply star_one. econs 2; eauto.
+  - i. inv MS.
+    specialize (SAFE _ (star_refl _ _ _)). des.
+    { inv SAFE. specialize (RCEXT PC). rewrite H5 in RCEXT. inv RCEXT. des_ifs.
+      rewrite <- H6 in H. rewrite <- Heq in H. ss. }
+    assert (rs0 PC = Vptr b Ptrofs.zero).
+    { r in TCHAR. ss. inv SAFE.
+      + exploit internal_pc_fsim; eauto. i. clarify.
+      + exploit internal_pc_fsim; eauto. i. clarify.
+      + exploit external_pc_fsim; eauto. i. clarify. }
+    inv SAFE; Eq; ss; fold ge in H7; Eq; ss.
+    assert (BINDARGS: val_intptrist m args0 args).
+    { exploit extcall_arguments_bind; eauto. i. des.
+      exploit Lowerbound.extcall_arguments_determ. eapply H1. eapply H4. i. subst; eauto. }
+    assert (BWD: extcall_properties_backward (external_call ef0) (ef_sig ef0)).
+    { destruct (classic (is_external_ef ef0)).
+      { eapply external_call_spec_backward. eauto. }
+      eapply forwrard_axiom_implies_backward_axiom. eapply external_call_spec. eauto. }
+    exploit ec_concrete_extends_backward; try eapply MCEXT; eauto.
+    i. des.
+    + left. esplits; eauto. econs 3; eauto.
+      econs; eauto. eapply set_bind; eauto.
+      { eapply val_intptr_concrete_extends. eapply ec_binds. eapply external_call_common_spec. eauto. eauto. }
+      eapply set_pair_bind; eauto. unfold undef_caller_save_regs. ii. des_ifs; try by econs.
+      { eapply val_intptr_concrete_extends. eapply ec_binds. eapply external_call_common_spec. eauto. eauto. }
+    + eapply UBSRC in H9. contradiction.
+    + right. esplits; eauto. eapply star_one. econs 3; eauto.
+Qed.
+
+Theorem step_simulation:
+  forall S1' t' S2', Step tsem S1' t' S2' ->
+  forall S1 (SAFE: safe sem S1) (IBIND: ge_binded_state ge S1' gmtgt) (TCHAR: state_char prog S1') (MS: match_states S1 S1'),
+    (exists t S2, tr_rel (ev_rel gmtgt) t t' /\ Step sem S1 t S2 /\ match_states S2 S2')
+  \/ (exists t S2, (~ trace_intact t')
+           /\ Star sem S1 t S2
+           /\ exists tl, tr_rel (ev_rel gmtgt) t (trace_cut_pterm t' ** tl)).
+Proof.
+  induction 1; ss; i.
+  - exploit astep_simulation; eauto. i. des.
+    + left. exploit cstep_simulation; try eapply CSTEP; eauto.
+    + right. esplits; eauto.
+  - exploit astep_simulation; eauto. i. des.
+    + right.
+      exploit tr_rel_cut_pterm; eauto.
+      { i. destruct ev1, ev2; ss. }
+      intros.
+      do 2 eexists. splits.
+      { subst. ii. eapply trace_intact_app_rev in H3. des.
+        eapply INTACT1; ss. eauto. }
+      { eapply star_one; eauto. }
+      { specialize (trace_cut_pterm_split t). i. des.
+        erewrite H3. erewrite OOMTR.
+        replace (trace_cut_pterm (tr ++ [Event_pterm])) with (trace_cut_pterm tr).
+        2:{ clear. ginduction tr; ss. rewrite <- IHtr. eauto. }
+        exists t1. eapply tr_rel_app; eauto. eapply tr_rel_refl. eapply ev_rel_refl. }
+    + right.
+      eexists. eexists. splits.
+      { subst. ii. eapply trace_intact_app_rev in H2. des; eauto. }
+      { eauto. }
+      { subst. 
+        replace (trace_cut_pterm (tr ++ [Event_pterm])) with (trace_cut_pterm tr).
+        2:{ clear. ginduction tr; ss. rewrite <- IHtr. eauto. }
+        eauto. }
+Qed.
+
+Lemma lowerbound_progress
+    S1 S2 tr S1'
+    (GEBIND: ge_binded_state (Genv.globalenv prog) S2 gmtgt)
+    (TCHAR: state_char prog S2)
+    (MATCH: match_states S1 S2)
+    (SAFESRC: Step (Asm.semantics prog) S1 tr S1'):
+  exists tr' S2', Step (Lowerbound.semantics prog) S2 tr' S2'.
+Proof.
+  inv MATCH. inv SAFESRC; ss.
+  - exploit internal_pc_fsim; eauto; i; ss.
+    exploit exec_instr_fsim; eauto. i. des.
+    assert (exists tr' S2', astep ge (Lowerbound.State rs' m') tr' S2').
+    { esplits. econs; eauto. }
+    des.
+    destruct (classic (exists S2'', cstep S2' S2'')).
+    { des. esplits. econs; eauto. }
+    esplits. econs 2; eauto.
+  - exploit internal_pc_fsim; eauto; i; ss.
+    assert (BWD: extcall_properties_backward (external_call ef) (ef_sig ef)).
+    { destruct (classic (is_external_ef ef)).
+      - eapply external_call_spec_backward; eauto.
+      - eapply forwrard_axiom_implies_backward_axiom. eapply external_call_spec. eauto. }
+    exploit eval_builtin_args_bind; eauto. i. des.
+    exploit ec_concrete_extends_backward_progress; eauto. i. des.
+    assert (exists tr' S2', astep ge (Lowerbound.State rs' m') tr' S2').
+    { esplits. econs 2; eauto. }
+    des.
+    destruct (classic (exists S2'', cstep S2' S2'')).
+    { des. esplits. econs; eauto. }
+    esplits. econs 2; eauto.
+  - exploit external_pc_fsim; eauto; i; ss.
+    assert (BWD: extcall_properties_backward (external_call ef) (ef_sig ef)).
+    { destruct (classic (is_external_ef ef)).
+      - eapply external_call_spec_backward; eauto.
+      - eapply forwrard_axiom_implies_backward_axiom. eapply external_call_spec. eauto. }
+    exploit extcall_arguments_bind; eauto. i. des.
+    exploit ec_concrete_extends_backward_progress; eauto. i. des.
+    assert (exists tr' S2', astep ge (Lowerbound.State rs' m') tr' S2').
+    { esplits. econs 3; eauto. }
+    des.
+    destruct (classic (exists S2'', cstep S2' S2'')).
+    { des. esplits. econs; eauto. }
+    esplits. econs 2; eauto.
+Qed.
+
+Lemma final_state_determ: forall p st0 retv,
+    Lowerbound.final_state st0 retv ->
+    Dfinal_state (Lowerbound.semantics p) st0 retv.
+Proof.
+  econstructor; eauto.
+  - intros. inv FINAL0; inv FINAL1; Eq; auto.
+  - red. unfold not. intros.
+    assert (NOSTEP: forall t st', ~ astep (Genv.globalenv p) st0 t st').
+    { ii. inv FINAL. inv H1; try rewrite H2 in *; ss. }     
+    inv FINAL; inv H0; simpl in *; Eq.
+    + eapply NOSTEP; eauto.
+    + eapply NOSTEP; eauto.
+Qed.
+
+Lemma final_state_fsim
+    st_src0 st_tgt0 r
+    (FINAL: Asm.final_state st_src0 r)
+    (MS: match_states st_src0 st_tgt0):
+  Lowerbound.final_state st_tgt0 r.
+Proof.
+  inv FINAL. inv MS. econs.
+  { specialize (RCEXT PC). erewrite H in RCEXT. inv RCEXT; ss. }
+  { specialize (RCEXT RAX). erewrite H0 in RCEXT. inv RCEXT; ss. }
+Qed.
+
+Lemma final_state_bsim
+    st_src0 st_tgt0 r
+    (SAFE: safe sem st_src0)
+    (FINAL: Lowerbound.final_state st_tgt0 r)
+    (TCHAR: state_char prog st_tgt0)
+    (MS: match_states st_src0 st_tgt0):
+  Asm.final_state st_src0 r.
+Proof.
+  specialize (SAFE _ (star_refl _ _ _)). des.
+  2:{ unfold state_char in TCHAR. inv SAFE; inv MS; inv FINAL.
+      - exploit internal_pc_fsim; eauto. i. ss. rewrite H5 in H3; ss.
+      - exploit internal_pc_fsim; eauto. i. ss. rewrite H6 in H4; ss.
+      - exploit external_pc_fsim; eauto. i. ss. rewrite H5 in H3; ss. }
+  exploit final_state_fsim; eauto. i. exploit final_state_determ. eauto.
+  instantiate (1:=prog). i. inv H0. exploit DTM; ss. eapply FINAL. eapply H. i. subst; eauto.
+Qed.
+
+Lemma initial_state_determ: forall st0 st1,
+    initial_state_r prog st0 ->
+    initial_state_r prog st1 -> st0 = st1.
+Proof.
+  intros. inv H; inv H0. inv INIT; inv INIT0; clarify.
+  exploit realloc_globals_determ. eapply REA. eapply REA0. i. subst.
+  subst ge ge0. subst rs2 rs0. eauto.
+Qed.
+
+Lemma match_states_xsim
+    st_src0 st_tgt0
+    (IBIND: ge_binded_state ge st_tgt0 gmtgt) (TCHAR: state_char prog st_tgt0)
+    (MATCH: match_states st_src0 st_tgt0) :
+  bsim sem tsem gmtgt lt 0%nat st_src0 st_tgt0.
+Proof.
+  generalize dependent st_src0. generalize dependent st_tgt0.
+  pcofix CIH. i. pfold.
+  econs. i. econs.
+  - i. exploit step_simulation; eauto. i. destruct H; des_safe.
+    { left. esplits; eauto. left. eapply plus_one; eauto.
+      right. eapply CIH; eauto.
+      - eapply ge_binded_state_step; eauto.
+      - eapply state_char_preservation; eauto. }
+    { right. esplits; eauto. }
+  - ii. esplits; eauto.
+    { eapply star_refl. }
+    eapply final_state_bsim; eauto.
+  - specialize (SAFESRC _ (star_refl _ _ _)). des.
+    { exploit final_state_fsim; eauto. }
+    right. eapply lowerbound_progress; eauto.
+Qed.
+
+
+End PRESERVATION.
+
+Lemma transf_initial_states1
+    prog st1 (INIT: Asm.initial_state prog st1):
+  exists st2, Lowerbound.initial_state prog st2 /\ match_states st1 st2.
+Proof.
+  inv INIT. unfold ge in *. esplits.
+  { econs. eauto. }
+  subst rs0. econs.
+  { eapply concrete_ext_refl. }
+  eapply rs_binded_refl.
+Qed.
+
+
+(* move to Memory.v *)
+Lemma nonempty_alloc_contents
+  b lo hi m m'
+  (NA: Mem.nonempty_alloc m b lo hi = Some m'):
+  Mem.mem_contents m = Mem.mem_contents m'.
+Proof. unfold Mem.nonempty_alloc in NA. des_ifs. Qed.
+
+Lemma nonempty_alloc_access_neq
+  b b' lo hi m m'
+  (NEQ: b <> b')
+  (NA: Mem.nonempty_alloc m b lo hi = Some m'):
+  ((Mem.mem_access m) !! b') = ((Mem.mem_access m') !! b').
+Proof. unfold Mem.nonempty_alloc in NA. des_ifs. ss. des_ifs. rewrite PMap.gso; eauto. Qed.
+
+(* Lemma init_mem *)
+
+Definition mem_char_init (prog: program) (m: mem) : Prop :=
+  (forall b f, Genv.find_funct_ptr (Genv.globalenv prog) b = Some f -> Mem.perm m b 0 Cur Nonempty)
+/\ (forall b, m.(Mem.mem_concrete) ! b = None).
+
+Lemma init_mem_mem_char_init prog m
+    (INIT: Genv.init_mem prog = Some m):
+  mem_char_init prog m.
+Proof.
+  split; ii.
+  - eapply Genv.init_mem_characterization_2 in H; eauto. des; eauto.
+  - eapply Genv.init_mem_logical. eauto.
+Qed.
+
+Lemma init_mem_char_realloc_glob prog m b
+    (INIT: mem_char_init prog m):
+  exists m', realloc_global prog m b = Some m' /\ mem_char_init prog m'.
+Proof.
+  unfold realloc_global.
+  destruct (Genv.find_funct_ptr (Genv.globalenv prog) b) eqn:FUNC.
+  2:{ esplits; eauto. }
+  des_ifs.
+  2:{ esplits; eauto. }
+  assert (exists m', Mem.nonempty_alloc m b 0 (function_length f0) = Some m').
+  { r in INIT. inv INIT. exploit H; eauto. i. eapply Mem.perm_max in H1. unfold Mem.nonempty_alloc. des_ifs.
+    specialize (H0 b). unfold Mem.is_concrete. esplits; eauto. }
+  des. esplits; eauto. split; i.
+  - destruct (peq b b0); cycle 1.
+    + unfold Mem.perm in *. erewrite <- nonempty_alloc_access_neq; eauto.
+      r in INIT. des. eapply INIT. eauto.
+    + subst. specialize (function_length_pos f0). intros POS.
+      exploit nonempty_nonempty_alloc; eauto.
+      { lia. }
+      { inv INIT. specialize (H2 b0). unfold Mem.is_concrete. rewrite H2. eauto. }
+      instantiate (1:= Cur). i. des. exploit H1; eauto. lia.
+  - inv INIT. erewrite <-Mem.nonempty_alloc_concrete; eauto.
+Qed.
+
+Lemma init_mem_char_realloc_glob_aux prog m bdd
+    (INIT: mem_char_init prog m):
+  exists m', _realloc_globals prog m bdd m' /\ mem_char_init prog m'.
+Proof.
+  revert INIT. revert m. induction bdd using positive_Peano_ind; i.
+  { exploit init_mem_char_realloc_glob; eauto. instantiate (1:=1%positive). i. des.
+    exists m'. esplits; eauto. econs; eauto. }
+  exploit init_mem_char_realloc_glob; eauto. instantiate (1:= Pos.succ bdd). i. des.
+  exploit IHbdd; eauto. i. des. exists m'0. esplits; eauto. econs 2; eauto.
+  { eapply Pos.succ_not_1. }
+  replace (Pos.succ bdd - 1)%positive with bdd by lia. eauto.
+Qed.
+
+Lemma init_mem_char_realloc_globals prog m
+    (INIT: mem_char_init prog m):
+  exists m', realloc_globals prog m m' /\ mem_char_init prog m'.
+Proof.
+  unfold realloc_globals. eapply init_mem_char_realloc_glob_aux; eauto.
+Qed.
+
+Lemma realloc_global_same_nextblock
+    prog m m'
+    (RA: realloc_globals prog m m'):
+  Mem.nextblock m = Mem.nextblock m'.
+Proof.
+  r in RA. induction RA.
+  - unfold realloc_global in RA. des_ifs. eapply Mem.nonempty_alloc_nextblock; eauto.
+  - unfold realloc_global in RA. des_ifs. eapply Mem.nonempty_alloc_nextblock in RA; eauto.
+    rewrite RA. eauto.
+Qed.
+
+Lemma realloc_global_same_concrete
+    prog m m'
+    (RA: realloc_globals prog m m'):
+  Mem.mem_concrete m = Mem.mem_concrete m'.
+Proof.
+  r in RA. induction RA.
+  - unfold realloc_global in RA. des_ifs. eapply Mem.nonempty_alloc_concrete; eauto.
+  - unfold realloc_global in RA. des_ifs. eapply Mem.nonempty_alloc_concrete in RA; eauto.
+    rewrite RA. eauto.
+Qed.
+
+Lemma realloc_global_same_contents
+    prog m m'
+    (RA: realloc_globals prog m m'):
+  Mem.mem_contents m = Mem.mem_contents m'.
+Proof.
+  r in RA. induction RA.
+  - unfold realloc_global in RA. des_ifs. eapply nonempty_alloc_contents; eauto.
+  - unfold realloc_global in RA. des_ifs. eapply nonempty_alloc_contents in RA; eauto.
+    rewrite RA. eauto.
+Qed.
+
+
+Lemma init_mem_realloc_glob prog m
+  (INIT: Genv.init_mem prog = Some m):
+  exists m', realloc_globals prog m m' /\ concrete_extends m m'.
+Proof.
+  exploit init_mem_mem_char_init; eauto. intros INITCHAR.
+  exploit init_mem_char_realloc_globals; eauto. i. des. esplits; eauto.
+  econs.
+  - eapply realloc_global_same_nextblock; eauto.
+  - i.
+    destruct (classic (b <= Mem.nextblock m - 1)%positive).
+    2:{ unfold realloc_globals in H.
+        exploit nonempty_realloc_globals_not_range; try eapply H.
+        { instantiate (1:=b). remember (Mem.nextblock m). lia. }
+        i. unfold Mem.perm. rewrite <- H3. eauto. }
+    destruct (Genv.find_funct_ptr (Genv.globalenv prog) b) eqn:FUNC.
+    2:{ exploit nonempty_realloc_globals_not_func; eauto. i. 
+        unfold Mem.perm. rewrite <- H3. eauto. }
+    destruct f.
+    { exploit nonempty_realloc_globals; try eapply H.
+      { inv INITCHAR. eauto. }
+      { eauto. }
+      { eapply Genv.find_funct_ptr_not_fresh; eauto. }
+      instantiate (1:= k). i. des.
+      exploit Genv.init_mem_characterization_2; eauto. i. des.
+      exploit H6; try eapply H1; eauto. i. des; subst.
+      exploit H3; eauto.
+      specialize (function_length_pos f). i. lia. }
+    exploit nonempty_realloc_globals_external; eauto. i.
+    unfold Mem.perm. rewrite <- H3. eauto.
+  - i. eapply realloc_global_same_contents in H. rewrite H. eapply memval_intptr_refl.
+  - i. eapply realloc_global_same_concrete in H. rewrite <- H. eauto.
+Qed.
+  
+Lemma transf_initial_states2
+    prog st1 (INIT: Asm.initial_state prog st1):
+  exists st2, Lowerbound.initial_state_r prog st2 /\ match_states st1 st2.
+Proof.
+  exploit transf_initial_states1; eauto. i. des.
+  inv INIT; inv H. Eq.
+  assert (exists m', realloc_globals prog m1 m' /\ concrete_extends m1 m').
+  { eapply init_mem_realloc_glob; eauto. }
+  des. exists (Lowerbound.State rs1 m'). esplits.
+  { econs; eauto. econs; eauto. }
+  econs; eauto. subst rs0 rs1. eapply rs_binded_refl.
+Qed.
+
+Lemma transf_initial_capture1
+  prog S1 S2 S2'
+  (INITSRC: Asm.initial_state prog S1)
+  (INITTGT: Lowerbound.initial_state_r prog S2)
+  (MATCH: match_states S1 S2)
+  (CAPTGT: Lowerbound.glob_capture prog S2 S2'):
+  exists S1',
+    Asm.glob_capture prog S1 S1'
+    /\ match_states S1' S2'
+    /\ gm_improves (Asm.concrete_snapshot (Genv.globalenv prog) S1') (Lowerbound.concrete_snapshot (Genv.globalenv prog) S2').
+Proof.
+  inv CAPTGT. inv MATCH.
+  rewrite Genv.globalenv_public in CAPTURE.
+  assert (exists m0', Genv.capture_init_mem m0 (Genv.non_static_glob (Genv.globalenv prog) (prog_public prog)) m0'
+                 /\ concrete_extends m0' m').
+  { inv CAPTURE. remember (prog_public prog) as lst. clear Heqlst. clear - MCEXT CAP.
+    ginduction lst; ss; i.
+    - inv CAP. esplits; eauto. econs; eauto. econs; eauto.
+    - destruct (Genv.public_symbol (Genv.globalenv prog) a) eqn:PSYMB.
+      2:{ exploit IHlst; eauto. }
+      destruct (Genv.find_symbol (Genv.globalenv prog) a) eqn:PFIND.
+      2:{ exploit IHlst; eauto. }
+      i. inv CAP.
+      exploit capture_concrete_extends; eauto. i. des. exploit IHlst; eauto. i. des.
+      inv H. esplits; eauto. econs; eauto. econs; eauto. }
+  des. esplits.
+  - econs; eauto. rewrite Genv.globalenv_public. eauto.
+  - econs; eauto. inv CAPTURE.
+    ii. specialize (RCEXT r). eapply val_intptr_concrete_extends; try eapply RCEXT.
+    i. eapply Mem.capture_list_prevaddr; eauto.
+  - unfold concrete_snapshot, Lowerbound.concrete_snapshot. ii. des_ifs. ss.
+    eapply extended_concrete; eauto.
+Qed.
+
+Lemma capture_mem_char_all
+    prog m b addr m'
+    (CHAR: mem_char_all prog m)
+    (CAP: Mem.capture m b addr m'):
+  mem_char_all prog m'.
+Proof.
+  inv CHAR. split; ii.
+  - inv CAP. unfold Mem.perm. rewrite <- ACCESS. eauto.
+  - inv CAP. unfold Mem.perm. rewrite <- ACCESS. eauto.
+Qed.
+
+Lemma capture_list_mem_char_all
+    prog m bs addrs m'
+    (CHAR: mem_char_all prog m)
+    (CAP: Mem.capture_list m bs addrs m'):
+  mem_char_all prog m'.
+Proof.
+  ginduction bs; i.
+  { inv CAP. eauto. }
+  inv CAP. exploit capture_mem_char_all; eauto.
+Qed.
+
+Lemma glob_capture_char
+    p s s'
+    (CHAR: state_char p s)
+    (GCAP: Lowerbound.glob_capture p s s'):
+  state_char p s'.
+Proof.
+  inv GCAP. inv CAPTURE. unfold state_char in *. ss.
+  eapply capture_list_mem_char_all; eauto.
+Qed.
+
+Lemma glob_capture_c_char
+    p s s'
+    (CHAR: state_char p s)
+    (GCAP: Lowerbound.glob_capture_c p s s'):
+  state_char p s'.
+Proof.
+  inv GCAP. eapply state_char_preservation_cstep; try eapply CS.
+  eapply glob_capture_char; eauto.
+Qed.
+
+Theorem lowerbound_correct prog:
+  Simulation.backward_simulation (Asm.semantics prog) (Lowerbound.semantics prog).
+Proof.
+  econs. econs.
+  - apply lt_wf.
+  - i. ss. exploit transf_initial_states2; eauto.
+    i. des. esplits; eauto.
+  - ii. ss. exploit transf_initial_states2; eauto.
+    i. des. exploit initial_state_determ. eapply INITTGT. eapply H. i. subst.
+    inv TGTCAP.
+    exploit transf_initial_capture1.
+    { eapply INITSRC. }
+    { eapply INITTGT. }
+    { eauto. }
+    { eauto. }
+    i. des.
+    exploit cstep_simulation.
+    { eapply H2. }
+    { eapply CS. }
+    i.
+    exists 0%nat. exists st_init_src_. exists S1'. exists (concrete_snapshot (Genv.globalenv prog) S1').
+    esplits; eauto.
+    { ii. eapply H3 in H5. unfold Lowerbound.concrete_snapshot in *. des_ifs.
+      inv CS. inv CONC; inv CCONC. des; ss. rewrite <- H10. eauto. }
+    eapply match_states_xsim; eauto.
+    { ii. unfold gmtgt. ss. unfold Lowerbound.concrete_snapshot.
+      unfold Senv.public_symbol, Senv.find_symbol. ss.
+      rewrite H5, H6. split; eauto.
+      inv GC.
+      assert (In b (Genv.non_static_glob (Genv.globalenv prog) (Genv.genv_public (Genv.globalenv prog)))).
+      { assert (In id (Genv.genv_public (Genv.globalenv prog))).
+        { unfold Genv.public_symbol in H5. rewrite H6 in H5.
+          destruct in_dec in H5; ss. }
+        remember (Genv.genv_public (Genv.globalenv prog)) as l.
+        clear - H7 H6 H5. ginduction l; ss; i; des; subst; eauto.
+        - rewrite H6, H5. ss. eauto.
+        - exploit IHl; eauto. i. des_ifs. ss. right. eapply H. }
+      inv CAPTURE.
+      exploit Mem.capture_list_concrete; eauto. i. des. exists addr. inv CS.
+      inv CONC; inv CCONC. des. ss. rewrite <- H14; eauto. }
+    exploit initial_state_char; eauto. i. exploit glob_capture_char; eauto. i.
+    eapply state_char_preservation_cstep in CS; eauto.
+Qed.
+
+Theorem cstep_sanity_check
+    s
+    (CFAIL: forall s', ~ cstep s s'):
+  forall m', ~ memory_block_concretize (Lowerbound.state_mem s) m'.
+Proof.
+  ii. destruct s; ss.
+  assert (MCC: exists m'', memory_concretize_contents m' m'').
+  { eapply memory_concretize_contents_exists_aux; eauto.
+    inv H. des. i. eapply H4. unfold Mem.valid_block in *. rewrite H2. eauto. }
+  des.
+  assert (RCC: exists r', register_concretizer m'' r r').
+  { eapply register_concretizer_exists. i.
+    inv MCC. des. rewrite <- H2. inv H. des. eapply H8.
+    unfold Mem.valid_block in *. rewrite H6, H1. eauto. }
+  des.
+  eapply CFAIL. econs; eauto.
+Qed.
+
diff --git a/x86/Machregs.v b/x86/Machregs.v
index 6f3064b8..3bb33d36 100644
--- a/x86/Machregs.v
+++ b/x86/Machregs.v
@@ -328,6 +328,8 @@ Definition two_address_op (op: operation) : bool :=
   | Oshrluimm _ => true
   | Ororlimm _ => true
   | Oleal addr => false
+  | Opsub => true
+  (* | Opsubl => true (* TODO: right? *) *)
   | Onegf => true
   | Oabsf => true
   | Oaddf => true
diff --git a/x86/NeedOp.v b/x86/NeedOp.v
index 775a23db..1be2c3ef 100644
--- a/x86/NeedOp.v
+++ b/x86/NeedOp.v
@@ -15,6 +15,7 @@
 Require Import Coqlib.
 Require Import AST Integers Floats Values Memory Globalenvs.
 Require Import Op NeedDomain RTL.
+Require Import sflib IntPtrRel PointerOp.
 
 Definition op1 (nv: nval) := nv :: nil.
 Definition op2 (nv: nval) := nv :: nv :: nil.
@@ -52,6 +53,7 @@ Definition needs_of_addressing_64 (addr: addressing) (nv: nval): list nval :=
 Definition needs_of_addressing (addr: addressing) (nv: nval): list nval :=
   if Archi.ptr64 then needs_of_addressing_64 addr nv else needs_of_addressing_32 addr nv.
 
+(* psub need operation default => right? *) 
 Definition needs_of_operation (op: operation) (nv: nval): list nval :=
   match op with
   | Omove => op1 nv
@@ -112,6 +114,7 @@ Definition needs_of_operation (op: operation) (nv: nval): list nval :=
   | Oshrluimm _ => op1 (default nv)
   | Ororlimm _ => op1 (default nv)
   | Oleal addr => needs_of_addressing_64 addr nv
+  | Opsub => op2 (default nv)
   | Onegf | Oabsf => op1 (default nv)
   | Oaddf | Osubf | Omulf | Odivf => op2 (default nv)
   | Onegfs | Oabsfs => op1 (default nv)
@@ -238,6 +241,64 @@ Proof.
   simpl; auto with na.
 Qed.
 
+Hypothesis mappedblocks: forall b b' delta, Mem.valid_block m b -> inject_id b = Some (b', delta) -> Mem.valid_block m' b'.
+
+Hypothesis src_concrete_public: forall b1 b2 addr delta,
+    inject_id b1 = Some (b2, delta) ->
+    Maps.PTree.get b1 (Mem.mem_concrete m) = Some addr ->
+    Maps.PTree.get b2 (Mem.mem_concrete m') = Some (addr - delta).
+
+Lemma needs_of_condition_join_sound
+  cond args b args'
+  (PCOND: ptr_cond cond = true)
+  (ECOND: eval_condition_join cond args m = Some b)
+  (VALST: vagree_list args args' (needs_of_condition cond))
+  :
+  <<ECOND': eval_condition_join cond args' m' = Some b>>.
+Proof. eapply default_needs_of_condition_join_sound; eauto. destruct cond; ss. Qed.
+
+Lemma needs_of_condition_wrapper_sound
+  cond args b args'
+  (ECOND: eval_condition_wrapper cond args m = Some b)
+  (VALST: vagree_list args args' (needs_of_condition cond))
+  :
+  <<ECOND': eval_condition_wrapper cond args' m' = Some b>>.
+Proof.
+  destruct (ptr_cond cond) eqn:PCOND; cycle 1.
+  { rewrite eval_condition_no_ptr_op in *; eauto.
+    eapply needs_of_condition_sound; eauto. }
+  destruct cond; ss.
+  - eapply default_needs_of_condition_wrapper_sound; eauto.
+  - eapply default_needs_of_condition_wrapper_sound; eauto.
+Qed.
+
+Lemma needs_of_operation_wrapper_sound
+  op args v nv args'
+  (EVAL: eval_operation_wrapper ge (Vptr sp Ptrofs.zero) op args m = Some v)
+  (VAGREE: vagree_list args args' (needs_of_operation op nv))
+  (NOTNOTING: nv <> Nothing)
+  :
+  exists v',
+     <<EVAL': eval_operation_wrapper ge (Vptr sp Ptrofs.zero) op args' m' = Some v'>>
+  /\ <<VAGREE': vagree v v' nv>>.
+Proof.
+  destruct (ptr_op op) eqn:PTROP; cycle 1.
+  { rewrite eval_operation_no_ptr_op in *; eauto. eapply needs_of_operation_sound; eauto. }
+  unfold needs_of_operation in *; intros; destruct op; ss.
+  - eapply default_needs_of_operation_wrapper_sound; eauto.
+  - unfold eval_operation_wrapper in *. ss. rewrite PTROP in *. esplits; eauto.
+    destruct (eval_condition_join cond args m) as [b|] eqn:EC; simpl in EVAL.
+    erewrite needs_of_condition_join_sound by eauto.
+    inv EVAL; simpl. auto with na.
+    inv EVAL; auto with na.
+  - unfold eval_operation_wrapper in *. ss. rewrite PTROP in *.
+    des_ifs_safe. InvAgree. esplits; eauto.
+    destruct (eval_condition_join c l0 m) as [b|] eqn:EC.
+    erewrite needs_of_condition_join_sound by eauto.
+    apply select_sound; auto.
+    simpl; auto with na.
+Qed.
+
 Lemma operation_is_redundant_sound:
   forall op nv arg1 args v arg1' args',
   operation_is_redundant op nv = true ->
@@ -254,6 +315,19 @@ Proof.
 - apply orimm_redundant_sound; auto.
 Qed.
 
+Lemma operation_wrapper_is_redundant_sound
+  op nv arg1 args v arg1' args'
+  (OPREDUN: operation_is_redundant op nv = true)
+  (EVAL: eval_operation_wrapper ge (Vptr sp Ptrofs.zero) op (arg1 :: args) m = Some v)
+  (VALIST: vagree_list (arg1 :: args) (arg1' :: args') (needs_of_operation op nv))
+  :
+  <<VAGREE: vagree v arg1' nv>>.
+Proof.
+  assert (PTROP: ptr_op op = false).
+  { destruct op; ss. }
+  rewrite eval_operation_no_ptr_op in EVAL; eauto. eapply operation_is_redundant_sound; eauto.
+Qed.
+
 End SOUNDNESS.
 
 
diff --git a/x86/Op.v b/x86/Op.v
index 16d75426..71921177 100644
--- a/x86/Op.v
+++ b/x86/Op.v
@@ -32,6 +32,8 @@ Require Import Values.
 Require Import Memory.
 Require Import Globalenvs.
 Require Import Events.
+Require Import sflib.
+Require Import IntPtrRel.
 
 Set Implicit Arguments.
 
@@ -166,6 +168,9 @@ Inductive operation : Type :=
   | Ofloatoflong             (**r [rd = float64_of_signed_long(r1)] *)
   | Olongofsingle            (**r [rd = signed_long_of_float32(r1)] *)
   | Osingleoflong            (**r [rd = float32_of_signed_long(r1)] *)
+(*pointer substraction *)
+  | Opsub
+  (* | Opsubl   *)
 (*c Boolean tests: *)
   | Ocmp (cond: condition)  (**r [rd = 1] if condition holds, [rd = 0] otherwise. *)
   | Osel: condition -> typ -> operation.
@@ -410,9 +415,29 @@ Definition eval_operation
   | Osingleoflong, v1::nil => Val.singleoflong v1
   | Ocmp c, _ => Some(Val.of_optbool (eval_condition c vl m))
   | Osel c ty, v1::v2::vl => Some(Val.select (eval_condition c vl m) v1 v2 ty)
+  | Opsub, v1::v2::nil => if Archi.ptr64 then Some (Val.psubl v1 v2) else Some (Val.psub v1 v2)
+  (* | Opsubl, v1::v2::nil => Some (Val.psubl v1 v2) *)
   | _, _ => None
   end.
 
+(* Lemma eval_operation_join_psubl_join *)
+(*   F V (genv: Genv.t F V) sp v1 v2 m v (SF: Archi.ptr64 = true): *)
+(*   <<SAME: eval_operation_join genv sp Opsub [v1; v2] m = Some v <-> psubl_join m v1 v2 = v>>. *)
+(* Proof. *)
+(*   unfold eval_operation_join, psubl_join. rewrite SF. rewrite SF. simpl. split; i. *)
+(*   - inv H; eauto. *)
+(*   - subst. eauto. *)
+(* Qed. *)
+
+(* Lemma eval_operation_join_psub_join *)
+(*   F V (genv: Genv.t F V) sp v1 v2 m v (SF: Archi.ptr64 = false): *)
+(*   <<SAME: eval_operation_join genv sp Opsub [v1; v2] m = Some v <-> psub_join m v1 v2 = v>>. *)
+(* Proof. *)
+(*   unfold eval_operation_join, psub_join. simpl in *. rewrite SF. simpl. split; i. *)
+(*   - inv H; eauto. *)
+(*   - subst. eauto. *)
+(* Qed. *)
+
 Remark eval_addressing_Aglobal:
   forall (F V: Type) (genv: Genv.t F V) sp id ofs,
   eval_addressing genv sp (Aglobal id ofs) nil = Some (Genv.symbol_address genv id ofs).
@@ -581,6 +606,7 @@ Definition type_of_operation (op: operation) : list typ * typ :=
   | Olongofsingle => (Tsingle :: nil, Tlong)
   | Osingleoflong => (Tlong :: nil, Tsingle)
   | Ocmp c => (type_of_condition c, Tint)
+  | Opsub => (Tptr :: Tptr :: nil, Tptr)
   | Osel c ty => (ty :: ty :: type_of_condition c, ty)
   end.
 
@@ -653,7 +679,7 @@ Proof with (try exact I; try reflexivity).
   destruct v0...
   destruct v0...
   destruct v0...
-  unfold Val.sub, Val.has_type; destruct Archi.ptr64, v0, v1... destruct (eq_block b b0)...
+  unfold Val.sub, Val.has_type; destruct Archi.ptr64, v0, v1...
   destruct v0; destruct v1...
   destruct v0...
   destruct v0; destruct v1...
@@ -689,7 +715,7 @@ Proof with (try exact I; try reflexivity).
   destruct v0...
   destruct v0...
   unfold Val.addl, Val.has_type; destruct Archi.ptr64, v0...
-  unfold Val.subl, Val.has_type; destruct Archi.ptr64, v0, v1... destruct (eq_block b b0)...
+  unfold Val.subl, Val.has_type; destruct Archi.ptr64, v0, v1...
   destruct v0; destruct v1...
   destruct v0...
   destruct v0; destruct v1...
@@ -738,6 +764,8 @@ Proof with (try exact I; try reflexivity).
   destruct v0; simpl in H0; inv H0...
   destruct v0; simpl in H0; inv H0. destruct (Float32.to_long f); inv H2...
   destruct v0; simpl in H0; inv H0...
+  unfold Val.psubl, Val.has_type; destruct v0, v1... rewrite Heqb. destruct (eq_block b b0)...
+  unfold Val.psub, Val.has_type; destruct v0, v1... (* rewrite Heqb. destruct (eq_block b b0)... *)
   destruct (eval_condition cond vl m); simpl... destruct b...
   unfold Val.select. destruct (eval_condition c vl m). apply Val.normalize_type. exact I.
 Qed.
@@ -972,6 +1000,7 @@ Definition condition_depends_on_memory (c: condition) : bool :=
   | _ => false
   end.
 
+(* depends on logical memory *)
 Definition op_depends_on_memory (op: operation) : bool :=
   match op with
   | Ocmp c => condition_depends_on_memory c
@@ -1310,6 +1339,8 @@ Proof.
   inv H4; simpl in H1; inv H1. simpl. destruct (Float32.to_long f0); simpl in H2; inv H2.
   exists (Vlong i); auto.
   inv H4; simpl in H1; inv H1. simpl. TrivialExists.
+  apply Val.psubl_inject; auto.
+  apply Val.psub_inject; auto.
   subst v1. destruct (eval_condition cond vl1 m1) eqn:?.
   exploit eval_condition_inj; eauto. intros EQ; rewrite EQ.
   destruct b; simpl; constructor.
@@ -1518,4 +1549,4 @@ Definition builtin_arg_ok
   match ba with
   | (BA _ | BA_splitlong (BA _) (BA _)) => true
   | _ => builtin_arg_ok_1 ba c
-  end.  
+  end.
diff --git a/x86/PointerOp.v b/x86/PointerOp.v
new file mode 100644
index 00000000..518ca540
--- /dev/null
+++ b/x86/PointerOp.v
@@ -0,0 +1,817 @@
+Require Import BoolEqual.
+Require Import Coqlib.
+Require Import AST.
+Require Import Integers.
+Require Import Floats.
+Require Import Values.
+Require Import Maps.
+Require Import Memory.
+Require Import Globalenvs.
+Require Import Events.
+(* Require Import Cminor. *)
+Require Import Op.
+Require Import IntPtrRel.
+Require Import sflib Classical.
+
+Set Implicit Arguments.
+
+(* unary cmp *)
+Definition ptr_uncond (c: condition) : bool :=
+  match c with
+  | Ccompuimm _ _ => if negb Archi.ptr64 then true else false
+  | Ccompluimm _ _ => if Archi.ptr64 then true else false
+  | _ => false
+  end.
+
+Definition ptr_bincond (c: condition) : bool :=
+  match c with
+  | Ccompu _ => if negb Archi.ptr64 then true else false
+  | Ccomplu _ => if Archi.ptr64 then true else false
+  | _ => false
+  end.
+      
+Definition ptr_cond (c: condition) : bool :=
+  orb (ptr_uncond c) (ptr_bincond c).
+
+Definition ptr_binop (op: operation) : bool :=
+  match op with
+  | Ocmp c => ptr_cond c
+  | Opsub =>  true
+  | _ => false
+  end.
+
+Definition ptr_op (op: operation) : bool :=
+  match op with
+  | Osel c _ => ptr_cond c
+  | _ => ptr_binop op
+  end.
+
+(* Osel needs this *)
+Definition eval_condition_join (c: condition) (vl: list val) (m: mem) : option bool :=
+  match c with
+  | Ccompuimm cmp n => match vl with
+                      | [] => None
+                      | [v] => cmpu_join_common m cmp v (Vint n) 
+                      | _ => None
+                      end
+  | Ccompluimm cmp n => match vl with
+                       | [] => None
+                       | [v] => cmplu_join_common m cmp v (Vlong n) 
+                       | _ => None
+                       end
+  | Ccomplu cmp => match vl with
+                  | [] => None
+                  | [v] => None
+                  | [v1; v2] => cmplu_join_common m cmp v1 v2
+                  | _ => None
+                  end
+  | Ccompu cmp => match vl with
+                 | [] => None
+                 | [v] => None
+                 | [v1; v2] => cmpu_join_common m cmp v1 v2
+                 | _ => None
+                 end
+  | _ => None
+  end.
+
+(* TODO: check Archi.ptr64 first *)
+Definition cmplu_bool_join_asm (m: mem) (cmp: comparison) (v1 v2: val) : option bool :=
+  cmplu_join_common m cmp v1 v2.
+
+Definition cmplu_join_asm (m: mem) (cmp: comparison) (v1 v2: val) : option val :=
+  option_map Val.of_bool (cmplu_bool_join_asm m cmp v1 v2).
+
+Lemma cmplu_join_same_eval_condition_join c v1 v2 m :
+  cmplu_bool_join_asm m c v1 v2 = eval_condition_join (Ccomplu c) [v1; v2] m.
+Proof. ss. Qed.
+
+Lemma cmplu_join_same_eval_condition_join_imm c v n m:
+  cmplu_bool_join_asm m c v (Vlong n) = eval_condition_join (Ccompluimm c n) [v] m.
+Proof. ss. Qed.
+
+Definition eval_condition_wrapper (c: condition) (vl: list val) (m: mem) : option bool :=
+  if ptr_cond c then eval_condition_join c vl m else eval_condition c vl m.
+
+Definition eval_operation_join (F V: Type) (genv: Genv.t F V) (sp: val)
+  (op: operation) (vl: list val) (m: mem): option val :=
+  match op with
+  | Ocmp c => Some (Val.of_optbool (eval_condition_join c vl m))
+  | Opsub => match vl with
+            | [] => None
+            | [v] => None
+            | [v1; v2] => if Archi.ptr64
+                         then Some (psubl_join_common m v1 v2)
+                         else Some (psub_join_common m v1 v2)
+            | _ => None
+            end
+  | _ => None
+  end.
+
+Definition psub_join_asm (m: mem) (v1 v2: val) : val :=
+  if Archi.ptr64
+  then psubl_join_common m v1 v2
+  else psub_join_common m v1 v2.
+
+Definition eval_operation_wrapper (F V: Type) (genv: Genv.t F V) (sp: val)
+  (op: operation) (vl: list val) (m: mem): option val :=
+  if ptr_op op
+  then
+    match op with
+    | Osel c ty => match vl with
+                  | [] => None
+                  | [v1] => None
+                  | v1 :: v2 :: vl0 => Some (Val.select (eval_condition_join c vl0 m) v1 v2 ty)
+                  end
+    | _ => eval_operation_join genv sp op vl m
+    end
+  else
+    eval_operation genv sp op vl m.
+
+
+Lemma  eval_condition_no_ptr_op c vl m
+    (NOPTR: ptr_cond c = false) :
+  <<SAME: eval_condition_wrapper c vl m = eval_condition c vl m>>.
+Proof. unfold eval_condition_wrapper. rewrite NOPTR. eauto. Qed.
+
+Lemma eval_operation_no_ptr_op F V (genv: Genv.t F V) sp op vl m
+    (NOPTR: ptr_op op = false) :
+  <<SAME: eval_operation_wrapper genv sp op vl m = eval_operation genv sp op vl m>>.
+Proof. unfold eval_operation_wrapper. rewrite NOPTR. eauto. Qed.
+
+Section GENV_TRANSF.
+
+Variable F1 F2 V1 V2: Type.
+Variable ge1: Genv.t F1 V1.
+Variable ge2: Genv.t F2 V2.
+
+Hypothesis agree_on_symbols:
+  forall (s: ident), Genv.find_symbol ge2 s = Genv.find_symbol ge1 s.
+
+Lemma eval_operation_wrapper_preserved:
+  forall sp op vl m,
+  eval_operation_wrapper ge2 sp op vl m = eval_operation_wrapper ge1 sp op vl m.
+Proof. intros. unfold eval_operation_wrapper. erewrite eval_operation_preserved; eauto. Qed.
+
+End GENV_TRANSF.
+
+Lemma eval_condition_no_angelic
+    cond m vl bp bi
+    (PTRCOND: ptr_bincond cond = true)
+    (COND1: eval_condition cond (map (to_ptr_val m) vl) m = Some bp)
+    (COND2: eval_condition cond (map (to_int_val m) vl) m = Some bi) :
+  <<NOANGELIC: bp = bi>>.
+Proof.
+  destruct (Archi.ptr64) eqn:BIT.
+  - destruct cond; simpl in *; try rewrite BIT in *; simpl in *; inv PTRCOND.
+    do 2 (destruct vl; [ss|]). destruct vl; [|ss]. simpl in *.
+    eapply cmplu_no_angelic; eauto.
+  - destruct cond; simpl in *; try rewrite BIT in *; simpl in *; inv PTRCOND.
+    do 2 (destruct vl; [ss|]). destruct vl; [|ss]. simpl in *.
+    eapply cmpu_no_angelic; eauto.
+Qed.
+
+Lemma cmp_wrapper_eval_condition_join
+    F V (genv: Genv.t F V) sp c vl m
+    (PTRCOND: ptr_cond c = true) :
+  <<SAME: eval_operation_wrapper genv sp (Ocmp c) vl m = Some (Val.of_optbool (eval_condition_join c vl m))>>.
+Proof.
+  unfold eval_operation_wrapper. simpl. rewrite PTRCOND. eauto.
+Qed.
+
+Definition not_cmp (op: operation) : bool :=
+  match op with
+  | Ocmp _ => false
+  | _ => true
+  end.
+
+Lemma eval_operation_join_no_angelic
+    F V (genv: Genv.t F V) sp op vl m vp vi
+    (PTROP: ptr_binop op = true)
+    (NOCMP: not_cmp op = true)
+    (EVAL1: eval_operation genv sp op (map (to_ptr_val m) vl) m = Some vp)
+    (EVAL2: eval_operation genv sp op (map (to_int_val m) vl) m = Some vi) :
+  <<NOANGELIC: vp = Vundef \/ vi = Vundef \/ vi = vp>>.
+Proof.
+  destruct (Archi.ptr64) eqn:BIT.
+  - destruct op; simpl in *; try rewrite BIT in *; inv PTROP; [|clarify].
+    do 2 (destruct vl; [ss|]). destruct vl; [|ss]. simpl in *.
+    inv EVAL1; inv EVAL2. eapply psubl_wrapper_no_angelic; eauto.
+  - destruct op; simpl in *; try rewrite BIT in *; inv PTROP; [|clarify].
+    do 2 (destruct vl; [ss|]). destruct vl; [|ss]. simpl in *.
+    inv EVAL1; inv EVAL2. eapply psub_wrapper_no_angelic; eauto.
+Qed.
+
+Lemma negate_cmpu_join c v1 v2 m:
+  <<SAME: cmpu_join m (negate_comparison c) v1 v2 = option_map negb (cmpu_join m c v1 v2)>>.
+Proof.
+  unfold cmpu_join. do 2 rewrite Val.negate_cmpu_bool. unfold bool_optjoin, opt_join.
+  des_ifs. simpl in *. inv Heq; inv Heq0. destruct b1; destruct b2; ss.
+Qed.
+
+Lemma negate_cmplu_join c v1 v2 m:
+  <<SAME: cmplu_join m (negate_comparison c) v1 v2 = option_map negb (cmplu_join m c v1 v2)>>.
+Proof.
+  unfold cmplu_join. do 2 rewrite Val.negate_cmplu_bool. unfold bool_optjoin, opt_join.
+  des_ifs. simpl in *. inv Heq; inv Heq0. destruct b1; destruct b2; ss.
+Qed.
+
+Lemma eval_negate_condition_join cond vl m (PTRCOND: ptr_cond cond = true) :
+  <<SAME: eval_condition_join (negate_condition cond) vl m = option_map negb (eval_condition_join cond vl m)>>.
+Proof.
+  destruct Archi.ptr64 eqn:SF.
+  - unfold eval_condition_join, ptr_cond, cmplu_join_common in *.
+    destruct cond; simpl in *; try rewrite SF in *; inv PTRCOND.
+    + repeat (destruct vl; auto). simpl. repeat rewrite Val.negate_cmplu_bool;
+      unfold bool_optjoin, opt_join; des_ifs; simpl in *; clarify;
+        rewrite negate_cmplu_join; eauto.
+    + repeat (destruct vl; auto). rewrite Val.negate_cmplu_bool; eauto.
+      rewrite negate_cmplu_join; eauto. des_ifs.
+  - unfold eval_condition_join, ptr_cond, cmpu_join_common in *.
+    destruct cond; simpl in *; try rewrite SF in *; inv PTRCOND.
+    + repeat (destruct vl; auto). simpl. repeat rewrite Val.negate_cmpu_bool;
+      unfold bool_optjoin, opt_join; des_ifs; simpl in *; clarify;
+        rewrite negate_cmpu_join; eauto.
+    + repeat (destruct vl; auto). rewrite Val.negate_cmpu_bool; eauto.
+      rewrite negate_cmpu_join; eauto. des_ifs.
+Qed.
+
+Lemma ptr_binop_not_shift_stack
+    F V op (genv: Genv.t F V) sp1 vl m
+    (PTROP: ptr_op op = true) delta :
+  eval_operation genv (Vptr sp1 Ptrofs.zero) op vl m =
+  eval_operation genv (Vptr sp1 Ptrofs.zero) (shift_stack_operation delta op) vl m.
+Proof. unfold shift_stack_operation; ss. des_ifs. Qed.
+
+Lemma ptr_binop_operation_to_ptr_return
+    F V (genv: Genv.t F V) sp op vl m v
+    (PTROP: ptr_binop op = true)
+    (EVAL: eval_operation genv sp op vl m = Some v) :
+  is_only_int v = true.
+Proof.
+  destruct op; ss.
+  - des_ifs. destruct v0; destruct v1; ss; clarify; eauto; ss; unfold Val.psubl; des_ifs; eauto.
+  - des_ifs. unfold eval_condition. des_ifs; ss; eauto. unfold Val.of_optbool. des_ifs; eauto.
+    unfold Val.of_optbool. des_ifs; eauto.
+Qed.
+
+Lemma type_of_operation_wrapper_sound
+    F V (genv: Genv.t F V) op vl sp v m
+    (NOTMV: op <> Omove)
+    (EVAL: eval_operation_wrapper genv sp op vl m = Some v) :
+  <<SOUND: Val.has_type v (snd (type_of_operation op))>>.
+Proof with (try exact I; try reflexivity).
+  destruct (ptr_op op) eqn:PTROP.
+  2:{ rewrite eval_operation_no_ptr_op in EVAL; eauto.
+      eapply type_of_operation_sound; eauto. }
+  destruct op; ss.
+  - unfold eval_operation_wrapper, Tptr in *. simpl in *.
+    destruct vl; [clarify|]. destruct vl; [clarify|]. destruct vl; [|clarify].
+    destruct Archi.ptr64 eqn:SF.
+  + destruct v0, v1; simpl in *; inv EVAL; simpl; auto.
+  * rewrite SF. simpl; eauto.
+  * unfold psubl_join.
+    destruct (classic (Val.psubl (to_ptr_val m (Vlong i)) (to_ptr_val m (Vptr b i0)) = Vundef)).
+    { destruct (classic (Val.psubl (to_int_val m (Vlong i)) (to_int_val m (Vptr b i0)) = Vundef)).
+      { rewrite H, H0. simpl. eauto. }
+      rewrite val_join_angelic_vi; try eapply H0.
+      { unfold Val.psubl. des_ifs; eauto. }
+      { unfold Val.psubl. des_ifs; eauto. }
+      { eapply psubl_wrapper_no_angelic; eauto. } }
+    rewrite val_join_angelic_vp; try eapply H.
+    { unfold Val.psubl. des_ifs; eauto. }
+    { unfold Val.psubl. des_ifs; eauto. }
+    { eapply psubl_wrapper_no_angelic; eauto. }
+  * unfold psubl_join.
+    destruct (classic (Val.psubl (to_ptr_val m (Vptr b i)) (to_ptr_val m (Vlong i0)) = Vundef)).
+    { destruct (classic (Val.psubl (to_int_val m (Vptr b i)) (to_int_val m (Vlong i0)) = Vundef)).
+      { rewrite H, H0. simpl. eauto. }
+      rewrite val_join_angelic_vi; try eapply H0.
+      { unfold Val.psubl. des_ifs; eauto. }
+      { unfold Val.psubl. des_ifs; eauto. }
+      { eapply psubl_wrapper_no_angelic; eauto. } }
+    rewrite val_join_angelic_vp; try eapply H.
+    { unfold Val.psubl. des_ifs; eauto. }
+    { unfold Val.psubl. des_ifs; eauto. }
+    { eapply psubl_wrapper_no_angelic; eauto. }
+  * rewrite SF. simpl. destruct (eq_block b b0); simpl; eauto.
+  + destruct v0, v1; simpl in *; inv EVAL; simpl; auto.
+  * rewrite SF. simpl; eauto.
+  * unfold psub_join.
+    destruct (classic (Val.psub (to_ptr_val m (Vint i)) (to_ptr_val m (Vptr b i0)) = Vundef)).
+    { destruct (classic (Val.psub (to_int_val m (Vint i)) (to_int_val m (Vptr b i0)) = Vundef)).
+      { rewrite H, H0. simpl. eauto. }
+      rewrite val_join_angelic_vi; try eapply H0.
+      { unfold Val.psubl. des_ifs; eauto. }
+      { unfold Val.psubl. des_ifs; eauto. }
+      { eapply psub_wrapper_no_angelic; eauto. } }
+    rewrite val_join_angelic_vp; try eapply H.
+    { unfold Val.psub. des_ifs; eauto. }
+    { unfold Val.psub. des_ifs; eauto. }
+    { eapply psub_wrapper_no_angelic; eauto. }
+  * unfold psub_join.
+    destruct (classic (Val.psub (to_ptr_val m (Vptr b i)) (to_ptr_val m (Vint i0)) = Vundef)).
+    { destruct (classic (Val.psub (to_int_val m (Vptr b i)) (to_int_val m (Vint i0)) = Vundef)).
+      { rewrite H, H0. simpl. eauto. }
+      rewrite val_join_angelic_vi; try eapply H0.
+      { unfold Val.psub. des_ifs; eauto. }
+      { unfold Val.psub. des_ifs; eauto. }
+      { eapply psub_wrapper_no_angelic; eauto. } }
+    rewrite val_join_angelic_vp; try eapply H.
+    { unfold Val.psub. des_ifs; eauto. }
+    { unfold Val.psub. des_ifs; eauto. }
+    { eapply psub_wrapper_no_angelic; eauto. }
+  * rewrite SF. simpl. destruct (eq_block b b0); simpl; eauto.
+  - unfold eval_operation_wrapper in EVAL. simpl in *.
+    unfold Val.of_optbool in EVAL. des_ifs; ss.
+  - unfold eval_operation_wrapper in EVAL; ss. 
+    unfold Val.select in *. des_ifs; ss; eapply Val.normalize_type.
+Qed.
+
+Lemma negate_ptr_cond c:
+  <<NEGC: ptr_cond c = ptr_cond (negate_condition c)>>.
+Proof. destruct c; ss. Qed.
+
+Lemma eval_negate_condition_wrapper cond vl m:
+  <<NEGC: eval_condition_wrapper (negate_condition cond) vl m = option_map negb (eval_condition_wrapper cond vl m)>>.
+Proof.
+  destruct (ptr_cond cond) eqn:PCOND.
+  2:{ repeat (erewrite eval_condition_no_ptr_op; eauto).
+      - eapply eval_negate_condition.
+      - rewrite <- negate_ptr_cond; eauto. }
+  unfold eval_condition_wrapper. rewrite PCOND.
+  rewrite negate_ptr_cond in PCOND. rewrite PCOND. 
+  eapply eval_negate_condition_join. rewrite negate_ptr_cond. eauto.
+Qed.
+
+Lemma condition_wrapper_depends_on_memory_correct args m1 m2 c
+    (INDEP: condition_depends_on_memory c = false) :
+  <<SAME: eval_condition_wrapper c args m1 = eval_condition_wrapper c args m2>>.
+Proof. destruct c; ss. Qed.
+
+Lemma same_concrete_same_psubl_l m1 m2 n b ofs
+    (SAMECONC: Mem.mem_concrete m1 = Mem.mem_concrete m2) :
+  <<SAME: psubl_join m1 (Vlong n) (Vptr b ofs) = psubl_join m2 (Vlong n) (Vptr b ofs)>>.
+Proof.
+  destruct ((Mem.mem_concrete m1)!b) eqn:CONC1.
+- erewrite psubl_always_captured1'; eauto.
+  rewrite SAMECONC in CONC1. erewrite psubl_always_captured1'; eauto.
+- rewrite psubl_always_captured1_undef; eauto.
+  rewrite SAMECONC in CONC1. rewrite psubl_always_captured1_undef; eauto.
+Qed.
+
+Lemma same_concrete_same_psubl_r m1 m2 n b ofs
+    (SAMECONC: Mem.mem_concrete m1 = Mem.mem_concrete m2) :
+  <<SAME: psubl_join m1 (Vptr b ofs) (Vlong n) = psubl_join m2 (Vptr b ofs) (Vlong n)>>.
+Proof.
+  destruct ((Mem.mem_concrete m1)!b) eqn:CONC1.
+- erewrite psubl_always_captured2'; eauto.
+  rewrite SAMECONC in CONC1. erewrite psubl_always_captured2'; eauto.
+- rewrite psubl_always_captured2_undef; eauto.
+  rewrite SAMECONC in CONC1. rewrite psubl_always_captured2_undef; eauto.
+Qed.
+  
+Lemma op_wrapper_depends_on_memory_correct
+    (F V: Type) (ge: Genv.t F V) sp op args m1 m2
+    (CONC: Mem.mem_concrete m1 = Mem.mem_concrete m2)
+    (INDEP: op_depends_on_memory op = false) :
+  <<SAME: eval_operation_wrapper ge sp op args m1 = eval_operation_wrapper ge sp op args m2>>.
+Proof.
+  destruct (ptr_op op) eqn:PTROP; cycle 1.
+  { do 2 (rewrite eval_operation_no_ptr_op; eauto). 
+    eapply op_depends_on_memory_correct; eauto. }
+  destruct op; ss.
+  - unfold eval_operation_wrapper. ss. unfold psubl_join_common, psub_join_common. des_ifs_safe.
+    des_ifs; eauto.
+    + erewrite same_concrete_same_psubl_l; eauto.
+    + erewrite same_concrete_same_psubl_r; eauto.
+  - destruct cond; ss.
+  - destruct c; ss.
+Qed.
+
+Definition op_depends_on_both_memory (op: operation) : bool :=
+  match op with
+  | Opsub => true
+  | _ => op_depends_on_memory op
+  end.
+
+Lemma op_wrapper_depends_on_both_memory_correct
+    (F V: Type) (ge: Genv.t F V) sp op args m1 m2
+    (INDEP: op_depends_on_both_memory op = false) :
+  <<SAME: eval_operation_wrapper ge sp op args m1 = eval_operation_wrapper ge sp op args m2>>.
+Proof.
+  destruct (ptr_op op) eqn:PTROP; cycle 1.
+  { do 2 (rewrite eval_operation_no_ptr_op; eauto). 
+    eapply op_depends_on_memory_correct; eauto.
+    destruct op; ss. }
+  destruct op; ss; [destruct cond; ss| destruct c; ss].
+Qed.
+
+Section EVAL_COMPAT.
+
+Variable F1 F2 V1 V2: Type.
+Variable ge1: Genv.t F1 V1.
+Variable ge2: Genv.t F2 V2.
+Variable f: meminj.
+
+Variable m1: mem.
+Variable m2: mem.
+
+Hypothesis mi_inj_perm: forall b1 b2 delta ofs k p,
+    f b1 = Some (b2, delta) ->
+    Mem.perm m1 b1 ofs k p -> Mem.perm m2 b2 (ofs + delta) k p.
+
+Hypothesis valid_pointer_inj:
+  forall b1 ofs b2 delta,
+  f b1 = Some(b2, delta) ->
+  Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->
+  Mem.valid_pointer m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.
+
+Hypothesis weak_valid_pointer_inj:
+  forall b1 ofs b2 delta,
+  f b1 = Some(b2, delta) ->
+  Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->
+  Mem.weak_valid_pointer m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.
+
+Hypothesis weak_valid_pointer_no_overflow:
+  forall b1 ofs b2 delta,
+  f b1 = Some(b2, delta) ->
+  Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->
+  0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <= Ptrofs.max_unsigned.
+
+Hypothesis valid_different_pointers_inj:
+  forall b1 ofs1 b2 ofs2 b1' delta1 b2' delta2,
+  b1 <> b2 ->
+  Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->
+  Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->
+  f b1 = Some (b1', delta1) ->
+  f b2 = Some (b2', delta2) ->
+  b1' <> b2' \/
+  Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <> Ptrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).
+
+Hypothesis src_concrete_private: forall b, f b = None -> (Mem.mem_concrete m1) ! b = None.
+
+Hypothesis mappedblocks: forall b b' delta, Mem.valid_block m1 b -> f b = Some (b', delta) -> Mem.valid_block m2 b'.
+
+Hypothesis src_concrete_public: forall b1 b2 addr delta,
+    f b1 = Some (b2, delta) ->
+    (Mem.mem_concrete m1) ! b1 = Some addr ->
+    (Mem.mem_concrete m2) ! b2 = Some (addr - delta).
+
+Hypothesis representable: forall b b' delta ofs,
+    f b = Some (b', delta) ->
+    Mem.perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \/
+    Mem.perm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->
+    delta >= 0 /\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.
+
+Lemma eval_condition_join_inj c vl1 vl2 b
+    (PTRCOND: ptr_cond c = true)
+    (VINJ: Val.inject_list f vl1 vl2)
+    (EVAL: eval_condition_join c vl1 m1 = Some b) :
+  <<EVAL': eval_condition_join c vl2 m2 = Some b>>.
+Proof.
+  unfold ptr_cond, ptr_uncond, ptr_bincond in PTRCOND.
+  destruct Archi.ptr64 eqn:SF; simpl in *; destruct c; simpl in PTRCOND; inv PTRCOND; ss.
+  (* cmplu *)
+  - do 2 (destruct VINJ; [ss|]). destruct VINJ; [|ss]. dup H. dup H0. unfold eval_condition_join, cmplu_join_common.
+    destruct v; destruct v0; inv H; inv H0; simpl in EVAL;
+      try rewrite SF in *; simpl in EVAL; inv EVAL; eauto.
+    + rewrite H0. destruct (Int64.eq i Int64.zero) eqn:NULL.
+      { eapply Val.cmplu_bool_inject; eauto. simpl. rewrite SF, NULL. eauto. }
+      { exploit cmplu_join_inj; try eapply H0; eauto. }
+    + rewrite H0. destruct (Int64.eq i0 Int64.zero) eqn:NULL.
+      { eapply Val.cmplu_bool_inject; eauto. simpl. rewrite SF, NULL. eauto. }
+      { exploit cmplu_join_inj; try eapply H0; eauto. }
+    + rewrite H0. eapply Val.cmplu_bool_inject; eauto.
+  (* cmpluimm *)
+  - destruct VINJ; [ss|]. destruct VINJ; [|ss]. dup H. unfold eval_condition_join, cmplu_join_common.
+    destruct v; inv H; simpl in EVAL;
+      try rewrite SF in *; simpl in EVAL; inv EVAL; eauto.
+    rewrite H1. destruct (Int64.eq n Int64.zero) eqn:NULL.
+    { eapply Val.cmplu_bool_inject with (v2:=Vlong n); eauto. simpl. rewrite SF, NULL. eauto. }
+    { exploit cmplu_join_inj; try eapply H1; eauto. }
+Qed.
+
+Lemma eval_operation_join_inj op sp1 vl1 sp2 vl2 v1
+    (PTRBINOP: ptr_binop op = true)
+    (VINJ: Val.inject_list f vl1 vl2)
+    (SPINJ: Val.inject f sp1 sp2)
+    (EVAL: eval_operation_join ge1 sp1 op vl1 m1 = Some v1) :
+  exists v2,
+     <<EVAL': eval_operation_join ge2 sp2 op vl2 m2 = Some v2>>
+   /\ <<VINJ': Val.inject f v1 v2>>.
+Proof.
+  unfold ptr_binop in PTRBINOP. destruct op; ss.
+  (* psub *)
+  - do 2 (destruct VINJ; [ss|]). destruct VINJ; [|ss]. dup H. dup H0.
+    destruct Archi.ptr64 eqn:SF; simpl in *; ss.
+    destruct v; destruct v0; inv H; inv H0; simpl in EVAL;
+      try rewrite SF in *; simpl in EVAL; inv EVAL; eauto; try (by (des_ifs; esplits; eauto)); ss.
+    { exploit Val.psubl_inject. eapply H1. eapply H2. i. esplits; eauto. }
+    { exploit psubl_join_common_inj. eauto. eauto. eauto. eauto. eauto.
+      eapply H1. eapply H2. eauto. i. des. subst. esplits; eauto. }
+    { exploit psubl_join_common_inj. eauto. eauto. eauto. eauto. eauto.
+      eapply H1. eapply H2. eauto. i. des. subst. esplits; eauto. }
+    { exploit Val.psubl_inject. eapply H1. eapply H2. i. esplits; eauto. }
+  - destruct (eval_condition_join cond vl1 m1) eqn:COND.
+    2:{ ss. clarify. esplits; eauto. }
+    exploit eval_condition_join_inj; eauto. i. rewrite H. inv EVAL. esplits; eauto.
+    destruct b; ss; econs.
+Qed.
+
+Lemma eval_operation_wrapper_inj op sp1 vl1 sp2 vl2 v1
+    (GLOB: forall id ofs,
+           In id (globals_operation op) ->
+           Val.inject f (Genv.symbol_address ge1 id ofs) (Genv.symbol_address ge2 id ofs))
+    (VINJ: Val.inject_list f vl1 vl2)
+    (SPINJ: Val.inject f sp1 sp2)
+    (EVAL: eval_operation_wrapper ge1 sp1 op vl1 m1 = Some v1) :
+  exists v2, <<EVAL': eval_operation_wrapper ge2 sp2 op vl2 m2 = Some v2>>
+     /\ <<VINJ': Val.inject f v1 v2>>.
+Proof.
+  destruct (ptr_op op) eqn:PTROP; cycle 1.
+  { rewrite eval_operation_no_ptr_op in *; eauto.
+    eapply eval_operation_inj; eauto. }
+  destruct (ptr_binop op) eqn:PTRBINOP; cycle 1.
+  { unfold eval_operation_wrapper in *. destruct op; ss; clarify.
+    destruct VINJ; ss. destruct VINJ; ss.
+    destruct (eval_condition_join c vl m1) eqn:EVAL1; cycle 1.
+    { clarify. esplits; eauto. }
+    exploit eval_condition_join_inj; eauto. i. des.
+    clarify. rewrite H1. ss. esplits; eauto.
+    eapply Val.normalize_inject. des_ifs; ss. }
+  unfold eval_operation_wrapper in *. rewrite PTROP in EVAL.
+  assert (EVAL1: eval_operation_join ge1 sp1 op vl1 m1 = Some v1) by (destruct op; ss).
+  exploit eval_operation_join_inj; try eapply EVAL1; eauto. i. des. rewrite EVAL'.
+  destruct op; ss; esplits; eauto. des_ifs.
+Qed.
+
+Lemma eval_condition_wrapper_inj c vl1 vl2 b
+    (VINJ: Val.inject_list f vl1 vl2)
+    (EVAL: eval_condition_wrapper c vl1 m1 = Some b) :
+  <<EVAL': eval_condition_wrapper c vl2 m2 = Some b>>.
+Proof.
+  destruct (ptr_cond c) eqn:COND.
+  - unfold eval_condition_wrapper in *. des_ifs. eapply eval_condition_join_inj; eauto.
+  - unfold eval_condition_wrapper in *. des_ifs. eapply eval_condition_inj; eauto.
+Qed.
+
+End EVAL_COMPAT.
+
+Section EVAL_WRAPPER_LESSDEF.
+
+Variable F V: Type.
+Variable genv: Genv.t F V.
+  
+Lemma eval_condition_join_lessdef c vl1 vl2 m1 m2 b
+    (PTRBINOP: ptr_cond c = true)
+    (LESS: Val.lessdef_list vl1 vl2)
+    (MEXT: Mem.extends m1 m2)
+    (EVAL: eval_condition_join c vl1 m1 = Some b) :
+  <<EVAL2: eval_condition_join c vl2 m2 = Some b>>.
+Proof.
+  assert (SAMEVLD: forall b ofs, Mem.valid_pointer m1 b ofs = true -> Mem.valid_pointer m2 b ofs = true).
+  { ii. eapply Mem.valid_pointer_extends; eauto. }
+  assert (SAMEWVLD: forall b ofs, Mem.weak_valid_pointer m1 b ofs = true -> Mem.weak_valid_pointer m2 b ofs = true).
+  { ii. eapply Mem.weak_valid_pointer_extends; eauto. }
+  unfold ptr_cond, ptr_uncond, ptr_bincond in PTRBINOP.
+  destruct Archi.ptr64 eqn:SF; simpl in *; destruct c; simpl in PTRBINOP; inv PTRBINOP.
+  (* cmplu *)
+  - do 2 (destruct LESS; [ss|]). destruct LESS; [|ss].
+    dup H. dup H0. unfold eval_condition_join, cmplu_join_common.
+    destruct v1; destruct v0; inv H; inv H0; simpl in EVAL;
+      try rewrite SF in *; simpl in EVAL; inv EVAL; eauto.
+    + rewrite H0. destruct (Int64.eq i Int64.zero) eqn:NULL.
+      { eapply Val.cmplu_bool_lessdef; eauto. simpl. rewrite SF, NULL. simpl. eauto. }
+      { exploit cmplu_join_lessdef; try eapply H0; eauto. }
+    + rewrite H0. destruct (Int64.eq i0 Int64.zero) eqn:NULL.
+      { eapply Val.cmplu_bool_lessdef; eauto. simpl. rewrite SF, NULL. simpl. eauto. }
+      { exploit cmplu_join_lessdef; try eapply H0; eauto. }
+    + rewrite H0. eapply Val.cmplu_bool_lessdef; eauto.
+  (* cmpluimm *)
+  - destruct LESS; [ss|]. destruct LESS; [|ss].
+    dup H. unfold eval_condition_join, cmplu_join_common.
+    destruct v1; inv H; simpl in EVAL;
+      try rewrite SF in *; simpl in EVAL; inv EVAL; eauto.
+    rewrite H1. destruct (Int64.eq n Int64.zero) eqn:NULL.
+    + eapply Val.cmplu_bool_lessdef with (v2:=Vlong n); eauto. simpl. rewrite SF, NULL. simpl. eauto.
+    + exploit cmplu_join_lessdef; try eapply H1; eauto.
+  (* cmpu *)
+  - do 2 (destruct LESS; [ss|]). destruct LESS; [|ss].
+    dup H. dup H0. unfold eval_condition_join, cmpu_join_common.
+    destruct v1; destruct v0; inv H; inv H0; simpl in EVAL;
+      try rewrite SF in *; simpl in EVAL; inv EVAL; eauto.
+    + rewrite H0. destruct (Int.eq i Int.zero) eqn:NULL.
+      { eapply Val.cmpu_bool_lessdef; eauto. simpl. rewrite SF, NULL. simpl. eauto. }
+      { exploit cmpu_join_lessdef; try eapply H0; eauto. }
+    + rewrite H0. destruct (Int.eq i0 Int.zero) eqn:NULL.
+      { eapply Val.cmpu_bool_lessdef; eauto. simpl. rewrite SF, NULL. simpl. eauto. }
+      { exploit cmpu_join_lessdef; try eapply H0; eauto. }
+    + rewrite H0. eapply Val.cmpu_bool_lessdef; eauto. simpl. rewrite SF in *. eauto.
+  (* cmpuimm *)
+  - destruct LESS; [ss|]. destruct LESS; [|ss].
+    dup H. unfold eval_condition_join, cmpu_join_common.
+    destruct v1; inv H; simpl in EVAL;
+      try rewrite SF in *; simpl in EVAL; inv EVAL; eauto.
+    rewrite H1. destruct (Int.eq n Int.zero) eqn:NULL.
+    + eapply Val.cmpu_bool_lessdef with (v2:=Vint n); eauto. simpl. rewrite SF, NULL. simpl. eauto.
+    + exploit cmpu_join_lessdef; try eapply H1; eauto.
+Qed.
+
+Lemma eval_operation_join_lessdef
+    sp op vl1 vl2 v1 m1 m2
+    (PTRBINOP: ptr_binop op = true)
+    (LESS: Val.lessdef_list vl1 vl2)
+    (MEXT: Mem.extends m1 m2)
+    (EVAL: eval_operation_join genv sp op vl1 m1 = Some v1) :
+  exists v2, <<EVAL2: eval_operation_join genv sp op vl2 m2 = Some v2>> /\ <<LESS': Val.lessdef v1 v2>>.
+Proof.
+  unfold ptr_binop in PTRBINOP. destruct op; ss.
+  (* psub *)
+  - do 2 (destruct LESS; [ss|]). destruct LESS; [|ss]. dup H. dup H0.
+    destruct Archi.ptr64 eqn:SF; simpl in *.
+    (* psubl *)
+    + destruct v0; destruct v3; inv H; inv H0; simpl in *;
+        try rewrite SF in *; simpl in *; inv EVAL; eauto; clear SF; try (by (des_ifs; esplits; eauto)).
+      { exploit psubl_join_lessdef. eapply H1. eapply H2. eapply MEXT. eauto. i. des.
+        rewrite PSUB. esplits; eauto. }
+      { exploit psubl_join_lessdef. eapply H1. eapply H2. eapply MEXT. eauto. i. des.
+        rewrite PSUB. esplits; eauto. }
+    (* psub *)
+    + destruct v0; destruct v3; inv H; inv H0; simpl in *;
+        try rewrite SF in *; simpl in *; inv EVAL; eauto; clear SF; try (by (des_ifs; esplits; eauto)).
+      { exploit psub_join_lessdef. eapply H1. eapply H2. eapply MEXT. eauto. i. des.
+        rewrite PSUB. esplits; eauto. }
+      { exploit psub_join_lessdef. eapply H1. eapply H2. eapply MEXT. eauto. i. des.
+        rewrite PSUB. esplits; eauto. }
+  (* cmp *)
+  - destruct (eval_condition_join cond vl1 m1) eqn:COND.
+    2:{ ss. clarify. esplits; eauto. }
+    exploit eval_condition_join_lessdef; eauto. i. rewrite H. inv EVAL. esplits; eauto.
+Qed.
+
+Lemma eval_operation_wrapper_lessdef
+    sp op vl1 vl2 v1 m1 m2
+    (LESS: Val.lessdef_list vl1 vl2)
+    (MEXT: Mem.extends m1 m2)
+    (EVAL: eval_operation_wrapper genv sp op vl1 m1 = Some v1) :
+  exists v2, <<EVAL2: eval_operation_wrapper genv sp op vl2 m2 = Some v2>> /\ <<LESS': Val.lessdef v1 v2>>.
+Proof.
+  destruct (ptr_op op) eqn:PTROP; cycle 1.
+  { unfold eval_operation_wrapper in *. rewrite PTROP in *.
+    eapply eval_operation_lessdef; eauto. }
+  destruct (ptr_binop op) eqn:PTRBINOP; cycle 1.
+  { unfold eval_operation_wrapper in *. destruct op; ss; clarify.
+    destruct LESS; ss. destruct LESS; ss.
+    destruct (eval_condition_join c vl1 m1) eqn:EVAL1; cycle 1.
+    { clarify. esplits; eauto. }
+    exploit eval_condition_join_lessdef; eauto. i. des.
+    clarify. rewrite H1. ss. esplits; eauto.
+    eapply Val.normalize_lessdef. des_ifs; ss. }
+  unfold eval_operation_wrapper in *. des_ifs_safe.
+  assert (EVAL1: eval_operation_join genv sp op vl1 m1 = Some v1) by (destruct op; ss).
+  exploit eval_operation_join_lessdef; eauto. i. des. rewrite EVAL2.
+  destruct op; ss; esplits; eauto.
+Qed.
+
+Lemma eval_condition_wrapper_lessdef
+    c vl1 vl2 b m1 m2
+    (LESS: Val.lessdef_list vl1 vl2)
+    (MEXT: Mem.extends m1 m2)
+    (ECOND: eval_condition_wrapper c vl1 m1 = Some b) :
+  <<ECOND': eval_condition_wrapper c vl2 m2 = Some b>>.
+Proof.
+  destruct (ptr_cond c) eqn:COND.
+  - unfold eval_condition_wrapper in *. des_ifs. eapply eval_condition_join_lessdef; eauto.
+  - unfold eval_condition_wrapper in *. des_ifs. eapply eval_condition_lessdef; eauto.
+Qed.
+
+End EVAL_WRAPPER_LESSDEF.
+
+Section EVAL_WRAPPER_INJECT.
+
+Variable F V: Type.
+Variable genv: Genv.t F V.
+Variable f: meminj.
+Hypothesis globals: meminj_preserves_globals genv f.
+Variable sp1: block.
+Variable sp2: block.
+Variable delta: Z.
+Hypothesis sp_inj: f sp1 = Some(sp2, delta).
+
+Lemma eval_condition_join_inject
+    c vl1 vl2 m1 m2 b
+    (PTRCOND: ptr_cond c = true)
+    (VINJ: Val.inject_list f vl1 vl2)
+    (MINJ: Mem.inject f m1 m2)
+    (EVAL: eval_condition_join c vl1 m1 = Some b) :
+  <<EVAL': eval_condition_join c vl2 m2 = Some b>>.
+Proof.
+  unfold ptr_cond, ptr_uncond, ptr_bincond in PTRCOND.
+  destruct Archi.ptr64 eqn:SF; simpl in *; destruct c; simpl in PTRCOND; inv PTRCOND.
+  (* cmplu *)
+  - do 2 (destruct VINJ; [ss|]). destruct VINJ; [|ss]. dup H. dup H0. unfold eval_condition_join, cmplu_join_common.
+    destruct v; destruct v0; inv H; inv H0; simpl in EVAL;
+      try rewrite SF in *; simpl in EVAL; inv EVAL; eauto.
+    + rewrite H0. destruct (Int64.eq i Int64.zero) eqn:NULL.
+      { eapply cmplu_bool_inject'; eauto. simpl. rewrite SF, NULL. eauto. }
+      { exploit cmplu_join_inject; try eapply H0; eauto. }
+    + rewrite H0. destruct (Int64.eq i0 Int64.zero) eqn:NULL.
+      { eapply cmplu_bool_inject'; eauto. simpl. rewrite SF, NULL. eauto. }
+      { exploit cmplu_join_inject; try eapply H0; eauto. }
+    + rewrite H0. eapply cmplu_bool_inject'; eauto.
+  (* cmpluimm *)
+  - destruct VINJ; [ss|]. destruct VINJ; [|ss]. dup H. unfold eval_condition_join, cmplu_join_common.
+    destruct v; inv H; simpl in EVAL;
+      try rewrite SF in *; simpl in EVAL; inv EVAL; eauto.
+    rewrite H1. destruct (Int64.eq n Int64.zero) eqn:NULL.
+    { eapply cmplu_bool_inject' with (v2:=Vlong n); eauto. simpl. rewrite SF, NULL. eauto. }
+    { exploit cmplu_join_inject; try eapply H1; eauto. }
+  (* cmpu *)
+  - do 2 (destruct VINJ; [ss|]). destruct VINJ; [|ss]. dup H. dup H0. unfold eval_condition_join, cmpu_join_common.
+    destruct v; destruct v0; inv H; inv H0; simpl in EVAL;
+      try rewrite SF in *; simpl in EVAL; inv EVAL; eauto.
+    + rewrite H0. destruct (Int.eq i Int.zero) eqn:NULL.
+      { eapply cmpu_bool_inject'; eauto. simpl. rewrite SF, NULL. eauto. }
+      { exploit cmpu_join_inject; try eapply H0; eauto. }
+    + rewrite H0. destruct (Int.eq i0 Int.zero) eqn:NULL.
+      { eapply cmpu_bool_inject'; eauto. simpl. rewrite SF, NULL. eauto. }
+      { exploit cmpu_join_inject; try eapply H0; eauto. }
+    + rewrite H0. eapply cmpu_bool_inject'; eauto. simpl. rewrite SF. eauto.
+  (* cmpuimm *)
+  - destruct VINJ; [ss|]. destruct VINJ; [|ss]. dup H. unfold eval_condition_join, cmpu_join_common.
+    destruct v; inv H; simpl in EVAL;
+      try rewrite SF in *; simpl in EVAL; inv EVAL; eauto.
+    rewrite H1. destruct (Int.eq n Int.zero) eqn:NULL.
+    { eapply cmpu_bool_inject' with (v2:=Vint n); eauto. simpl. rewrite SF, NULL. eauto. }
+    { exploit cmpu_join_inject; try eapply H1; eauto. }
+Qed.
+
+Lemma eval_operation_join_inject
+    op vl1 vl2 v1 m1 m2
+    (PTRBINOP: ptr_binop op = true)
+    (VINJ: Val.inject_list f vl1 vl2)
+    (MINJ: Mem.inject f m1 m2)
+    (EVAL: eval_operation_join genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) :
+  exists v2, <<EVAL': eval_operation_join genv (Vptr sp2 Ptrofs.zero) (shift_stack_operation delta op) vl2 m2 = Some v2>>
+   /\ <<VINJ': Val.inject f v1 v2>>.
+Proof.
+  unfold ptr_binop in PTRBINOP. destruct op; ss.
+  (* psub *)
+  - do 2 (destruct VINJ; [ss|]). destruct VINJ; [|ss]. dup H. dup H0.
+    destruct Archi.ptr64 eqn:SF; simpl in *.
+    (* psubl *)
+    + destruct v; destruct v0; inv H; inv H0; simpl in EVAL;
+        try rewrite SF in *; simpl in EVAL; inv EVAL; eauto; try (by (des_ifs; esplits; eauto)).
+      { exploit Val.psubl_inject. eapply H1. eapply H2. i. esplits; eauto. }
+      { exploit psubl_join_common_inject. eauto. eapply H1. eapply H2. eauto. eauto. i. des. subst. esplits; eauto. }
+      { exploit psubl_join_common_inject. eauto. eapply H1. eapply H2. eauto. eauto. i. des. subst. esplits; eauto. }
+      { exploit Val.psubl_inject. eapply H1. eapply H2. i. esplits; eauto. }
+    (* psub *)
+    + destruct v; destruct v0; inv H; inv H0; simpl in EVAL;
+        try rewrite SF in *; simpl in EVAL; inv EVAL; eauto; try (by (des_ifs; esplits; eauto)).
+  - destruct (eval_condition_join cond vl1 m1) eqn:COND.
+    2:{ ss. clarify. esplits; eauto. }
+    exploit eval_condition_join_inject; eauto. i. rewrite H. inv EVAL. esplits; eauto.
+    destruct b; ss; econs.
+Qed.
+
+Lemma eval_operation_wrapper_inject
+    op vl1 vl2 v1 m1 m2
+    (VINJ: Val.inject_list f vl1 vl2)
+    (MINJ: Mem.inject f m1 m2)
+    (EVAL: eval_operation_wrapper genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) :
+  exists v2, <<EVAL': eval_operation_wrapper genv (Vptr sp2 Ptrofs.zero) (shift_stack_operation delta op) vl2 m2 = Some v2>>
+   /\ <<VINJ': Val.inject f v1 v2>>.
+Proof.
+  assert (SHIFT: ptr_op (shift_stack_operation delta op) = ptr_op op) by (destruct op; ss).
+  assert (SHIFT': ptr_binop (shift_stack_operation delta op) = ptr_binop op) by (destruct op; ss).
+  destruct (ptr_op op) eqn:PTROP; cycle 1.
+  { unfold eval_operation_wrapper in *. rewrite SHIFT. rewrite PTROP in EVAL.
+    eapply eval_operation_inject; eauto. }
+  destruct (ptr_binop op) eqn:PTRBINOP; cycle 1.
+  { unfold eval_operation_wrapper in *. destruct op; ss; clarify.
+    destruct VINJ; ss. destruct VINJ; ss.
+    destruct (eval_condition_join c vl m1) eqn:EVAL1; cycle 1.
+    { clarify. esplits; eauto. }
+    exploit eval_condition_join_inject; eauto. i. des.
+    clarify. rewrite H1. ss. esplits; eauto.
+    eapply Val.normalize_inject. des_ifs; ss. }
+  unfold eval_operation_wrapper in *. rewrite PTROP in EVAL. rewrite SHIFT.
+  assert (EVAL1: eval_operation_join genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) by (destruct op; ss).
+  exploit eval_operation_join_inject; try eapply EVAL1; eauto. i. des. rewrite EVAL'.
+  destruct op; ss; esplits; eauto.
+Qed.
+
+Lemma eval_condition_wrapper_inject
+    c vl1 vl2 m1 m2 b
+    (VINJ: Val.inject_list f vl1 vl2)
+    (MINJ: Mem.inject f m1 m2)
+    (EVAL: eval_condition_wrapper c vl1 m1 = Some b) :
+  <<EVAL': eval_condition_wrapper c vl2 m2 = Some b>>.
+Proof.
+  destruct (ptr_cond c) eqn:COND.
+  - unfold eval_condition_wrapper in *. des_ifs. eapply eval_condition_join_inject; eauto.
+  - unfold eval_condition_wrapper in *. des_ifs. eapply eval_condition_inject; eauto.
+Qed.
+
+End EVAL_WRAPPER_INJECT.
diff --git a/x86/PrintOp.ml b/x86/PrintOp.ml
index 6aa4d450..bc6110df 100644
--- a/x86/PrintOp.ml
+++ b/x86/PrintOp.ml
@@ -117,6 +117,7 @@ let print_operation reg pp = function
   | Ocast32unsigned, [r1] -> fprintf pp "long32unsigned(%a)" reg r1
   | Onegl, [r1] -> fprintf pp "(-l %a)" reg r1
   | Osubl, [r1;r2] -> fprintf pp "%a -l %a" reg r1 reg r2
+  | Opsub, [r1;r2] -> fprintf pp "%a -p %a" reg r1 reg r2
   | Omull, [r1;r2] -> fprintf pp "%a *l %a" reg r1 reg r2
   | Omullimm n, [r1] -> fprintf pp "%a *l %Ld" reg r1 (camlint64_of_coqint n)
   | Omullhs, [r1;r2] -> fprintf pp "mullhs(%a,%a)" reg r1 reg r2
diff --git a/x86/SelectLong.vp b/x86/SelectLong.vp
index b213e23f..5a50662d 100644
--- a/x86/SelectLong.vp
+++ b/x86/SelectLong.vp
@@ -259,6 +259,18 @@ Nondetfunction subl (e1: expr) (e2: expr) :=
       Eop Osubl (e1:::e2:::Enil)
   end.
 
+Nondetfunction psubl (e1: expr) (e2: expr) :=
+  match e1, e2 with
+  | Eop (Oleal (Aindexed n1)) (t1:::Enil), Eop (Oleal (Aindexed n2)) (t2:::Enil) =>
+      addlimm (Int64.repr (n1 - n2)) (Eop Opsub (t1:::t2:::Enil))
+  | Eop (Oleal (Aindexed n1)) (t1:::Enil), t2 =>
+      addlimm (Int64.repr n1) (Eop Opsub (t1:::t2:::Enil))
+  | t1, Eop (Oleal (Aindexed n2)) (t2:::Enil) =>
+      addlimm (Int64.repr (- n2)) (Eop Opsub (t1:::t2:::Enil))
+  | _, _ =>
+      Eop Opsub (e1:::e2:::Enil)
+  end.
+
 Definition mullimm_base (n1: int64) (e2: expr) :=
   match Int64.one_bits' n1 with
   | i :: nil =>
diff --git a/x86/SelectLongproof.v b/x86/SelectLongproof.v
index 3bef632d..d94c9cd8 100644
--- a/x86/SelectLongproof.v
+++ b/x86/SelectLongproof.v
@@ -18,6 +18,7 @@ Require Import AST Values Memory Globalenvs Events.
 Require Import Cminor Op CminorSel.
 Require Import SelectOp SelectOpproof SplitLong SplitLongproof.
 Require Import SelectLong.
+Require Import IntPtrRel PointerOp.
 
 Local Open Scope cminorsel_scope.
 Local Open Scope string_scope.
@@ -482,8 +483,43 @@ Proof.
   TrivialExists.
 Qed.
 
+Theorem eval_psubl: binary_constructor_sound psubl (psubl_join_common m).
+Proof.
+  unfold psubl.
+  red; intros; destruct (psubl_match a b); InvEval.
+- subst. rewrite psubl_join_common_addl_l. rewrite psubl_join_common_addl_r.
+  rewrite Val.addl_assoc. simpl. rewrite Int64.add_commut. rewrite <- Int64.sub_add_opp.
+  replace (Int64.repr (n1 - n2)) with (Int64.sub (Int64.repr n1) (Int64.repr n2)).
+  apply eval_addlimm; EvalOpPtr.
+  (* { unfold eval_operation_wrapper, psubl_join_common. *)
+  (*   unfold ptr_op. ss. destruct Archi.ptr64 eqn:SF. *)
+  (*   2:{ ss. } *)
+  (*   destruct v1; destruct v0; ss. } *)
+  apply Int64.eqm_samerepr; auto with ints.
+- subst. rewrite psubl_join_common_addl_l. apply eval_addlimm; EvalOpPtr.
+  (* unfold eval_operation_wrapper, psubl_join_common. *)
+  (* unfold ptr_op. ss. destruct Archi.ptr64 eqn:SF. *)
+  (* 2:{ ss. } *)
+  (* destruct v1; destruct y; ss. *)
+- subst. rewrite psubl_join_common_addl_r.
+  replace (Int64.repr (-n2)) with (Int64.neg (Int64.repr n2)).
+  apply eval_addlimm; EvalOpPtr.
+  (* { unfold eval_operation_wrapper, psubl_join_common. *)
+  (*   unfold ptr_op. ss. destruct Archi.ptr64 eqn:SF. *)
+  (*   2:{ ss. } *)
+  (*   destruct x; destruct v1; ss. } *)
+  apply Int64.eqm_samerepr; auto with ints.
+- esplits; eauto; ss. econs.
+  + econs; eauto. econs; eauto. econs.
+  + unfold eval_operation_wrapper, psubl_join_common.
+    unfold ptr_op. ss.
+    (* destruct Archi.ptr64 eqn:SF. *)
+    (* 2:{ ss. } *)
+    (* destruct x; destruct y; ss. *)
+Qed.
+
 Theorem eval_cmplu:
-  forall c le a x b y v,
+  forall c le a x b y v (PCOND: ptr_cond (Ccomplu c) = false),
   eval_expr ge sp e m le a x ->
   eval_expr ge sp e m le b y ->
   Val.cmplu (Mem.valid_pointer m) c x y = Some v ->
@@ -503,6 +539,55 @@ Proof.
 - EvalOp. simpl; rewrite C; auto.
 Qed.
 
+Theorem eval_cmplu_wrapper
+  c le a x b y v
+  (EVAL1: eval_expr ge sp e m le a x)
+  (EVAL2: eval_expr ge sp e m le b y)
+  (EVOP: eval_binop_wrapper (Ocmplu c) x y m = Some v)
+  :
+  <<EVAL: eval_expr ge sp e m le (cmplu c a b) v>>.
+Proof.
+  unfold cmplu; intros. destruct Archi.splitlong eqn:SL.
+  eapply SplitLongproof.eval_cmplu; eauto using Archi.splitlong_ptr32.
+  { unfold eval_binop_wrapper in EVOP. simpl in *. des_ifs. }
+  destruct (is_longconst a) as [n1|] eqn:LC1; destruct (is_longconst b) as [n2|] eqn:LC2;
+  try (assert (x = Vlong n1) by (eapply is_longconst_sound; eauto));
+  try (assert (y = Vlong n2) by (eapply is_longconst_sound; eauto));
+  subst.
+  - unfold eval_binop_wrapper in EVOP. simpl in *.
+    econs. econs. des_ifs.
+  - EvalOpPtr. simpl.
+    unfold eval_operation_wrapper. simpl.
+    unfold ptr_cond. simpl. des_ifs_safe. unfold cmplu_join_common, cmplu_join.
+    do 3 rewrite Val.swap_cmplu_bool. unfold eval_binop_wrapper in EVOP. simpl in EVOP.
+    des_ifs_safe. fold (cmplu_join m c (Vlong n1) (Vptr b0 i)).
+    destruct (Int64.eq n1 Int64.zero) eqn:NULL.
+    + ss. des_ifs_safe. inv EVOP. ss. destruct c; ss.
+    + destruct (cmplu_join m c (Vlong n1) (Vptr b0 i)) as [vb|] eqn:C.
+      2:{ ss. }
+      simpl in EVOP. eauto.
+  - EvalOpPtr. simpl.
+    unfold eval_operation_wrapper. simpl.
+    unfold ptr_cond. simpl. des_ifs_safe. unfold cmplu_join_common, cmplu_join.
+    unfold eval_binop_wrapper in *. simpl in EVOP. des_ifs_safe.
+    fold (cmplu_join m c (Vptr b0 i) (Vlong n2)).
+    destruct (Int64.eq n2 Int64.zero) eqn:NULL.
+    + ss. des_ifs_safe. destruct c; ss.
+    + destruct (cmplu_join m c (Vptr b0 i) (Vlong n2)) as [vb|] eqn:C.
+      2:{ ss. }
+      simpl in *. eauto.
+  - EvalOpPtr. unfold eval_operation_wrapper. simpl in *. unfold eval_binop_wrapper, eval_binop_join in *.
+    ss. unfold ptr_cond, ptr_bincond. simpl. destruct Archi.ptr64 eqn:SF.
+    2:{ unfold Val.cmplu in EVOP. destruct (Val.cmplu_bool (Mem.valid_pointer m) c x y) eqn:A;[|simpl in *; clarify].
+        simpl in *. destruct b0; simpl in *; eauto. }
+    unfold cmplu_join_common. des_ifs; eauto.
+    + destruct (Val.cmplu_bool (Mem.valid_pointer m) c (Vlong i) (Vptr b0 i0)); ss.
+    + destruct (cmplu_join m c (Vlong i) (Vptr b0 i0)); ss.
+    + destruct (Val.cmplu_bool (Mem.valid_pointer m) c (Vptr b0 i) (Vlong i0)); ss.
+    + destruct (cmplu_join m c (Vptr b0 i) (Vlong i0)); ss.
+    + ss. des_ifs. destruct c; ss.
+Qed.
+    
 Theorem eval_cmpl:
   forall c le a x b y v,
   eval_expr ge sp e m le a x ->
diff --git a/x86/SelectOp.vp b/x86/SelectOp.vp
index 31be8c32..ab11c118 100644
--- a/x86/SelectOp.vp
+++ b/x86/SelectOp.vp
@@ -139,6 +139,18 @@ Nondetfunction sub (e1: expr) (e2: expr) :=
       Eop Osub (e1:::e2:::Enil)
   end.
 
+Nondetfunction psub (e1: expr) (e2: expr) :=
+  match e1, e2 with
+  | Eop (Olea (Aindexed n1)) (t1:::Enil), Eop (Olea (Aindexed n2)) (t2:::Enil) =>
+      addimm (Int.repr (n1 - n2)) (Eop Opsub (t1:::t2:::Enil))
+  | Eop (Olea (Aindexed n1)) (t1:::Enil), t2 =>
+      addimm (Int.repr n1) (Eop Opsub (t1:::t2:::Enil))
+  | t1, Eop (Olea (Aindexed n2)) (t2:::Enil) =>
+      addimm (Int.repr (-n2)) (Eop Opsub (t1:::t2:::Enil))
+  | _, _ =>
+      Eop Opsub (e1:::e2:::Enil)
+  end.
+
 (** ** Immediate shifts *)
 
 Definition shift_is_scale (n: int) : bool :=
diff --git a/x86/SelectOpproof.v b/x86/SelectOpproof.v
index d8ab32a4..7aa2f083 100644
--- a/x86/SelectOpproof.v
+++ b/x86/SelectOpproof.v
@@ -17,6 +17,7 @@ Require Import AST Integers Floats.
 Require Import Values Memory Builtins Globalenvs.
 Require Import Cminor Op CminorSel.
 Require Import SelectOp.
+Require Import IntPtrRel PointerOp.
 
 Local Open Scope cminorsel_scope.
 
@@ -26,7 +27,8 @@ Local Open Scope cminorsel_scope.
   perform backward (inversion) and forward reasoning over the evaluation
   of operator applications. *)
 
-Ltac EvalOp := eapply eval_Eop; eauto with evalexpr.
+Ltac EvalOp := eapply eval_Eop; eauto with evalexpr; (try (rewrite eval_operation_no_ptr_op in *; eauto)).
+Ltac EvalOpPtr := eapply eval_Eop; eauto with evalexpr.
 
 Ltac InvEval1 :=
   match goal with
@@ -58,13 +60,19 @@ Ltac InvEval2 :=
       idtac
   end.
 
-Ltac InvEval := InvEval1; InvEval2; InvEval2; subst.
+Ltac InvEval := InvEval1; (try (rewrite eval_operation_no_ptr_op in *; eauto)); InvEval2; InvEval2; subst.
+Ltac InvEvalPtr := InvEval1; InvEval2; InvEval2; subst.
 
 Ltac TrivialExists :=
   match goal with
   | [ |- exists v, _ /\ Val.lessdef ?a v ] => exists a; split; [EvalOp | auto]
   end.
 
+Ltac TrivialExistsPtr :=
+  match goal with
+  | [ |- exists v, _ /\ Val.lessdef ?a v ] => exists a; split; [EvalOpPtr | auto]
+  end.
+
 (** * Correctness of the smart constructors *)
 
 Section CMCONSTR.
@@ -139,9 +147,9 @@ Qed.
 
 Theorem eval_notint: unary_constructor_sound notint Val.notint.
 Proof.
-  unfold notint; red; intros until x. case (notint_match a); intros; InvEval.
+  unfold notint; red; intros until x. case (notint_match a); intros. InvEval.
 - TrivialExists.
-- rewrite Val.not_xor. rewrite Val.xor_assoc. TrivialExists.
+- InvEval. rewrite Val.not_xor. rewrite Val.xor_assoc. TrivialExists.
 - TrivialExists.
 Qed.
 
@@ -154,7 +162,7 @@ Proof.
   destruct x; simpl; rewrite ?Int.add_zero, ?Ptrofs.add_zero; auto.
 - case (addimm_match a); intros; InvEval.
 + TrivialExists; simpl. rewrite Int.add_commut. auto.
-+ inv H0. simpl in H6. TrivialExists. simpl.
++ inv H0. rewrite eval_operation_no_ptr_op in *; eauto. simpl in H6. TrivialExists. simpl. 
   erewrite eval_offset_addressing_total_32 by eauto. rewrite Int.repr_signed; auto.
 + TrivialExists. simpl. rewrite Int.repr_signed; auto.
 Qed.
@@ -211,6 +219,36 @@ Proof.
 - TrivialExists.
 Qed.
 
+Theorem eval_psub (SF: Archi.ptr64 = false) : binary_constructor_sound psub (psub_join_common m). (* Val.psub join needed *)
+Proof.
+  unfold psub.
+  red; intros; destruct (psub_match a b); InvEval.
+- subst. rewrite psub_join_common_addl_l. rewrite psub_join_common_addl_r.
+  rewrite Val.add_assoc. simpl. rewrite Int.add_commut. rewrite <- Int.sub_add_opp.
+  replace (Int.repr (n1 - n2)) with (Int.sub (Int.repr n1) (Int.repr n2)).
+  apply eval_addimm; EvalOpPtr.
+  { unfold eval_operation_wrapper, psubl_join_common.
+    unfold ptr_op. simpl. rewrite SF. clear SF.
+    destruct v1; destruct v0; ss. }
+  apply Int.eqm_samerepr; auto with ints.
+- subst. rewrite psub_join_common_addl_l. apply eval_addimm; EvalOpPtr.
+  unfold eval_operation_wrapper, psub_join_common.
+  unfold ptr_op. simpl. rewrite SF. clear SF.
+  destruct v1; destruct y; ss.
+- subst. rewrite psub_join_common_addl_r.
+  replace (Int.repr (-n2)) with (Int.neg (Int.repr n2)).
+  apply eval_addimm; EvalOpPtr.
+  { unfold eval_operation_wrapper, psub_join_common.
+    unfold ptr_op. simpl. rewrite SF. clear SF.
+    destruct x; destruct v1; ss. }
+  apply Int.eqm_samerepr; auto with ints.
+- esplits; eauto; simpl. econs.
+  + econs; eauto. econs; eauto. econs.
+  + unfold eval_operation_wrapper, psub_join_common.
+    unfold ptr_op. simpl. rewrite SF. clear SF.
+    destruct x; destruct y; ss.
+Qed.
+
 Theorem eval_negint: unary_constructor_sound negint Val.neg.
 Proof.
   red; intros until x. unfold negint. case (negint_match a); intros; InvEval.
@@ -624,6 +662,7 @@ Variable default: comparison -> int -> condition.
 Variable intsem: comparison -> int -> int -> bool.
 Variable sem: comparison -> val -> val -> val.
 
+Hypothesis default_notptr: forall c n, ptr_cond (default c n) = false.
 Hypothesis sem_int: forall c x y, sem c (Vint x) (Vint y) = Val.of_bool (intsem c x y).
 Hypothesis sem_undef: forall c v, sem c Vundef v = Vundef.
 Hypothesis sem_eq: forall x y, sem Ceq (Vint x) (Vint y) = Val.of_bool (Int.eq x y).
@@ -641,8 +680,10 @@ Proof.
 - (* constant *)
   InvEval. rewrite sem_int. TrivialExists. simpl. destruct (intsem c0 n1 n2); auto.
 - (* eq cmp *)
-  InvEval. inv H. simpl in H5. inv H5.
+  destruct (ptr_cond c0) eqn:PCOND; cycle 1.
+  InvEval. inv H. rewrite eval_operation_no_ptr_op in *; eauto. simpl in H5. inv H5.
   destruct (Int.eq_dec n2 Int.zero). subst n2. TrivialExists.
+  2:{ simpl. destruct c0; ss. }
   simpl. rewrite eval_negate_condition.
   destruct (eval_condition c0 vl m); simpl.
   unfold Vtrue, Vfalse. destruct b; simpl; rewrite sem_eq; auto.
@@ -655,13 +696,32 @@ Proof.
   destruct (eval_condition c0 vl m); simpl.
   unfold Vtrue, Vfalse. destruct b; rewrite sem_eq; rewrite Int.eq_false; auto.
   rewrite sem_undef; auto.
+  { InvEval. inv H. rewrite cmp_wrapper_eval_condition_join in *; eauto. inv H5.
+    destruct (Int.eq_dec n2 Int.zero). subst n2. TrivialExistsPtr.
+    rewrite cmp_wrapper_eval_condition_join; eauto.
+    2:{ destruct c0; ss. }
+    rewrite eval_negate_condition_join; eauto.
+    destruct (eval_condition_join c0 vl m); simpl.
+    unfold Vtrue, Vfalse. destruct b; simpl; rewrite sem_eq; auto.
+    rewrite sem_undef; auto.
+    destruct (Int.eq_dec n2 Int.one). subst n2. TrivialExistsPtr.
+    rewrite cmp_wrapper_eval_condition_join; eauto.
+    simpl. destruct (eval_condition_join c0 vl m); simpl.
+    unfold Vtrue, Vfalse. destruct b; simpl; rewrite sem_eq; auto.
+    rewrite sem_undef; auto.
+    exists (Vint Int.zero); split. EvalOpPtr.
+    destruct (eval_condition_join c0 vl m); simpl.
+    unfold Vtrue, Vfalse. destruct b; rewrite sem_eq; rewrite Int.eq_false; auto.
+    rewrite sem_undef; auto. }
 - (* ne cmp *)
-  InvEval. inv H. simpl in H5. inv H5.
+  destruct (ptr_cond c0) eqn:PCOND; cycle 1.
+  InvEval. inv H. rewrite eval_operation_no_ptr_op in *; eauto. simpl in H5. inv H5.
   destruct (Int.eq_dec n2 Int.zero). subst n2. TrivialExists.
   simpl. destruct (eval_condition c0 vl m); simpl.
   unfold Vtrue, Vfalse. destruct b; simpl; rewrite sem_ne; auto.
   rewrite sem_undef; auto.
   destruct (Int.eq_dec n2 Int.one). subst n2. TrivialExists.
+  2:{ destruct c0; ss. }
   simpl. rewrite eval_negate_condition. destruct (eval_condition c0 vl m); simpl.
   unfold Vtrue, Vfalse. destruct b; simpl; rewrite sem_ne; auto.
   rewrite sem_undef; auto.
@@ -669,6 +729,22 @@ Proof.
   destruct (eval_condition c0 vl m); simpl.
   unfold Vtrue, Vfalse. destruct b; rewrite sem_ne; rewrite Int.eq_false; auto.
   rewrite sem_undef; auto.
+  { InvEval. inv H. rewrite cmp_wrapper_eval_condition_join in *; eauto. simpl in H5. inv H5.
+    destruct (Int.eq_dec n2 Int.zero). subst n2. TrivialExistsPtr.
+    rewrite cmp_wrapper_eval_condition_join; eauto.
+    simpl. destruct (eval_condition_join c0 vl m); simpl.
+    unfold Vtrue, Vfalse. destruct b; simpl; rewrite sem_ne; auto.
+    rewrite sem_undef; auto.
+    destruct (Int.eq_dec n2 Int.one). subst n2. TrivialExistsPtr.
+    rewrite cmp_wrapper_eval_condition_join; eauto.
+    2:{ destruct c0; ss. }
+    simpl. rewrite eval_negate_condition_join; eauto. destruct (eval_condition_join c0 vl m); simpl.
+    unfold Vtrue, Vfalse. destruct b; simpl; rewrite sem_ne; auto.
+    rewrite sem_undef; auto.
+    exists (Vint Int.one); split. EvalOp.
+    destruct (eval_condition_join c0 vl m); simpl.
+    unfold Vtrue, Vfalse. destruct b; rewrite sem_ne; rewrite Int.eq_false; auto.
+    rewrite sem_undef; auto. }
 - (* eq andimm *)
   destruct (Int.eq_dec n2 Int.zero). InvEval; subst.
   econstructor; split. EvalOp. simpl; eauto.
@@ -764,7 +840,7 @@ Proof.
 Qed.
 
 Theorem eval_select: 
-  forall le ty cond al vl a1 v1 a2 v2 a b,
+  forall le ty cond al vl a1 v1 a2 v2 a b (COND: ptr_cond cond = false),
   select ty cond al a1 a2 = Some a ->
   eval_exprlist ge sp e m le al vl ->
   eval_expr ge sp e m le a1 v1 ->
@@ -780,12 +856,48 @@ Proof.
 - exists (Val.select (Some (negb b)) v2 v1 ty); split.
   apply eval_Eop with (v2 :: v1 :: vl).
   constructor; auto. constructor; auto.
+  rewrite eval_operation_no_ptr_op; eauto.
+  2:{ simpl. destruct cond; ss. }
   simpl. rewrite eval_negate_condition, H3; auto.
   destruct b; auto.
 - exists (Val.select (Some b) v1 v2 ty); split.
-  apply eval_Eop with (v1 :: v2 :: vl).
+  apply eval_Eop with (v1 :: v2 :: vl). 
   constructor; auto. constructor; auto.
+  rewrite eval_operation_no_ptr_op; eauto.
+  2:{ simpl. destruct cond; ss. }
   simpl. rewrite H3; auto.
+  (* auto. *)
+Qed.
+
+Theorem eval_select_join
+  le ty cond al vl a1 v1 a2 v2 a b
+  (COND: ptr_cond cond = true)
+  (SEL: select ty cond al a1 a2 = Some a)
+  (ARGS: eval_exprlist ge sp e m le al vl)
+  (EVAL1: eval_expr ge sp e m le a1 v1)
+  (EVAL2: eval_expr ge sp e m le a2 v2)
+  (JOIN: eval_condition_join cond vl m = Some b)
+  :
+  exists v, 
+    <<EVAL': eval_expr ge sp e m le a v>>
+  /\ <<SEL': Val.lessdef (Val.select (Some b) v1 v2 ty) v>>.
+Proof.
+  assert (NEG: ptr_cond (negate_condition cond) = true).
+  { destruct cond; ss. }
+  unfold select in SEL; intros. 
+  destruct (select_supported ty); try discriminate.
+  destruct (select_swap cond); inv SEL.
+- exists (Val.select (Some (negb b)) v2 v1 ty); split.
+  apply eval_Eop with (v2 :: v1 :: vl).
+  constructor; auto. constructor; auto.
+  unfold eval_operation_wrapper. simpl. rewrite NEG.
+  simpl. rewrite eval_negate_condition_join, JOIN; eauto.
+  destruct b; auto.
+- exists (Val.select (Some b) v1 v2 ty); split.
+  apply eval_Eop with (v1 :: v2 :: vl). 
+  constructor; auto. constructor; auto.
+  unfold eval_operation_wrapper. simpl. rewrite COND.
+  simpl. rewrite JOIN; auto.
   auto.
 Qed.
 
@@ -857,7 +969,9 @@ Proof.
   rewrite Int.add_zero in A4.
   auto.
 - apply Float.to_intu_to_long in Heqo. repeat econstructor. eauto.
+  rewrite eval_operation_no_ptr_op; eauto.
   simpl. rewrite Heqo; reflexivity.
+  rewrite eval_operation_no_ptr_op; eauto.
   simpl. unfold Int64.loword. rewrite Int64.unsigned_repr, Int.repr_unsigned; auto.
   assert (Int.modulus < Int64.max_unsigned) by reflexivity. 
   generalize (Int.unsigned_range n); lia.
@@ -975,6 +1089,39 @@ Proof.
 - apply D; auto.
 Qed.
 
+(* need to expand for 32 bit *)
+Theorem eval_addressing_long:
+  forall le chunk a v n (SF: Archi.ptr64 = true),
+  eval_expr ge sp e m le a v ->
+  v = Vlong n ->
+  match addressing chunk a with (mode, args) =>
+    exists vl,
+    eval_exprlist ge sp e m le args vl /\
+    Op.eval_addressing ge sp mode vl = Some v
+  end.
+Proof.
+  intros until n. intros SF.
+  assert (A: v = Vlong n -> Op.eval_addressing ge sp (Aindexed 0) (v :: nil) = Some v).
+  { intros. subst v. unfold Op.eval_addressing.
+    ss. rewrite SF. rewrite Int64.add_zero. eauto. }
+  assert (D: forall a,
+             eval_expr ge sp e m le a v ->
+             v = Vlong n ->
+             exists vl, eval_exprlist ge sp e m le (a ::: Enil) vl
+                     /\ Op.eval_addressing ge sp (Aindexed 0) vl = Some v).
+  { intros. exists (v :: nil); split. constructor; auto. constructor. auto. }
+  unfold addressing; case (addressing_match a); intros.
+- destruct (negb Archi.ptr64 && addressing_valid addr) eqn:E.
++ inv H. InvBooleans. apply negb_true_iff in H. unfold Op.eval_addressing; rewrite H.
+  exists vl; auto.
++ apply D; auto.
+- destruct (Archi.ptr64 && addressing_valid addr) eqn:E.
++ inv H. InvBooleans. unfold Op.eval_addressing; rewrite H.
+  exists vl; auto.
++ apply D; auto.
+- apply D; auto.
+Qed.
+
 Theorem eval_builtin_arg_addr:
   forall addr al vl v,
   eval_exprlist ge sp e m nil al vl ->
@@ -988,7 +1135,7 @@ Proof.
   rewrite EQ. constructor. constructor; auto. unfold v2; destruct Archi.ptr64; constructor.
 - rewrite eval_addressing_Aglobal in H0. inv H0. constructor.
 - rewrite eval_addressing_Ainstack in H0. inv H0. constructor.
-- constructor. econstructor. eauto. rewrite eval_Olea_ptr. auto. 
+- constructor. econstructor. eauto. rewrite eval_operation_no_ptr_op; eauto. (* rewrite eval_Olea_ptr. auto.  *)
 Qed. 
 
 Theorem eval_builtin_arg:
diff --git a/x86/Stacklayout.v b/x86/Stacklayout.v
index 002b86bf..b1f3c2a0 100644
--- a/x86/Stacklayout.v
+++ b/x86/Stacklayout.v
@@ -101,6 +101,58 @@ Local Opaque Z.add Z.mul sepconj range.
   exact H.
 Qed.
 
+Lemma frame_env_separated_undef:
+  forall b sp m P,
+  let fe := make_env b in
+  m |= undef_area sp 0 (fe_stack_data fe) ** undef_area sp (fe_stack_data fe + bound_stack_data b) (fe_size fe) ** P ->
+  m |= undef_area sp (fe_ofs_local fe) (fe_ofs_local fe + 4 * bound_local b)
+       ** undef_area sp fe_ofs_arg (fe_ofs_arg + 4 * bound_outgoing b)
+       ** undef_area sp (fe_ofs_link fe) (fe_ofs_link fe + size_chunk Mptr)
+       ** undef_area sp (fe_ofs_retaddr fe) (fe_ofs_retaddr fe + size_chunk Mptr)
+       ** undef_area sp (fe_ofs_callee_save fe) (size_callee_save_area b (fe_ofs_callee_save fe))
+       ** P.
+Proof.
+Local Opaque Z.add Z.mul sepconj range.
+  intros; simpl.
+  set (w := if Archi.ptr64 then 8 else 4).
+  set (olink := align (fe_ofs_arg + 4 * b.(bound_outgoing)) w).
+  set (ocs := olink + w).
+  set (ol :=  align (size_callee_save_area b ocs) 8).
+  set (ostkdata := align (ol + 4 * b.(bound_local)) 8).
+  set (oretaddr := align (ostkdata + b.(bound_stack_data)) w).
+  replace (size_chunk Mptr) with w by (rewrite size_chunk_Mptr; auto).
+  assert (0 < w) by (unfold w; destruct Archi.ptr64; lia).
+  generalize b.(bound_local_pos) b.(bound_outgoing_pos) b.(bound_stack_data_pos); intros.
+  assert (0 <= fe_ofs_arg) by (unfold fe_ofs_arg; destruct Archi.win64; lia).
+  assert (0 <= 4 * b.(bound_outgoing)) by lia.
+  assert (fe_ofs_arg + 4 * b.(bound_outgoing) <= olink) by (apply align_le; lia).
+  assert (olink + w <= ocs) by (unfold ocs; lia).
+  assert (ocs <= size_callee_save_area b ocs) by (apply size_callee_save_area_incr).
+  assert (size_callee_save_area b ocs <= ol) by (apply align_le; lia).
+  assert (ol + 4 * b.(bound_local) <= ostkdata) by (apply align_le; lia).
+  assert (ostkdata + bound_stack_data b <= oretaddr) by (apply align_le; lia).
+(* Reorder as:
+     outgoing
+     back link
+     callee-save
+     local
+     retaddr *)
+  rewrite sep_swap12.
+  rewrite sep_swap23.
+  rewrite sep_swap45.
+  rewrite sep_swap34.
+(* Apply range_split and range_split2 repeatedly *)
+  apply undef_area_drop_left with 0. lia. 
+  apply undef_area_split_2. fold olink. lia. lia. lia.
+  apply undef_area_split. lia.
+  apply undef_area_split_2. fold ol. lia. lia. lia.
+  apply undef_area_drop_right with ostkdata. lia.
+  rewrite sep_swap.
+  apply undef_area_drop_left with (ostkdata + bound_stack_data b). lia.
+  rewrite sep_swap.
+  exact H.
+Qed.
+
 Lemma frame_env_range:
   forall b,
   let fe := make_env b in
diff --git a/x86/TargetPrinter.ml b/x86/TargetPrinter.ml
index 1b27ee73..e04daccb 100644
--- a/x86/TargetPrinter.ml
+++ b/x86/TargetPrinter.ml
@@ -541,6 +541,8 @@ module Target(System: SYSTEM):TARGET =
           fprintf oc "	subl	%a, %a\n" ireg32 r1 ireg32 rd
       | Psubq_rr(rd, r1) ->
           fprintf oc "	subq	%a, %a\n" ireg64 r1 ireg64 rd
+      | Psubp_rr(rd, r1) ->
+          fprintf oc "	subq	%a, %a\n" ireg64 r1 ireg64 rd
       | Pimull_rr(rd, r1) ->
           fprintf oc "	imull	%a, %a\n" ireg32 r1 ireg32 rd
       | Pimulq_rr(rd, r1) ->
@@ -842,6 +844,7 @@ module Target(System: SYSTEM):TARGET =
               fprintf oc "%s begin inline assembly\n\t" comment;
               print_inline_asm preg_asm oc (camlstring_of_coqstring txt) sg args res;
               fprintf oc "%s end inline assembly\n" comment
+          | EF_capture -> fprintf oc ""
           | _ ->
               assert false
           end
diff --git a/x86/ValueAOp.v b/x86/ValueAOp.v
index d0b8427a..ef636b90 100644
--- a/x86/ValueAOp.v
+++ b/x86/ValueAOp.v
@@ -13,6 +13,7 @@
 Require Import Coqlib Compopts.
 Require Import AST Integers Floats Values Memory Globalenvs.
 Require Import Op RTL ValueDomain.
+Require Import sflib PointerOp IntPtrRel.
 
 (** Value analysis for x86_64 operators *)
 
@@ -137,6 +138,7 @@ Definition eval_static_operation (op: operation) (vl: list aval): aval :=
   | Oshrluimm n, v1::nil => shrlu v1 (I n)
   | Ororlimm n, v1::nil => rorl v1 (I n)
   | Oleal addr, _ => eval_static_addressing_64 addr vl
+  | Opsub, v1::v2::nil => ptrsub v1 v2
   | Onegf, v1::nil => negf v1
   | Oabsf, v1::nil => absf v1
   | Oaddf, v1::v2::nil => addf v1 v2
@@ -258,9 +260,83 @@ Proof.
   destruct (propagate_float_constants tt); constructor.
   eapply eval_static_addressing_32_sound; eauto.
   eapply eval_static_addressing_64_sound; eauto.
+  unfold ptrsub. rewrite Heqb. eapply ptrsub64_sound; eauto.
+  unfold ptrsub. rewrite Heqb. eapply ptrsub32_sound; eauto.
   apply of_optbool_sound. eapply eval_static_condition_sound; eauto.
   apply select_sound; auto. eapply eval_static_condition_sound; eauto.
 Qed.
 
+Theorem eval_static_condition_join_sound
+  cond vargs m aargs
+  (PCOND: ptr_cond cond = true)
+  (ARGS: list_forall2 (vmatch bc) vargs aargs)
+  :
+  <<MATCH: cmatch (eval_condition_join cond vargs m) (eval_static_condition cond aargs)>>.
+Proof.
+  unfold eval_condition_join. unfold cmpu_join_common, cmplu_join_common.
+  destruct cond; ss; auto with va.
+  - inv ARGS; ss; eauto with va. inv H0; ss; eauto with va.
+    inv H2; ss; eauto with va.
+    unfold ptr_cond in PCOND. ss. dup H. dup H1. des_ifs; inv H; inv H1; ss; try econs.
+    { des_ifs; [|econs]. eapply cmp_different_blocks_none. }
+    { eapply pcmp_none. }
+    { eapply pcmp_none. }
+    { des_ifs; [|econs]. eapply cmp_different_blocks_none. }
+    { rewrite Heq0, Heq. simpl. des_ifs.
+      - eapply cmp_different_blocks_sound.
+      - eapply cmp_different_blocks_none. }
+    { rewrite Heq. econs. }
+    { eapply pcmp_none. }
+    { rewrite Heq, Heq0. simpl. des_ifs.
+      - eapply cmp_different_blocks_sound.
+      - eapply cmp_different_blocks_none. }
+    { rewrite Heq. econs. }
+    { eapply pcmp_sound_64; eauto. }
+  - inv ARGS; ss; eauto with va. inv H0; ss; eauto with va.
+    unfold ptr_cond in PCOND. ss. dup H. des_ifs; inv H; ss; try econs.
+    { des_ifs; [|econs]. eapply cmp_different_blocks_none. }
+    { rewrite Heq0, Heq. simpl. des_ifs.
+      - eapply cmp_different_blocks_sound.
+      - eapply cmp_different_blocks_none. }
+    { rewrite Heq. econs. }
+Qed.
+
+Theorem eval_static_condition_wrapper_sound
+  cond vargs m aargs
+  (ARGS: list_forall2 (vmatch bc) vargs aargs)
+  :
+  <<MATCH: cmatch (eval_condition_wrapper cond vargs m) (eval_static_condition cond aargs)>>.
+Proof.
+  unfold eval_condition_wrapper. des_ifs.
+  - eapply eval_static_condition_join_sound; eauto.
+  - eapply eval_static_condition_sound; eauto.
+Qed.
+
+Theorem eval_static_operation_wrapper_sound
+  op vargs m vres aargs
+  (EVAL: eval_operation_wrapper ge (Vptr sp Ptrofs.zero) op vargs m = Some vres)
+  (ARGS: list_forall2 (vmatch bc) vargs aargs)
+  :
+  <<SOUND: vmatch bc vres (eval_static_operation op aargs)>>.
+Proof.
+  destruct (ptr_op op) eqn:PTRBIN; cycle 1.
+  { rewrite eval_operation_no_ptr_op in EVAL; eauto. eapply eval_static_operation_sound; eauto. }
+  unfold eval_operation_wrapper in EVAL. rewrite PTRBIN in EVAL. destruct op; ss.
+  (* psub *)
+  - inv ARGS; ss; eauto with va. inv H0; ss; eauto with va. inv H2; ss; eauto with va.
+    dup H. dup H1. unfold ptrsub. destruct Archi.ptr64 eqn:SF.
+    + inv H; inv H1; simpl in EVAL; inv EVAL; try rewrite SF in *;
+        simpl; try econs; try destruct (eq_block b b1); try econs;
+        try (by (exploit ptrsub64_join_sound_r; eauto)); exploit ptrsub64_join_sound_l; eauto.
+    + inv H; inv H1; simpl in EVAL; inv EVAL; try rewrite SF in *;
+        simpl; try econs; try destruct (eq_block b b1); try econs;
+        try (by (exploit ptrsub32_join_sound_r; eauto)); exploit ptrsub32_join_sound_l; eauto.
+  - inv EVAL. eapply of_optbool_sound. eapply eval_static_condition_join_sound; eauto.
+  - inv ARGS; ss; eauto with va. inv H0; ss; eauto with va.
+    inv EVAL. eapply select_sound; eauto.
+    eapply eval_static_condition_join_sound; eauto.
+    Unshelve. all: eauto.
+Qed.
+
 End SOUNDNESS.
 
diff --git a/x86/ValueAOpSSA.v b/x86/ValueAOpSSA.v
deleted file mode 100644
index d67722d1..00000000
--- a/x86/ValueAOpSSA.v
+++ /dev/null
@@ -1,269 +0,0 @@
-(* *********************************************************************)
-(*                                                                     *)
-(*              The Compcert verified compiler                         *)
-(*                                                                     *)
-(*                Xavier Leroy, INRIA Paris                            *)
-(*                                                                     *)
-(*  Copyright Institut National de Recherche en Informatique et en     *)
-(*  Automatique.  All rights reserved.  This file is distributed       *)
-(*  under the terms of the INRIA Non-Commercial License Agreement.     *)
-(*                                                                     *)
-(* *********************************************************************)
-
-Require Import Coqlib Compopts.
-Require Import AST Integers Floats Values Memory Globalenvs.
-Require Import Op SSA ValueDomainSSA.
-
-(** Value analysis for x86_64 operators *)
-
-Definition eval_static_condition (cond: condition) (vl: list aval): abool :=
-  match cond, vl with
-  | Ccomp c, v1 :: v2 :: nil => cmp_bool c v1 v2
-  | Ccompu c, v1 :: v2 :: nil => cmpu_bool c v1 v2
-  | Ccompimm c n, v1 :: nil => cmp_bool c v1 (I n)
-  | Ccompuimm c n, v1 :: nil => cmpu_bool c v1 (I n)
-  | Ccompl c, v1 :: v2 :: nil => cmpl_bool c v1 v2
-  | Ccomplu c, v1 :: v2 :: nil => cmplu_bool c v1 v2
-  | Ccomplimm c n, v1 :: nil => cmpl_bool c v1 (L n)
-  | Ccompluimm c n, v1 :: nil => cmplu_bool c v1 (L n)
-  | Ccompf c, v1 :: v2 :: nil => cmpf_bool c v1 v2
-  | Cnotcompf c, v1 :: v2 :: nil => cnot (cmpf_bool c v1 v2)
-  | Ccompfs c, v1 :: v2 :: nil => cmpfs_bool c v1 v2
-  | Cnotcompfs c, v1 :: v2 :: nil => cnot (cmpfs_bool c v1 v2)
-  | Cmaskzero n, v1 :: nil => maskzero v1 n
-  | Cmasknotzero n, v1 :: nil => cnot (maskzero v1 n)
-  | _, _ => Bnone
-  end.
-
-Definition eval_static_addressing_32 (addr: addressing) (vl: list aval): aval :=
-  match addr, vl with
-  | Aindexed n, v1::nil => add v1 (I (Int.repr n))
-  | Aindexed2 n, v1::v2::nil => add (add v1 v2) (I (Int.repr n))
-  | Ascaled sc ofs, v1::nil => add (mul v1 (I (Int.repr sc))) (I (Int.repr ofs))
-  | Aindexed2scaled sc ofs, v1::v2::nil => add v1 (add (mul v2 (I (Int.repr sc))) (I (Int.repr ofs)))
-  | Aglobal s ofs, nil => Ptr (Gl s ofs)
-  | Abased s ofs, v1::nil => add (Ptr (Gl s ofs)) v1
-  | Abasedscaled sc s ofs, v1::nil => add (Ptr (Gl s ofs)) (mul v1 (I (Int.repr sc)))
-  | Ainstack ofs, nil => Vtop  (* Ptr(Stk ofs) *)
-  | _, _ => Vbot
-  end.
-
-Definition eval_static_addressing_64 (addr: addressing) (vl: list aval): aval :=
-  match addr, vl with
-  | Aindexed n, v1::nil => addl v1 (L (Int64.repr n))
-  | Aindexed2 n, v1::v2::nil => addl (addl v1 v2) (L (Int64.repr n))
-  | Ascaled sc ofs, v1::nil => addl (mull v1 (L (Int64.repr sc))) (L (Int64.repr ofs))
-  | Aindexed2scaled sc ofs, v1::v2::nil => addl v1 (addl (mull v2 (L (Int64.repr sc))) (L (Int64.repr ofs)))
-  | Aglobal s ofs, nil => Ptr (Gl s ofs)
-  | Abased s ofs, v1::nil => addl (Ptr (Gl s ofs)) v1
-  | Abasedscaled sc s ofs, v1::nil => addl (Ptr (Gl s ofs)) (mull v1 (L (Int64.repr sc)))
-  | Ainstack ofs, nil => Vtop (* Ptr(Stk ofs) *)
-  | _, _ => Vbot
-  end.
-
-Definition eval_static_addressing (addr: addressing) (vl: list aval): aval :=
-  if Archi.ptr64
-  then eval_static_addressing_64 addr vl
-  else eval_static_addressing_32 addr vl.
-
-Definition eval_static_operation (op: operation) (vl: list aval): aval :=
-  match op, vl with
-  | Omove, v1::nil => v1
-  | Ointconst n, nil => I n
-  | Olongconst n, nil => L n
-  | Ofloatconst n, nil => if propagate_float_constants tt then F n else ntop
-  | Osingleconst n, nil => if propagate_float_constants tt then FS n else ntop
-  | Oindirectsymbol id, nil => Ifptr (Gl id Ptrofs.zero)
-  | Ocast8signed, v1 :: nil => sign_ext 8 v1
-  | Ocast8unsigned, v1 :: nil => zero_ext 8 v1
-  | Ocast16signed, v1 :: nil => sign_ext 16 v1
-  | Ocast16unsigned, v1 :: nil => zero_ext 16 v1
-  | Oneg, v1::nil => neg v1
-  | Osub, v1::v2::nil => sub v1 v2
-  | Omul, v1::v2::nil => mul v1 v2
-  | Omulimm n, v1::nil => mul v1 (I n)
-  | Omulhs, v1::v2::nil => mulhs v1 v2
-  | Omulhu, v1::v2::nil => mulhu v1 v2
-  | Odiv, v1::v2::nil => divs v1 v2
-  | Odivu, v1::v2::nil => divu v1 v2
-  | Omod, v1::v2::nil => mods v1 v2
-  | Omodu, v1::v2::nil => modu v1 v2
-  | Oand, v1::v2::nil => and v1 v2
-  | Oandimm n, v1::nil => and v1 (I n)
-  | Oor, v1::v2::nil => or v1 v2
-  | Oorimm n, v1::nil => or v1 (I n)
-  | Oxor, v1::v2::nil => xor v1 v2
-  | Oxorimm n, v1::nil => xor v1 (I n)
-  | Onot, v1::nil => notint v1
-  | Oshl, v1::v2::nil => shl v1 v2
-  | Oshlimm n, v1::nil => shl v1 (I n)
-  | Oshr, v1::v2::nil => shr v1 v2
-  | Oshrimm n, v1::nil => shr v1 (I n)
-  | Oshrximm n, v1::nil => shrx v1 (I n)
-  | Oshru, v1::v2::nil => shru v1 v2
-  | Oshruimm n, v1::nil => shru v1 (I n)
-  | Ororimm n, v1::nil => ror v1 (I n)
-  | Oshldimm n, v1::v2::nil => or (shl v1 (I n)) (shru v2 (I (Int.sub Int.iwordsize n)))
-  | Olea addr, _ => eval_static_addressing_32 addr vl
-  | Omakelong, v1::v2::nil => longofwords v1 v2
-  | Olowlong, v1::nil => loword v1
-  | Ohighlong, v1::nil => hiword v1
-  | Ocast32signed, v1::nil => longofint v1
-  | Ocast32unsigned, v1::nil => longofintu v1
-  | Onegl, v1::nil => negl v1
-  | Oaddlimm n, v1::nil => addl v1 (L n)
-  | Osubl, v1::v2::nil => subl v1 v2
-  | Omull, v1::v2::nil => mull v1 v2
-  | Omullimm n, v1::nil => mull v1 (L n)
-  | Omullhs, v1::v2::nil => mullhs v1 v2
-  | Omullhu, v1::v2::nil => mullhu v1 v2
-  | Odivl, v1::v2::nil => divls v1 v2
-  | Odivlu, v1::v2::nil => divlu v1 v2
-  | Omodl, v1::v2::nil => modls v1 v2
-  | Omodlu, v1::v2::nil => modlu v1 v2
-  | Oandl, v1::v2::nil => andl v1 v2
-  | Oandlimm n, v1::nil => andl v1 (L n)
-  | Oorl, v1::v2::nil => orl v1 v2
-  | Oorlimm n, v1::nil => orl v1 (L n)
-  | Oxorl, v1::v2::nil => xorl v1 v2
-  | Oxorlimm n, v1::nil => xorl v1 (L n)
-  | Onotl, v1::nil => notl v1
-  | Oshll, v1::v2::nil => shll v1 v2
-  | Oshllimm n, v1::nil => shll v1 (I n)
-  | Oshrl, v1::v2::nil => shrl v1 v2
-  | Oshrlimm n, v1::nil => shrl v1 (I n)
-  | Oshrxlimm n, v1::nil => shrxl v1 (I n)
-  | Oshrlu, v1::v2::nil => shrlu v1 v2
-  | Oshrluimm n, v1::nil => shrlu v1 (I n)
-  | Ororlimm n, v1::nil => rorl v1 (I n)
-  | Oleal addr, _ => eval_static_addressing_64 addr vl
-  | Onegf, v1::nil => negf v1
-  | Oabsf, v1::nil => absf v1
-  | Oaddf, v1::v2::nil => addf v1 v2
-  | Osubf, v1::v2::nil => subf v1 v2
-  | Omulf, v1::v2::nil => mulf v1 v2
-  | Odivf, v1::v2::nil => divf v1 v2
-  | Onegfs, v1::nil => negfs v1
-  | Oabsfs, v1::nil => absfs v1
-  | Oaddfs, v1::v2::nil => addfs v1 v2
-  | Osubfs, v1::v2::nil => subfs v1 v2
-  | Omulfs, v1::v2::nil => mulfs v1 v2
-  | Odivfs, v1::v2::nil => divfs v1 v2
-  | Osingleoffloat, v1::nil => singleoffloat v1
-  | Ofloatofsingle, v1::nil => floatofsingle v1
-  | Ointoffloat, v1::nil => intoffloat v1
-  | Ofloatofint, v1::nil => floatofint v1
-  | Ointofsingle, v1::nil => intofsingle v1
-  | Osingleofint, v1::nil => singleofint v1
-  | Olongoffloat, v1::nil => longoffloat v1
-  | Ofloatoflong, v1::nil => floatoflong v1
-  | Olongofsingle, v1::nil => longofsingle v1
-  | Osingleoflong, v1::nil => singleoflong v1
-  | Ocmp c, _ => of_optbool (eval_static_condition c vl)
-  | Osel c ty, v1::v2::vl => select (eval_static_condition c vl) v1 v2
-  | _, _ => Vbot
-  end.
-
-Section SOUNDNESS.
-
-Variable bc: block_classification.
-Variable ge: genv. 
-Hypothesis GENV: genv_match bc ge.
-Variable sp: block.
-Hypothesis STACK: bc sp <> BCinvalid.
-
-Theorem eval_static_condition_sound:
-  forall cond vargs m aargs,
-  list_forall2 (vmatch bc) vargs aargs ->
-  cmatch (eval_condition cond vargs m) (eval_static_condition cond aargs).
-Proof.
-  intros until aargs; intros VM. inv VM.
-  destruct cond; auto with va.
-  inv H0.
-  destruct cond; simpl; eauto with va.
-  inv H2.
-  destruct cond; simpl; eauto with va.
-  destruct cond; auto with va.
-Qed.
-
-Lemma symbol_address_sound:
-  forall id ofs,
-  vmatch bc (Genv.symbol_address ge id ofs) (Ptr (Gl id ofs)).
-Proof.
-  intros; apply symbol_address_sound; apply GENV.
-Qed.
-
-Lemma symbol_address_sound_2:
-  forall id ofs,
-  vmatch bc (Genv.symbol_address ge id ofs) (Ifptr (Gl id ofs)).
-Proof.
-  intros. unfold Genv.symbol_address. destruct (Genv.find_symbol ge id) as [b|] eqn:F.
-  constructor. constructor. apply GENV; auto.
-  constructor.
-Qed.
-
-Hint Resolve symbol_address_sound symbol_address_sound_2: va.
-
-Ltac InvHyps :=
-  match goal with
-  | [H: None = Some _ |- _ ] => discriminate
-  | [H: Some _ = Some _ |- _] => inv H
-  | [H1: match ?vl with nil => _ | _ :: _ => _ end = Some _ ,
-     H2: list_forall2 _ ?vl _ |- _ ] => inv H2; InvHyps
-  | [H: (if Archi.ptr64 then _ else _) = Some _ |- _] => destruct Archi.ptr64 eqn:?; InvHyps
-  | _ => idtac
-  end.
-
-Theorem eval_static_addressing_32_sound:
-  forall addr vargs vres aargs,
-  eval_addressing32 ge (Vptr sp Ptrofs.zero) addr vargs = Some vres ->
-  list_forall2 (vmatch bc) vargs aargs ->
-  vmatch bc vres (eval_static_addressing_32 addr aargs).
-Proof.
-  unfold eval_addressing32, eval_static_addressing_32; intros;
-  destruct addr; InvHyps; eauto with va.
-  rewrite Ptrofs.add_zero_l; eauto with va.
-  constructor; auto.
-  constructor; auto.
-Qed.
-
-Theorem eval_static_addressing_64_sound:
-  forall addr vargs vres aargs,
-  eval_addressing64 ge (Vptr sp Ptrofs.zero) addr vargs = Some vres ->
-  list_forall2 (vmatch bc) vargs aargs ->
-  vmatch bc vres (eval_static_addressing_64 addr aargs).
-Proof.
-  unfold eval_addressing64, eval_static_addressing_64; intros;
-  destruct addr; InvHyps; eauto with va.
-  rewrite Ptrofs.add_zero_l; eauto with va.
-  constructor. constructor. auto.
-Qed.
-
-Theorem eval_static_addressing_sound:
-  forall addr vargs vres aargs,
-  eval_addressing ge (Vptr sp Ptrofs.zero) addr vargs = Some vres ->
-  list_forall2 (vmatch bc) vargs aargs ->
-  vmatch bc vres (eval_static_addressing addr aargs).
-Proof.
-  unfold eval_addressing, eval_static_addressing; intros.
-  destruct Archi.ptr64; eauto using eval_static_addressing_32_sound, eval_static_addressing_64_sound.
-Qed.
-
-Theorem eval_static_operation_sound:
-  forall op vargs m vres aargs,
-  eval_operation ge (Vptr sp Ptrofs.zero) op vargs m = Some vres ->
-  list_forall2 (vmatch bc) vargs aargs ->
-  vmatch bc vres (eval_static_operation op aargs).
-Proof.
-  unfold eval_operation, eval_static_operation; intros;
-  destruct op; InvHyps; eauto with va.
-  destruct (propagate_float_constants tt); constructor.
-  destruct (propagate_float_constants tt); constructor.
-  eapply eval_static_addressing_32_sound; eauto.
-  eapply eval_static_addressing_64_sound; eauto.
-  apply of_optbool_sound. eapply eval_static_condition_sound; eauto.
-  apply select_sound; auto. eapply eval_static_condition_sound; eauto.
-Qed.
-
-End SOUNDNESS.
-
